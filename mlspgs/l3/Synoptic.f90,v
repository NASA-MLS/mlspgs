head	1.41;
access;
symbols
	v5-02-NRT-19:1.41
	v6-00:1.41
	v5-02-NRT-18:1.41
	v5-02:1.41
	v5-01-NRT-17:1.41
	v5-01-NRT-16:1.41
	v5-01-NRT-15:1.41
	v5-01-NRT-14:1.41
	neuralnetworks-1-0:1.41.0.14
	cfm-single-freq-0-1:1.41.0.12
	v5-01:1.41
	v5-00:1.41
	v4-23-TA133:1.41.0.10
	mus-emls-1-70:1.41.0.8
	rel-1-0-englocks-work:1.41.0.6
	VUMLS1-00:1.41
	VPL1-00:1.41
	V4-22-NRT-08:1.41
	VAM1-00:1.41
	V4-21:1.41.0.4
	V4-13:1.41
	V4-12:1.41
	V4-11:1.41
	V4-10:1.41
	V3-43:1.41
	M4-00:1.41
	V3-41:1.41
	V3-40-PlusGM57:1.41.0.2
	V2-24-NRT-04:1.40
	V3-33:1.41
	V2-24:1.40
	V3-31:1.41
	V3-30-NRT-05:1.41
	cfm-01-00:1.41
	V3-30:1.41
	V3-20:1.41
	V3-10:1.41
	V2-23-NRT-02:1.40
	V2-23:1.40
	V2-22-NRT-01:1.40
	V2-22:1.40
	V2-21:1.40
	V2-20:1.40
	V2-11:1.40
	V2-10:1.40
	V2-00:1.40
	V1-51:1.37
	V1-50:1.37
	V1-45:1.36
	V1-44:1.36
	V1-43:1.35
	V1-42:1.31
	V1-41:1.31
	V1-32:1.30
	V1-40:1.31
	V1-31:1.30
	V1-30:1.30
	V1-13:1.28
	V1-12:1.28
	V1-11:1.28
	V1-10:1.28
	newfwm-feb03:1.28.0.2
	V1-04:1.26
	V1-03:1.26
	V1-02:1.26
	V1-00:1.23
	newfwm-sep01:1.15.0.2
	V0-7:1.15
	V0-5-Level2:1.13
	V0-5-SIPS:1.13;
locks; strict;
comment	@# @;


1.41
date	2008.12.02.23.17.55;	author pwagner;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.24.19.14.30;	author cvuu;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.23.19.07.39;	author pwagner;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.30.17.53.10;	author cvuu;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.22.16.55.47;	author cvuu;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.02.20.07.28;	author ybj;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.13.23.50.52;	author ybj;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.06.13.16.46;	author cvuu;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.04.15.33.15;	author cvuu;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.07.21.43.18;	author cvuu;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.30.18.15.48;	author pwagner;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.22.02.59.22;	author jdone;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.06.19.51.31;	author pwagner;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.08.16.23.47;	author ybj;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.30.20.05.21;	author jdone;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.11.00.53.57;	author jdone;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.10.21.30.33;	author jdone;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.01.21.57.13;	author jdone;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.27.22.45.17;	author jdone;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.27.21.35.14;	author jdone;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.20.22.30.33;	author ybj;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.20.22.13.54;	author ybj;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.27.20.38.31;	author ybj;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.27.20.07.14;	author ybj;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.06.18.45.37;	author nakamura;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.13.19.28.03;	author ybj;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.13.16.42.20;	author ybj;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.12.16.04.41;	author ybj;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.11.18.29.22;	author ybj;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.08.00.53.15;	author ybj;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.00.37.17;	author ybj;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.12.15;	author ybj;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.05.19.58.59;	author ybj;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.03.01.38.02;	author ybj;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.03.00.45.44;	author ybj;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.03.00.20.07;	author ybj;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.19.41.57;	author ybj;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.28.19.27.03;	author ybj;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.28.17.15.06;	author ybj;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.27.20.51.28;	author ybj;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Change to type of arg in intrinisic to avoid mixing types forbidden by a compiler
@
text
@
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!===============
MODULE Synoptic
!===============

  Use DailyMapModule, ONLY: Init, ClearMemory, CordTransform, & 
       & FFSM, FFSMA, FFSMD, &
       & Reconstruct, Diagnostics, DataGenerate, DataGeneratePrec, &
       & CopyPrec2Data
  USE L3CF, ONLY: L3CFDef_T, L3CFProd_T
  USE L2GPData, ONLY: L2GPData_T, DestroyL2GPDatabase
  USE MLSCommon, ONLY: r8, r4
  USE MLSL3Common, ONLY: DATE_LEN, maxWindow
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_ALLOCATE, & 
       & MLSMSG_DEALLOCATE, MLSMSG_Warning
  USE Dump_0, only: DUMP

  Implicit none
  
  private
  public :: DailyCoreProcessing, ExpandArray
  PRIVATE :: ID, ModuleName, my_sortp
  
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       "$Id: Synoptic.f90,v 1.40 2006/05/24 19:14:30 cvuu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Synoptic.f90,v $"
  !----------------------------------------------------------

  ! Contents:
  
  ! Subroutines -- DailyCoreProcessing
  !                
  ! This subroutine will process one product for all the input days data
  ! Remarks:  This module contains subroutines related to MLS L3 Daily Map 
  ! Processing 

  interface my_sortp !Becuase we sometimes call with r4, other times with r8
     module procedure my_sortp_r4
     module procedure my_sortp_r8
  end interface
  
CONTAINS
  
  !-------------------------------------------------------------------------
  SUBROUTINE DailyCoreProcessing(cfDef, cfProd, pcf, l2Days, l2gp, & 
       & avgPeriod, l3sp, l3dm, dmA, dmD, l3r, residA, residD, & 
       & flags)
  !-------------------------------------------------------------------------
  USE L2Interface, ONLY: ReadL2GPProd, SetupL2GPProd
  USE L3DMData, ONLY: L3DMData_T, AllocateL3DM
  USE L3SPData, ONLY: L3SPData_T, AllocateL3SP
  USE OpenInit, ONLY: PCFData_T 
  USE OutputClose, ONLY: OutputFlags_T
  USE SDPToolkit, ONLY: PI
     
     ! Brief description of program
     ! This is the main program to run the Core processing.

     ! Parameters

     ! Variable definitions

    TYPE( L3CFDef_T ) :: cfDef
    TYPE( PCFData_T ) :: pcf
    TYPE( L3CFProd_T ) :: cfProd
    TYPE( OutputFlags_T ) :: flags
    TYPE( L2GPData_T ), POINTER :: l2gp(:), l3r(:), residA(:), residD(:), &
         & l3r_temp(:), residA_temp(:), residD_temp(:)
    TYPE( L3DMData_T ), POINTER :: l3dm(:), dmA(:), dmD(:)
    TYPE( L3SPData_T ), POINTER :: l3sp(:), l3spPrec(:)
     
    CHARACTER (LEN=480) :: msr

    INTEGER :: mis_Days_temp(maxWindow)
     
    REAL (r8), DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: delTad
     
    REAL (r8), POINTER, DIMENSION(:, :, :) ::  & 
         & alons(:, :, :), alats(:, :, :), dlons(:, :, :), dlats(:, :, :), &
         & atimes(:, :, :), dtimes(:, :, :), afields(:, :, :), & 
         & dfields(:, :, :), aprec(:, :, :), dprec(:, :, :)
     
    REAL (r8), POINTER, DIMENSION(:) :: startTime(:), endTime(:), & 
         & l3Result(:), &  ! returned reconstructed result
         & sortTemp(:)     ! hold sort array temporary
     
    REAL(r8), POINTER :: avgPeriod(:)
     
    REAL(r8) :: lonD0_in, lonA0_in
    REAL :: tau0, l3ret, avg
        
    INTEGER, DIMENSION(l2gp(1)%nLevels) :: perMisPoints
    INTEGER, DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: anlats, dnlats 

    INTEGER, POINTER, DIMENSION(:) :: pt(:), nc(:), nca(:), ncd(:)

    INTEGER ::  error, l2Days, nlev, nlev_temp, nwv, numDays, & 
         & numSwaths, rDays, pEndIndex, pStartIndex, &
         & mis_l2Days_temp, i, j, k, iP, kP, iD, iL, n,m, &
	 & totalIndex=0

     !*** Initilize variables
 
    nwv = cfProd%nWave

    nlev = 0
    DO j = 1, l2gp(1)%nLevels
       IF( l2gp(1)%pressures(j) >= cfProd%l3presLvl(1) .AND. &
            & l2gp(1)%pressures(j) <= cfProd%l3presLvl(2) ) THEN
          nlev = nlev + 1
          IF (nlev == 1) pStartIndex = j 
          pEndIndex = j 
       ENDIF
    ENDDO
     
    IF (nlev == 0) THEN
       nlev_temp = 1
       nlev = 1
       pStartIndex = 1
       pEndIndex = 1
    ELSE
       nlev_temp = -1
    END IF
     
    totalIndex = pEndIndex - pStartIndex + 1 

    !*** Initilize POINTERS
     
    IF (cfProd%mode == 'all' .or. cfProd%mode == 'ado') THEN
       numSwaths = 3
    ELSE
       numSwaths = 1
    ENDIF
     
    ALLOCATE( l3sp(numSwaths), STAT=error )
    IF ( error /= 0 ) THEN
       msr = MLSMSG_Allocate // ' l3sp array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
     
    ALLOCATE( l3spPrec(numSwaths), STAT=error )
    IF ( error /= 0 ) THEN
       msr = MLSMSG_Allocate // ' l3spPrec array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
     
    IF (cfProd%mode == 'all' .or. cfProd%mode == 'ado') THEN
       l3sp(1)%name = cfProd%l3prodNameD
       l3sp(2)%name = TRIM(cfProd%l3prodNameD) // 'Ascending'
       l3sp(3)%name = TRIM(cfProd%l3prodNameD) // 'Descending'
    ELSE
       l3sp(1)%name = TRIM(cfProd%l3prodNameD)
    ENDIF
     
    l3sp%startTime = l2gp(1)%time(1)
     
    if (l2Days .GT. 0) then 
       l3sp%endTime = l2gp(l2Days)%time(l2gp(l2Days)%nTimes)
    else
       l3sp%endTime = l3sp%startTime
    endif
    
    DO j = 1, numSwaths
        
       CALL AllocateL3SP( nlev, cfProd%nLats, nwv, l3sp(j) )
       CALL AllocateL3SP( nlev, cfProd%nLats, nwv, l3spPrec(j) )
       l3sp(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
       l3sp(j)%latitude = cfProd%latGridMap(:l3sp(j)%nLats)
       l3sp(j)%waveNumber = 0.0
       l3sp(j)%frequency = 0.0
       l3sp(j)%l3spRelValue = -999.99 
       l3sp(j)%l3spRelPrecision = -999.99 
       l3sp(j)%l3spImgValue = -999.99 
       l3sp(j)%l3spImgPrecision = -999.99 
        
       l3spPrec(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
       l3spPrec(j)%latitude = cfProd%latGridMap(:l3sp(j)%nLats)
       l3spPrec(j)%waveNumber = 0.0
       l3spPrec(j)%frequency = 0.0
       l3spPrec(j)%l3spRelValue = -999.99 
       l3spPrec(j)%l3spRelPrecision = -999.99 
       l3spPrec(j)%l3spImgValue = -999.99 
       l3spPrec(j)%l3spImgPrecision = -999.99 
        
    ENDDO
     
    numDays = cfProd%nDays

    !!      Initialize Daily Map & Diagnostic

    if (numDays .gt. 0) then
       IF (cfProd%mode == 'com') THEN        
          ALLOCATE( l3dm(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l3dm array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          l3dm%name = TRIM(cfProd%l3prodNameD)
          DO j = 1, numDays
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, l3dm(j) )
             l3dm(j)%time      = cfProd%timeD(j)
             l3dm(j)%pressure  = l2gp(1)%pressures(pStartIndex:pEndIndex)
       	     l3dm(j)%latitude  = cfProd%latGridMap(:l3dm(j)%nLats)
             l3dm(j)%longitude = cfProd%longGrid(:l3dm(j)%nLons)
             l3dm(j)%l3dmValue = -999.99 
             l3dm(j)%l3dmPrecision = -999.99 
             l3dm(j)%gRss  = -999.99 
             l3dm(j)%perMisPoints  = 0 
             do n=1,cfDef%N
               do m=1,nlev
                  l3dm(j)%latRss(n,m) = 0.0
                  l3dm(j)%maxDiff(n,m) = 0.0
                  l3dm(j)%maxDiffTime(n,m)  = 0.0
               end do
             end do
          ENDDO

       ELSE IF (cfProd%mode == 'asc') THEN        
          ALLOCATE( dmA(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmA array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          dmA%name  = TRIM(cfProd%l3prodNameD) // 'Ascending'
          DO j = 1, numDays
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmA(j) )
             dmA(j)%time       = cfProd%timeD(j)
             dmA(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmA(j)%latitude   = cfProd%latGridMap(:dmA(j)%nLats)
             dmA(j)%longitude  = cfProd%longGrid(:dmA(j)%nLons)
             dmA(j)%l3dmValue  = -999.99 
             dmA(j)%l3dmPrecision  = -999.99 
             dmA(j)%gRss  = -999.99 
             dmA(j)%perMisPoints  = 0 
             do n=1,cfDef%N
               do m=1,nlev
                  dmA(j)%latRss(n,m)  = 0.0
                  dmA(j)%maxDiff(n,m)  = 0.0
                  dmA(j)%maxDiffTime(n,m)  = 0.0
               end do
             end do
          ENDDO

       ELSE IF (cfProd%mode == 'dsc') THEN        
          ALLOCATE( dmD(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmD array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          dmD%name  = TRIM(cfProd%l3prodNameD) // 'Descending'
          DO j = 1, numDays
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmD(j) )
             dmD(j)%time       = cfProd%timeD(j)
             dmD(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmD(j)%latitude   = cfProd%latGridMap(:dmD(j)%nLats)
             dmD(j)%longitude  = cfProd%longGrid(:dmD(j)%nLons)
             dmD(j)%l3dmValue  = -999.99 
             dmD(j)%l3dmPrecision  = -999.99 
             dmD(j)%gRss  = -999.99 
             dmD(j)%perMisPoints  = 0 
             do n=1,cfDef%N
               do m=1,nlev
                 dmD(j)%latRss(n,m)  = 0.0
                 dmD(j)%maxDiff(n,m)  = 0.0
                 dmD(j)%maxDiffTime(n,m) = 0.0
               end do
             end do
          ENDDO

       ELSE IF (cfProd%mode == 'ado') THEN        
          ALLOCATE( dmA(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmA array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          ALLOCATE( dmD(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmD array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          dmA%name  = TRIM(cfProd%l3prodNameD) // 'Ascending'
          dmD%name  = TRIM(cfProd%l3prodNameD) // 'Descending'

          DO j = 1, numDays
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmD(j) )
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmA(j) )
             dmA(j)%time       = cfProd%timeD(j)
             dmD(j)%time       = cfProd%timeD(j)
             dmA(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmD(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmA(j)%latitude   = cfProd%latGridMap(:dmA(j)%nLats)
             dmD(j)%latitude   = cfProd%latGridMap(:dmD(j)%nLats)
             dmA(j)%longitude  = cfProd%longGrid(:dmA(j)%nLons)
             dmD(j)%longitude  = cfProd%longGrid(:dmD(j)%nLons)
             dmA(j)%l3dmValue  = -999.99 
             dmD(j)%l3dmValue  = -999.99 
             dmA(j)%l3dmPrecision  = -999.99 
             dmD(j)%l3dmPrecision  = -999.99 
             dmA(j)%gRss  = -999.99 
             dmA(j)%perMisPoints  = 0 
             dmD(j)%gRss  = -999.99 
             dmD(j)%perMisPoints  = 0 
             do n=1,cfDef%N
               do m=1,nlev
                  dmA(j)%latRss(n,m)  = 0.0
                  dmA(j)%maxDiff(n,m)  = 0.0
                  dmA(j)%maxDiffTime(n,m)  = 0.0
                  dmD(j)%latRss(n,m)  = 0.0
                  dmD(j)%maxDiff(n,m)  = 0.0
                  dmD(j)%maxDiffTime(n,m)  = 0.0
               end do
             end do
          ENDDO

       ELSE IF (cfProd%mode == 'all') THEN        
          ALLOCATE( l3dm(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l3dm array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          ALLOCATE( dmA(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmA array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          ALLOCATE( dmD(numDays), STAT=error )
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dmD array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          l3dm%name = TRIM(cfProd%l3prodNameD)
          dmA%name  = TRIM(cfProd%l3prodNameD) // 'Ascending'
          dmD%name  = TRIM(cfProd%l3prodNameD) // 'Descending'
          DO j = 1, numDays
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, l3dm(j) )
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmD(j) )
             CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmA(j) )
             l3dm(j)%time      = cfProd%timeD(j)
             dmA(j)%time       = cfProd%timeD(j)
             dmD(j)%time       = cfProd%timeD(j)
             l3dm(j)%pressure  = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmA(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
             dmD(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
       	     l3dm(j)%latitude  = cfProd%latGridMap(:l3dm(j)%nLats)
             dmA(j)%latitude   = cfProd%latGridMap(:dmA(j)%nLats)
             dmD(j)%latitude   = cfProd%latGridMap(:dmD(j)%nLats)
             l3dm(j)%longitude = cfProd%longGrid(:l3dm(j)%nLons)
             dmA(j)%longitude  = cfProd%longGrid(:dmA(j)%nLons)
             dmD(j)%longitude  = cfProd%longGrid(:dmD(j)%nLons)
             l3dm(j)%l3dmValue = -999.99 
             dmA(j)%l3dmValue  = -999.99 
             dmD(j)%l3dmValue  = -999.99 
             l3dm(j)%l3dmPrecision = -999.99 
             dmA(j)%l3dmPrecision  = -999.99 
             dmD(j)%l3dmPrecision  = -999.99 
             l3dm(j)%gRss  = -999.99 
             l3dm(j)%perMisPoints  = 0 
             dmA(j)%gRss  = -999.99 
             dmA(j)%perMisPoints  = 0 
             dmD(j)%gRss  = -999.99 
             dmD(j)%perMisPoints  = 0 
             do n=1,cfDef%N
               do m=1,nlev
                  l3dm(j)%latRss(n,m)  = 0.0
                  l3dm(j)%maxDiff(n,m)  = 0.0
                  l3dm(j)%maxDiffTime(n,m)  = 0.0
                  dmA(j)%latRss(n,m)  = 0.0
                  dmA(j)%maxDiff(n,m)  = 0.0
                  dmA(j)%maxDiffTime(n,m)  = 0.0
                  dmD(j)%latRss(n,m)  = 0.0
                  dmD(j)%maxDiff(n,m)  = 0.0
                  dmD(j)%maxDiffTime(n,m)  = 0.0
               end do
             end do
          ENDDO
       ENDIF
    ENDIF
    
    if ( numDays .gt. 0) then
       ALLOCATE( nc(numDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' nc array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ALLOCATE( nca(numDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' nca array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ALLOCATE( ncd(numDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' ncd array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ALLOCATE( startTime(numDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' startTime array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ALLOCATE( endTime(numDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' endTime array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
    endif
 
    !!      Initialize Daily Map Residues
  
    IF (cfProd%mode == 'com') THEN
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r_temp)
       CALL SetupL2GPProd(rDays, totalIndex, l3r_temp, l3r)
       l3r%name = TRIM(cfProd%l3prodNameD) // 'Residuals'
       DO j = 1, rDays
           l3r(j)%pressures = l3r_temp(j)%pressures(pStartIndex:pEndIndex)
           l3r(j)%l2gpValue = -999.99 
           l3r(j)%l2gpPrecision = l3r_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:)
           l3r_temp(j)%l2gpValue    = -999.99 
           DO k = 1, l3r(j)%nTimes
             if(l3r(j)%time(k) > 0) then
               startTime(j) = l3r(j)%time(k)
               exit
             endif
           ENDDO
           DO k = l3r(j)%nTimes, 1, -1
             if(l3r(j)%time(k) > 0) then
               endTime(j) = l3r(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO

    ELSE IF (cfProd%mode == 'asc') THEN
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residA_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp, residA)
       residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
       DO j = 1, rDays
           residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
           residA(j)%l2gpValue = -999.99
           residA(j)%l2gpPrecision = residA_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           residA_temp(j)%l2gpValue = -999.99
           DO k = 1, residA(j)%nTimes
             if(residA(j)%time(k) > 0) then
               startTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residA(j)%nTimes, 1, -1
             if(residA(j)%time(k) > 0) then
               endTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO

    ELSE IF (cfProd%mode == 'dsc') THEN
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
           & pcf%l3StartDay, & 
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residD_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp, residD)
       residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
       DO j = 1, rDays
           residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
           residD(j)%l2gpValue      = -999.99
           residD_temp(j)%l2gpValue = -999.99
           residD(j)%l2gpPrecision = residD_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           DO k = 1, residD(j)%nTimes
             if(residD(j)%time(k) > 0) then
               startTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residD(j)%nTimes, 1, -1
             if(residD(j)%time(k) > 0) then
               endTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO
 
    ELSE IF (cfProd%mode == 'ado') THEN
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residA_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp, residA)
       residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
       
       DO j = 1, rDays
           residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
           residA(j)%l2gpValue = -999.99
           residA_temp(j)%l2gpValue = -999.99
           residA(j)%l2gpPrecision = residA_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           DO k = 1, residA(j)%nTimes
             if(residA(j)%time(k) > 0) then
               startTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residA(j)%nTimes, 1, -1
             if(residA(j)%time(k) > 0) then
               endTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO
       rDays = 0
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
           & pcf%l3StartDay, & 
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residD_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp, residD)
       residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
       DO j = 1, rDays
           residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
           residD(j)%l2gpValue      = -999.99
           residD_temp(j)%l2gpValue = -999.99
           residD(j)%l2gpPrecision = residD_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           DO k = 1, residD(j)%nTimes
             if(residD(j)%time(k) > 0) then
               startTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residD(j)%nTimes, 1, -1
             if(residD(j)%time(k) > 0) then
               endTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO

    ELSE IF (cfProd%mode == 'all') THEN
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r_temp)
       CALL SetupL2GPProd(rDays, totalIndex, l3r_temp, l3r)
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
           & pcf%l3StartDay, &
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residA_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp, residA)
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
           & pcf%l3StartDay, &
           & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residD_temp)
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp, residD)
       l3r%name    = TRIM(cfProd%l3prodNameD) // 'Residuals'
       residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
       residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
       DO j = 1, rDays
           l3r(j)%pressures = l3r_temp(j)%pressures(pStartIndex:pEndIndex)
           l3r(j)%l2gpValue         = -999.99 
           l3r_temp(j)%l2gpValue    = -999.99 
           l3r(j)%l2gpPrecision = l3r_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:)
           residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
           residA(j)%l2gpValue = -999.99
           residA_temp(j)%l2gpValue = -999.99
           residA(j)%l2gpPrecision = residA_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
           residD(j)%l2gpValue      = -999.99
           residD_temp(j)%l2gpValue = -999.99
           residD(j)%l2gpPrecision = residD_temp(j)%l2gpPrecision(:,pStartIndex:pEndIndex,:) 
           DO k = 1, l3r(j)%nTimes
             if(l3r(j)%time(k) > 0) then
               startTime(j) = l3r(j)%time(k)
               exit
             endif
           ENDDO
           DO k = l3r(j)%nTimes, 1, -1
             if(l3r(j)%time(k) > 0) then
               endTime(j) = l3r(j)%time(k)
               exit
             endif
           ENDDO
           DO k = 1, residA(j)%nTimes
             if(residA(j)%time(k) > 0) then
               startTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residA(j)%nTimes, 1, -1
             if(residA(j)%time(k) > 0) then
               endTime(j) = residA(j)%time(k)
               exit
             endif
           ENDDO
           DO k = 1, residD(j)%nTimes
             if(residD(j)%time(k) > 0) then
               startTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
           DO k = residD(j)%nTimes, 1, -1
             if(residD(j)%time(k) > 0) then
               endTime(j) = residD(j)%time(k)
               exit
             endif
           ENDDO
       ENDDO

    ENDIF
        
    !!      Initialize Flags
        
    flags%writel3sp    = .FALSE.
    flags%writel3dmCom = .FALSE.
    flags%writel3dmAsc = .FALSE.
    flags%writel3dmDes = .FALSE.
    flags%writel3rCom  = .FALSE.
    flags%writel3rAsc  = .FALSE.
    flags%writel3rDes  = .FALSE.
       
    !!      Check if pressure levels are found 
        
    IF (nlev_temp == 1) THEN 
       RETURN
    END IF
    
    !*** Calculate average orbital period (day)
    
    tau0 = 0.0
    DO I = 1, size(avgPeriod)
       tau0 = tau0 + avgPeriod(i)
    ENDDO
        
    IF (size(avgPeriod) .ne. 0) tau0 = tau0/86400.0/float(size(avgPeriod))
        
    !*** Sort & Prepare the Data 
    
    Call SortData(cfProd, l2Days, l2gp, 	&
         & pStartIndex, pEndIndex,		&
         & tau0, 				&
         & anlats, dnlats, 			&
         & alats, dlats, 			&
         & alons, dlons, 			&
         & atimes, dtimes, 			&
         & afields, dfields, 		        &
         & aprec, dprec,                        &
         & delTad, perMisPoints )
        
        !*** Main Loop 
        
        !*** Calculate Field Values ********
        
    iP = 0
    DO kP = pStartIndex, pEndIndex 
	
       iP = iP + 1
       DO I = 1, rDays 
          nc(I) = 0
          nca(I) = 0
          ncd(I) = 0
       ENDDO
           
       DO J = 1, cfProd%nLats
          IF( anlats(J, iP) > 0 ) THEN
             
             IF( atimes(J, 1, iP) < dtimes(J, 1, iP) ) THEN
                
                lonD0_in = FindRealLon(real(dlons(J, 1, iP)))
                lonA0_in = FindRealLon(real(alons(J, 1, iP)))
                    
                CALL Init( & 
                     & nt_a_i   = anlats(J, iP), 		&
                     & nt_d_i   = dnlats(J, iP), 		&
                     & tau0_i   = tau0, 			&
                     & delTad_i = delTad(J, iP), 		&
                     & c0_i     = 2.0*PI, 			&
                     & lonD0_i  = lonD0_in, 			&
                     & tD0_i    = dtimes(J, 1, iP), 		&
                     & lonA0_i  = lonA0_in, 			&
                     & tA0_i    = atimes(J, 1, iP), 		&
                     & lat_i    = alats(J, 1, iP) )
                CALL DataGenerate(afields(J, :, iP), dfields(J, :, iP) )
                CALL DataGeneratePrec(aprec(J, :, iP), dprec(J, :, iP) )
             ELSE
                    
                lonD0_in = FindRealLon(real(dlons(J, 2, iP)))
                lonA0_in = FindRealLon(real(alons(J, 1, iP)))
                    
                CALL Init( & 
                     & nt_a_i   = anlats(J, iP), 			&
                     & nt_d_i   = dnlats(J, iP)-1, 			&
                     & tau0_i   = tau0, 				&
                     & delTad_i = delTad(J, iP), 			&
                     & c0_i     = 2.0*PI, 				&
                     & lonD0_i  = lonD0_in, 			        &
                     & tD0_i    = dtimes(J, 2, iP), 		        & 
                     & lonA0_i  = lonA0_in, 			        &
                     & tA0_i    = atimes(J, 1, iP), 		        &
                     & lat_i    = alats(J, 1, iP) )
                CALL DataGenerate(afields(J, :, iP), dfields(J, 2:, iP) )
                CALL DataGeneratePrec(aprec(J, :, iP), dprec(J, 2:, iP) )
             END IF
                
             IF (cfProd%mode == 'com') THEN
                
                if (l3dm(1)%nLons .gt. 0) then 
                   
                   ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                       
                   CALL CordTransform(cfProd%mode)
                   CALL FFSM(l3sp(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmValue(iP, J, I) = l3Result(I) 
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, l3dm(iD)%nLons
                         avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (l3dm(iD)%nLons .ne. 0) & 
                           & avg = avg/real(l3dm(iD)%nLons)
                      l3dm(iD)%latRss(iP, J) = 0.0
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%latRss(iP, J) = & 
                              & l3dm(iD)%latRss(iP, J) +  &
                              & (l3dm(iD)%l3dmValue(iP, J, I)-avg)*  &
                              & (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                          
                      IF (l3dm(iD)%nLons .ne. 0) THEN
                         l3dm(iD)%latRss(iP, J) = sqrt(l3dm(iD)%latRss(iP, J)/ &
                              & real(l3dm(iD)%nLons-1))
                      ENDIF
                          
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
! write(*,*) iD, startTime(iD), endTime(iD) 
                      DO iL = 1, anlats(J, iP)
                         IF( & 
                              &((atimes(J, iL, iP)*86400.+l2gp(1)%time(1)) .ge. startTime(iD)) .AND. &
                              &((atimes(J, iL, iP)*86400.+l2gp(1)%time(1)) .le. endTime(iD))) THEN
                            nc(iD) = nc(iD) + 1
                            CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret)
                            l3r_temp(iD)%time(nc(iD))  = atimes(J, iL,iP)*86400.0+l2gp(1)%time(1)
                            l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
                            l3r_temp(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
                            l3r_temp(iD)%l2gpValue(1, kP, nc(iD)) = afields(J, iL, iP)-l3ret 
if((afields(J, iL, iP)-l3ret)/afields(J, iL, iP)*100.0 > 10) then
! write(*,*) iD, afields(J, iL, iP), l3ret, alons(J, iL, iP), atimes(J, iL, iP), l3r_temp(iD)%time(nc(iD)), 'a'
end if
if(afields(J, iL, iP) < 0.0) then
! write(*,*) iD, afields(J, iL, iP), l3ret, alons(J, iL, iP), atimes(J, iL, iP), l3r_temp(iD)%time(nc(iD)), 'a'
end if
                            l3r_temp(iD)%l2gpPrecision(1, kP, nc(iD)) = 0.0
                         END IF
                             
                      ENDDO

                      DO iL = 1, dnlats(J, iP)
                         IF( &
                              & dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
                              & dtimes(J,iL,iP)*86400.0+l2gp(1)%time(1)<= endTime(iD)) THEN
                            nc(iD) = nc(iD) + 1
                            CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
                            l3r_temp(iD)%time(nc(iD)) = dtimes(J,iL, iP)*86400.0+l2gp(1)%time(1)
                            l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
                            l3r_temp(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
                            l3r_temp(iD)%l2gpValue(1, kP, nc(iD)) = dfields(J, iL, iP)-l3ret 
if((dfields(J, iL, iP)-l3ret)/dfields(J, iL, iP)*100.0 > 10) then
 !write(*,*) iD, dfields(J, iL, iP), l3ret, 'd'
end if
                            l3r_temp(iD)%l2gpPrecision(1, kP, nc(iD)) = 0.0
                         END IF
                      ENDDO
                   ENDDO
 
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
 
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
                       
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result, STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                       
                   flags%writel3dmCom = .TRUE.
                   flags%writel3rCom  = .TRUE.
                   flags%writel3sp = .TRUE.
                  
                endif
                    
             ELSE IF (cfProd%mode == 'asc') THEN
                    
                if (dmA(1)%nLons .gt. 0) then 
                       
                   if ( associated(l3Result) ) then 
                      ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                       
                   CALL CordTransform(cfProd%mode)
                   CALL FFSMA(l3sp(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, & 
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmValue(iP, J, I) = l3Result(I) 
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmA(iD)%nLons
                         avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) & 
                           & avg = avg/real(dmA(iD)%nLons)
                      dmA(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +  &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) THEN 
                         dmA(iD)%latRss(iP, J) = sqrt(dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons-1))
                      ENDIF
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, anlats(J, iP)
                         IF & 
                              & (atimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & atimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            nc(iD) = nc(iD) + 1
                            CALL Diagnostics(cfProd%mode, & 
                                 & atimes(J, iL, iP), & 
                                 & alons(J, iL, iP), l3ret) 
                            residA_temp(iD)%time(nc(iD))     = & 
                                 & atimes(J,iL, iP)*86400.0+l2gp(1)%time(1)
                            residA_temp(iD)%latitude(nc(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            residA_temp(iD)%longitude(nc(iD)) = & 
                                 & FindRealLon(real(alons(J, iL, iP)))* & 
                                 & 180.0/PI
                            residA_temp(iD)%l2gpValue(1, kP, nc(iD)) = & 
                                 & afields(J, iL, iP)-l3ret 
                            residA_temp(iD)%l2gpPrecision(1, kP, nc(iD)) =&
                                 & 0.0
                         END IF
                      ENDDO
                   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
                  
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result, STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                       
                   flags%writel3dmAsc = .TRUE.
                   flags%writel3rAsc  = .TRUE.
                   flags%writel3sp = .TRUE.
                  
                endif
                    
             ELSE IF (cfProd%mode == 'des') THEN
                    
                if (dmD(1)%nLons .gt. 0) then 
                   
                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                       
                   CALL CordTransform(cfProd%mode)
                   CALL FFSMD(l3sp(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, & 
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmValue(iP, J, I) = l3Result(I) 
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmD(iD)%nLons
                         avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) & 
                           & avg = avg/real(dmD(iD)%nLons)
                      dmD(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +  &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)*  &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) THEN
                         dmD(iD)%latRss(iP, J) = sqrt(dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons-1))
                      ENDIF
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, dnlats(J, iP)
                         IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & dtimes(J,iL,iP)*86400.0+l2gp(1)%time(1)<=& 
                              & endTime(iD)) THEN
                            nc(iD) = nc(iD) + 1
                            CALL Diagnostics(cfProd%mode, &
                                 & dtimes(J, iL, iP), & 
                                 & dlons(J, iL, iP), l3ret) 
                            residD_temp(iD)%time(nc(iD))     = & 
                                 & dtimes(J, iL,iP)*86400.0+l2gp(1)%time(1)
                            residD_temp(iD)%latitude(nc(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            residD_temp(iD)%longitude(nc(iD)) = & 
                                 & FindRealLon(real(dlons(J, iL, iP)))* & 
                                 & 180.0/PI
                            residD_temp(iD)%l2gpValue(1, kP, nc(iD)) = & 
                                 & dfields(J, iL, iP)-l3ret 
                            residD_temp(iD)%l2gpPrecision(1, kP, nc(iD))= &
                                 & 0.0 
                         END IF
                      ENDDO
                   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
                  
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result, STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                   
                   flags%writel3dmDes = .TRUE.
                   flags%writel3rDes  = .TRUE.
                   flags%writel3sp    = .TRUE.
                       
                endif
                    
             ELSE IF (cfProd%mode == 'ado') THEN
                
                if (dmA(1)%nLons .gt. 0) then 
                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                       
                   CALL CordTransform('asc')
                   CALL FFSMA(l3sp(2), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct('asc', & 
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0,  &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmValue(iP, J, I) = l3Result(I)
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmA(iD)%nLons
                         avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) & 
                           & avg = avg/real(dmA(iD)%nLons)
                      dmA(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +  &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)* & 
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) THEN
                         dmA(iD)%latRss(iP, J) = sqrt(dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons-1))
                      ENDIF
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, anlats(J, iP)
                         
                         IF & 
                              & (atimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & atimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            nca(iD) = nca(iD) + 1
                            CALL Diagnostics('asc', atimes(J, iL, iP), & 
                                 & alons(J, iL, iP), l3ret)
                            
                            residA_temp(iD)%time(nca(iD)) = & 
                                 & atimes(J, iL,iP)*86400.0+l2gp(1)%time(1)
                            residA_temp(iD)%longitude(nca(iD)) = & 
                                 &FindRealLon(real(alons(J,iL,iP)))*180./PI
                            residA_temp(iD)%latitude(nca(iD)) = & 
                                 & cfProd%latGridMap(J)  
                            residA_temp(iD)%l2gpValue(1, kP, nca(iD)) = & 
                                 & afields(J, iL, iP)-l3ret
                            residA_temp(iD)%l2gpPrecision(1, kP, nca(iD)) &
                                 & = 0.0
                                
                         END IF
                      ENDDO
                   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
                      DO I = 1, dmA(1)%nLons
                         l3Result(I) = 0.0 
                      ENDDO
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(2)%l3spRelPrecision = l3spPrec(2)%l3spRelValue
		   l3sp(2)%l3spImgPrecision = l3spPrec(2)%l3spImgValue
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      Deallocate(l3Result, STAT=error) 
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                       
                   flags%writel3dmAsc = .TRUE. 
                   flags%writel3rAsc  = .TRUE.
                       
                endif
                    
                if (dmD(1)%nLons .gt. 0) then 
                       
                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // '  l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                       
                   CALL CordTransform('des')
                   CALL FFSMD(l3sp(3), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct('des', & 
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmValue(iP, J, I) = l3Result(I)
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmD(iD)%nLons
                         avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) & 
                           & avg = avg/real(dmD(iD)%nLons)
                      dmD(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) + &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)* & 
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) THEN 
                         dmD(iD)%latRss(iP, J) = sqrt(dmD(iD)%latRss(iP, J)/ &
                              & real(dmD(iD)%nLons-1))
                      ENDIF
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, dnlats(J, iP)
                         IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & dtimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            ncd(iD) = ncd(iD) + 1
                            CALL Diagnostics('des', dtimes(J, iL, iP), & 
                                 & dlons(J, iL, iP), l3ret)
                                
                            residD_temp(iD)%longitude(ncd(iD))       = & 
                                 & FindRealLon(real(dlons(J, iL, iP)))*& 
                                 & 180./PI

                            residD_temp(iD)%time(ncd(iD))            = & 
                                 & dtimes(J,iL, iP)*86400.0+l2gp(1)%time(1)
                            
                            residD_temp(iD)%latitude(ncd(iD))        = & 
                                 & cfProd%latGridMap(J)  
                                
                            residD_temp(iD)%l2gpValue(1, kP, ncd(iD))= & 
                                 & dfields(J, iL, iP)-l3ret

                            residD_temp(iD)%l2gpPrecision(1, kP, ncd(iD)) &
                                 & = 0.0
                                
                         END IF
                      ENDDO
                   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(3)%l3spRelPrecision = l3spPrec(3)%l3spRelValue
		   l3sp(3)%l3spImgPrecision = l3spPrec(3)%l3spImgValue
                       
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result, STAT=error) 
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                       
                   flags%writel3dmDes = .TRUE. 
                   flags%writel3rDes  = .TRUE.
                   flags%writel3sp    = .TRUE.
                       
                endif
                    
             ELSE IF (cfProd%mode == 'all') THEN
                    
                if (l3dm(1)%nLons .gt. 0) then 
                       
                   ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                       
                   CALL CordTransform('com')
                   CALL FFSM(l3sp(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct('com', & 
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmValue(iP, J, I) = l3Result(I) 
                      ENDDO
                          !***Root-Sum-Square for each latitude, 
                          ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, l3dm(iD)%nLons
                         avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (l3dm(iD)%nLons .ne. 0) & 
                           & avg = avg/real(l3dm(iD)%nLons)
                      l3dm(iD)%latRss(iP, J) = 0.0
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J) +&
                              & (l3dm(iD)%l3dmValue(iP, J, I)-avg)*  &
                              & (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (l3dm(iD)%nLons .ne. 0) THEN
                         l3dm(iD)%latRss(iP, J) = sqrt(l3dm(iD)%latRss(iP, J)/ &
                              & real(l3dm(iD)%nLons-1))
                      ENDIF
                   ENDDO
                       
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, anlats(J, iP)
                         IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & atimes(J, iL, iP)*86400.0+ & 
                              & l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            nc(iD) = nc(iD) + 1
                            CALL Diagnostics('com', atimes(J, iL, iP), & 
                                 & alons(J, iL, iP), l3ret) 
                            l3r_temp(iD)%time(nc(iD))  = & 
                                 & atimes(J,iL, iP)*86400.0+l2gp(1)%time(1)
                            l3r_temp(iD)%latitude(nc(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            l3r_temp(iD)%longitude(nc(iD)) = & 
                                 & FindRealLon(real(alons(J, iL, iP)))* & 
                                 & 180.0/PI
                            l3r_temp(iD)%l2gpValue(1, kP, nc(iD)) = & 
                                 & afields(J, iL, iP)-l3ret 
                            l3r_temp(iD)%l2gpPrecision(1, kP, nc(iD)) = 0.0
                         END IF
                      ENDDO
                      DO iL = 1, dnlats(J, iP)
                         IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & dtimes(J, iL, iP)*86400.+l2gp(1)%time(1)<=&
                              & endTime(iD)) THEN
                            
                            nc(iD) = nc(iD) + 1
                                
                            CALL Diagnostics('com', dtimes(J, iL, iP), & 
                                 & dlons(J, iL, iP), l3ret) 
                                
                            l3r_temp(iD)%time(nc(iD))                 = & 
                                 & dtimes(J, iL, iP)*86400.+l2gp(1)%time(1)
                            
                            l3r_temp(iD)%latitude(nc(iD))             = & 
                                 & cfProd%latGridMap(J) 
                                
                            l3r_temp(iD)%longitude(nc(iD))            = & 
                                 & FindRealLon(real(dlons(J, iL, iP)))* & 
                                 & 180.0/PI
                                
                            l3r_temp(iD)%l2gpValue(1, kP, nc(iD))     = & 
                                 & dfields(J, iL, iP)-l3ret 

                            l3r_temp(iD)%l2gpPrecision(1, kP, nc(iD)) = 0.0

                         END IF
		      ENDDO
		   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
                   
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result,STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                   
		   flags%writel3dmCom = .TRUE.
		   flags%writel3rCom  = .TRUE.
                   
                endif
                
                if (dmA(1)%nLons .gt. 0) then 
                   
                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   
                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMA(l3sp(2), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('asc', & 
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
            !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmA(iD)%nLons
                         avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) avg = avg/real(dmA(iD)%nLons)
                      dmA(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) + &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmA(iD)%nLons .ne. 0) THEN
                         dmA(iD)%latRss(iP, J) = sqrt(dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons-1))
                      ENDIF
                   ENDDO
                   
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, anlats(J, iP)
                         IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            
                            nca(iD) = nca(iD) + 1
                            
                            CALL Diagnostics('asc', atimes(J, iL, iP), & 
                                & alons(J, iL, iP), l3ret) 
                            
                            residA_temp(iD)%time(nca(iD))     = & 
                                 & atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                            
                            residA_temp(iD)%latitude(nca(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            
                            residA_temp(iD)%longitude(nca(iD)) = & 
                                 & FindRealLon(real(alons(J, iL, iP)))*180.0/PI
                            
                            residA_temp(iD)%l2gpValue(1, kP, nca(iD)) = & 
                                 & afields(J, iL, iP)-l3ret 
                            
                            residA_temp(iD)%l2gpPrecision(1, kP, nca(iD)) = 0.0
                            
                         END IF
		      ENDDO
		   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(2)%l3spRelPrecision = l3spPrec(2)%l3spRelValue
		   l3sp(2)%l3spImgPrecision = l3spPrec(2)%l3spImgValue
                   
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result,STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                   
		   flags%writel3dmAsc = .TRUE.
		   flags%writel3rAsc  = .TRUE.
                   
                endif
                
                if (dmD(1)%nLons .gt. 0) then 
                   
                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_Allocate // ' l3Result array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   
                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMD(l3sp(3), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('des', & 
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
                      !***Root-Sum-Square for each latitude, 
                      ! dimensioned (nLevels, nLats)
                      avg = 0.0
                      DO I = 1, dmD(iD)%nLons
                         avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) avg = avg/real(dmD(iD)%nLons)
                      dmD(iD)%latRss(iP, J) = 0.0
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +  &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      IF (dmD(iD)%nLons .ne. 0) THEN 
                         dmD(iD)%latRss(iP, J) = sqrt(dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons-1))
                      ENDIF
		   ENDDO
                   
                   !*** Calculate Residual     
                   DO iD = 1, rDays
                      DO iL = 1, dnlats(J, iP)
                         IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= & 
                              & endTime(iD)) THEN
                            
                            ncd(iD) = ncd(iD) + 1

                            CALL Diagnostics('des', dtimes(J, iL, iP), & 
                                 & dlons(J, iL, iP), l3ret) 

                            residD_temp(iD)%time(ncd(iD))     = & 
                                 & dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                            
                            residD_temp(iD)%latitude(ncd(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            
                            residD_temp(iD)%longitude(ncd(iD)) = & 
                                 & FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
                            
                            residD_temp(iD)%l2gpValue(1, kP, ncd(iD)) = & 
                                 & dfields(J, iL, iP)-l3ret
                            
                            residD_temp(iD)%l2gpPrecision(1, kP, ncd(iD)) = 0.0

                         END IF
		      ENDDO
		   ENDDO
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(3)%l3spRelPrecision = l3spPrec(3)%l3spRelValue
		   l3sp(3)%l3spImgPrecision = l3spPrec(3)%l3spImgValue
                   
                   !*** Cleanup    
                   if ( associated(l3Result) ) then 
                      DeAllocate(l3Result,STAT=error)
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_DeAllocate // '  l3Result array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                   endif
                   
		   flags%writel3dmDes = .TRUE.
		   flags%writel3rDes  = .TRUE.
		   flags%writel3sp    = .TRUE.
                   
                endif
                
             END IF
             
             CALL ClearMemory()
             
          END IF
       ENDDO


    !*** Sort into time ascending order according to l2gp format
       IF (cfProd%mode == 'com') THEN
          DO iD = 1, rDays
             
             if (nc(iD) .gt. 0) then 
                
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                ALLOCATE( sortTemp(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' sortTemp array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                DO i = 1, nc(iD)
                   pt(i) = 0
                   sortTemp(i) = 999.99 
                ENDDO
                CALL my_sortp(l3r_temp(iD)%time, 1, nc(iD), pt)
                !** do time
                CALL DSORT(l3r_temp(iD)%time, 1, nc(iD))
                !** do latitude
                DO i = 1, nc(iD)
                   sortTemp(i) = l3r_temp(iD)%latitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   l3r_temp(iD)%latitude(i) = sortTemp(pt(i))
                ENDDO
                !** do longitude
                DO i = 1, nc(iD)
                   sortTemp(i) = l3r_temp(iD)%longitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   l3r_temp(iD)%longitude(i) = sortTemp(pt(i))
                ENDDO
                !** do value
                DO i = 1, nc(iD)
                   sortTemp(i) = l3r_temp(iD)%l2gpValue(1, kP, i)
                ENDDO
                DO i = 1, nc(iD)
                   l3r_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                ENDDO
 
                !*** Interpolate to l2gp grid 
                !CALL Residual2L2Grid( iD, kP, l3r_temp, l3r ) 
                CALL Residual2L2Grid( iD, iP, kP, l3r_temp, l3r ) 

                if ( associated(sortTemp) ) then 
                   DeAllocate(sortTemp, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  sortTemp array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
                if ( associated(pt)) then 
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !*** Calculate Maximum Difference
             
             if ( nc(iD) .gt. 0 ) then 
                
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // '  pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                CALL my_sortp(-abs(l3r_temp(iD)%l2gpValue & 
                     (1, kP, 1:nc(iD))), 1, nc(iD), pt)
                DO i = 1, cfDef%N
                   l3dm(iD)%maxDiff(i, iP) = & 
                        l3r_temp(iD)%l2gpValue(1, kP, pt(i))
                ENDDO
                
                if ( associated(pt) ) then 
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !***Root-Sum-Square for each latitude, dimensioned (nLevels)
             avg = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, l3dm(iD)%nLons
                   avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
                ENDDO
             ENDDO
             IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN
                avg = avg/real(l3dm(iD)%nLons*cfProd%nLats)
             ENDIF
             l3dm(iD)%gRss(iP) = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, l3dm(iD)%nLons
                   l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP) + &
                        & (l3dm(iD)%l3dmValue(iP, J, I)-avg)* &
                        & (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                ENDDO
             ENDDO
             IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN
                l3dm(iD)%gRss(iP) = sqrt(l3dm(iD)%gRss(iP)/real(l3dm(iD)%nLons*cfProd%nLats-1))
             ENDIF
             l3dm(iD)%perMisPoints(iP) = perMisPoints(iP)
          ENDDO
       ELSE IF (cfProd%mode == 'asc') THEN
          DO iD = 1, rDays
             
             if ( nc(iD) .gt. 0 ) then 
                
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                     
                ALLOCATE( sortTemp(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' sortTemp array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                CALL my_sortp(residA_temp(iD)%time, 1, nc(iD), pt)
                !** do time
                CALL DSORT(residA_temp(iD)%time, 1, nc(iD))
                !** do latitude
                DO i = 1, nc(iD)
                   sortTemp(i) = residA_temp(iD)%latitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   residA_temp(iD)%latitude(i) = sortTemp(pt(i))
                   !** do longitude
                ENDDO
                DO i = 1, nc(iD)
                   sortTemp(i) = residA_temp(iD)%longitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   residA_temp(iD)%longitude(i) = sortTemp(pt(i))
                   !** do value
                ENDDO
                DO i = 1, nc(iD)
                   sortTemp(i) = residA_temp(iD)%l2gpValue(1, kP, i)
                ENDDO
                DO i = 1, nc(iD)
                   residA_temp(iD)%l2gpValue(1, kP, i) = & 
                        sortTemp(pt(i))
                ENDDO
                
                !*** Interpolate to l2gp grid 
                !CALL Residual2L2Grid( iD, kP, residA_temp, residA ) 
                CALL Residual2L2Grid( iD, iP, kP, residA_temp, residA ) 
                
                if ( associated(sortTemp)) then
                   DeAllocate(sortTemp, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  sortTemp array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
                if ( associated(pt) ) then
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !*** Calculate Maximum Difference
             
             if ( nc(iD) .gt. 0 ) then 
                
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                         
                CALL my_sortp(-abs(residA_temp(iD)% & 
                     l2gpValue(1, kP, :)), 1, nc(iD), pt)
                DO i = 1,cfDef%N
                   dmA(iD)%maxDiff(i, kP) = & 
                        residA_temp(iD)%l2gpValue(1, kP, pt(i))
                ENDDO
                
                if ( associated(pt) ) then
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !***Root-Sum-Square for each latitude, dimensioned (nLevels)
             avg = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, dmA(iD)%nLons
                   avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                ENDDO
             ENDDO
             IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
             ENDIF
             dmA(iD)%gRss(iP) = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, dmA(iD)%nLons
                   dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                        & (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                        & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                ENDDO
             ENDDO
             IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN
                dmA(iD)%gRss(iP) = sqrt(dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats-1))
             ENDIF
             dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
          ENDDO
       ELSE IF (cfProd%mode == 'des') THEN
          DO iD = 1, rDays
             
             if ( nc(iD) .gt. 0 ) then 
                
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                ALLOCATE( sortTemp(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' sortTemp array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                CALL my_sortp(residD_temp(iD)%time, 1, nc(iD), pt)
                !** do time
                CALL DSORT(residD_temp(iD)%time, 1, nc(iD))
                !** do latitude
                DO i = 1, nc(iD)
                   sortTemp(i) = residD_temp(iD)%latitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   residD_temp(iD)%latitude(i) = sortTemp(pt(i))
                ENDDO
                !** do longitude
                DO i = 1, nc(iD)
                   sortTemp(i) = residD_temp(iD)%longitude(i)
                ENDDO
                DO i = 1, nc(iD)
                   residD_temp(iD)%longitude(i) = sortTemp(pt(i))
                ENDDO
                !** do value
                DO i = 1, nc(iD)
                   sortTemp(i) = residD_temp(iD)%l2gpValue(1, kP, i)
                ENDDO
                DO i = 1, nc(iD)
                   residD_temp(iD)%l2gpValue(1, kP, i) = & 
                        sortTemp(pt(i))
                ENDDO
                
                !*** Interpolate to l2gp grid 
                !CALL Residual2L2Grid( iD, kP, residD_temp, residD ) 
                CALL Residual2L2Grid( iD, iP, kP, residD_temp, residD ) 
                
                if ( associated(sortTemp) ) then 
                   DeAllocate(sortTemp, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  sortTemp array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
                if ( associated(pt) ) then 
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !*** Calculate Maximum Difference
             
             if (nc(iD) .gt. 0) then 
                         
                ALLOCATE( pt(nc(iD)), STAT=error )
                IF ( error /= 0 ) THEN
                   msr = MLSMSG_Allocate // ' pt array.'
                   CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                ENDIF
                
                CALL my_sortp(-abs(residD_temp(iD)% & 
                     & l2gpValue(1, kP, :)), 1, nc(iD), pt)
                DO i = 1,cfDef%N
                   dmD(iD)%maxDiff(i, iP) = & 
                        & residD_temp(iD)%l2gpValue(1, kP, pt(i))
                ENDDO
                
                if ( associated(pt) ) then
                   DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                      msr = MLSMSG_DeAllocate // '  pt array.'
                      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                endif
                
             endif
             
             !***Root-Sum-Square for each latitude, dimensioned (nLevels)
             avg = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, dmD(iD)%nLons
                   avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                ENDDO
             ENDDO
             IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN
                avg = avg/real(dmD(iD)%nLons*cfProd%nLats)
             ENDIF
             dmD(iD)%gRss(iP) = 0.0
             DO J = 1, cfProd%nLats
                DO I = 1, dmD(iD)%nLons
                   dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                        & (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                        & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                ENDDO
             ENDDO
             IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                dmD(iD)%gRss(iP) = sqrt(dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats-1))
             ENDIF
             dmD(iD)%perMisPoints(iP) = perMisPoints(iP)
          ENDDO
       ELSE IF (cfProd%mode == 'ado') THEN
                DO iD = 1, rDays
                   if ( nca(iD) .gt. 0 ) then 
                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      ALLOCATE( sortTemp(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // '  sortTemp array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(residA_temp(iD)%time, 1, nca(iD), pt)
                      !** do time
                      CALL DSORT(residA_temp(iD)%time, 1, nca(iD))
                      !** do latitude
                      DO i = 1, nca(iD)
                         sortTemp(i) = residA_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, nca(iD)
                         residA_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, nca(iD)
                         sortTemp(i) = residA_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, nca(iD)
                         residA_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, nca(iD)
                         sortTemp(i) = residA_temp(iD)%l2gpValue(1, kP, i)
                      ENDDO
                      DO i = 1, nca(iD)
                         residA_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                      ENDDO
                      
                      !*** Interpolate to l2gp grid 
		      !CALL Residual2L2Grid( iD, kP, residA_temp, residA ) 
		      CALL Residual2L2Grid( iD, iP, kP, residA_temp, residA ) 
                      
                      if ( associated(sortTemp) ) then 
                         DeAllocate(sortTemp, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  sortTemp array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif
                   
                   !*** Calculate Maximum Difference
                   
                   if ( nca(iD) .gt. 0 ) then 
                      
                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(-abs(residA_temp(iD)% & 
                           l2gpValue(1, kP, :)), 1, nca(iD), pt)
                      DO i = 1,cfDef%N
                         dmA(iD)%maxDiff(i, iP) = & 
                              residA_temp(iD)%l2gpValue(1, kP, pt(i))
                      ENDDO
                      
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif
                   
                  !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                   avg = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                         avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                   ENDDO
                   
                   IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
                   ENDIF
                   
                   dmA(iD)%gRss(iP) = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                   ENDDO
                   
                   IF (dmA(iD)%nLons*cfProd%nLats .ne. 0 ) THEN 
                      dmA(iD)%gRss(iP) = sqrt(dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats-1))
                   ENDIF
                   
                   dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO
                
                DO iD = 1, rDays
                   
                   if (ncd(iD) .gt. 0) then 
                      
                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      ALLOCATE( sortTemp(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' sortTemp array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(residD_temp(iD)%time, 1, ncd(iD), pt)
                      !** do time
                      CALL DSORT(residD_temp(iD)%time, 1, ncd(iD))
                      !** do latitude
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%l2gpValue(1, kP, i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                      ENDDO
                      
                      !*** Interpolate to l2gp grid 
		      !CALL Residual2L2Grid( iD, kP, residD_temp, residD ) 
		      CALL Residual2L2Grid( iD, iP, kP, residD_temp, residD ) 
                      
                      if ( associated(sortTemp) ) then 
                         DeAllocate(sortTemp, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  sortTemp array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif
                   
                   !*** Calculate Maximum Difference
                   
                   if (ncd(iD) .gt. 0) then 
                      
                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(-abs(residD_temp(iD)% & 
                           l2gpValue(1, kP, :)), 1, ncd(iD), pt)
                      DO i = 1,cfDef%N
                         dmD(iD)%maxDiff(i, iP) = & 
                              residD_temp(iD)%l2gpValue(1, kP, pt(i))
                      ENDDO
                      
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif

                   !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                   avg = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                         avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                   ENDDO
                   IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN
                      avg = avg/real(dmD(iD)%nLons*cfProd%nLats)
                   ENDIF
                   dmD(iD)%gRss(iP) = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                   ENDDO
                   IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      dmD(iD)%gRss(iP) = sqrt(dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats-1))
                   ENDIF
                      dmD(iD)%perMisPoints(iP) = perMisPoints(iP)
                   ENDDO
                ELSE IF (cfProd%mode == 'all') THEN
                   DO iD = 1, rDays
                      
                      if (nca(iD) .gt. 0) then 
                         
                         ALLOCATE( pt(nca(iD)), STAT=error )
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                     ENDIF
                     
                     ALLOCATE( sortTemp(nca(iD)), STAT=error )
                     IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                     ENDIF
                     
                     CALL my_sortp(residA_temp(iD)%time, 1, nca(iD), pt)
                     !** do time
                     CALL DSORT(residA_temp(iD)%time, 1, nca(iD))
                     !** do latitude
                     DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%latitude(i)
                     ENDDO
                     DO i = 1, nca(iD)
                        residA_temp(iD)%latitude(i) = sortTemp(pt(i))
                     ENDDO
                     !** do longitude
                     DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%longitude(i)
                     ENDDO
                     DO i = 1, nca(iD)
                        residA_temp(iD)%longitude(i) = sortTemp(pt(i))
                     ENDDO
                     !** do value
                     DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%l2gpValue(1, kP, i)
                     ENDDO
                     DO i = 1, nca(iD)
                        residA_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                     ENDDO
                     
                     !*** Interpolate to l2gp grid 
                     !CALL Residual2L2Grid( iD, kP, residA_temp, residA ) 
                     CALL Residual2L2Grid( iD, iP, kP, residA_temp, residA ) 
                     
                     if ( associated(sortTemp)) then 
                        
                        DeAllocate(sortTemp, STAT=error)
                        IF ( error /= 0 ) THEN
                           msr = MLSMSG_DeAllocate // '  sortTemp array.'
                           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                        ENDIF
                        
                     endif
                     
                     if ( associated(pt) ) then 
                        
                        DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                         
                      endif
                      
                   endif
                   
                   !*** Calculate Maximum Difference

                   if (nca(iD) .gt. 0) then 
                      
                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residA_temp(iD)% & 
                           l2gpValue(1, kP, :)), 1, nca(iD), pt)
                      DO i = 1,cfDef%N
                         dmA(iD)%maxDiff(i, iP) = & 
                              residA_temp(iD)%l2gpValue(1, kP, pt(i))
                      ENDDO
                      
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif
                   
                   !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                   avg = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                         avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                   ENDDO
                   IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
                   ENDIF
                   dmA(iD)%gRss(iP) = 0.0
                   DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                              & (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                   ENDDO
                   IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      dmA(iD)%gRss(iP) = sqrt(dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats-1))
                   ENDIF
                   dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO
                
                DO iD = 1, rDays
                   
                   if (ncd(iD) .gt. 0) then 
                     
                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      ALLOCATE( sortTemp(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' sortTemp array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(residD_temp(iD)%time, 1, ncd(iD), pt)
                      !** do time
                      CALL DSORT(residD_temp(iD)%time, 1, ncd(iD))
                     !** do latitude
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, ncd(iD)
                         sortTemp(i) = residD_temp(iD)%l2gpValue(1, kP, i)
                      ENDDO
                      DO i = 1, ncd(iD)
                         residD_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                      ENDDO
                      
                      !*** Interpolate to l2gp grid 
		      !CALL Residual2L2Grid( iD, kP, residD_temp, residD ) 
		      CALL Residual2L2Grid( iD, iP, kP, residD_temp, residD ) 
                      
                      if ( associated(sortTemp) ) then
                         DeAllocate(sortTemp, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  sortTemp array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                   endif
                   
                   !*** Calculate Maximum Difference
                   
                   if ( ncd(iD) .gt. 0 ) then 
                      
                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                     CALL my_sortp(-abs(residD_temp(iD)% & 
                          & l2gpValue(1, kP, :)), 1, ncd(iD), pt)
                     DO i = 1,cfDef%N
                        dmD(iD)%maxDiff(i, iP) = & 
                             & residD_temp(iD)%l2gpValue(1, kP, pt(i))
                     ENDDO
                     
                     if ( associated(pt) ) then 
                        DeAllocate(pt, STAT=error)
                        IF ( error /= 0 ) THEN
                           msr = MLSMSG_DeAllocate // '  pt array.'
                           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                        ENDIF
                     endif
                     
                  endif
                  
                  !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                  avg = 0.0
                  DO J = 1, cfProd%nLats
                     DO I = 1, dmD(iD)%nLons
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                     ENDDO
                  ENDDO
                  IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                     avg = avg/real(dmD(iD)%nLons*cfProd%nLats)
                  ENDIF
                  dmD(iD)%gRss(iP) = 0.0
                  DO J = 1, cfProd%nLats
                     DO I = 1, dmD(iD)%nLons
                        dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                             & (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                             & (dmD(iD)%l3dmValue(iP, J, I)-avg)
                     ENDDO
                  ENDDO
                  IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                     dmD(iD)%gRss(iP) = sqrt(dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats-1))
                  ENDIF
                  dmD(iD)%perMisPoints(iP) = perMisPoints(iP)
               ENDDO
               
               DO iD = 1, rDays
                  
                  if ( nc(iD) .gt. 0 ) then 
                     
                     ALLOCATE( pt(nc(iD)), STAT=error )
                     IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      ALLOCATE( sortTemp(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' sortTemp array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      
                      CALL my_sortp(l3r_temp(iD)%time, 1, nc(iD), pt)
                      !** do time
                      CALL DSORT(l3r_temp(iD)%time, 1, nc(iD))
                      !** do latitude
                      DO i = 1, nc(iD)
                         sortTemp(i) = l3r_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                         l3r_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, nc(iD)
                         sortTemp(i) = l3r_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                         l3r_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, nc(iD)
                         sortTemp(i) = l3r_temp(iD)%l2gpValue(1, kP, i)
                      ENDDO
                      DO i = 1, nc(iD)
                         l3r_temp(iD)%l2gpValue(1, kP, i) = sortTemp(pt(i))
                      ENDDO
                     
                      !*** Interpolate to l2gp grid
                      !CALL Residual2L2Grid( iD, kP, l3r_temp, l3r )
                      CALL Residual2L2Grid( iD, iP, kP, l3r_temp, l3r )
 
                      if ( associated(sortTemp) ) then 
                         DeAllocate(sortTemp, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  sortTemp array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                      if ( associated(pt) ) then 
                         DeAllocate(pt, STAT=error)
                         IF ( error /= 0 ) THEN
                            msr = MLSMSG_DeAllocate // '  pt array.'
                            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                         ENDIF
                      endif
                      
                  endif
                   
                  !*** Calculate Maximum Difference
                   
                  if ( nc(iD) .gt. 0 ) then 
                      
                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                         msr = MLSMSG_Allocate // ' pt array.'
                         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                     
                      CALL my_sortp(-abs(l3r_temp(iD)% & 
                           l2gpValue(1, kP, :)), 1, nc(iD), pt)
                     DO i = 1,cfDef%N
                        l3dm(iD)%maxDiff(i, iP) = & 
                             & l3r_temp(iD)%l2gpValue(1, kP, pt(i))
                     ENDDO
                     
                     if ( associated(pt) ) then 
                        DeAllocate(pt, STAT=error)
                        IF ( error /= 0 ) THEN
                           msr = MLSMSG_DeAllocate // '  pt array.'
                           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                        ENDIF
                     endif
                     
                  
                  !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                  avg = 0.0
                  DO J = 1, cfProd%nLats
                         DO I = 1, l3dm(iD)%nLons
                            avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
                         ENDDO
                  ENDDO
                  IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                         avg = avg/real(l3dm(iD)%nLons*cfProd%nLats)
                  ENDIF
                  l3dm(iD)%gRss(iP) = 0.0
                  DO J = 1, cfProd%nLats
                         DO I = 1, l3dm(iD)%nLons
                            l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP) +  &
                                 & (l3dm(iD)%l3dmValue(iP, J, I)-avg)* &
                                 & (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                         ENDDO
                  ENDDO
                  IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                         l3dm(iD)%gRss(iP) = sqrt(l3dm(iD)%gRss(iP)/real(l3dm(iD)%nLons*cfProd%nLats-1))
                  ENDIF
                  l3dm(iD)%perMisPoints(iP) = perMisPoints(iP)

                endif

               ENDDO

            END IF
                
       ENDDO
       
       !*** Calculate Field Precisions ********
             
       iP = 0
       DO kP = pStartIndex, pStartIndex 
           iP = iP + 1
                
           DO J = 1, cfProd%nLats
              IF( anlats(J, iP) > 0 ) THEN
                      
                 IF( atimes(J, 1, iP) < dtimes(J, 1, iP) ) THEN
                         
                         lonD0_in = FindRealLon(real(dlons(J, 1, iP)))
                         lonA0_in = FindRealLon(real(alons(J, 1, iP)))
                         
                         CALL Init( & 
                              & nt_a_i   = anlats(J, iP), 		&
                              & nt_d_i   = dnlats(J, iP), 		&
                              & tau0_i   = tau0, 			&
                              & delTad_i = delTad(J, iP), 		&
                              & c0_i     = 2.0*PI, 			&
                              & lonD0_i  = lonD0_in, 			&
                              & tD0_i    = dtimes(J, 1, iP), 		&
                              & lonA0_i  = lonA0_in, 			&
                              & tA0_i    = atimes(J, 1, iP), 		&
                              & lat_i    = alats(J, 1, iP) )

                         CALL DataGenerate(aprec(J, :, iP), dprec(J, :, iP) )
                         
                 ELSE

                         lonD0_in = FindRealLon(real(dlons(J, 2, iP)))
                         lonA0_in = FindRealLon(real(alons(J, 1, iP)))

                         CALL Init( & 
                              & nt_a_i   = anlats(J, iP), 		&
                              & nt_d_i   = dnlats(J, iP)-1, 		&
                              & tau0_i   = tau0, 			&
                              & delTad_i = delTad(J, iP), 		&
                              & c0_i     = 2.0*PI, 			&
                              & lonD0_i  = lonD0_in, 			&
                              & tD0_i    = dtimes(J, 2, iP), 		&
                              & lonA0_i  = lonA0_in, 			&
                              & tA0_i    = atimes(J, 1, iP), 		&
                              & lat_i    = alats(J, 1, iP) )
                         CALL DataGenerate(aprec(J, :, iP), dprec(J, 2:, iP) )
                         
                 END IF
                      
                 IF (cfProd%mode == 'com') THEN

                         if (l3dm(1)%nLons .gt. 0) then 
                       
                            ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                            IF ( error /= 0 ) THEN
                               msr = MLSMSG_Allocate // ' l3Result array.'
                               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                            ENDIF
                            
                            CALL CordTransform(cfProd%mode)
                            CALL FFSM(l3spPrec(1), iP, J)
                            DO iD = 1, cfProd%nDays
                               CALL Reconstruct(cfProd%mode, &
                                    & real(l3dm(iD)%time - & 
                                    & l2gp(1)%time(1))/86400.0,&
				    & l3dm(iD)%nLons, l3dm(iD)%longitude, & 
                                    & l3Result)
                               DO I = 1, l3dm(iD)%nLons
                                  l3dm(iD)%l3dmPrecision(iP, J, I) = & 
                                       & l3Result(I) 
                               ENDDO
                            ENDDO
                            
                            if ( associated(l3Result) ) then 
                               DeAllocate(l3Result, STAT=error)
                               IF ( error /= 0 ) THEN
                                  msr = MLSMSG_DeAllocate //'  l3Result array.'
                                  CALL MLSMessage(MLSMSG_Error,ModuleName, msr)
                               ENDIF
                            endif
                         endif  ! nlons > 0
                    
                 ELSE IF (cfProd%mode == 'asc') THEN
                    
                    if (dmA(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMA(l3spPrec(1), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct(cfProd%mode, &
                               & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                          DO I = 1, dmA(iD)%nLons
                             dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                 ELSE IF (cfProd%mode == 'des') THEN
                    
                    if (dmD(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMD(l3spPrec(1), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct(cfProd%mode, &
                               & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                          DO I = 1, dmD(iD)%nLons
                             dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                 ELSE IF (cfProd%mode == 'ado') THEN
                    
                    if (dmA(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMA(l3spPrec(2), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct('asc', &
                               & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                          DO I = 1, dmA(iD)%nLons
                             dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                    if (dmD(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMD(l3spPrec(3), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct('des', &
                               & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                          DO I = 1, dmD(iD)%nLons
                             dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                 ELSE IF (cfProd%mode == 'all') THEN
                    
                    if (l3dm(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // '  l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSM(l3spPrec(1), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct('com', &
                               & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                          DO I = 1, l3dm(iD)%nLons
                             l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                    if (dmA(1)%nLons .gt. 0) then 
                       
                       ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMA(l3spPrec(2), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct('asc', &
                               & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                          DO I = 1, dmA(iD)%nLons
                             dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                    if (dmD(1)%nLons .gt. 0) then 
                      
                       ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                       IF ( error /= 0 ) THEN
                          msr = MLSMSG_Allocate // ' l3Result array.'
                          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                       ENDIF
                       CALL CordTransform(cfProd%mode)
                       CALL FFSMD(l3spPrec(3), iP, J)
                       DO iD = 1, cfProd%nDays
                          CALL Reconstruct('des', &
                               & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                               & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                          DO I = 1, dmD(iD)%nLons
                             dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                          ENDDO
                       ENDDO
                       
                       if ( associated(l3Result) ) then 
                          DeAllocate(l3Result, STAT=error)
                          IF ( error /= 0 ) THEN
                             msr = MLSMSG_DeAllocate // '  l3Result array.'
                             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                          ENDIF
                       endif
                       
                    endif
                    
                 END IF
                
                 CALL ClearMemory()
                 
              END IF
           ENDDO
           
       ENDDO

       !*** Finish and Clean the Memory ********

       if ( associated(l3spPrec) ) then 
          DeAllocate(l3spPrec, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  l3spPrec array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(nc) ) then
          DeAllocate(nc, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  nc array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(nca) ) then 
          DeAllocate(nca, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  nca array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(ncd) ) then
          DeAllocate(ncd, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  ncd array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(startTime)) then 
          DeAllocate(startTime, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  startTime array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(endTime)) then
          DeAllocate(endTime, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  endTime array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       if ( associated(alats) ) then
          DeAllocate(alats, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  alats array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(dlats) ) then
          DeAllocate(dlats, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  dlats array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(alons)) then
          DeAllocate(alons, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  alons array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(dlons)) then
          DeAllocate(dlons, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  dlons array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(atimes)) then
          DeAllocate(atimes, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  atimes array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(dtimes) ) then
          DeAllocate(dtimes, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  dtimes array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(afields) ) then
          DeAllocate(afields, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  afields array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(dfields) ) then
          DeAllocate(dfields, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  dfields array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
                                                                                           
       if ( associated(aprec)) then
          DeAllocate(aprec, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  aprec array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       if ( associated(dprec)) then
          DeAllocate(dprec, STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_DeAllocate // '  dprec array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
       endif
       
       CALL DestroyL2GPDatabase(l2gp)
       IF (cfProd%mode == 'com') THEN
          CALL DestroyL2GPDatabase(l3r_temp)
       ELSE IF (cfProd%mode == 'asc') THEN
          CALL DestroyL2GPDatabase(residA_temp)
       ELSE IF (cfProd%mode == 'dsc') THEN
          CALL DestroyL2GPDatabase(residD_temp)
       ELSE IF (cfProd%mode == 'ado') THEN
          CALL DestroyL2GPDatabase(residA_temp)
          CALL DestroyL2GPDatabase(residD_temp)
       ELSE IF (cfProd%mode == 'all') THEN
          CALL DestroyL2GPDatabase(l3r_temp)
          CALL DestroyL2GPDatabase(residA_temp)
          CALL DestroyL2GPDatabase(residD_temp)
       ENDIF  

       !-----------------------------------
     END SUBROUTINE DailyCoreProcessing
     !-----------------------------------

      !------------------------------------------------------------------------
     SUBROUTINE SortData(cfProd, l2Days, l2gp, pStartIndex, pEndIndex, tau0, & 
          & anlats, dnlats, alats_interp, dlats_interp, alons_interp, & 
          & dlons_interp, atimes_interp, dtimes_interp, afields_interp, & 
          & dfields_interp, aprec_interp, dprec_interp, delTad, perMisPoints)
      !------------------------------------------------------------------------
       USE SDPToolkit, ONLY: PI
       !USE MLSNumerics, ONLY: INTERPOLATEVALUES, InterpolateArraySetup, INTERPOLATEARRAYTEARDOWN
       USE MLSNumerics, ONLY: INTERPOLATEVALUES
       !USE MLSNumerics, ONLY: HUNT 
        
       TYPE( L3CFProd_T ) :: cfProd
       TYPE( L2GPData_T ), POINTER :: l2gp(:)
        
       CHARACTER (LEN=480) :: msr
        
       INTEGER :: pStartIndex, pEndIndex, nIndex
        
       REAL (r8), DIMENSION(cfProd%nLats, pEndIndex-pStartIndex+1) :: delTad 
       
       REAL (r8), POINTER, DIMENSION(:, :, :) ::             & 
            & alons_interp(:, :, :), alats_interp(:, :, :),    & 
            & dlons_interp(:, :, :), dlats_interp(:, :, :),    & 
            & atimes_interp(:, :, :), dtimes_interp(:, :, :),  &
            & afields_interp(:, :, :), dfields_interp(:, :, :),& 
            & aprec_interp(:, :, :), dprec_interp(:, :, :) 
       
       REAL (r8), POINTER, DIMENSION(:, :) ::  &
            & l2Times(:, :), l2Lons(:, :), & 
            & l2Lons_old(:, :), l2Lats(:, :), l2Values(:, :), l2Prec(:, :), &
            & l2GeodAngle(:, :), dataInput(:), latInput(:), resultIntp(:), latIntp(:), &
            & resultTimesIntp(:), resultLonsIntp(:), resultPrecIntp(:)

       REAL (r8), POINTER, DIMENSION(:) :: l2Qual(:) 
       Integer, POINTER, DIMENSION(:) :: l2Status(:) 
       
       REAL (r8) &
            & dlons, alons, lons_found, lats_found, times_found, fields_found,&
            & prec_found, slope, slope_time, slope_field, slope_prec, sTime, & 
            & lons_found_old
        
       REAL :: tau0, latRange, firstTime
        
       INTEGER, DIMENSION(cfProd%nLats, pEndIndex-pStartIndex+1) :: & 
            & anlats, dnlats
       INTEGER, DIMENSION(pEndIndex-pStartIndex+1) :: & 
            & perMisPoints, numData
       
       INTEGER :: nPd, iMin, error, i, j, k, iT, iD, iP, kP, iL, & 
            & nterms, nstart, nr, lindex, lindex_prev, l2Days, nloop, aindex,& 
            & aindex_prev, dindex_prev, latIndex, prevLatIndex, nPIntp, nPTotal, &
            & prevlatOrder, prevlat, latOrder, orbitStatus, latStartIndex, latEndIndex
       
       REAL (r8), DIMENSION(37, 3496) :: read_prec 
       REAL (r8), DIMENSION(37) :: read_pressure 

       REAL (r8), DIMENSION(83) :: timeDiff_asc_to_des, timeDiff_des_to_asc 

       Logical bfound, binaction
       INTEGER npMissing, npIndex, maxDays

       REAL (r8), POINTER, DIMENSION(:) :: ioTimeArray, ioValueArray, ioLatArray, ioLonArray, &
            &                              ioGeodArray, ioPrecArray, ioLonNewArray

       !*** Initilize the timeDiff_asc_to_des, timeDiff_des_to_asc
 
       latRange = 8.0

       timeDiff_des_to_asc = (/ 0.0, &
                                190.156,  290.521,  376.161,  455.367,  531.078,  604.537,  676.494,  747.424,  817.580,  887.059, &
                                956.125, 1024.869, 1093.288, 1161.432, 1229.357, 1297.078, 1364.655, 1432.178, 1499.502, 1566.795, &
                               1633.957, 1701.070, 1768.077, 1835.055, 1902.000, 1968.812, 2035.705, 2102.527, 2169.208, 2235.945, &
                               2302.584, 2369.311, 2435.913, 2502.582, 2569.186, 2635.781, 2702.395, 2768.886, 2835.555, 2902.073, &
                               2968.733, 3035.184, 3101.706, 3168.211, 3234.851, 3301.390, 3367.921, 3434.550, 3501.134, 3567.662, &
                               3634.334, 3700.963, 3767.612, 3834.309, 3901.051, 3967.798, 4034.556, 4101.489, 4168.244, 4235.218, &
                               4302.215, 4369.293, 4436.466, 4503.766, 4571.024, 4638.574, 4706.177, 4774.006, 4842.007, 4910.293, &
                               4978.839, 5047.746, 5117.202, 5187.135, 5257.944, 5329.738, 5403.078, 5478.616, 5557.638, 5643.114, &
                               5743.230, &
                                0.0 /)
       timeDiff_asc_to_des = (/ 0.0, &
                               5742.843, 5642.495, 5556.851, 5477.603, 5401.936, 5328.448, 5256.506, 5185.599, 5115.440, 5045.933, &
                               4976.886, 4908.115, 4839.720, 4771.568, 4703.624, 4635.913, 4568.349, 4500.825, 4433.535, 4366.219, &
                               4299.075, 4231.939, 4164.947, 4097.938, 4031.027, 3964.192, 3897.299, 3830.525, 3763.786, 3697.070, &
                               3630.410, 3563.683, 3497.089, 3430.443, 3363.846, 3297.237, 3230.593, 3164.122, 3097.461, 3030.924, &
                               2964.288, 2897.837, 2831.291, 2764.801, 2698.158, 2631.620, 2565.056, 2498.508, 2431.901, 2365.329, &
                               2298.671, 2232.051, 2165.394, 2098.696, 2031.967, 1965.198, 1898.439, 1831.531, 1764.703, 1697.760, &
                               1630.782, 1563.703, 1496.558, 1429.211, 1361.990, 1294.430, 1226.814, 1159.022, 1090.977, 1022.685, &
                                954.157,  885.204,  815.793,  745.821,  675.002,  603.197,  529.881,  454.363,  375.302,  289.864, &
                                189.772, &
                                0.0 /)

       !*** Calculate the number of points in each pressure level 
       
       nPIntp = 10
       nPd = 15
       maxDays = 31  ! need to allocate more in case of missing days
 
       ! testing the missing day for Oct 2005 data: l2Days + 1
       !l2Days = l2Days + 1  ! testing
 
       nterms = 0
       DO I = 1, l2Days
          nterms = nterms + l2gp(I)%nTimes
       ENDDO
       
       !*** Allocate space for all the arrays
          
       ALLOCATE(latIntp(1), STAT=error)
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' latIntp array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
          
       ALLOCATE(resultIntp(1), STAT=error)
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' resultIntp array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
          
       ALLOCATE(resultTimesIntp(1), STAT=error)
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' resultIntp array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
          
       ALLOCATE(resultLonsIntp(1), STAT=error)
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' resultIntp array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
          
       ALLOCATE(resultPrecIntp(1), STAT=error)
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' resultIntp array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
          
       
       if ((nterms.gt.0).and.( (pEndIndex-pStartIndex).ge.0) ) then 
          
          ALLOCATE(l2Times(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Times array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(l2GeodAngle(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2GeodAngle array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          
          ALLOCATE(l2Lons(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Lons array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          
          ALLOCATE(l2Lats(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Lats array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          
          ALLOCATE(l2Values(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Values array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(l2Prec(nterms, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Prec array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(l2Qual(nterms), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Qual array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(l2Status(nterms), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' l2Status array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
       endif
       
       if ( (cfProd%nLats.gt.0).and. & 
            & ( (pEndIndex-pStartIndex).ge.0).and.(nPd*l2Days.gt.0)  ) then 
          
          ALLOCATE(alons_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' alons_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(alats_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' alats_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(atimes_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' atimes_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(afields_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' afields_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(aprec_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' aprec_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(dlons_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dlons_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(dlats_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dlats_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(dtimes_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dtimes_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(dfields_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dfields_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
          ALLOCATE(dprec_interp(cfProd%nLats, nPd*maxDays+1, & 
               pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dprec_interp array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
          
       endif
 
       !*** Re-arrange the data into longitude order for each pressure level 
       
       DO kP = pStartIndex, pEndIndex
          perMisPoints(kP+1-pStartIndex) = 0
          numData(kP+1-pStartIndex) = 0
       ENDDO

!***********************************************************************
       
       nstart = 1
       DO iD = 1, l2Days
	  DO iT = 1, l2gp(iD)%nTimes
             iP = 0
             DO kP = pStartIndex, pEndIndex 
	        iP = iP + 1
                l2Times(nstart, iP)     = l2gp(iD)%time(iT)
                l2GeodAngle(nstart, iP) = l2gp(iD)%geodAngle(iT)
                !l2Lons(nstart, iP)     = l2gp(iD)%longitude(iT) * PI/180.0
                !l2Lons_old(nstart, iP) = l2gp(iD)%longitude(iT) * PI/180.0
                l2Lons(nstart, iP)      = l2gp(iD)%longitude(iT)
                l2Lats(nstart, iP)      = l2gp(iD)%latitude(iT)
                l2Values(nstart, iP)    = l2gp(iD)%l2gpValue(1, kP, iT) 
		l2Prec(nstart, iP)      = l2gp(iD)%l2gpPrecision(1, kP, iT)
		l2Qual(nstart)          = l2gp(iD)%Quality(iT)
		l2Status(nstart)        = l2gp(iD)%Status(iT)
                numData(iP)             = numData(iP) + 1
                !IF(l2gp(iD)%l2gpValue(1, kP, iT) == -999.99) THEN 
                IF(isGoodData(l2Values(nstart, iP), l2Qual(nstart), l2Status(nstart)) ) THEN
                   perMisPoints(iP)  = perMisPoints(iP) + 1     ! Good Points
                ENDIF
             ENDDO
             nstart = nstart + 1
	  ENDDO
       ENDDO

       DO kP = pStartIndex, pEndIndex
          if (numData(kP+1-pStartIndex).ne.0) then 
             perMisPoints(kP+1-pStartIndex) = 100.0-100.0*perMisPoints(kP+1-pStartIndex)/(l2Days*3494)
                  !&100*perMisPoints(kP+1-pStartIndex)/numData(kP+1-pStartIndex)
          endif
       ENDDO
       
       !*** Prepare Data for L3 Processing (Convert time reference to the starting point)
       
       iP = 0
       DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
          !sTime = l2Times(1, iP)
          DO k = 1, nterms
             if(l2Times(k, iP) > 0) then
               sTime = l2Times(k, iP)
               exit
             endif
          ENDDO
          
          anlats(1, iP) = 0 
          anlats(cfProd%nLats, iP) = 0 
          dnlats(1, iP) = 0 
          dnlats(cfProd%nLats, iP) = 0 

          DO J = 2, cfProd%nLats-1
            anlats(J, iP) = 0 
            dnlats(J, iP) = 0 

            iL = 0
            binaction = .false.
	    DO iT = 1, nterms 
              IF( abs(l2Lats(iT, iP)-cfProd%latGridMap(J)) <= latRange*0.5 ) THEN 
	        iL = iL + 1
                if(iL == 1) then
                  binaction = .true.
                  orbitStatus = isAscending(l2GeodAngle(iT, iP))
                  firstTime = l2Times(iT, iP)
                end if
     
                if(isAscending(l2GeodAngle(iT, iP)) == orbitStatus &
                   & .and. isGoodData(l2Values(iT, iP), l2Qual(iT), l2Status(iT)) & 
                   !& .and. l2Values(iT, iP) /= -999.99 & 
                   & .and. (l2Times(iT, iP)-firstTime) < 250.0 & 
                   & .and. binaction) then
                  Call ExpandArray(ioValueArray, l2Values(iT, iP))
                  Call ExpandArray(ioPrecArray, l2Prec(iT, iP))
                  Call ExpandArray(ioTimeArray, l2Times(iT, iP))
                  Call ExpandArray(ioLatArray, l2Lats(iT, iP))
                  Call ExpandArray(ioLonArray, l2Lons(iT, iP))
                  !Call ExpandArray(ioGeodArray, l2GeodAngle(iT, iP))
                else if(isAscending(l2GeodAngle(iT, iP)) /= orbitStatus &
                   & .or. (l2Times(iT, iP)-firstTime) > 250.0 ) then
                  iL = 0
                  binaction = .false.
                  latIntp(1) = cfProd%latGridMap(J)

                  if(associated(ioLatArray) .and. size(ioLatArray) > 1) then

                    ALLOCATE(ioLonNewArray(size(ioLonArray)), STAT=error)
                    IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' ioLonNewArray array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF

                    nr = 0
                    ioLonNewArray(1) = ioLonArray(1)
	            DO i = 2, size(ioLonArray)
                      if(ioLonArray(i) >= 0.0 .and. ioLonArray(i-1) < 0.0) then
                         ioLonNewArray(i) = ioLonArray(i) - nr*360.0 - 360.0
                         nr = nr + 1
                      else
                         ioLonNewArray(i) = ioLonArray(i) - nr*360.0
                      endif
                    enddo 
	            DO i = 1, size(ioLonArray)
                    enddo

               !write(*,'(10(1pE11.3))') (ioValueArray(i), i=1, size(ioValueArray))
                    call InterpolateValues ( &
                                           & ioLatArray, &                  ! OldX
                                           & ioValueArray, &                ! OldY
                                           & latIntp, &                     ! NewX
                                           & resultIntp, &                  ! NewY
                                           & 'Linear', &                    ! use linear
                                           & extrapolate='Constant' )       ! No extrapolation
               !write(*,'(10(1pE11.3))') resultIntp(1) 
                    call InterpolateValues ( &
                                           & ioLatArray, &                  ! OldX
                                           & ioPrecArray, &                ! OldY
                                           & latIntp, &                     ! NewX
                                           & resultPrecIntp, &                  ! NewY
                                           & 'Linear', &                    ! use linear
                                           & extrapolate='Constant' )       ! No extrapolation
                    call InterpolateValues ( &
                                           & ioLatArray, &                  ! OldX
                                           & ioLonNewArray, &                ! OldY
                                           & latIntp, &                     ! NewX
                                           & resultLonsIntp, &                  ! NewY
                                           & 'Linear', &                    ! use linear
                                           & extrapolate='Constant' )       ! No extrapolation
                    if ( associated(ioLonNewArray) ) then
                      DEALLOCATE(ioLonNewArray, STAT=error)
                      IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioLonNewArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                    endif
                    call InterpolateValues ( &
                                           & ioLatArray, &                  ! OldX
                                           & ioTimeArray, &                ! OldY
                                           & latIntp, &                     ! NewX
                                           & resultTimesIntp, &                  ! NewY
                                           & 'Linear', &                    ! use linear
                                           & extrapolate='Constant' )       ! No extrapolation

                    IF( orbitStatus == 1) THEN                    
                      anlats(J, iP) = anlats(J, iP) + 1 
                      alats_interp(J, anlats(J, iP), iP)   = cfProd%latGridMap(J) 
                      atimes_interp(J, anlats(J, iP), iP)  = resultTimesIntp(1)
                      afields_interp(J, anlats(J, iP), iP) = resultIntp(1)
                      aprec_interp(J, anlats(J, iP), iP)   = resultPrecIntp(1)
                      if(resultLonsIntp(1) < -180.0) then
                         alons_interp(J, anlats(J, iP), iP)   = resultLonsIntp(1) + 360.0
                      else
                         alons_interp(J, anlats(J, iP), iP)   = resultLonsIntp(1)
                      endif
                    END IF
          
                    IF( orbitStatus == 2) THEN
                      IF(anlats(J, iP) > 0) THEN
                        dnlats(J, iP) = dnlats(J, iP) + 1 
                        dlats_interp(J, dnlats(J, iP), iP)   = cfProd%latGridMap(J) 
                        dtimes_interp(J, dnlats(J, iP), iP)  = resultTimesIntp(1)
                        dfields_interp(J, dnlats(J, iP), iP) = resultIntp(1)
                        dprec_interp(J, dnlats(J, iP), iP)   = resultPrecIntp(1)
                        if(resultLonsIntp(1) < -180.0) then
                          dlons_interp(J, dnlats(J, iP), iP)   = resultLonsIntp(1) + 360.0
                        else
                          dlons_interp(J, dnlats(J, iP), iP)   = resultLonsIntp(1)
                        endif
                      END IF
                    END IF
              
                  endif

                  if ( associated(ioValueArray) ) then
                    DEALLOCATE(ioValueArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioValueArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
                  endif
                  if ( associated(ioTimeArray) ) then
                    DEALLOCATE(ioTimeArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioTimeArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
                  endif
                  if ( associated(ioLatArray) ) then
                    DEALLOCATE(ioLatArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioLatArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
                  endif
                  if ( associated(ioLonArray) ) then
                    DEALLOCATE(ioLonArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioLonArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
                  endif
                  if ( associated(ioPrecArray) ) then
                    DEALLOCATE(ioPrecArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioPrecArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
                  endif

                endif 

              ENDIF
            ENDDO

            ! Modify data for the missing data points
            !** Ascending
            npMissing = 0
            DO iT = 1, anlats(J, iP)-1
              !if(atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP) < 5930.0) then
                 !print *, anlats(J, iP), iT, atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP), int((atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP))/5800.0)
                !print *, anlats(J, iP), iT, atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP), int((atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP))/5800.0), &
                !  &       afields_interp(J, iT, iP)
              !endif
              if(atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP) > 6000.0) then
                npMissing = npMissing + int((atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP))/5800.0)-1
              endif
            ENDDO
            !print *, 'ascending missing=', iP, pEndIndex-pStartIndex, J, cfProd%latGridMap(J), npMissing

            ALLOCATE(ioTimeArray(anlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioTimeArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioValueArray(anlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioValueArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioPrecArray(anlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioPrecArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioLonArray(anlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioLonArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            npIndex = 1 
            DO iT = 1, anlats(J, iP)-1
              ioTimeArray(npIndex) = atimes_interp(J, iT, iP)
              ioValueArray(npIndex) = afields_interp(J, iT, iP)
              ioPrecArray(npIndex) = aprec_interp(J, iT, iP)
              ioLonArray(npIndex) = alons_interp(J, iT, iP)
              DO iL = 1, int((atimes_interp(J, iT+1, iP) - atimes_interp(J, iT, iP))/5800.0)-1 
                 npIndex = npIndex + 1
                 ioTimeArray(npIndex) = atimes_interp(J, iT, iP) + 5933.0*iL
                 ioValueArray(npIndex) = -999.99 
                 ioPrecArray(npIndex) = -999.99 
                 ioLonArray(npIndex) = alons_interp(J, iT, iP) - 24.72*iL
                 if(ioLonArray(npIndex) < -180.0) then
                   ioLonArray(npIndex) = 360.0 + ioLonArray(npIndex)
                 endif
              ENDDO
              npIndex = npIndex + 1
            ENDDO
            ioTimeArray(npIndex) = atimes_interp(J, anlats(J, iP), iP)
            ioValueArray(npIndex) = afields_interp(J, anlats(J, iP), iP)
            ioPrecArray(npIndex) = aprec_interp(J, anlats(J, iP), iP)
            ioLonArray(npIndex) = alons_interp(J, anlats(J, iP), iP)

            call InterpolateValues ( &
                                     & atimes_interp(J, 1:anlats(J, iP), iP), &                  ! OldX
                                     & afields_interp(J, 1:anlats(J, iP), iP), &                 ! OldY
                                     & ioTimeArray, &                                            ! NewX
                                     & ioValueArray, &                                           ! NewY
                                     & 'Linear', &                                               ! use linear
                                     & extrapolate='Constant' )                                  ! No extrapolation

            call InterpolateValues ( &
                                     & atimes_interp(J, 1:anlats(J, iP), iP), &                  ! OldX
                                     & aprec_interp(J, 1:anlats(J, iP), iP), &                 ! OldY
                                     & ioTimeArray, &                                            ! NewX
                                     & ioPrecArray, &                                           ! NewY
                                     & 'Linear', &                                               ! use linear
                                     & extrapolate='Constant' )                                  ! No extrapolation

            !if(ioValueArray(iT) < 0) then
            !    write(*,*) iT, afields_interp(J, iT, iP), ioValueArray(iT)
            !endif
            if(npIndex > anlats(J, iP)) then
               !write(*,'(10(1pE11.3))') (afields_interp(J, iT, iP), atimes_interp(J, iT, iP), iT=1, anlats(J, iP))
            endif
!            k = 1
!            DO iT = 1, anlats(J, iP)
!               if(afields_interp(J, iT, iP) < 0) then
!                 k = 0
!               endif
!            enddo
!            if(k == 0) then
!               !write(*,*) J, iP,  anlats(J, iP)
!               !write(*,'(10(1pE11.3))') (afields_interp(J, iT, iP), iT=1, anlats(J, iP))
!            endif
!            k = 1
            DO iT = 1, size(ioTimeArray) 
               afields_interp(J, iT, iP) = ioValueArray(iT)
!               if(ioValueArray(iT) < 0) then
!                 k = 0
!               endif
               aprec_interp(J, iT, iP) = ioPrecArray(iT)
               atimes_interp(J, iT, iP) = (ioTimeArray(iT)-sTime)/86400.0
               alats_interp(J, iT, iP) = cfProd%latGridMap(J) 
               alons_interp(J, iT, iP) = ioLonArray(iT)*PI/180.0 - 2.0*PI*(iT-1)
            ENDDO
            anlats(J, iP) = anlats(J, iP) + npMissing

!            if(k == 0) then
               !write(*,'(10(1pE11.3))') (afields_interp(J, iT, iP), atimes_interp(J, iT, iP), iT=1, anlats(J, iP))
               !write(*,*) J, iP,  anlats(J, iP)
               !write(*,'(10(1pE11.3))') (afields_interp(J, iT, iP), iT=1, anlats(J, iP))
!            endif

            if ( associated(ioValueArray) ) then
                    DEALLOCATE(ioValueArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioValueArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioTimeArray) ) then
                    DEALLOCATE(ioTimeArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioTimeArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioLatArray) ) then
                    DEALLOCATE(ioLatArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioatnArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioLonArray) ) then
                    DEALLOCATE(ioLonArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioLonArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioPrecArray) ) then
                    DEALLOCATE(ioPrecArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioPrecArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif

            !** Descending
            npMissing = 0
            DO iT = 1, dnlats(J, iP)-1
              if(dtimes_interp(J, iT+1, iP) - dtimes_interp(J, iT, iP) > 6000.0) then
                npMissing = npMissing + int((dtimes_interp(J, iT+1, iP) - dtimes_interp(J, iT, iP))/5800.0)-1
              endif
            ENDDO

            ALLOCATE(ioTimeArray(dnlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioTimeArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioValueArray(dnlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioValueArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioPrecArray(dnlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioPrecArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            ALLOCATE(ioLonArray(dnlats(J, iP)+npMissing), STAT=error)
            IF ( error /= 0 ) THEN
               msr = MLSMSG_Allocate // ' ioLonArray array.'
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
            ENDIF

            npIndex = 1 
            DO iT = 1, dnlats(J, iP)-1
              ioTimeArray(npIndex) = dtimes_interp(J, iT, iP)
              ioValueArray(npIndex) = dfields_interp(J, iT, iP)
              ioPrecArray(npIndex) = dprec_interp(J, iT, iP)
              ioLonArray(npIndex) = dlons_interp(J, iT, iP)
              DO iL = 1, int((dtimes_interp(J, iT+1, iP) - dtimes_interp(J, iT, iP))/5800.0)-1 
                 npIndex = npIndex + 1
                 ioTimeArray(npIndex) = dtimes_interp(J, iT, iP) + 5933.0*iL
                 ioValueArray(npIndex) = -999.99 
                 ioPrecArray(npIndex) = -999.99 
                 ioLonArray(npIndex) = dlons_interp(J, iT, iP) - 24.72*iL
                 if(ioLonArray(npIndex) < -180.0) then
                   ioLonArray(npIndex) = 360.0 + ioLonArray(npIndex)
                 endif
              ENDDO
              npIndex = npIndex + 1
            ENDDO
            ioTimeArray(npIndex) = dtimes_interp(J, dnlats(J, iP), iP)
            ioValueArray(npIndex) = dfields_interp(J, dnlats(J, iP), iP)
            ioPrecArray(npIndex) = dprec_interp(J, dnlats(J, iP), iP)
            ioLonArray(npIndex) = dlons_interp(J, dnlats(J, iP), iP)

            call InterpolateValues ( &
                                     & dtimes_interp(J, 1:dnlats(J, iP), iP), &                  ! OldX
                                     & dfields_interp(J, 1:dnlats(J, iP), iP), &                 ! OldY
                                     & ioTimeArray, &                                            ! NewX
                                     & ioValueArray, &                                           ! NewY
                                     & 'Linear', &                                               ! use linear
                                     & extrapolate='Constant' )                                  ! No extrapolation

            call InterpolateValues ( &
                                     & dtimes_interp(J, 1:dnlats(J, iP), iP), &                  ! OldX
                                     & dprec_interp(J, 1:dnlats(J, iP), iP), &                 ! OldY
                                     & ioTimeArray, &                                            ! NewX
                                     & ioPrecArray, &                                           ! NewY
                                     & 'Linear', &                                               ! use linear
                                     & extrapolate='Constant' )                                  ! No extrapolation

            DO iT = 1, size(ioTimeArray) 
               dfields_interp(J, iT, iP) = ioValueArray(iT)
               dprec_interp(J, iT, iP) = ioPrecArray(iT)
               dtimes_interp(J, iT, iP) = (ioTimeArray(iT)-sTime)/86400.0
               dlats_interp(J, iT, iP) = cfProd%latGridMap(J) 
               dlons_interp(J, iT, iP) = ioLonArray(iT)*PI/180.0 - 2.0*PI*(iT-1)
            ENDDO
            dnlats(J, iP) = dnlats(J, iP) + npMissing

            if ( associated(ioValueArray) ) then
                    DEALLOCATE(ioValueArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioValueArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioTimeArray) ) then
                    DEALLOCATE(ioTimeArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioTimeArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioLatArray) ) then
                    DEALLOCATE(ioLatArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioatnArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioLonArray) ) then
                    DEALLOCATE(ioLonArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioLonArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif
            if ( associated(ioPrecArray) ) then
                    DEALLOCATE(ioPrecArray, STAT=error)
                    IF ( error /= 0 ) THEN
                       msr = MLSMSG_DeAllocate // '  ioPrecArray pointer.'
                       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                    ENDIF
            endif

          ENDDO

       ENDDO
       
       !*** Find averaged asc/des time difference 
       
       iP = 0
       DO kP = pStartIndex, pEndIndex 
          iP = iP + 1
          DO J = 1, cfProd%nLats
             delTad(J,iP) = 0.0
             IF (anlats(J, iP) < dnlats(J, iP)) THEN
                iMin = anlats(J, iP)
             ELSE
                iMin = dnlats(J, iP)
             END IF
             DO I = 2, iMin 
                delTad(J,iP) = & 
                     & delTad(J,iP) + dtimes_interp(J, I, iP) & 
                     & - atimes_interp(J, I, iP)
        !write(1, *) iP, J, I, dtimes_interp(J, I, iP), atimes_interp(J, I, iP) 
        !write(*, *) iP, J, I, dtimes_interp(J, I, iP), atimes_interp(J, I, iP) , tau0
             ENDDO
             IF(iMin > 0) THEN
                if (iMin .ne. 1) delTad(J,iP) = delTad(J,iP)/float(iMin-1)
             ELSE
                delTad(J,iP) = 0.0 
             END IF
             
             IF(delTad(J,iP) < 0) THEN
                delTad(J,iP) = delTad(J,iP) + tau0 
             END IF
        !write(*, *) iP, J, delTad(J,iP), tau0
          ENDDO
       ENDDO
       
       !*** Deallocate intermediate arrays 
       
       if ((nterms.gt.0).and.( (pEndIndex-pStartIndex).ge.0) ) then 
          
          if ( associated(l2Times) ) then
             DEALLOCATE(l2Times, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Times pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2GeodAngle) ) then
             DEALLOCATE(l2GeodAngle, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2GeodAngle pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Lons) ) then 
             DEALLOCATE(l2Lons, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Lons pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Lats) ) then
             DEALLOCATE(l2Lats, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Lats pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Values) ) then
             DEALLOCATE(l2Values, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Values pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Prec) ) then
             DEALLOCATE(l2Prec, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Prec pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Qual) ) then
             DEALLOCATE(l2Qual, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Qual pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Status) ) then
             DEALLOCATE(l2Status, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Status pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
       endif
 
     !-----------------------------------
     END SUBROUTINE SortData
     !-----------------------------------


     !-------------------------------------------------------------------------
     Subroutine ExpandArray(ioArray, value)
     !-------------------------------------------------------------------------

     ! This routine adds to the ioArray arrays 

     ! Dummy arguments
     REAL (r8), POINTER, DIMENSION(:) :: ioArray 
     Real (r8), intent(in) :: value

     ! Local variables
     REAL (r8), POINTER, DIMENSION(:) :: tempArray => null()
     integer :: newsize
     integer :: status
     if ( associated(ioArray) ) then
        newSize=SIZE(ioArray)+1
     else
        newSize=1
     end if
     if(newSize == 1) then
        allocate(ioArray(newSize),STAT=status)
        if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "ioArray")
        ioArray(newSize) = value
        return
     endif
     allocate(tempArray(newSize),STAT=status)
     if ( status/=0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // "temp ioArray")
     if ( newSize>1 ) tempArray(1:newSize-1) = ioArray 
     if ( ASSOCIATED(ioArray) ) &
      & deallocate ( ioArray, stat=status )
     if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_DeAllocate // "ioArray" )
     ioArray => tempArray
     ioArray(newSize) = value

      !-----------------------------------
     END Subroutine ExpandArray
     !-----------------------------------

     !-------------------------------------------------------------------------
     Logical FUNCTION isGoodData(value, qual, status)
     !-------------------------------------------------------------------------
  
       Real(r8) value, qual
       Integer status

       IF(value == -999.99 .or. qual < 0.0 .or. status < 0 .or. mod(status, 2) == 1) THEN
          isGoodData = .false. 
       ELSE 
          isGoodData = .true. 
       END IF

      !-----------------------------------
     END FUNCTION isGoodData
     !-----------------------------------

     !-------------------------------------------------------------------------
     Integer FUNCTION isAscending(geodAngle)
     !-------------------------------------------------------------------------
  
       Real(r8) modGeod, geodAngle

       IF(geodAngle > -360.0) THEN
          modGeod = mod(geodAngle, 360.0_r8)
          IF(modGeod < 0.0) THEN
            modGeod = modGeod + 360.0
          ENd IF
          IF(modGeod < 90.0 .OR. modGeod >= 270.0) THEN
            isAscending = 1
          ELSE IF(modGeod >= 90.0 .AND. modGeod < 270.0) THEN
            isAscending = 2
          ELSE 
            isAscending = 0 
          END IF
       ELSE 
          isAscending = 0 
       END IF

      !-----------------------------------
     END FUNCTION isAscending
     !-----------------------------------


     !-------------------------------------------------------------------------
     REAL(r8) FUNCTION FindRealLon(alon)
     !-------------------------------------------------------------------------
  USE SDPToolkit, ONLY: PI
  
       Real, intent(in) :: alon
  
       IF(mod(alon, 2.0*PI) < -PI) THEN
          FindRealLon = 2.0*PI + mod(alon, 2.0*PI) 
       ELSE IF(mod(alon, 2.0*PI) > PI) THEN
          FindRealLon = -2.0*PI + mod(alon, 2.0*PI) 
       ELSE 
          FindRealLon = mod(alon, 2.0*PI) 
       END IF
       
      !-----------------------------------
     END FUNCTION FindRealLon
     !-----------------------------------

     
     !-------------------------------------------------------------------------
     SUBROUTINE Residual2L2Grid( iD, iP, iN, l3r_temp, l3r ) 
     !-------------------------------------------------------------------------
  
       TYPE( L2GPData_T ), POINTER :: l3r(:)
       TYPE( L2GPData_T ), POINTER :: l3r_temp(:)
       INTEGER, INTENT(IN) :: iD, iP, iN
       
!       integer :: error, i, j, iT, icount, l2Days, nloop, aindex, & 
!            aindex_prev, dindex_prev

       INTEGER :: i, j, icount, startTime, endTime
       
       DO i = 1, l3r_temp(iD)%nTimes
         if(l3r_temp(iD)%time(i) > 0) then
            startTime = l3r_temp(iD)%time(i)
            exit
         endif
       ENDDO
       
       DO i = l3r_temp(iD)%nTimes, 1, -1
         if(l3r_temp(iD)%time(i) > 0) then
            endTime = l3r_temp(iD)%time(i)
            exit
         endif
       ENDDO

       icount = 1
       DO I = 1, l3r(iD)%nTimes 
          DO J = icount, l3r_temp(iD)%nTimes 
             If( l3r(iD)%time(I) < startTime .OR. & 
                  !& l3r(iD)%time(I) > l3r_temp(iD)%time(l3r(iD)%nTimes) ) Then
                  & l3r(iD)%time(I) > endTime ) Then
                l3r(iD)%l2gpValue(1,iP, I) = -999.99 
                EXIT
             ELSE IF (J .LT. l3r_temp(iD)%nTimes) THEN
                If(   (l3r(iD)%time(I) > 0 .AND. l3r_temp(iD)%time(J) > 0 .AND. l3r_temp(iD)%time(J+1) > 0 ) .AND. &
                    & l3r(iD)%time(I) > l3r_temp(iD)%time(J) .AND. & 
                    & l3r(iD)%time(I) < l3r_temp(iD)%time(J+1) ) Then
                   
                   l3r(iD)%l2gpValue(1, iP, I) =  & 
                        & l3r_temp(iD)%l2gpValue(1, iN, J) + &
                        & (l3r(iD)%time(I) - l3r_temp(iD)%time(J))*&
                        & (l3r_temp(iD)%l2gpValue(1, iN, J+1) - & 
                        & l3r_temp(iD)%l2gpValue(1, iN, J))/	&
                        & (l3r_temp(iD)%time(J+1) - l3r_temp(iD)%time(J))
                   If( J > icount) Then
                      icount = J
                   End If
                   EXIT
                End If
             ENDIF
          ENDDO
       ENDDO
  
     !-----------------------------------
     END SUBROUTINE Residual2L2Grid
     !-----------------------------------

     subroutine my_sortp_r4(sngl_array, n, m, pt_array)
       real(r4), dimension(*), intent(in) :: sngl_array
       integer, intent(in)                :: n
       integer, intent(in)                :: m
       integer, dimension(*), intent(out) :: pt_array
       call ssortp(sngl_array, n, m, pt_array)
     end subroutine my_sortp_r4
     
     subroutine my_sortp_r8(dbl_array, n, m, pt_array)
       real(r8), dimension(*), intent(in) :: dbl_array
       integer, intent(in)                :: n
       integer, intent(in)                :: m
       integer, dimension(*), intent(out) :: pt_array
       call dsortp(dbl_array, n, m, pt_array)
     end subroutine my_sortp_r8
     
     !===================
   END MODULE Synoptic
!===================

! $Log: Synoptic.f90,v $
! Revision 1.40  2006/05/24 19:14:30  cvuu
! Fix the deallocate problem
!
! Revision 1.39  2006/02/28 17:56:56  cvuu
! V2.00 commit
!
! Revision 1.37  2004/09/30 17:53:10  cvuu
! bug fixes
!
! Revision 1.36  2004/06/22 16:55:47  cvuu
! Using SetupNewL2GPRecord for L3 Residual based on the nLevels from L3 not L2
!
! Revision 1.35  2004/06/02 20:07:28  ybj
! *** empty log message ***
!
! Revision 1.34  2004/05/13 23:50:52  ybj
! *** empty log message ***
!
! Revision 1.33  2004/05/06 13:16:46  cvuu
! remove print statements
!
! Revision 1.32  2004/05/04 15:33:15  cvuu
! v1.4.3: Use int array for Date in Data Field
!
! Revision 1.31  2004/01/07 21:43:18  cvuu
! version 1.4 commit
!
! Revision 1.30  2003/04/30 18:15:48  pwagner
! Work-around for LF95 infinite compile-time bug
!
! Revision 1.29  2003/03/22 02:59:22  jdone
! individual allocate/deallocate, use only and indentation added
!
! Revision 1.28  2003/02/06 19:51:31  pwagner
! Fixed problem arising from different num types in calls to _sortp
!
! Revision 1.27  2002/05/08 16:23:47  ybj
! Fix residual problem in order to interpolate to L2GP grid
!
! Revision 1.26  2002/04/30 20:05:21  jdone
! indexing issues related to nc* arrays
!
! Revision 1.25  2002/04/11 00:53:57  jdone
! initialization added
!
! Revision 1.24  2002/04/10 21:30:33  jdone
! associated statements before deallocate added
!
! Revision 1.23  2002/04/01 21:57:13  jdone
! check division by zero
!
! Revision 1.22  2002/03/27 22:45:17  jdone
! deallocate statements added
!
! Revision 1.21  2002/03/27 21:35:14  jdone
! allocate statements checked and maxDiff is initialized
!
! Revision 1.20  2002/02/20 22:30:33  ybj
! *** empty log message ***
!
! Revision 1.19  2002/02/20 22:13:54  ybj
! *** empty log message ***
!
! Revision 1.18  2001/09/27 20:38:31  ybj
! Add Precision Calculation & ado mode
!
! Revision 1.17  2001/09/27 20:07:14  ybj
! Add Precision Calculation
!
! Revision 1.16  2001/09/06 18:45:37  nakamura
! Initialized pStart/EndIndex; removed some unused variables.
!
! Revision 1.15  2001/08/13 19:28:03  ybj
! *** empty log message ***
!
! Revision 1.14  2001/08/13 16:42:20  ybj
! *** empty log message ***
!
! Revision 1.13  2001/04/12 16:04:41  ybj
! reasonable values
!
! Revision 1.12  2001/04/11 18:29:22  ybj
! reasonable values
!
! Revision 1.11  2001/03/08 00:53:15  ybj
! *** empty log message ***
!
! Revision 1.10  2001/03/08 00:37:17  ybj
! *** empty log message ***
!
! Revision 1.9  2001/03/07 23:12:15  ybj
! *** empty log message ***
!
! Revision 1.8  2001/03/05 19:58:59  ybj
! with selected pressure levels
!
! Revision 1.7  2001/03/03 01:38:02  ybj
! with selected pressure levels
!
! Revision 1.6  2001/03/03 00:45:44  ybj
! with selected pressure levels
!
! Revision 1.5  2001/03/03 00:20:07  ybj
! with selected pressure levels
!
! Revision 1.3  2001/02/28 19:27:03  ybj
! Fix residue allocation & flags initialization
!
! Revision 1.2  2001/02/28 17:15:06  ybj
! Fix residue structure alocation
!
! Revision 1.1  2001/02/27 20:51:28  ybj
! Daily Map Core Processing
!
! Revision 1.1  2000/10/05 18:38:48  nakamura
! Program split from synoptic.f90 and modified to be more like the standard template.
!


@


1.40
log
@Fix the deallocate problem
@
text
@d29 1
a29 1
       "$Id: Synoptic.f90,v 1.39 2006/02/28 17:56:56 cvuu Exp $"
d3828 1
a3828 1
          modGeod = mod(geodAngle, 360.0)
d3948 3
@


1.39
log
@V2.00 commit
@
text
@d18 1
a18 1
       & MLSMSG_DEALLOCATE
d29 1
a29 1
       "$Id: Synoptic.f90,v 1.37 2004/09/30 17:53:10 cvuu Exp $"
d3901 1
a3901 1
                l3r(iD)%l2gpValue(0,iP, I) = -999.99 
d3908 1
a3908 2
                   !l3r(iD)%l2gpValue(1, iP, I) =  & 
                   l3r(iD)%l2gpValue(0,iP, I) =  & 
d3948 3
@


1.38
log
@Reworded Copyright statement, moved rcs id
@
text
@d2 2
a3 10
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.
d24 2
a25 1
  public :: DailyCoreProcessing
d27 5
a31 5
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------
d103 2
a104 2
         & mis_l2Days_temp, i, j, iP, kP, iD, iL, n,m, &
	 & totalIndex
d130 1
d166 1
a166 1
     
d175 4
a178 4
       l3sp(j)%l3spRelValue = 0.0 
       l3sp(j)%l3spRelPrecision = 0.0 
       l3sp(j)%l3spImgValue = 0.0 
       l3sp(j)%l3spImgPrecision = 0.0 
d184 4
a187 4
       l3spPrec(j)%l3spRelValue = 0.0
       l3spPrec(j)%l3spRelPrecision = 0.0
       l3spPrec(j)%l3spImgValue = 0.0
       l3spPrec(j)%l3spImgPrecision = 0.0
d192 1
a192 1
     
d209 4
a212 2
             l3dm(j)%l3dmValue = 0.0
             l3dm(j)%l3dmPrecision = 0.0
d215 1
d235 4
a238 2
             dmA(j)%l3dmValue  = 0.0
             dmA(j)%l3dmPrecision  = 0.0
d241 1
d261 4
a264 2
             dmD(j)%l3dmValue  = 0.0
             dmD(j)%l3dmPrecision  = 0.0
d267 1
d299 8
a306 4
             dmA(j)%l3dmValue  = 0.0
             dmD(j)%l3dmValue  = 0.0
             dmA(j)%l3dmPrecision  = 0.0
             dmD(j)%l3dmPrecision  = 0.0
d309 1
d311 2
a313 1
                  dmA(j)%maxDiffTime(n,m)  = 0.0
d354 12
a365 6
             l3dm(j)%l3dmValue = 0.0
             dmA(j)%l3dmValue  = 0.0
             dmD(j)%l3dmValue  = 0.0
             l3dm(j)%l3dmPrecision = 0.0
             dmA(j)%l3dmPrecision  = 0.0
             dmD(j)%l3dmPrecision  = 0.0
d368 1
d370 2
d373 2
a375 2
                  l3dm(j)%maxDiffTime(n,m)  = 0.0
                  dmA(j)%maxDiffTime(n,m)  = 0.0
d416 1
a416 1
   
d421 1
a421 1
       CALL SetupL2GPProd(rDays, totalIndex, l3r_temp(1)%nTimes, l3r)
d424 16
a439 14
	   l3r(j)%chunkNumber = l3r_temp(j)%chunkNumber
	   l3r(j)%solarTime = l3r_temp(j)%solarTime
	   l3r(j)%solarZenith = l3r_temp(j)%solarZenith
	   l3r(j)%losAngle = l3r_temp(j)%losAngle
	   l3r(j)%geodAngle = l3r_temp(j)%geodAngle
	   l3r(j)%pressures = l3r_temp(j)%pressures(pStartIndex:pEndIndex)
	   l3r(j)%latitude = l3r_temp(j)%latitude
	   l3r(j)%longitude = l3r_temp(j)%longitude
	   l3r(j)%time = l3r_temp(j)%time
	   l3r(j)%nTimes = l3r_temp(j)%nTimes
           l3r_temp(j)%l2gpValue    = 0.0
           l3r_temp(j)%latitude     = 0.0
           startTime(j) = l3r_temp(j)%time(1)
           endTime(j) = l3r_temp(j)%time(l3r_temp(j)%nTimes)
d446 1
a446 1
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp(1)%nTimes, residA)
d449 16
a464 15
	   residA(j)%chunkNumber = residA_temp(j)%chunkNumber
	   residA(j)%solarTime = residA_temp(j)%solarTime
	   residA(j)%solarZenith = residA_temp(j)%solarZenith
	   residA(j)%losAngle = residA_temp(j)%losAngle
	   residA(j)%geodAngle = residA_temp(j)%geodAngle
	   residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
	   residA(j)%latitude = residA_temp(j)%latitude
	   residA(j)%longitude = residA_temp(j)%longitude
	   residA(j)%time = residA_temp(j)%time
	   residA(j)%nTimes = residA_temp(j)%nTimes
           residA_temp(j)%l2gpValue = 0.0
           residA_temp(j)%latitude  = 0.0
           residA_temp(j)%longitude = 0.0
           startTime(j) = residA_temp(j)%time(1)
           endTime(j) = residA_temp(j)%time(residA_temp(j)%nTimes)
d471 1
a471 1
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp(1)%nTimes, residD)
d474 16
a489 15
	   residD(j)%chunkNumber = residD_temp(j)%chunkNumber
	   residD(j)%solarTime = residD_temp(j)%solarTime
	   residD(j)%solarZenith = residD_temp(j)%solarZenith
	   residD(j)%losAngle = residD_temp(j)%losAngle
	   residD(j)%geodAngle = residD_temp(j)%geodAngle
	   residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
	   residD(j)%latitude = residD_temp(j)%latitude
	   residD(j)%longitude = residD_temp(j)%longitude
	   residD(j)%time = residD_temp(j)%time
	   residD(j)%nTimes = residD_temp(j)%nTimes
           residD_temp(j)%l2gpValue = 0.0
           residD_temp(j)%latitude  = 0.0
           residD_temp(j)%longitude = 0.0
           startTime(j) = residD_temp(j)%time(1)
           endTime(j) = residD_temp(j)%time(residD_temp(j)%nTimes)
d496 23
a518 2
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp(1)%nTimes, residA)
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
d521 1
a521 2
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp(1)%nTimes, residD)
       residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
a522 1

d524 16
a539 30
	   residA(j)%chunkNumber = residA_temp(j)%chunkNumber
	   residA(j)%solarTime = residA_temp(j)%solarTime
	   residA(j)%solarZenith = residA_temp(j)%solarZenith
	   residA(j)%losAngle = residA_temp(j)%losAngle
	   residA(j)%geodAngle = residA_temp(j)%geodAngle
	   residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
	   residA(j)%latitude = residA_temp(j)%latitude
	   residA(j)%longitude = residA_temp(j)%longitude
	   residA(j)%time = residA_temp(j)%time
	   residA(j)%nTimes = residA_temp(j)%nTimes
           residA_temp(j)%l2gpValue = 0.0
           residA_temp(j)%latitude  = 0.0
           residA_temp(j)%longitude = 0.0
           startTime(j) = residA_temp(j)%time(1)
           endTime(j) = residA_temp(j)%time(residA_temp(j)%nTimes)
	   residD(j)%chunkNumber = residD_temp(j)%chunkNumber
	   residD(j)%solarTime = residD_temp(j)%solarTime
	   residD(j)%solarZenith = residD_temp(j)%solarZenith
	   residD(j)%losAngle = residD_temp(j)%losAngle
	   residD(j)%geodAngle = residD_temp(j)%geodAngle
	   residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
	   residD(j)%latitude = residD_temp(j)%latitude
	   residD(j)%longitude = residD_temp(j)%longitude
	   residD(j)%time = residD_temp(j)%time
	   residD(j)%nTimes = residD_temp(j)%nTimes
           residD_temp(j)%l2gpValue = 0.0
           residD_temp(j)%latitude  = 0.0
           residD_temp(j)%longitude = 0.0
           startTime(j) = residD_temp(j)%time(1)
           endTime(j) = residD_temp(j)%time(residD_temp(j)%nTimes)
d546 1
a546 1
       CALL SetupL2GPProd(rDays, totalIndex, l3r_temp(1)%nTimes, l3r)
d548 1
a548 1
	   & pcf%l3StartDay, & 
d550 3
a552 3
       CALL SetupL2GPProd(rDays, totalIndex, residA_temp(1)%nTimes, residA)
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
           & pcf%l3StartDay, & 
d554 1
a554 1
       CALL SetupL2GPProd(rDays, totalIndex, residD_temp(1)%nTimes, residD)
d559 48
a606 44
	   l3r(j)%chunkNumber = l3r_temp(j)%chunkNumber
	   l3r(j)%solarTime = l3r_temp(j)%solarTime
	   l3r(j)%solarZenith = l3r_temp(j)%solarZenith
	   l3r(j)%losAngle = l3r_temp(j)%losAngle
	   l3r(j)%geodAngle = l3r_temp(j)%geodAngle
	   l3r(j)%pressures = l3r_temp(j)%pressures(pStartIndex:pEndIndex)
	   l3r(j)%latitude = l3r_temp(j)%latitude
	   l3r(j)%longitude = l3r_temp(j)%longitude
	   l3r(j)%time = l3r_temp(j)%time
	   l3r(j)%nTimes = l3r_temp(j)%nTimes
           l3r_temp(j)%l2gpValue    = 0.0
           l3r_temp(j)%latitude     = 0.0
           startTime(j) = l3r_temp(j)%time(1)
           endTime(j) = l3r_temp(j)%time(l3r_temp(j)%nTimes)
	   residA(j)%chunkNumber = residA_temp(j)%chunkNumber
	   residA(j)%solarTime = residA_temp(j)%solarTime
	   residA(j)%solarZenith = residA_temp(j)%solarZenith
	   residA(j)%losAngle = residA_temp(j)%losAngle
	   residA(j)%geodAngle = residA_temp(j)%geodAngle
	   residA(j)%pressures = residA_temp(j)%pressures(pStartIndex:pEndIndex)
	   residA(j)%latitude = residA_temp(j)%latitude
	   residA(j)%longitude = residA_temp(j)%longitude
	   residA(j)%time = residA_temp(j)%time
	   residA(j)%nTimes = residA_temp(j)%nTimes
           residA_temp(j)%l2gpValue = 0.0
           residA_temp(j)%latitude  = 0.0
           residA_temp(j)%longitude = 0.0
           startTime(j) = residA_temp(j)%time(1)
           endTime(j) = residA_temp(j)%time(residA_temp(j)%nTimes)
	   residD(j)%chunkNumber = residD_temp(j)%chunkNumber
	   residD(j)%solarTime = residD_temp(j)%solarTime
	   residD(j)%solarZenith = residD_temp(j)%solarZenith
	   residD(j)%losAngle = residD_temp(j)%losAngle
	   residD(j)%geodAngle = residD_temp(j)%geodAngle
	   residD(j)%pressures = residD_temp(j)%pressures(pStartIndex:pEndIndex)
	   residD(j)%latitude = residD_temp(j)%latitude
	   residD(j)%longitude = residD_temp(j)%longitude
	   residD(j)%time = residD_temp(j)%time
	   residD(j)%nTimes = residD_temp(j)%nTimes
           residD_temp(j)%l2gpValue = 0.0
           residD_temp(j)%latitude  = 0.0
           residD_temp(j)%longitude = 0.0
           startTime(j) = residD_temp(j)%time(1)
           endTime(j) = residD_temp(j)%time(residD_temp(j)%nTimes)
d608 1
a637 1

d655 1
a655 1

a656 1
           
d703 1
a703 1
                 
d740 2
a741 2
                         l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/ &
                              & real(l3dm(iD)%nLons)
d748 1
d751 2
a752 6
                              &((atimes(J, iL, iP)*86400.+l2gp(1)%time(1))&
                              & .ge.& 
                              & startTime(iD)) .AND. &
                              &((atimes(J, iL, iP)*86400.+l2gp(1)%time(1))&
                              & .le.& 
                              & endTime(iD))) THEN
d754 12
a765 14
                            CALL Diagnostics(cfProd%mode, & 
                                 & atimes(J, iL, iP), & 
                                 & alons(J, iL, iP), l3ret)
                                
                            l3r_temp(iD)%time(nc(iD))  = & 
                                 & atimes(J, iL,iP)*86400.0+l2gp(1)%time(1)
                            l3r_temp(iD)%latitude(nc(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            l3r_temp(iD)%longitude(nc(iD)) = & 
                                 & FindRealLon(real(alons(J, iL, iP)))* & 
                                 & 180.0/PI
                            l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = & 
                                 & afields(J, iL, iP)-l3ret 
                            l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0
d771 3
a773 4
                         IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= & 
                              & startTime(iD) .AND. &
                              & dtimes(J,iL,iP)*86400.0+l2gp(1)%time(1)<= &
                              & endTime(iD)) THEN
d775 9
a783 13
                            CALL Diagnostics(cfProd%mode, & 
                                 & dtimes(J, iL, iP), & 
                                 & dlons(J, iL, iP), l3ret) 
                            l3r_temp(iD)%time(nc(iD))     = & 
                                 & dtimes(J,iL, iP)*86400.0+l2gp(1)%time(1)
                            l3r_temp(iD)%latitude(nc(iD)) = & 
                                 & cfProd%latGridMap(J) 
                            l3r_temp(iD)%longitude(nc(iD)) = & 
                                 & FindRealLon(real(dlons(J, iL, iP)))* & 
                                 & 180.0/PI
                            l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = & 
                                 & dfields(J, iL, iP)-l3ret 
                            l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0
d799 1
d853 1
a853 2
                         dmA(iD)%latRss(iP, J) = & 
                              & dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d878 1
a878 1
                            residA_temp(iD)%l2gpValue(1, iP, nc(iD)) = & 
d880 1
a880 1
                            residA_temp(iD)%l2gpPrecision(1, iP, nc(iD)) =&
d949 1
a949 2
                         dmD(iD)%latRss(iP, J) = & 
                              & dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons)
d971 1
a971 1
                            residD_temp(iD)%l2gpValue(1, iP, nc(iD)) = & 
d973 1
a973 1
                            residD_temp(iD)%l2gpPrecision(1, iP, nc(iD))= &
a1010 1
                   
d1041 1
a1041 2
                         dmA(iD)%latRss(iP, J) = & 
                              & dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d1066 1
a1066 1
                            residA_temp(iD)%l2gpValue(1, iP, nca(iD)) = & 
d1068 1
a1068 1
                            residA_temp(iD)%l2gpPrecision(1, iP, nca(iD)) &
d1079 3
a1090 1
                       
d1093 1
a1093 1
                      DeAllocate(l3Result, STAT=error) 
d1137 2
a1138 2
                         dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J)/ &
                              & real(dmD(iD)%nLons)
d1164 1
a1164 1
                            residD_temp(iD)%l2gpValue(1, iP, ncd(iD))= & 
d1167 1
a1167 1
                            residD_temp(iD)%l2gpPrecision(1, iP, ncd(iD)) &
d1237 2
a1238 2
                         l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/ &
                              & real(l3dm(iD)%nLons)
d1260 1
a1260 1
                            l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = & 
d1262 1
a1262 1
                            l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0
d1286 1
a1286 1
                            l3r_temp(iD)%l2gpValue(1, iP, nc(iD))     = & 
d1289 1
a1289 1
                            l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0
d1353 1
a1353 2
                         dmA(iD)%latRss(iP, J) = & 
                              & dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d1379 1
a1379 1
                            residA_temp(iD)%l2gpValue(1, iP, nca(iD)) = & 
d1382 1
a1382 1
                            residA_temp(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0
d1447 1
a1447 2
                         dmD(iD)%latRss(iP, J) = & 
                              & dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons)
d1473 1
a1473 1
                            residD_temp(iD)%l2gpValue(1, iP, ncd(iD)) = & 
d1476 1
a1476 1
                            residD_temp(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0
d1539 1
a1539 1
                   sortTemp(i) = 0.0
d1560 1
a1560 1
                   sortTemp(i) = l3r_temp(iD)%l2gpValue(1, iP, i)
d1563 1
a1563 1
                   l3r_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1565 1
a1565 1
                
d1567 2
a1568 1
                CALL Residual2L2Grid( iD, iP, l3r_temp, l3r ) 
d1599 1
a1599 1
                     (1, iP, 1:nc(iD))), 1, nc(iD), pt)
d1602 1
a1602 1
                        l3r_temp(iD)%l2gpValue(1, iP, pt(i))
d1634 1
a1634 2
                l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/ &
                     & real(l3dm(iD)%nLons*cfProd%nLats)
d1674 1
a1674 1
                   sortTemp(i) = residA_temp(iD)%l2gpValue(1, iP, i)
d1677 1
a1677 1
                   residA_temp(iD)%l2gpValue(1, iP, i) = & 
d1682 2
a1683 1
                CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 
d1714 1
a1714 1
                     l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1716 2
a1717 2
                   dmA(iD)%maxDiff(i, iP) = & 
                        residA_temp(iD)%l2gpValue(1, iP, pt(i))
d1749 1
a1749 2
                dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/ &
                     & real(dmA(iD)%nLons*cfProd%nLats)
d1789 1
a1789 1
                   sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
d1792 1
a1792 1
                   residD_temp(iD)%l2gpValue(1, iP, i) = & 
d1797 2
a1798 1
                CALL Residual2L2Grid( iD, iP, residD_temp, residD ) 
d1829 1
a1829 1
                     & l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1832 1
a1832 1
                        & residD_temp(iD)%l2gpValue(1, iP, pt(i))
d1864 1
a1864 2
                dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/ & 
                     & real(dmD(iD)%nLons*cfProd%nLats)
a1869 1
                   
d1902 1
a1902 1
                         sortTemp(i) = residA_temp(iD)%l2gpValue(1, iP, i)
d1905 1
a1905 1
                         residA_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1909 2
a1910 1
		      CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 
d1940 1
a1940 1
                           l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1943 1
a1943 1
                              residA_temp(iD)%l2gpValue(1, iP, pt(i))
d1978 1
a1978 2
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/ & 
                           & real(dmA(iD)%nLons*cfProd%nLats)
d2019 1
a2019 1
                         sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
d2022 1
a2022 1
                         residD_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d2026 2
a2027 1
		      CALL Residual2L2Grid( iD, iP, residD_temp, residD ) 
d2057 1
a2057 1
                           l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d2060 1
a2060 1
                              residD_temp(iD)%l2gpValue(1, iP, pt(i))
d2092 1
a2092 2
                      dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/ & 
                           & real(dmD(iD)%nLons*cfProd%nLats)
d2132 1
a2132 1
                        sortTemp(i) = residA_temp(iD)%l2gpValue(1, iP, i)
d2135 1
a2135 1
                        residA_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d2139 2
a2140 1
                     CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 
d2175 1
a2175 1
                           l2gpValue(1, iP, :)), 1, nca(iD), pt)
d2178 1
a2178 1
                              residA_temp(iD)%l2gpValue(1, iP, pt(i))
d2210 1
a2210 2
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/ & 
                           & real(dmA(iD)%nLons*cfProd%nLats)
d2250 1
a2250 1
                         sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
d2253 1
a2253 1
                         residD_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d2257 2
a2258 1
		      CALL Residual2L2Grid( iD, iP, residD_temp, residD ) 
d2288 1
a2288 1
                          & l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d2291 1
a2291 1
                             & residD_temp(iD)%l2gpValue(1, iP, pt(i))
d2323 1
a2323 2
                     dmD(iD)%gRss(iP) = & 
                          & dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats)
d2363 1
a2363 1
                         sortTemp(i) = l3r_temp(iD)%l2gpValue(1, iP, i)
d2366 1
a2366 1
                         l3r_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d2370 2
a2371 1
                      CALL Residual2L2Grid( iD, iP, l3r_temp, l3r )
d2389 1
a2389 1
                   endif
d2391 1
a2391 1
                   !*** Calculate Maximum Difference
d2393 1
a2393 1
                   if ( nc(iD) .gt. 0 ) then 
d2402 1
a2402 1
                           l2gpValue(1, iP, :)), 1, nc(iD), pt)
d2405 1
a2405 1
                             & l3r_temp(iD)%l2gpValue(1, iP, pt(i))
a2415 1
                  endif
d2419 1
a2419 1
                      DO J = 1, cfProd%nLats
d2423 2
a2424 2
                      ENDDO
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
d2426 3
a2428 3
                      ENDIF
                      l3dm(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
d2434 11
a2444 8
                      ENDDO
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                         l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/ &
                              & real(l3dm(iD)%nLons*cfProd%nLats)
                      ENDIF
                      l3dm(iD)%perMisPoints(iP) = perMisPoints(iP)
                   ENDDO
                END IF
d2446 3
a2448 1
             ENDDO
d2450 3
a2452 5
             !*** Calculate Field Precisions ********
             
             iP = 0
             DO kP = pStartIndex, pStartIndex 
                iP = iP + 1
d2454 2
a2455 2
                DO J = 1, cfProd%nLats
                   IF( anlats(J, iP) > 0 ) THEN
d2457 1
a2457 1
                      IF( atimes(J, 1, iP) < dtimes(J, 1, iP) ) THEN
d2476 1
a2476 1
                      ELSE
d2494 1
a2494 1
                      END IF
d2496 1
a2496 1
                      IF (cfProd%mode == 'com') THEN
d2529 1
a2529 1
                     ELSE IF (cfProd%mode == 'asc') THEN
d2661 1
a2661 1
                       CALL CordTransform('com')
d2746 4
a2749 2
        ENDDO
       
d2876 1
a2876 1

d2903 4
a2906 1
  USE SDPToolkit, ONLY: PI
d2913 1
a2913 1
       INTEGER :: pStartIndex, pEndIndex
d2925 7
a2931 2
            & l2Times(:, :), l2Lons_new(:, :), l2Lons(:, :),  & 
            & l2Lons_old(:, :), l2Lats(:, :), l2Values(:, :), l2Prec(:, :)
d2938 1
a2938 1
       REAL :: tau0
d2945 1
a2945 1
       INTEGER :: nPd, iMin, error, i, j, iT, iD, iP, kP, & 
d2947 2
a2948 1
            & aindex_prev, dindex_prev
d2953 35
d2990 1
d2992 5
a2996 1
       
d3003 31
d3043 6
d3070 1
a3070 2
          
          ALLOCATE(l2Lons_old(nterms, pEndIndex-pStartIndex+1), STAT=error)
d3072 1
a3072 1
             msr = MLSMSG_Allocate // ' l2Lons_old array.'
d3076 1
a3076 1
          ALLOCATE(l2Prec(nterms, pEndIndex-pStartIndex+1), STAT=error)
d3078 1
a3078 1
             msr = MLSMSG_Allocate // ' l2Prec array.'
d3082 1
a3082 1
          ALLOCATE(l2Lons_new(nterms, pEndIndex-pStartIndex+1), STAT=error)
d3084 1
a3084 1
             msr = MLSMSG_Allocate // ' l2Lons_new array.'
d3093 1
a3093 1
          ALLOCATE(alons_interp(cfProd%nLats, nPd*l2Days, & 
d3100 1
a3100 1
          ALLOCATE(alats_interp(cfProd%nLats, nPd*l2Days, & 
d3107 1
a3107 1
          ALLOCATE(atimes_interp(cfProd%nLats, nPd*l2Days, & 
a3108 1
          
d3114 1
a3114 1
          ALLOCATE(afields_interp(cfProd%nLats, nPd*l2Days, & 
a3115 1
          
d3121 1
a3121 1
          ALLOCATE(aprec_interp(cfProd%nLats, nPd*l2Days, & 
a3122 1
          
d3128 1
a3128 1
          ALLOCATE(dlons_interp(cfProd%nLats, nPd*l2Days, & 
a3129 1
          
d3135 1
a3135 1
          ALLOCATE(dlats_interp(cfProd%nLats, nPd*l2Days, & 
d3142 1
a3142 1
          ALLOCATE(dtimes_interp(cfProd%nLats, nPd*l2Days, & 
d3149 1
a3149 1
          ALLOCATE(dfields_interp(cfProd%nLats, nPd*l2Days, & 
d3156 1
a3156 1
          ALLOCATE(dprec_interp(cfProd%nLats, nPd*l2Days, & 
a3157 1
          
d3164 1
a3164 2
       
       
a3172 20
!       open(1, file="prec.dat", status="old")
!       DO iD = 1, 37
!          DO iT = 1, 3496
!            read(1, *) read_pressure(iD), read_prec(iD, iT)
!	  ENDDO
!       ENDDO
!       close(1)
!        
!
!       DO iD = 1, l2Days
!          DO kP = pStartIndex, pEndIndex 
!	     DO iT = 1, l2gp(iD)%nTimes
!                DO i = 1, 37
!                 IF( abs(l2gp(iD)%Pressures(kp)-read_pressure(i)) < 0.01) & 
!		   l2gp(iD)%l2gpPrecision(1, kP, iT) = read_prec(i, iT)
!	        ENDDO
!             ENDDO
!	  ENDDO
!       ENDDO
!***********************************************************************
d3180 15
a3194 9
                l2Times(nstart, iP)    = l2gp(iD)%time(iT)
                l2Lons(nstart, iP)     = l2gp(iD)%longitude(iT) * PI/180.0
                l2Lons_old(nstart, iP) = l2gp(iD)%longitude(iT) * PI/180.0
                l2Lats(nstart, iP)     = l2gp(iD)%latitude(iT)
                l2Values(nstart, iP)   = l2gp(iD)%l2gpValue(1, kP, iT) 
		l2Prec(nstart, iP)     = l2gp(iD)%l2gpPrecision(1, kP, iT)
                IF(l2Values(nstart, iP) < 0.0) & 
                     perMisPoints(iP)  = perMisPoints(iP) + 1
                numData(iP)            = numData(iP) + 1
d3199 1
a3199 1
       
d3202 2
a3203 2
             perMisPoints(kP+1-pStartIndex) = & 
                  &100*perMisPoints(kP+1-pStartIndex)/numData(kP+1-pStartIndex)
d3207 1
a3207 1
       !*** Re-arrange the longitude into sequence 
d3212 7
a3218 32
          nr = 0
	  DO iT = 2, nterms 
             IF( l2Lons(iT, iP) >= 0.0 .AND. l2Lons(iT-1, iP) < 0.0 ) THEN 
                l2Lons_new(iT, iP) = l2Lons(iT, iP) - nr*2.0*PI - 2.0*PI
                nr = nr + 1
             ELSE
                l2Lons_new(iT, iP) = l2Lons(iT, iP) - nr*2.0*PI
             END IF
	  ENDDO
          l2Lons_new(1, iP) = l2Lons(1, iP)
       ENDDO
       
       !*** Convert time reference to the starting point
       
       iP = 0
       DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
          sTime = l2Times(1, iP)
	  DO iT = 1, nterms 
             l2Times(iT, iP) = (l2Times(iT, iP) - sTime)/86400.0 
	  ENDDO
       ENDDO
       
       !*** Find longitudes & latitudes for L3 latitudes in L2 data points 
       
       dlons = 0.3*PI/180.0
       
       iP = 0
       DO kP = pStartIndex, pEndIndex 
          iP = iP + 1
           
          alons = l2Lons_new(1, iP) 
d3220 53
a3272 38
          lindex      = 1
          lindex_prev = 0
          aindex_prev = 0
          dindex_prev = 0
          
          nloop = (l2Lons_new(1, iP)-l2Lons_new(nterms, iP))/dlons
          
          DO J = 1, cfProd%nLats
       	     anlats(J, iP) = 0 
       	     dnlats(J, iP) = 0 
	  ENDDO
          
	  DO I = 1, nloop
             alons = alons -  dlons
             DO iT = lindex, nterms-1 
                IF( l2Lons_new(iT, iP) > alons .AND. & 
                     l2Lons_new(iT+1, iP) <= alons ) THEN
                   lindex = iT
                   EXIT
                END IF
             ENDDO
             
             IF ( lindex /= lindex_prev ) THEN
                
                lindex_prev = lindex
                
                DO J = 1, cfProd%nLats
                   IF( ( l2Lats(lindex, iP)  <= cfProd%latGridMap(J) .AND. &
                        & l2Lats(lindex+1, iP) > cfProd%latGridMap(J) )  .OR.&
                        & ( l2Lats(lindex, iP) >= cfProd%latGridMap(J) .AND. &
                        & l2Lats(lindex+1, iP) < cfProd%latGridMap(J) )  ) THEN
                      
                      if ( & 
                           &abs(l2Lons_new(lindex+1,iP)-l2Lons_new(lindex,iP))&
                           &.ge.1.0e-12) then 
                         
                         slope = (l2Lats(lindex+1, iP)-l2Lats(lindex, iP))/&
                              &(l2Lons_new(lindex+1,iP)-l2Lons_new(lindex, iP))
d3274 52
a3325 7
                      
                      if ( & 
                           &abs(l2Lons_new(lindex+1,iP)-l2Lons_new(lindex,iP))&
                           &.ge.1.0e-12) then 
                         slope_time = & 
                              &(l2Times(lindex+1, iP)-l2Times(lindex, iP))/&
                              &(l2Lons_new(lindex+1,iP)-l2Lons_new(lindex, iP))
d3327 14
a3340 23
                      
                      if (abs(l2Lons(lindex+1, iP)-l2Lons(lindex, iP))& 
                           &.ge.1.e-12) then
                         slope_field = & 
                              &(l2Values(lindex+1, iP)-l2Values(lindex, iP))/&
                              &(l2Lons(lindex+1, iP)-l2Lons(lindex, iP))
                      endif
                      
                      if (abs(l2Lons(lindex+1, iP)-l2Lons(lindex, iP)) & 
                           &.ge.1.e-12) then
                         slope_prec = & 
                              &(l2Prec(lindex+1, iP)-l2Prec(lindex, iP))/ &
                              &(l2Lons(lindex+1, iP)-l2Lons(lindex, iP))
                      endif
                
                      IF(ABS(slope) < 1.e-6) THEN
                         lons_found     = l2Lons_new(lindex, iP)
                         lons_found_old = l2Lons_old(lindex, iP)
                      ELSE
                         lons_found     = l2Lons_new(lindex, iP) + & 
                              &(cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
                         lons_found_old = l2Lons_old(lindex, iP) + &
                              &(cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
d3342 310
a3651 39
                      lats_found   = cfProd%latGridMap(J)
                      times_found  = l2Times(lindex, iP) + &
                           &(lons_found-l2Lons_new(lindex, iP))*slope_time
                      fields_found = l2Values(lindex, iP) + & 
                           &(lons_found-l2Lons_new(lindex, iP))*slope_field
                      prec_found = l2Prec(lindex, iP) + & 
                           &(lons_found-l2Lons_new(lindex, iP))*slope_prec
                      aindex = J
                      EXIT
                   END IF
                ENDDO
          
                IF( slope < 0 .and. aindex /= aindex_prev) THEN
                   aindex_prev = aindex
                   anlats(aindex, iP) = anlats(aindex, iP) + 1 
                   alons_interp(aindex, anlats(aindex, iP), iP)   = lons_found
                   alats_interp(aindex, anlats(aindex, iP), iP)   = lats_found
                   atimes_interp(aindex, anlats(aindex, iP), iP)  = times_found
                   afields_interp(aindex, anlats(aindex, iP), iP) = & 
                        & fields_found
                   aprec_interp(aindex, anlats(aindex, iP), iP)   = prec_found
                END IF
          
                IF( slope >= 0 .and. aindex /= dindex_prev) THEN
                   dindex_prev = aindex
                   IF(anlats(aindex, iP) > 0) THEN
                      dnlats(aindex, iP) = dnlats(aindex, iP) + 1 
                      dlons_interp(aindex, dnlats(aindex, iP), iP) = lons_found
                      dlats_interp(aindex, dnlats(aindex, iP), iP) = lats_found
                      dtimes_interp(aindex, dnlats(aindex, iP), iP)= & 
                           & times_found
                      dfields_interp(aindex, dnlats(aindex, iP), iP) = & 
                           & fields_found
                      dprec_interp(aindex, dnlats(aindex, iP), iP) = prec_found
                   END IF
                END IF
                
             END IF
             
d3653 1
a3653 1
          
d3655 1
a3655 1
 
d3672 2
d3684 1
d3700 2
a3701 10
          if ( associated(l2Lons) ) then 
             DEALLOCATE(l2Lons, STAT=error)
             IF ( error /= 0 ) THEN
                msr = MLSMSG_DeAllocate // '  l2Lons pointer.'
                CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
             ENDIF
          endif
          
          if ( associated(l2Lons_new) ) then
             DEALLOCATE(l2Lons_new, STAT=error)
d3703 1
a3703 1
                msr = MLSMSG_DeAllocate // '  l2Lons_new pointer.'
d3708 2
a3709 2
          if ( associated(l2Lons_old) ) then
             DEALLOCATE(l2Lons_old, STAT=error)
d3711 1
a3711 1
                msr = MLSMSG_DeAllocate // '  l2Lons_old pointer.'
d3740 16
d3764 85
d3869 1
a3869 1
     SUBROUTINE Residual2L2Grid( iD, iP, l3r_temp, l3r ) 
d3874 1
a3874 1
       INTEGER, INTENT(IN) :: iD, iP
d3879 8
a3886 1
       INTEGER :: i, j, icount
d3888 7
d3898 4
a3901 3
             If( l3r(iD)%time(I) < l3r_temp(iD)%time(1) .OR. & 
                  & l3r(iD)%time(I) > l3r_temp(iD)%time(l3r(iD)%nTimes) ) Then
                l3r(iD)%l2gpValue(1, iP, I) = 0.0 
d3904 7
a3910 5
                If( l3r(iD)%time(I) > l3r_temp(iD)%time(J) .AND. & 
                     & l3r(iD)%time(I) < l3r_temp(iD)%time(J+1) ) Then
                   
                   l3r(iD)%l2gpValue(1, iP, I) =  & 
                        & l3r_temp(iD)%l2gpValue(1, iP, J) + &
d3912 2
a3913 2
                        & (l3r_temp(iD)%l2gpValue(1, iP, J+1) - & 
                        & l3r_temp(iD)%l2gpValue(1, iP, J))/	&
a3914 1
                   
a3944 8
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
@


1.37
log
@bug fixes
@
text
@d2 10
a11 2
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a32 1
  PRIVATE :: ID, ModuleName, my_sortp
d34 5
a38 5
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       "$Id: Synoptic.f90,v 1.36 2004/06/22 16:55:47 cvuu Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Synoptic.f90,v $"
  !----------------------------------------------------------
d3450 8
d3462 3
@


1.36
log
@Using SetupNewL2GPRecord for L3 Residual based on the nLevels from L3 not L2
@
text
@d29 1
a29 1
       "$Id: Synoptic.f90,v 1.35 2004/06/02 20:07:28 ybj Exp $"
d210 2
a211 2
             do n=1,nlev
               do m=1,cfDef%N
d233 2
a234 2
             do n=1,nlev
               do m=1,cfDef%N
d256 2
a257 2
             do n=1,nlev
               do m=1,cfDef%N
d293 2
a294 2
             do n=1,nlev
               do m=1,cfDef%N
d344 2
a345 2
             do n=1,nlev
               do m=1,cfDef%N
d3447 3
@


1.35
log
@*** empty log message ***
@
text
@d19 1
d29 1
a29 1
       "$Id: Synoptic.f90,v 1.34 2004/05/13 23:50:52 ybj Exp $"
d53 1
a53 1
  USE L2Interface, ONLY: ReadL2GPProd
d103 2
a104 1
         & mis_l2Days_temp, i, j, iP, kP, iD, iL, n,m
d129 1
a129 1
     
d396 2
a397 4
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r)
       l3r%name    = TRIM(cfProd%l3prodNameD) // 'Residuals'
d399 10
a408 1
       	   l3r(j)%l2gpValue         = 0.0
d411 2
a412 2
           startTime(j) = l3r(j)%time(1)
           endTime(j) = l3r(j)%time(l3r(j)%nTimes)
d414 1
a414 1
 
d419 1
a419 3
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA)
d422 10
a431 1
           residA(j)%l2gpValue      = 0.0
d435 2
a436 2
           startTime(j) = residA(j)%time(1)
           endTime(j) = residA(j)%time(residA(j)%nTimes)
d443 1
a443 3
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
           & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD)
d446 10
a455 1
           residD(j)%l2gpValue      = 0.0
d459 2
a460 2
           startTime(j) = residD(j)%time(1)
           endTime(j) = residD(j)%time(residD(j)%nTimes)
d467 1
a467 3
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA)
d471 3
a473 5
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
           & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD)
        residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
        residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
d475 11
a485 2
        DO j = 1, rDays
           residA(j)%l2gpValue      = 0.0
d489 12
a500 1
           residD(j)%l2gpValue      = 0.0
d504 2
a505 2
           startTime(j) = residA(j)%time(1)
           endTime(j) = residA(j)%time(residA(j)%nTimes)
d512 1
a512 3
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r)
d516 1
a516 3
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, &
	   & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA)
d520 15
a534 8
       CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
           & pcf%l3StartDay, & 
           & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD)
        l3r%name    = TRIM(cfProd%l3prodNameD) // 'Residuals'
        residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
        residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
        DO j = 1, rDays
       	   l3r(j)%l2gpValue         = 0.0
d537 12
a548 2
           l3r_temp(j)%longitude    = 0.0
           residA(j)%l2gpValue      = 0.0
d552 12
a563 1
           residD(j)%l2gpValue      = 0.0
d567 2
a568 2
           startTime(j) = l3r(j)%time(1)
           endTime(j) = l3r(j)%time(l3r(j)%nTimes)
d617 1
a711 1
                             
a733 1
                            
d737 1
d760 1
a760 1
                  
d1544 1
a1544 1
                
d2321 1
a2321 1
                      CALL my_sortp(l3r(iD)%time, 1, nc(iD), pt)
d2323 1
a2323 1
                      CALL DSORT(l3r(iD)%time, 1, nc(iD))
d2326 1
a2326 1
                         sortTemp(i) = l3r(iD)%latitude(i)
d2329 1
a2329 1
                         l3r(iD)%latitude(i) = sortTemp(pt(i))
d2333 1
a2333 1
                         sortTemp(i) = l3r(iD)%longitude(i)
d2336 1
a2336 1
                         l3r(iD)%longitude(i) = sortTemp(pt(i))
d2340 1
a2340 1
                         sortTemp(i) = l3r(iD)%l2gpValue(1, iP, i)
d2343 1
a2343 1
                         l3r(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d2345 4
a2348 1
                      
d2377 1
a2377 1
                      CALL my_sortp(-abs(l3r(iD)% & 
d2381 1
a2381 1
                             & l3r(iD)%l2gpValue(1, iP, pt(i))
d3447 3
@


1.34
log
@*** empty log message ***
@
text
@d28 1
a28 1
       "$Id: Synoptic.f90,v 1.33 2004/05/06 13:16:46 cvuu Exp $"
a643 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
d645 1
d697 14
a765 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
d767 1
d796 15
a862 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
d864 1
d890 15
a956 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(2)%l3spRelPrecision = l3spPrec(2)%l3spRelValue
		   l3sp(2)%l3spImgPrecision = l3spPrec(2)%l3spImgValue
d958 1
d987 14
d1002 1
a1051 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(3)%l3spRelPrecision = l3spPrec(3)%l3spRelValue
		   l3sp(3)%l3spImgPrecision = l3spPrec(3)%l3spImgValue
d1053 1
d1084 14
d1099 1
a1151 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
                         l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(1)%l3spRelPrecision = l3spPrec(1)%l3spRelValue
		   l3sp(1)%l3spImgPrecision = l3spPrec(1)%l3spImgValue
d1153 1
d1205 14
d1220 1
a1267 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
                         dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(2)%l3spRelPrecision = l3spPrec(2)%l3spRelValue
		   l3sp(2)%l3spImgPrecision = l3spPrec(2)%l3spImgValue
d1269 1
d1299 14
d1314 1
a1362 14
                  
                   !*** Calculate Precision     
                   Call CopyPrec2Data()
                   CALL FFSM(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
                      CALL Reconstruct(cfProd%mode, &
                           & real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                           & dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
                         dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
                      ENDDO
                   ENDDO
		   l3sp(3)%l3spRelPrecision = l3spPrec(3)%l3spRelValue
		   l3sp(3)%l3spImgPrecision = l3spPrec(3)%l3spImgValue
d1364 1
d1394 14
d1409 1
d3381 3
@


1.33
log
@remove print statements
@
text
@d11 2
a12 1
       & Reconstruct, Diagnostics, DataGenerate
d28 1
a28 1
       "$Id: Synoptic.f90,v 1.32 2004/05/04 15:33:15 cvuu Exp $"
d100 1
a100 1
    INTEGER ::  error, l2Days, nlev, nlev_temp, nf, nwv, numDays, & 
d106 1
a106 2
    nwv = cfProd%rangWavenumber(2) - cfProd%rangWavenumber(1) + 1
    nf = 60 
d166 2
a167 2
       CALL AllocateL3SP( nlev, cfProd%nLats, nwv, nf, l3sp(j) )
       CALL AllocateL3SP( nlev, cfProd%nLats, nwv, nf, l3spPrec(j) )
d531 1
a531 1
       
d536 1
d582 1
d600 1
d644 14
d765 14
d860 14
d952 14
d1045 14
d1143 14
d1257 14
d1350 14
d2832 3
d2983 22
d3366 3
@


1.32
log
@v1.4.3: Use int array for Date in Data Field
@
text
@d27 1
a27 1
       "$Id: Synoptic.f90,v 1.31 2004/01/07 21:43:18 cvuu Exp $"
a191 5
    !print *, 'cfProd%mode', cfProd%mode
    !print *, 'numDays', numDays 
    !print *, 'nlev', nlev
    !print *, 'n', cfDef%N

a531 1
    print *, 'tau0 before if, avgPeriod ', tau0, size(avgPeriod) 
a532 1
    print *, 'tau0 after if ', tau0
a535 3
    !print *, 'pStartIndex', pStartIndex    
    !print *, 'pEndIndex', pEndIndex

a2574 1
          !print *,'deallocate alats'
d3226 3
@


1.31
log
@version 1.4 commit
@
text
@d27 1
a27 1
       "$Id: Synoptic.f90,v 1.30 2003/04/30 18:15:48 pwagner Exp $"
d76 1
a76 1
    CHARACTER (LEN=DATE_LEN) :: mis_Days_temp(maxWindow)
a393 5
     
    DO j = 1, maxWindow
       mis_Days_temp(j) = ''
    ENDDO
    mis_l2Days_temp = 0
a451 4
       DO j = 1, maxWindow
          mis_Days_temp(j) = ''
       ENDDO
       mis_l2Days_temp = 0
a459 1
        !print *, 'rDays', rDays
a480 4
       DO j = 1, maxWindow
          mis_Days_temp(j) = ''
       ENDDO
       mis_l2Days_temp = 0
a486 4
       DO j = 1, maxWindow
          mis_Days_temp(j) = ''
       ENDDO
       mis_l2Days_temp = 0
d536 2
a537 1
        
d539 1
d2664 1
d3237 3
@


1.30
log
@Work-around for LF95 infinite compile-time bug
@
text
@d27 1
a27 1
       "$Id: Synoptic.f90,v 1.29 2003/03/22 02:59:22 jdone Exp $"
d101 1
a101 1
         & mis_l2Days_temp, i, j, iP, kP, iD, iL
d190 7
d198 177
a374 2
        
       ALLOCATE( l3dm(numDays), STAT=error )
d376 1
a376 1
          msr = MLSMSG_Allocate // ' l3dm array.'
d379 2
a380 2
        
       ALLOCATE( dmA(numDays), STAT=error )
d382 1
a382 1
          msr = MLSMSG_Allocate // ' dmA array.'
d385 2
a386 2
        
       ALLOCATE( dmD(numDays), STAT=error )
d388 1
a388 1
          msr = MLSMSG_Allocate // ' dmD array.'
a390 1
        
d392 1
a392 50
     
    !!      Initialize Daily Map & Diagnostic
     
    l3dm%name = cfProd%l3prodNameD
    dmA%name  = TRIM(cfProd%l3prodNameD) // 'Ascending'
    dmD%name  = TRIM(cfProd%l3prodNameD) // 'Descending'
     
    DO j = 1, numDays
        
       CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, & 
            & l3dm(j) )
       CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, & 
            & dmA(j) )
       CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, & 
            & dmD(j) )
        
       l3dm(j)%time      = cfProd%timeD(j)
       dmA(j)%time       = cfProd%timeD(j)
       dmD(j)%time       = cfProd%timeD(j)
        
       l3dm(j)%pressure  = l2gp(1)%pressures(pStartIndex:pEndIndex)
       dmA(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
       dmD(j)%pressure   = l2gp(1)%pressures(pStartIndex:pEndIndex)
        
       l3dm(j)%latitude  = cfProd%latGridMap(:l3dm(j)%nLats)
       dmA(j)%latitude   = cfProd%latGridMap(:dmA(j)%nLats)
       dmD(j)%latitude   = cfProd%latGridMap(:dmD(j)%nLats)
        
       l3dm(j)%longitude = cfProd%longGrid(:l3dm(j)%nLons)
       dmA(j)%longitude  = cfProd%longGrid(:dmA(j)%nLons)
       dmD(j)%longitude  = cfProd%longGrid(:dmD(j)%nLons)
        
       l3dm(j)%l3dmValue = 0.0
       dmA(j)%l3dmValue  = 0.0
       dmD(j)%l3dmValue  = 0.0
        
       l3dm(j)%l3dmPrecision = 0.0
       dmA(j)%l3dmPrecision  = 0.0
       dmD(j)%l3dmPrecision  = 0.0
        
       l3dm(j)%maxDiff = 0.0 
       dmA(j)%maxDiff  = 0.0 
       dmD(j)%maxDiff  = 0.0 
        
       l3dm(j)%maxDiffTime = 0.0 
       dmA(j)%maxDiffTime  = 0.0 
       dmD(j)%maxDiffTime  = 0.0 
        
    ENDDO
     
a397 1
     
d399 84
a482 24
    
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r_temp)
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r)
     
    DO j = 1, maxWindow
       mis_Days_temp(j) = ''
    ENDDO
        
    mis_l2Days_temp = 0
        
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residA_temp)
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA)
        
    DO j = 1, maxWindow
       mis_Days_temp(j) = ''
    ENDDO
d484 47
a530 27
    mis_l2Days_temp = 0
        
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay,rDays, mis_l2Days_temp, mis_Days_temp, residD_temp)
    CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, & 
         & pcf%l3StartDay, & 
         & pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD)
        
    l3r%name    = TRIM(cfProd%l3prodNameD) // 'Residuals'
    residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
    residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'
        
    DO j = 1, rDays
       l3r(j)%l2gpValue         = 0.0
       l3r_temp(j)%l2gpValue    = 0.0
       l3r_temp(j)%latitude     = 0.0
       l3r_temp(j)%longitude    = 0.0
       residA(j)%l2gpValue      = 0.0
       residA_temp(j)%l2gpValue = 0.0
       residA_temp(j)%latitude  = 0.0
       residA_temp(j)%longitude = 0.0
       residD(j)%l2gpValue      = 0.0
       residD_temp(j)%l2gpValue = 0.0
       residD_temp(j)%latitude  = 0.0
       residD_temp(j)%longitude = 0.0
    ENDDO
d541 1
a541 41
        
    if ( rDays .gt. 0) then 
           
       ALLOCATE( nc(rDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' nc array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
           
           
       ALLOCATE( nca(rDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' nca array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
           
       ALLOCATE( ncd(rDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' ncd array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
           
       ALLOCATE( startTime(rDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' startTime array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF

       ALLOCATE( endTime(rDays), STAT=error )
       IF ( error /= 0 ) THEN
          msr = MLSMSG_Allocate // ' endTime array.'
          CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
       ENDIF
           
    endif
        
    DO I = 1, rDays 
       startTime(I) = l3r(I)%time(1)
       endTime(I) = l3r(I)%time(l3r(I)%nTimes)
    ENDDO
        
d558 4
a561 1
        
d1327 2
a1328 1
          !*** Sort into time ascending order according to l2gp format
d2331 1
a2331 2
                            
                    endif
d2333 1
a2333 1
                 ELSE IF (cfProd%mode == 'asc') THEN
d2601 1
d2608 2
a2609 2
       
       if ( associated(dlats) ) then 
d2616 1
a2616 1
       
d2624 1
a2624 1
       
d2632 1
a2632 1
       
d2640 1
a2640 1
       
d2648 1
a2648 1
       
d2656 1
a2656 1
       
d2664 2
a2665 2
       
       if ( associated(aprec)) then 
a2671 1
       
d2679 16
a2694 5
       
       CALL DestroyL2GPDatabase(l3r_temp)
       CALL DestroyL2GPDatabase(residA_temp)
       CALL DestroyL2GPDatabase(residD_temp)
       
d3252 3
@


1.29
log
@individual allocate/deallocate, use only and indentation added
@
text
@a11 1
  USE L2Interface, ONLY: ReadL2GPProd
a12 1
  USE L3DMData, ONLY: L3DMData_T, AllocateL3DM
a13 1
  USE L3SPData, ONLY: L3SPData_T, OutputL3SP, AllocateL3SP
a17 4
  USE OpenInit, ONLY: PCFData_T 
  USE OutputClose, ONLY: OutputFlags_T
  USE global_data
  USE SDPToolkit, ONLY: PI
d21 2
d27 1
a27 1
       "$Id: Synoptic.f90,v 1.28 2003/02/06 19:51:31 pwagner Exp $"
d51 6
d2520 1
d2985 1
d3067 3
@


1.28
log
@Fixed problem arising from different num types in calls to _sortp
@
text
@d9 35
a43 33
   Use OpenInit
   Use MLSCommon
   USE MLSCF
   USE MLSPCF3
   USE L3CF
   USE L3DMData
   USE L2GPData
   USE L2Interface
   USE OutputClose
   Use global_data
   Use DailyMapModule
   USE L3DMData

   USE NumRecipesModule

   Implicit none

   PRIVATE :: ID, ModuleName, my_sortp

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: Synoptic.f90,v 1.27 2002/05/08 16:23:47 ybj Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Synoptic.f90,v $"
!----------------------------------------------------------

! Contents:

! Subroutines -- DailyCoreProcessing
!                
! This subroutine will process one product for all the input days data
!
! Remarks:  This module contains subroutines related to MLS L3 Daily Map Processing 
!
d45 2
a46 2
    module procedure my_sortp_r4
    module procedure my_sortp_r8
d48 1
a48 1

d50 51
d102 1
a102 55
!-------------------------------------------------------------------------
   SUBROUTINE DailyCoreProcessing(cfDef, cfProd, pcf, l2Days, l2gp, avgPeriod, l3sp, &
     l3dm, dmA, dmD, l3r, residA, residD, mis_l2Days, mis_Days, flags)
!-------------------------------------------------------------------------

! Brief description of program
! This is the main program to run the Core processing.

! Parameters

	! Variable definitions

        TYPE( L3CFDef_T ) :: cfDef
        TYPE( PCFData_T ) :: pcf
        TYPE( L3CFProd_T ) :: cfProd
        TYPE( L2GPData_T ), POINTER :: l2gp(:)
        TYPE( L3DMData_T ), POINTER :: l3dm(:), dmA(:), dmD(:)
        TYPE( L3SPData_T ), POINTER :: l3sp(:), l3spPrec(:)
        TYPE( L2GPData_T ), POINTER :: l3r(:), residA(:), residD(:)
        TYPE( L2GPData_T ), POINTER :: l3r_temp(:), residA_temp(:), residD_temp(:)

   	TYPE( OutputFlags_T ) :: flags

	Real (r8), POINTER, DIMENSION(:, :, :) ::  alons(:, :, :), alats(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  dlons(:, :, :), dlats(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  atimes(:, :, :), dtimes(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  afields(:, :, :), dfields(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  aprec(:, :, :), dprec(:, :, :)

        REAL(r8), POINTER :: avgPeriod(:)

        INTEGER, DIMENSION(l2gp(1)%nLevels) :: perMisPoints
	INTEGER, DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: anlats, dnlats 
	Real (r8), DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: delTad 
        REAL(r8), DIMENSION(:), POINTER :: l3Result(:)       ! returned reconstructed result 

        REAL(r8), DIMENSION(:), POINTER :: sortTemp(:)       ! hold sort array temporary
        INTEGER, POINTER, DIMENSION(:) :: pt(:)

        INTEGER, POINTER, DIMENSION(:) :: nc(:), nca(:), ncd(:)
        Real (r8), POINTER, DIMENSION(:) :: startTime(:), endTime(:)

	INTEGER ::  error, l2Days, nlev, nlev_temp, nf, nwv, numDays, numSwaths
        INTEGER ::  rDays, pEndIndex, pStartIndex

        integer mis_l2Days, mis_l2Days_temp
        CHARACTER (LEN=DATE_LEN) :: mis_Days(maxWindow), mis_Days_temp(maxWindow)
        CHARACTER (LEN=480) :: msr

        integer i, j, iP, kP, iD, iL, iT
	real tau0, l3ret, avg
	real(r8) lonD0_in, lonA0_in


!*** Initilize variables
d104 2
a105 340
        nwv = cfProd%rangWavenumber(2) - cfProd%rangWavenumber(1) + 1
        nf = 60 

	nlev = 0
        DO j = 1, l2gp(1)%nLevels
           IF( l2gp(1)%pressures(j) >= cfProd%l3presLvl(1) .AND. &
	       l2gp(1)%pressures(j) <= cfProd%l3presLvl(2) ) THEN
	     nlev = nlev + 1
	     IF (nlev == 1) pStartIndex = j 
	     pEndIndex = j 
	   ENDIF
        ENDDO

	IF (nlev == 0) THEN
		nlev_temp = 1
		nlev = 1
                pStartIndex = 1
                pEndIndex = 1
	ELSE
		nlev_temp = -1
	END IF


!*** Initilize POINTERS

        IF (cfProd%mode == 'all' .or. cfProd%mode == 'ado') THEN
           numSwaths = 3
        ELSE
           numSwaths = 1
        ENDIF

        ALLOCATE( l3sp(numSwaths), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' l3sp array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( l3spPrec(numSwaths), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' l3spPrec array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        IF (cfProd%mode == 'all' .or. cfProd%mode == 'ado') THEN
           l3sp(1)%name = cfProd%l3prodNameD
           l3sp(2)%name = TRIM(cfProd%l3prodNameD) // 'Ascending'
           l3sp(3)%name = TRIM(cfProd%l3prodNameD) // 'Descending'
        ELSE
           l3sp(1)%name = TRIM(cfProd%l3prodNameD)
        ENDIF

        l3sp%startTime = l2gp(1)%time(1)

        if (l2Days .GT. 0) then 
          l3sp%endTime = l2gp(l2Days)%time(l2gp(l2Days)%nTimes)
        else
          l3sp%endTime = l3sp%startTime
        endif

        DO j = 1, numSwaths

           CALL AllocateL3SP( nlev, cfProd%nLats, nwv, nf, l3sp(j) )
           CALL AllocateL3SP( nlev, cfProd%nLats, nwv, nf, l3spPrec(j) )
           l3sp(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           l3sp(j)%latitude = cfProd%latGridMap(:l3sp(j)%nLats)
           l3sp(j)%waveNumber = 0.0
           l3sp(j)%frequency = 0.0
           l3sp(j)%l3spRelValue = 0.0 
           l3sp(j)%l3spRelPrecision = 0.0 
           l3sp(j)%l3spImgValue = 0.0 
           l3sp(j)%l3spImgPrecision = 0.0 

           l3spPrec(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           l3spPrec(j)%latitude = cfProd%latGridMap(:l3sp(j)%nLats)
           l3spPrec(j)%waveNumber = 0.0
           l3spPrec(j)%frequency = 0.0
           l3spPrec(j)%l3spRelValue = 0.0
           l3spPrec(j)%l3spRelPrecision = 0.0
           l3spPrec(j)%l3spImgValue = 0.0
           l3spPrec(j)%l3spImgPrecision = 0.0

        ENDDO

        numDays = cfProd%nDays

        if (numDays .gt. 0) then

        ALLOCATE( l3dm(numDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' l3dm array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( dmA(numDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' dmA array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( dmD(numDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' dmD array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        endif

!!      Initialize Daily Map & Diagnostic

        l3dm%name = cfProd%l3prodNameD
        dmA%name = TRIM(cfProd%l3prodNameD) // 'Ascending'
        dmD%name = TRIM(cfProd%l3prodNameD) // 'Descending'

        DO j = 1, numDays

           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, l3dm(j) )
           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmA(j) )
           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, cfDef%N, dmD(j) )

           l3dm(j)%time = cfProd%timeD(j)
           dmA(j)%time = cfProd%timeD(j)
           dmD(j)%time = cfProd%timeD(j)

           l3dm(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           dmA(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           dmD(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)

           l3dm(j)%latitude = cfProd%latGridMap(:l3dm(j)%nLats)
           dmA(j)%latitude = cfProd%latGridMap(:dmA(j)%nLats)
           dmD(j)%latitude = cfProd%latGridMap(:dmD(j)%nLats)

           l3dm(j)%longitude = cfProd%longGrid(:l3dm(j)%nLons)
           dmA(j)%longitude = cfProd%longGrid(:dmA(j)%nLons)
           dmD(j)%longitude = cfProd%longGrid(:dmD(j)%nLons)

           l3dm(j)%l3dmValue = 0.0
           dmA(j)%l3dmValue = 0.0
           dmD(j)%l3dmValue = 0.0

           l3dm(j)%l3dmPrecision = 0.0
           dmA(j)%l3dmPrecision = 0.0
           dmD(j)%l3dmPrecision = 0.0

           l3dm(j)%maxDiff = 0.0 
           dmA(j)%maxDiff = 0.0 
           dmD(j)%maxDiff = 0.0 

           l3dm(j)%maxDiffTime = 0.0 
           dmA(j)%maxDiffTime = 0.0 
           dmD(j)%maxDiffTime = 0.0 

        ENDDO

!!      Initialize Daily Map Residues

        DO j = 1, maxWindow
        	mis_Days_temp(j) = ''
        ENDDO

        mis_l2Days_temp = 0

        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r_temp)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, l3r)

        DO j = 1, maxWindow
        	mis_Days_temp(j) = ''
        ENDDO

        mis_l2Days_temp = 0

        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA_temp)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residA)

        DO j = 1, maxWindow
        	mis_Days_temp(j) = ''
        ENDDO

        mis_l2Days_temp = 0

        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD_temp)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, & 
          pcf%l3EndDay, rDays, mis_l2Days_temp, mis_Days_temp, residD)

        l3r%name    = TRIM(cfProd%l3prodNameD) // 'Residuals'
        residA%name = TRIM(cfProd%l3prodNameD) // 'AscendingResiduals'
        residD%name = TRIM(cfProd%l3prodNameD) // 'DescendingResiduals'

        DO j = 1, rDays
           l3r(j)%l2gpValue    = 0.0
           l3r_temp(j)%l2gpValue    = 0.0
           l3r_temp(j)%latitude     = 0.0
           l3r_temp(j)%longitude    = 0.0
           residA(j)%l2gpValue = 0.0
           residA_temp(j)%l2gpValue = 0.0
           residA_temp(j)%latitude  = 0.0
           residA_temp(j)%longitude = 0.0
           residD(j)%l2gpValue = 0.0
           residD_temp(j)%l2gpValue = 0.0
           residD_temp(j)%latitude  = 0.0
           residD_temp(j)%longitude = 0.0
        ENDDO
 
!!      Initialize Flags

        flags%writel3sp    = .FALSE.
        flags%writel3dmCom = .FALSE.
        flags%writel3dmAsc = .FALSE.
        flags%writel3dmDes = .FALSE.
        flags%writel3rCom  = .FALSE.
        flags%writel3rAsc  = .FALSE.
        flags%writel3rDes  = .FALSE.

        if ( rDays .gt. 0) then 
 
        ALLOCATE( nc(rDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' nc array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF


        ALLOCATE( nca(rDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' nca array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( ncd(rDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' ncd array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( startTime(rDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' startTime array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        ALLOCATE( endTime(rDays), STAT=error )
        IF ( error /= 0 ) THEN
           msr = MLSMSG_Allocate // ' endTime array.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF

        endif

        DO I = 1, rDays 
	    startTime(I) = l3r(I)%time(1)
	    endTime(I) = l3r(I)%time(l3r(I)%nTimes)
	ENDDO 
 
!!      Check if pressure levels are found 

	IF (nlev_temp == 1) THEN 
	   RETURN
	END IF
!
!*** Calculate average orbital period (day)

	tau0 = 0.0
        DO I = 1, size(avgPeriod)
	  tau0 = tau0 + avgPeriod(i)
	ENDDO 
        IF (size(avgPeriod) .ne. 0) tau0 = tau0/86400.0/float(size(avgPeriod))
 
!*** Sort & Prepare the Data 

	Call SortData(cfProd, l2Days, l2gp, 			&
			pStartIndex, pEndIndex,			&
			tau0, 					&
			anlats, dnlats, 			&
		        alats, dlats, 				&
			alons, dlons, 				&
			atimes, dtimes, 			&
			afields, dfields, 			&
			aprec, dprec,                           &
			delTad, perMisPoints )

!*** Main Loop 

   !*** Calculate Field Values ********

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1

          DO I = 1, rDays 
	    nc(I) = 0
	    nca(I) = 0
	    ncd(I) = 0
	  ENDDO 

	  DO J = 1, cfProd%nLats
       	     IF( anlats(J, iP) > 0 ) THEN

		IF( atimes(J, 1, iP) < dtimes(J, 1, iP) ) THEN

   		  lonD0_in = FindRealLon(real(dlons(J, 1, iP)))
   		  lonA0_in = FindRealLon(real(alons(J, 1, iP)))

	          CALL Init(cfProd%mode, 				&
			  nt_a_i   = anlats(J, iP), 			&
			  nt_d_i   = dnlats(J, iP), 			&
			  tau0_i   = tau0, 				&
			  delTad_i = delTad(J, iP), 			&
			  c0_i     = 2.0*PI, 				&
			  lonD0_i  = lonD0_in, 				&
			  tD0_i    = dtimes(J, 1, iP), 			&
			  lonA0_i  = lonA0_in, 				&
			  tA0_i    = atimes(J, 1, iP), 			&
			  lat_i    = alats(J, 1, iP) )
          		CALL DataGenerate(afields(J, :, iP), dfields(J, :, iP) )
		ELSE

   		  lonD0_in = FindRealLon(real(dlons(J, 2, iP)))
   		  lonA0_in = FindRealLon(real(alons(J, 1, iP)))

	          CALL Init(cfProd%mode, 				&
			  nt_a_i   = anlats(J, iP), 			&
			  nt_d_i   = dnlats(J, iP)-1, 			&
			  tau0_i   = tau0, 				&
			  delTad_i = delTad(J, iP), 			&
			  c0_i     = 2.0*PI, 				&
			  lonD0_i  = lonD0_in, 				&
			  tD0_i    = dtimes(J, 2, iP), 			&
			  lonA0_i  = lonA0_in, 				&
			  tA0_i    = atimes(J, 1, iP), 			&
			  lat_i    = alats(J, 1, iP) )
          		CALL DataGenerate(afields(J, :, iP), dfields(J, 2:, iP) )
		END IF

		IF (cfProd%mode == 'com') THEN

                  if (l3dm(1)%nLons .gt. 0) then 
d107 348
d457 2
a458 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d460 1
a460 1

d462 1
a462 1
	   	   CALL FFSM(l3sp(1), iP, J)
d464 3
a466 3
        	      CALL Reconstruct(cfProd%mode, &
                        real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
                        l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
d468 4
a471 3
			l3dm(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
          !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d474 1
a474 1
                        avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
d476 2
a477 1
                    IF (l3dm(iD)%nLons .ne. 0) avg = avg/real(l3dm(iD)%nLons)
d480 4
a483 3
                        l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J) +  &
                                      (l3dm(iD)%l3dmValue(iP, J, I)-avg)*  &
                                      (l3dm(iD)%l3dmValue(iP, J, I)-avg)
d485 1
a485 1

d487 2
a488 2
                       l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/ &
                         real(l3dm(iD)%nLons)
d490 3
a492 3

		   ENDDO

d495 27
a521 15

		IF(((atimes(J, iL, iP)*86400.+l2gp(1)%time(1)) .ge. startTime(iD)) .AND. &
                   ((atimes(J, iL, iP)*86400.+l2gp(1)%time(1)) .le. endTime(iD))) THEN
			   nc(iD) = nc(iD) + 1
		   CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret)
                   
		   l3r_temp(iD)%time(nc(iD))  = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	           l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	           l3r_temp(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
		   l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
	           l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 

			END IF

		      ENDDO
d523 22
a544 13
			IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nc(iD) = nc(iD) + 1
	       CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
		   l3r_temp(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		   l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
		   l3r_temp(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
		   l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		   l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
			END IF
		      ENDDO
		   ENDDO
                   
d546 5
a550 5
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d552 11
a562 11

		   flags%writel3dmCom = .TRUE.
		   flags%writel3rCom  = .TRUE.
		   flags%writel3sp = .TRUE.

                   endif

		ELSE IF (cfProd%mode == 'asc') THEN

                  if (dmA(1)%nLons .gt. 0) then 

d564 5
a568 5
                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d570 1
a570 1

d572 1
a572 1
	   	   CALL FFSMA(l3sp(1), iP, J)
d574 3
a576 2
       	      CALL Reconstruct(cfProd%mode, real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
				    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
d578 4
a581 3
			dmA(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d584 1
a584 1
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
d586 2
a587 1
                      IF (dmA(iD)%nLons .ne. 0) avg = avg/real(dmA(iD)%nLons)
d590 3
a592 3
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +  &
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)
d595 2
a596 1
                      dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d598 2
a599 2
		   ENDDO

d602 26
a627 13
			IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nc(iD) = nc(iD) + 1
		   CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
	         residA_temp(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	         residA_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	         residA_temp(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
	         residA_temp(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
		 residA_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
			END IF
		      ENDDO
		   ENDDO

d629 5
a633 5
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d635 11
a645 11

		   flags%writel3dmAsc = .TRUE.
		   flags%writel3rAsc  = .TRUE.
		   flags%writel3sp = .TRUE.

                   endif

		ELSE IF (cfProd%mode == 'des') THEN

                  if (dmD(1)%nLons .gt. 0) then 

d648 2
a649 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d651 1
a651 1

d653 1
a653 1
	   	   CALL FFSMD(l3sp(1), iP, J)
d655 3
a657 2
             CALL Reconstruct(cfProd%mode, real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
			      dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
d659 4
a662 3
			dmD(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d665 1
a665 1
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
d667 2
a668 1
                      IF (dmD(iD)%nLons .ne. 0) avg = avg/real(dmD(iD)%nLons)
d671 3
a673 3
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +  &
                                     (dmD(iD)%l3dmValue(iP, J, I)-avg)*  &
                                     (dmD(iD)%l3dmValue(iP, J, I)-avg)
d676 2
a677 1
                      dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons)
d679 2
a680 2
		   ENDDO

d683 23
a705 13
			IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nc(iD) = nc(iD) + 1
		   CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
		  residD_temp(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		  residD_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	          residD_temp(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
	          residD_temp(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		  residD_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
			END IF
		      ENDDO
		   ENDDO

d707 5
a711 5
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d713 11
a723 11

		   flags%writel3dmDes = .TRUE.
		   flags%writel3rDes  = .TRUE.
		   flags%writel3sp = .TRUE.

                   endif

                ELSE IF (cfProd%mode == 'ado') THEN

                  if (dmA(1)%nLons .gt. 0) then 

d726 2
a727 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d729 1
a729 1

d733 3
a735 2
                   CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0,  &
                                    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
d737 1
a737 1
                        dmA(iD)%l3dmValue(iP, J, I) = l3Result(I)
d739 2
a740 1
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d743 1
a743 1
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
d745 2
a746 1
                      IF (dmA(iD)%nLons .ne. 0) avg = avg/real(dmA(iD)%nLons)
d749 3
a751 3
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +  &
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)* & 
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)
d754 2
a755 1
                      dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d757 2
a758 2
                   ENDDO 

d761 24
a784 13

                        IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
                           atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
                           nca(iD) = nca(iD) + 1
                          CALL Diagnostics('asc', atimes(J, iL, iP), alons(J, iL, iP), l3ret)
                          
                           residA_temp(iD)%time(nca(iD)) = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                           residA_temp(iD)%longitude(nca(iD))=FindRealLon(real(alons(J,iL,iP)))*180./PI
                           residA_temp(iD)%latitude(nca(iD)) = cfProd%latGridMap(J)  
                           residA_temp(iD)%l2gpValue(1, iP, nca(iD)) = afields(J, iL, iP)-l3ret
                           residA_temp(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0

                        END IF
d787 1
a787 1

d789 5
a793 5
                   DeAllocate(l3Result, STAT=error) 
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d795 1
a795 1

d798 5
a802 5

                   endif

                   if (dmD(1)%nLons .gt. 0) then 

d805 2
a806 2
                     msr = MLSMSG_Allocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d808 1
a808 1

d812 3
a814 2
                      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
                                    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
d816 1
a816 1
                        dmD(iD)%l3dmValue(iP, J, I) = l3Result(I)
d818 2
a819 1
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d822 1
a822 1
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
d824 2
a825 1
                      IF (dmD(iD)%nLons .ne. 0) avg = avg/real(dmD(iD)%nLons)
d828 3
a830 3
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) + &
                                               (dmD(iD)%l3dmValue(iP, J, I)-avg)* & 
                                               (dmD(iD)%l3dmValue(iP, J, I)-avg)
d833 2
a834 2
                      dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J)/ &
                        real(dmD(iD)%nLons)
d836 2
a837 2
                   ENDDO 

d840 26
a865 12
                        IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
                           dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
                           ncd(iD) = ncd(iD) + 1
                          CALL Diagnostics('des', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret)

                  residD_temp(iD)%longitude(ncd(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180./PI
                  residD_temp(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                  residD_temp(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J)  
                  residD_temp(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret
                  residD_temp(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0

                        END IF
d868 1
a868 1

d870 5
a874 5
                   DeAllocate(l3Result, STAT=error) 
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d876 1
a876 1

d879 8
a886 8
                   flags%writel3sp = .TRUE.

                   endif

		ELSE IF (cfProd%mode == 'all') THEN

                  if (l3dm(1)%nLons .gt. 0) then 

d889 2
a890 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d892 1
a892 1

d894 1
a894 1
	   	   CALL FFSM(l3sp(1), iP, J)
d896 3
a898 2
            CALL Reconstruct('com', real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, &
				    l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
d900 4
a903 3
			l3dm(iD)%l3dmValue(iP, J, I) = l3Result(I) 
		      ENDDO
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d906 1
a906 1
                        avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
d908 2
a909 1
                      IF (l3dm(iD)%nLons .ne. 0) avg = avg/real(l3dm(iD)%nLons)
d912 3
a914 3
                        l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J) +  &
                                      (l3dm(iD)%l3dmValue(iP, J, I)-avg)*  &
                                      (l3dm(iD)%l3dmValue(iP, J, I)-avg)
d917 2
a918 2
                      l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/ &
                        real(l3dm(iD)%nLons)
d920 2
a921 2
		   ENDDO

d924 20
a943 12
			IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nc(iD) = nc(iD) + 1
		         CALL Diagnostics('com', atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
		        l3r_temp(iD)%time(nc(iD))  = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			l3r_temp(iD)%longitude(nc(iD)) = & 
                          FindRealLon(real(alons(J, iL, iP)))*180.0/PI
			   l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
			   l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
			END IF
		      ENDDO
d945 26
a970 10
			IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nc(iD) = nc(iD) + 1
		         CALL Diagnostics('com', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
	             l3r_temp(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	             l3r_temp(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
		     l3r_temp(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
		     l3r_temp(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		     l3r_temp(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
			END IF
d973 1
a973 1

d975 5
a979 5
		   DeAllocate(l3Result,STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d981 1
a981 1

d984 5
a988 5

                   endif

                   if (dmA(1)%nLons .gt. 0) then 

d991 2
a992 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d994 1
a994 1

d998 3
a1000 2
        	      CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, &
				    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
d1002 1
a1002 1
			dmA(iD)%l3dmValue(iP, J, I) = l3Result(I) 
d1004 1
a1004 1
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d1007 1
a1007 1
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
d1012 3
a1014 3
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) + &
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                                               (dmA(iD)%l3dmValue(iP, J, I)-avg)
d1017 2
a1018 1
                      dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J)/real(dmA(iD)%nLons)
d1020 2
a1021 2
		   ENDDO

d1024 25
a1048 10
			IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   nca(iD) = nca(iD) + 1
	           CALL Diagnostics('asc', atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
		  residA_temp(iD)%time(nca(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		  residA_temp(iD)%latitude(nca(iD)) = cfProd%latGridMap(J) 
		  residA_temp(iD)%longitude(nca(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
                  residA_temp(iD)%l2gpValue(1, iP, nca(iD)) = afields(J, iL, iP)-l3ret 
                  residA_temp(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0 
			END IF
d1051 1
a1051 1

d1053 5
a1057 5
		   DeAllocate(l3Result,STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1059 1
a1059 1

d1062 5
a1066 5

                   endif

                   if (dmD(1)%nLons .gt. 0) then 

d1069 2
a1070 2
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1072 1
a1072 1

d1076 3
a1078 2
        	      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, &
				    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
d1080 1
a1080 1
			dmD(iD)%l3dmValue(iP, J, I) = l3Result(I) 
d1082 2
a1083 1
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d1086 1
a1086 1
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
d1091 3
a1093 3
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +  &
                                               (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                                               (dmD(iD)%l3dmValue(iP, J, I)-avg)
d1096 2
a1097 1
                      dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons)
d1100 1
a1100 1

d1103 25
a1127 11
			IF(dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
			   ncd(iD) = ncd(iD) + 1
		         CALL Diagnostics('des', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 

		  residD_temp(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                  residD_temp(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J) 
                  residD_temp(iD)%longitude(ncd(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
                  residD_temp(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret 
                  residD_temp(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0 
			END IF
d1130 1
a1130 1

d1132 5
a1136 5
		   DeAllocate(l3Result,STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1138 1
a1138 1

d1141 10
a1150 10
		   flags%writel3sp = .TRUE.

                   endif

		END IF

                CALL ClearMemory()

	     END IF
	  ENDDO
d1153 349
a1501 1
          IF (cfProd%mode == 'com') THEN
d1503 3
a1505 4

                  if (nc(iD) .gt. 0) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
d1507 2
a1508 2
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1510 2
a1511 2

                      ALLOCATE( sortTemp(nc(iD)), STAT=error )
d1513 2
a1514 2
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1516 2
a1517 6

                      DO i = 1, nc(iD)
                        pt(i) = 0
                        sortTemp(i) = 0.0
                      ENDDO
                      CALL my_sortp(l3r_temp(iD)%time, 1, nc(iD), pt)
d1519 1
a1519 1
                      CALL DSORT(l3r_temp(iD)%time, 1, nc(iD))
d1521 2
a1522 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r_temp(iD)%latitude(i)
d1524 2
a1525 2
                      DO i = 1, nc(iD)
                        l3r_temp(iD)%latitude(i) = sortTemp(pt(i))
d1528 2
a1529 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r_temp(iD)%longitude(i)
d1531 2
a1532 2
                      DO i = 1, nc(iD)
                        l3r_temp(iD)%longitude(i) = sortTemp(pt(i))
d1535 2
a1536 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r_temp(iD)%l2gpValue(1, iP, i)
d1538 2
a1539 2
                      DO i = 1, nc(iD)
                        l3r_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1541 1
a1541 1

d1543 2
a1544 2
		      CALL Residual2L2Grid( iD, iP, l3r_temp, l3r ) 

d1546 5
a1550 5
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1552 6
a1557 7

                      if ( associated(pt)) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
a1558 6

                      endif

                      !*** Calculate Maxmum Difference

                      if ( nc(iD) .gt. 0 ) then 
d1560 7
a1566 1
                      ALLOCATE( pt(nc(iD)), STAT=error )
d1568 2
a1569 2
                        msr = MLSMSG_Allocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1571 6
a1576 4

                      CALL my_sortp(-abs(l3r_temp(iD)%l2gpValue(1, iP, 1:nc(iD))), 1, nc(iD), pt)
                      DO i = 1, cfDef%N
                        l3dm(iD)%maxDiff(i, iP) = l3r_temp(iD)%l2gpValue(1, iP, pt(i))
d1578 1
a1578 1

d1580 5
a1584 5
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1586 8
a1593 8

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, l3dm(iD)%nLons
                        avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
d1595 12
d1608 8
a1615 16
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN
                      avg = avg/real(l3dm(iD)%nLons*cfProd%nLats)
                      ENDIF
                      l3dm(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, l3dm(iD)%nLons
                        l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP) +         &
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN
                      l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/ &
                        real(l3dm(iD)%nLons*cfProd%nLats)
                      ENDIF
                      l3dm(iD)%perMisPoints(iP) = perMisPoints(iP)
d1617 1
a1617 1
          ELSE IF (cfProd%mode == 'asc') THEN
d1619 4
a1622 4

                  if ( nc(iD) .gt. 0 ) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
d1624 2
a1625 2
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1627 2
a1628 2

                      ALLOCATE( sortTemp(nc(iD)), STAT=error )
d1630 2
a1631 2
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1633 2
a1634 2

                      CALL my_sortp(residA_temp(iD)%time, 1, nc(iD), pt)
d1636 1
a1636 1
                      CALL DSORT(residA_temp(iD)%time, 1, nc(iD))
d1638 5
a1642 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = residA_temp(iD)%latitude(i)
a1643 2
                      DO i = 1, nc(iD)
                        residA_temp(iD)%latitude(i) = sortTemp(pt(i))
d1645 2
d1648 2
a1649 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = residA_temp(iD)%longitude(i)
a1650 2
                      DO i = 1, nc(iD)
                        residA_temp(iD)%longitude(i) = sortTemp(pt(i))
d1652 2
d1655 2
a1656 2
                      DO i = 1, nc(iD)
                        sortTemp(i) = residA_temp(iD)%l2gpValue(1, iP, i)
d1658 1
a1658 4
                      DO i = 1, nc(iD)
                        residA_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
                      ENDDO

d1660 15
a1674 8
		      CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 

                      if ( associated(sortTemp)) then
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1676 8
a1683 3

                      if ( associated(pt) ) then
                      DeAllocate(pt, STAT=error)
d1685 2
a1686 2
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1688 3
a1690 15
                      endif

                      endif

                      !*** Calculate Maxmum Difference

                      if ( nc(iD) .gt. 0 ) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1692 2
a1693 1
                        dmA(iD)%maxDiff(i, iP) = residA_temp(iD)%l2gpValue(1, iP, pt(i))
d1695 1
a1695 88

                      if ( associated(pt) ) then
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      ENDDO
                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmA(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                        dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/ &
                        real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO
          ELSE IF (cfProd%mode == 'des') THEN
                DO iD = 1, rDays

                  if ( nc(iD) .gt. 0 ) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      ALLOCATE( sortTemp(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(residD_temp(iD)%time, 1, nc(iD), pt)
                      !** do time
                      CALL DSORT(residD_temp(iD)%time, 1, nc(iD))
                      !** do latitude
                      DO i = 1, nc(iD)
                        sortTemp(i) = residD_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                        residD_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, nc(iD)
                        sortTemp(i) = residD_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                        residD_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, nc(iD)
                        sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
                      ENDDO
                      DO i = 1, nc(iD)
                        residD_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
                      ENDDO

                      !*** Interpolate to l2gp grid 
		      CALL Residual2L2Grid( iD, iP, residD_temp, residD ) 

                      if ( associated(sortTemp) ) then 
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

d1697 5
a1701 7
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

d1703 2
d1706 3
a1708 28
                      !*** Calculate Maxmum Difference

                      if (nc(iD) .gt. 0) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
                      DO i = 1,cfDef%N
                        dmD(iD)%maxDiff(i, iP) = residD_temp(iD)%l2gpValue(1, iP, pt(i))
                      ENDDO

                      if ( associated(pt) ) then
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
d1710 1
a1710 1
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
d1712 2
a1713 2
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN
d1715 3
a1717 3
                      ENDIF
                      dmD(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
d1719 3
a1721 3
                        dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)
d1723 2
a1724 2
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
d1726 2
a1727 2
                        real(dmD(iD)%nLons*cfProd%nLats)
                      ENDIF
d1729 15
a1743 8
                ENDDO
          ELSE IF (cfProd%mode == 'ado') THEN
                DO iD = 1, rDays

                  if ( nca(iD) .gt. 0 ) then 
                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
d1745 7
a1751 13
                      ENDIF

                      ALLOCATE( sortTemp(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(residA_temp(iD)%time, 1, nca(iD), pt)
                      !** do time
                      CALL DSORT(residA_temp(iD)%time, 1, nca(iD))
                      !** do latitude
                      DO i = 1, nca(iD)
d1753 2
a1754 2
                      ENDDO
                      DO i = 1, nca(iD)
d1756 3
a1758 3
                      ENDDO
                      !** do longitude
                      DO i = 1, nca(iD)
d1760 2
a1761 2
                      ENDDO
                      DO i = 1, nca(iD)
d1763 3
a1765 3
                      ENDDO
                      !** do value
                      DO i = 1, nca(iD)
d1767 2
a1768 2
                      ENDDO
                      DO i = 1, nca(iD)
d1770 23
a1792 20
                      ENDDO

                      !*** Interpolate to l2gp grid 
		      CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 

                      if ( associated(sortTemp) ) then 
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif
                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

d1794 4
d1799 1
a1799 1
                      !*** Calculate Maxmum Difference
a1800 2
                      if ( nca(iD) .gt. 0 ) then 

d1803 2
a1804 2
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1807 2
a1808 1
                      CALL my_sortp(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1810 2
a1811 1
                        dmA(iD)%maxDiff(i, iP) = residA_temp(iD)%l2gpValue(1, iP, pt(i))
d1813 1
a1813 1

d1815 5
a1819 5
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1821 6
a1826 6

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
d1828 1
a1828 1
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
d1830 6
a1835 8
                      ENDDO

                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                        avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF

                      dmA(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
d1837 3
a1839 3
                        dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)
d1841 2
a1842 3
                      ENDDO

                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0 ) THEN 
d1844 3
a1846 4
                        real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF

                      dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
d1848 1
a1848 1

d1850 3
a1852 3

                  if (ncd(iD) .gt. 0) then 
                  
d1855 2
a1856 2
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1858 1
a1858 1

d1861 2
a1862 2
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d1864 1
a1864 1

d1868 1
a1868 1
                      !** do latitude
d1870 1
a1870 1
                        sortTemp(i) = residD_temp(iD)%latitude(i)
d1873 1
a1873 1
                        residD_temp(iD)%latitude(i) = sortTemp(pt(i))
d1877 1
a1877 1
                        sortTemp(i) = residD_temp(iD)%longitude(i)
d1880 1
a1880 1
                        residD_temp(iD)%longitude(i) = sortTemp(pt(i))
d1884 1
a1884 1
                        sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
d1887 1
a1887 1
                        residD_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1889 1
a1889 1

d1892 7
a1898 7

                      if ( associated(sortTemp) ) then 
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1901 5
a1905 5
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
d1907 1
a1907 675

                      endif

                      !*** Calculate Maxmum Difference

                      if (ncd(iD) .gt. 0) then 

                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
                      DO i = 1,cfDef%N
                        dmD(iD)%maxDiff(i, iP) = residD_temp(iD)%l2gpValue(1, iP, pt(i))
                      ENDDO

                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN
                      avg = avg/real(dmD(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmD(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                        dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/ & 
                        real(dmD(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmD(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO
          ELSE IF (cfProd%mode == 'all') THEN
                DO iD = 1, rDays

                  if (nca(iD) .gt. 0) then 

                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      ALLOCATE( sortTemp(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(residA_temp(iD)%time, 1, nca(iD), pt)
                      !** do time
                      CALL DSORT(residA_temp(iD)%time, 1, nca(iD))
                      !** do latitude
                      DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, nca(iD)
                        residA_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, nca(iD)
                        residA_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, nca(iD)
                        sortTemp(i) = residA_temp(iD)%l2gpValue(1, iP, i)
                      ENDDO
                      DO i = 1, nca(iD)
                        residA_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
                      ENDDO

                      !*** Interpolate to l2gp grid 
		      CALL Residual2L2Grid( iD, iP, residA_temp, residA ) 

                      if ( associated(sortTemp)) then 

                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      endif

                      if ( associated(pt) ) then 

                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      endif

                      endif

                      !*** Calculate Maxmum Difference

                      if (nca(iD) .gt. 0) then 

                      ALLOCATE( pt(nca(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
                      DO i = 1,cfDef%N
                        dmA(iD)%maxDiff(i, iP) = residA_temp(iD)%l2gpValue(1, iP, pt(i))
                      ENDDO

                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                        avg = avg + dmA(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      ENDDO
                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmA(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmA(iD)%nLons
                        dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP) +   &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (dmA(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/ & 
                        real(dmA(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmA(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO

                DO iD = 1, rDays

                  if (ncd(iD) .gt. 0) then 

                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      ALLOCATE( sortTemp(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(residD_temp(iD)%time, 1, ncd(iD), pt)
                      !** do time
                      CALL DSORT(residD_temp(iD)%time, 1, ncd(iD))
                      !** do latitude
                      DO i = 1, ncd(iD)
                        sortTemp(i) = residD_temp(iD)%latitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                        residD_temp(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, ncd(iD)
                        sortTemp(i) = residD_temp(iD)%longitude(i)
                      ENDDO
                      DO i = 1, ncd(iD)
                        residD_temp(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, ncd(iD)
                        sortTemp(i) = residD_temp(iD)%l2gpValue(1, iP, i)
                      ENDDO
                      DO i = 1, ncd(iD)
                        residD_temp(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
                      ENDDO

                      !*** Interpolate to l2gp grid 
		      CALL Residual2L2Grid( iD, iP, residD_temp, residD ) 

                      if ( associated(sortTemp) ) then
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif
                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !*** Calculate Maxmum Difference

                      if ( ncd(iD) .gt. 0 ) then 

                      ALLOCATE( pt(ncd(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
                      DO i = 1,cfDef%N
                        dmD(iD)%maxDiff(i, iP) = residD_temp(iD)%l2gpValue(1, iP, pt(i))
                      ENDDO

                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                        avg = avg + dmD(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      avg = avg/real(dmD(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmD(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, dmD(iD)%nLons
                        dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP) +   &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (dmD(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats)
                      ENDIF
                      dmD(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO

                DO iD = 1, rDays

                  if ( nc(iD) .gt. 0 ) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      ALLOCATE( sortTemp(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(l3r(iD)%time, 1, nc(iD), pt)
                      !** do time
                      CALL DSORT(l3r(iD)%time, 1, nc(iD))
                      !** do latitude
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r(iD)%latitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                        l3r(iD)%latitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do longitude
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r(iD)%longitude(i)
                      ENDDO
                      DO i = 1, nc(iD)
                        l3r(iD)%longitude(i) = sortTemp(pt(i))
                      ENDDO
                      !** do value
                      DO i = 1, nc(iD)
                        sortTemp(i) = l3r(iD)%l2gpValue(1, iP, i)
                      ENDDO
                      DO i = 1, nc(iD)
                        l3r(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
                      ENDDO

                      if ( associated(sortTemp) ) then 
                      DeAllocate(sortTemp, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  sortTemp array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !*** Calculate Maxmum Difference

                      if ( nc(iD) .gt. 0 ) then 

                      ALLOCATE( pt(nc(iD)), STAT=error )
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_Allocate // ' pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF

                      CALL my_sortp(-abs(l3r(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
                      DO i = 1,cfDef%N
                        l3dm(iD)%maxDiff(i, iP) = l3r(iD)%l2gpValue(1, iP, pt(i))
                      ENDDO

                      if ( associated(pt) ) then 
                      DeAllocate(pt, STAT=error)
                      IF ( error /= 0 ) THEN
                        msr = MLSMSG_DeAllocate // '  pt array.'
                        CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                      ENDIF
                      endif

                      endif

                      !***Root-Sum-Square for each latitude, dimensioned (nLevels)
                      avg = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, l3dm(iD)%nLons
                        avg = avg + l3dm(iD)%l3dmValue(iP, J, I)
                      ENDDO
                      ENDDO
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                        avg = avg/real(l3dm(iD)%nLons*cfProd%nLats)
                      ENDIF
                      l3dm(iD)%gRss(iP) = 0.0
                      DO J = 1, cfProd%nLats
                      DO I = 1, l3dm(iD)%nLons
                        l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP) +         &
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)* &
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      ENDDO
                      IF (l3dm(iD)%nLons*cfProd%nLats .ne. 0) THEN 
                      l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/ &
                        real(l3dm(iD)%nLons*cfProd%nLats)
                      ENDIF
                      l3dm(iD)%perMisPoints(iP) = perMisPoints(iP)
                ENDDO
          END IF

        ENDDO

   !*** Calculate Field Precisions ********

	iP = 0
	DO kP = pStartIndex, pStartIndex 
	  iP = iP + 1

	  DO J = 1, cfProd%nLats
       	     IF( anlats(J, iP) > 0 ) THEN

		IF( atimes(J, 1, iP) < dtimes(J, 1, iP) ) THEN

   		  lonD0_in = FindRealLon(real(dlons(J, 1, iP)))
   		  lonA0_in = FindRealLon(real(alons(J, 1, iP)))

	          CALL Init(cfProd%mode, 					&
			  nt_a_i   = anlats(J, iP), 				&
			  nt_d_i   = dnlats(J, iP), 				&
			  tau0_i   = tau0, 					&
			  delTad_i = delTad(J, iP), 				&
			  c0_i     = 2.0*PI, 					&
			  lonD0_i  = lonD0_in, 					&
			  tD0_i    = dtimes(J, 1, iP), 				&
			  lonA0_i  = lonA0_in, 					&
			  tA0_i    = atimes(J, 1, iP), 				&
			  lat_i    = alats(J, 1, iP) )
          	  CALL DataGenerate(aprec(J, :, iP), dprec(J, :, iP) )

		ELSE

   		  lonD0_in = FindRealLon(real(dlons(J, 2, iP)))
   		  lonA0_in = FindRealLon(real(alons(J, 1, iP)))

	          CALL Init(cfProd%mode, 					&
			  nt_a_i   = anlats(J, iP), 				&
			  nt_d_i   = dnlats(J, iP)-1, 				&
			  tau0_i   = tau0, 					&
			  delTad_i = delTad(J, iP), 				&
			  c0_i     = 2.0*PI, 					&
			  lonD0_i  = lonD0_in, 					&
			  tD0_i    = dtimes(J, 2, iP), 				&
			  lonA0_i  = lonA0_in, 					&
			  tA0_i    = atimes(J, 1, iP), 				&
			  lat_i    = alats(J, 1, iP) )
         	  CALL DataGenerate(aprec(J, :, iP), dprec(J, 2:, iP) )

		END IF

		IF (cfProd%mode == 'com') THEN

                  if (l3dm(1)%nLons .gt. 0) then 
                  
                   ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct(cfProd%mode, &
                        real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
			l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

		ELSE IF (cfProd%mode == 'asc') THEN

                  if (dmA(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMA(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct(cfProd%mode, &
                        real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
			dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

		ELSE IF (cfProd%mode == 'des') THEN

                  if (dmD(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMD(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct(cfProd%mode, &
                        real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
			dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

		ELSE IF (cfProd%mode == 'ado') THEN

                  if (dmA(1)%nLons .gt. 0) then 
                  
                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMA(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('asc', &
                        real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
			dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

                   if (dmD(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMD(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('des', &
                        real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
			dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

		ELSE IF (cfProd%mode == 'all') THEN

                  if (l3dm(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(l3dm(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform('com')
	   	   CALL FFSM(l3spPrec(1), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('com', &
                        real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
                      DO I = 1, l3dm(iD)%nLons
			l3dm(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

                   if (dmA(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(dmA(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF

                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMA(l3spPrec(2), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('asc', &
                        real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmA(iD)%nLons, dmA(iD)%longitude, l3Result)
                      DO I = 1, dmA(iD)%nLons
			dmA(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   endif

                   endif

                   if (dmD(1)%nLons .gt. 0) then 

                   ALLOCATE(l3Result(dmD(1)%nLons), STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_Allocate // ' l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
                   CALL CordTransform(cfProd%mode)
	   	   CALL FFSMD(l3spPrec(3), iP, J)
                   DO iD = 1, cfProd%nDays
        	      CALL Reconstruct('des', &
                        real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
                      DO I = 1, dmD(iD)%nLons
			dmD(iD)%l3dmPrecision(iP, J, I) = l3Result(I) 
		      ENDDO
		   ENDDO

                   if ( associated(l3Result) ) then 
		   DeAllocate(l3Result, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  l3Result array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1909 110
a2018 1

d2020 105
d2126 253
a2378 11
		END IF

                CALL ClearMemory()

	     END IF
	  ENDDO

	ENDDO

        if ( associated(l3spPrec) ) then 
	DeAllocate(l3spPrec, STAT=error)
d2383 4
a2386 4
        endif

        if ( associated(nc) ) then
	DeAllocate(nc, STAT=error)
d2388 2
a2389 2
              msr = MLSMSG_DeAllocate // '  nc array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2391 4
a2394 4
        endif

        if ( associated(nca) ) then 
	DeAllocate(nca, STAT=error)
d2396 2
a2397 2
              msr = MLSMSG_DeAllocate // '  nca array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2399 4
a2402 4
        endif

        if ( associated(ncd) ) then
	DeAllocate(ncd, STAT=error)
d2404 2
a2405 2
              msr = MLSMSG_DeAllocate // '  ncd array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2407 4
a2410 4
        endif

        if ( associated(startTime)) then 
	DeAllocate(startTime, STAT=error)
d2412 2
a2413 2
              msr = MLSMSG_DeAllocate // '  startTime array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2415 4
a2418 4
        endif

        if ( associated(endTime)) then
	DeAllocate(endTime, STAT=error)
d2420 2
a2421 2
              msr = MLSMSG_DeAllocate // '  endTime array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2423 4
a2426 4
        endif

        if ( associated(alats) ) then
	DeAllocate(alats, STAT=error)
d2428 2
a2429 2
              msr = MLSMSG_DeAllocate // '  alats array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2431 4
a2434 4
        endif

        if ( associated(dlats) ) then 
	DeAllocate(dlats, STAT=error)
d2436 2
a2437 2
              msr = MLSMSG_DeAllocate // '  dlats array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2439 4
a2442 4
        endif

        if ( associated(alons)) then
	DeAllocate(alons, STAT=error)
d2444 2
a2445 2
              msr = MLSMSG_DeAllocate // '  alons array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2447 4
a2450 4
        endif

        if ( associated(dlons)) then
	DeAllocate(dlons, STAT=error)
d2452 2
a2453 2
              msr = MLSMSG_DeAllocate // '  dlons array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2455 4
a2458 4
        endif

        if ( associated(atimes)) then
	DeAllocate(atimes, STAT=error)
d2460 2
a2461 2
              msr = MLSMSG_DeAllocate // '  atimes array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2463 4
a2466 4
        endif

        if ( associated(dtimes) ) then
	DeAllocate(dtimes, STAT=error)
d2468 2
a2469 2
              msr = MLSMSG_DeAllocate // '  dtimes array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2471 4
a2474 4
        endif

        if ( associated(afields) ) then
	DeAllocate(afields, STAT=error)
d2476 2
a2477 2
              msr = MLSMSG_DeAllocate // '  afields array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2479 4
a2482 4
        endif

        if ( associated(dfields) ) then
	DeAllocate(dfields, STAT=error)
d2484 2
a2485 2
              msr = MLSMSG_DeAllocate // '  dfields array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2487 4
a2490 4
        endif

        if ( associated(aprec)) then 
	DeAllocate(aprec, STAT=error)
d2492 2
a2493 2
              msr = MLSMSG_DeAllocate // '  aprec array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2495 4
a2498 4
        endif

        if ( associated(dprec)) then
	DeAllocate(dprec, STAT=error)
d2500 2
a2501 2
              msr = MLSMSG_DeAllocate // '  dprec array.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d2503 67
a2569 70
        endif

        CALL DestroyL2GPDatabase(l3r_temp)
        CALL DestroyL2GPDatabase(residA_temp)
        CALL DestroyL2GPDatabase(residD_temp)

!-----------------------------------
   END SUBROUTINE DailyCoreProcessing
!-----------------------------------



!-------------------------------------------------------------------------
   SUBROUTINE SortData(cfProd, l2Days, l2gp, pStartIndex, pEndIndex, tau0, anlats, dnlats, &
		alats_interp, dlats_interp, alons_interp, dlons_interp, 	&
		atimes_interp, dtimes_interp, afields_interp, dfields_interp,	&
		aprec_interp, dprec_interp, delTad, perMisPoints)
!-------------------------------------------------------------------------

        integer error, i, j, iT, iD, iP, kP, nterms, nstart, nr, lindex, lindex_prev
	INTEGER ::  l2Days, nloop, aindex, aindex_prev, dindex_prev

        TYPE( L3CFProd_T ) :: cfProd
        TYPE( L2GPData_T ), POINTER :: l2gp(:)

	Real (r8), POINTER, DIMENSION(:, :) ::  &
          l2Times(:, :), l2Lons_new(:, :), &
          l2Lons(:, :),  l2Lons_old(:, :), l2Lats(:, :), l2Values(:, :), l2Prec(:, :)

	Real (r8), POINTER, DIMENSION(:, :, :) ::  & 
          alons_interp(:, :, :), alats_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  & 
          dlons_interp(:, :, :), dlats_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  & 
          atimes_interp(:, :, :), dtimes_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  & 
          afields_interp(:, :, :), dfields_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  &
          aprec_interp(:, :, :), dprec_interp(:, :, :)

	Real (r8) &
          dlons, alons, lons_found, lats_found, times_found, fields_found, prec_found, 	&
	  slope, slope_time, slope_field, slope_prec, sTime

	Real (r8) lons_found_old

	Real tau0
 
	Integer nPd, pStartIndex, pEndIndex, iMin

	INTEGER, DIMENSION(cfProd%nLats, pEndIndex-pStartIndex+1) :: anlats, dnlats
	Real (r8), DIMENSION(cfProd%nLats, pEndIndex-pStartIndex+1) :: delTad 

        INTEGER, DIMENSION(pEndIndex-pStartIndex+1) :: perMisPoints, numData
        CHARACTER (LEN=480) :: msr

!*** Calculate the number of points in each pressure level 

	nPd = 15

        nterms = 0
	DO I = 1, l2Days
            nterms = nterms + l2gp(I)%nTimes
	ENDDO

!*** Allocate space for all the arrays

        if ((nterms.gt.0).and.( (pEndIndex-pStartIndex).ge.0) ) then 

        ALLOCATE(l2Times(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2574 3
a2576 3


        ALLOCATE(l2Lons(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2581 3
a2583 3


        ALLOCATE(l2Lats(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2588 3
a2590 3


	ALLOCATE(l2Values(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2595 3
a2597 3


        ALLOCATE(l2Lons_old(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2602 2
a2603 2

	ALLOCATE(l2Prec(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2608 2
a2609 2

        ALLOCATE(l2Lons_new(nterms, pEndIndex-pStartIndex+1), STAT=error)
d2614 8
a2621 6

          endif

        if ( (cfProd%nLats.gt.0).and.( (pEndIndex-pStartIndex).ge.0).and.(nPd*l2Days.gt.0)  ) then 

        ALLOCATE(alons_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2626 3
a2628 2

        ALLOCATE(alats_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2633 4
a2636 3

       ALLOCATE(atimes_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

d2641 4
a2644 3

      ALLOCATE(afields_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

d2649 4
a2652 3

	ALLOCATE(aprec_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

d2657 4
a2660 3

        ALLOCATE(dlons_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

d2665 3
a2667 2

        ALLOCATE(dlats_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2672 3
a2674 2

       ALLOCATE(dtimes_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2679 3
a2681 2

      ALLOCATE(dfields_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2686 4
a2689 3

	ALLOCATE(dprec_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

d2694 7
a2700 7

          endif


!*** Re-arrange the data into longitude order for each pressure level 

        DO kP = pStartIndex, pEndIndex
d2703 4
a2706 4
        ENDDO

        nstart = 1
	DO iD = 1, l2Days
d2708 2
a2709 2
	    iP = 0
	    DO kP = pStartIndex, pEndIndex 
d2711 2
a2712 2
                l2Times(nstart, iP) = l2gp(iD)%time(iT)
                l2Lons(nstart, iP) = l2gp(iD)%longitude(iT) * PI/180.0
d2714 8
a2721 7
                l2Lats(nstart, iP) = l2gp(iD)%latitude(iT)
                l2Values(nstart, iP) = l2gp(iD)%l2gpValue(1, kP, iT) 
		l2Prec(nstart, iP) = l2gp(iD)%l2gpPrecision(1, kP, iT)
                IF(l2Values(nstart, iP) < 0.0) perMisPoints(iP) = perMisPoints(iP) + 1
                numData(iP) = numData(iP) + 1
	    ENDDO
            nstart = nstart + 1
d2723 3
a2725 3
	ENDDO

        DO kP = pStartIndex, pEndIndex
d2727 9
a2735 9
            perMisPoints(kP+1-pStartIndex) = & 
              100*perMisPoints(kP+1-pStartIndex)/numData(kP+1-pStartIndex)
            endif
        ENDDO

!*** Re-arrange the longitude into sequence 

	iP = 0
	DO kP = pStartIndex, pEndIndex 
d2739 6
a2744 6
                IF( l2Lons(iT, iP) >= 0.0 .AND. l2Lons(iT-1, iP) < 0.0 ) THEN 
     			l2Lons_new(iT, iP) = l2Lons(iT, iP) - nr*2.0*PI - 2.0*PI
     			nr = nr + 1
		ELSE
     			l2Lons_new(iT, iP) = l2Lons(iT, iP) - nr*2.0*PI
		END IF
d2747 6
a2752 6
	ENDDO

!*** Convert time reference to the starting point

	iP = 0
	DO kP = pStartIndex, pEndIndex 
d2756 1
a2756 1
                l2Times(iT, iP) = (l2Times(iT, iP) - sTime)/86400.0 
d2758 17
a2774 17
	ENDDO

!*** Find longitudes & latitudes for L3 latitudes in L2 data points 

        dlons = 0.3*PI/180.0

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1

 	  alons = l2Lons_new(1, iP) 

	  lindex = 1
	  lindex_prev = 0
	  aindex_prev = 0
	  dindex_prev = 0

d2776 2
a2777 2

	  DO J = 1, cfProd%nLats
d2781 1
a2781 1

d2783 97
a2879 83
	    alons = alons -  dlons
	    DO iT = lindex, nterms-1 
              IF( l2Lons_new(iT, iP) > alons .AND. l2Lons_new(iT+1, iP) <= alons ) THEN
	 	 lindex = iT
	 	 EXIT
	      END IF
	    ENDDO

            IF ( lindex /= lindex_prev ) THEN

	     lindex_prev = lindex

	     DO J = 1, cfProd%nLats
              IF( ( l2Lats(lindex, iP) <= cfProd%latGridMap(J) .AND. 	&
		    l2Lats(lindex+1, iP) > cfProd%latGridMap(J) )  .OR.	&
                  ( l2Lats(lindex, iP) >= cfProd%latGridMap(J) .AND. 	&
		    l2Lats(lindex+1, iP) < cfProd%latGridMap(J) )  ) THEN
                
                if (abs(l2Lons_new(lindex+1, iP)-l2Lons_new(lindex, iP)).ge.1.0e-12) then 
		slope = (l2Lats(lindex+1, iP)-l2Lats(lindex, iP))/	&
			(l2Lons_new(lindex+1, iP)-l2Lons_new(lindex, iP))
                endif

                if (abs(l2Lons_new(lindex+1, iP)-l2Lons_new(lindex, iP)).ge.1.0e-12) then 
		slope_time = (l2Times(lindex+1, iP)-l2Times(lindex, iP))/	&
			(l2Lons_new(lindex+1, iP)-l2Lons_new(lindex, iP))
                endif

                if (abs(l2Lons(lindex+1, iP)-l2Lons(lindex, iP)).ge.1.0e-12) then 
		slope_field = (l2Values(lindex+1, iP)-l2Values(lindex, iP))/	&
			(l2Lons(lindex+1, iP)-l2Lons(lindex, iP))
                endif 

                if (abs(l2Lons(lindex+1, iP)-l2Lons(lindex, iP)).ge.1.0e-12) then 
                slope_prec = (l2Prec(lindex+1, iP)-l2Prec(lindex, iP))/ &
                        (l2Lons(lindex+1, iP)-l2Lons(lindex, iP))
                endif

		IF(ABS(slope) < 1.e-6) THEN
		   lons_found = l2Lons_new(lindex, iP)
		   lons_found_old = l2Lons_old(lindex, iP)
		ELSE
		   lons_found = l2Lons_new(lindex, iP) + & 
                     (cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
		   lons_found_old = l2Lons_old(lindex, iP) + &
                     (cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
		END IF
		lats_found = cfProd%latGridMap(J)
		times_found = l2Times(lindex, iP) + &
                  (lons_found-l2Lons_new(lindex, iP))*slope_time
		fields_found = l2Values(lindex, iP) + & 
                  (lons_found-l2Lons_new(lindex, iP))*slope_field
		prec_found = l2Prec(lindex, iP) + & 
                  (lons_found-l2Lons_new(lindex, iP))*slope_prec
                aindex = J
		EXIT
	      END IF
	     ENDDO
              
	     IF( slope < 0 .and. aindex /= aindex_prev) THEN
	         aindex_prev = aindex
       	           anlats(aindex, iP) = anlats(aindex, iP) + 1 
	           alons_interp(aindex, anlats(aindex, iP), iP) = lons_found
	           alats_interp(aindex, anlats(aindex, iP), iP) = lats_found
	           atimes_interp(aindex, anlats(aindex, iP), iP) = times_found
	           afields_interp(aindex, anlats(aindex, iP), iP) = fields_found
		   aprec_interp(aindex, anlats(aindex, iP), iP) = prec_found
	     END IF

	     IF( slope >= 0 .and. aindex /= dindex_prev) THEN
	         dindex_prev = aindex
		 IF(anlats(aindex, iP) > 0) THEN
       	           dnlats(aindex, iP) = dnlats(aindex, iP) + 1 
	           dlons_interp(aindex, dnlats(aindex, iP), iP) = lons_found
	           dlats_interp(aindex, dnlats(aindex, iP), iP) = lats_found
	           dtimes_interp(aindex, dnlats(aindex, iP), iP) = times_found
	           dfields_interp(aindex, dnlats(aindex, iP), iP) = fields_found
		   dprec_interp(aindex, dnlats(aindex, iP), iP) = prec_found
	         END IF
	     END IF

	    END IF

d2881 21
a2901 19

        ENDDO

!*** Find averaged asc/des time difference 

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
	  DO J = 1, cfProd%nLats
            delTad(J,iP) = 0.0
            IF (anlats(J, iP) < dnlats(J, iP)) THEN
		iMin = anlats(J, iP)
	    ELSE
		iMin = dnlats(J, iP)
	    END IF 
	    DO I = 2, iMin 
             delTad(J,iP) = delTad(J,iP) + dtimes_interp(J, I, iP) - atimes_interp(J, I, iP)
	    ENDDO
            IF(iMin > 0) THEN
d2903 1
a2903 1
	    ELSE
d2905 3
a2907 3
	    END IF

            IF(delTad(J,iP) < 0) THEN
d2909 105
a3013 101
	    END IF
	  ENDDO
	ENDDO

!*** Deallocate intermediate arrays 

        if ((nterms.gt.0).and.( (pEndIndex-pStartIndex).ge.0) ) then 

        if ( associated(l2Times) ) then
        DEALLOCATE(l2Times, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Times pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Lons) ) then 
        DEALLOCATE(l2Lons, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Lons pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Lons_new) ) then
        DEALLOCATE(l2Lons_new, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Lons_new pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Lons_old) ) then
        DEALLOCATE(l2Lons_old, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Lons_old pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Lats) ) then
        DEALLOCATE(l2Lats, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Lats pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Values) ) then
        DEALLOCATE(l2Values, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Values pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        if ( associated(l2Prec) ) then
        DEALLOCATE(l2Prec, STAT=error)
          IF ( error /= 0 ) THEN
              msr = MLSMSG_DeAllocate // '  l2Prec pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
        endif

        endif

!-----------------------------------
   END SUBROUTINE SortData
!-----------------------------------


!-------------------------------------------------------------------------
   REAL(r8) FUNCTION FindRealLon(alon)
!-------------------------------------------------------------------------

	Real alon

	IF(mod(alon, 2.0*PI) < -PI) THEN
	   FindRealLon = 2.0*PI + mod(alon, 2.0*PI) 
	ELSE IF(mod(alon, 2.0*PI) > PI) THEN
	   FindRealLon = -2.0*PI + mod(alon, 2.0*PI) 
	ELSE 
	   FindRealLon = mod(alon, 2.0*PI) 
	END IF

!-----------------------------------
   END FUNCTION FindRealLon
!-----------------------------------


!-------------------------------------------------------------------------
   SUBROUTINE Residual2L2Grid( iD, iP, l3r_temp, l3r ) 
!-------------------------------------------------------------------------

        integer error, i, j, iT, iD, iP, icount 
	INTEGER ::  l2Days, nloop, aindex, aindex_prev, dindex_prev

        TYPE( L2GPData_T ), POINTER :: l3r(:), l3r_temp(:)

        icount = 1
        DO I = 1, l3r(iD)%nTimes 
d3015 21
a3035 13
 	    If( l3r(iD)%time(I) < l3r_temp(iD)%time(1) .OR. l3r(iD)%time(I) > l3r_temp(iD)%time(l3r(iD)%nTimes) ) Then
		 l3r(iD)%l2gpValue(1, iP, I) = 0.0 
		 EXIT
 	    Else If( l3r(iD)%time(I) > l3r_temp(iD)%time(J) .AND. l3r(iD)%time(I) < l3r_temp(iD)%time(J+1) ) Then
		 l3r(iD)%l2gpValue(1, iP, I) =  l3r_temp(iD)%l2gpValue(1, iP, J) + &
				(l3r(iD)%time(I) - l3r_temp(iD)%time(J))*	&
				(l3r_temp(iD)%l2gpValue(1, iP, J+1) - l3r_temp(iD)%l2gpValue(1, iP, J))/	&
				(l3r_temp(iD)%time(J+1) - l3r_temp(iD)%time(J))
		 If( J > icount) Then
			icount = J
		 End If
		 EXIT
	    End If
d3037 24
a3060 24
        ENDDO

!-----------------------------------
   END SUBROUTINE Residual2L2Grid
!-----------------------------------

subroutine my_sortp_r4(sngl_array, n, m, pt_array)
  real(r4), dimension(*), intent(in) :: sngl_array
  integer, intent(in)                :: n
  integer, intent(in)                :: m
  integer, dimension(*), intent(out) :: pt_array
  call ssortp(sngl_array, n, m, pt_array)
end subroutine my_sortp_r4

subroutine my_sortp_r8(dbl_array, n, m, pt_array)
  real(r8), dimension(*), intent(in) :: dbl_array
  integer, intent(in)                :: n
  integer, intent(in)                :: m
  integer, dimension(*), intent(out) :: pt_array
  call dsortp(dbl_array, n, m, pt_array)
end subroutine my_sortp_r8

!===================
END MODULE Synoptic
d3064 3
@


1.27
log
@Fix residual problem in order to interpolate to L2GP grid
@
text
@d26 1
a26 1
   PRIVATE :: ID, ModuleName
d30 1
a30 1
   "$Id: Synoptic.f90,v 1.26 2002/04/30 20:05:21 jdone Exp $"
d42 4
d1017 1
a1017 1
                      CALL DSORTP(l3r_temp(iD)%time, 1, nc(iD), pt)
d1073 1
a1073 1
                      CALL DSORTP(-abs(l3r_temp(iD)%l2gpValue(1, iP, 1:nc(iD))), 1, nc(iD), pt)
d1129 1
a1129 1
                      CALL DSORTP(residA_temp(iD)%time, 1, nc(iD), pt)
d1185 1
a1185 1
                      CALL DSORTP(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1241 1
a1241 1
                      CALL DSORTP(residD_temp(iD)%time, 1, nc(iD), pt)
d1297 1
a1297 1
                      CALL DSORTP(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1352 1
a1352 1
                      CALL DSORTP(residA_temp(iD)%time, 1, nca(iD), pt)
d1407 1
a1407 1
                      CALL DSORTP(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1467 1
a1467 1
                      CALL DSORTP(residD_temp(iD)%time, 1, ncd(iD), pt)
d1522 1
a1522 1
                      CALL DSORTP(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d1578 1
a1578 1
                      CALL DSORTP(residA_temp(iD)%time, 1, nca(iD), pt)
d1638 1
a1638 1
                      CALL DSORTP(-abs(residA_temp(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1694 1
a1694 1
                      CALL DSORTP(residD_temp(iD)%time, 1, ncd(iD), pt)
d1749 1
a1749 1
                      CALL DSORTP(-abs(residD_temp(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d1804 1
a1804 1
                      CALL DSORTP(l3r(iD)%time, 1, nc(iD), pt)
d1857 1
a1857 1
                      CALL DSORTP(-abs(l3r(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d2826 15
d2847 3
@


1.26
log
@indexing issues related to nc* arrays
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.25 2002/04/11 00:53:57 jdone Exp $"
d64 1
d263 2
d274 2
d285 2
d295 3
a297 2
           l3r(j)%latitude     = 0.0
           l3r(j)%longitude    = 0.0
d299 3
a301 2
           residA(j)%latitude  = 0.0
           residA(j)%longitude = 0.0
d303 3
a305 2
           residD(j)%latitude  = 0.0
           residD(j)%longitude = 0.0
a386 1

d485 5
a489 5
		   l3r(iD)%time(nc(iD))  = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	           l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	           l3r(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
		   l3r(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
	           l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d499 5
a503 5
		   l3r(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		   l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
		   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
		   l3r(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		   l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d565 5
a569 5
	         residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	         residA(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	         residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
	         residA(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
		 residA(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d629 5
a633 5
		  residD(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		  residD(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
	          residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
	          residD(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		  residD(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d695 5
a699 5
                           residA(iD)%time(nca(iD)) = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                           residA(iD)%longitude(nca(iD))=FindRealLon(real(alons(J,iL,iP)))*180./PI
                           residA(iD)%latitude(nca(iD)) = cfProd%latGridMap(J)  
                           residA(iD)%l2gpValue(1, iP, nca(iD)) = afields(J, iL, iP)-l3ret
                           residA(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0
d759 5
a763 5
                  residD(iD)%longitude(ncd(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180./PI
                  residD(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                  residD(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J)  
                  residD(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret
                  residD(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0
d825 3
a827 3
		        l3r(iD)%time(nc(iD))  = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			l3r(iD)%longitude(nc(iD)) = & 
d829 2
a830 2
			   l3r(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
			   l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d838 5
a842 5
	             l3r(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
	             l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
		     l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
		     l3r(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
		     l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d899 5
a903 5
		  residA(iD)%time(nca(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
		  residA(iD)%latitude(nca(iD)) = cfProd%latGridMap(J) 
		  residA(iD)%longitude(nca(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
                  residA(iD)%l2gpValue(1, iP, nca(iD)) = afields(J, iL, iP)-l3ret 
                  residA(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0 
d961 5
a965 5
		  residD(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                  residD(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J) 
                  residD(iD)%longitude(ncd(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
                  residD(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret 
                  residD(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0 
d1013 1
a1013 1
                      CALL DSORTP(l3r(iD)%time, 1, nc(iD), pt)
d1015 1
a1015 1
                      CALL DSORT(l3r(iD)%time, 1, nc(iD))
d1018 1
a1018 1
                        sortTemp(i) = l3r(iD)%latitude(i)
d1021 1
a1021 1
                        l3r(iD)%latitude(i) = sortTemp(pt(i))
d1025 1
a1025 1
                        sortTemp(i) = l3r(iD)%longitude(i)
d1028 1
a1028 1
                        l3r(iD)%longitude(i) = sortTemp(pt(i))
d1032 1
a1032 1
                        sortTemp(i) = l3r(iD)%l2gpValue(1, iP, i)
d1035 1
a1035 1
                        l3r(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1037 4
a1040 1
                      
d1069 1
a1069 1
                      CALL DSORTP(-abs(l3r(iD)%l2gpValue(1, iP, 1:nc(iD))), 1, nc(iD), pt)
d1071 1
a1071 1
                        l3dm(iD)%maxDiff(i, iP) = l3r(iD)%l2gpValue(1, iP, pt(i))
d1125 1
a1125 1
                      CALL DSORTP(residA(iD)%time, 1, nc(iD), pt)
d1127 1
a1127 1
                      CALL DSORT(residA(iD)%time, 1, nc(iD))
d1130 1
a1130 1
                        sortTemp(i) = residA(iD)%latitude(i)
d1133 1
a1133 1
                        residA(iD)%latitude(i) = sortTemp(pt(i))
d1137 1
a1137 1
                        sortTemp(i) = residA(iD)%longitude(i)
d1140 1
a1140 1
                        residA(iD)%longitude(i) = sortTemp(pt(i))
d1144 1
a1144 1
                        sortTemp(i) = residA(iD)%l2gpValue(1, iP, i)
d1147 1
a1147 1
                        residA(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1150 3
d1181 1
a1181 1
                      CALL DSORTP(-abs(residA(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1183 1
a1183 1
                        dmA(iD)%maxDiff(i, iP) = residA(iD)%l2gpValue(1, iP, pt(i))
d1237 1
a1237 1
                      CALL DSORTP(residD(iD)%time, 1, nc(iD), pt)
d1239 1
a1239 1
                      CALL DSORT(residD(iD)%time, 1, nc(iD))
d1242 1
a1242 1
                        sortTemp(i) = residD(iD)%latitude(i)
d1245 1
a1245 1
                        residD(iD)%latitude(i) = sortTemp(pt(i))
d1249 1
a1249 1
                        sortTemp(i) = residD(iD)%longitude(i)
d1252 1
a1252 1
                        residD(iD)%longitude(i) = sortTemp(pt(i))
d1256 1
a1256 1
                        sortTemp(i) = residD(iD)%l2gpValue(1, iP, i)
d1259 1
a1259 1
                        residD(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1262 3
d1293 1
a1293 1
                      CALL DSORTP(-abs(residD(iD)%l2gpValue(1, iP, :)), 1, nc(iD), pt)
d1295 1
a1295 1
                        dmD(iD)%maxDiff(i, iP) = residD(iD)%l2gpValue(1, iP, pt(i))
d1348 1
a1348 1
                      CALL DSORTP(residA(iD)%time, 1, nca(iD), pt)
d1350 1
a1350 1
                      CALL DSORT(residA(iD)%time, 1, nca(iD))
d1353 1
a1353 1
                        sortTemp(i) = residA(iD)%latitude(i)
d1356 1
a1356 1
                        residA(iD)%latitude(i) = sortTemp(pt(i))
d1360 1
a1360 1
                        sortTemp(i) = residA(iD)%longitude(i)
d1363 1
a1363 1
                        residA(iD)%longitude(i) = sortTemp(pt(i))
d1367 1
a1367 1
                        sortTemp(i) = residA(iD)%l2gpValue(1, iP, i)
d1370 1
a1370 1
                        residA(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1372 4
d1403 1
a1403 1
                      CALL DSORTP(-abs(residA(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1405 1
a1405 1
                        dmA(iD)%maxDiff(i, iP) = residA(iD)%l2gpValue(1, iP, pt(i))
d1463 1
a1463 1
                      CALL DSORTP(residD(iD)%time, 1, ncd(iD), pt)
d1465 1
a1465 1
                      CALL DSORT(residD(iD)%time, 1, ncd(iD))
d1468 1
a1468 1
                        sortTemp(i) = residD(iD)%latitude(i)
d1471 1
a1471 1
                        residD(iD)%latitude(i) = sortTemp(pt(i))
d1475 1
a1475 1
                        sortTemp(i) = residD(iD)%longitude(i)
d1478 1
a1478 1
                        residD(iD)%longitude(i) = sortTemp(pt(i))
d1482 1
a1482 1
                        sortTemp(i) = residD(iD)%l2gpValue(1, iP, i)
d1485 1
a1485 1
                        residD(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1488 3
d1518 1
a1518 1
                      CALL DSORTP(-abs(residD(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d1520 1
a1520 1
                        dmD(iD)%maxDiff(i, iP) = residD(iD)%l2gpValue(1, iP, pt(i))
d1574 1
a1574 1
                      CALL DSORTP(residA(iD)%time, 1, nca(iD), pt)
d1576 1
a1576 1
                      CALL DSORT(residA(iD)%time, 1, nca(iD))
d1579 1
a1579 1
                        sortTemp(i) = residA(iD)%latitude(i)
d1582 1
a1582 1
                        residA(iD)%latitude(i) = sortTemp(pt(i))
d1586 1
a1586 1
                        sortTemp(i) = residA(iD)%longitude(i)
d1589 1
a1589 1
                        residA(iD)%longitude(i) = sortTemp(pt(i))
d1593 1
a1593 1
                        sortTemp(i) = residA(iD)%l2gpValue(1, iP, i)
d1596 1
a1596 1
                        residA(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1599 3
d1634 1
a1634 1
                      CALL DSORTP(-abs(residA(iD)%l2gpValue(1, iP, :)), 1, nca(iD), pt)
d1636 1
a1636 1
                        dmA(iD)%maxDiff(i, iP) = residA(iD)%l2gpValue(1, iP, pt(i))
d1690 1
a1690 1
                      CALL DSORTP(residD(iD)%time, 1, ncd(iD), pt)
d1692 1
a1692 1
                      CALL DSORT(residD(iD)%time, 1, ncd(iD))
d1695 1
a1695 1
                        sortTemp(i) = residD(iD)%latitude(i)
d1698 1
a1698 1
                        residD(iD)%latitude(i) = sortTemp(pt(i))
d1702 1
a1702 1
                        sortTemp(i) = residD(iD)%longitude(i)
d1705 1
a1705 1
                        residD(iD)%longitude(i) = sortTemp(pt(i))
d1709 1
a1709 1
                        sortTemp(i) = residD(iD)%l2gpValue(1, iP, i)
d1712 1
a1712 1
                        residD(iD)%l2gpValue(1, iP, i) = sortTemp(pt(i))
d1714 4
d1745 1
a1745 1
                      CALL DSORTP(-abs(residD(iD)%l2gpValue(1, iP, :)), 1, ncd(iD), pt)
d1747 1
a1747 1
                        dmD(iD)%maxDiff(i, iP) = residD(iD)%l2gpValue(1, iP, pt(i))
d2321 4
d2790 32
d2828 3
@


1.25
log
@initialization added
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.24 2002/04/10 21:30:33 jdone Exp $"
a46 1
!     l3dm, dmA, dmD, l3r, residA, residD, flags)
d122 1
d152 6
a157 1
        l3sp%endTime = l2gp(l2Days)%time(l2gp(l2Days)%nTimes)
a261 1
!          pcf%l3EndDay, rDays, l3r)
a270 1
!          pcf%l3EndDay, rDays, residA)
a279 1
!          pcf%l3EndDay, rDays, residD)
d353 1
a353 1

d470 3
a472 2
		IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
                   atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
d474 2
a475 1
		   CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
d481 1
d483 1
d680 1
d685 3
a687 2
                           residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+ & 
                             l2gp(1)%time(1)
a688 2
                           residA(iD)%longitude(nc(iD)) = &
                             FindRealLon(real(alons(J, iL, iP)))*180.0/PI
d691 1
d749 2
a752 1
                  residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
d755 1
d890 1
a890 1
		  residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
d892 1
a892 1
		  residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
d951 1
d954 1
a954 1
                  residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
d2760 3
@


1.24
log
@associated statements before deallocate added
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.23 2002/04/01 21:57:13 jdone Exp $"
d250 6
d259 7
d269 7
d2750 3
@


1.23
log
@check division by zero
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.22 2002/03/27 22:45:17 jdone Exp $"
d47 1
a90 1

d180 2
d200 2
d251 1
d254 1
d257 1
d285 2
d319 2
d408 3
a411 1

d472 2
d479 1
d484 3
d488 4
d497 1
d538 2
d545 1
d550 3
d554 3
d602 2
d609 1
d614 3
d618 3
d668 2
d675 1
d680 4
d685 5
d730 2
d737 1
d742 3
d746 3
d808 2
d815 1
d820 4
d869 2
d876 1
d881 4
d930 2
d937 1
d942 3
d955 3
d999 1
d1001 5
a1005 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1007 1
d1009 7
a1015 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1018 3
d1022 5
d1031 2
d1034 7
a1040 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1068 3
d1107 2
d1110 5
a1114 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1116 1
d1118 7
a1124 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1127 3
d1140 2
d1143 7
a1149 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1177 3
d1216 2
d1219 5
a1223 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1225 1
d1227 7
a1233 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1236 3
d1249 2
d1252 7
a1258 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1286 2
d1324 1
d1326 12
a1337 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1339 1
a1339 5
                      DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1342 3
d1355 2
d1358 7
a1364 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1396 3
d1435 2
d1438 12
a1449 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1451 1
a1451 5
                      DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1454 3
d1467 2
d1470 7
a1476 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1504 3
d1543 3
d1547 8
a1554 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1557 8
a1564 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1567 3
d1580 2
d1583 7
a1589 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1617 3
d1656 1
d1658 12
a1669 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1671 1
a1671 5
                      DeAllocate(pt, STAT=error)
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1674 3
d1687 2
d1690 7
a1696 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1723 3
d1762 2
d1765 5
a1769 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  sortTemp array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1771 1
d1773 7
a1779 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
d1782 3
d1795 2
d1798 7
a1804 4
                   IF ( error /= 0 ) THEN
                     msr = MLSMSG_DeAllocate // '  pt array.'
                     CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
                   ENDIF
a1838 1
	print *, 'Residual Loop -- Processing Level =', kP
d1882 3
d1902 1
d1908 3
d1913 3
d1933 1
d1939 3
d1944 3
d1964 1
d1970 3
d1975 3
d1995 1
d2001 5
d2024 1
d2030 3
d2035 3
d2039 5
d2055 1
d2061 5
d2084 1
d2090 5
d2112 1
d2118 3
d2131 1
d2137 1
d2139 1
d2145 1
d2147 1
d2153 1
d2155 1
d2161 1
d2163 1
d2169 1
d2171 1
d2177 1
d2179 1
d2185 1
d2187 1
d2193 1
d2195 1
d2201 1
d2203 1
d2209 1
d2211 1
d2217 1
d2219 1
d2225 1
d2227 1
d2233 1
d2235 1
d2241 1
d2243 1
d2249 1
d2251 1
d2257 1
d2320 2
d2368 4
d2437 2
d2638 1
a2638 1
!*** Deallocate intermidiate arrays 
d2640 1
d2642 1
d2645 1
a2645 1
              msr = MLSMSG_DeAllocate // '  l2Times array.'
d2648 1
d2650 1
d2653 1
a2653 1
              msr = MLSMSG_DeAllocate // '  l2Lons array.'
d2656 1
d2658 1
d2661 1
a2661 1
              msr = MLSMSG_DeAllocate // '  l2Lons_new array.'
d2664 1
d2666 1
d2669 1
a2669 1
              msr = MLSMSG_DeAllocate // '  l2Lons_old array.'
d2672 1
d2674 1
d2677 1
a2677 1
              msr = MLSMSG_DeAllocate // '  l2Lats array.'
d2680 1
d2682 1
d2685 1
a2685 1
              msr = MLSMSG_DeAllocate // '  l2Values array.'
d2688 1
d2690 1
d2693 1
a2693 1
              msr = MLSMSG_DeAllocate // '  l2Prec array.'
d2696 1
d2698 1
d2730 3
@


1.22
log
@deallocate statements added
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.21 2002/03/27 21:35:14 jdone Exp $"
d46 2
a47 2
   SUBROUTINE DailyCoreProcessing(cfDef, cfProd, pcf, l2Days, l2gp, avgPeriod, l3sp, l3dm, dmA, dmD, &
				  l3r, residA, residD, mis_l2Days, mis_Days, flags)
d86 2
a87 1
	INTEGER ::  error, l2Days, nlev, nlev_temp, nf, nwv, numDays, numSwaths, rDays, pEndIndex, pStartIndex
d238 4
d246 6
a251 6
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, &
                          mis_l2Days_temp, mis_Days_temp, l3r)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, &
                          mis_l2Days_temp, mis_Days_temp, residA)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, &
                          mis_l2Days_temp, mis_Days_temp, residD)
d327 1
a327 1
	tau0 = tau0/86400.0/float(size(avgPeriod))
d365 10
a374 10
	          CALL Init(cfProd%mode, 						&
			  nt_a_i   = anlats(J, iP), 				&
			  nt_d_i   = dnlats(J, iP), 				&
			  tau0_i   = tau0, 					&
			  delTad_i = delTad(J, iP), 				&
			  c0_i     = 2.0*PI, 					&
			  lonD0_i  = lonD0_in, 					&
			  tD0_i    = dtimes(J, 1, iP), 				&
			  lonA0_i  = lonA0_in, 					&
			  tA0_i    = atimes(J, 1, iP), 				&
d382 10
a391 10
	          CALL Init(cfProd%mode, 						&
			  nt_a_i   = anlats(J, iP), 				&
			  nt_d_i   = dnlats(J, iP)-1, 				&
			  tau0_i   = tau0, 					&
			  delTad_i = delTad(J, iP), 				&
			  c0_i     = 2.0*PI, 					&
			  lonD0_i  = lonD0_in, 					&
			  tD0_i    = dtimes(J, 2, iP), 				&
			  lonA0_i  = lonA0_in, 					&
			  tA0_i    = atimes(J, 1, iP), 				&
d407 3
a409 2
        	      CALL Reconstruct(cfProd%mode, real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    l3dm(iD)%nLons, l3dm(iD)%longitude, l3Result)
a411 2
			if(l3Result(I) < 0.0) then
			end if
d413 1
a413 1
                      !***Root-Sum-Square for each latitude, dimensioned (nLevels, nLats)
d418 1
a418 1
                      avg = avg/real(l3dm(iD)%nLons)
d421 3
a423 2
                        l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J) +       &
                                                   (l3dm(iD)%l3dmValue(iP, J, I)-avg)*(l3dm(iD)%l3dmValue(iP, J, I)-avg)
d425 6
a430 1
                      l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/real(l3dm(iD)%nLons)
d435 2
a436 2
			IF(atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) >= startTime(iD) .AND. &
			   atimes(J, iL, iP)*86400.0+l2gp(1)%time(1) <= endTime(iD)) THEN
d438 6
a443 6
		           CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
			   l3r(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
			   l3r(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
			   l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d450 6
a455 6
		           CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
			   l3r(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
			   l3r(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
			   l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d478 1
a478 1
        	      CALL Reconstruct(cfProd%mode, real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d488 1
a488 1
                      avg = avg/real(dmA(iD)%nLons)
d491 3
a493 2
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +         &
                                                   (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d495 1
d497 1
d505 6
a510 6
		           CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
			   residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   residA(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
			   residA(iD)%l2gpValue(1, iP, nc(iD)) = afields(J, iL, iP)-l3ret 
			   residA(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d533 2
a534 2
        	      CALL Reconstruct(cfProd%mode, real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
				    dmD(iD)%nLons, dmD(iD)%longitude, l3Result)
d543 1
a543 1
                      avg = avg/real(dmD(iD)%nLons)
d546 3
a548 2
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +         &
                                                   (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
d550 1
d552 1
d560 6
a565 6
		           CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
			   residD(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   residD(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
			   residD(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
			   residD(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d588 1
a588 1
                      CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0,       &
d598 1
a598 1
                      avg = avg/real(dmA(iD)%nLons)
d601 3
a603 2
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +         &
                                                   (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d605 1
d607 1
d615 3
a617 2
                           CALL Diagnostics('asc', atimes(J, iL, iP), alons(J, iL, iP), l3ret)
                           residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
d619 2
a620 1
                           residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
d639 1
a639 1
                      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0,       &
d649 1
a649 1
                      avg = avg/real(dmD(iD)%nLons)
d652 8
a659 4
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +         &
                                                   (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J)/real(dmD(iD)%nLons)
d667 6
a672 6
                           CALL Diagnostics('des', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret)
                           residD(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
                           residD(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J)  
                           residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
                           residD(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret
                           residD(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0
d695 1
a695 1
        	      CALL Reconstruct('com', real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d705 1
a705 1
                      avg = avg/real(l3dm(iD)%nLons)
d708 8
a715 4
                        l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J) +       &
                                                   (l3dm(iD)%l3dmValue(iP, J, I)-avg)*(l3dm(iD)%l3dmValue(iP, J, I)-avg)
                      ENDDO
                      l3dm(iD)%latRss(iP, J) = l3dm(iD)%latRss(iP, J)/real(l3dm(iD)%nLons)
d723 5
a727 4
		           CALL Diagnostics('com', atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
			   l3r(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
d736 6
a741 6
		           CALL Diagnostics('com', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
			   l3r(iD)%time(nc(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   l3r(iD)%latitude(nc(iD)) = cfProd%latGridMap(J) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
			   l3r(iD)%l2gpValue(1, iP, nc(iD)) = dfields(J, iL, iP)-l3ret 
			   l3r(iD)%l2gpPrecision(1, iP, nc(iD)) = 0.0 
d763 1
a763 1
        	      CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d773 1
a773 1
                      avg = avg/real(dmA(iD)%nLons)
d776 3
a778 2
                        dmA(iD)%latRss(iP, J) = dmA(iD)%latRss(iP, J) +         &
                                                   (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d780 1
d782 1
d790 6
a795 6
		           CALL Diagnostics('asc', atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
			   residA(iD)%time(nc(iD))     = atimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   residA(iD)%latitude(nca(iD)) = cfProd%latGridMap(J) 
			   residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))*180.0/PI
			   residA(iD)%l2gpValue(1, iP, nca(iD)) = afields(J, iL, iP)-l3ret 
			   residA(iD)%l2gpPrecision(1, iP, nca(iD)) = 0.0 
d817 1
a817 1
        	      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d827 1
a827 1
                      avg = avg/real(dmD(iD)%nLons)
d830 3
a832 2
                        dmD(iD)%latRss(iP, J) = dmD(iD)%latRss(iP, J) +         &
                                                   (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
d834 1
d836 1
d844 6
a849 6
		           CALL Diagnostics('des', dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
			   residD(iD)%time(ncd(iD))     = dtimes(J, iL, iP)*86400.0+l2gp(1)%time(1)
			   residD(iD)%latitude(ncd(iD)) = cfProd%latGridMap(J) 
			   residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))*180.0/PI
			   residD(iD)%l2gpValue(1, iP, ncd(iD)) = dfields(J, iL, iP)-l3ret 
			   residD(iD)%l2gpPrecision(1, iP, ncd(iD)) = 0.0 
d944 1
d946 1
d951 2
a952 1
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)*(l3dm(iD)%l3dmValue(iP, J, I)-avg)
d955 4
a958 1
                      l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/real(l3dm(iD)%nLons*cfProd%nLats)
d984 1
a985 1
                      !** do longitude
d991 1
a992 1
                      !** do value
d1035 1
d1037 1
d1042 2
a1043 1
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d1046 4
a1049 1
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats)
d1126 1
d1128 1
d1133 2
a1134 1
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
d1137 4
a1140 1
                      dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats)
d1217 5
a1221 1
                      avg = avg/real(dmA(iD)%nLons*cfProd%nLats)
d1226 2
a1227 1
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d1230 6
a1235 1
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats)
d1312 1
d1314 1
d1319 2
a1320 1
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
d1323 4
a1326 1
                      dmD(iD)%gRss(iP) = dmD(iD)%gRss(iP)/real(dmD(iD)%nLons*cfProd%nLats)
d1403 1
d1405 1
d1410 2
a1411 1
                                           (dmA(iD)%l3dmValue(iP, J, I)-avg)*(dmA(iD)%l3dmValue(iP, J, I)-avg)
d1414 4
a1417 1
                      dmA(iD)%gRss(iP) = dmA(iD)%gRss(iP)/real(dmA(iD)%nLons*cfProd%nLats)
d1494 1
d1496 1
d1501 2
a1502 1
                                           (dmD(iD)%l3dmValue(iP, J, I)-avg)*(dmD(iD)%l3dmValue(iP, J, I)-avg)
d1505 1
d1507 1
d1584 3
a1586 1
                      avg = avg/real(l3dm(iD)%nLons*cfProd%nLats)
d1591 2
a1592 1
                                           (l3dm(iD)%l3dmValue(iP, J, I)-avg)*(l3dm(iD)%l3dmValue(iP, J, I)-avg)
d1595 4
a1598 1
                      l3dm(iD)%gRss(iP) = l3dm(iD)%gRss(iP)/real(l3dm(iD)%nLons*cfProd%nLats)
d1663 2
a1664 1
        	      CALL Reconstruct(cfProd%mode, real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1687 2
a1688 1
        	      CALL Reconstruct(cfProd%mode, real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1711 2
a1712 1
        	      CALL Reconstruct(cfProd%mode, real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1735 2
a1736 1
        	      CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1758 2
a1759 1
        	      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1777 2
a1778 1
        	      CALL Reconstruct('com', real(l3dm(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1800 2
a1801 1
        	      CALL Reconstruct('asc', real(dmA(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1822 2
a1823 1
        	      CALL Reconstruct('des', real(dmD(iD)%time-l2gp(1)%time(1))/86400.0, 	&
d1948 1
a1948 1
   SUBROUTINE SortData(cfProd, l2Days, l2gp, pStartIndex, pEndIndex, tau0, anlats, dnlats, 	&
d1960 18
a1977 11
	Real (r8), POINTER, DIMENSION(:, :) ::  l2Times(:, :), l2Lons_new(:, :), l2Lons(:, :),  l2Lons_old(:, :), &
						l2Lats(:, :), l2Values(:, :), l2Prec(:, :)

	Real (r8), POINTER, DIMENSION(:, :, :) ::  alons_interp(:, :, :), alats_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  dlons_interp(:, :, :), dlats_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  atimes_interp(:, :, :), dtimes_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  afields_interp(:, :, :), dfields_interp(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  aprec_interp(:, :, :), dprec_interp(:, :, :)

	Real (r8) dlons, alons, lons_found, lats_found, times_found, fields_found, prec_found, 	&
		  slope, slope_time, slope_field, slope_prec, sTime
d2060 1
a2060 1
        ALLOCATE(atimes_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2067 1
a2067 1
        ALLOCATE(afields_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2094 1
a2094 1
        ALLOCATE(dtimes_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2100 1
a2100 1
        ALLOCATE(dfields_interp(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
d2141 4
a2144 1
          perMisPoints(kP+1-pStartIndex) = 100*perMisPoints(kP+1-pStartIndex)/numData(kP+1-pStartIndex)
d2215 2
d2219 3
d2224 3
d2229 3
d2234 2
d2240 4
a2243 2
		   lons_found = l2Lons_new(lindex, iP) + (cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
		   lons_found_old = l2Lons_old(lindex, iP) + (cfProd%latGridMap(J)-l2Lats(lindex, iP))/slope
d2246 6
a2251 3
		times_found = l2Times(lindex, iP) + (lons_found-l2Lons_new(lindex, iP))*slope_time
		fields_found = l2Values(lindex, iP) + (lons_found-l2Lons_new(lindex, iP))*slope_field
		prec_found = l2Prec(lindex, iP) + (lons_found-l2Lons_new(lindex, iP))*slope_prec
a2258 1
		 !IF(dnlats(aindex, iP) > 0) THEN
a2264 1
	         !END IF
d2298 1
a2298 1
                delTad(J,iP) = delTad(J,iP) + dtimes_interp(J, I, iP) - atimes_interp(J, I, iP)
d2301 1
a2301 1
                delTad(J,iP) = delTad(J,iP)/float(iMin-1)
d2388 3
@


1.21
log
@allocate statements checked and maxDiff is initialized
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.20 2002/02/20 22:30:33 ybj Exp $"
a1873 2
	Real (r8), POINTER, DIMENSION(:, :, :) ::  alons_interp_old(:, :, :), dlons_interp_old(:, :, :)

a2010 12
        ALLOCATE(alons_interp_old(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)
          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' alons_interp_old array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF

        ALLOCATE(dlons_interp_old(cfProd%nLats, nPd*l2Days, pEndIndex-pStartIndex+1), STAT=error)

          IF ( error /= 0 ) THEN
             msr = MLSMSG_Allocate // ' dlons_interp_old array.'
             CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF
a2142 1
	           alons_interp_old(aindex, anlats(aindex, iP), iP) = lons_found_old
a2154 1
	           dlons_interp_old(aindex, dnlats(aindex, iP), iP) = lons_found_old
d2193 7
d2267 3
@


1.20
log
@*** empty log message ***
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.19 2002/02/20 22:13:54 ybj Exp $"
a85 2
        CHARACTER (LEN=480) :: msr

d91 1
d97 1
d131 5
d138 1
a138 1
           msr = MLSMSG_Allocate // ' l3sp array.'
d178 8
a185 1
        ALLOCATE( l3dm(numDays), dmA(numDays), dmD(numDays), STAT=error )
d187 7
a193 1
           msr = MLSMSG_Allocate // ' l3dm, l3r arrays.'
d233 4
d275 6
d282 5
d288 4
d294 5
d300 5
d339 1
d393 6
d406 2
d449 6
a454 1
		   DeAllocate(l3Result)
d460 5
d501 6
a506 1
		   DeAllocate(l3Result)
d512 5
d553 6
a558 1
		   DeAllocate(l3Result)
d564 5
d605 5
a609 1
                   DeAllocate(l3Result) 
d651 5
a655 1
                   DeAllocate(l3Result) 
d662 5
d715 5
a719 1
		   DeAllocate(l3Result)
d725 5
d766 5
a770 1
		   DeAllocate(l3Result)
d776 5
d817 5
a821 1
		   DeAllocate(l3Result)
d837 5
d843 5
d876 12
a887 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d895 5
a899 1
                      DeAllocate(pt)
d922 5
d928 5
d957 11
a967 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d971 5
d980 5
a984 1
                      DeAllocate(pt)
d1007 5
d1013 5
d1042 11
a1052 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1056 5
d1065 5
a1069 1
                      DeAllocate(pt)
d1092 5
d1098 5
d1127 11
a1137 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1141 5
d1150 5
a1154 1
                      DeAllocate(pt)
d1177 5
d1183 5
d1212 11
a1222 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1226 5
d1235 5
a1239 1
                      DeAllocate(pt)
d1262 5
d1268 5
d1297 11
a1307 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1311 5
d1320 5
a1324 1
                      DeAllocate(pt)
d1347 5
d1353 5
d1382 11
a1392 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1396 5
d1405 5
a1409 1
                      DeAllocate(pt)
d1432 5
d1438 5
d1467 11
a1477 2
                      DeAllocate(sortTemp)
                      DeAllocate(pt)
d1481 5
d1490 5
a1494 1
                      DeAllocate(pt)
d1521 1
a1521 1
	DO kP = pStartIndex, pEndIndex 
d1523 1
d1568 5
d1583 6
a1588 1
		   DeAllocate(l3Result)
d1591 5
d1606 6
a1611 1
		   DeAllocate(l3Result)
d1614 5
d1629 6
a1634 1
		   DeAllocate(l3Result)
d1637 5
d1652 5
a1656 1
		   DeAllocate(l3Result)
d1659 5
d1674 5
a1678 1
		   DeAllocate(l3Result)
d1692 5
a1696 1
		   DeAllocate(l3Result)
d1699 5
d1714 5
a1718 1
		   DeAllocate(l3Result)
d1721 4
d1735 5
a1739 1
		   DeAllocate(l3Result)
d1750 95
a1844 5
	DeAllocate(l3spPrec)
	DeAllocate(nc, nca, ncd)
	DeAllocate(startTime, endTime)

	DeAllocate(alats, dlats, alons, dlons, atimes, dtimes, afields, dfields, aprec, dprec)
d1889 1
d1903 6
d1910 6
d1917 6
d1924 12
d1937 4
d1943 4
a1946 1
        ALLOCATE(l2Lons_old(nterms, pEndIndex-pStartIndex+1), STAT=error)
d1949 5
d1955 5
d1961 6
d1968 6
d1975 6
d1982 6
d1989 5
d1995 5
d2001 5
d2008 5
d2014 5
d2021 4
a2024 4
	IF(error /= 0 ) THEN
          print *, "Allocation Error"
	  STOP
	END IF
a2173 1

a2177 1

d2209 36
a2244 1
        DEALLOCATE(l2Lons, l2Lons_new, l2Lons_old, l2Lats, l2Values, l2Prec)
d2276 3
@


1.19
log
@*** empty log message ***
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.18 2001/09/27 20:38:31 ybj Exp $"
a711 2
	ENDDO

d1645 3
@


1.18
log
@Add Precision Calculation & ado mode
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.17 2001/09/27 20:07:14 ybj Exp $"
d46 2
a47 2
   SUBROUTINE DailyCoreProcessing(cfProd, pcf, l2Days, l2gp, avgPeriod, l3sp, l3dm, dmA, dmD, &
				  l3r, residA, residD, flags)
d57 1
d75 1
d78 4
a81 1
        REAL(r8), DIMENSION(:), POINTER :: l3Result       ! returned reconstructed result 
d90 6
a95 2
        integer i, j, iP, kP, iD, iL
	real tau0, l3ret
d100 1
a100 1
        nwv = 10
d124 1
a124 1
        IF (cfProd%mode == 'all') THEN
d137 1
a137 1
        IF (cfProd%mode == 'all') THEN
d161 9
d179 1
a179 1
!!      Initialize Daily Map 
d187 3
a189 3
           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, l3dm(j) )
           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, dmA(j) )
           CALL AllocateL3DM( nlev, cfProd%nLats, cfProd%nLons, dmD(j) )
d219 6
a224 3
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, l3r)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, residA)
        CALL ReadL2GPProd(cfProd%l3prodNameD, cfProd%fileTemplate, pcf%l3StartDay, pcf%l3EndDay, rDays, residD)
d232 2
d235 2
d238 2
d288 1
a288 1
			delTad )
d353 12
d407 12
d449 12
d483 1
a483 1
                   CALL CordTransform(cfProd%mode)
d491 12
d525 1
a525 1
                   CALL CordTransform(cfProd%mode)
d533 12
d576 12
d630 12
d672 12
d714 465
d1230 1
a1230 2
                   !DO iD = 1, cfProd%nDays
                   DO iD = 1, 1 
d1357 1
a1357 1
		aprec_interp, dprec_interp, delTad)
d1389 2
d1432 5
d1449 2
d1456 4
d1647 3
@


1.17
log
@Add Precision Calculation
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.16 2001/09/06 18:45:37 nakamura Exp $"
d418 61
d1047 3
@


1.16
log
@Initialized pStart/EndIndex; removed some unused variables.
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.15 2001/08/13 19:28:03 ybj Exp $"
d61 1
a61 1
        TYPE( L3SPData_T ), POINTER :: l3sp(:)
d70 1
d122 1
d142 1
d259 3
a261 1
			afields, dfields, delTad )
d265 2
d336 1
a336 2
			   !l3r(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))
d348 1
a348 2
			   !l3r(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))
d378 1
a378 2
			   !residA(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
			   residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))
d408 1
a408 2
			   !residD(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
			   residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))
d438 1
a438 2
			   !l3r(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))
d450 1
a450 2
			   !l3r(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
			   l3r(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))
d480 1
a480 2
			   !residA(iD)%longitude(nca(iD)) = alons(J, iL, iP) - mod( real(alons(J, iL, iP)), (2.0*PI) ) 
			   residA(iD)%longitude(nc(iD)) = FindRealLon(real(alons(J, iL, iP)))
d510 1
a510 2
			   !residD(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
			   residD(iD)%longitude(nc(iD)) = FindRealLon(real(dlons(J, iL, iP)))
d530 164
d697 1
a697 4
	DeAllocate(alats, dlats, alons, dlons, atimes, dtimes, afields, dfields)

	close(12)
	close(13)
d709 1
a709 1
		delTad)
d719 1
a719 1
						l2Lats(:, :), l2Values(:, :)
d725 1
d729 2
a730 2
	Real (r8) dlons, alons, lons_found, lats_found, times_found, fields_found, 	&
		  slope, slope_time, slope_field, sTime
d755 2
a756 1
        ALLOCATE(l2Values(nterms, pEndIndex-pStartIndex+1), STAT=error)
d765 1
d770 1
d793 1
a798 2
	close(12)

a811 1
     		!l2Lons_new(iT, iP) = l2Lons(iT, iP)
d873 2
d885 1
d899 1
d912 1
d954 1
a954 1
        DEALLOCATE(l2Lons, l2Lons_new, l2Lons_old, l2Lats, l2Values)
a970 7
	ELSE
	   FindRealLon = mod(alon, 2.0*PI) 
	END IF
	IF(mod(alon, 2.0*PI) < -PI) THEN
	   FindRealLon = 2.0*PI + mod(alon, 2.0*PI) 
	ELSE IF(mod(alon, 2.0*PI) > PI) THEN
	   FindRealLon = -2.0*PI + mod(alon, 2.0*PI) 
d986 3
@


1.15
log
@*** empty log message ***
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.14 2001/08/13 16:42:20 ybj Exp $"
d106 2
d553 1
a553 1
	INTEGER ::  l2Days, nloop, aindex, aindex_prev, dindex, dindex_prev
d569 1
a569 1
		  slope, slope_time, slope_field, sTime, ddtad
d826 3
@


1.14
log
@*** empty log message ***
@
text
@d30 1
a30 1
   "$Id: Synoptic.f90,v 1.13 2001/04/12 16:04:41 ybj Exp $"
d82 1
a82 1
	INTEGER ::  error, l2Days, nlev, nf, nwv, numDays, numSwaths, rDays, pEndIndex, pStartIndex
a89 1
	nlev = 24
d103 7
d230 6
d824 3
@


1.13
log
@reasonable values
@
text
@a14 1
   USE L3DZData
d30 1
a30 1
   "$Id: Synoptic.f90,v 1.12 2001/04/11 18:29:22 ybj Exp $"
d47 1
a47 1
					l3dz, dzA, dzD, l3r, residA, residD, flags)
a54 2
	integer, Parameter :: nlons = 180

a60 1
	TYPE( L3DZData_T ), POINTER :: l3dz(:), dzA(:), dzD(:)
d85 1
a85 1
	real zonAvg, tau0, l3ret
a144 1
        ALLOCATE( l3dz(numDays), dzA(numDays), dzD(numDays), STAT=error )
a187 34
!!      Initialize Daily Zonal Mean 

        l3dz%name = cfProd%l3prodNameD
        dzA%name = TRIM(cfProd%l3prodNameD) // 'Ascending'
        dzD%name = TRIM(cfProd%l3prodNameD) // 'Descending'

        DO j = 1, numDays

           CALL AllocateL3DZ( nlev, cfProd%nLats, l3dz(j) )
           CALL AllocateL3DZ( nlev, cfProd%nLats, dzA(j) )
           CALL AllocateL3DZ( nlev, cfProd%nLats, dzD(j) )

           l3dz(j)%time = cfProd%timeD(j)
           dzA(j)%time = cfProd%timeD(j)
           dzD(j)%time = cfProd%timeD(j)

           l3dz(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           dzA(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)
           dzD(j)%pressure = l2gp(1)%pressures(pStartIndex:pEndIndex)

           l3dz(j)%latitude = cfProd%latGridMap(:l3dm(j)%nLats)
           dzA(j)%latitude = cfProd%latGridMap(:dmA(j)%nLats)
           dzD(j)%latitude = cfProd%latGridMap(:dmD(j)%nLats)

           l3dz(j)%l3dzValue = 0.0
           dzA(j)%l3dzValue = 0.0
           dzD(j)%l3dzValue = 0.0

           l3dz(j)%l3dzPrecision = 0.0
           dzA(j)%l3dzPrecision = 0.0
           dzD(j)%l3dzPrecision = 0.0

        ENDDO

d190 3
a192 3
        CALL ReadL2GPProd(cfProd, pcf%l3StartDay, pcf%l3EndDay, rDays, l3r)
        CALL ReadL2GPProd(cfProd, pcf%l3StartDay, pcf%l3EndDay, rDays, residA)
        CALL ReadL2GPProd(cfProd, pcf%l3StartDay, pcf%l3EndDay, rDays, residD)
a208 1
        flags%writel3dzAsc = .FALSE.
a209 1
	flags%writel3dzDes = .FALSE.
d235 1
a235 1
	Call SortData(cfProd, l2Days, l2gp, 		&
a257 2
   		lonD0_in = FindRealLon(real(dlons(J, 1, iP)))
   		lonA0_in = FindRealLon(real(alons(J, 1, iP)))
d259 6
a264 1
	        CALL Init(cfProd%mode, 						&
d275 20
a294 1
          	CALL DataGenerate(afields(J, :, iP), dfields(J, :, iP) )
a301 1
		      zonAvg = 0.0
a303 1
		        zonAvg = zonAvg + l3Result(I) 
a304 1
		      l3dz(iD)%l3dzValue(iP, J) = zonAvg/float(l3dm(iD)%nLons) 
a336 1
		   flags%writel3dzCom = .TRUE.
a345 1
		      zonAvg = 0.0
a347 1
		        zonAvg = zonAvg + l3Result(I) 
a348 1
		      dzA(iD)%l3dzValue(iP, J) = zonAvg/float(dmA(iD)%nLons) 
a367 1
		   flags%writel3dzAsc = .TRUE.
a376 1
		      zonAvg = 0.0
a378 1
		        zonAvg = zonAvg + l3Result(I) 
a379 1
		      dzD(iD)%l3dzValue(iP, J) = zonAvg/float(dmD(iD)%nLons) 
a398 1
		   flags%writel3dzDes = .TRUE.
a407 1
		      zonAvg = 0.0
a409 1
		        zonAvg = zonAvg + l3Result(I) 
a410 1
		      l3dz(iD)%l3dzValue(iP, J) = zonAvg/float(l3dm(iD)%nLons) 
a443 1
		   flags%writel3dzCom = .TRUE.
a451 1
		      zonAvg = 0.0
a453 1
		        zonAvg = zonAvg + l3Result(I) 
a454 1
		      dzA(iD)%l3dzValue(iP, J) = zonAvg/float(dmA(iD)%nLons) 
a474 1
		   flags%writel3dzAsc = .TRUE.
a482 1
		      zonAvg = 0.0
a484 1
		        zonAvg = zonAvg + l3Result(I) 
a485 1
		      dzD(iD)%l3dzValue(iP, J) = zonAvg/float(dmD(iD)%nLons) 
a505 1
		   flags%writel3dzDes = .TRUE.
d522 3
d620 2
d812 3
@


1.12
log
@reasonable values
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.11 2001/03/08 00:53:15 ybj Exp $"
d337 2
a338 1
			   l3r(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
d350 2
a351 1
			   l3r(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
d385 2
a386 1
			   residA(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
d420 2
a421 1
			   residD(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
d455 2
a456 1
			   l3r(iD)%longitude(nc(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
d468 2
a469 1
			   l3r(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
d503 2
a504 1
			   residA(iD)%longitude(nca(iD)) = alons(J, iL, iP) -  mod( real(alons(J, iL, iP)), (2.0*PI) ) 
d538 2
a539 1
			   residD(iD)%longitude(nc(iD)) = dlons(J, iL, iP) -  mod( real(dlons(J, iL, iP)), (2.0*PI) ) 
d850 3
@


1.11
log
@*** empty log message ***
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.10 2001/03/08 00:37:17 ybj Exp $"
d90 1
d96 1
a96 1
        nf = cfProd%nFreqs
d138 2
d183 8
d217 8
a297 1
	  !DO J = 10, 10 
d299 13
a311 10
	        CALL Init(cfProd%mode, 				&
			  nt_a_i   = anlats(J, iP), 		&
			  nt_d_i   = dnlats(J, iP), 		&
			  tau0_i   = tau0, 			&
			  delTad_i = delTad(J, iP), 		&
			  c0_i     = 2.0*PI, 			&
			  lonD0_i  = alons(J, 1, iP), 		&
			  tD0_i    = atimes(J, 1, iP), 		&
			  lonA0_i  = dlons(J, 1, iP), 		&
			  tA0_i    = dtimes(J, 1, iP), 		&
d313 1
a313 1
          	CALL DataGenerate(cfProd%mode, afields(J, :, iP), dfields(J, :, iP) )
d448 1
a448 1
		           CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
d460 1
a460 1
		           CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
d494 1
a494 1
		           CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
d528 1
a528 1
		           CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
d555 1
a555 1
!	DeAllocate( anlats, dnlats, alats, dlats, alons, dlons, atimes, dtimes, afields, dfields, delTad )
d576 2
a577 4
	Real (r8), POINTER, DIMENSION(:, :) ::  l2Times(:, :), l2Times_Rev(:, :), &
						l2Lons_new(:, :), l2Lons(:, :), l2Lons_Rev(:, :), &
						l2Lats(:, :), l2Lats_Rev(:, :), &
						l2Values(:, :), l2Values_Rev(:, :)
d584 2
d589 2
d593 1
a593 1
	Integer nPd, pStartIndex, pEndIndex
d615 1
a615 4
        ALLOCATE(l2Lons_Rev(nterms, pEndIndex-pStartIndex+1), STAT=error)
        ALLOCATE(l2Times_Rev(nterms, pEndIndex-pStartIndex+1), STAT=error)
        ALLOCATE(l2Lats_Rev(nterms, pEndIndex-pStartIndex+1), STAT=error)
        ALLOCATE(l2Values_Rev(nterms, pEndIndex-pStartIndex+1), STAT=error)
d626 3
d644 1
d665 1
d670 1
a670 11
!*** Reverse longitude order

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
	  DO iT = 1, nterms 
     		l2Lons_Rev(iT, iP) = l2Lons_new(nterms+1-iT, iP)
	  ENDDO
	ENDDO

!*** Reverse time order
a680 32
	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
	  DO iT = 1, nterms 
                l2Times_Rev(iT, iP) = l2Times(nterms+1-iT, iP)
	  ENDDO
	ENDDO

!*** Reverse latitude order

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
	  DO iT = 1, nterms 
     		l2Lats_Rev(iT, iP) = l2Lats(nterms+1-iT, iP)
	  ENDDO
	ENDDO

!*** Reverse field value order

	iP = 0
	DO kP = pStartIndex, pEndIndex 
	  iP = iP + 1
	  DO iT = 1, nterms 
     		l2Values_Rev(iT, iP) = l2Values(nterms+1-iT, iP)
	  ENDDO
	ENDDO

!*** Deallocate intermidiate arrays 

        DEALLOCATE(l2Lons, l2Lons_new, l2Lats, l2Values)

d689 1
a689 1
 	  alons = l2Lons_Rev(1, iP) 
d696 1
a696 1
          nloop = (l2Lons_Rev(nterms, iP)-l2Lons_Rev(1, iP))/dlons
d704 1
a704 1
	    alons = alons +  dlons
d706 1
a706 1
              IF( l2Lons_Rev(iT, iP) < alons .AND. l2Lons_Rev(iT+1, iP) >= alons ) THEN
d717 10
a726 10
              IF( ( l2Lats_Rev(lindex, iP) <= cfProd%latGridMap(J) .AND. 	&
		    l2Lats_Rev(lindex+1, iP) > cfProd%latGridMap(J) )  .OR.	&
                  ( l2Lats_Rev(lindex, iP) >= cfProd%latGridMap(J) .AND. 	&
		    l2Lats_Rev(lindex+1, iP) < cfProd%latGridMap(J) )  ) THEN
		slope = (l2Lats_Rev(lindex+1, iP)-l2Lats_Rev(lindex, iP))/	&
			(l2Lons_Rev(lindex+1, iP)-l2Lons_Rev(lindex, iP))
		slope_time = (l2Times_Rev(lindex+1, iP)-l2Times_Rev(lindex, iP))/	&
			(l2Lons_Rev(lindex+1, iP)-l2Lons_Rev(lindex, iP))
		slope_field = (l2Values_Rev(lindex+1, iP)-l2Values_Rev(lindex, iP))/	&
			(l2Lons_Rev(lindex+1, iP)-l2Lons_Rev(lindex, iP))
d728 2
a729 1
		   lons_found = l2Lons_Rev(lindex, iP)
d731 2
a732 1
		   lons_found = l2Lons_Rev(lindex, iP) + (cfProd%latGridMap(J)-l2Lats_Rev(lindex, iP))/slope
d735 2
a736 2
		times_found = l2Times_Rev(lindex, iP) + (lons_found-l2Lons_Rev(lindex, iP))*slope_time
		fields_found = l2Values_Rev(lindex, iP) + (lons_found-l2Lons_Rev(lindex, iP))*slope_field
a737 3
                if(aindex == 1) then
	           !print *, 'aindex=1 case:', lats_found, lons_found, times_found
	  	end if
d742 1
a742 5
             !if(lats_found <= -74.0 .and. lons_found < -2830.0) then
	!	print *, aindex, lons_found, lats_found
	!     end if

	     IF( slope <= 0 .and. aindex /= aindex_prev) THEN
d744 8
a751 5
       	         anlats(aindex, iP) = anlats(aindex, iP) + 1 
	         alons_interp(aindex, anlats(aindex, iP), iP) = lons_found
	         alats_interp(aindex, anlats(aindex, iP), iP) = lats_found
	         atimes_interp(aindex, anlats(aindex, iP), iP) = times_found
	         afields_interp(aindex, anlats(aindex, iP), iP) = fields_found
d754 1
a754 1
	     IF( slope > 0 .and. aindex /= dindex_prev) THEN
d756 8
a763 5
       	         dnlats(aindex, iP) = dnlats(aindex, iP) + 1 
	         dlons_interp(aindex, dnlats(aindex, iP), iP) = lons_found
	         dlats_interp(aindex, dnlats(aindex, iP), iP) = lats_found
	         dtimes_interp(aindex, dnlats(aindex, iP), iP) = times_found
	         dfields_interp(aindex, dnlats(aindex, iP), iP) = fields_found
d781 7
a787 2
	    DO I = 1, anlats(J, iP) 
                delTad(J,iP) = delTad(J,iP) + atimes_interp(J, I, iP) - dtimes_interp(J, I, iP)
d789 2
a790 2
            IF(anlats(J, iP) > 0) THEN
              delTad(J,iP) = delTad(J,iP)/float(anlats(J, iP))
d792 1
a792 1
              delTad(J,iP) = 0.0 
d794 1
d796 1
a796 1
              delTad(J,iP) = delTad(J,iP) + tau0 
d803 1
a803 2
        DEALLOCATE(l2Lons_Rev, l2Times_Rev, l2Lats_Rev, l2Values_Rev)

d810 25
d842 3
@


1.10
log
@*** empty log message ***
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.9 2001/03/07 23:12:15 ybj Exp $"
d534 2
d813 1
a813 1
        DEALLOCATE(l2Lons_new, l2Lons_Rev, l2Times_Rev, l2Lats_Rev, l2Values_Rev)
d828 3
@


1.9
log
@*** empty log message ***
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.8 2001/03/05 19:58:59 ybj Exp $"
a74 1
	Real (r8), POINTER, DIMENSION(:) :: l2gpValue_1Day
d88 1
a88 2
        integer i, j, k, ctype, iP, kP, iD, iL
        real(r8), Dimension(nlons) :: xlon, result
d257 1
a257 1
	Call SortData(cfProd, pcf, l2Days, l2gp, 		&
a538 16
!-------------------------------------------------------------------------
   SUBROUTINE ParameterCalc(cfProd, pcf, l2Days, l2gp)
!-------------------------------------------------------------------------

        integer error, i, j, k, iT, iD, iP, ctype, nterms, nstart, nr, lindex, lindex_prev
	INTEGER ::  l2Days, nloop, aindex, aindex_prev, dindex, dindex_prev

        TYPE( PCFData_T ) :: pcf
        TYPE( L3CFProd_T ) :: cfProd
        TYPE( L2GPData_T ), POINTER :: l2gp(:)


!-----------------------------------
   END SUBROUTINE ParameterCalc
!-----------------------------------

d541 1
a541 1
   SUBROUTINE SortData(cfProd, pcf, l2Days, l2gp, pStartIndex, pEndIndex, tau0, anlats, dnlats, 	&
d547 1
a547 1
        integer error, i, j, k, iT, iD, iP, kP, ctype, nterms, nstart, nr, lindex, lindex_prev
a549 1
        TYPE( PCFData_T ) :: pcf
d811 2
a818 48
!-------------------------------------------------------------------------
   SUBROUTINE TransformCord(cfProd, pcf, l2Days, alats, dlats, alons, dlons, atimes, dtimes, afields, dfields)
!-------------------------------------------------------------------------

        integer error, i, j, k, iT, iD, iP, ctype, nterms, nstart, nr, lindex, lindex_prev
	INTEGER ::  l2Days, nloop, aindex, aindex_prev, dindex, dindex_prev

        TYPE( PCFData_T ) :: pcf
        TYPE( L3CFProd_T ) :: cfProd

	Real (r8), POINTER, DIMENSION(:, :) ::  l2Times(:, :), l2Times_Rev(:, :), &
						l2Lons_new(:, :), l2Lons(:, :), l2Lons_Rev(:, :), &
						l2Lats(:, :), l2Lats_Rev(:, :), &
						l2Values(:, :), l2Values_Rev(:, :)

	Real (r8), POINTER, DIMENSION(:, :, :) ::  alons(:, :, :), alats(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  dlons(:, :, :), dlats(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  atimes(:, :, :), dtimes(:, :, :)
	Real (r8), POINTER, DIMENSION(:, :, :) ::  afields(:, :, :), dfields(:, :, :)


 
! Read the l2gp data for ClO, the first product listed in the cf (and the only
! one for which simulated input files currently exist)



!-----------------------------------
   END SUBROUTINE TransformCord
!-----------------------------------



!-------------------------------------------------------------------------
   INTEGER FUNCTION FindL2LongitudeIndex(lons, alons)
!-------------------------------------------------------------------------

        integer error, i, j, k, iT, iD, iP, ctype, nterms, nstart, nr

        Real (r8) alons

	Real (r8), POINTER, DIMENSION(:, :) ::  lons(:, :)

 	FindL2LongitudeIndex = 1	
!-----------------------------------
   END FUNCTION FindL2LongitudeIndex
!-----------------------------------

d826 3
@


1.8
log
@with selected pressure levels
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.7 2001/03/03 01:38:02 ybj Exp $"
d82 2
d238 10
a267 7
	!open(5, file='l2gp_intp.dat', status='replace')
	!DO J = 1, anlats(10, 1)
	!  write(5,*) J, atimes(10, J, 1)*60.*60.*24.+l2gp(1)%time(1), alons(10, J, 1), afields(10, J, 1) 
	  !write(5,*) J, atimes(10, J, 1), alons(10, J, 1), afields(10, J, 1) 
        !ENDDO
        !close(5)

a269 2
!	cfProd%mode = 'com'

d273 7
d309 26
a334 7
                   DO iL = 1, anlats(J, iP)
		      !CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
		      !print *, atimes(J, iL, iP), alons(J, iL, iP), afields(J, iL, iP)-l3ret
		   ENDDO
                   DO iL = 1, anlats(J, iP)
		      !CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
		      !print *, dfields(J, iL, iP)-l3ret
d355 15
d389 15
d423 27
d469 15
d503 15
d533 3
a629 2
!	open(5, file='l2gp_info.dat', status='replace')

a640 1
!	    write(5, *) nstart, l2Times(nstart, 1), l2Lons(nstart, 1), l2Lats(nstart, 1), l2Values(nstart, 1)
a644 1
!	close(5)
d891 3
@


1.7
log
@with selected pressure levels
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.6 2001/03/03 00:45:44 ybj Exp $"
d137 4
d776 3
@


1.6
log
@with selected pressure levels
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.5 2001/03/03 00:20:07 ybj Exp $"
d306 1
d325 1
d344 1
d364 1
d383 1
d402 1
d772 3
@


1.5
log
@with selected pressure levels
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.3 2001/02/28 19:27:03 ybj Exp $"
d296 1
a296 1
		      CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
d300 1
a300 1
		      CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
d766 3
@


1.4
log
@With All Levels & Latitudes
@
text
@d85 1
a85 1
	INTEGER ::  error, l2Days, nlev, nf, nwv, numDays, numSwaths, rDays
d87 1
a87 1
        integer i, j, k, ctype, iP, iD, iL
d91 1
a91 1
!*** Initilize variables & POINTERS
d95 13
a107 1
        nf = 100
d135 1
a135 1
           l3sp(j)%pressure = l2gp(1)%pressures(:nlev)
d164 3
a166 3
           l3dm(j)%pressure = l2gp(1)%pressures(:nlev)
           dmA(j)%pressure = l2gp(1)%pressures(:nlev)
           dmD(j)%pressure = l2gp(1)%pressures(:nlev)
d194 3
a196 3
           l3dz(j)%pressure = l2gp(1)%pressures(:nlev)
           dzA(j)%pressure = l2gp(1)%pressures(:nlev)
           dzD(j)%pressure = l2gp(1)%pressures(:nlev)
d244 1
d252 7
d261 5
a265 1
	DO iP = 1, l2gp(1)%nLevels
d267 1
d296 1
a296 1
		      !CALL Diagnostics(cfProd%mode, atimes(J, iL, iP), alons(J, iL, iP), l3ret) 
d300 1
a300 1
		      !CALL Diagnostics(cfProd%mode, dtimes(J, iL, iP), dlons(J, iL, iP), l3ret) 
d306 1
a306 2
		   flags%writel3sp    = .TRUE.
             	   flags%writel3rCom  = .TRUE.
d324 1
a324 2
		   flags%writel3sp    = .TRUE.
        	   flags%writel3rAsc  = .TRUE.
d342 1
a342 2
		   flags%writel3sp    = .TRUE.
        	   flags%writel3rDes  = .TRUE.
a360 1
             	   flags%writel3rCom  = .TRUE.
a378 1
        	   flags%writel3rAsc  = .TRUE.
a396 1
        	   flags%writel3rDes  = .TRUE.
d430 1
a430 1
   SUBROUTINE SortData(cfProd, pcf, l2Days, l2gp, tau0, anlats, dnlats, 	&
d436 1
a436 1
        integer error, i, j, k, iT, iD, iP, ctype, nterms, nstart, nr, lindex, lindex_prev
a455 3
	INTEGER, DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: anlats, dnlats
	Real (r8), DIMENSION(cfProd%nLats, l2gp(1)%nLevels) :: delTad 

d458 1
a458 1
	Integer nPd
d460 2
a461 1
	nPd = 15
d465 2
d474 19
a492 19
        ALLOCATE(l2Times(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Lons(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Lats(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Values(nterms, l2gp(1)%nLevels), STAT=error)

        ALLOCATE(l2Lons_new(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Lons_Rev(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Times_Rev(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Lats_Rev(nterms, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(l2Values_Rev(nterms, l2gp(1)%nLevels), STAT=error)

        ALLOCATE(alons_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(alats_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(atimes_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(afields_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(dlons_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(dlats_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(dtimes_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
        ALLOCATE(dfields_interp(cfProd%nLats, nPd*l2Days, l2gp(1)%nLevels), STAT=error)
d501 2
d506 3
a508 1
	    DO iP = 1, l2gp(iD)%nLevels
d512 1
a512 1
                l2Values(nstart, iP) = l2gp(iD)%l2gpValue(1, iP, iT) 
d514 1
d519 1
d522 3
a524 1
	DO iP = 1, l2gp(1)%nLevels
d539 3
a541 1
	DO iP = 1, l2gp(1)%nLevels
d549 3
a551 1
	DO iP = 1, l2gp(1)%nLevels
d558 3
a560 1
	DO iP = 1, l2gp(1)%nLevels
d568 3
a570 1
	DO iP = 1, l2gp(1)%nLevels
d578 3
a580 1
	DO iP = 1, l2gp(1)%nLevels
d594 3
a596 1
	DO iP = 1, l2gp(1)%nLevels
d684 3
a686 1
	DO iP = 1, l2gp(1)%nLevels
@


1.3
log
@Fix residue allocation & flags initialization
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.2 2001/02/28 17:15:06 ybj Exp $"
d87 1
a87 1
        integer i, j, k, ctype, iP, iD
d89 1
a89 1
	real zonAvg, tau0
d241 2
a242 4
	!DO iP = 1, l2gp(1)%nLevels
	DO iP = 1, 1
	  !DO J = 1, cfProd%nLats
	  DO J = 10, 10 
d270 8
d281 2
a282 1
		   flags%writel3sp = .TRUE.
d300 2
a301 1
		   flags%writel3sp = .TRUE.
d319 2
a320 1
		   flags%writel3sp = .TRUE.
d339 1
d358 1
d377 1
d725 3
@


1.2
log
@Fix residue structure alocation
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.1 2001/02/27 20:51:28 ybj Exp $"
d129 1
a129 2
        ALLOCATE( l3dm(numDays), dmA(numDays), dmD(numDays), l3r(numDays), &
                residA(numDays), residD(numDays), STAT=error )
d208 12
d241 4
a244 2
	DO iP = 1, l2gp(1)%nLevels
	  DO J = 1, cfProd%nLats
d713 3
@


1.1
log
@Daily Map Core Processing
@
text
@d31 1
a31 1
   "$Id: Synoptic.f90,v 1.1 2000/10/05 18:38:48 nakamura Exp $"
d85 1
a85 1
	INTEGER ::  error, l2Days, nlev, nf, nwv, numDays, numSwaths
d193 16
d700 3
@

