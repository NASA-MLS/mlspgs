head	1.18;
access;
symbols
	v5-02-NRT-19:1.18
	v6-00:1.18
	v5-02-NRT-18:1.18
	v5-02:1.18
	v5-01-NRT-17:1.18
	v5-01-NRT-16:1.18
	v5-01-NRT-15:1.18
	v5-01-NRT-14:1.18
	neuralnetworks-1-0:1.18.0.12
	cfm-single-freq-0-1:1.18.0.10
	v5-01:1.18
	v5-00:1.18
	v4-23-TA133:1.18.0.8
	mus-emls-1-70:1.18.0.6
	rel-1-0-englocks-work:1.18.0.4
	VUMLS1-00:1.18
	VPL1-00:1.18
	V4-22-NRT-08:1.18
	VAM1-00:1.18
	V4-21:1.18.0.2
	V4-13:1.18
	V4-12:1.18
	V4-11:1.18
	V4-10:1.18
	V3-43:1.17
	M4-00:1.17
	V3-41:1.17
	V3-40-PlusGM57:1.17.0.2
	V2-24-NRT-04:1.16
	V3-33:1.17
	V2-24:1.16
	V3-31:1.17
	V3-30-NRT-05:1.17
	cfm-01-00:1.17
	V3-30:1.17
	V3-20:1.17
	V3-10:1.17
	V2-23-NRT-02:1.16
	V2-23:1.16
	V2-22-NRT-01:1.16
	V2-22:1.16
	V2-21:1.16
	V2-20:1.16
	V2-11:1.16
	V2-10:1.16
	V2-00:1.16
	V1-51:1.14
	V1-50:1.14
	V1-45:1.14
	V1-44:1.14
	V1-43:1.14
	V1-42:1.13
	V1-41:1.13
	V1-32:1.13
	V1-40:1.13
	V1-31:1.13
	V1-30:1.13
	V1-13:1.9
	V1-12:1.9
	V1-11:1.9
	V1-10:1.9
	newfwm-feb03:1.9.0.2
	V1-04:1.9
	V1-03:1.9
	V1-02:1.9
	V1-00:1.8
	newfwm-sep01:1.8.0.2
	V0-7:1.8
	V0-5-Level2:1.8
	V0-5-SIPS:1.7;
locks; strict;
comment	@# @;


1.18
date	2013.07.02.22.46.13;	author pwagner;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.02.23.14.20;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.23.19.07.39;	author pwagner;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.13.20.19.54;	author ybj;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.08.00.18.09;	author pwagner;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.30.23.51.59;	author pwagner;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.30.18.15.48;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.22.02.42.37;	author jdone;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.10.22.06.05;	author jdone;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.24.19.39.12;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.27.19.30.43;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.21.20.49.29;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.09.20.29.35;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.09.19.17.05;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.16.17.44.38;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.29.20.51.11;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.29.21.44.16;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Brought up-to-date with 64-bit interface
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE L3SPData
!==============================================================================

   USE L3CF, ONLY: L3CFProd_T
   USE MLSCommon, ONLY: r8
   USE MLSFiles, ONLY: HDFVERSION_4, HDFVERSION_5, WILDCARDHDFVERSION, &
        & MLS_HDF_VERSION
   USE MLSHDFEOS, ONLY: HSIZE
   USE MLSL3Common, ONLY: GridNameLen, HDFE_NOMERGE, FILENAMELEN, &
        & DIM_ERR, GEO_ERR, DAT_ERR, WR_ERR, &
        & GEO_FIELD1, GEO_FIELD9, GEO_FIELD10, &
        & DIML_NAME, DIM_NAME2, DIM_NAME3
   USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Allocate, & 
        & MLSMSG_Fileopen, MLSMSG_Info, MLSMSG_DeAllocate
   USE MLSPCF3, ONLY: mlspcf_l3sp_start, mlspcf_l3sp_end

   IMPLICIT NONE
   private
   public :: L3SPData_T, AllocateL3SP, OutputL3SP, DeallocateL3SP, &
     &        DestroyL3SPDatabase


!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: L3SPData.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! Contents:

! Definition -- L3SPData_T
! Subroutines -- AllocateL3SP
!                OutputL3SP
!                DeallocateL3SP
!                DestroyL3SPDatabase

! Remarks:  This module contains the definition of the L3SPData type, as well
!           as any routines pertaining to it.

! Parameters

   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMW_NAME  = 'nWave'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMWD_NAME = 'nLevels,nLats,nWave'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMFD_NAME = 'nLevels,nLats,nWave'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMSP_NAME = 'nLevels,nLats,nWave'

   CHARACTER (LEN=*), PARAMETER, PUBLIC :: GEO_FIELDWN  = 'waveNumber'

   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDRV = 'L3spRelValue'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDRP = 'L3spRelPrecision'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDIV = 'L3spImgValue'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DATA_FIELDIP = 'L3spImgPrecision'

! This data type is used to store the L3 fourier spectra.

  TYPE L3SPData_T

     ! Now the spectra fields:

     CHARACTER (LEN=GridNameLen) :: name	! name for the output quantity

     ! dimensioned as (nLevels, nLats, nWaveNum, nFreqs):

     REAL(r8), DIMENSION(:,:,:), POINTER :: l3spRelValue     ! Real part
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3spRelPrecision
						! Real part precision
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3spImgValue     ! Imaginary part
     REAL(r8), DIMENSION(:,:,:), POINTER :: l3spImgPrecision
						! Imaginary part precision

     ! Now we store the waveNumber and frequency fields:

     REAL(r8), DIMENSION(:,:,:), POINTER :: waveNumber
	! dimensioned (nLevels, nLats, nWave)

     REAL(r8), DIMENSION(:,:,:), POINTER :: frequency
	! dimensioned (nLevels, nLats, nWave):

     ! Now we store the geolocation fields.  First, the vertical one:

     REAL(r8), DIMENSION(:), POINTER :: pressure	! dimensioned (nLevels)

     ! Now the horizontal geolocation information and time:

     REAL(r8), DIMENSION(:), POINTER :: latitude        ! dimensioned (nLats)

     REAL(r8) :: startTime	! start time of L2 data used in the analysis

     REAL(r8) :: endTime	! end time of L2 data used in the analysis

     INTEGER :: nLevels				! Total number of surfaces
     INTEGER :: nLats				! Total number of latitudes
     INTEGER :: nWave				! Total number of components

   END TYPE L3SPData_T

CONTAINS

!--------------------------------------------------------
   SUBROUTINE AllocateL3SP (nlev, nlat, nwv, l3sp)
!--------------------------------------------------------

! Brief description of subroutine
! This subroutine allocates the internal field pointers of the L3SPData_T
! derived type.

! Arguments

      INTEGER, INTENT(IN) :: nlev, nlat, nwv

      TYPE( L3SPData_T ), INTENT(INOUT) :: l3sp

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

      ! Store the sizes of the dimensions

      l3sp%nLevels  = nlev
      l3sp%nLats    = nlat
      l3sp%nWave    = nwv

      ! Allocate the vertical geolocation field

      if (l3sp%nLevels .gt. 0) then

         ALLOCATE(l3sp%pressure(l3sp%nLevels), STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_Allocate // ' L3SPData_T pressure pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

      endif

      ! Horizontal geolocation field

	if (l3sp%nLats .gt. 0) then

           ALLOCATE(l3sp%latitude(l3sp%nLats), STAT=err)
           IF ( err /= 0 ) THEN
              msr = MLSMSG_Allocate // ' L3SPData_T latitude pointer.'
              CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
           ENDIF

	endif

        ! Wavenumber & frequency

	if ( (l3sp%nLevels .gt. 0).and. & 
             & (l3sp%nLats .gt. 0).and.(l3sp%nWave .gt. 0)) then
      ALLOCATE(l3sp%waveNumber(l3sp%nLevels,l3sp%nLats,l3sp%nWave), & 
           & STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T waveNumber pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
	endif

	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0)) then
      ALLOCATE(l3sp%frequency(l3sp%nLevels,l3sp%nLats,l3sp%nWave), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T frequency pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      endif

! Spectra fields

	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0).and. & 
             & (l3sp%nWave .gt. 0) ) then

      ALLOCATE(l3sp%l3spRelValue(l3sp%nLevels,l3sp%nLats,l3sp%nWave), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T RelValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3sp%l3spRelPrecision(l3sp%nLevels,l3sp%nLats,l3sp%nWave), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T RelPrecision pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF


      ALLOCATE(l3sp%l3spImgValue(l3sp%nLevels,l3sp%nLats,l3sp%nWave), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T ImgValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      ALLOCATE(l3sp%l3spImgPrecision(l3sp%nLevels,l3sp%nLats,l3sp%nWave), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T ImgPrecision pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

     endif
!-----------------------------
   END SUBROUTINE AllocateL3SP
!-----------------------------

!--------------------------------------------
   SUBROUTINE OutputL3SP (cfProd, anText, sp, hdfVersion)
!--------------------------------------------

     ! Arguments

     TYPE( L3CFProd_T ), INTENT(IN) :: cfProd

     TYPE( L3SPData_T ), INTENT(IN) :: sp(:)

     CHARACTER (LEN=1), POINTER :: anText(:)

     INTEGER :: hdfVersion

     IF (hdfVersion == HDFVERSION_5) THEN
        CALL OutputL3SP_HDF5(cfProd, anText, sp)
     ELSE
         CALL MLSMessage(MLSMSG_Error, ModuleName, 'Wrong hdfVersion')
     ENDIF

!---------------------------
   END SUBROUTINE OutputL3SP
!---------------------------

!--------------------------------------------
   SUBROUTINE OutputL3SP_HDF5(cfProd, anText, sp)
!--------------------------------------------

   USE HDFEOS5, only: HE5F_ACC_TRUNC, HE5T_NATIVE_FLOAT
   USE Intrinsic, ONLY: l_swath
   USE PCFHdr, ONLY: WritePCF2Hdr
   USE PCFModule, ONLY: ExpandFileTemplate, FindFileType
! Brief description of subroutine
! This subroutine creates and writes to the swaths in an l3sp file.

! Arguments

      TYPE( L3CFProd_T ), INTENT(IN) :: cfProd

      TYPE( L3SPData_T ), INTENT(IN) :: sp(:)

      CHARACTER (LEN=1), POINTER :: anText(:)

! Parameters

! Functions

      INTEGER, EXTERNAL :: he5_swattach, he5_swclose, he5_swcreate, & 
           & he5_swdefdfld, he5_swdefgfld, he5_swdefdim, & 
           & he5_swdetach, he5_swopen, he5_swwrfld

! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=FileNameLen) :: spFile, type
 
      INTEGER :: start(3), stride(3), edge(3)
      INTEGER :: i, match, numSwaths, status, swfID, swID

! Expand the template given in the CF

      CALL ExpandFileTemplate(cfProd%fileTemplate, type, 'L3SP')

! Find a PCF entry for this file type

      CALL FindFileType(type, mlspcf_l3sp_start, mlspcf_l3sp_end, match, &
           & spFile)

! Open the l3sp file for the creation of swaths

      swfID = he5_swopen(spFile, HE5F_ACC_TRUNC)

      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // trim(spFile)
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! For each swath found,

      numSwaths = SIZE(sp)

      DO i = 1, numSwaths

! Create a swath of the appropriate name

         swID = he5_swcreate( swfID, sp(i)%name )

         IF (swID == -1) THEN
            msr = ' L3SPData::OutputL3SP: Failed to create swath '// & 
                 & trim(sp(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the swath dimensions

         status = he5_swdefdim(swID, DIM_NAME2, hsize(sp(i)%nLevels))
         IF (status /= 0) THEN
            msr = DIM_ERR // DIM_NAME2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefdim(swID, DIML_NAME, hsize(sp(i)%nLats))
         IF (status /= 0) THEN
            msr = DIM_ERR // DIML_NAME
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefdim(swID, DIMW_NAME, hsize(sp(i)%nWave))
         IF (status /= 0) THEN
            msr = DIM_ERR // DIMW_NAME
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the vertical geolocation field, using the above dimensions

         status = he5_swdefgfld(swID, GEO_FIELD9, DIM_NAME2, "", & 
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the horizontal geolocation field

         status = he5_swdefgfld(swID, GEO_FIELD1, DIML_NAME, "",& 
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the waveNumber & frequency fields


         status = he5_swdefgfld(swID, GEO_FIELDWN, DIMWD_NAME, "",& 
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELDWN
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefgfld(swID, GEO_FIELD10, DIMFD_NAME, "",&
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD10
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the data fields using above dimensions

         status = he5_swdefdfld(swID, DATA_FIELDRV, DIMSP_NAME, "", &
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDRV
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefdfld(swID, DATA_FIELDRP, DIMSP_NAME, "", &
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDRP 
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefdfld(swID, DATA_FIELDIV, DIMSP_NAME, "", &
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDIV 
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = he5_swdefdfld(swID, DATA_FIELDIP, DIMSP_NAME, "", &
              & HE5T_NATIVE_FLOAT, HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDIP
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ! Detach from the swath interface

         status = he5_swdetach(swID)
         IF (status /= 0) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                & 'Failed to detach from swath interface ' & 
                & //'after L3SP definition.')
         ENDIF

! Re-attach to the swath for writing

         swID = he5_swattach(swfID, sp(i)%name)
         IF (swID == -1) THEN
            msr = 'Failed to re-attach to swath ' // TRIM(sp(i)%name) &
                 & // ' for writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Write the data

         start = 0
         stride = 1
         edge(1) = sp(i)%nLevels
         edge(2) = sp(i)%nLats
         edge(3) = sp(i)%nWave

! Write the vertical geolocation data

         if ( sp(i)%nLevels.gt.0 ) then

         status = he5_swwrfld(swID, GEO_FIELD9, start(1), stride(1), edge(1), &
              & REAL(sp(i)%pressure) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF

         endif

! Write the horizontal geolocation data

         if (sp(i)%nLats.gt.0) then

         status = he5_swwrfld(swID, GEO_FIELD1, start(2), stride(2), edge(2), &
              & REAL(sp(i)%latitude) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         endif

! Write the waveNumber data

         if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
              & (sp(i)%nLats.gt.0)) then

         status = he5_swwrfld( swID, GEO_FIELDWN, start, stride, &
              & edge, REAL(sp(i)%waveNumber) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELDWN
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         endif

! Write the frequency data
         
         if (sp(i)%nWave.gt.0) then 

            if ((sp(i)%nLevels.gt.0).and.(sp(i)%nLats.gt.0)) then

               status = he5_swwrfld(swID,GEO_FIELD10,start,stride, &
                    & edge, REAL(sp(i)%frequency) )
               IF (status /= 0) THEN
                  msr = WR_ERR // GEO_FIELD10
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

            endif

         endif

! Write the real part of the data

         if (sp(i)%nWave.gt.0) then 

            if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
                 & (sp(i)%nLats.gt.0)) then

               status = he5_swwrfld( swID, DATA_FIELDRV, start, stride, edge, &
                    & REAL(sp(i)%l3spRelValue) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDRV
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF
         
               status = he5_swwrfld( swID, DATA_FIELDRP, start, stride, edge, &
                    & REAL(sp(i)%l3spRelPrecision) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDRP
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

            endif

         endif

! Write the imaginary part of the data

         if (sp(i)%nWave.gt.0) then 

            if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
                 & (sp(i)%nLats.gt.0)) then

               status = he5_swwrfld( swID, DATA_FIELDIV, start, stride, edge, &
                    & REAL(sp(i)%l3spImgValue) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDIV
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

               status = he5_swwrfld( swID, DATA_FIELDIP, start, stride, edge, &
                    & REAL(sp(i)%l3spImgPrecision) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDIP
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

            endif

         endif


! After writing, detach from swath interface


         status = he5_swdetach(swID)
         IF (status /= 0) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                 & 'Failed to detach from swath interface after writing.')
         ELSE
            msr = 'Swath ' // TRIM(sp(i)%name) // & 
                 & ' successfully written to file ' // trim(spFile)
            CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
         ENDIF

      ENDDO

      ! Close the file


      status = he5_swclose(swfID)

      IF (status /= 0) THEN
         msr = 'Failed to close file ' // trim(spFile) // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF


! Annotate the file with the PCF

      CALL WritePCF2Hdr(spFile, anText, HDFVERSION_5, filetype=l_swath)

!---------------------------
   END SUBROUTINE OutputL3SP_HDF5
!---------------------------

!----------------------------------
   SUBROUTINE DeallocateL3SP (l3sp)
!----------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal field pointers of the L2GP_T
! derived type, after the calling program has finished with the data.

! Arguments

      TYPE( L3SPData_T ), INTENT(INOUT) :: l3sp

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Vertical geolocation field

      IF ( ASSOCIATED(l3sp%pressure) ) THEN
         DEALLOCATE (l3sp%pressure, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3sp pressure pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Horizontal geolocation field

      IF ( ASSOCIATED(l3sp%latitude) ) THEN
         DEALLOCATE (l3sp%latitude, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3sp latitude pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Wavenumber & frequency fields

      IF ( ASSOCIATED(l3sp%waveNumber) ) THEN
         DEALLOCATE (l3sp%waveNumber, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3sp waveNumber pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3sp%frequency) ) THEN
         DEALLOCATE (l3sp%frequency, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3sp frequency pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

! Spectra fields

      IF ( ASSOCIATED(l3sp%l3spRelValue) ) THEN
         DEALLOCATE (l3sp%l3spRelValue,  STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3spRelValue pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3sp%l3spRelPrecision) ) THEN
         DEALLOCATE (l3sp%l3spRelPrecision, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3spRelPrecision'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3sp%l3spImgValue) ) THEN
         DEALLOCATE (l3sp%l3spImgValue, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3spImgValue pointer.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

      IF ( ASSOCIATED(l3sp%l3spImgPrecision) ) THEN
         DEALLOCATE (l3sp%l3spImgPrecision, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3spImgPrecision'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF
      ENDIF

!-------------------------------
   END SUBROUTINE DeallocateL3SP
!-------------------------------

!-----------------------------------------
   SUBROUTINE DestroyL3SPDatabase (l3spdb)
!-----------------------------------------

! Brief description of subroutine
! This subroutine deallocates the internal structures of an l3sp database, and
! then database itself


! Arguments

      TYPE (L3SPData_T), DIMENSION(:), POINTER :: l3spdb

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err, i

! Check the status of the input pointer

      IF ( ASSOCIATED(l3spdb) ) THEN

! If it's associated, then deallocate the internal structures

         DO i = 1, SIZE(l3spdb)
            CALL DeallocateL3SP( l3spdb(i) )
         ENDDO

! Deallocate the database itself

         DEALLOCATE (l3spdb, STAT=err)
         IF ( err /= 0 ) THEN
            msr = MLSMSG_DeAllocate // '  l3sp database'
            CALL MLSMessage ( MLSMSG_Error, ModuleName, msr)
         ENDIF

      ENDIF

!------------------------------------
   END SUBROUTINE DestroyL3SPDatabase
!------------------------------------

!==================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: L3SPData.f90,v 1.17 2008/12/02 23:14:20 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
END MODULE L3SPData
!==================

! $Log: L3SPData.f90,v $
! Revision 1.17  2008/12/02 23:14:20  pwagner
! mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
!
! Revision 1.16  2006/02/28 17:56:56  cvuu
! V2.00 commit
!
! Revision 1.15  2005/06/23 19:07:39  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.14  2004/05/13 20:19:54  ybj
! *** empty log message ***
!
! Revision 1.13  2003/07/08 00:18:09  pwagner
! fileType now a lit_name instead of a char string
!
! Revision 1.12  2003/05/30 23:51:59  pwagner
! Passes actual hdf version instead of relying on default being 4
!
! Revision 1.11  2003/04/30 18:15:48  pwagner
! Work-around for LF95 infinite compile-time bug
!
! Revision 1.10  2003/03/22 02:42:37  jdone
! added HDFEOS2/HDFEOS5 functionality
!
! Revision 1.9  2002/04/10 22:06:05  jdone
! check on array size for allocate
!
! Revision 1.8  2001/04/24 19:39:12  nakamura
! Removed references to private L2 parameters.
!
! Revision 1.7  2001/03/27 19:30:43  nakamura
! Added use of PCFHdr; fixed err checks on deallocate.
!
! Revision 1.6  2001/02/21 20:49:29  nakamura
! Changed MLSPCF to MLSPCF3.
!
! Revision 1.5  2001/02/09 20:29:35  nakamura
! Added third dimension to waveNumber & frequency.
!
! Revision 1.4  2001/02/09 19:17:05  nakamura
! Changed dimensions on waveNumber & frequency.
!
! Revision 1.3  2001/01/16 17:44:38  nakamura
! Added annotation.
!
! Revision 1.2  2000/12/29 20:51:11  nakamura
! Added subroutine OutputL3SP.
!
! Revision 1.1  2000/11/29 21:44:16  nakamura
! Module for the L3SP data type.
!
@


1.17
log
@mls_io_gen_[openF,closeF] functions now private; use MLSFile_T interfaces instead
@
text
@d20 1
d315 1
a315 1
         status = he5_swdefdim(swID, DIM_NAME2, sp(i)%nLevels)
d321 1
a321 1
         status = he5_swdefdim(swID, DIML_NAME, sp(i)%nLats)
d327 1
a327 1
         status = he5_swdefdim(swID, DIMW_NAME, sp(i)%nWave)
d715 1
a715 1
       "$Id: L3SPData.f90,v 1.16 2006/02/28 17:56:56 cvuu Exp $"
d724 3
@


1.16
log
@V2.00 commit
@
text
@d19 1
a19 1
        & MLS_HDF_VERSION, MLS_IO_GEN_OPENF, MLS_IO_GEN_CLOSEF
d714 1
a714 1
       "$Id: L3SPData.f90,v 1.15 2005/06/23 19:07:39 pwagner Exp $"
d723 3
@


1.15
log
@Reworded Copyright statement, moved rcs id
@
text
@d36 1
a36 1
       "$RCSfile: $"
d233 1
a233 3
     IF (hdfVersion == HDFVERSION_4) THEN
        CALL OutputL3SP_HDF4(cfProd, anText, sp)
     ELSE IF (hdfVersion == HDFVERSION_5) THEN
d235 2
a243 320
   SUBROUTINE OutputL3SP_HDF4(cfProd, anText, sp)
!--------------------------------------------
   USE HDF, ONLY: DFACC_CREATE, DFNT_FLOAT32 
   USE PCFHdr, ONLY: WritePCF2Hdr
   USE PCFModule, ONLY: ExpandFileTemplate, FindFileType

! Brief description of subroutine
! This subroutine creates and writes to the swaths in an l3sp file.

! Arguments

      TYPE( L3CFProd_T ), INTENT(IN) :: cfProd

      TYPE( L3SPData_T ), INTENT(IN) :: sp(:)

      CHARACTER (LEN=1), POINTER :: anText(:)

! Parameters

! Functions

      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, & 
           & swdefgfld, swdefdim, swdetach, swopen, swwrfld

! Variables

      CHARACTER (LEN=480) :: msr
      CHARACTER (LEN=FileNameLen) :: spFile, type
 
      INTEGER :: start(3), stride(3), edge(3)
      INTEGER :: i, match, numSwaths, status, swfID, swID

! Expand the template given in the CF

      CALL ExpandFileTemplate(cfProd%fileTemplate, type, 'L3SP')

! Find a PCF entry for this file type

      CALL FindFileType(type, mlspcf_l3sp_start, mlspcf_l3sp_end, match, &
           & spFile)

! Open the l3sp file for the creation of swaths

      swfID = swopen(spFile, DFACC_CREATE)

      IF (swfID == -1) THEN
         msr = MLSMSG_Fileopen // spFile
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! For each swath found,

      numSwaths = SIZE(sp)

      DO i = 1, numSwaths

! Create a swath of the appropriate name

         swID = swcreate( swfID, sp(i)%name )

         IF (swID == -1) THEN
            msr = ' L3SPData::OutputL3SP: Failed to create swath ' & 
                 & // trim(sp(i)%name)
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the swath dimensions

         status = swdefdim(swID, DIM_NAME2, sp(i)%nLevels)
         IF (status /= 0) THEN
            msr = DIM_ERR // DIM_NAME2
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefdim(swID, DIML_NAME, sp(i)%nLats)
         IF (status /= 0) THEN
            msr = DIM_ERR // DIML_NAME
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefdim(swID, DIMW_NAME, sp(i)%nWave)
         IF (status /= 0) THEN
            msr = DIM_ERR // DIMW_NAME
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the vertical geolocation field, using the above dimensions

         status = swdefgfld(swID, GEO_FIELD9, DIM_NAME2, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the horizontal geolocation field

         status = swdefgfld(swID, GEO_FIELD1, DIML_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the waveNumber & frequency fields


         status = swdefgfld(swID, GEO_FIELDWN, DIMWD_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELDWN
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefgfld(swID, GEO_FIELD10, DIMFD_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = GEO_ERR // GEO_FIELD10
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Define the data fields using above dimensions

         status = swdefdfld(swID, DATA_FIELDRV, DIMSP_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDRV
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefdfld(swID, DATA_FIELDRP, DIMSP_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDRP 
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefdfld(swID, DATA_FIELDIV, DIMSP_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDIV 
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         status = swdefdfld(swID, DATA_FIELDIP, DIMSP_NAME, DFNT_FLOAT32, &
              & HDFE_NOMERGE)
         IF (status /= 0) THEN
            msr = DAT_ERR // DATA_FIELDIP
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         ! Detach from the swath interface

         status = swdetach(swID)
         IF (status /= 0) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                 & 'Failed to detach from swath interface ' & 
                 & //'after L3SP definition.')
         ENDIF

! Re-attach to the swath for writing

         swID = swattach(swfID, sp(i)%name)
         IF (swID == -1) THEN
            msr = 'Failed to re-attach to swath ' // TRIM(sp(i)%name) &
                 & // ' for writing.'
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

! Write the data

         start = 0
         stride = 1
         edge(1) = sp(i)%nLevels
         edge(2) = sp(i)%nLats
         edge(3) = sp(i)%nWave

! Write the vertical geolocation data

         if ( sp(i)%nLevels.gt.0 ) then

         status = swwrfld( swID, GEO_FIELD9, start(1), stride(1), edge(1), &
              & REAL(sp(i)%pressure) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELD9
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
          ENDIF

         endif

! Write the horizontal geolocation data

         if (sp(i)%nLats.gt.0) then

         status = swwrfld( swID, GEO_FIELD1, start(2), stride(2), edge(2), &
              & REAL(sp(i)%latitude) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELD1
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         endif

! Write the waveNumber data

         if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
              & (sp(i)%nLats.gt.0)) then

         status = swwrfld( swID, GEO_FIELDWN, start, stride, &
              & edge, REAL(sp(i)%waveNumber) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELDWN
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         endif

! Write the frequency data
         
         if (sp(i)%nWave.gt.0) then 

         if ((sp(i)%nLevels.gt.0).and.(sp(i)%nLats.gt.0)) then

         status = swwrfld( swID, GEO_FIELD10, start, stride, &
              & edge, REAL(sp(i)%frequency) )
         IF (status /= 0) THEN
            msr = WR_ERR // GEO_FIELD10
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

         endif

         endif

! Write the real part of the data

         if (sp(i)%nWave.gt.0) then 

            if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
                 & (sp(i)%nLats.gt.0)) then

               status = swwrfld( swID, DATA_FIELDRV, start, stride, edge, &
                    & REAL(sp(i)%l3spRelValue) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDRV
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF
         
               status = swwrfld( swID, DATA_FIELDRP, start, stride, edge, &
                    & REAL(sp(i)%l3spRelPrecision) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDRP
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

            endif

         endif

! Write the imaginary part of the data

         if (sp(i)%nWave.gt.0) then 

            if ((sp(i)%nWave.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
                 & (sp(i)%nLats.gt.0)) then

               status = swwrfld( swID, DATA_FIELDIV, start, stride, edge, &
                    & REAL(sp(i)%l3spImgValue) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDIV
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

               status = swwrfld( swID, DATA_FIELDIP, start, stride, edge, &
                    & REAL(sp(i)%l3spImgPrecision) )
               IF (status /= 0) THEN
                  msr = WR_ERR // DATA_FIELDIP
                  CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
               ENDIF

            endif

         endif


! After writing, detach from swath interface


         status = swdetach(swID)
         IF (status /= 0) THEN
            CALL MLSMessage(MLSMSG_Error, ModuleName, & 
                 & 'Failed to detach from swath interface after writing.')
         ELSE
            msr = 'Swath ' // TRIM(sp(i)%name) // & 
                 & ' successfully written to file ' // spFile
            CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
         ENDIF

      ENDDO

      ! Close the file


      status = swclose(swfID)

      IF (status /= 0) THEN
         msr = 'Failed to close file ' // spFile // ' after writing.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF


! Annotate the file with the PCF

      CALL WritePCF2Hdr(spFile, anText, hdfVersion=HDFVERSION_4)

!---------------------------
   END SUBROUTINE OutputL3SP_HDF4
!---------------------------

!--------------------------------------------
d714 1
a714 1
       "$Id: $"
d723 3
@


1.14
log
@*** empty log message ***
@
text
@d1 10
a10 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a32 1
   PRIVATE :: ID, ModuleName
d34 5
a38 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: L3SPData.f90,v 1.13 2003/07/08 00:18:09 pwagner Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: L3SPData.f90,v $"
!----------------------------------------------------------
d1031 8
d1043 3
@


1.13
log
@fileType now a lit_name instead of a char string
@
text
@d29 1
a29 1
   "$Id: L3SPData.f90,v 1.12 2003/05/30 23:51:59 pwagner Exp $"
d46 4
a49 4
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMW_NAME  = 'nWaveNum'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMWD_NAME = 'nLevels,nLats,nWaveNum'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMFD_NAME = 'nLevels,nLats,nFreqs'
   CHARACTER (LEN=*), PARAMETER, PUBLIC :: DIMSP_NAME = 'nLevels,nLats,nWaveNum,nFreqs'
d68 2
a69 2
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spRelValue     ! Real part
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spRelPrecision
d71 2
a72 2
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spImgValue     ! Imaginary part
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spImgPrecision
d78 1
a78 1
	! dimensioned (nLevels, nLats, nWaveNum)
d81 1
a81 1
	! dimensioned (nLevels, nLats, nFreqs):
d97 1
a97 2
     INTEGER :: nWaveNum			! Total number of waveNumbers
     INTEGER :: nFreqs				! Total number of frequencies
d104 1
a104 1
   SUBROUTINE AllocateL3SP (nlev, nlat, nwv, nfreq, l3sp)
d113 1
a113 1
      INTEGER, INTENT(IN) :: nlev, nlat, nwv, nfreq
d131 1
a131 2
      l3sp%nWaveNum = nwv
      l3sp%nFreqs   = nfreq
d160 2
a161 2
             & (l3sp%nLats .gt. 0).and.(l3sp%nWaveNum .gt. 0)) then
      ALLOCATE(l3sp%waveNumber(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum), & 
d169 2
a170 3
	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0) & 
             & .and.(l3sp%nFreqs .gt. 0)) then
      ALLOCATE(l3sp%frequency(l3sp%nLevels,l3sp%nLats,l3sp%nFreqs), STAT=err)
d180 1
a180 1
             & (l3sp%nWaveNum .gt. 0) .and. (l3sp%nFreqs.gt.0) ) then
d182 1
a182 2
      ALLOCATE(l3sp%l3spRelValue(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum,&
              &l3sp%nFreqs), STAT=err)
d188 1
a188 2
      ALLOCATE(l3sp%l3spRelPrecision(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum,&
              &l3sp%nFreqs), STAT=err)
d195 1
a195 2
      ALLOCATE(l3sp%l3spImgValue(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum,&
              &l3sp%nFreqs), STAT=err)
d201 1
a201 2
      ALLOCATE(l3sp%l3spImgPrecision(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum,&
              &l3sp%nFreqs), STAT=err)
d266 1
a266 1
      INTEGER :: start(4), stride(4), edge(4)
d317 1
a317 1
         status = swdefdim(swID, DIMW_NAME, sp(i)%nWaveNum)
a322 6
         status = swdefdim(swID, DIM_NAME3, sp(i)%nFreqs)
         IF (status /= 0) THEN
            msr = DIM_ERR // DIM_NAME3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

d412 1
a412 2
         edge(3) = sp(i)%nWaveNum
         edge(4) = sp(i)%nFreqs
d442 1
a442 1
         if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d445 2
a446 2
         status = swwrfld( swID, GEO_FIELDWN, start(1:3), stride(1:3), &
              & edge(1:3), REAL(sp(i)%waveNumber) )
a454 2

         edge(3) = sp(i)%nFreqs
d456 1
a456 1
         if (sp(i)%nFreqs.gt.0) then 
d460 2
a461 2
         status = swwrfld( swID, GEO_FIELD10, start(1:3), stride(1:3), &
              & edge(1:3), REAL(sp(i)%frequency) )
d473 1
a473 3
         edge(3) = sp(i)%nWaveNum

         if (sp(i)%nFreqs.gt.0) then 
d475 1
a475 1
            if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d498 1
a498 1
         if (sp(i)%nFreqs.gt.0) then 
d500 1
a500 1
            if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d588 1
a588 1
      INTEGER :: start(4), stride(4), edge(4)
d639 1
a639 1
         status = he5_swdefdim(swID, DIMW_NAME, sp(i)%nWaveNum)
a644 6
         status = he5_swdefdim(swID, DIM_NAME3, sp(i)%nFreqs)
         IF (status /= 0) THEN
            msr = DIM_ERR // DIM_NAME3
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

d734 1
a734 2
         edge(3) = sp(i)%nWaveNum
         edge(4) = sp(i)%nFreqs
d764 1
a764 1
         if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d767 2
a768 2
         status = he5_swwrfld( swID, GEO_FIELDWN, start(1:3), stride(1:3), &
              & edge(1:3), REAL(sp(i)%waveNumber) )
a776 2

         edge(3) = sp(i)%nFreqs
d778 1
a778 1
         if (sp(i)%nFreqs.gt.0) then 
d782 2
a783 2
               status = he5_swwrfld(swID,GEO_FIELD10,start(1:3),stride(1:3), &
                    & edge(1:3), REAL(sp(i)%frequency) )
d795 1
a795 3
         edge(3) = sp(i)%nWaveNum

         if (sp(i)%nFreqs.gt.0) then 
d797 1
a797 1
            if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d820 1
a820 1
         if (sp(i)%nFreqs.gt.0) then 
d822 1
a822 1
            if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and. & 
d1028 3
@


1.12
log
@Passes actual hdf version instead of relying on default being 4
@
text
@d29 1
a29 1
   "$Id: L3SPData.f90,v 1.11 2003/04/30 18:15:48 pwagner Exp $"
d579 1
d901 1
a901 1
      CALL WritePCF2Hdr(spFile, anText, HDFVERSION_5, 'sw')
d1057 3
@


1.11
log
@Work-around for LF95 infinite compile-time bug
@
text
@d1 1
a1 2

! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d29 1
a29 1
   "$Id: L3SPData.f90,v 1.10 2003/03/22 02:42:37 jdone Exp $"
d568 1
a568 1
      CALL WritePCF2Hdr(spFile, anText)
d1056 3
@


1.10
log
@added HDFEOS2/HDFEOS5 functionality
@
text
@a8 4
   USE HDF, ONLY: DFACC_CREATE, DFNT_FLOAT32 
   USE HDFEOS
   USE HDFEOS5
   USE HE5_SWAPI
a19 3
   USE PCFHdr, ONLY: WritePCF2Hdr
   USE PCFModule, ONLY: ExpandFileTemplate, FindFileType
   USE SWAPI
d22 3
a24 1
   PUBLIC
d30 1
a30 1
   "$Id: L3SPData.f90,v 1.9 2002/04/10 22:06:05 jdone Exp $"
d47 11
a57 11
   CHARACTER (LEN=*), PARAMETER :: DIMW_NAME  = 'nWaveNum'
   CHARACTER (LEN=*), PARAMETER :: DIMWD_NAME = 'nLevels,nLats,nWaveNum'
   CHARACTER (LEN=*), PARAMETER :: DIMFD_NAME = 'nLevels,nLats,nFreqs'
   CHARACTER (LEN=*), PARAMETER :: DIMSP_NAME = 'nLevels,nLats,nWaveNum,nFreqs'

   CHARACTER (LEN=*), PARAMETER :: GEO_FIELDWN  = 'waveNumber'

   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDRV = 'L3spRelValue'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDRP = 'L3spRelPrecision'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDIV = 'L3spImgValue'
   CHARACTER (LEN=*), PARAMETER :: DATA_FIELDIP = 'L3spImgPrecision'
d247 3
d579 3
d1057 3
@


1.9
log
@check on array size for allocate
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 1
!===============================================================================
d9 18
a26 8
   USE Hdf
   USE L3CF
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSPCF3
   USE PCFHdr
   USE PCFModule
d35 1
a35 1
   "$Id: L3SPData.f90,v 1.8 2001/04/24 19:39:12 nakamura Exp $"
d52 1
a52 1
   CHARACTER (LEN=*), PARAMETER :: DIMW_NAME = 'nWaveNum'
d57 1
a57 1
   CHARACTER (LEN=*), PARAMETER :: GEO_FIELDWN = 'waveNumber'
d68 2
d72 16
a87 4
     INTEGER :: nLevels				! Total number of surfaces
     INTEGER :: nLats				! Total number of latitudes
     INTEGER :: nWaveNum			! Total number of waveNumbers
     INTEGER :: nFreqs				! Total number of frequencies
d101 4
a104 17
     ! Now we store the waveNumber and frequency fields:

     REAL(r8), DIMENSION(:,:,:), POINTER :: waveNumber
	! dimensioned (nLevels, nLats, nWaveNum)

     REAL(r8), DIMENSION(:,:,:), POINTER :: frequency
	! dimensioned (nLevels, nLats, nFreqs)

     ! Now the spectra fields:

     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spRelValue     ! Real part
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spRelPrecision
						! Real part precision
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spImgValue     ! Imaginary part
     REAL(r8), DIMENSION(:,:,:,:), POINTER :: l3spImgPrecision
						! Imaginary part precision
     ! dimensioned as (nLevels, nLats, nWaveNum, nFreqs)
d134 1
a134 1
! Store the sizes of the dimensions
d136 2
a137 2
      l3sp%nLevels = nlev
      l3sp%nLats = nlat
d139 1
a139 1
      l3sp%nFreqs = nfreq
d141 1
a141 1
! Allocate the vertical geolocation field
d143 1
a143 1
	if (l3sp%nLevels .gt. 0) then
d145 5
a149 5
      ALLOCATE(l3sp%pressure(l3sp%nLevels), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T pressure pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d151 1
a151 1
	endif
d153 1
a153 1
! Horizontal geolocation field
d157 5
a161 5
      ALLOCATE(l3sp%latitude(l3sp%nLats), STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_Allocate // ' L3SPData_T latitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d165 1
a165 1
! Wavenumber & frequency
d167 4
a170 2
	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0).and.(l3sp%nWaveNum .gt. 0)) then
      ALLOCATE(l3sp%waveNumber(l3sp%nLevels,l3sp%nLats,l3sp%nWaveNum), STAT=err)
d177 2
a178 1
	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0).and.(l3sp%nFreqs .gt. 0)) then
d184 1
a184 1
	endif
d188 2
a189 1
	if ((l3sp%nLevels .gt. 0).and.(l3sp%nLats .gt. 0).and.(l3sp%nWaveNum .gt. 0) .and. (l3sp%nFreqs.gt.0) ) then
d220 1
a220 1
	endif
d226 25
a250 1
   SUBROUTINE OutputL3SP (cfProd, anText, sp)
d268 2
a269 2
      INTEGER, EXTERNAL :: swattach, swclose, swcreate, swdefdfld, swdefgfld
      INTEGER, EXTERNAL :: swdefdim, swdetach, swopen, swwrfld
d273 1
d275 2
a276 2
      CHARACTER (LEN=480) :: msr

a277 1
      INTEGER :: start(4), stride(4), edge(4)
d286 1
a286 1
                        spFile)
d291 1
d306 1
d308 2
a309 1
            msr = ' L3SPData::OutputL3SP: Failed to create swath ' // sp(i)%name
d316 1
a316 1
         IF (status == -1) THEN
d322 1
a322 1
         IF (status == -1) THEN
d328 1
a328 1
         IF (status == -1) THEN
d334 1
a334 1
         IF (status == -1) THEN
d342 2
a343 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d351 2
a352 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d361 2
a362 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d368 2
a369 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d377 2
a378 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d384 2
a385 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d391 2
a392 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d398 2
a399 2
                            HDFE_NOMERGE)
         IF (status == -1) THEN
d404 1
a404 1
! Detach from the swath interface
d407 4
a410 3
         IF (status == -1) THEN
           CALL MLSMessage(MLSMSG_Error, ModuleName, & 
             'Failed to detach from swath interface after L3SP definition.')
d418 1
a418 1
                   // ' for writing.'
d436 2
a437 2
                           REAL(sp(i)%pressure) )
         IF (status == -1) THEN
d449 2
a450 2
                           REAL(sp(i)%latitude) )
         IF (status == -1) THEN
d459 2
a460 2
         if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and.(sp(i)%nLats.gt.0)) then

d463 2
a464 2
                           edge(1:3), REAL(sp(i)%waveNumber) )
         IF (status == -1) THEN
d480 2
a481 2
                           edge(1:3), REAL(sp(i)%frequency) )
         IF (status == -1) THEN
d496 229
a724 1
         if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and.(sp(i)%nLats.gt.0)) then
d726 4
a729 4
         status = swwrfld( swID, DATA_FIELDRV, start, stride, edge, &
                           REAL(sp(i)%l3spRelValue) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELDRV
d732 16
a747 5
         
         status = swwrfld( swID, DATA_FIELDRP, start, stride, edge, &
                           REAL(sp(i)%l3spRelPrecision) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELDRP
d751 19
a769 1
         endif
d773 1
a773 1
! Write the imaginary part of the data
d775 1
a775 1
         if (sp(i)%nFreqs.gt.0) then 
d777 4
a780 6
         if ((sp(i)%nWaveNum.gt.0).and.(sp(i)%nLevels.gt.0).and.(sp(i)%nLats.gt.0)) then

         status = swwrfld( swID, DATA_FIELDIV, start, stride, edge, &
                        REAL(sp(i)%l3spImgValue) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELDIV
d784 11
a794 4
         status = swwrfld( swID, DATA_FIELDIP, start, stride, edge, &
                           REAL(sp(i)%l3spImgPrecision) )
         IF (status == -1) THEN
            msr = WR_ERR // DATA_FIELDIP
d800 69
d875 2
a876 2
         status = swdetach(swID)
         IF (status == -1) THEN
d878 1
a878 1
              'Failed to detach from swath interface after writing.')
d880 2
a881 2
            msr = 'Swath ' // TRIM(sp(i)%name) // ' successfully written to &
                  &file ' // spFile
d887 1
a887 1
! Close the file
d890 1
a890 1
      status = swclose(swfID)
d892 2
a893 2
      IF (status == -1) THEN
         msr = 'Failed to close file ' // spFile // ' after writing.'
d900 1
a900 1
      CALL WritePCF2Hdr(spFile, anText)
d903 1
a903 1
   END SUBROUTINE OutputL3SP
d1056 3
@


1.8
log
@Removed references to private L2 parameters.
@
text
@d25 1
a25 1
   "$Id: L3SPData.f90,v 1.7 2001/03/27 19:30:43 nakamura Exp $"
d132 2
d140 2
d144 2
d152 2
d156 1
d162 1
d164 1
d170 1
d174 2
d190 1
d205 1
d267 1
a267 1
            msr = 'Failed to create swath ' // sp(i)%name
d317 1
d365 4
a368 2
         IF (status == -1) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                       &to detach from swath interface after L3SP definition.')
d390 2
d397 3
a399 1
         ENDIF
d403 2
d412 2
d416 3
d426 2
d431 4
d443 4
d451 4
d461 1
a461 1

d469 4
d475 4
d493 5
d500 1
d503 2
a504 2
            CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to detach from &
                                              &swath interface after writing.')
d515 1
d517 1
d523 1
d682 3
@


1.7
log
@Added use of PCFHdr; fixed err checks on deallocate.
@
text
@a9 2
   USE L2GPData, ONLY: L2GPNameLen, DIM_NAME2, DIM_NAME3, GEO_FIELD1, &
                       GEO_FIELD9, GEO_FIELD10, HDFE_NOMERGE
d25 1
a25 1
   "$Id: L3SPData.f90,v 1.6 2001/02/21 20:49:29 nakamura Exp $"
d58 1
a58 1
     CHARACTER (LEN=L2GPNameLen) :: name	! name for the output quantity
d621 3
@


1.6
log
@Changed MLSPCF to MLSPCF3.
@
text
@d17 1
d27 1
a27 1
   "$Id: L3SPData.f90,v 1.5 2001/02/09 20:29:35 nakamura Exp $"
d497 6
a502 4
      IF ( ASSOCIATED(l3sp%pressure) ) DEALLOCATE (l3sp%pressure, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3sp pressure pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d507 6
a512 4
      IF ( ASSOCIATED(l3sp%latitude) ) DEALLOCATE (l3sp%latitude, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3sp latitude pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d517 6
a522 4
      IF ( ASSOCIATED(l3sp%waveNumber) ) DEALLOCATE (l3sp%waveNumber, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3sp waveNumber pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d525 6
a530 4
      IF ( ASSOCIATED(l3sp%frequency) ) DEALLOCATE (l3sp%frequency, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3sp frequency pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d535 1
a535 1
      IF ( ASSOCIATED(l3sp%l3spRelValue) ) &
d537 4
a540 3
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3spRelValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d543 1
a543 1
      IF ( ASSOCIATED(l3sp%l3spRelPrecision) ) &
d545 4
a548 3
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3spRelPrecision'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d551 1
a551 1
      IF ( ASSOCIATED(l3sp%l3spImgValue) ) &
d553 4
a556 3
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3spImgValue pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d559 1
a559 1
      IF ( ASSOCIATED(l3sp%l3spImgPrecision) ) &
d561 4
a564 3
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  l3spImgPrecision'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d623 3
@


1.5
log
@Added third dimension to waveNumber & frequency.
@
text
@d16 1
a16 1
   USE MLSPCF
d26 1
a26 1
   "$Id: L3SPData.f90,v 1.4 2001/02/09 19:17:05 nakamura Exp $"
d610 3
@


1.4
log
@Changed dimensions on waveNumber & frequency.
@
text
@d26 1
a26 1
   "$Id: L3SPData.f90,v 1.3 2001/01/16 17:44:38 nakamura Exp $"
d44 2
d80 2
a81 1
     REAL(r8), DIMENSION(:,:), POINTER :: waveNumber
d83 2
a84 3
     REAL(r8), DIMENSION(:,:), POINTER :: frequency

	! dimensioned (nLevels, nLats)
d149 1
a149 1
      ALLOCATE(l3sp%waveNumber(l3sp%nLevels,l3sp%nLats), STAT=err)
d155 1
a155 1
      ALLOCATE(l3sp%frequency(l3sp%nLevels,l3sp%nLats), STAT=err)
d302 1
a302 1
         status = swdefgfld(swID, GEO_FIELDWN, DIMLL_NAME, DFNT_FLOAT32, &
d309 1
a309 1
         status = swdefgfld(swID, GEO_FIELD10, DIMLL_NAME, DFNT_FLOAT32, &
d390 2
a391 2
         status = swwrfld( swID, GEO_FIELDWN, start(1:2), stride(1:2), &
                           edge(1:2), REAL(sp(i)%waveNumber) )
d399 4
a402 2
         status = swwrfld( swID, GEO_FIELD10, start(1:2), stride(1:2), &
                           edge(1:2), REAL(sp(i)%frequency) )
d410 2
d610 3
@


1.3
log
@Added annotation.
@
text
@d26 1
a26 1
   "$Id: L3SPData.f90,v 1.2 2000/12/29 20:51:11 nakamura Exp $"
a42 1
   CHARACTER (LEN=*), PARAMETER :: DIML_NAME = 'nLats'
d78 5
a82 2
     REAL(r8), DIMENSION(:), POINTER :: waveNumber	! dimensioned (nWaveNum)
     REAL(r8), DIMENSION(:), POINTER :: frequency	! dimensioned (nFreqs)
d103 1
a103 1
! This subroutine allocates the internal field pointers of the L3DMData_T
d147 1
a147 1
      ALLOCATE(l3sp%waveNumber(l3sp%nWaveNum), STAT=err)
d153 1
a153 1
      ALLOCATE(l3sp%frequency(l3sp%nFreqs), STAT=err)
d300 1
a300 1
         status = swdefgfld(swID, GEO_FIELDWN, DIMW_NAME, DFNT_FLOAT32, &
d307 1
a307 1
         status = swdefgfld(swID, GEO_FIELD10, DIM_NAME3, DFNT_FLOAT32, &
d388 2
a389 2
         status = swwrfld( swID, GEO_FIELDWN, start(3), stride(3), edge(3), &
                           REAL(sp(i)%waveNumber) )
d397 2
a398 2
         status = swwrfld( swID, GEO_FIELD10, start(4), stride(4), edge(4), &
                           REAL(sp(i)%frequency) )
d583 1
a583 1
         END DO
d604 3
@


1.2
log
@Added subroutine OutputL3SP.
@
text
@d26 1
a26 1
   "$Id: L3SPData.f90,v 1.4 2000/12/28 21:32:17 nakamura Exp nakamura $"
d191 3
a193 3
!------------------------------------
   SUBROUTINE OutputL3SP (cfProd, sp)
!------------------------------------
d204 2
d456 4
d602 3
@


1.1
log
@Module for the L3SP data type.
@
text
@d9 4
a12 1
   USE L2GPData, ONLY: L2GPNameLen
d14 1
d16 3
d26 1
a26 1
   "$Id: L3SPData.f90,v 1.2 2000/11/29 20:35:04 nakamura Exp nakamura $"
d34 1
d191 267
d595 3
a597 1
! $Log: $
@

