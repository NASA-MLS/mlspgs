head	1.23;
access;
symbols
	v5-02-NRT-19:1.23
	v6-00:1.23
	v5-02-NRT-18:1.23
	v5-02:1.23
	v5-01-NRT-17:1.23
	v5-01-NRT-16:1.23
	v5-01-NRT-15:1.23
	v5-01-NRT-14:1.23
	neuralnetworks-1-0:1.23.0.14
	cfm-single-freq-0-1:1.23.0.12
	v5-01:1.23
	v5-00:1.23
	v4-23-TA133:1.23.0.10
	mus-emls-1-70:1.23.0.8
	rel-1-0-englocks-work:1.23.0.6
	VUMLS1-00:1.23
	VPL1-00:1.23
	V4-22-NRT-08:1.23
	VAM1-00:1.23
	V4-21:1.23.0.4
	V4-13:1.23
	V4-12:1.23
	V4-11:1.23
	V4-10:1.23
	V3-43:1.23
	M4-00:1.23
	V3-41:1.23
	V3-40-PlusGM57:1.23.0.2
	V2-24-NRT-04:1.23
	V3-33:1.23
	V2-24:1.23
	V3-31:1.23
	V3-30-NRT-05:1.23
	cfm-01-00:1.23
	V3-30:1.23
	V3-20:1.23
	V3-10:1.23
	V2-23-NRT-02:1.23
	V2-23:1.23
	V2-22-NRT-01:1.23
	V2-22:1.23
	V2-21:1.23
	V2-20:1.23
	V2-11:1.23
	V2-10:1.23
	V2-00:1.23
	V1-51:1.21
	V1-50:1.21
	V1-45:1.21
	V1-44:1.21
	V1-43:1.21
	V1-42:1.20
	V1-41:1.20
	V1-32:1.19
	V1-40:1.20
	V1-31:1.19
	V1-30:1.19
	V1-13:1.17
	V1-12:1.17
	V1-11:1.17
	V1-10:1.16
	newfwm-feb03:1.16.0.2
	V1-04:1.16
	V1-03:1.16
	V1-02:1.16
	V1-00:1.15
	newfwm-sep01:1.13.0.2
	V0-7:1.13
	V0-5-Level2:1.11
	V0-5-SIPS:1.10;
locks; strict;
comment	@# @;


1.23
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.23.19.07.39;	author pwagner;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.04.15.33.15;	author cvuu;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.07.21.43.18;	author cvuu;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.30.18.15.48;	author pwagner;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.22.02.54.02;	author jdone;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.15.00.16.38;	author pwagner;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.10.22.10.41;	author jdone;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.13.20.51.20;	author nakamura;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.26.19.27.14;	author nakamura;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.19.14.03.27;	author nakamura;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.18.40.04;	author nakamura;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.24.19.41.41;	author nakamura;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.11.18.51.38;	author nakamura;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.27.19.36.43;	author nakamura;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.07.21.28.41;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.21.21.16.31;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.16.17.49.03;	author nakamura;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.29.21.44.16;	author nakamura;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.07.21.20.43;	author nakamura;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.07.19.40.37;	author nakamura;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.24.19.36.56;	author nakamura;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.17.20.27.49;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.23
log
@V2.00 commit
@
text
@
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!==============================================================================
MODULE OutputClose
!==============================================================================

  USE L2GPData, ONLY: L2GPData_T, DestroyL2GPDatabase
  USE L2Interface, ONLY: ResidualOutput
  USE L3CF, ONLY: L3CFProd_T
  USE MLSCF, ONLY: Mlscf_T
  USE MLSCommon, ONLY: FileNameLen, r8
  USE MLSFiles, ONLY: HDFVERSION_5, HDFVERSION_4
  USE MLSL3Common, ONLY: NOOUT_ERR, OutputFiles_T, INVENTORYMETADATA
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, MLSMSG_Warning, & 
       & MLSMSG_DeAllocate
  USE MLSPCF3, ONLY: mlspcf_mcf_l3log_start 
  USE OpenInit, ONLY: PCFData_T
  USE SDPToolkit, only: PGS_S_SUCCESS, PGSd_MET_GROUP_NAME_L, & 
       & PGSD_MET_NUM_OF_GROUPS, Pgs_smf_getMsg, WARNIFCANTPGSMETREMOVE
  IMPLICIT NONE
  PUBLIC
  
  
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: OutputClose.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

! Contents:

! Definitions -- OutputFlags_T
! Subroutines -- WriteMetaLog
!                OutputProd
!                OutputAndClose

! Remarks:  This module contains the routines needed for the L3 Daily
! Output/Close task.

! Parameters

! This data type is used to store the flags indicating whether the product
! databases are suitable for output

   TYPE OutputFlags_T

     LOGICAL :: writel3dmCom, writel3dmAsc, writel3dmDes
     ! daily map databases (for all output days)
     
     LOGICAL :: writel3rCom, writel3rAsc, writel3rDes
     ! L3Residual databases (for all output days)
     
     LOGICAL :: writel3sp
     ! L3SP database (for asc/des/com)
     
  END TYPE OutputFlags_T
  
CONTAINS


  !-------------------------------
  SUBROUTINE WriteMetaLog (pcf)
  !-------------------------------
  USE PCFModule, ONLY: ExpandFileTemplate

    ! Brief description of subroutine
    ! This subroutine writes metadata for the log file to separate ASCII file. 
    ! Arguments

    TYPE( PCFData_T ), INTENT(IN) :: pcf
    
    ! Variables

    CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)
    CHARACTER (LEN=480) :: msg, msr
    CHARACTER (LEN=45) :: sval
    CHARACTER (LEN=32) :: mnemonic
    CHARACTER (LEN=1) :: nullStr
    
    INTEGER :: result
    
    ! Functions

    INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d, & 
         pgs_met_setAttr_s, pgs_met_write
    
    ! Parameters

    INTEGER, PARAMETER :: ASCII_FILE = 101

    nullStr = ''

    ! Initialize the MCF file

    result = pgs_met_init(mlspcf_mcf_l3log_start, groups)
    IF (result /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, ModuleName, &
         & 'Initialization error.  See LogStatus for details.')
    
    ! Set PGE values

    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalGranuleID", &
         & pcf%logGranID)
    
    CALL ExpandFileTemplate('$cycle', sval, cycle=pcf%cycle)
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalVersionID", &
         & sval)
    
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
         & "RangeBeginningDate", pcf%l3StartDay)
    sval= '00:00:00.000000'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
         & "RangeBeginningTime", sval)
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
         & "RangeEndingDate", pcf%l3EndDay)
    sval= '23:59:59.999999'
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
         & "RangeEndingTime", sval)
    
    result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "PGEVersion", &
         & pcf%outputVersion)
    
    IF (result /= PGS_S_SUCCESS) THEN
       call Pgs_smf_getMsg(result, mnemonic, msg)
       msr = mnemonic // ':  ' // msg
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    
    ! Write the metadata and their values to an ASCII file
    
    result = pgs_met_write(groups(1), nullStr, ASCII_FILE)
    
    IF (result /= PGS_S_SUCCESS) THEN
       call Pgs_smf_getMsg(result, mnemonic, msg)
       msr = mnemonic // ':  ' // msg
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    
    result = pgs_met_remove()
    if (result /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
       write(msr, *) result
       CALL MLSMessage (MLSMSG_Warning, ModuleName, &
            & "Calling pgs_met_remove() failed with value " // trim(msr) )
    endif

  !-----------------------------
  END SUBROUTINE WriteMetaLog
  !------------------

  !-------------------------------------------------------------------
  SUBROUTINE OutputProd (pcf, l3cf, anText, l3sp, l3dm, dmA, dmD, &
       & l3r, residA, residD, flags, hdfVersion)
  !-------------------------------------------------------------------
  USE L3DMData, ONLY: L3DMData_T, OutputGrids, WriteMetaL3DM, &
     & DestroyL3DMDatabase
  USE L3SPData, ONLY: L3SPData_T, OutputL3SP, DestroyL3SPDatabase
  USE PCFModule, ONLY: ExpandFileTemplate
    
    ! Brief description of subroutine
    ! This subroutine performs the Output/Close task in the MLSL3 program.

    ! Arguments
    
    TYPE( PCFData_T ), INTENT(IN) :: pcf
    
    TYPE( L3CFProd_T ), INTENT(IN) :: l3cf
    
    TYPE( OutputFlags_T ), INTENT(IN) :: flags
    
    TYPE( L2GPData_T ), POINTER :: l3r(:), residA(:), residD(:)
    
    TYPE( L3DMData_T ), POINTER :: l3dm(:), dmA(:), dmD(:)
    
    TYPE( L3SPData_T ), POINTER :: l3sp(:)
    
    CHARACTER (LEN=1), POINTER :: anText(:)
    
    INTEGER, INTENT(IN), OPTIONAL :: hdfVersion
   
    ! Parameters
    
    ! Functions
    
    ! Variables
    
    TYPE( OutputFiles_T ) :: files
    
    CHARACTER (LEN=480) :: msr
    CHARACTER (LEN=FileNameLen) :: type
    
    INTEGER :: myHDFVersion
    LOGICAL :: createFile
 
    ! Check version of HDFEOS
   
    IF (PRESENT(hdfVersion)) THEN 
       myHDFVersion = hdfVersion
    ELSE
       myHDFVersion = HDFVERSION_4
    ENDIF

    ! L3SP -- if data exist, create & write a file for this product
    
    IF (flags%writel3sp) THEN
       CALL OutputL3SP (l3cf, anText, l3sp, myHDFVersion)
       CALL DestroyL3SPDatabase(l3sp)
    ELSE
       msr = TRIM(l3cf%l3prodNameD) // ' L3SP' // NOOUT_ERR
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
    ENDIF
 
    ! L3DM -- check that daily map data exist in some form for the product
    
    IF ( .NOT.(flags%writel3dmCom) .AND. .NOT.(flags%writel3dmAsc) .AND. &
         & .NOT.(flags%writel3dmDes) ) THEN
       
       msr = 'No l3dm data found, no file produced for ' // l3cf%l3prodNameD
       CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
       
    ELSE
       
       ! Expand the level in the file template
       
       CALL ExpandFileTemplate(l3cf%fileTemplate, type, 'L3DM')
       
       ! If combined l3dm data exist, write them to l3dm files; 
       ! save the names of any files created
       
       files%nFiles = 0
       files%name   = ''
       files%date   = ''
       createFile = .true.

       IF (flags%writel3dmCom) THEN
          CALL OutputGrids(type, l3dm, files, myHDFVersion, createFile)
          CALL DestroyL3DMDatabase(l3dm)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'com') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
 
       ! If ascending l3dm data exist, write/append them to l3dm files; 
       ! add the names of any new files created to the files array
       
       IF (flags%writel3dmAsc) THEN
          CALL OutputGrids(type, dmA, files, myHDFVersion, createFile)
          CALL DestroyL3DMDatabase(dmA)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'asc') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'Ascending' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
       
       ! If descending l3dm data exist, write/append them to l3dm files, 
       ! adding any new names to the files array
       
       IF (flags%writel3dmDes) THEN
          CALL OutputGrids(type, dmD, files, myHDFVersion, createFile)
          CALL DestroyL3DMDatabase(dmD)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'des') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'Descending' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
       
       ! L3Residual--if any residual data exist, 
       ! append swaths to the l3dm files
       
       createFile = .False. 
       IF (flags%writel3rCom) THEN
          CALL ResidualOutput(type, l3r)
          CALL DestroyL2GPDatabase(l3r)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'com') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'Residuals' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
       
       IF (flags%writel3rAsc) THEN
          CALL ResidualOutput(type, residA)
          CALL DestroyL2GPDatabase(residA)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'asc') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'AscendingResiduals' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
       
       IF (flags%writel3rDes) THEN
          CALL ResidualOutput(type, residD)
          CALL DestroyL2GPDatabase(residD)
       ELSE
          IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'des') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'DescendingResiduals' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
          ENDIF
       ENDIF
      
       ! Write the L3DM metadata
       CALL WriteMetaL3DM(pcf, l3cf, files, anText, hdfVersion)
       
    ENDIF
    
  !---------------------------
  END SUBROUTINE OutputProd
  !---------------------------
  !------------------------------------------
  SUBROUTINE OutputAndClose (cf, pcf, cfProd, avgPer, anText)
  !-------------------------------------------------------------

     ! Brief description of subroutine
     ! This subroutine performs final Output & Close tasks 
     ! outside the product loop.

     ! Arguments
     
     TYPE( Mlscf_T ), INTENT(INOUT) :: cf
     
     TYPE( PCFData_T ), INTENT(IN) :: pcf

     TYPE( L3CFProd_T ), POINTER :: cfProd(:)
     
     CHARACTER (LEN=1), POINTER :: anText(:)
     
     REAL(r8), POINTER :: avgPer(:)

     ! Parameters
     
     ! Functions

     ! Variables
     
     CHARACTER (LEN=480) :: msr

     INTEGER :: err

     LOGICAL :: writeLog = .false.

     ! Write the log file metadata

     if (writeLog) CALL WriteMetaLog(pcf)

     ! Final deallocations
     ! Check if the pointers are associated and then deallocate. 

     if (associated(cfProd)) then

        DEALLOCATE(cfProd, STAT=err)
        IF ( err /= 0 ) THEN
           msr = MLSMSG_DeAllocate // '  cfProd pointer.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        
     endif
     
     if (associated(anText)) then
        
        DEALLOCATE(anText, STAT=err)
        IF ( err /= 0 ) THEN
           msr = MLSMSG_DeAllocate // '  anText pointer.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        
     endif
     
     if (associated(avgPer)) then

        DEALLOCATE(avgPer, STAT=err)
        IF ( err /= 0 ) THEN
           msr = MLSMSG_DeAllocate // '  avgPer pointer.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        
     endif
     
     if ( associated(cf%Sections) ) then 
        
        DEALLOCATE (cf%Sections, STAT=err)
        IF ( err /= 0 ) THEN
           msr = MLSMSG_DeAllocate // '  cf section pointers.'
           CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
        ENDIF
        
     endif

   !-------------------------------
   END SUBROUTINE OutputAndClose
   !-------------------------------

 !=====================
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: OutputClose.f90,v 1.22 2005/06/23 19:07:39 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
 END MODULE OutputClose
 !=====================

!$Log: OutputClose.f90,v $
!Revision 1.22  2005/06/23 19:07:39  pwagner
!Reworded Copyright statement, moved rcs id
!
!Revision 1.21  2004/05/04 15:33:15  cvuu
!v1.4.3: Use int array for Date in Data Field
!
!Revision 1.20  2004/01/07 21:43:18  cvuu
!version 1.4 commit
!
!Revision 1.19  2003/04/30 18:15:48  pwagner
!Work-around for LF95 infinite compile-time bug
!
!Revision 1.18  2003/03/22 02:54:02  jdone
!HDFEOS2/HDFEOS5 functionality, use only, and indentation added
!
!Revision 1.17  2003/03/15 00:16:38  pwagner
!May warn if pgs_met_remove returns non-zero value
!
!Revision 1.16  2002/04/10 22:10:41  jdone
!Associated statements added before deallocate.
!
!Revision 1.15  2001/12/13 20:51:20  nakamura
!Removed separate write, flags for diagnostics.
!
!Revision 1.14  2001/11/26 19:27:14  nakamura
!Added L3DMDiag stuff.
!
!Revision 1.13  2001/07/19 14:03:27  nakamura
!Removed DZ stuff.
!
!Revision 1.12  2001/05/04 18:40:04  nakamura
!Changed to generic OutputFiles_T, WriteMetaL3DZ.
!
!Revision 1.11  2001/04/24 19:41:41  nakamura
!Added ONLY to USE L2GPData statement.
!
!Revision 1.10  2001/04/11 18:51:38  nakamura
!Moved deallocations for pointers passed between CORE & I/O up to main program.
!
!Revision 1.9  2001/03/27 19:36:43  nakamura
!Moved a parameter to MLSL3Common; updated metadata.
!
!Revision 1.8  2001/03/07 21:28:41  nakamura
!Commented out database deallocations.
!
!Revision 1.7  2001/02/21 21:16:31  nakamura
!Changed MLSPCF to MLSPCF3; added L3DZ stuff; changed log LocalGranuleID; renamed/split OutputAndClose tasks.
!
!Revision 1.6  2001/01/16 17:49:03  nakamura
!Updated for new MCFs and annotation.
!
!Revision 1.5  2000/12/29 21:44:16  nakamura
!Removed obsolete routines CheckOutputDate & FindDatabaseIndex; switched to one-product/all-days paradigm.
!
!Revision 1.4  2000/12/07 21:20:43  nakamura
!Changed search/bypass PCF logic, so that the SearchPCFNames subroutine always returns a file name with a path.
!
!Revision 1.3  2000/12/07 19:40:37  nakamura
!Updated for modified ExpandFileTemplate.
!
!Revision 1.2  2000/10/24 19:36:56  nakamura
!Updated WriteMetaLog for new MCF; moved search for PCF number of MCF to L3CF module.
!
!Revision 1.1  2000/10/17 20:27:49  nakamura
!Module for the Output/Close task.
!
@


1.22
log
@Reworded Copyright statement, moved rcs id
@
text
@d36 1
a36 1
       "$RCSfile: $"
d47 1
a47 1
! Remarks:  This is a prototype module for the routines needed for the L3 Daily
d408 1
a408 1
       "$Id: $"
d417 3
@


1.21
log
@v1.4.3: Use int array for Date in Data Field
@
text
@d2 10
a11 2
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a32 1
  PRIVATE :: ID, ModuleName
d34 5
a38 5
!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                
   "$Id: OutputClose.f90,v 1.20 2004/01/07 21:43:18 cvuu Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: OutputClose.f90,v $"
!----------------------------------------------------------
d405 8
d417 3
@


1.20
log
@version 1.4 commit
@
text
@d29 1
a29 1
   "$Id: OutputClose.f90,v 1.19 2003/04/30 18:15:48 pwagner Exp $"
d305 1
a305 1
       
d402 3
@


1.19
log
@Work-around for LF95 infinite compile-time bug
@
text
@d9 1
a9 1
  USE L2GPData, ONLY: L2GPData_T
d29 1
a29 1
   "$Id: OutputClose.f90,v 1.18 2003/03/22 02:54:02 jdone Exp $"
d156 3
a158 2
  USE L3DMData, ONLY: L3DMData_T, OutputGrids, WriteMetaL3DM
  USE L3SPData, ONLY: L3SPData_T, OutputL3SP
d181 1
a181 1
    
d194 2
a195 1
    
d208 1
d213 1
a213 1
    
d234 2
a235 1
                     
d237 2
a238 1
          CALL OutputGrids(type, l3dm, files, myHDFVersion)
d245 1
a245 1
       
d250 2
a251 1
          CALL OutputGrids(type, dmA, files, myHDFVersion)
d263 2
a264 1
          CALL OutputGrids(type, dmD, files, myHDFVersion)
d275 1
d278 1
d288 1
d298 1
d344 2
d348 1
a348 1
     CALL WriteMetaLog(pcf)
d402 3
@


1.18
log
@HDFEOS2/HDFEOS5 functionality, use only, and indentation added
@
text
@a11 2
  USE L3DMData, ONLY: L3DMData_T, OutputGrids, WriteMetaL3DM, INVENTORYMETADATA
  USE L3SPData, ONLY: L3SPData_T, OutputL3SP
d15 1
a15 1
  USE MLSL3Common, ONLY: NOOUT_ERR, OutputFiles_T
a19 1
  USE PCFModule, ONLY: ExpandFileTemplate
d29 1
a29 1
   "$Id: OutputClose.f90,v 1.17 2003/03/15 00:16:38 pwagner Exp $"
d67 1
d156 3
d389 3
@


1.17
log
@May warn if pgs_met_remove returns non-zero value
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 20
!===============================================================================

   USE L2GPData, ONLY: L2GPData_T
   USE L2Interface
   USE L3CF
   USE L3DMData
   USE L3SPData
   USE MLSCF
   USE MLSCommon
   USE MLSL3Common
   USE MLSMessageModule
   USE MLSPCF3
   USE MLSStrings
   USE OpenInit
   USE PCFModule
   USE SDPToolkit, only: WARNIFCANTPGSMETREMOVE
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID, ModuleName
d9 21
d31 2
a32 2
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: OutputClose.f90,v 1.16 2002/04/10 22:10:41 jdone Exp $"
d54 2
a55 2
	! daily map databases (for all output days)

d57 2
a58 2
	! L3Residual databases (for all output days)

d60 4
a63 4
	! L3SP database (for asc/des/com)

   END TYPE OutputFlags_T

a65 3
!-------------------------------
   SUBROUTINE WriteMetaLog (pcf)
!-------------------------------
d67 222
a288 206
! Brief description of subroutine
! This subroutine writes metadata for the log file to a separate ASCII file.

! Arguments

      TYPE( PCFData_T ), INTENT(IN) :: pcf

! Parameters

      INTEGER, PARAMETER :: ASCII_FILE = 101

! Functions

      INTEGER, EXTERNAL :: pgs_met_init, pgs_met_remove, pgs_met_setAttr_d
      INTEGER, EXTERNAL :: pgs_met_setAttr_s, pgs_met_write

! Variables

      CHARACTER (LEN=1) :: nullStr
      CHARACTER (LEN=45) :: sval
      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=480) :: msg, msr
      CHARACTER (LEN=PGSd_MET_GROUP_NAME_L) :: groups(PGSd_MET_NUM_OF_GROUPS)

      INTEGER :: result

      nullStr = ''

! Initialize the MCF file

      result = pgs_met_init(mlspcf_mcf_l3log_start, groups)
      IF (result /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, ModuleName, &
                          'Initialization error.  See LogStatus for details.')

! Set PGE values

      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalGranuleID", &
                                 pcf%logGranID)

      CALL ExpandFileTemplate('$cycle', sval, cycle=pcf%cycle)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "LocalVersionID", &
                                 sval)

      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeBeginningDate", pcf%l3StartDay)
      sval= '00:00:00.000000'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeBeginningTime", sval)
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingDate", pcf%l3EndDay)
      sval= '23:59:59.999999'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "RangeEndingTime", sval)

      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "PGEVersion", &
                                 pcf%outputVersion)

      IF (result /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Write the metadata and their values to an ASCII file

      result = pgs_met_write(groups(1), nullStr, ASCII_FILE)

      IF (result /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(result, mnemonic, msg)
         msr = mnemonic // ':  ' // msg
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      result = pgs_met_remove()
      if (result /= PGS_S_SUCCESS .and. WARNIFCANTPGSMETREMOVE) THEN 
        write(msr, *) result
        CALL MLSMessage (MLSMSG_Warning, ModuleName, &
              "Calling pgs_met_remove() failed with value " // trim(msr) )
      endif          

!-----------------------------
   END SUBROUTINE WriteMetaLog
!-----------------------------

!-------------------------------------------------------------------
   SUBROUTINE OutputProd (pcf, l3cf, anText, l3sp, l3dm, dmA, dmD, &
                          l3r, residA, residD, flags)
!-------------------------------------------------------------------

! Brief description of subroutine
! This subroutine performs the Output/Close task in the MLSL3 program.

! Arguments

      TYPE( PCFData_T ), INTENT(IN) :: pcf

      TYPE( L3CFProd_T ), INTENT(IN) :: l3cf

      TYPE( OutputFlags_T ), INTENT(IN) :: flags

      TYPE( L2GPData_T ), POINTER :: l3r(:), residA(:), residD(:)

      TYPE( L3DMData_T ), POINTER :: l3dm(:), dmA(:), dmD(:)

      TYPE( L3SPData_T ), POINTER :: l3sp(:)

      CHARACTER (LEN=1), POINTER :: anText(:)

! Parameters

! Functions

! Variables

      TYPE( OutputFiles_T ) :: files

      CHARACTER (LEN=FileNameLen) :: type
      CHARACTER (LEN=480) :: msr

! L3SP -- if data exist, create & write a file for this product

      IF (flags%writel3sp) THEN
         CALL OutputL3SP (l3cf, anText, l3sp)
      ELSE
         msr = TRIM(l3cf%l3prodNameD) // ' L3SP' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF

! L3DM -- check that daily map data exist in some form for the product

      IF ( .NOT.(flags%writel3dmCom) .AND. .NOT.(flags%writel3dmAsc) .AND. &
           .NOT.(flags%writel3dmDes) ) THEN

         msr = 'No l3dm data found, no file produced for ' // l3cf%l3prodNameD
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)

      ELSE

! Expand the level in the file template

         CALL ExpandFileTemplate(l3cf%fileTemplate, type, 'L3DM')

! If combined l3dm data exist, write them to l3dm files; save the names of any
! files created

         files%nFiles = 0
         files%name = ''
         files%date = ''

         IF (flags%writel3dmCom) THEN
            CALL OutputGrids(type, l3dm, files)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'com') ) THEN
               msr = TRIM(l3cf%l3prodNameD) // NOOUT_ERR
               CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

! If ascending l3dm data exist, write/append them to l3dm files; add the names
! of any new files created to the files array

         IF (flags%writel3dmAsc) THEN
            CALL OutputGrids(type, dmA, files)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'asc') ) THEN
               msr = TRIM(l3cf%l3prodNameD) // 'Ascending' // NOOUT_ERR
               CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

! If descending l3dm data exist, write/append them to l3dm files, adding any
! new names to the files array

         IF (flags%writel3dmDes) THEN
            CALL OutputGrids(type, dmD, files)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'des') ) THEN
               msr = TRIM(l3cf%l3prodNameD) // 'Descending' // NOOUT_ERR
               CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

! L3Residual -- if any residual data exist, append swaths to the l3dm files

         IF (flags%writel3rCom) THEN
            CALL ResidualOutput(type, l3r)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'com') ) THEN
               msr = TRIM(l3cf%l3prodNameD) // 'Residuals' // NOOUT_ERR
               CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

         IF (flags%writel3rAsc) THEN
            CALL ResidualOutput(type, residA)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'asc') ) THEN
              msr = TRIM(l3cf%l3prodNameD) // 'AscendingResiduals' // NOOUT_ERR
              CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

         IF (flags%writel3rDes) THEN
           CALL ResidualOutput(type, residD)
         ELSE
           IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'des') ) THEN
d291 87
a377 88
           ENDIF
         ENDIF

! Write the L3DM metadata
         CALL WriteMetaL3DM(pcf, l3cf, files, anText)

      ENDIF

!---------------------------
   END SUBROUTINE OutputProd
!---------------------------

!-------------------------------------------------------------
   SUBROUTINE OutputAndClose (cf, pcf, cfProd, avgPer, anText)
!-------------------------------------------------------------

! Brief description of subroutine
! This subroutine performs final Output & Close tasks outside the product loop.

! Arguments

      TYPE( PCFData_T ), INTENT(IN) :: pcf

      TYPE( L3CFProd_T ), POINTER :: cfProd(:)

      CHARACTER (LEN=1), POINTER :: anText(:)

      REAL(r8), POINTER :: avgPer(:)

      TYPE( Mlscf_T ), INTENT(INOUT) :: cf

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: err

! Write the log file metadata

      CALL WriteMetaLog(pcf)

! Final deallocations
! Check if the pointers are associated and then deallocate. 

      if (associated(cfProd)) then

      DEALLOCATE(cfProd, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  cfProd pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif

      if (associated(anText)) then

      DEALLOCATE(anText, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  anText pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif


      if (associated(avgPer)) then

      DEALLOCATE(avgPer, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  avgPer pointer.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
      
      endif

      if ( associated(cf%Sections) ) then 

      DEALLOCATE (cf%Sections, STAT=err)
      IF ( err /= 0 ) THEN
         msr = MLSMSG_DeAllocate // '  cf section pointers.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      endif
d379 1
a379 1
!-------------------------------
d381 1
a381 1
!-------------------------------
d383 3
a385 3
!=====================
END MODULE OutputClose
!=====================
d388 3
@


1.16
log
@Associated statements added before deallocate.
@
text
@d22 1
a22 1
   USE SDPToolkit
d30 1
a30 1
   "$Id: OutputClose.f90,v 1.15 2001/12/13 20:51:20 nakamura Exp $"
d142 5
d374 3
@


1.15
log
@Removed separate write, flags for diagnostics.
@
text
@d30 1
a30 1
   "$Id: OutputClose.f90,v 1.14 2001/11/26 19:27:14 nakamura Exp $"
a274 1

d317 15
a331 2
 
      DEALLOCATE(cfProd, anText, avgPer, STAT=err)
d333 1
a333 1
         msr = MLSMSG_DeAllocate // '  Open/Init quantities.'
d337 15
d358 2
d369 3
@


1.14
log
@Added L3DMDiag stuff.
@
text
@a12 1
   USE L3DMDiag
d30 1
a30 1
   "$Id: OutputClose.f90,v 1.13 2001/07/19 14:03:27 nakamura Exp $"
a56 3
     LOGICAL :: writel3dgCom, writel3dgAsc, writel3dgDes
	! diagnostic databases (for all output days)

d147 4
a150 4
!--------------------------------------------------------------------------------
   SUBROUTINE OutputProd (pcf, l3cf, anText, l3sp, l3dm, dmA, dmD, l3r, residA, &
                          residD, l3dg, dgA, dgD, flags)
!--------------------------------------------------------------------------------
a166 2
      TYPE( L3DMDiag_T ), POINTER :: l3dg(:), dgA(:), dgD(:)

a244 29
! Diagnostics -- if any diagnostic data exist, append swaths to the l3dm files

         IF (flags%writel3dgCom) THEN
            CALL OutputDiags(type, l3dg)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'com') ) THEN
               msr = TRIM(l3cf%l3prodNameD) // 'Diagnostics' // NOOUT_ERR
               CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

         IF (flags%writel3dgAsc) THEN
            CALL OutputDiags(type, dgA)
         ELSE
            IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'asc') ) THEN
              msr = TRIM(l3cf%l3prodNameD) // 'AscendingDiagnostics' // NOOUT_ERR
              CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            ENDIF
         ENDIF

         IF (flags%writel3dgDes) THEN
           CALL OutputDiags(type, dgD)
         ELSE
           IF ( (l3cf%mode == 'all') .OR. (l3cf%mode == 'des') ) THEN
             msr = TRIM(l3cf%l3prodNameD) // 'DescendingDiagnostics' // NOOUT_ERR
             CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
           ENDIF
         ENDIF

d340 3
@


1.13
log
@Removed DZ stuff.
@
text
@d13 1
d31 1
a31 1
   "$Id: OutputClose.f90,v 1.18 2001/07/18 15:14:10 nakamura Exp nakamura $"
d58 3
d153 1
a153 1
                          residD, flags)
d171 2
d251 29
d375 3
@


1.12
log
@Changed to generic OutputFiles_T, WriteMetaL3DZ.
@
text
@a12 1
   USE L3DZData
d30 1
a30 1
   "$Id: OutputClose.f90,v 1.11 2001/04/24 19:41:41 nakamura Exp $"
a56 3
     LOGICAL :: writel3dzCom, writel3dzAsc, writel3dzDes
	! daily zonal mean databases (for all output days)

d147 4
a150 4
!---------------------------------------------------------------------------
   SUBROUTINE OutputProd (pcf, l3cf, cfDef, anText, l3sp, l3dm, dmA, dmD, &
                          l3r, residA, residD, dzs, dzA, dzD, flags, sFiles)
!---------------------------------------------------------------------------
a158 2
      TYPE( L3CFDef_T ), INTENT(IN) :: cfDef

a166 2
      TYPE( L3DZData_T ), POINTER :: dzs(:), dza(:), dzd(:)

a170 2
      TYPE( OutputFiles_T ), INTENT(INOUT) :: sFiles

a279 28
! L3DZ -- if data exist, write them to L3DZ Standard files; keep track of
!         which files have been created for later metadata annotation

      IF (flags%writel3dzCom) THEN
         CALL OutputL3DZ(cfDef%stdType, dzs, sFiles)
      ELSE
         msr = TRIM(l3cf%l3prodNameD) // ' DZ' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF

! If ascending data for the product exist, write them to the Standard files

      IF (flags%writel3dzAsc) THEN
         CALL OutputL3DZ(cfDef%stdType, dza, sFiles)
      ELSE
         msr = TRIM(l3cf%l3prodNameD) // 'Ascending DZ' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF

! If descending data exist, write them to the Standard files

      IF (flags%writel3dzDes) THEN
         CALL OutputL3DZ(cfDef%stdType, dzd, sFiles)
      ELSE
         msr = TRIM(l3cf%l3prodNameD) // 'Descending DZ' // NOOUT_ERR
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
      ENDIF

d284 3
a286 4
!------------------------------------------------------------------------------
   SUBROUTINE OutputAndClose (cf, pcf, cfProd, cfDef, avgPer, anText, sFiles, &
                              dFiles)
!------------------------------------------------------------------------------
a292 4
      TYPE( L3CFDef_T ), INTENT(IN) :: cfDef

      TYPE( OutputFiles_T ), INTENT(IN) :: dFiles, sFiles

a312 16
! Write the metadata to any L3DZ files created

      IF (sFiles%nFiles == 0) THEN
         CALL MLSMessage(MLSMSG_Warning, ModuleName, 'No L3DZ Standard files &
                                                               &were created.')
      ELSE
         CALL WriteMetaL3DZ(pcf, cfDef%stdMCFnum, sFiles, anText)
      ENDIF

      IF (dFiles%nFiles == 0) THEN
         CALL MLSMessage(MLSMSG_Warning, ModuleName, 'No L3DZ Diagnostic &
                                                              &files were created.')
      ELSE
         CALL WriteMetaL3DZ(pcf, cfDef%dgMCFnum, dFiles, anText)
      ENDIF

d340 3
@


1.11
log
@Added ONLY to USE L2GPData statement.
@
text
@d31 1
a31 1
   "$Id: OutputClose.f90,v 1.10 2001/04/11 18:51:38 nakamura Exp $"
d153 1
a153 1
                          l3r, residA, residD, dzs, dzA, dzD, flags, zFiles)
d179 1
a179 1
      TYPE( L3DZFiles_T ), INTENT(INOUT) :: zFiles
d187 1
a187 1
      TYPE( L3DMFiles_T ) :: files
d290 1
a290 1
! L3DZ -- if data exist, write them to the l3dz Standard file; keep track of
d294 1
a294 1
         CALL OutputL3DZ(cfDef%stdType, dzs, zFiles)
d300 1
a300 1
! If ascending map data for the product exist, write them to l3dm files
d303 1
a303 1
         CALL OutputL3DZ(cfDef%stdType, dza, zFiles)
d309 1
a309 1
! If descending map data for the product exist, write them to l3dm files
d312 1
a312 1
         CALL OutputL3DZ(cfDef%stdType, dzd, zFiles)
d322 4
a325 3
!----------------------------------------------------------------------------
   SUBROUTINE OutputAndClose (cf, pcf, cfProd, cfDef, avgPer, anText, zFiles)
!----------------------------------------------------------------------------
d334 1
a334 1
      TYPE( L3DZFiles_T ), INTENT(IN) :: zFiles
d358 1
a358 1
      IF (zFiles%nStd == 0) THEN
d362 1
a362 1
         CALL WriteMetaL3DZS(pcf, cfDef, zFiles, anText)
d365 1
a365 1
      IF (zFiles%nDg == 0) THEN
d367 1
a367 1
                                                         &files were created.')
d369 1
a369 1
         CALL WriteMetaL3DZD(pcf, cfDef, zFiles, anText)
d399 3
@


1.10
log
@Moved deallocations for pointers passed between CORE & I/O up to main program.
@
text
@d9 1
a9 1
   USE L2GPData
d31 1
a31 1
   "$Id: OutputClose.f90,v 1.9 2001/03/27 19:36:43 nakamura Exp $"
d398 3
@


1.9
log
@Moved a parameter to MLSL3Common; updated metadata.
@
text
@d31 1
a31 1
   "$Id: OutputClose.f90,v 1.8 2001/03/07 21:28:41 nakamura Exp $"
a317 16
! Deallocate the databases

!     CALL DestroyL2GPDatabase(l3r)
!     CALL DestroyL2GPDatabase(residA)
!     CALL DestroyL2GPDatabase(residD)

!     CALL DestroyL3DMDatabase(l3dm)
!     CALL DestroyL3DMDatabase(dmA)
!     CALL DestroyL3DMDatabase(dmD)

!     CALL DestroyL3SPDatabase(l3sp)

!     CALL DestroyL3DZDatabase(dzs)
!     CALL DestroyL3DZDatabase(dza)
!     CALL DestroyL3DZDatabase(dzd)

d398 3
@


1.8
log
@Commented out database deallocations.
@
text
@d31 1
a31 1
   "$Id: OutputClose.f90,v 1.7 2001/02/21 21:16:31 nakamura Exp $"
a46 3
   CHARACTER (LEN=*), PARAMETER :: NOOUT_ERR = ' data expected but not found &
                                                &for output.'

d111 1
a111 2
      CALL ExpandFileTemplate('$version-$cycle', sval, &
                              version=pcf%outputVersion, cycle=pcf%cycle)
d414 3
@


1.7
log
@Changed MLSPCF to MLSPCF3; added L3DZ stuff; changed log LocalGranuleID; renamed/split OutputAndClose tasks.
@
text
@d31 1
a31 1
   "$Id: OutputClose.f90,v 1.13 2001/02/20 20:52:34 nakamura Exp nakamura $"
d324 13
a336 13
      CALL DestroyL2GPDatabase(l3r)
      CALL DestroyL2GPDatabase(residA)
      CALL DestroyL2GPDatabase(residD)

      CALL DestroyL3DMDatabase(l3dm)
      CALL DestroyL3DMDatabase(dmA)
      CALL DestroyL3DMDatabase(dmD)

      CALL DestroyL3SPDatabase(l3sp)

      CALL DestroyL3DZDatabase(dzs)
      CALL DestroyL3DZDatabase(dza)
      CALL DestroyL3DZDatabase(dzd)
d418 3
@


1.6
log
@Updated for new MCFs and annotation.
@
text
@d13 1
d15 1
d19 1
a19 1
   USE MLSPCF
d31 1
a31 1
   "$Id: OutputClose.f90,v 1.5 2000/12/29 21:44:16 nakamura Exp $"
d39 1
d61 3
d71 3
a73 3
!----------------------------------------
   SUBROUTINE WriteMetaLog (pcf, logType)
!----------------------------------------
a81 2
      CHARACTER (LEN=*), INTENT(IN) :: logType

a110 1
      sval = TRIM(logType) // pcf%l3StartDay // ':' // pcf%l3EndDay
d112 1
a112 1
                                 sval)
d155 4
a158 4
!----------------------------------------------------------------------------
   SUBROUTINE OutputAndClose (pcf, l3cf, anText, l3sp, l3dm, dmA, dmD, l3r, &
                              residA, residD, flags)
!----------------------------------------------------------------------------
d167 2
d177 2
d183 2
d224 1
d294 28
d334 75
d418 3
@


1.5
log
@Removed obsolete routines CheckOutputDate & FindDatabaseIndex; switched to one-product/all-days paradigm.
@
text
@d29 1
a29 1
   "$Id: OutputClose.f90,v 1.9 2000/12/29 19:18:21 nakamura Exp nakamura $"
d65 3
a67 3
!-------------------------------
   SUBROUTINE WriteMetaLog (pcf)
!-------------------------------
d76 2
d90 1
a90 1
      CHARACTER (LEN=21) :: sval
d107 1
d109 1
a109 1
                                 pcf%logGranID)
d111 2
d114 1
a114 1
                                 pcf%outputVersion)
d152 4
a155 4
!-----------------------------------------------------------------------
   SUBROUTINE OutputAndClose (l3cf, l3sp, l3dm, dmA, dmD, l3r, residA, &
                              residD, flags)
!-----------------------------------------------------------------------
d162 2
d174 2
d190 1
a190 1
         CALL OutputL3SP (l3cf, l3sp)
d280 1
a280 1
         CALL WriteMetaL3DM(files, l3cf%mcf)
d305 3
@


1.4
log
@Changed search/bypass PCF logic, so that the SearchPCFNames subroutine always returns a file name with a path.
@
text
@d9 5
d15 1
a15 1
   USE SDPToolkit
d17 1
a17 2
   USE L3DMData
   USE L3CF
a18 1
   USE MLSPCF
a19 1
   USE MLSCF
d21 1
d29 1
a29 1
   "$Id: OutputClose.f90,v 1.3 2000/12/07 19:40:37 nakamura Exp $"
d35 2
a36 3
! Subroutines -- CheckOutputDate
!                FindDatabaseIndex
!                WriteMetaLog
d45 1
a45 1
                                               &for output.'
d47 2
a48 1
CONTAINS
d50 1
a50 3
!---------------------------------------------
   SUBROUTINE CheckOutputDate (dataTAI, timeA)
!---------------------------------------------
d52 2
a53 3
! Brief description of subroutine
! This subroutine checks the dates within a database for consistency and
! returns the last date/time in CCSDS A format.
d55 2
a56 1
! Arguments
d58 2
a59 1
      REAL(r8), INTENT(IN) :: dataTAI(:)
d61 1
a61 1
      CHARACTER (LEN=CCSDS_LEN), INTENT(OUT) :: timeA
d63 1
a63 109
! Parameters

! Functions

! Variables

      CHARACTER (LEN=CCSDS_LEN) :: cmpTime

      INTEGER :: i, returnStatus

! Check that dates within the l3dm database are consistent

      returnStatus = Pgs_td_taiToUTC(dataTAI(1), cmpTime)
      IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
                                                         ModuleName, TAI2A_ERR)

      DO i = 2, SIZE(dataTAI)

         returnStatus = Pgs_td_taiToUTC(dataTAI(i), timeA)
         IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
                                                     ModuleName, TAI2A_ERR)

         IF (timeA(1:10) /= cmpTime(1:10)) CALL MLSMessage(MLSMSG_Error, &
                  ModuleName,'Inconsistent dates within the output database.')

      ENDDO

!--------------------------------
   END SUBROUTINE CheckOutputDate
!--------------------------------

!-----------------------------------------------------------
   SUBROUTINE FindDatabaseIndex (l3dm, l3cf, indx, numGrids)
!-----------------------------------------------------------

! Brief description of subroutine
! This subroutine checks for the existence of data in the database and returns
! the number of structures found, and their database indices.

! Arguments

      TYPE( L3DMData_T ), INTENT(IN) :: l3dm(:)

      TYPE( L3CFProd_T ), INTENT(IN) :: l3cf

      INTEGER, INTENT(OUT) :: indx(:)

      INTEGER, INTENT(OUT) :: numGrids

! Parameters

! Functions

! Variables

      CHARACTER (LEN=480) :: msr

      INTEGER :: i, idm

! Loop through all possible grids for the product

      DO i = 1, l3cf%nGrids

! Check for a corresponding name in the l3dm database

         idm = LinearSearchStringArray( l3dm%name,TRIM(l3cf%quantities(i)) )

! If some grid is missing, check the processing mode requested, and issue a
! message, if necessary

         IF (idm == 0) THEN
 
            IF ( INDEX(l3cf%quantities(i),'Ascending') /= 0 ) THEN

               IF ( (l3cf%mode == 'asc') .OR. (l3cf%mode == 'all') ) THEN
                  msr = 'Ascending ' // TRIM(l3cf%l3prodNameD) // NOOUT_ERR
                  CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
               ENDIF

            ELSE IF ( INDEX(l3cf%quantities(i),'Descending') /= 0 ) THEN

                 IF ( (l3cf%mode == 'des') .OR. (l3cf%mode == 'all') ) THEN
                    msr = 'Descending ' // TRIM(l3cf%l3prodNameD) // NOOUT_ERR
                    CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
                 ENDIF

            ELSE IF ( l3cf%quantities(i) == l3cf%l3prodNameD ) THEN

                 IF ( (l3cf%mode == 'com') .OR. (l3cf%mode == 'all') ) THEN
                    msr = TRIM(l3cf%l3prodNameD) // NOOUT_ERR
                    CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
                 ENDIF

            ENDIF

         ELSE

! Calculate the number of grids found; save their indices

            numGrids = numGrids + 1
            indx(numGrids) = idm

         ENDIF

      ENDDO

!----------------------------------
   END SUBROUTINE FindDatabaseIndex
!----------------------------------
d147 4
a150 3
!-------------------------------------------------
   SUBROUTINE OutputAndClose (pcf, cf, l3cf, l3dm)
!-------------------------------------------------
d157 3
a159 1
      TYPE( PCFData_T ), INTENT(IN) :: pcf
d161 1
a161 1
      TYPE( Mlscf_T ), INTENT(INOUT) :: cf
d163 1
a163 1
      TYPE( L3CFProd_T ), POINTER :: l3cf(:)
d165 1
a165 1
      TYPE( L3DMData_T ), POINTER :: l3dm(:)
d171 1
a171 1
      INTEGER, EXTERNAL :: Pgs_td_asciiTime_aToB
d173 1
a173 1
! Variables
d175 1
a175 4
      CHARACTER (LEN=8) :: procDay
      CHARACTER (LEN=CCSDS_LEN) :: dataDT
      CHARACTER (LEN=CCSDSB_LEN) :: timeB
      CHARACTER (LEN=FileNameLen) :: l3File, match
d178 1
a178 3
      INTEGER :: err, i, mlspcf_l3dm, numGrids, numProds
      INTEGER :: returnStatus
      INTEGER :: indx(maxNumGrids)
d180 6
a185 1
! Check that dates within the l3dm database are consistent
d187 1
a187 1
      CALL CheckOutputDate(l3dm%time, dataDT)
d189 2
a190 1
! Convert to CCSDS B format, for comparison to file name
d192 2
a193 3
      returnStatus = Pgs_td_asciiTime_aToB(dataDT,timeB)
      IF (returnStatus /= PGS_S_SUCCESS) CALL MLSMessage(MLSMSG_Error, &
                 ModuleName,'Error converting data time from CCSDS A to B.')
d195 1
a195 1
      procDay = timeB(1:8)
d197 1
a197 1
! Check that date falls within the output data range
d199 1
a199 5
      IF ( LLT(procDay,pcf%l3StartDay) .OR. LGT(procDay,pcf%l3EndDay) ) THEN
         msr = 'Data produced for day ' // procDay // ' is not in the &
                                                      &specified output range.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF
d201 2
a202 1
! For each product in the DailyMap section of the l3cf,
d204 2
a205 1
      numProds = SIZE(l3cf)
d207 8
a214 1
      DO i = 1, numProds
d216 2
a217 2
         numGrids = 0
         indx = 0
d219 8
a226 1
         CALL FindDatabaseIndex(l3dm, l3cf(i), indx, numGrids)
d228 2
a229 1
! If all grids are missing, issue a warning for the product
d231 7
a237 5
         IF (numGrids == 0) THEN
            msr = 'No l3dm data found, no file produced for ' // &
                  l3cf(i)%l3prodNameD
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msr)
            CYCLE
d240 1
a240 1
! Expand any fields in the given output file name
d242 8
a249 26
         CALL ExpandFileTemplate(l3cf(i)%fileTemplate, l3File, 'l3dm', &
                                 pcf%outputVersion, pcf%cycle, procDay)

! Check that the expanded name appears in the PCF. 

         CALL SearchPCFNames(l3File, mlspcf_l3dm_start, mlspcf_l3dm_end, &
                                mlspcf_l3dm, match)

! If no match was found,

         IF (mlspcf_l3dm == -1) THEN

! Check the bypass flag is set.  If set, issue a message to that effect, giving
! the file name to be used

            IF (l3cf(i)%bpFlag == 1) THEN

               msr = 'Bypassing PCF:  using file name ' // match
               CALL MLSMessage(MLSMSG_Info, ModuleName, msr)

            ELSE

! If not set, exit with an error.

               msr = 'No match in the PCF for file ' // l3File
               CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
d251 6
a257 1
     
d260 8
a267 3
! Create & write to structures in the file

         CALL OutputGrids(match, numGrids, indx, l3dm)
d271 1
a271 1
         CALL WriteMetaL3DM(match, l3cf(i)%mcf, numGrids, indx, l3dm, dataDT)
d273 1
a273 3
      ENDDO

! Write the log file metadata
d275 1
a275 1
      CALL WriteMetaLog(pcf)
d277 3
a279 1
! Deallocate the l3dm database
d282 2
d285 1
a285 11
! Deallocate the l3cf pointer

      DEALLOCATE(l3cf, STAT=err)
      IF ( err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                               &deallocation of l3dm input data structures.')

! Deallocate the section pointer of the CF structure

      DEALLOCATE (cf%Sections, STAT=err)
      IF ( err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed to &
                                         &deallocate l3cf section pointers.')
d296 3
@


1.3
log
@Updated for modified ExpandFileTemplate.
@
text
@d26 1
a26 1
   "$Id: OutputClose.f90,v 1.2 2000/10/24 19:36:56 nakamura Exp $"
d281 1
a281 1
      CHARACTER (LEN=FileNameLen) :: l3File
d284 1
a284 1
      INTEGER :: err, i, match, mlspcf_l3dm, numGrids, numProds
d333 1
a333 2
! If the bypass flag is set, issue a message to that effect, giving the file
! name to be used
d335 9
a343 1
         IF (l3cf(i)%bpFlag == 1) THEN
d345 1
a345 2
            msr = 'Bypassing PCF:  using file name ' // l3File
            CALL MLSMessage(MLSMSG_Info, ModuleName, msr)
d347 4
a350 1
         ELSE
d352 1
a352 2
! If not, check that the expanded name appears in the PCF.  Exit with an error,
! if the required name has no PCF entry
a353 3
            CALL SearchPCFNames(l3File, mlspcf_l3dm_start, mlspcf_l3dm_end, &
                                mlspcf_l3dm, match)
            IF (TRIM(match) == 'NONE') THEN
d356 1
d400 3
@


1.2
log
@Updated WriteMetaLog for new MCF; moved search for PCF number of MCF to L3CF module.
@
text
@d26 1
a26 1
   "$Id: OutputClose.f90,v 1.3 2000/10/17 19:54:29 nakamura Exp nakamura $"
d330 1
a330 1
         CALL ExpandFileTemplate(l3cf(i)%fileTemplate, l3File, &
d348 1
a348 1
            IF (match == 0) THEN
d357 1
a357 1
         CALL OutputGrids(l3File, numGrids, indx, l3dm)
d361 1
a361 1
         CALL WriteMetaL3DM(l3File, l3cf(i)%mcf, numGrids, indx, l3dm, dataDT)
d394 3
@


1.1
log
@Module for the Output/Close task.
@
text
@d171 3
a173 3
!--------------------------------
   SUBROUTINE WriteMetaLog (date)
!--------------------------------
d180 1
a180 1
      CHARACTER (LEN=*), INTENT(IN) :: date
a200 2
      REAL(r8) :: dval

d211 5
a215 3
      sval = 'Horizontal & Vertical'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), &
                                 "GranuleSpatialDomainType", sval)
d218 1
a218 1
                                 "RangeBeginningDate", date)
d223 1
a223 1
                                 "RangeEndingDate", date)
d228 2
a229 16
      sval = 'Other Grid System'
      result = pgs_met_setAttr_s(groups(INVENTORYMETADATA), "ZoneIdentifier", &
                                 sval)

      dval = -180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "WestBoundingCoordinate", dval)
      dval = 90.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "NorthBoundingCoordinate", dval)
      dval = 180.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "EastBoundingCoordinate", dval)
      dval = -90.0
      result = pgs_met_setAttr_d(groups(INVENTORYMETADATA), &
                                "SouthBoundingCoordinate", dval)
d284 1
a284 1
      INTEGER :: err, i, match, mlspcf_l3dm, mlspcf_mcf, numGrids, numProds
a358 9
! Find the PCF number of the MCF

         CALL SearchPCFNames(l3cf(i)%mcf, mlspcf_l3dm_mcf_start, &
                             mlspcf_l3dm_mcf_end, mlspcf_mcf, match)
         IF (match == 0) THEN
            msr = 'No match in the PCF for file ' // l3cf(i)%mcf
            CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
         ENDIF

d361 1
a361 1
         CALL WriteMetaL3DM(l3File, mlspcf_mcf, numGrids, indx, l3dm, dataDT)
d367 1
a367 1
      CALL WriteMetaLog(dataDT(1:10))
d393 4
a396 1
!$Log: $
@

