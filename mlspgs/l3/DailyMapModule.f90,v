head	1.15;
access;
symbols
	v5-02-NRT-19:1.15
	v6-00:1.15
	v5-02-NRT-18:1.15
	v5-02:1.15
	v5-01-NRT-17:1.15
	v5-01-NRT-16:1.15
	v5-01-NRT-15:1.15
	v5-01-NRT-14:1.15
	neuralnetworks-1-0:1.15.0.14
	cfm-single-freq-0-1:1.15.0.12
	v5-01:1.15
	v5-00:1.15
	v4-23-TA133:1.15.0.10
	mus-emls-1-70:1.15.0.8
	rel-1-0-englocks-work:1.15.0.6
	VUMLS1-00:1.15
	VPL1-00:1.15
	V4-22-NRT-08:1.15
	VAM1-00:1.15
	V4-21:1.15.0.4
	V4-13:1.15
	V4-12:1.15
	V4-11:1.15
	V4-10:1.15
	V3-43:1.15
	M4-00:1.15
	V3-41:1.15
	V3-40-PlusGM57:1.15.0.2
	V2-24-NRT-04:1.15
	V3-33:1.15
	V2-24:1.15
	V3-31:1.15
	V3-30-NRT-05:1.15
	cfm-01-00:1.15
	V3-30:1.15
	V3-20:1.15
	V3-10:1.15
	V2-23-NRT-02:1.15
	V2-23:1.15
	V2-22-NRT-01:1.15
	V2-22:1.15
	V2-21:1.15
	V2-20:1.15
	V2-11:1.15
	V2-10:1.15
	V2-00:1.15
	V1-51:1.13
	V1-50:1.13
	V1-45:1.13
	V1-44:1.13
	V1-43:1.13
	V1-42:1.11
	V1-41:1.11
	V1-32:1.11
	V1-40:1.11
	V1-31:1.11
	V1-30:1.11
	V1-13:1.9
	V1-12:1.9
	V1-11:1.9
	V1-10:1.9
	newfwm-feb03:1.9.0.2
	V1-04:1.9
	V1-03:1.9
	V1-02:1.9
	V1-00:1.9
	newfwm-sep01:1.8.0.2
	V0-7:1.8
	V0-5-Level2:1.5
	V0-5-SIPS:1.5;
locks; strict;
comment	@# @;


1.15
date	2006.02.28.17.56.56;	author cvuu;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.23.19.07.38;	author pwagner;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.02.20.07.52;	author ybj;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.13.20.18.52;	author ybj;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.30.21.44.32;	author pwagner;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.22.03.42.55;	author jdone;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.20.21.18.13;	author ybj;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.17.20.27.51;	author nakamura;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.14.16.13.24;	author nakamura;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.13.16.42.06;	author ybj;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.13.22.07.05;	author ybj;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.11.18.29.30;	author ybj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.18.52.41;	author ybj;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.03.01.38.12;	author ybj;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.27.20.52.39;	author ybj;	state Exp;
branches;
next	;


desc
@@


1.15
log
@V2.00 commit
@
text
@
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

!==============================================================================
Module DailyMapModule
!==============================================================================
	
  USE MLSCommon, ONLY: r8 
  USE L3SPData, ONLY: L3SPData_T
  USE global_data
  USE SDPToolkit, ONLY: PI
  USE MLSMessageModule, ONLY: MLSMessage, MLSMSG_Error, & 
       & MLSMSG_DEALLOCATE, MLSMSG_ALLOCATE
  Implicit None
  private
  PUBLIC :: Init, ClearMemory, CordTransform, FindAD, &
    & FFSM_Opt, FFSM, FFSMA, FFSMD, Reconstruct, Diagnostics, DataGenerate, &
    & DataGeneratePrec, CopyPrec2Data
  
  PRIVATE :: ID, ModuleName

  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       
       "$Id: DailyMapModule.f90,v 1.13 2004/06/02 20:07:52 ybj Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: DailyMapModule.f90,v $"
  !----------------------------------------------------------

  ! Contents:

  ! Subroutines -- Init 
  !                Loc2RS
  !                CordTransform
  !                findad
  !                FFSM
  !                Reconstruct
  !                Diagnostics
  !                DataGenerate
  !                DataGeneratePrec
  !                CopyPrec2Data
  ! Function -- 
  
  ! Remarks:  This is a module for the main Core processing.

  ! Parameters

  integer FFTW_FORWARD,FFTW_BACKWARD
  parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)
  
  integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
  parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)
  
  integer FFTW_ESTIMATE,FFTW_MEASURE
  parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)
  
  integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
  parameter (FFTW_OUT_OF_PLACE=0)
  parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)
  
  integer FFTW_THREADSAFE
  parameter (FFTW_THREADSAFE=128)
  
  !     Constants for the MPI wrappers:
  integer FFTW_TRANSPOSED_ORDER, FFTW_NORMAL_ORDER
  integer FFTW_SCRAMBLED_INPUT, FFTW_SCRAMBLED_OUTPUT
  parameter(FFTW_TRANSPOSED_ORDER=1, FFTW_NORMAL_ORDER=0)
  parameter(FFTW_SCRAMBLED_INPUT=8192)
  parameter(FFTW_SCRAMBLED_OUTPUT=16384)
  
  Save

Contains

  ! /---------------------------------------------------------------\
  ! |*** Initilization
  ! \---------------------------------------------------------------/
  
  Subroutine Init(nt_a_i, nt_d_i, tau0_i, delTad_i, 	&
       & c0_i, lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i)
    
    ! Arguments

!    CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
    
    CHARACTER (LEN=480) :: msr

    REAL (r8) :: lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i, delTad_i, & 
         lonD0_i_temp, lonA0_i_temp
    REAL :: c0_i, tau0_i
          
    INTEGER :: nt_a_i, nt_d_i, err
    
    lat	 = lat_i
    nt_a = nt_a_i
    nt_d = nt_d_i
    
    if(nt_a > nt_d) then
       nt = nt_d
    else
       nt = nt_a
    end if
    
    nt_a = nt
    nt_d = nt
    
    c0 	 = c0_i
    tau0 = tau0_i 
    
    sina = 1.0/sqrt(1.0+c0*c0)
    cosa = c0/sqrt(1.0+c0*c0)
    ds   = tau0/sina

    krmax = 1.0/sina
    !! jpd
    if (abs(ds*cosa).gt.0.000001) then 
       nwave = PI/(ds*cosa)
    else
       nwave = 100000
    endif
    !! jpd
    dtad = delTad_i 

    if(lonD0_i < 0) then
       lonD0_i_temp = 2.0*PI+lonD0_i
    else 
       lonD0_i_temp = lonD0_i
    end if
    if(lonA0_i < 0) then
       lonA0_i_temp = 2.0*PI+lonA0_i
    else 	
       lonA0_i_temp = lonA0_i
    end if
    
    dlonad    = abs( lonD0_i-lonA0_i)
    if(lonD0_i < 0 .and. lonA0_i > 0 .or. lonD0_i > 0 .and. lonA0_i < 0) then
       dlonad    = abs( lonD0_i-lonA0_i)
    else if(lonD0_i < 0 .and. lonA0_i < 0 ) then
       dlonad    = abs( lonD0_i-lonA0_i)
    else
       dlonad    = abs( lonD0_i+lonA0_i)
    end if
    
    if(lonA0_i_temp < lonD0_i_temp) then
       dlonad  = abs( lonD0_i_temp-lonA0_i_temp )
    else 
       dlonad  = 2.0*PI-abs( lonD0_i_temp-lonA0_i_temp )
    end if
    
    d1lonad   = dlonad + c0*dtad
    
    lonD0   = lonD0_i
    tD0     = tD0_i
    lonA0   = lonA0_i
    tA0     = tA0_i
    
    !open(1, file="para.dat", status="new")
    !write(1,*) nt, tA0, tD0, lonD0, lonA0, dlonad, dtad, ds,  tau0

    !	  if(mode == 'com') then
    Allocate(lonD(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' lonD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(tD(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' tD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(sD(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' sD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(rD(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' rD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(lonA(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' lonA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(tA(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' tA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(sA(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' sA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(rA(nt), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' rA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(Dscend(nt_d), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' Dscend array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(Ascend(nt_a), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' Ascend array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(DPrec(nt_d), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' DPrec array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(APrec(nt_a), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' APrec array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(wn(nt*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' wn array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(sigma(nt*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' sigma array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(wna(nt_a*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' wna array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(sigmaa(nt_a*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' sigmaa array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(wnd(nt_d*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' wnd array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(sigmad(nt_d*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' sigmad array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(phikr(nt*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' phikr array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(phikra(nt_a*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' phikra array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    Allocate(phikrd(nt_d*2), STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Allocate // ' phikrd array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    !          else if(mode == 'asc') then
    !	    Allocate(lonDA(nt), tDA(nt), sDA(nt), rDA(nt))
    !	    Allocate(DAcend(nt))
    !	    Allocate(wn(nt*2), sigma(nt*2))
    !	    Allocate(phikrda(nt*2))
    !	  end if
  End Subroutine Init

  ! /---------------------------------------------------------------\
  ! |*** Clear Memory
  ! \---------------------------------------------------------------/

  Subroutine ClearMemory()

    CHARACTER (LEN=480) :: msr
    
    INTEGER :: err

      DeAllocate(lonD, STAT=err)
      IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' lonD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

    DeAllocate(tD, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' tD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(sD, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' sD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(rD, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' rD array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(lonA, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' lonA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(tA, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' tA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(sA, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' sA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(rA, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' rA array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(Dscend, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' Dscend array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(Ascend, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' Ascend array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(DPrec, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' DPrec array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(APrec, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' APrec array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(wn, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' wn array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(sigma, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' sigma array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(wna, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' wna array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(sigmaa, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' sigmaa array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(wnd, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' wnd array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(sigmad, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' sigmad array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(phikr, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' phikr array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(phikra, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' phikra array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF

    DeAllocate(phikrd, STAT=err)
    IF ( err /= 0 ) THEN
       msr = MLSMSG_Deallocate // ' phikrd array.'
       CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
    ENDIF
    
  End Subroutine ClearMemory
  
  ! /---------------------------------------------------------------\
  ! |*** Coordinate transformation
  ! \---------------------------------------------------------------/
  
  Subroutine CordTransform(mode)
    
    ! Arguments
    
    CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
    
    ! Variables
    
    Integer :: i
    
    if(mode == 'com') then
       sD0 = lonD0*cosa - tD0*sina - tau0*(nt-1.0)/sina
       sA0 = sD0 + (-dlonad*c0 + dtad)*sina
       rD0 = (lonD0 + c0*tD0)*sina
       rA0 = (lonD0 - dlonad + c0*tD0 - c0*dtad)*sina
    else if(mode == 'asc') then
       sA0 = lonA0*cosa - tA0*sina - tau0*(nt-1.0)/sina
       rA0 = (lonA0 + c0*tA0)*sina
    else if(mode == 'des') then
       sD0 = lonD0*cosa - tD0*sina - tau0*(nt-1.0)/sina
       rD0 = (lonD0 + c0*tD0)*sina
    end if
    
    if(mode == 'com') then
       Do i = 1, nt
          rD(i) = rD0
          rA(i) = rA0
          sD(i) = sD0 + i*tau0/sina
          sA(i) = sA0 + i*tau0/sina
       End Do
    else if(mode == 'asc') then
       Do i = 1, nt
          rA(i) = rA0
          sA(i) = sA0 + i*tau0/sina
       End Do
    else if(mode == 'des') then
       Do i = 1, nt
          rD(i) = rD0
          sD(i) = sD0 + i*tau0/sina
       End Do
    end if
    
  End Subroutine CordTransform
  
  
  ! /---------------------------------------------------------------\
  ! |*** findad 
  ! \---------------------------------------------------------------/
  
  Subroutine FindAD(sina, cosa, t, r0, ep, em, frp, frm, rpi, rmi)
    
    ! Arguments
    
    Real :: sina, cosa, t, r0, ep, em, frp, frm, rpi, rmi
    
    ! Variables
    
    Real :: e, r, s
    Integer :: inc
    
    e = ep
    
    r = e*sina + t*cosa
    s = e*cosa - t*sina
    
    if (abs(r-r0) >= 1.e-6) then 
       
       if ( r > r0 ) then 
          inc = -1
          ep = e
       else 
          inc = 1
          em = e
       end if
       
       e = e + inc*2.0*PI
       r = e*sina + t*cosa
       
       if ( inc < 0) then 
          do
             if (r <= r0) exit
             ep = e
             e  = e + inc*2.0*PI
             r = e*sina + t*cosa
          end do
          em = e
       endif
       
       if ( inc > 0) then 
          do
             if (r >= r0) exit
             em = e
             e  = e + inc*2.0*PI
             r = e*sina + t*cosa
          end do
          ep = e
       endif
       
       rpi = ep*sina + t*cosa
       rmi = em*sina + t*cosa
       
       if( abs(r0-rpi) <= 1.e-8 .and. abs(r0-rmi) <= 1.e-8) then 
          frm = 1.0
          frp = 0.0
       else 
          frm = (r0-rpi)**2/((r0-rpi)**2+(r0-rmi)**2)
          frp = (r0-rmi)**2/((r0-rpi)**2+(r0-rmi)**2)
       end if
       
    else 
       frm = 1.0
       frp = 0.0
       rpi = ep*sina + t*cosa
       rmi = em*sina + t*cosa
    end if
    
  End Subroutine findad
  
  ! /---------------------------------------------------------------\
  ! |*** FFSM_Opt --- FFSM Mode Passing Routine
  ! \---------------------------------------------------------------/
  
  Subroutine FFSM_Opt(mode, l3sp, iLv, iLt)
    
    ! Variables
    
    CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
    TYPE( L3SPData_T ), POINTER :: l3sp(:)
    
    integer iLv, iLt
    
    
    if(mode == 'com') then
       CALL FFSM(l3sp(1), iLv, iLt)
    else if(mode == 'asc') then
       CALL FFSMA(l3sp(1), iLv, iLt)
    else if(mode == 'des') then
       CALL FFSMD(l3sp(1), iLv, iLt)
    else if(mode == 'all') then
       CALL FFSM(l3sp(1), iLv, iLt)
       CALL FFSMA(l3sp(2), iLv, iLt)
       CALL FFSMD(l3sp(3), iLv, iLt)
    end if
    
  End Subroutine FFSM_Opt
  
  ! /---------------------------------------------------------------\
  ! |*** FFSM --- combined mode
  ! \---------------------------------------------------------------/
  
  Subroutine FFSM(l3sp, iLv, iLt)
    
    ! Variables
    
    TYPE( L3SPData_T ) :: l3sp
    !TYPE( L3SPData_T ), POINTER :: l3sp
    
    double complex phia, phid
    
    REAL(r8), Dimension((nt+1)/2) :: imgPtemp
    REAL(r8), Dimension(nt) :: & 
         & dscend_fft, ascend_fft, drealP, dimgP, arealP, aimgP 
    
    real :: ks, kr, expa, expd, krmax_g
    
    INTEGER :: plan, m, m1, i, j, flag, iLv, iLt, wIndex
    
    ! Fourier Transform of both descending & ascending series
    
    call rfftw_f77_create_plan(plan,nt,FFTW_FORWARD,FFTW_ESTIMATE)
    call rfftw_f77_one(plan,ascend,ascend_fft)
    call rfftw_f77_one(plan,dscend,dscend_fft)
    call rfftw_f77_destroy_plan(plan)
    
    ! Ascending Part
    
    Do i = nt/2, nt
       arealP(i) = ascend_fft(i+1-nt/2)/float(nt)
    End Do
    Do i = 1, nt/2-1
       arealP(i) = ascend_fft(nt/2-i+1)/float(nt)
    End Do
    
    Do i = 1, (nt+1)/2-1
       imgPTemp(i) = ascend_fft(nt+1-i)/float(nt)
    End Do
    
    IF (mod(nt, 2) == 0) THEN
       imgPTemp((nt+1)/2) = 0.0
    ENDIF
    
    aimgP(nt/2) = 0.0 
    Do i = nt/2+1, nt-1
       aimgP(i) = imgPtemp(i-nt/2)
    End Do
    Do i = 1, nt/2-1
       aimgP(i) = -imgPtemp(nt/2-i)
    End Do
    aimgP(nt) = 0.0
    
    ! Dscending Part
    
    Do i = 1, (nt+1)/2
       imgPTemp(i) = 0.0 
    End Do
    
    Do i = nt/2, nt
       drealP(i) = dscend_fft(i+1-nt/2)/float(nt)
    End Do
    Do i = 1, nt/2-1
       drealP(i) = dscend_fft(nt/2-i+1)/float(nt)
    End Do
    
    Do i = 1, (nt+1)/2-1
       imgPTemp(i) = dscend_fft(nt+1-i)/float(nt)
    End Do
    
    IF (mod(nt, 2) == 0) THEN
       imgPTemp((nt+1)/2) = 0.0
    ENDIF
    
    dimgP(nt/2) = 0.0 
    Do i = nt/2+1, nt-1
       dimgP(i) = imgPtemp(i-nt/2)
    End Do
    Do i = 1, nt/2-1
       dimgP(i) = -imgPtemp(nt/2-i)
    End Do
    dimgP(nt) = 0.0
    
    mtotal = 0
    
    krmax_g = krmax

    Do m = 1, nwave + 1
       m1 = m-1
       Do i = 1, nt
          
          mtotal = mtotal + 1
          
          wn(mtotal) = float(m1)
          
          if (abs(float(nt)*ds).gt.0.00001) ks = 2.*PI*(-nt/2+i)/(float(nt)*ds)
          !ks = 2.*PI*(-nt/2+i)/(float(nt)*ds)
          if (abs(sina) .gt.0.00001) kr = -ks*c0+float(m1)/sina
          !kr = -ks*c0+float(m1)/sina
          
          sigma(mtotal) = -ks*sina + kr*cosa
          
          if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
             flag = 0
             phikr(mtotal) = CMPLX(0.0, 0.0)
             Goto 101
          endif
          
          expa = ks*sa0 + kr*ra0
          expd = ks*sd0 + kr*rd0
          
          flag = 0
          
          phia   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expa), -sin(expa))
          phid   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expd), -sin(expd))
          
          phikr(mtotal) = & 
               & (phia-phid*CMPLX(cos(d1lonad), -sin(d1lonad)))/& 
               & (1.0-CMPLX(cos(d1lonad), -sin(d1lonad)))

          if( phikr(mtotal) /= CMPLX(0.0, 0.0) ) flag = 1
          
          
101       continue 
          
          ! *** kr+
          
          if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
             if (flag == 0 .and. mtotal > 0) mtotal = mtotal-1
             Goto 102
          endif
          
          kr  = -ks*c0+float(m1-1)/sina
          
          expa = ks*sa0 + kr*ra0
          expd = ks*sd0 + kr*rd0
          
          phia   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expa), -sin(expa))
          phid   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expd), -sin(expd))
          
          phikr(mtotal) = & 
               (phid-phia)*CMPLX( cos(rd0/sina), -sin(rd0/sina) )/& 
               (1.0-CMPLX( cos(d1lonad), -sin(d1lonad) ))
          
102       continue 
          
       End Do
    End Do

    !open(99, file="spec.dat", status="old")
 
    !write(99, *) ds
    !write(99, *) c0
    !write(99, *) sina
    !write(99, *) cosa

    do j = 1, mtotal
       l3sp%waveNumber(iLv, iLt, j) =  int(wn(j))
       l3sp%frequency(iLv, iLt, j) = sigma(j)
       l3sp%l3spRelValue(iLv, iLt, j) = real(phikr(j))
       l3sp%l3spRelPrecision(iLv, iLt, j) = real(phikr(j))
       l3sp%l3spImgValue(iLv, iLt, j) = aimag(phikr(j))
       l3sp%l3spImgPrecision(iLv, iLt, j) = aimag(phikr(j))
       !write(99,*)  j, int(wn(j)), sigma(j), real(phikr(j)), aimag(phikr(j))
    end do
    
    !close(99)
    
  End Subroutine FFSM

  ! /---------------------------------------------------------------\
  ! |*** FFSMA --- single mode / ascending
  ! \---------------------------------------------------------------/
  
  Subroutine FFSMA(l3sp, iLv, iLt)
    
    Implicit None

    ! Variables
    
    !TYPE( L3SPData_T ), POINTER :: l3sp
    TYPE( L3SPData_T ) :: l3sp
    
    double complex phida

    REAL(r8), Dimension((nt_a+1)/2) :: imgPtemp
    REAL(r8), Dimension(nt_a) :: ascend_fft, arealP, aimgP
    
    REAL :: ks, kr, expda, krmax_g
    
    INTEGER :: plan, m, m1, i, j, flag, iLv, iLt, wIndex
    
    ! Fourier Transform of one series
    
    call rfftw_f77_create_plan(plan,nt_a,FFTW_FORWARD,FFTW_ESTIMATE)
    call rfftw_f77_one(plan,ascend,ascend_fft)
    call rfftw_f77_destroy_plan(plan)

    ! re-order the fft transform result

    Do i = 1, (nt_a+1)/2
       imgPTemp(i) = 0.0 
    End Do
    
    Do i = nt_a/2, nt_a
       arealP(i) = ascend_fft(i+1-nt_a/2)/float(nt_a)
    End Do
    Do i = 1, nt_a/2-1
       arealP(i) = ascend_fft(nt_a/2-i+1)/float(nt_a)
    End Do
    
    Do i = 1, (nt_a+1)/2-1
       imgPTemp(i) = ascend_fft(nt_a+1-i)/float(nt_a)
    End Do
    
    IF (mod(nt_a, 2) == 0) THEN
       imgPTemp((nt_a+1)/2) = 0.0
    ENDIF
    
    aimgP(nt_a/2) = 0.0 
    Do i = nt_a/2+1, nt_a
       aimgP(i) = imgPtemp(i-nt_a/2)
    End Do
    Do i = 1, nt_a/2-1
       aimgP(i) = -imgPtemp(nt_a/2-i)
    End Do
    
    mtotala = 0
    
    krmax_g = krmax/2.0
    
    Do m = 1, nwave + 1 
       m1 = m-1
       Do i = 1, nt_a
          mtotala = mtotala + 1
          
          wna(mtotala) = float(m1)
          
          !! floating point error

          if (abs(float(nt_a)*ds) .gt. 0.0000001) ks = 2.0*PI*(-nt_a/2+i)/(float(nt_a)*ds)
               !ks = 2.0*PI*(-nt_a/2+i)/(float(nt_a)*ds)
          if (abs(sina) .gt. 0.0000001) kr = -ks*c0+float(m1)/sina
          !kr = -ks*c0+float(m1)/sina
          
          !! floating point error

          sigmaa(mtotala) = -ks*sina + kr*cosa
          
          if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
             flag = 0
             Goto 101
          endif
          
          expda = ks*sa0 + kr*ra0
          
          flag = 0
          
          phida   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expda), -sin(expda))
          
          phikra(mtotala) = phida 
          
 
          if( phikra(mtotala) /= CMPLX(0.0, 0.0) ) flag = 1
          
          
101       continue 
          
          ! *** kr+
          
          if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
             if (flag == 0 .and. mtotala > 0) mtotala = mtotala-1
             Goto 102
          endif
          
          kr  = -ks*c0+float(m1)/sina
          
          expda = ks*sa0 + kr*ra0
          
          phida   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expda), -sin(expda))

          phikra(mtotala) = phida 
          
102       continue 
          
       End Do
    End Do
    
    
    do j = 1, mtotala
       l3sp%waveNumber(iLv, iLt, j) = int(wna(j)) 
       l3sp%frequency(iLv, iLt, j) = sigmaa(j)
       l3sp%l3spRelValue(iLv, iLt, j) = real(phikra(j))
       l3sp%l3spRelPrecision(iLv, iLt, j) = real(phikra(j))
       l3sp%l3spImgValue(iLv, iLt, j) = aimag(phikra(j))
       l3sp%l3spImgPrecision(iLv, iLt, j) = aimag(phikra(j))
    end do
    
    
  End Subroutine FFSMA
  
  
  ! /---------------------------------------------------------------\
  ! |*** FFSMD --- single mode / descending
  ! \---------------------------------------------------------------/
  
  Subroutine FFSMD(l3sp, iLv, iLt)

    Implicit None
    
    ! Variables
    
    !TYPE( L3SPData_T ), POINTER :: l3sp
    TYPE( L3SPData_T ) :: l3sp
    
    double complex phida
    
    REAL(r8), Dimension((nt_d+1)/2) :: imgPtemp
    REAL(r8), Dimension(nt_d) :: dscend_fft, drealP, dimgP
    
    REAL :: ks, kr, expda, krmax_g
    
    INTEGER ::  plan, m, m1, i, j, flag, iLv, iLt, wIndex
    
    ! Fourier Transform of one series

    call rfftw_f77_create_plan(plan,nt_d,FFTW_FORWARD,FFTW_ESTIMATE)
    call rfftw_f77_one(plan,dscend,dscend_fft)
    call rfftw_f77_destroy_plan(plan)

    ! re-order the fft transform result

    Do i = 1, (nt_d+1)/2
       imgPTemp(i) = 0.0 
    End Do
    
    Do i = nt_d/2, nt_d
       drealP(i) = dscend_fft(i+1-nt_d/2)/float(nt_d)
    End Do
    Do i = 1, nt_d/2-1
       drealP(i) = dscend_fft(nt_d/2-i+1)/float(nt_d)
    End Do
    
    Do i = 1, (nt_d+1)/2-1
       imgPTemp(i) = dscend_fft(nt_d+1-i)/float(nt_d)
    End Do
    
    IF (mod(nt_d, 2) == 0) THEN
       imgPTemp((nt_d+1)/2) = 0.0
    ENDIF
    
    dimgP(nt_d/2) = 0.0 
    
    Do i = nt_d/2+1, nt_d
       dimgP(i) = imgPtemp(i-nt_d/2)
    End Do
    Do i = 1, nt_d/2-1
       dimgP(i) = -imgPtemp(nt_d/2-i)
    End Do
    
    mtotald = 0
    
    krmax_g = krmax/2.0
    
    Do m = 1, nwave + 1
       m1 = m-1
       Do i = 1, nt_d
          
          mtotald = mtotald + 1
          
          wnd(mtotald) = float(m1)
          !! floating point 
          if (abs(float(nt_d)*ds).gt.0.000001) ks = 2.0*PI*(-nt_d/2+i)/(float(nt_d)*ds)
               !ks = 2.0*PI*(-nt_d/2+i)/(float(nt_d)*ds)
          if (abs(sina).gt.0.000001) kr = -ks*c0+float(m1)/sina
          !kr = -ks*c0+float(m1)/sina
          !! floating point
          sigmad(mtotald) = -ks*sina + kr*cosa

          if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
             flag = 0
             Goto 101
          endif
          
          expda = ks*sd0 + kr*rd0
          
          flag = 0

          phida   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expda), -sin(expda))
          
          phikrd(mtotald) = phida 
          
          
          if( phikrd(mtotald) /= CMPLX(0.0, 0.0) ) flag = 1
          
          
101       continue 
          
          ! *** kr+

          if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
             if (flag == 0 .and. mtotald > 0) mtotald = mtotald-1
             Goto 102
          endif
          
          kr  = -ks*c0+float(m1)/sina
          
          expda = ks*sd0 + kr*rd0
          
          phida   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expda), -sin(expda))
          
          phikrd(mtotald) = phida 
          
102       continue 
          
       End Do
    End Do
    
    
    do j = 1, mtotald
       l3sp%waveNumber(iLv, iLt, j) =  int(wnd(j))
       l3sp%frequency(iLv, iLt, j) = sigmad(j)
       l3sp%l3spRelValue(iLv, iLt, j) = real(phikrd(j))
       l3sp%l3spRelPrecision(iLv, iLt, j) = real(phikrd(j))
       l3sp%l3spImgValue(iLv, iLt, j) = aimag(phikrd(j))
       l3sp%l3spImgPrecision(iLv, iLt, j) = aimag(phikrd(j))
    end do
    
    
  End Subroutine FFSMD

  
  ! /---------------------------------------------------------------\
  ! |*** Reconstruct 
  ! \---------------------------------------------------------------/
  
  Subroutine Reconstruct(mode, xtime, nlons, xlon_orig, result)
    
    ! Arguments
    
    CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
    
    INTEGER :: nlons
    
    REAL :: xtime
    
    REAL(r8), Dimension(nlons) :: xlon, xlon_orig, result

    ! Variables

    REAL :: kr, ks, xloni, eoff, rp, rm, ep, em, sum, & 
         & argpa, argpd, argma, argmd, argp, argm, & 
         & epa, epd, ema, emd, rma, rmd, rpa, rpd , &
         & rdp, ran, rdn, frpa, frma, frpd, frmd, frp, frm, rpi, rmi

    INTEGER :: j, k

    !*** Convert to gradient 
    
    do k = 1, nlons
       xlon(k) = xlon_orig(k)*PI/180.0
    end do
    
    !*** find offset in longitude necessary to get r value right
    
    eoff = c0*xtime - mod( (c0*xtime), real(2.0*PI) )
    if (eoff < 0.0) eoff = 2.0*PI
    
    !*** Loop over longitude
    
    do k = 1, nlons
       
       result(k) = 0.0
       
       xloni = xlon(k) - eoff
       
       if (mode == 'com') then 
          
          !***find r value corresponding to this xlon & xtime
          
          epa = xloni
          ema = xloni
          epd = xloni
          emd = xloni
          
          rdp = xloni*sina + xtime*cosa

          call findad(sina, cosa, xtime, ra0, epa, ema, frpa, frma, rpi, rmi)
          call findad(sina, cosa, xtime, rd0, epd, emd, frpd, frmd, rpi, rmi)

          rpa = epa*sina + xtime*cosa
          rma = ema*sina + xtime*cosa
          rpd = epd*sina + xtime*cosa
          rmd = emd*sina + xtime*cosa
          
          if( (rpa-ra0)**2 >= (rma-ra0)**2 ) ran = (rma-ra0)**2
          if( (rpa-ra0)**2 <  (rma-ra0)**2 ) ran = (rpa-ra0)**2
          
          if( (rpd-rd0)**2 >= (rmd-rd0)**2 ) rdn = (rmd-rd0)**2
          if( (rpd-rd0)**2 <  (rmd-rd0)**2 ) rdn = (rpd-rd0)**2

          frpa = frpa*rdn/(rdn+ran)
          frma = frma*rdn/(rdn+ran)
          frpd = frpd*ran/(rdn+ran)
          frmd = frmd*ran/(rdn+ran)


          do j = 1, mtotal 

             kr     = wn(j)*sina+sigma(j)*cosa
             ks     = wn(j)*cosa-sigma(j)*sina

             argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)/(2.0*PI)
             argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)/(2.0*PI)
             argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)/(2.0*PI)
             argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)/(2.0*PI)
             !argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)
             !argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)
             !argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)
             !argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)
             
             sum =  real( frpa*phikr(j)*CMPLX(cos(argpa), sin(argpa)) ) + &
                  & real( frma*phikr(j)*CMPLX(cos(argma), sin(argma)) ) + &
                  & real( frpd*phikr(j)*CMPLX(cos(argpd), sin(argpd)) ) + &
                  & real( frmd*phikr(j)*CMPLX(cos(argmd), sin(argmd)) ) 
             
             if( abs(ks) > 1.e-4) then 
                sum = sum + & 
                     real( conjg(frpa*phikr(j))*CMPLX(cos(argpa), & 
                     -sin(argpa)) ) + &
 
                     real( conjg(frma*phikr(j))*CMPLX(cos(argma), & 
                     -sin(argma)) ) + &

                     real( conjg(frpd*phikr(j))*CMPLX(cos(argpd), & 
                     -sin(argpd)) ) + &

                     real( conjg(frmd*phikr(j))*CMPLX(cos(argmd), & 
                     -sin(argmd)) ) 
             endif
             
             result(k) = result(k) + sum

          end do

          
       else if (mode == 'des') then 

          ep = xloni
          em = xloni
          
          call findad( sina, cosa, xtime, rd0, ep, em, frp, frm, rpi, rmi)
          
          rp = rpi 
          rm = rmi 

          do j = 1, mtotald 

             kr     = wnd(j)*sina+sigmad(j)*cosa
             ks     = wnd(j)*cosa-sigmad(j)*sina

             argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)/(2.0*PI)
             argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)/(2.0*PI)

             sum = real( frp*phikrd(j)*CMPLX(cos(argp), sin(argp)) ) + &
                  real( frm*phikrd(j)*CMPLX(cos(argm), sin(argm)) ) 
             
             if( abs(ks) > 1.e-4) then 
                sum = sum + & 
                     & real( conjg(frp*phikrd(j))*CMPLX(cos(argp),-sin(argp)))&
                     & + &
                     & real( conjg(frm*phikrd(j))*CMPLX(cos(argm), -sin(argm)))
             endif
             
             result(k) = result(k) + sum
             
          end do


       else if (mode == 'asc') then 
          
          ep = xloni
          em = xloni

          call findad( sina, cosa, xtime, ra0, ep, em, frp, frm, rpi, rmi)

          rp = rpi 
          rm = rmi 
                
          do j = 1, mtotala 

             kr     = wna(j)*sina+sigmaa(j)*cosa
             ks     = wna(j)*cosa-sigmaa(j)*sina

             argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)/(2.0*PI)
             argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)/(2.0*PI)

             sum = real( frp*phikra(j)*CMPLX(cos(argp), sin(argp)) ) + &
                  & real( frm*phikra(j)*CMPLX(cos(argm), sin(argm)) ) 

             if( abs(ks) > 1.e-4) then 
                sum = sum + & 
                     & real(conjg(frp*phikra(j))*CMPLX(cos(argp), -sin(argp)))&
                     & + &
                     & real(conjg(frm*phikra(j))*CMPLX(cos(argm), -sin(argm))) 
             endif
             
             result(k) = result(k) + sum

          end do

       end if

    end do

  End Subroutine Reconstruct

  
  ! /---------------------------------------------------------------\
  ! |*** Diagnostics 
  ! \---------------------------------------------------------------/

  Subroutine Diagnostics(mode, xtime_in, xlon_in, result)

    ! Arguments

    CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
    
    REAL(r8) :: xtime_in, xlon_in
    REAL :: xtime, xlon, result
    
    ! Variables
    
    REAL :: kr, ks, xloni, eoff, rp, rm, ep, em, sum, &
         & argpa, argpd, argma, argmd, argp, argm, &
         & epa, epd, ema, emd, rma, rmd, rpa, rpd , & 
         & rdp, ran, rdn, frpa, frma, frpd, frmd, frp, frm, rpi, rmi

    INTEGER :: j

    !*** find offset in longitude necessary to get r value right

    xtime = xtime_in
    xlon  = xlon_in

    eoff = c0*xtime - mod( (c0*xtime), real(2.0*PI) )
    if (eoff < 0.0) eoff = 2.0*PI
    
    result = 0.0
    
    xloni = xlon - eoff
    
    if (mode == 'com') then 

       !***find r value corresponding to this xlon & xtime

       epa = xloni
       ema = xloni
       epd = xloni
       emd = xloni

       rdp = xloni*sina + xtime*cosa
       
       call findad(sina, cosa, xtime, ra0, epa, ema, frpa, frma, rpi, rmi)
       call findad(sina, cosa, xtime, rd0, epd, emd, frpd, frmd, rpi, rmi)

       rpa = epa*sina + xtime*cosa
       rma = ema*sina + xtime*cosa
       rpd = epd*sina + xtime*cosa
       rmd = emd*sina + xtime*cosa
       
       if( (rpa-ra0)**2 >= (rma-ra0)**2 ) ran = (rma-ra0)**2
       if( (rpa-ra0)**2 <  (rma-ra0)**2 ) ran = (rpa-ra0)**2
       
       if( (rpd-rd0)**2 >= (rmd-rd0)**2 ) rdn = (rmd-rd0)**2
       if( (rpd-rd0)**2 <  (rmd-rd0)**2 ) rdn = (rpd-rd0)**2

       frpa = frpa*rdn/(rdn+ran)
       frma = frma*rdn/(rdn+ran)
       frpd = frpd*ran/(rdn+ran)
       frmd = frmd*ran/(rdn+ran)

       do j = 1, mtotal 

          kr     = wn(j)*sina+sigma(j)*cosa
          ks     = wn(j)*cosa-sigma(j)*sina

          argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)/(2.0*PI)
          argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)/(2.0*PI)
          argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)/(2.0*PI)
          argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)/(2.0*PI)
          
          sum = real( frpa*phikr(j)*CMPLX(cos(argpa), sin(argpa))  ) + &
               & real( frma*phikr(j)*CMPLX(cos(argma), sin(argma)) ) + &
               & real( frpd*phikr(j)*CMPLX(cos(argpd), sin(argpd)) ) + &
               & real( frmd*phikr(j)*CMPLX(cos(argmd), sin(argmd)) ) 
          
          if( abs(ks) > 1.e-4) then 
             sum = sum + & 
                  & real(conjg(frpa*phikr(j))*CMPLX(cos(argpa), -sin(argpa))) &
                  & + &
                  & real(conjg(frma*phikr(j))*CMPLX(cos(argma), -sin(argma))) &
                  & + &
                  & real(conjg(frpd*phikr(j))*CMPLX(cos(argpd), -sin(argpd))) &
                  & + &
                  & real(conjg(frmd*phikr(j))*CMPLX(cos(argmd), -sin(argmd))) 
          endif

          result = result + sum
          
       end do

    else if (mode == 'des') then 

       ep = xloni
       em = xloni

       call findad( sina, cosa, xtime, rd0, ep, em, frp, frm, rpi, rmi)

       rp = rpi 
       rm = rmi 

       do j = 1, mtotald 
          
          kr     = wnd(j)*sina+sigmad(j)*cosa
          ks     = wnd(j)*cosa-sigmad(j)*sina
          
          argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)/(2.0*PI)
          argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)/(2.0*PI)
          
          sum = real( frp*phikrd(j)*CMPLX(cos(argp), sin(argp)) ) + &
               & real( frm*phikrd(j)*CMPLX(cos(argm), sin(argm)) ) 
          
          if( abs(ks) > 1.e-4) then 
             sum = sum + & 
                  & real( conjg(frp*phikrd(j))*CMPLX(cos(argp), -sin(argp)))+ &
                  & real( conjg(frm*phikrd(j))*CMPLX(cos(argm), -sin(argm))) 
          endif

          result = result + sum
          
       end do
       
    else if (mode == 'asc') then 

       ep = xloni
       em = xloni

       call findad( sina, cosa, xtime, ra0, ep, em, frp, frm, rpi, rmi)

       rp = rpi 
       rm = rmi 
                
       do j = 1, mtotala 

          kr     = wna(j)*sina+sigmaa(j)*cosa
          ks     = wna(j)*cosa-sigmaa(j)*sina

          argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)/(2.0*PI)
          argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)/(2.0*PI)

          sum = real( frp*phikra(j)*CMPLX(cos(argp), sin(argp)) ) + &
               & real(frm*phikra(j)*CMPLX(cos(argm), sin(argm))) 

          if( abs(ks) > 1.e-4) then 
             sum = sum + & 
                 & real(conjg(frp*phikra(j))*CMPLX(cos(argp), -sin(argp))) + &
                 & real(conjg(frm*phikra(j))*CMPLX(cos(argm), -sin(argm))) 
          endif

          result = result + sum

       end do

    end if
    
    
  End Subroutine Diagnostics

  
  ! /---------------------------------------------------------------\
  ! |*** Generate Data
  ! \---------------------------------------------------------------/

  Subroutine DataGenerate(aField, dField)

    ! Arguments

    REAL (r8), DIMENSION(:) ::  aField, dField

    ! Variables

	 INTEGER :: i
         
	 Do i = 1, nt
            Dscend(nt+1-i) = dField(i) 
            Ascend(nt+1-i) = aField(i) 
            if(dField(i) < 0.0) then
              !Dscend(nt+1-i) = 0.0
            end if
            if(aField(i) < 0.0) then
              !Ascend(nt+1-i) = 0.0
            end if
         End Do

	 Do i = 1, nt
           !write(*,*) i, Dscend(nt+1-i), Ascend(nt+1-i) 
         End Do

  End Subroutine DataGenerate


  Subroutine DataGeneratePrec(aField, dField)

    ! Arguments

    REAL (r8), DIMENSION(:) ::  aField, dField

    ! Variables

	 INTEGER :: i
         
	 Do i = 1, nt
            DPrec(nt+1-i) = dField(i) 
            APrec(nt+1-i) = aField(i) 
         End Do

  End Subroutine DataGeneratePrec


  Subroutine CopyPrec2Data()
         
	Dscend = DPrec
	Ascend = APrec

  End Subroutine CopyPrec2Data
       
!===================
End Module DailyMapModule
!===================

! $Log: DailyMapModule.f90,v $
! Revision 1.13  2004/06/02 20:07:52  ybj
! *** empty log message ***
!
! Revision 1.12  2004/05/13 20:18:52  ybj
! *** empty log message ***
!
! Revision 1.11  2003/04/30 21:44:32  pwagner
! Work-around for LF95 infinite compile-time bug
!
! Revision 1.10  2003/03/22 03:42:55  jdone
! zero denominator check, individual allocate/deallocate, use only and indentation added
!
! Revision 1.9  2002/02/20 21:18:13  ybj
! *** empty log message ***
!
! Revision 1.8  2001/08/17 20:27:51  nakamura
! Fixed bug & core dump problems.
!
! Revision 1.7  2001/08/14 16:13:24  nakamura
! Adjusted initialization of fNum in FFS routines.
!
! Revision 1.6  2001/08/13 16:42:06  ybj
! *** empty log message ***
!
! Revision 1.5  2001/04/13 22:07:05  ybj
! reasonable values
!
! Revision 1.4  2001/04/11 18:29:30  ybj
! reasonable values
!
! Revision 1.3  2001/03/06 18:52:41  ybj
! *** empty log message ***
!
! Revision 1.2  2001/03/03 01:38:12  ybj
! with selected pressure levels
!
! Revision 1.1  2001/02/27 20:52:39  ybj
! FFSM Process
!
! Revision 1.1  2000/10/05 18:17:41  nakamura
! Module split from synoptic.f90 and modified to be more like the standard template.
!
@


1.14
log
@Reworded Copyright statement, moved rcs id
@
text
@d2 2
a3 10
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.
d21 1
d23 6
a28 5
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: $"
  private :: not_used_here 
!---------------------------------------------------------------------------
d44 1
a44 1
  ! Remarks:  This is a prototype module for the main Core processing.
d123 1
a123 1
    
d157 3
d305 2
a306 2
    DeAllocate(lonD, STAT=err)
    IF ( err /= 0 ) THEN
d309 1
a309 1
    ENDIF
d1381 10
a1421 8
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here
@


1.13
log
@*** empty log message ***
@
text
@d2 10
a11 2
! Copyright (c) 2003, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a28 1
  PRIVATE :: ID, ModuleName
d30 5
a34 6
  !------------------- RCS Ident Info -----------------------
  CHARACTER(LEN=130) :: Id = &
       
       "$Id: DailyMapModule.f90,v 1.12 2004/05/13 20:18:52 ybj Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: DailyMapModule.f90,v $"
  !----------------------------------------------------------
d1415 8
d1427 3
@


1.12
log
@*** empty log message ***
@
text
@d26 1
a26 1
       "$Id: DailyMapModule.f90,v 1.11 2003/04/30 21:44:32 pwagner Exp $"
d668 1
a668 1
    Do m = 1, nwave 
d730 7
a736 1
    
d744 1
d747 1
d812 1
a812 1
    Do m = 1, nwave 
d945 1
a945 1
    Do m = 1, nwave 
d1413 3
@


1.11
log
@Work-around for LF95 infinite compile-time bug
@
text
@d18 2
a19 1
    & FFSM_Opt, FFSM, FFSMA, FFSMD, Reconstruct, Diagnostics, DataGenerate
d26 1
a26 1
       "$Id: DailyMapModule.f90,v 1.10 2003/03/22 03:42:55 jdone Exp $"
d40 2
a41 1
  !                DataGenerate1
d218 12
d362 12
a598 1
    INTEGER :: fNum(0:nt)
d677 3
a679 1
          if (abs(sina)        .gt.0.00001) kr = -ks*c0+float(m1)/sina
a729 1
    fNum = 0 
d732 6
a737 6
       wIndex = int(wn(j))
       fNum(wIndex) = fNum(wIndex) + 1
       l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
       l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigma(j)
       l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikr(j))
       l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikr(j))
a762 1
    INTEGER :: fNum(0:nt_a)
d813 2
a814 2
          if (abs(float(nt_a)*ds) .gt. 0.0000001) & 
               & ks = 2.0*PI*(-float(nt_a)/2+i)/(float(nt_a)*ds)
d816 1
a860 1
    fNum = 0 
d863 6
a868 6
       wIndex = int(wna(j))
       fNum(wIndex) = fNum(wIndex) + 1
       l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
       l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigmaa(j)
       l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikra(j))
       l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikra(j))
a894 1
    INTEGER :: fNum(0:nt_d)
d945 2
a946 2
          if (abs(float(nt_d)*ds).gt.0.000001) & 
               ks = 2.0*PI*(-0.5*float(nt_d)+i)/(float(nt_d)*ds)
d948 1
a990 1
    fNum = 0 
d993 6
a998 6
       wIndex = int(wnd(j))
       fNum(wIndex) = fNum(wIndex) + 1
       l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
       l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigmad(j)
       l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikrd(j))
       l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikrd(j))
d1373 26
d1405 3
@


1.10
log
@zero denominator check, individual allocate/deallocate, use only and indentation added
@
text
@d2 1
a2 1
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d16 3
a18 1
  PUBLIC
d25 1
a25 1
       "$Id: DailyMapModule.f90,v 1.9 2002/02/20 21:18:13 ybj Exp $"
d1348 1
a1348 1
       End Subroutine DataGenerate
d1350 3
a1352 3
     !===================
     End Module DailyMapModule
     !===================
d1355 3
@


1.9
log
@*** empty log message ***
@
text
@d5 1
a5 1
!===============================================================================
d7 1
a7 1
!===============================================================================
d9 59
a67 63
   	Use MLSCommon
   	USE MLSCF
   	USE MLSPCF3
   	USE L3CF
   	USE L3DMData
   	USE L2GPData
   	USE L2Interface
   	USE L3DMData
   	USE L3SPData
	Use global_data
	Implicit None
	PUBLIC

	PRIVATE :: ID, ModuleName

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &

   "$Id: DailyMapModule.f90,v 1.8 2001/08/17 20:27:51 nakamura Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: DailyMapModule.f90,v $"
!----------------------------------------------------------

! Contents:

! Subroutines -- Init 
!                Loc2RS
!                CordTransform
!                findad
!                FFSM
!                Reconstruct
!                Diagnostics
!                DataGenerate
!                DataGenerate1
! Function -- 

! Remarks:  This is a prototype module for the main Core processing.

! Parameters

      	integer FFTW_FORWARD,FFTW_BACKWARD
      	parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)

      	integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
      	parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)

      	integer FFTW_ESTIMATE,FFTW_MEASURE
      	parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)

      	integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
      	parameter (FFTW_OUT_OF_PLACE=0)
      	parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)

      	integer FFTW_THREADSAFE
      	parameter (FFTW_THREADSAFE=128)

!     Constants for the MPI wrappers:
      	integer FFTW_TRANSPOSED_ORDER, FFTW_NORMAL_ORDER
      	integer FFTW_SCRAMBLED_INPUT, FFTW_SCRAMBLED_OUTPUT
      	parameter(FFTW_TRANSPOSED_ORDER=1, FFTW_NORMAL_ORDER=0)
      	parameter(FFTW_SCRAMBLED_INPUT=8192)
      	parameter(FFTW_SCRAMBLED_OUTPUT=16384)

	Save
d71 736
a806 379
! /---------------------------------------------------------------\
! |*** Initilization
! \---------------------------------------------------------------/

	Subroutine Init(mode, nt_a_i, nt_d_i, tau0_i, delTad_i, 	&
			c0_i, lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i)

! Arguments

	  CHARACTER (LEN=3) :: mode                  ! asc/des/com/all

          Integer :: nt_a_i, nt_d_i
	  Real    :: c0_i, tau0_i
	  Real (r8)   :: lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i, delTad_i
	  Real (r8)   :: lonD0_i_temp, lonA0_i_temp
	 
          lat	    = lat_i
	  nt_a      = nt_a_i
	  nt_d      = nt_d_i

	  if(nt_a > nt_d) then
	    nt = nt_d
	  else
	    nt = nt_a
	  end if

	  nt_a = nt
	  nt_d = nt

	  c0 	    = c0_i
 	  tau0 	    = tau0_i 

 	  sina      = 1.0/sqrt(1.0+c0*c0)
 	  cosa      = c0/sqrt(1.0+c0*c0)
 	  ds        = tau0/sina

	  krmax     = 1.0/sina
 	  nwave     = PI/(ds*cosa)

 	  dtad	    = delTad_i 

	  if(lonD0_i < 0) then
		lonD0_i_temp = 2.0*PI+lonD0_i
	  else 
		lonD0_i_temp = lonD0_i
	  end if
	  if(lonA0_i < 0) then
		lonA0_i_temp = 2.0*PI+lonA0_i
	  else 	
		lonA0_i_temp = lonA0_i
	  end if

          dlonad    = abs( lonD0_i-lonA0_i)
          if(lonD0_i < 0 .and. lonA0_i > 0 .or. lonD0_i > 0 .and. lonA0_i < 0) then
                dlonad    = abs( lonD0_i-lonA0_i)
          else if(lonD0_i < 0 .and. lonA0_i < 0 ) then
                dlonad    = abs( lonD0_i-lonA0_i)
          else
                dlonad    = abs( lonD0_i+lonA0_i)
          end if

          if(lonA0_i_temp < lonD0_i_temp) then
                dlonad  = abs( lonD0_i_temp-lonA0_i_temp )
          else 
                dlonad  = 2.0*PI-abs( lonD0_i_temp-lonA0_i_temp )
          end if

	  d1lonad   = dlonad + c0*dtad

	  lonD0   = lonD0_i
    	  tD0     = tD0_i
	  lonA0   = lonA0_i
    	  tA0     = tA0_i

!	  if(mode == 'com') then
	    Allocate(lonD(nt), tD(nt), sD(nt), rD(nt))
	    Allocate(lonA(nt), tA(nt), sA(nt), rA(nt))
	    Allocate(Dscend(nt_d), Ascend(nt_a))
	    Allocate(wn(nt*2), sigma(nt*2))
	    Allocate(wna(nt_a*2), sigmaa(nt_a*2))
	    Allocate(wnd(nt_d*2), sigmad(nt_d*2))
	    Allocate(phikr(nt*2))
	    Allocate(phikra(nt_a*2))
	    Allocate(phikrd(nt_d*2))
!          else if(mode == 'asc') then
!	    Allocate(lonDA(nt), tDA(nt), sDA(nt), rDA(nt))
!	    Allocate(DAcend(nt))
!	    Allocate(wn(nt*2), sigma(nt*2))
!	    Allocate(phikrda(nt*2))
!	  end if
 	 
	End Subroutine Init

! /---------------------------------------------------------------\
! |*** Clear Memory
! \---------------------------------------------------------------/

	Subroutine ClearMemory()

	    DeAllocate(lonD, tD, sD, rD)
	    DeAllocate(lonA, tA, sA, rA)
	    DeAllocate(Dscend, Ascend)
	    DeAllocate(wn, sigma)
	    DeAllocate(wna, sigmaa)
	    DeAllocate(wnd, sigmad)
	    DeAllocate(phikr)
	    DeAllocate(phikra)
	    DeAllocate(phikrd)
 	 
	End Subroutine ClearMemory

! /---------------------------------------------------------------\
! |*** Coordinate transformation
! \---------------------------------------------------------------/

        Subroutine CordTransform(mode)

! Arguments

	  CHARACTER (LEN=3) :: mode                  ! asc/des/com/all

! Variables

	  Integer :: i

          if(mode == 'com') then
	    sD0 = lonD0*cosa - tD0*sina - tau0*(nt-1.0)/sina
	    sA0 = sD0 + (-dlonad*c0 + dtad)*sina
	    rD0 = (lonD0 + c0*tD0)*sina
	    rA0 = (lonD0 - dlonad + c0*tD0 - c0*dtad)*sina
	  else if(mode == 'asc') then
	    sA0 = lonA0*cosa - tA0*sina - tau0*(nt-1.0)/sina
	    rA0 = (lonA0 + c0*tA0)*sina
	  else if(mode == 'des') then
	    sD0 = lonD0*cosa - tD0*sina - tau0*(nt-1.0)/sina
	    rD0 = (lonD0 + c0*tD0)*sina
          end if 

          if(mode == 'com') then
	    Do i = 1, nt
   	       rD(i) = rD0
               rA(i) = rA0
               sD(i) = sD0 + i*tau0/sina
               sA(i) = sA0 + i*tau0/sina
            End Do
	  else if(mode == 'asc') then
	    Do i = 1, nt
   	       rA(i) = rA0
               sA(i) = sA0 + i*tau0/sina
            End Do
	  else if(mode == 'des') then
	    Do i = 1, nt
   	       rD(i) = rD0
               sD(i) = sD0 + i*tau0/sina
            End Do
          end if 

	End Subroutine CordTransform


! /---------------------------------------------------------------\
! |*** findad 
! \---------------------------------------------------------------/

	Subroutine FindAD(sina, cosa, t, r0, ep, em, frp, frm, rpi, rmi)

! Arguments

	  Real :: sina, cosa, t, r0, ep, em, frp, frm, rpi, rmi

! Variables

	  Integer :: inc
	  Real :: e, r, s

	  e = ep

	  r = e*sina + t*cosa
	  s = e*cosa - t*sina

	  if (abs(r-r0) >= 1.e-6) then 
     
  	    if ( r > r0 ) then 
		inc = -1
        	ep = e
  	    else 
		inc = 1
        	em = e
  	    end if

  	    e = e + inc*2.0*PI
  	    r = e*sina + t*cosa

  	    if ( inc < 0) then 
              do
    	        if (r <= r0) exit
       		ep = e
      		e  = e + inc*2.0*PI
      		r = e*sina + t*cosa
    	      end do 
    	      em = e
   	    endif

  	    if ( inc > 0) then 
              do
    	        if (r >= r0) exit
      		em = e
      		e  = e + inc*2.0*PI
      		r = e*sina + t*cosa
    	      end do 
    	      ep = e
  	    endif

  	    rpi = ep*sina + t*cosa
  	    rmi = em*sina + t*cosa

  	    if( abs(r0-rpi) <= 1.e-8 .and. abs(r0-rmi) <= 1.e-8) then 
    		frm = 1.0
    		frp = 0.0
  	    else 
    		frm = (r0-rpi)**2/((r0-rpi)**2+(r0-rmi)**2)
    		frp = (r0-rmi)**2/((r0-rpi)**2+(r0-rmi)**2)
  	    end if

	  else 
    	    frm = 1.0
    	    frp = 0.0
    	    rpi = ep*sina + t*cosa
    	    rmi = em*sina + t*cosa
	  end if

	End Subroutine findad

! /---------------------------------------------------------------\
! |*** FFSM_Opt --- FFSM Mode Passing Routine
! \---------------------------------------------------------------/

        Subroutine FFSM_Opt(mode, l3sp, iLv, iLt)

! Variables

	  CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
   	  TYPE( L3SPData_T ), POINTER :: l3sp(:)

	  integer iLv, iLt


          if(mode == 'com') then
        	CALL FFSM(l3sp(1), iLv, iLt)
	  else if(mode == 'asc') then
        	CALL FFSMA(l3sp(1), iLv, iLt)
	  else if(mode == 'des') then
        	CALL FFSMD(l3sp(1), iLv, iLt)
	  else if(mode == 'all') then
        	CALL FFSM(l3sp(1), iLv, iLt)
        	CALL FFSMA(l3sp(2), iLv, iLt)
        	CALL FFSMD(l3sp(3), iLv, iLt)
	  end if

	End Subroutine FFSM_Opt

! /---------------------------------------------------------------\
! |*** FFSM --- combined mode
! \---------------------------------------------------------------/

        Subroutine FFSM(l3sp, iLv, iLt)

! Variables

   	  !TYPE( L3SPData_T ), POINTER :: l3sp
   	  TYPE( L3SPData_T ) :: l3sp

	  integer plan, m, m1, i, j, flag, iLv, iLt

	  integer fNum(0:nt), wIndex

          real(r8), Dimension(nt) :: dscend_fft, ascend_fft
          real(r8), Dimension(nt) :: drealP, dimgP, arealP, aimgP 
          real(r8), Dimension((nt+1)/2) :: imgPtemp
	  double complex phia, phid

	  real	ks, kr, expa, expd, krmax_g

! Fourier Transform of both descending & ascending series

	  call rfftw_f77_create_plan(plan,nt,FFTW_FORWARD,FFTW_ESTIMATE)
	  call rfftw_f77_one(plan,ascend,ascend_fft)
	  call rfftw_f77_one(plan,dscend,dscend_fft)
	  call rfftw_f77_destroy_plan(plan)

! Ascending Part

	  Do i = nt/2, nt
   	     arealP(i) = ascend_fft(i+1-nt/2)/float(nt)
          End Do
	  Do i = 1, nt/2-1
   	     arealP(i) = ascend_fft(nt/2-i+1)/float(nt)
          End Do

	  Do i = 1, (nt+1)/2-1
   	     imgPTemp(i) = ascend_fft(nt+1-i)/float(nt)
          End Do

	  IF (mod(nt, 2) == 0) THEN
	     imgPTemp((nt+1)/2) = 0.0
	  ENDIF

   	  aimgP(nt/2) = 0.0 
	  Do i = nt/2+1, nt-1
   	     aimgP(i) = imgPtemp(i-nt/2)
          End Do
	  Do i = 1, nt/2-1
   	     aimgP(i) = -imgPtemp(nt/2-i)
          End Do
	  aimgP(nt) = 0.0

! Dscending Part

	  Do i = 1, (nt+1)/2
   	     imgPTemp(i) = 0.0 
          End Do

	  Do i = nt/2, nt
   	     drealP(i) = dscend_fft(i+1-nt/2)/float(nt)
          End Do
	  Do i = 1, nt/2-1
   	     drealP(i) = dscend_fft(nt/2-i+1)/float(nt)
          End Do

	  Do i = 1, (nt+1)/2-1
   	     imgPTemp(i) = dscend_fft(nt+1-i)/float(nt)
          End Do

	  IF (mod(nt, 2) == 0) THEN
	     imgPTemp((nt+1)/2) = 0.0
	  ENDIF

   	  dimgP(nt/2) = 0.0 
	  Do i = nt/2+1, nt-1
   	     dimgP(i) = imgPtemp(i-nt/2)
          End Do
	  Do i = 1, nt/2-1
   	     dimgP(i) = -imgPtemp(nt/2-i)
          End Do
	  dimgP(nt) = 0.0

 	  mtotal = 0

	  krmax_g = krmax

 	  Do m = 1, nwave 
            m1 = m-1
   	    Do i = 1, nt

     	       mtotal = mtotal + 1

      	       wn(mtotal) = float(m1)

               ks = 2.0*PI*(-nt/2+i)/(nt*ds)
               kr = -ks*c0+float(m1)/sina

               sigma(mtotal) = -ks*sina + kr*cosa

               if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
                  flag = 0
		  phikr(mtotal) = CMPLX(0.0, 0.0)
                  Goto 101
               endif

               expa = ks*sa0 + kr*ra0
               expd = ks*sd0 + kr*rd0

               flag = 0

     	       phia   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expa), -sin(expa))
     	       phid   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expd), -sin(expd))

     	       phikr(mtotal) = (phia-phid*CMPLX(cos(d1lonad), -sin(d1lonad)))/(1.0-CMPLX(cos(d1lonad), -sin(d1lonad)))

d808 269
a1076 130
      	       if( phikr(mtotal) /= CMPLX(0.0, 0.0) ) flag = 1


101            continue 

! *** kr+

      	       if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
                  if (flag == 0 .and. mtotal > 0) mtotal = mtotal-1
                  Goto 102
     	       endif

               kr  = -ks*c0+float(m1-1)/sina

     	       expa = ks*sa0 + kr*ra0
     	       expd = ks*sd0 + kr*rd0

     	       phia   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expa), -sin(expa))
     	       phid   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expd), -sin(expd))

     	       phikr(mtotal) = (phid-phia)*CMPLX( cos(rd0/sina), -sin(rd0/sina) )/(1.0-CMPLX( cos(d1lonad), -sin(d1lonad) ))

102            continue 

           End Do
         End Do

	   fNum = 0 

	 do j = 1, mtotal
	   wIndex = int(wn(j))
	   fNum(wIndex) = fNum(wIndex) + 1
	   l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
	   l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigma(j)
	   l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikr(j))
	   l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikr(j))
         end do


	End Subroutine FFSM

! /---------------------------------------------------------------\
! |*** FFSMA --- single mode / ascending
! \---------------------------------------------------------------/

        Subroutine FFSMA(l3sp, iLv, iLt)

	  Implicit None

! Variables

   	  !TYPE( L3SPData_T ), POINTER :: l3sp
   	  TYPE( L3SPData_T ) :: l3sp

	  integer plan, m, m1, i, j, flag, iLv, iLt

	  integer fNum(0:nt_a), wIndex

          real(r8), Dimension(nt_a) :: ascend_fft
          real(r8), Dimension(nt_a) :: arealP, aimgP
          real(r8), Dimension((nt_a+1)/2) :: imgPtemp
	  double complex phida

	  real	ks, kr, expda, krmax_g


! Fourier Transform of one series

	  call rfftw_f77_create_plan(plan,nt_a,FFTW_FORWARD,FFTW_ESTIMATE)
	  call rfftw_f77_one(plan,ascend,ascend_fft)
	  call rfftw_f77_destroy_plan(plan)

! re-order the fft transform result

	  Do i = 1, (nt_a+1)/2
   	     imgPTemp(i) = 0.0 
          End Do

	  Do i = nt_a/2, nt_a
   	     arealP(i) = ascend_fft(i+1-nt_a/2)/float(nt_a)
          End Do
	  Do i = 1, nt_a/2-1
   	     arealP(i) = ascend_fft(nt_a/2-i+1)/float(nt_a)
          End Do

	  Do i = 1, (nt_a+1)/2-1
   	     imgPTemp(i) = ascend_fft(nt_a+1-i)/float(nt_a)
          End Do

	  IF (mod(nt_a, 2) == 0) THEN
	     imgPTemp((nt_a+1)/2) = 0.0
	  ENDIF

   	  aimgP(nt_a/2) = 0.0 
	  Do i = nt_a/2+1, nt_a
   	     aimgP(i) = imgPtemp(i-nt_a/2)
          End Do
	  Do i = 1, nt_a/2-1
   	     aimgP(i) = -imgPtemp(nt_a/2-i)
          End Do

 	  mtotala = 0

	  krmax_g = krmax/2.0

 	  Do m = 1, nwave 
            m1 = m-1
   	    Do i = 1, nt_a
     	       mtotala = mtotala + 1

      	       wna(mtotala) = float(m1)

               ks = 2.0*PI*(-nt_a/2+i)/(nt_a*ds)
               kr = -ks*c0+float(m1)/sina

               sigmaa(mtotala) = -ks*sina + kr*cosa

               if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
                  flag = 0
                  Goto 101
               endif

               expda = ks*sa0 + kr*ra0

               flag = 0

     	       phida   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expda), -sin(expda))

     	       phikra(mtotala) = phida 

d1078 2
a1079 181
      	       if( phikra(mtotala) /= CMPLX(0.0, 0.0) ) flag = 1


101            continue 

! *** kr+

      	       if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
                  if (flag == 0 .and. mtotala > 0) mtotala = mtotala-1
                  Goto 102
     	       endif

               kr  = -ks*c0+float(m1)/sina

     	       expda = ks*sa0 + kr*ra0

     	       phida   = CMPLX(arealP(i), aimgP(i))*CMPLX(cos(expda), -sin(expda))

     	       phikra(mtotala) = phida 

102            continue 

           End Do
         End Do

	   fNum = 0 

	 do j = 1, mtotala
	   wIndex = int(wna(j))
	   fNum(wIndex) = fNum(wIndex) + 1
	   l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
	   l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigmaa(j)
	   l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikra(j))
	   l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikra(j))
         end do


	End Subroutine FFSMA


! /---------------------------------------------------------------\
! |*** FFSMD --- single mode / descending
! \---------------------------------------------------------------/

        Subroutine FFSMD(l3sp, iLv, iLt)

	  Implicit None

! Variables

   	  !TYPE( L3SPData_T ), POINTER :: l3sp
   	  TYPE( L3SPData_T ) :: l3sp

	  integer plan, m, m1, i, j, flag, iLv, iLt

	  integer fNum(0:nt_d), wIndex

          real(r8), Dimension(nt_d) :: dscend_fft
          real(r8), Dimension(nt_d) :: drealP, dimgP
          real(r8), Dimension((nt_d+1)/2) :: imgPtemp
	  double complex phida

	  real	ks, kr, expda, krmax_g


! Fourier Transform of one series

	  call rfftw_f77_create_plan(plan,nt_d,FFTW_FORWARD,FFTW_ESTIMATE)
	  call rfftw_f77_one(plan,dscend,dscend_fft)
	  call rfftw_f77_destroy_plan(plan)

! re-order the fft transform result

	  Do i = 1, (nt_d+1)/2
   	     imgPTemp(i) = 0.0 
          End Do

	  Do i = nt_d/2, nt_d
   	     drealP(i) = dscend_fft(i+1-nt_d/2)/float(nt_d)
          End Do
	  Do i = 1, nt_d/2-1
   	     drealP(i) = dscend_fft(nt_d/2-i+1)/float(nt_d)
          End Do

	  Do i = 1, (nt_d+1)/2-1
   	     imgPTemp(i) = dscend_fft(nt_d+1-i)/float(nt_d)
          End Do

	  IF (mod(nt_d, 2) == 0) THEN
	     imgPTemp((nt_d+1)/2) = 0.0
	  ENDIF

   	  dimgP(nt_d/2) = 0.0 

	  Do i = nt_d/2+1, nt_d
   	     dimgP(i) = imgPtemp(i-nt_d/2)
          End Do
	  Do i = 1, nt_d/2-1
   	     dimgP(i) = -imgPtemp(nt_d/2-i)
          End Do

 	  mtotald = 0

	  krmax_g = krmax/2.0

 	  Do m = 1, nwave 
            m1 = m-1
   	    Do i = 1, nt_d

     	       mtotald = mtotald + 1

      	       wnd(mtotald) = float(m1)

               ks = 2.0*PI*(-nt_d/2+i)/(nt_d*ds)
               kr = -ks*c0+float(m1)/sina

               sigmad(mtotald) = -ks*sina + kr*cosa

               if (kr < -krmax_g .or. kr > 0.0 .or. ks < 0.0) then 
                  flag = 0
                  Goto 101
               endif

               expda = ks*sd0 + kr*rd0

               flag = 0

     	       phida   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expda), -sin(expda))

     	       phikrd(mtotald) = phida 

 
      	       if( phikrd(mtotald) /= CMPLX(0.0, 0.0) ) flag = 1


101            continue 

! *** kr+

      	       if (kr > krmax_g .or. kr < 0.0 .or. ks < 0.0 ) then 
                  if (flag == 0 .and. mtotald > 0) mtotald = mtotald-1
                  Goto 102
     	       endif

               kr  = -ks*c0+float(m1)/sina

     	       expda = ks*sd0 + kr*rd0

     	       phida   = CMPLX(drealP(i), dimgP(i))*CMPLX(cos(expda), -sin(expda))

     	       phikrd(mtotald) = phida 

102            continue 

           End Do
         End Do

	   fNum = 0 

	 do j = 1, mtotald
	   wIndex = int(wnd(j))
	   fNum(wIndex) = fNum(wIndex) + 1
	   l3sp%waveNumber(iLv, iLt, wIndex+1) = wIndex 
	   l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigmad(j)
	   l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikrd(j))
	   l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikrd(j))
         end do


	End Subroutine FFSMD


! /---------------------------------------------------------------\
! |*** Reconstruct 
! \---------------------------------------------------------------/

        Subroutine Reconstruct(mode, xtime, nlons, xlon_orig, result)

! Arguments

	  CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
d1081 2
a1082 1
	  integer nlons
d1084 248
a1331 1
	  real xtime
d1333 1
a1333 1
	  real(r8), Dimension(nlons) :: xlon, xlon_orig, result
d1335 1
a1335 1
! Variables
d1337 1
a1337 332
	  integer j, k

	  real  kr, ks

	  real  xloni, eoff, rp, rm, ep, em, sum 
	  real  argpa, argpd, argma, argmd, argp, argm
 	  real  epa, epd, ema, emd
 	  real  rma, rmd, rpa, rpd , rdp, ran, rdn
 	  real  frpa, frma, frpd, frmd, frp, frm, rpi, rmi

!*** Convert to gradient 

 	  do k = 1, nlons
	    xlon(k) = xlon_orig(k)*PI/180.0
  	  end do

!*** find offset in longitude necessary to get r value right

 	 eoff = c0*xtime - mod( (c0*xtime), (2.0*PI) )
 	 if (eoff < 0.0) eoff = 2.0*PI

!*** Loop over longitude

 	 do k = 1, nlons

  	    result(k) = 0.0

            xloni = xlon(k) - eoff

            if (mode == 'com') then 

!***find r value corresponding to this xlon & xtime

  	      	epa = xloni
  		ema = xloni
  		epd = xloni
  		emd = xloni

  		rdp = xloni*sina + xtime*cosa

  		call findad(sina, cosa, xtime, ra0, epa, ema, frpa, frma, rpi, rmi)
  		call findad(sina, cosa, xtime, rd0, epd, emd, frpd, frmd, rpi, rmi)

  		rpa = epa*sina + xtime*cosa
  		rma = ema*sina + xtime*cosa
  		rpd = epd*sina + xtime*cosa
  		rmd = emd*sina + xtime*cosa

  		if( (rpa-ra0)**2 >= (rma-ra0)**2 ) ran = (rma-ra0)**2
  		if( (rpa-ra0)**2 <  (rma-ra0)**2 ) ran = (rpa-ra0)**2

  		if( (rpd-rd0)**2 >= (rmd-rd0)**2 ) rdn = (rmd-rd0)**2
  		if( (rpd-rd0)**2 <  (rmd-rd0)**2 ) rdn = (rpd-rd0)**2

  		frpa = frpa*rdn/(rdn+ran)
  		frma = frma*rdn/(rdn+ran)
  		frpd = frpd*ran/(rdn+ran)
  		frmd = frmd*ran/(rdn+ran)


  		do j = 1, mtotal 

        	  kr     = wn(j)*sina+sigma(j)*cosa
        	  ks     = wn(j)*cosa-sigma(j)*sina

        	  argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)/(2.0*PI)
        	  argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)/(2.0*PI)
        	  argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)/(2.0*PI)
        	  argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)/(2.0*PI)
        	  !argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)
        	  !argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)
        	  !argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)
        	  !argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)

		  sum = real( frpa*phikr(j)*CMPLX(cos(argpa), sin(argpa)) ) + &
	      		real( frma*phikr(j)*CMPLX(cos(argma), sin(argma)) ) + &
	      		real( frpd*phikr(j)*CMPLX(cos(argpd), sin(argpd)) ) + &
	      		real( frmd*phikr(j)*CMPLX(cos(argmd), sin(argmd)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frpa*phikr(j))*CMPLX(cos(argpa), -sin(argpa)) ) + &
	               		    real( conjg(frma*phikr(j))*CMPLX(cos(argma), -sin(argma)) ) + &
	               		    real( conjg(frpd*phikr(j))*CMPLX(cos(argpd), -sin(argpd)) ) + &
	               		    real( conjg(frmd*phikr(j))*CMPLX(cos(argmd), -sin(argmd)) ) 
        	  endif

  		  result(k) = result(k) + sum

  		end do


 	    else if (mode == 'des') then 

  		ep = xloni
  		em = xloni

  		call findad( sina, cosa, xtime, rd0, ep, em, frp, frm, rpi, rmi)

  		rp = rpi 
  		rm = rmi 

  		do j = 1, mtotald 

        	  kr     = wnd(j)*sina+sigmad(j)*cosa
        	  ks     = wnd(j)*cosa-sigmad(j)*sina

        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)/(2.0*PI)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)/(2.0*PI)

		  sum = real( frp*phikrd(j)*CMPLX(cos(argp), sin(argp)) ) + &
	      	        real( frm*phikrd(j)*CMPLX(cos(argm), sin(argm)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frp*phikrd(j))*CMPLX(cos(argp), -sin(argp)) ) + &
	               		    real( conjg(frm*phikrd(j))*CMPLX(cos(argm), -sin(argm)) ) 
        	  endif

  		  result(k) = result(k) + sum

  		end do


 	    else if (mode == 'asc') then 

  		ep = xloni
  		em = xloni

  		call findad( sina, cosa, xtime, ra0, ep, em, frp, frm, rpi, rmi)

  		rp = rpi 
  		rm = rmi 

  		do j = 1, mtotala 

        	  kr     = wna(j)*sina+sigmaa(j)*cosa
        	  ks     = wna(j)*cosa-sigmaa(j)*sina

        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)/(2.0*PI)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)/(2.0*PI)

		  sum = real( frp*phikra(j)*CMPLX(cos(argp), sin(argp)) ) + &
	      	        real( frm*phikra(j)*CMPLX(cos(argm), sin(argm)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frp*phikra(j))*CMPLX(cos(argp), -sin(argp)) ) + &
	               		    real( conjg(frm*phikra(j))*CMPLX(cos(argm), -sin(argm)) ) 
        	  endif

  		  result(k) = result(k) + sum

  		end do

 	    end if

 	 end do

	End Subroutine Reconstruct


! /---------------------------------------------------------------\
! |*** Diagnostics 
! \---------------------------------------------------------------/

        Subroutine Diagnostics(mode, xtime_in, xlon_in, result)

! Arguments

	  CHARACTER (LEN=3) :: mode                  ! asc/des/com/all

	  real (r8) :: xtime_in, xlon_in
	  real xtime, xlon, result

! Variables

	  integer j

	  real  kr, ks

	  real  xloni, eoff, rp, rm, ep, em, sum 
	  real  argpa, argpd, argma, argmd, argp, argm
 	  real  epa, epd, ema, emd
 	  real  rma, rmd, rpa, rpd , rdp, ran, rdn
 	  real  frpa, frma, frpd, frmd, frp, frm, rpi, rmi

!*** find offset in longitude necessary to get r value right

	 xtime = xtime_in
	 xlon = xlon_in

 	 eoff = c0*xtime - mod( (c0*xtime), (2.0*PI) )
 	 if (eoff < 0.0) eoff = 2.0*PI

         result = 0.0

         xloni = xlon - eoff

         if (mode == 'com') then 

!***find r value corresponding to this xlon & xtime

  	    	epa = xloni
  		ema = xloni
  		epd = xloni
  		emd = xloni

  		rdp = xloni*sina + xtime*cosa

  		call findad(sina, cosa, xtime, ra0, epa, ema, frpa, frma, rpi, rmi)
  		call findad(sina, cosa, xtime, rd0, epd, emd, frpd, frmd, rpi, rmi)

  		rpa = epa*sina + xtime*cosa
  		rma = ema*sina + xtime*cosa
  		rpd = epd*sina + xtime*cosa
  		rmd = emd*sina + xtime*cosa

  		if( (rpa-ra0)**2 >= (rma-ra0)**2 ) ran = (rma-ra0)**2
  		if( (rpa-ra0)**2 <  (rma-ra0)**2 ) ran = (rpa-ra0)**2

  		if( (rpd-rd0)**2 >= (rmd-rd0)**2 ) rdn = (rmd-rd0)**2
  		if( (rpd-rd0)**2 <  (rmd-rd0)**2 ) rdn = (rpd-rd0)**2

  		frpa = frpa*rdn/(rdn+ran)
  		frma = frma*rdn/(rdn+ran)
  		frpd = frpd*ran/(rdn+ran)
  		frmd = frmd*ran/(rdn+ran)

  		do j = 1, mtotal 

        	  kr     = wn(j)*sina+sigma(j)*cosa
        	  ks     = wn(j)*cosa-sigma(j)*sina

        	  argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)/(2.0*PI)
        	  argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)/(2.0*PI)
        	  argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)/(2.0*PI)
        	  argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)/(2.0*PI)

		  sum = real( frpa*phikr(j)*CMPLX(cos(argpa), sin(argpa)) ) + &
	      		real( frma*phikr(j)*CMPLX(cos(argma), sin(argma)) ) + &
	      		real( frpd*phikr(j)*CMPLX(cos(argpd), sin(argpd)) ) + &
	      		real( frmd*phikr(j)*CMPLX(cos(argmd), sin(argmd)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frpa*phikr(j))*CMPLX(cos(argpa), -sin(argpa)) ) + &
	               		    real( conjg(frma*phikr(j))*CMPLX(cos(argma), -sin(argma)) ) + &
	               		    real( conjg(frpd*phikr(j))*CMPLX(cos(argpd), -sin(argpd)) ) + &
	               		    real( conjg(frmd*phikr(j))*CMPLX(cos(argmd), -sin(argmd)) ) 
        	  endif

  		  result = result + sum

  		end do

 	else if (mode == 'des') then 

  		ep = xloni
  		em = xloni

  		call findad( sina, cosa, xtime, rd0, ep, em, frp, frm, rpi, rmi)

  		rp = rpi 
  		rm = rmi 

  		do j = 1, mtotald 

        	  kr     = wnd(j)*sina+sigmad(j)*cosa
        	  ks     = wnd(j)*cosa-sigmad(j)*sina

        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)/(2.0*PI)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)/(2.0*PI)

		  sum = real( frp*phikrd(j)*CMPLX(cos(argp), sin(argp)) ) + &
	      	        real( frm*phikrd(j)*CMPLX(cos(argm), sin(argm)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frp*phikrd(j))*CMPLX(cos(argp), -sin(argp)) ) + &
	               		    real( conjg(frm*phikrd(j))*CMPLX(cos(argm), -sin(argm)) ) 
        	  endif

  		  result = result + sum

  		end do

 	else if (mode == 'asc') then 

  		ep = xloni
  		em = xloni

  		call findad( sina, cosa, xtime, ra0, ep, em, frp, frm, rpi, rmi)

  		rp = rpi 
  		rm = rmi 

  		do j = 1, mtotala 

        	  kr     = wna(j)*sina+sigmaa(j)*cosa
        	  ks     = wna(j)*cosa-sigmaa(j)*sina

        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)/(2.0*PI)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)/(2.0*PI)

		  sum = real( frp*phikra(j)*CMPLX(cos(argp), sin(argp)) ) + &
	      	        real( frm*phikra(j)*CMPLX(cos(argm), sin(argm)) ) 

        	  if( abs(ks) > 1.e-4) then 
	   		sum = sum + real( conjg(frp*phikra(j))*CMPLX(cos(argp), -sin(argp)) ) + &
	               		    real( conjg(frm*phikra(j))*CMPLX(cos(argm), -sin(argm)) ) 
        	  endif

  		  result = result + sum

  		end do

 	end if


	End Subroutine Diagnostics


! /---------------------------------------------------------------\
! |*** Generate Data
! \---------------------------------------------------------------/

        Subroutine DataGenerate(aField, dField)

! Arguments

         Real (r8), DIMENSION(:) ::  aField, dField


! Variables

	 Integer i
d1339 2
d1346 5
a1350 5
	End Subroutine DataGenerate

!===================
End Module DailyMapModule
!===================
d1353 3
@


1.8
log
@Fixed bug & core dump problems.
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.7 2001/08/14 16:13:24 nakamura Exp $"
d127 9
d1121 3
@


1.7
log
@Adjusted initialization of fNum in FFS routines.
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.6 2001/08/13 16:42:06 ybj Exp $"
d115 1
a115 1
 	  !dlonad    = PI-dtad*c0 
d126 6
a131 2
 	  !dlonad    = abs( lonD0_i_temp-lonA0_i_temp )
 	  dlonad    = abs( lonD0_i-lonA0_i)
d1112 3
@


1.6
log
@*** empty log message ***
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.5 2001/04/13 22:07:05 ybj Exp $"
d469 1
a469 3
	 do j = 1, nt
	   fNum(j) = 0 
	 end do
d598 1
a598 3
	 do j = 1, nt_a
	   fNum(j) = 0 
	 end do
d730 1
a730 3
	 do j = 1, nt_d
	   fNum(j) = 0 
	 end do
d1108 3
@


1.5
log
@reasonable values
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.4 2001/04/11 18:29:30 ybj Exp $"
d89 1
d116 12
a127 1
 	  dlonad    = abs(lonD0_i-lonA0_i) 
d370 1
a370 1
	  Do i = nt/2+1, nt
d376 1
d400 1
a400 1
	  Do i = nt/2+1, nt
d406 1
d427 1
d834 8
a841 4
        	  argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)
        	  argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)
        	  argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)
        	  argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)
d875 2
a876 2
        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)
d906 2
a907 2
        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)
d1000 4
a1003 4
        	  argpa = (wn(j)*epa + sigma(j)*xtime) + kr*(ra0-rpa)
        	  argma = (wn(j)*ema + sigma(j)*xtime) + kr*(ra0-rma)
        	  argpd = (wn(j)*epd + sigma(j)*xtime) + kr*(rd0-rpd)
        	  argmd = (wn(j)*emd + sigma(j)*xtime) + kr*(rd0-rmd)
d1036 2
a1037 2
        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rd0-rp)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rd0-rm)
d1066 2
a1067 2
        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(ra0-rp)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(ra0-rm)
a1106 1

d1114 3
@


1.4
log
@reasonable values
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.3 2001/03/06 18:52:41 ybj Exp $"
d100 3
d127 1
a127 1
	    Allocate(Dscend(nt), Ascend(nt))
d129 2
a130 2
	    Allocate(wna(nt*2), sigmaa(nt*2))
	    Allocate(wnd(nt*2), sigmad(nt*2))
d132 2
a133 2
	    Allocate(phikra(nt*2))
	    Allocate(phikrd(nt*2))
d617 1
a617 1
	  integer fNum(0:nt), wIndex
d1096 3
@


1.3
log
@*** empty log message ***
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.2 2001/03/03 01:38:12 ybj Exp $"
d42 1
a42 1
! Function -- DataField
d79 2
a80 1
	Subroutine Init(mode, nt_a_i, nt_d_i, tau0_i, delTad_i, c0_i, lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i)
d111 2
a112 1
 	  dlonad    = PI-dtad*c0 
a205 37
!********************************************************************

        Subroutine Loc2RS(aLoc, aRS)

	 TYPE(Loc_T), INTENT(IN) :: aLoc
	 TYPE(RS_T), INTENT(OUT) :: aRS

	End Subroutine Loc2RS

! /---------------------------------------------------------------\
! |*** Data Field 
! \---------------------------------------------------------------/

	Real Function DataField(lon, lat, t)

! Arguments

	  Real :: lon, lat, t

! Variables

	  Real :: m0, sigma0, k0

   	  m0      = 4.0
   	  sigma0  = 0.1
   	  !sigma0 = 0.0
   	  k0      = 2.25

   	  !DataField = cos(m0*lon + sigma0*t)
   	  !DataField = cos(2.0*lon + sigma0*t)
   	  !DataField = 2.0*cos(m0*lon - sigma0*t + lat) + cos(3.0*lon - 2.0*sigma0*t + lat) - 1.5*cos(1.0*lon - 3.0*sigma0*t)
   	  !DataField = 2.0*cos(4*lon - 2.*sigma0*t + lat) - cos(3.0*lon - 2.0*sigma0*t + lat) - 1.5*cos(1.0*lon + 1.0*sigma0*t)
   	  !DataField = cos(m0*lon + sigma0*t)*cos(k0*lat)
   	  DataField = 1.5 + 0.5*cos(lon) + cos(2.0*lon + 0.5*t)

	End Function DataField

d211 1
a211 1
	Subroutine findad(sina, cosa, t, r0, ep, em, frp, frm, rpi, rmi)
d364 4
d500 4
d548 1
a548 1
               expda = ks*sda0 + kr*rda0
d571 1
a571 1
     	       expda = ks*sda0 + kr*rda0
d632 4
d682 1
a682 1
               expda = ks*sda0 + kr*rda0
d705 1
a705 1
     	       expda = ks*sda0 + kr*rda0
d737 1
a737 1
        Subroutine Reconstruct(mode, xtime, nlons, xlon, result)
d747 1
a747 1
	  real(r8), Dimension(nlons) :: xlon, result
d751 1
a751 1
	  integer plan, m, m1, i, j, k
d761 5
d843 1
a843 1
  		call findad( sina, cosa, xtime, rda0, ep, em, frp, frm, rpi, rmi)
d853 2
a854 2
        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rda0-rp)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rda0-rm)
d874 1
a874 1
  		call findad( sina, cosa, xtime, rda0, ep, em, frp, frm, rpi, rmi)
d884 2
a885 2
        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(rda0-rp)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(rda0-rm)
d921 1
a921 1
	  integer plan, m, m1, i, j, k
d1004 1
a1004 1
  		call findad( sina, cosa, xtime, rda0, ep, em, frp, frm, rpi, rmi)
d1014 2
a1015 2
        	  argp = (wnd(j)*ep + sigmad(j)*xtime) + kr*(rda0-rp)
        	  argm = (wnd(j)*em + sigmad(j)*xtime) + kr*(rda0-rm)
d1034 1
a1034 1
  		call findad( sina, cosa, xtime, rda0, ep, em, frp, frm, rpi, rmi)
d1044 2
a1045 2
        	  argp = (wna(j)*ep + sigmaa(j)*xtime) + kr*(rda0-rp)
        	  argm = (wna(j)*em + sigmaa(j)*xtime) + kr*(rda0-rm)
d1069 1
a1069 1
        Subroutine DataGenerate(mode, aField, dField)
a1072 1
	 CHARACTER (LEN=3) :: mode                  ! asc/des/com/all
a1078 1
         Real	      :: temp1, temp2, temp3
a1084 6
         open(2, file='fields.dat', status="replace")
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(2F10.5)') Ascend(i), Dscend(i)  
         End Do
         close(2) 
a1087 131
!**************************************************************************************

        Subroutine DataGenerate_old(mode, filename1, filename2)

! Arguments

	 CHARACTER (LEN=3) :: mode                  ! asc/des/com/all

	 Character(*) :: filename1, filename2

! Variables

	 Integer i
         Real	      :: temp1, temp2, temp3

         lonD(1) = lonD0
         lonA(1) = lonD0 - dlonad
         tD(1)   = tD0
         tA(1)   = tA0

         If (lonD(1) < -PI) lonD(1) = 2.0*PI + lonD(1)
   	 print *, 'lonD0=', lonD0

         If (lonA(1) < -PI) lonA(1) = 2.0*PI + lonA(1)

	 Do i = 2, nt
            lonD(i) = lonD(i-1) - c0*tau0
            If (lonD(i) < -PI) lonD(i) = 2.0*PI + lonD(i)
            lonA(i) = lonD(i) - dlonad
            If (lonA(i) < -PI) lonA(i) = 2.0*PI + lonA(i)
            tD(i) = tD0 + i*tau0
            tA(i) = tA0 + i*tau0
            temp1 = lonD(i)
            temp2 = tD(i)
            Dscend(nt+1-i) = DataField(temp1, lat, temp2) 
            temp1 = lonA(i)
            temp2 = tA(i)
            Ascend(nt+1-i) = DataField(temp1, lat, temp2) 
         End Do
         temp1 = lonD(1)
         temp2 = tD(1)
         Dscend(nt) = DataField(temp1, lat, temp2) 
         temp1 = lonA(1)
         temp2 = tA(1)
         Ascend(nt) = DataField(temp1, lat, temp2) 

         open(2, file=filename1, status="replace")
   	 write(2, '(4A10)') 'lonA', 'lonD', 'tA', 'tD'
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(4F10.5)') lonA(i), lonD(i), tA(i), tD(i)
         End Do
         close(2) 

         open(2, file=filename2, status="replace")
   	 write(2, '(6A10)') 'sA', 'sD', 'rA', 'rD', 'Ascend', 'Dscend'  
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(6F10.5)') sA(i), sD(i), rA(i), rD(i), Ascend(i), Dscend(i)  
         End Do
         close(2) 

         open(2, file="ascend.dat", status="replace")
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(F10.5)') Ascend(i) 
         End Do
         close(2) 

         open(2, file="dscend.dat", status="replace")
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(F10.5)') Dscend(i) 
         End Do
         close(2) 

	End Subroutine DataGenerate_old


! /---------------------------------------------------------------\
! |*** Generate Data for only one series
! \---------------------------------------------------------------/

        Subroutine DataGenerate1(filename1, filename2)

! Arguments

	 Character(*) :: filename1, filename2

! Variables

	 Integer i
         Real	      :: temp1, temp2, temp3

         lonDA(1) = lonDA0
         tDA(1)   = tDA0

         If (lonDA(1) < -PI) lonDA(1) = 2.0*PI + lonDA(1)
   	 print *, 'lonDA0=', lonDA0

	 Do i = 2, nt
            lonDA(i) = lonDA(i-1) - c0*tau0
            If (lonDA(i) < -PI) lonDA(i) = 2.0*PI + lonDA(i)
            tDA(i) = tDA0 + i*tau0
            temp1 = lonDA(i)
            temp2 = tDA(i)
            DAcend(nt+1-i) = DataField(temp1, lat, temp2) 
         End Do
         temp1 = lonDA(1)
         temp2 = tDA(1)
         DAcend(nt) = DataField(temp1, lat, temp2) 

         open(2, file=filename1, status="replace")
   	 write(2, '(4A10)') 'lonDA',  'tDA'
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(2F10.5)') lonDA(i), tDA(i)
         End Do
         close(2) 

         open(2, file=filename2, status="replace")
   	 write(2, '(4A10)') 'sDA', 'rDA', 'DAcend'  
   	 write(2, *) nt 
	 Do i = 1, nt
   	   write(2, '(4F10.5)') sDA(i), rDA(i), DAcend(i)  
         End Do
         close(2) 

	End Subroutine DataGenerate1


d1093 3
@


1.2
log
@with selected pressure levels
@
text
@d27 1
a27 1
   "$Id: DailyMapModule.f90,v 1.1 2001/02/27 20:52:39 ybj Exp $"
d618 2
a619 2
	   l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikr(j))
	   l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikr(j))
d748 2
a749 2
	   l3sp%l3spRelValue(iLv, iLt, wIndex+1, fNum(wIndex)) = real(phikr(j))
	   l3sp%l3spImgValue(iLv, iLt, wIndex+1, fNum(wIndex)) = aimag(phikr(j))
d1250 3
@


1.1
log
@FFSM Process
@
text
@d27 2
a28 2
   "$Id: main_func.f90,v 1.1 2000/10/05 18:17:41 nakamura Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName="$RCSfile: main_func.f90,v $"
d87 1
a87 1
	  Real (r8)    ::  lonD0_i, tD0_i, lonA0_i, tA0_i, lat_i, delTad_i
d124 2
d148 2
d554 1
a554 1
 	  mtotal = 0
d561 1
d563 1
a563 3
     	       mtotal = mtotal + 1

      	       wn(mtotal) = float(m1)
d568 1
a568 1
               sigma(mtotal) = -ks*sina + kr*cosa
d581 1
a581 1
     	       phikra(mtotal) = phida 
d584 1
a584 1
      	       if( phikra(mtotal) /= CMPLX(0.0, 0.0) ) flag = 1
d592 1
a592 1
                  if (flag == 0 .and. mtotal > 0) mtotal = mtotal-1
d602 1
a602 1
     	       phikra(mtotal) = phida 
d613 2
a614 2
	 do j = 1, mtotal
	   wIndex = int(wn(j))
d617 1
a617 1
	   l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigma(j)
d683 1
a683 1
 	  mtotal = 0
d691 1
a691 1
     	       mtotal = mtotal + 1
d693 1
a693 1
      	       wn(mtotal) = float(m1)
d698 1
a698 1
               sigma(mtotal) = -ks*sina + kr*cosa
d711 1
a711 1
     	       phikrd(mtotal) = phida 
d714 1
a714 1
      	       if( phikrd(mtotal) /= CMPLX(0.0, 0.0) ) flag = 1
d722 1
a722 1
                  if (flag == 0 .and. mtotal > 0) mtotal = mtotal-1
d732 1
a732 1
     	       phikrd(mtotal) = phida 
d743 2
a744 2
	 do j = 1, mtotal
	   wIndex = int(wn(j))
d747 1
a747 1
	   l3sp%frequency(iLv, iLt, fNum(wIndex)) = sigma(j)
d866 1
a866 1
  		do j = 1, mtotal 
d868 2
a869 2
        	  kr     = wn(j)*sina+sigma(j)*cosa
        	  ks     = wn(j)*cosa-sigma(j)*sina
d871 2
a872 2
        	  argp = (wn(j)*ep + sigma(j)*xtime) + kr*(rda0-rp)
        	  argm = (wn(j)*em + sigma(j)*xtime) + kr*(rda0-rm)
d897 1
a897 1
  		do j = 1, mtotal 
d899 2
a900 2
        	  kr     = wn(j)*sina+sigma(j)*cosa
        	  ks     = wn(j)*cosa-sigma(j)*sina
d902 2
a903 2
        	  argp = (wn(j)*ep + sigma(j)*xtime) + kr*(rda0-rp)
        	  argm = (wn(j)*em + sigma(j)*xtime) + kr*(rda0-rm)
d928 1
a928 1
        Subroutine Diagnostics(ctype, xtime, nlons, xlon, result)
d932 1
a932 3
	  integer ctype, nlons

	  real  xtime
d934 2
a935 1
	  real(r8), Dimension(nlons) :: xlon, result
d941 1
a941 1
	  real	kr, ks
d943 2
a944 2
	  real  xloni, eoff, rp, rm, argp, argm, ep, em, sum 
	  real  argpa, argpd, argma, argmd
d949 130
d1249 4
a1252 1
! $Log: main_func.f90,v $
@

