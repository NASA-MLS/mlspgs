head	2.8;
access;
symbols
	v5-02-NRT-19:2.8
	v6-00:2.8
	v5-02-NRT-18:2.8
	v5-02:2.8
	v5-01-NRT-17:2.8
	v5-01-NRT-16:2.8
	v5-01-NRT-15:2.8
	v5-01-NRT-14:2.8
	neuralnetworks-1-0:2.8.0.10
	cfm-single-freq-0-1:2.8.0.8
	v5-01:2.8
	v5-00:2.8
	v4-23-TA133:2.8.0.6
	mus-emls-1-70:2.8.0.4
	rel-1-0-englocks-work:2.8.0.2
	VUMLS1-00:2.7
	VPL1-00:2.7
	V4-22-NRT-08:2.7
	VAM1-00:2.7
	V4-21:2.7.0.2
	V4-13:2.7
	V4-12:2.7
	V4-11:2.7
	V4-10:2.7
	V3-43:2.6
	M4-00:2.7
	V3-41:2.6
	V3-40-PlusGM57:2.6.0.2
	V2-24-NRT-04:2.3
	V3-33:2.6
	V2-24:2.3
	V3-31:2.6
	V3-30-NRT-05:2.6
	cfm-01-00:2.6
	V3-30:2.6
	V3-20:2.6
	V3-10:2.6
	V2-23-NRT-02:2.3
	V2-23:2.3
	V2-22-NRT-01:2.3
	V2-22:2.3
	V2-21:2.3
	V2-20:2.3
	V2-11:2.3
	V2-10:2.3
	V2-00:2.3;
locks; strict;
comment	@# @;


2.8
date	2017.10.31.23.49.36;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2011.05.09.17.54.29;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2008.05.02.00.46.56;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2007.11.29.23.28.22;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2005.09.03.01.21.59;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2005.08.06.01.41.10;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2005.08.03.02.31.08;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.8
log
@Make Coefficients a parameterized type
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module ScanAverage_m
  use MLSKinds, only: RP, RV

  implicit NONE
  private

  public ScanAverage

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: ScanAverage_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  interface ScanAverage
    module procedure ScanAverage_1d, ScanAverage_2d
  end interface

  integer, parameter :: NG = 8 ! Order of Gauss quadrature
  real(rp), parameter :: GX(ng) = (/ &          ! Gauss abscissae
    & -.960289856497536231684_rp, -.796666477413626739592_rp, &
    & -.525532409916328985818_rp, -.183434642495649804939_rp, &
    & 0.183434642495649804939_rp, 0.525532409916328985818_rp, &
    & 0.796666477413626739592_rp, 0.960289856497536231684_rp /)
  real(rp), parameter :: GW(ng) = 0.5_rp * (/ & ! Gauss weights
    & 0.101228536290376259153_rp, 0.222381034453374470544_rp, &
    & 0.313706645877887287338_rp, 0.362683783378361982965_rp, &
    & 0.362683783378361982965_rp, 0.313706645877887287338_rp, &
    & 0.222381034453374470544_rp, 0.101228536290376259153_rp /)

contains

  ! ---------------------------------------------  ScanAverage_1d  -----
  subroutine ScanAverage_1d ( MIF_Times, DeadTime, Chi_In, Chi_Out, Y_in, &
    &                         Y_Out, DY_DX_Out )
    ! Average over each MIF.  Assume linear motion during the MIF.
    ! Assume the MIFs begin at MIF_Times + deadTime.

    use MLSFILLVALUES, only: ISNAN
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
    use MLSNUMERICS, only: INTERPOLATEVALUES

    real(rv), intent(in) :: MIF_Times(:)   ! MIF starts here + deadTime
    real(rv), intent(in) :: DeadTime ! How much of each MIF is not collecting data
    real(rp), intent(in) :: Chi_In(:)   ! For Y_In
    real(rp), intent(in) :: Chi_Out(:)  ! For Y_Out.  Same size as MIF_Times
    real(rp), intent(in) :: Y_In(:)     ! Quantity to be scan averaged
                                        ! size(Chi_in)
    real(rp), intent(out) :: Y_Out(:)   ! Scan averaged quantity
                                        ! size(Chi_out)
    real(rp), intent(out), optional :: DY_DX_Out(:)

    integer :: I ! Subscript and loop inductor

    real(rp), dimension(ng*size(chi_out)) :: X     ! Quadrature abscissae
    real(rp), dimension(ng*size(chi_out)) :: Y, DY ! Quadrature ordinates

    call scanAverage_prep ( MIF_Times, deadTime, chi_out, x )

    if ( present(dY_dX_out) ) then
      ! Interpolate from (Chi_In,Y_in) to (x,y) and to (x,dy)
      call interpolateValues ( chi_in, y_in, x, y, &
                             & METHOD='S', extrapolate='C', dYbYdX=dY )
      if ( any(isNaN(y)) ) &
        & call MLSMessage( MLSMSG_Warning, ModuleName // 'ScanAverage_1D', &
        & 'NaNs returned by 1st interpolation' )
      ! Integrate panels of y and dy
      do i = 1, size(y_out)
        y_out(i) = dot_product(y(1+(i-1)*ng:i*ng),gw)
        dy_dx_out(i) = dot_product(dy(1+(i-1)*ng:i*ng),gw)
      end do
    else
      ! Interpolate from (Chi_In,Y_in) to (x,y)
      call interpolateValues ( chi_in, y_in, x, y, &
                             & METHOD='S', extrapolate='C' )
      if ( any(isNaN(y)) ) &
        & call MLSMessage( MLSMSG_Warning, ModuleName // 'ScanAverage_1D', &
        & 'NaNs returned by 2nd interpolation' )
      ! Integrate panels of y
      do i = 1, size(y_out)
        y_out(i) = dot_product(y(1+(i-1)*ng:i*ng),gw)
      end do
    end if

  end subroutine ScanAverage_1d

  ! ---------------------------------------------  ScanAverage_2d  -----
  subroutine ScanAverage_2d ( MIF_Times, DeadTime, Chi_In, Chi_Out, Y_in, &
    &                         Y_Out, DY_DX_Out )
    ! Average over each MIF.  Assume linear motion during the MIF.
    ! Assume MIF_Times are midway between T1 and T2-deadTime, where T1 and
    ! T2 are the beginning and ending times for MIF integration.

    use MLSNUMERICS, only: Coefficients, INTERPOLATEARRAYSETUP, &
      & INTERPOLATEARRAYTEARDOWN, INTERPOLATEVALUES

    real(rv), intent(in) :: MIF_Times(:) ! MIF starts here + deadTime
    real(rv), intent(in) :: DeadTime ! How much of each MIF is not collecting data
    real(rp), intent(in) :: Chi_In(:)   ! For Y_In
    real(rp), intent(in) :: Chi_Out(:)  ! For Y_Out.  Same size as MIF_Times
    real(rp), intent(in) :: Y_In(:,:)   ! Quantity to be scan averaged
                                        ! size(Chi_in) x ???
    real(rp), intent(out) :: Y_Out(:,:) ! Scan averaged quantity
                                        ! size(Chi_out) x size(Y_in,2)
    real(rp), intent(out), optional :: DY_DX_Out(:,:)

    type(coefficients(rp)) :: Coeffs        ! to interpolate from Chi_In to X

    integer :: I, J ! Subscripts and loop inductors

    real(rp), dimension(ng*size(chi_out)) :: X     ! Quadrature abscissae
    real(rp), dimension(ng*size(chi_out)) :: Y, DY ! Quadrature ordinates

    call scanAverage_prep ( MIF_Times, deadTime, chi_out, x )

    call interpolateArraySetup ( chi_in, x, 'S', coeffs, extrapolate='C', &
      & DyByDx=present(dY_dX_out) )

    do j = 1, size(y_out,2)
      if ( present(dY_dX_out) ) then
        ! Interpolate from (Chi_In,Y_in) to (x,y) and to (x,dy)
        call interpolateValues ( coeffs, chi_in, y_in(:,j), x, y, &
                               & METHOD='S', extrapolate='C', dYbYdX=dY )
        ! Integrate panels of y and dy
        do i = 1, size(y_out)
          y_out(i,j) = dot_product(y(1+(i-1)*ng:i*ng),gw)
          dy_dx_out(i,j) = dot_product(dy(1+(i-1)*ng:i*ng),gw)
        end do
      else
        ! Interpolate from (Chi_In,Y_in) to (x,y)
        call interpolateValues ( coeffs, chi_in, y_in(:,j), x, y, &
                               & METHOD='S', extrapolate='C' )
        ! Integrate panels of y
        do i = 1, size(y_out)
          y_out(i,j) = dot_product(y(1+(i-1)*ng:i*ng),gw)
        end do
      end if
    end do

    call interpolateArrayTeardown ( coeffs )

  end subroutine ScanAverage_2d

  ! ---------------------------------------------  ScanAverage_Prep  -----
  subroutine ScanAverage_Prep ( MIF_Times, DeadTime, Chi_Out, X, Pos1P )
    ! Average over each MIF.  Assume linear motion during the MIF.
    ! Assume MIF_Times are midway between T1 and T2-deadTime, where T1 and
    ! T2 are the beginning and ending times for MIF integration.

    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use MLSNUMERICS, only: INTERPOLATEVALUES
    use SORT_M, only: SORTP

    real(rv), intent(in) :: MIF_Times(:) ! MIF starts here + deadTime
    real(rv), intent(in) :: DeadTime ! How much of each MIF is not collecting data
    real(rp), intent(in) :: Chi_Out(:)  ! For Y_Out.  No larger than MIF_Times
    real(rp), intent(out) :: X(:)       ! Quadrature abscissae
    real(rp), intent(in), optional :: Pos1P(:) ! Positions (Chi) at MIF_Times.
                                        ! If present, Chi_Out is assumed to be
                                        ! Pos2P.  Size(Chi_Out).

    integer :: I     ! Subscript and loop inductor
    integer :: N     ! Size(chi_Out)

    real(rp), dimension(ng*size(chi_out)) :: T     ! Quadrature abscissae
    real(rp), dimension(size(chi_out)) :: TB, TE   ! Bounding times
    real(rp), dimension(size(chi_out)) :: TBAR     ! Time at Chi_Out

    ! If Pos1P is present
    integer, dimension(:), pointer :: I_POS
    real(rp), dimension(:), pointer :: X_POS, T_POS

    n = size(chi_out)
    ! Integration start times for each MIF
    tb = MIF_Times(:n) + deadTime
    ! Integration end times for each MIF
    te(1:n-1) = MIF_Times(2:n)
    te(n) = 2.0*MIF_Times(n) - MIF_Times(n-1)
    ! Times corresponding to Chi_Out
    tbar(1:n-1) = 0.5 * ( MIF_Times(1:n-1) + MIF_Times(2:n) )
    tbar(n) = 0.5 * ( MIF_Times(n) + te(n) )
    ! Times at quadrature abscissae
    do i = 1, n
      t(1+(i-1)*ng:i*ng) = 0.5 * ( tb(i) + te(i) + ( te(i) - tb(i) ) * gx )
    end do

    if ( present(pos1P) ) then
      call allocate_test ( i_pos, 2*size(chi_out), 'I_Pos', moduleName )
      call allocate_test ( t_pos, 2*size(chi_out), 'T_Pos', moduleName )
      call allocate_test ( x_pos, 2*size(chi_out), 'X_Pos', moduleName )
      x_pos(1:n) = chi_out
      x_pos(n+1:) = pos1P
      t_pos(1:n) = tbar
      t_pos(n+1:) = MIF_Times
      call sortp ( t_pos, 1, 2*n, i_pos )
      call interpolateValues ( t_pos(i_pos), x_pos(i_pos), t, x, &
                             & METHOD='S', extrapolate='C' )
      call deallocate_test ( i_pos, 'I_Pos', moduleName )
      call deallocate_test ( t_pos, 'T_Pos', moduleName )
      call deallocate_test ( x_pos, 'X_Pos', moduleName )
    else
      ! Interpolate from (tbar,Chi_Out) to (t,x)
      call interpolateValues ( tbar, Chi_Out, t, x, &
                             & METHOD='S', extrapolate='C' )
    end if

  end subroutine ScanAverage_Prep

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ScanAverage_m.f90,v 2.7 2011/05/09 17:54:29 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ScanAverage_m

! $Log: ScanAverage_m.f90,v $
! Revision 2.7  2011/05/09 17:54:29  pwagner
! Warns of NaNs retruned by interpolations
!
! Revision 2.6  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.5  2008/05/02 00:46:56  vsnyder
! Remove unused symbols
!
! Revision 2.4  2007/11/29 23:28:22  vsnyder
! Repair some comments
!
! Revision 2.3  2005/09/03 01:21:59  vsnyder
! Completely revised
!
! Revision 2.2  2005/08/06 01:41:10  vsnyder
! Get rid of coeffs, use trapezoid rule with endpoint corrections
!
! Revision 2.1  2005/08/03 02:31:08  vsnyder
! Initial commit
!
@


2.7
log
@Warns of NaNs retruned by interpolations
@
text
@d105 1
a105 1
    use MLSNUMERICS, only: COEFFICIENTS => COEFFICIENTS_R8, INTERPOLATEARRAYSETUP, &
d118 1
a118 1
    type(coefficients) :: Coeffs        ! to interpolate from Chi_In to X
d223 1
a223 1
       "$Id: ScanAverage_m.f90,v 2.6 2009/06/23 18:26:10 pwagner Exp $"
d233 3
@


2.6
log
@Prevent Intel from optimizing ident string away
@
text
@d13 1
a13 1
  use MLSCommon, only: RP
d22 1
a22 1
       "$RCSfile: $"
d50 3
a52 2
    use MLSCommon, only: RP, RV
    use MLSNumerics, only: InterpolateValues
d75 3
d87 3
d105 2
a106 3
    use MLSCommon, only: RP, RV
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateArraySetup, &
      & InterpolateArrayTeardown, InterpolateValues
d161 3
a163 4
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use MLSCommon, only: RP, RV
    use MLSNumerics, only: InterpolateValues
    use Sort_m, only: Sortp
d223 1
a223 1
       "$Id: read_apriori.f90 is it here $"
d233 3
@


2.5
log
@Remove unused symbols
@
text
@d22 1
a22 1
       "$RCSfile: ScanAverage_m.f90,v $"
d215 1
a216 1
!---------------------------- RCS Ident Info -------------------------------
d218 2
a219 3
       "$Id: ScanAverage_m.f90,v 2.4 2007/11/29 23:28:22 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d221 1
d223 1
d228 3
@


2.4
log
@Repair some comments
@
text
@d46 1
a46 1
    &                         Y_Out, Pos1P, DY_DX_Out )
a60 3
    real(rp), intent(in), optional :: Pos1P(:) ! Positions (Chi) at MIF_Times.
                                        ! If present, Chi_Out is assumed to be
                                        ! Pos2P
d93 1
a93 1
    &                         Y_Out, Pos1P, DY_DX_Out )
a109 3
    real(rp), intent(in), optional :: Pos1P(:) ! Positions (Chi) at MIF_Times.
                                        ! If present, Chi_Out is assumed to be
                                        ! Pos2P
d218 1
a218 1
       "$Id: ScanAverage_m.f90,v 2.3 2005/09/03 01:21:59 vsnyder Exp $"
d227 3
@


2.3
log
@Completely revised
@
text
@d31 1
a31 1
  real(rp), parameter :: GX(ng) = (/ & ! Gauss abscissae
d94 1
a94 1
  ! ---------------------------------------------  ScanAverage_1d  -----
d224 1
a224 1
       "$Id: ScanAverage_m.f90,v 2.2 2005/08/06 01:41:10 vsnyder Exp $"
d233 3
@


2.2
log
@Get rid of coeffs, use trapezoid rule with endpoint corrections
@
text
@d13 1
d30 12
d46 1
a46 1
    &                         Y_Out, DY_DX_Out )
d48 1
a48 2
    ! Assume MIF_Times are midway between T1 and T2-deadTime, where T1 and
    ! T2 are the beginning and ending times for MIF integration.
d53 1
a53 1
    real(rv), intent(in) :: MIF_Times(:)
d61 3
d66 25
a90 16
    real(rp), dimension(size(chi_out)) :: DYBDX, DYEDX ! \int YB dX, \int YE dX
!   real(rp), dimension(size(chi_out)) :: IntYBDX, IntYEDX ! \int YB dX, \int YE dX
    real(rp), dimension(size(chi_out)) :: TB, TE ! Bounding times
    real(rp), dimension(size(chi_out)) :: XB, XE ! Bounding angles
    real(rp), dimension(size(chi_out)) :: YB, YE ! Y at XB and XE

    call scanAverage_prep ( MIF_Times, deadTime, chi_out, xb, xe )

    ! Scan smooth to get the output
    call InterpolateValues ( chi_in, y_in, xb, yb, &
                           & METHOD='S', extrapolate='C', dYbYdX=dYBdX ) ! intYdx=intYbDx )
    call InterpolateValues ( chi_in, y_in, xe, ye, &
                           & METHOD='S', extrapolate='C', dYbYdX=dYEdX ) ! intYdx=intYeDx )
    y_out = 0.5 * ( yb + ye ) + (xe - xb ) * ( dyEdX - dyBdx ) / 12.0
!   y_out = intYeDx - intYbDx
    if ( present(dY_dX_out) ) dY_dX_out = ye - yb ! \int y' dx = y
d96 1
a96 1
    &                         Y_Out, DY_DX_Out )
d102 2
a103 1
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateValues
d105 1
a105 1
    real(rv), intent(in) :: MIF_Times(:)
d113 3
d118 3
a120 6
    real(rp), dimension(size(chi_out)) :: DYBDX, DYEDX ! \int YB dX, \int YE dX
!   real(rp), dimension(size(chi_out)) :: IntYBDX, IntYEDX ! \int YB dX, \int YE dX
    real(rp), dimension(size(chi_out)) :: R      ! Time or angle difference ratios
    real(rp), dimension(size(chi_out)) :: TB, TE ! Bounding times
    real(rp), dimension(size(chi_out)) :: XB, XE ! Bounding angles
    real(rp), dimension(size(chi_out)) :: YB, YE ! Y at XB and XE
d122 2
a123 1
    integer :: I     ! Subscript and loop inductor
d125 1
a125 1
    call scanAverage_prep ( MIF_Times, deadTime, chi_out, xb, xe )
d127 22
a148 10
    ! Scan smooth to get the output
    r = ( xe - xb ) / 12.0
    do i = 1, size(y_out,2)
      call InterpolateValues ( chi_in, y_in(:,i), xb, yb, &
                               & METHOD='S', extrapolate='C', dYbYdX=dYBdX ) ! intYdx=intYbDx )
      call InterpolateValues ( chi_in, y_in(:,i), xe, ye, &
                               & METHOD='S', extrapolate='C', dYbYdX=dYEdX ) ! intYdx=intYeDx )
      y_out(:,i) = 0.5 * ( yb + ye ) + r * ( dyEdX - dyBdx )
!     y_out(:,i) = intYeDx - intYbDx
      if ( present(dY_dX_out) ) dY_dX_out(:,i) = ye - yb ! \int y' dx = y
d151 2
d156 1
a156 1
  subroutine ScanAverage_Prep ( MIF_Times, DeadTime, Chi_Out, XB, XE )
d161 1
d163 4
a166 1
    real(rv), intent(in) :: MIF_Times(:)
d169 4
a172 6
    real(rp), intent(out) :: XB(:), XE(:) ! Bounding angles

    real(rp), dimension(1:size(chi_out)-4) :: A  ! Acceleration
    real(rp), dimension(2:size(chi_out)-5) :: B  ! Acceleration's moment
    real(rp), dimension(size(chi_out)-1) :: R    ! Time or angle difference ratios
    real(rp), dimension(size(chi_out)) :: TB, TE ! Bounding times
a173 1
    real(rp) :: AMAX ! Maxval(A)
a174 1
    integer :: M     ! minloc(abs(a)+abs(b))
d177 8
d186 11
a196 7

    ! Get the times at the MIF starts and ends
    tb(1) = ( 3.0 * MIF_times(1) - MIF_times(2) + deadTime ) * 0.5
    te(1) = 2.0 * MIF_Times(1) - tb(1)
    do i = 2, n
      tb(i) = 2.0 * MIF_times(i-1) - tb(i-1) + deadTime
      te(i) = 2.0 * MIF_times(i) - tb(i)
d199 19
a217 48
    ! Get the bounding angles.
    ! The accuracy depends critically upon getting a good initial condition.
    ! We choose a place where the scan acceleration is zero or velocity is
    ! most constant.
    ! Compute acceleration:
    a = ((chi_out(5:n)-chi_out(4:n-1)) / ((MIF_times(5:n)-MIF_times(4:n-1)) * &
      &                                   (MIF_times(4:n-1)-MIF_times(3:n-2))) + &
      &  (chi_out(4:n-1)-2.0*chi_out(3:n-2)+chi_out(2:n-3)) / &
      &     ((MIF_times(4:n-1)-MIF_times(3:n-2)) * &
      &      (MIF_times(3:n-2)-MIF_times(2:n-3))) - &
      &  (chi_out(2:n-3)-chi_out(1:n-4)) / ((MIF_times(3:n-2)-MIF_times(2:n-3)) * &
      &  (MIF_times(2:n-3)-MIF_times(1:n-4)))) / 4.0
    amax = maxval(a)
    ! Compute first moment of acceleration
    b = ((a(3:n-4)-a(2:n-5)) / (MIF_times(5:n-2)-MIF_times(4:n-3)) + &
      & (a(2:n-5)-a(1:n-6)) / (MIF_times(4:n-3)-MIF_times(3:n-4)))*0.5
    ! Find where acceleration + moment is minimum.  We add 2 to the index
    ! because acceleration is a second difference.
    m = minloc(abs(a(2:n-5))+abs(b),1) + 2

    ! Estimate an initial value for XB(m)
    xb(m) = chi_out(m-1) + (chi_out(m)-chi_out(m-1)) * (tb(m)-MIF_times(m-1)) / &
      &                  (MIF_times(m)-MIF_times(m-1))

    ! Get time difference ratios
    r = (tb(2:n)-tb(1:n-1)) / (MIF_times(1:n-1)-tb(1:n-1))

    ! Get XB for MIFs above M
    do i = m+1, n
      xb(i) = xb(i-1) + ( chi_out(i-1) - xb(i-1) ) * r(i-1)
    end do
    ! Get XB for MIFs below B
    do i = m-1, 1, -1
      xb(i) = ( xb(i+1) - r(i) * chi_out(i) ) / ( 1.0 - r(i) )
    end do

    ! Get XE
    xe(1:n-1) = xb(1:n-1) + ( xb(2:n) - xb(1:n-1) ) * ( te(1:n-1) - tb(1:n-1) ) / &
      &                                               ( tb(2:n)   - tb(1:n-1) )
    ! With an estimated extrapolated XE(n)
    xe(n) = xb(n) + (( chi_out(n) - xb(n) ) * ( te(n) - tb(n) ) / &
      &                                       ( MIF_times(n) - tb(n)))

    ! We could have replaced this with a simple interpolation from
    ! MIF_times, Chi_out to XB, XE at TB, TE, but that does not
    ! guarantee a constant velocity between Xb and XE, which is a
    ! requirement for the scan smoothing integration algorithm.  In
    ! practice it probably doesn't matter.
d224 1
a224 1
       "$Id: ScanAverage_m.f90,v 2.1 2005/08/03 02:31:08 vsnyder Exp $"
d233 3
@


2.1
log
@Initial commit
@
text
@d21 1
a21 1
       "$RCSfile: Convolve_All_m.f90,v $"
d32 1
a32 1
  subroutine ScanAverage_1d ( Coeffs, MIF_Times, DeadTime, Chi_In, Chi_Out, Y_in, &
d37 1
d39 2
a40 2
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateValues
    type(coefficients), intent(in) :: Coeffs ! To interpolate from Chi_In to Chi_Out
d51 2
a52 1
    real(rp), dimension(size(chi_out)) :: IntYBDX, IntYEDX ! \int YB dX, \int YE dX
d60 6
a65 5
    call InterpolateValues ( coeffs, chi_in, y_in, xb, yb, &
                           & METHOD='S', extrapolate='C', intYdx=intYbDx )
    call InterpolateValues ( coeffs, chi_in, y_in, xe, ye, &
                           & METHOD='S', extrapolate='C', intYdx=intYeDx )
    y_out = intYeDx - intYbDx
d71 1
a71 1
  subroutine ScanAverage_2d ( Coeffs, MIF_Times, DeadTime, Chi_In, Chi_Out, Y_in, &
d76 1
d79 1
a79 1
    type(coefficients), intent(in) :: Coeffs ! To interpolate from Chi_In to Chi_Out
d90 2
a91 1
    real(rp), dimension(size(chi_out)) :: IntYBDX, IntYEDX ! \int YB dX, \int YE dX
d104 6
a109 5
      call InterpolateValues ( coeffs, chi_in, y_in(:,i), xb, yb, &
                               & METHOD='S', extrapolate='C', intYdx=intYbDx )
      call InterpolateValues ( coeffs, chi_in, y_in(:,i), xe, ye, &
                               & METHOD='S', extrapolate='C', intYdx=intYeDx )
      y_out(:,i) = intYeDx - intYbDx
d120 1
d124 1
a124 1
    real(rp), intent(in) :: Chi_Out(:)  ! For Y_Out.  Same size as MIF_Times
d127 2
a128 1
    real(rp), dimension(size(chi_out)-4) :: A, B ! Acceleration, its moment
d141 1
d144 1
a145 1
    te = 2.0 * MIF_times - tb
d161 2
a162 3
    b = (/ amax, ((a(3:n-4)-a(2:n-5)) / (MIF_times(5:n-2)-MIF_times(4:n-3)) + &
      &          (a(2:n-5)-a(1:n-6)) / (MIF_times(4:n-3)-MIF_times(3:n-4)))*0.5, &
      &    amax /)
d165 1
a165 1
    m = minloc(abs(a)+abs(b),1) + 2
d179 1
a179 1
    do I = m-1, 1, -1
d184 5
a188 6
    xe = (/ xb(1:n-1) + ( xb(2:n) - xb(1:n-1) ) * ( te(1:n-1) - tb(1:n-1) ) / &
      &                 ( tb(2:n) - tb(1:n-1) ), &
      ! With an estimated extrapolated XE at N
      &     xb(n) + (( chi_out(n) - xb(n) ) * ( te(n) - tb(n) ) / &
      &              ( MIF_times(n) - tb(n))) &
      &  /)
d201 1
a201 1
       "$Id: Convolve_All_m.f90,v 2.2 2005/07/08 00:12:11 vsnyder Exp $"
d210 3
@

