head	2.2;
access;
symbols
	v5-02-NRT-19:2.2
	v6-00:2.2
	v5-02-NRT-18:2.2
	v5-02:2.2
	v5-01-NRT-17:2.2
	v5-01-NRT-16:2.2
	v5-01-NRT-15:2.2
	v5-01-NRT-14:2.2
	neuralnetworks-1-0:2.2.0.12
	cfm-single-freq-0-1:2.2.0.10
	v5-01:2.2
	v5-00:2.2
	v4-23-TA133:2.2.0.8
	mus-emls-1-70:2.2.0.6
	rel-1-0-englocks-work:2.2.0.4
	VUMLS1-00:2.2
	VPL1-00:2.2
	V4-22-NRT-08:2.2
	VAM1-00:2.2
	V4-21:2.2.0.2
	V4-13:2.2
	V4-12:2.2
	V4-11:2.2
	V4-10:2.2
	M4-00:2.2
	V3-33:2.2
	V3-31:2.2
	V3-30-NRT-05:2.1
	cfm-01-00:2.1;
locks; strict;
comment	@# @;


2.2
date	2010.11.05.20.28.53;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2010.06.07.23.15.49;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.2
log
@Delete unused declarations
@
text
@! subroutine Get_Eta_Stru_D_D ( Basis, Grid, Eta )
!   ! Compute linear interpolating coefficients from Basis to Grid. It is
!   ! assumed that Basis(:) is sorted, but it is not assumed that Grid(:)
!   ! is sorted.  It is assumed that Grid(:) changes slowly and smoothly.
!   ! It is assumed that Size(Grid) == SIze(Eta).
!   ! To interpolate from some T whose coordinates are Basis(:) to
!   ! a value corresponding to Grid(k), compute
!   ! Basis(eta(k)%l)*eta(k)%eta + Basis(eta(k)%l+1)*(1.0-eta(k)%eta).
!   ! If Grid(k) < Basis(1) then Eta(k)%L = 1 and Eta(k)%Eta = 1.0.
!   ! If Grid(k) >= Basis(size(basis)) then Eta(k)%L = size(basis-1) and
!   ! Eta(k)%Eta = 0.0.  That is, outside the range of Basis(:), constant
!   ! extrapolation is used.
!   integer, parameter :: KB = kind(0.0d0)
!   integer, parameter :: KG = kind(0.0d0)
    real(kb), intent(in) :: Basis(:)
    real(kg), intent(in) :: Grid(:)
    type(eta_d_t), intent(out) :: Eta(:)
    integer :: K, L
    l = 1
    do k = 1, size(grid)
      do ! hunt for grid(k) in Basis(:) from previous place
        if ( basis(l) <= grid(k) ) then
          if ( grid(k) < basis(l+1) ) then
            eta(k)%eta = ( basis(l+1) - grid(k) ) / &
                       & ( basis(l+1) - basis(l) )
            exit
          end if
          if ( l == size(basis,1)-1 ) then
            eta(k)%eta = 0.0
            exit
          end if
          l = l + 1
        else if ( l > 1 ) then
          l = l - 1
        else
          eta(k)%eta = 1.0
          exit
        end if
      end do ! Hunt
      eta(k)%l = l
    end do ! k
! end subroutine Get_Eta_Stru_D_D
@


2.1
log
@Initial commit
@
text
@d18 1
a18 1
    integer :: I, K, L
@

