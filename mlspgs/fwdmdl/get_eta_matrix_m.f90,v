head	2.39;
access;
symbols
	v5-02-NRT-19:2.39
	v6-00:2.39
	v5-02-NRT-18:2.39
	v5-02:2.39
	v5-01-NRT-17:2.39
	v5-01-NRT-16:2.39
	v5-01-NRT-15:2.39
	v5-01-NRT-14:2.39
	neuralnetworks-1-0:2.39.0.6
	cfm-single-freq-0-1:2.39.0.4
	v5-01:2.39
	v5-00:2.39
	v4-23-TA133:2.39.0.2
	mus-emls-1-70:2.36.0.2
	rel-1-0-englocks-work:2.32.0.2
	VUMLS1-00:2.27
	VPL1-00:2.26
	V4-22-NRT-08:2.26
	VAM1-00:2.26
	V4-21:2.26.0.2
	V4-13:2.26
	V4-12:2.26
	V4-11:2.26
	V4-10:2.26
	V3-43:2.22
	M4-00:2.25
	V3-41:2.22
	V3-40-PlusGM57:2.22.0.2
	V2-24-NRT-04:2.17
	V3-33:2.23
	V2-24:2.17
	V3-31:2.23
	V3-30-NRT-05:2.23
	cfm-01-00:2.23
	V3-30:2.22
	V3-20:2.22
	V3-10:2.22
	V2-23-NRT-02:2.17
	V2-23:2.17
	V2-22-NRT-01:2.17
	V2-22:2.17
	V2-21:2.11
	V2-20:2.11
	V2-11:2.11
	V2-10:2.11
	V2-00:2.9
	V1-51:2.5
	V1-50:2.5
	V1-45:2.5
	V1-44:2.5
	V1-43:2.5
	V1-32:2.5
	V1-31:2.5
	V1-30:2.5
	V1-13:2.4
	V1-12:2.4
	V1-11:2.3
	V1-10:2.3
	newfwm-feb03:2.3.0.2
	V1-04:2.0
	V1-03:2.0
	V1-02:2.0
	JointForwardModel:2.0.0.2
	V1-00:2.0
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.39
date	2018.09.13.00.16.25;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2018.09.12.23.48.08;	author vsnyder;	state dead;
branches;
next	2.37;

2.37
date	2018.08.07.18.10.15;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2018.05.17.01.55.00;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2018.05.14.23.30.19;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2018.04.26.02.58.13;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2018.04.26.00.09.38;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2018.03.21.01.58.10;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2017.11.21.00.03.42;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2017.09.20.01.06.04;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2017.06.01.22.50.25;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2017.05.24.20.29.49;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2016.10.18.00.29.13;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2013.05.13.23.40.52;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2013.02.28.21.06.42;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2011.06.23.01.13.31;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2010.06.07.23.17.20;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.21;

2.21
date	2009.04.17.22.41.26;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2009.01.16.23.44.15;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2008.10.14.20.59.16;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2008.10.13.23.42.28;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2007.06.25.20.36.08;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2007.06.06.01.15.43;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2007.01.20.01.06.39;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2007.01.19.02.38.29;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2006.12.13.21.53.11;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2006.12.09.02.23.45;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2006.06.29.02.51.30;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2006.06.29.01.44.02;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2005.12.23.03.12.42;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2005.12.22.20.55.16;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2005.12.10.01.52.44;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2003.06.20.02.02.11;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2003.03.21.17.02.19;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2002.10.08.17.08.04;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2002.09.06.20.50.28;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2002.09.06.18.17.19;	author vsnyder;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.10.09.42;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.10.10.09.42;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.10.10.25.05;	author zvi;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.12.21.38.49;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.39
log
@Mistakenly moved to the attic
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Get_Eta_Matrix_m

  use MLSKinds, only: RP, IP

  implicit NONE

  private
  public :: Eta_D_T, Eta_S_T
  public :: Clean_Out_Nonzeros, Dump, Dump_Eta_Column_Sparse, Dump_Eta_Transpose
  public :: Eta_Func, Eta_Func_1d, Eta_Func_2d
  public :: Get_Column_Sparsity
  public :: Get_Eta_Column_Sparse, Get_Eta_Column_Sparse_fl_nz, Get_Eta_Sparse
  public :: Get_Eta_Sparse_1d, Get_Eta_Sparse_1d_fl, Get_Eta_Sparse_1d_nz
  public :: Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_fl, Get_Eta_Sparse_2d_fl_nz
  public :: Get_Eta_Sparse_2d_nz
  public :: Get_Eta_Stru, Get_Eta_Stru_D_D, Get_Eta_Stru_D_S, Get_Eta_Stru_S_S
  public :: Get_Eta_1d_Hunt, Get_Eta_ZP
  public :: Interpolate_Stru
  public :: Interpolate_Stru_1D_D, Interpolate_Stru_1D_S
  public :: Interpolate_Stru_2D_D, Interpolate_Stru_2D_S
  public :: Multiply_Eta_Column_Sparse
  public :: Select_NZ_List

  interface Dump
    module procedure Dump_Eta_Column_Sparse, Dump_Eta_Transpose
  end interface

  interface Eta_Func
    module procedure Eta_Func_1d, Eta_Func_2d
  end interface Eta_Func

  interface Get_Eta_Sparse
    module procedure Get_Eta_Column_Sparse, Get_Eta_Column_Sparse_fl_nz
    module procedure Get_Eta_Sparse_1d, Get_Eta_Sparse_1d_fl, Get_Eta_Sparse_1d_nz
    module procedure Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_fl, Get_Eta_Sparse_2d_nz
    module procedure Get_Eta_Sparse_2d_fl_nz
  end interface

  interface Get_Eta_Stru
    module procedure Get_Eta_Stru_D_D, Get_Eta_Stru_D_S, Get_Eta_Stru_S_S
  end interface

  interface Interpolate_Stru
    module procedure Interpolate_Stru_1D_D, Interpolate_Stru_1D_S
    module procedure Interpolate_Stru_2D_D, Interpolate_Stru_2D_S
  end interface

  type :: Eta_S_T
    integer :: L
    real :: Eta
  end type Eta_S_T

  type :: Eta_D_T
    integer :: L
    double precision :: Eta
  end type Eta_D_T

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: get_eta_matrix_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains

! -------------------------------------------  Clean_Out_Nonzeros  -----
  subroutine Clean_Out_Nonzeros ( Eta_Array, Do_Calc, NZ, NNZ )
    ! Clean out old nonzeros in Eta_Array and old true values in Do_Calc
    use MLSKinds, only: RP
    real(rp), intent(inout) :: Eta_Array(:,:)
    logical, intent(inout), optional :: Do_Calc(:,:) ! Same shape as Eta_Array
    integer, intent(inout), optional :: NZ(:,:)      ! Row subscripts of nonzeros
    integer, intent(inout), optional :: NNZ(:)       ! How many nonzeros in a column
    integer :: I
    if ( present(nz) ) then
      do i = 1, size(eta_array,2)
        eta_array(nz(:nnz(i),i),i) = 0
        if ( present(do_calc) ) do_calc(nz(:nnz(i),i),i) = .false.
        nnz(i) = 0
      end do
    else
      eta_array = 0
      if ( present(do_calc) ) do_calc=.false.
    end if
  end subroutine Clean_Out_Nonzeros

! ---------------------------------------  Dump_Eta_Column_Sparse  -----
  subroutine Dump_Eta_Column_Sparse ( Eta, Nz, NNz, Grids_f, Name, Short, &
    & Show_Z, ZP_only, Small, Width, WhichSps )
    use Array_Stuff, only: Subscripts
    use Dump_0, only: Dump
    use intrinsic, only: Lit_Indices
    use Load_SPS_Data_m, only: Grids_t
    use Output_m, only: Blanks, NewLine, Output
    use String_Table, only: Display_String
    real(rp), intent(in) :: Eta(:,:)
    integer, intent(in) :: Nz(:,:) ! Nonzeroes in each column
    integer, intent(in) :: NNz(:)  ! Number of nonzeroes in each column
    type (grids_t), intent(in) :: Grids_f ! to compute subscripts
    character(len=*), intent(in), optional :: Name
    logical, intent(in), optional :: Short   ! "Don't print zero columns", default false
    logical, intent(in), optional :: Show_Z  ! "Print zeroes", default false
    logical, intent(in), optional :: ZP_Only ! No Freq coordinate for Eta cols
    real(rp), intent(in), optional :: Small  ! Don't print smaller values
    integer, intent(in), optional :: Width   ! How many nonzeros per line
    integer, intent(in), optional :: WhichSps ! Which species to dump
    integer :: Dims(4), I, J, J1, J2, L, MySps, MyWidth
    integer :: Places, Sps, Subs(4)
    logical :: MyShort, MyShow_Z, MyZP
    real(rp) :: MySmall
    logical :: Saw_NZ

    myShort = .false.
    if ( present(short) ) myShort = short
    myShow_Z = .false.
    if ( present(show_Z) ) myShow_Z = show_Z
    myZP = .false.
    if ( present(ZP_Only) ) myZP = ZP_Only
    mySmall = 0
    if ( present(small) ) mySmall = small
    myWidth = 5
    if ( present(width) ) myWidth = width
    mySps = -1
    if ( present(whichSps) ) mySps = whichSps

    j2 = 0
    do sps = 1, ubound(grids_f%l_v,1)
      j1 = j2
      if ( myZP ) then
        j2 = grids_f%l_zp(sps)
        dims = [ size(eta,1), &
               & grids_f%l_z(sps) - grids_f%l_z(sps-1), &
               & grids_f%l_p(sps) - grids_f%l_p(sps-1), 1 ]
      else
        j2 = grids_f%l_v(sps)
        dims = [ size(eta,1), &
               & grids_f%l_f(sps) - grids_f%l_f(sps-1), &
               & grids_f%l_z(sps) - grids_f%l_z(sps-1), &
               & grids_f%l_p(sps) - grids_f%l_p(sps-1) ]
      end if
      if ( mySps > 0 .and. sps /= mySps ) cycle
      if ( present(name) ) then
        call output ( name )
        call blanks ( 1 )
      end if
      if ( grids_f%mol(sps) /= 0 ) then
        call display_string ( lit_indices(grids_f%mol(sps)) )
        call blanks ( 1 )
      end if
      if ( grids_f%l_f(sps) - grids_f%l_f(sps-1) > 1 ) &
        call output ( 'frequency dependent ' )
      if ( grids_f%qty(sps) > 0 ) then
        call display_string ( lit_indices(grids_f%qty(sps)), &
          & before='quantity: ' )
        call blanks ( 1 )
      end if
      call showList ( dims, dims, '')
      dims = [dims(2:), 1]
      call output ( ' state-vector-index ( path-index eta )*', advance='yes' )
      if ( all(nnz(j1+1:j2) == 0) ) then
        call output ( j1+1, before='Columns ' )
        call output ( j2, before=':' )
        call output ( ' are zero', advance='yes' )
        cycle
      end if
      do j = j1+1, j2 ! Corresponds to elements of grids_f%l_v...
        if ( myShort .and. nnz(j) == 0 ) cycle
        subs = subscripts ( j-j1, dims )
        if ( nnz(j) == size(eta,1) ) then
          call output ( 'All rows in column ' )
          call showList ( dims, subs, ' are nonzero')
          call dump ( eta(nz(:nnz(j),j),j), name='Values' )
        else
          places = 5
          places = sum(int(log10(real(subs)))) + count(dims/=1) + 3
          l = 0
          saw_nz = .false.
          do i = 1, nnz(j)
            if ( .not. myShow_Z .and. abs(eta(nz(i,j),j)) <= mySmall ) cycle
            if ( abs(eta(nz(i,j),j)) > mySmall .or. myShow_Z ) then
              if ( .not. saw_nz ) call showList ( dims, subs, '')
              saw_nz = .true.
              l = l + 1
              if ( l > myWidth ) then
                l = 1
                call newLine
                call blanks ( places )
              end if
              call output ( nz(i,j), format='(i4)' )
              call output ( eta(nz(i,j),j), format='(1pg14.6)' )
            end if
          end do
          if ( saw_nz ) call newLine
        end if
      end do
    end do
  contains
    subroutine ShowList ( Dims, Subs, After )
    use Output_m, only: Output
    ! Print "(" subs where dims/=1 ")"
    integer, intent(in) :: Dims(:), Subs(:)
    character(*), intent(in) :: After
    integer :: S
    do s = 1, size(subs)-1
      if ( dims(s) /= 1 ) exit
    end do
    call output ( subs(s), before="(" )
    do while ( s < size(subs) )
      s = s + 1
      if ( dims(s) /= 1 ) call output ( subs(s), before="," )
    end do
    call output ( ")" )
    end subroutine ShowList
  end subroutine Dump_Eta_Column_Sparse

! -------------------------------------------  Dump_Eta_Transpose  -----
  subroutine Dump_Eta_Transpose ( Eta, NPF, Grids_f, Name, N, Width, ZP_Only, &
                                & DoBig, P_only )
    use intrinsic, only: Lit_Indices
    use Load_SPS_Data_m, only: Grids_t
    use Output_m, only: Blanks, NewLine, Output
    use String_Table, only: Display_String
    real(rp), intent(in), contiguous, target :: Eta(:,:)
    integer, intent(in) :: NPF               ! Fine path length = how much
                                             ! of first dimension of Eta to use
    type (grids_t), intent(in) :: Grids_f    ! to compute subscripts
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: N       ! Which species to dump
    integer, intent(in), optional :: Width   ! How many per line, default 5
    logical, intent(in), optional :: ZP_Only ! Eta has no frequency spread
    logical, intent(in), optional :: DoBig   ! Show subs for entire state vector
    logical, intent(in), optional :: P_only  ! Second dimension of Eta is P,
                                             ! not Z, overrides ZP_Only
    integer :: Dims(4,ubound(grids_f%l_z,1))
    real(rp), pointer :: Eta3(:,:,:)
    logical :: FrqDep(ubound(grids_f%l_v,1))
    integer :: I, J, J2(0:ubound(grids_f%l_z,1)), K, L, N1, N2, NC, Sps, W
    integer :: BigSubs(3) ! In entire state vector
    integer :: Subs(3)    ! Only within one species
    equivalence ( subs(1), j ), ( subs(2), k ), (subs(3), l )
    logical :: MyBig, MyP, MyZP, SawNZ
    integer :: MyWidth

    myWidth = 5
    if ( present(width) ) myWidth = width
    myZP = .false.
    if ( present(ZP_Only) ) myZP = ZP_Only
    myBig = .false.
    if ( present(doBig) ) myBig = .true.
    myP = .false.
    if ( present(p_only) ) myP = p_only
    n1 = 1
    n2 = ubound(grids_f%l_z,1)
    if ( myP ) n2 = ubound(grids_f%l_p,1)
    if ( present(n) ) then
      n1 = min(n,n2)
      n2 = n1
    end if
    j2(0) = 0
    do sps = 1, n2
      frqDep(sps) = grids_f%l_f(sps) - grids_f%l_f(sps-1) > 1
      if ( myP ) then
        dims(:,sps) = [ npf, &
                      & grids_f%l_p(sps) - grids_f%l_p(sps-1), 1, 1 ]
        j2(sps) = j2(sps-1) + dims(2,sps)
      else if ( myZP .or. .not. frqDep(sps) ) then
        dims(:,sps) = [ npf, &
                      & grids_f%l_z(sps) - grids_f%l_z(sps-1), &
                      & grids_f%l_p(sps) - grids_f%l_p(sps-1), 1 ]
        j2(sps) = j2(sps-1) + dims(2,sps) * dims(3,sps)
      else
        dims(:,sps) = [ npf, &
                      & grids_f%l_f(sps) - grids_f%l_f(sps-1), &
                      & grids_f%l_z(sps) - grids_f%l_z(sps-1), &
                      & grids_f%l_p(sps) - grids_f%l_p(sps-1) ]
        j2(sps) = j2(sps-1) + dims(2,sps) * dims(3,sps) * dims(4,sps)
      end if
    end do
    do sps = n1, n2
      nc = 3 ! Upper bound of useful part of dims(sps,:)
      if ( frqDep(sps) ) nc = 4
      if ( myP ) then
        nc = 2
      else if ( myZP ) then
        nc = 3
      end if
      if ( present(name) ) then
        call output ( name )
        call blanks ( 1 )
      end if
      if ( grids_f%mol(sps) /= 0 ) then
        call display_string ( lit_indices(grids_f%mol(sps)) )
        call blanks ( 1 )
      end if
      if ( frqDep(sps) ) call output ( 'frequency dependent ' )
      if ( grids_f%qty(sps) > 0 ) then
        call display_string ( lit_indices(grids_f%qty(sps)), &
          & before='quantity: ' )
        call blanks ( 1 )
      end if
      call showList ( dims(:nc,sps) )
      call output ( ' state-vector-index ( path-index eta )*', advance='yes' )
      do i = 1, npf ! path length
        sawNZ = .false.
        w = 0
        eta3(1:dims(2,sps),1:dims(3,sps),1:dims(4,sps)) => eta(i,j2(sps-1)+1:j2(sps))
        do l = 1, size(eta3,3)
          do k = 1, size(eta3,2)
            do j = 1, size(eta3,1)
              if ( eta3(j,k,l) /= 0 ) then
                if ( .not. sawNZ ) call output ( i, places=4, after='#' )
                sawNZ = .true.
                if ( w >= myWidth ) then
                  call newLine
                  call blanks ( 5 )
                  w = 0
                end if
                w = w + 1
                if ( myBig ) then ! Show Grids_f%v subscripts as if it were 4D
                  if ( myZP ) then
                    bigSubs(1) = subs(1) + grids_f%l_z(sps-1)
                    bigSubs(2) = subs(2) + grids_f%l_p(sps-1)
                  else if ( .not. frqDep(sps) ) then
                    bigSubs(1) = subs(2) + grids_f%l_z(sps-1)
                    bigSubs(2) = subs(3) + grids_f%l_p(sps-1)
                    nc = 3
                  else
                    bigSubs(1) = subs(1) + grids_f%l_f(sps-1)
                    bigSubs(2) = subs(2) + grids_f%l_z(sps-1)
                    bigSubs(3) = subs(3) + grids_f%l_p(sps-1)
                  end if
                  call showlist ( bigSubs(:nc-1) )
                else ! Show subscripts for one species as if in Vector_T%value3
                  call showlist ( subs(:nc-1) )
                end if
                call output ( eta3(j,k,l),  format='(1x,1pg14.6)' )
              end if
            end do
          end do
        end do
        if ( sawNZ ) call newLine
      end do
    end do
  contains
    subroutine ShowList ( A )
      integer, intent(in) :: A(:)
      integer :: S
      call output ( a(1), before=' (' )
      do s = 2, size(a)
        call output ( a(s), before=',' )
      end do
      call output ( ")" )
    end subroutine ShowList
  end subroutine Dump_Eta_Transpose

! ---------------------------------  ShowList (for dump routines)  -----
  subroutine ShowList ( J, Dims, Subs, After, Grids_f )
    use Load_SPS_Data_m, only: Grids_t
    use Output_m, only: Output
    ! Print "(" subs where dims/=1 ")"
    integer, intent(in) :: J, Dims(4), Subs(4)
    character(*), intent(in) :: After
    type (grids_t), intent(in), optional :: Grids_f ! to compute subscripts
    integer :: S
    if ( present(grids_f) ) then
      do s = 1, 3
        if ( dims(s) /= 1 ) exit
      end do
      call output ( subs(s), before="(" )
      do while ( s < 4 )
        s = s + 1
        if ( dims(s) /= 1 ) call output ( subs(s), before="," )
      end do
      call output ( ")" )
    else
      call output ( j, places=4, after=after )
    end if
  end subroutine ShowList

! --------------------------------------------------  Eta_Func_1d  -----
  pure function Eta_Func_1d ( Basis, Grid_Pt ) result ( Eta )

! Compute the eta matrix

! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid_pt  ! grid point

! Outputs

    real(rp) :: Eta(size(basis))

! Internals

    integer(ip) :: J, N_coeffs
    real(rp) :: Del_basis

! The first coefficient is one for all values of grid_pt below basis(1)
! until grid_pt = basis(1),then it ramps down in the usual triangular sense.
! J is the coefficient index.

    n_coeffs = size(basis)
    eta = 0.0_rp

! first basis calculation

    if ( grid_pt <= basis(1) ) eta(1) = 1.0_rp

! Normal triangular function for j=2 to j=n_coeffs-1

    do j = 2 , n_coeffs
      del_basis = basis(j) - basis(j-1)
      if ( grid_pt <= basis(j) .and. &
        &  basis(j-1) <= grid_pt ) then
        eta(j-1) = (basis(j) - grid_pt) / del_basis
        eta(j) =   (grid_pt - basis(j-1)) / del_basis
      end if
    end do

! last basis calculation

    if ( grid_pt > basis(n_coeffs) ) eta(n_coeffs) = 1.0_rp

  end function Eta_Func_1d

! ------------------------------------------  Get_Column_Sparsity  -----
  subroutine Get_Column_Sparsity ( A, Nz, NNz )
    ! This isn't very efficient because it fills Nz and NNz with zeroes.
    ! If one knew that they had been filled with zeroes ab initio, and then
    ! kept properly, one could make Nz and NNz intent(inout) and use NNz
    ! to put zeroes into Nz.
    real(rp), intent(in) :: A(:,:)
    integer, intent(out) :: Nz(:,:) ! Nonzeroes in each column
    integer, intent(out) :: NNz(:)  ! Number of nonzeroes in each column
    integer :: I, J

    nnz = 0
    do j = 1, size(a,2)
      nz(:,j) = 0
      do i = 1, size(a,1)
        if ( a(i,j) /= 0.0 ) then
          nnz(j) = nnz(j) + 1
          nz(nnz(j),j) = i
        end if
      end do
    end do

  end subroutine Get_Column_Sparsity

! ----------------------------------------------  Get_Eta_1d_Hunt  -----
  subroutine Get_Eta_1d_Hunt ( Basis, Grid_Pt, Eta, IX )
  ! Find Grid_Pt in Basis, then compute Eta(1:2).  Use constant
  ! interpolation of Grid_Pt is below or above Basis.
    use MLSNumerics, only: Hunt

  ! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid_pt  ! grid point

  ! Outputs

    real(rp), intent(out) :: Eta(2)
    integer, intent(out) :: IX ! if 1 <= IX < size(basis),
                               ! Basis(ix) <= Grid_Pt < Basis(ix+1)

  ! Internals

    integer(ip) :: N_coeffs

    if ( grid_pt < basis(1) ) then
      ix = 0
      eta = (/ 1.0, 0.0 /) ! constant extrapolation below range
      return
    end if

    n_coeffs = size(basis)
    if ( grid_pt >= basis(n_coeffs) ) then
      ix = n_coeffs
      eta = (/ 0.0, 1.0 /) ! constant extrapolation above range
      return
    end if

    ! basis(ix) <= grid_pt < basis(ix+1)
    call hunt ( basis, grid_pt, ix )
    eta(1) = ( grid_pt - basis(ix) ) / &
           & ( basis(ix+1) - basis(ix) )
    eta(2) = 1.0 - eta(1)

  end subroutine Get_Eta_1d_Hunt

!---------------------------------------------------  Eta_Func_2d  -----
  function Eta_Func_2d ( Basis, Grid, Sorted ) result ( Eta )

! Compute the eta matrix

    use Sort_m, only: SortP
! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    logical, optional, intent(in) :: Sorted ! "Grid is sorted"

! Outputs

    real(rp) :: Eta(size(grid),size(basis))

! Internals

    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
    real(rp) :: Del_basis
    logical :: MySorted

! Things below go more efficiently if Grid is sorted

    n_grid = size(grid)

    mySorted = n_grid == 1
    if ( .not. mySorted ) then
      if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
    end if

    if ( mySorted ) then
      do i = 1, n_grid
        p(i) = i
      end do
    else
      call sortp ( grid, 1, n_grid, p ) ! grid(p(:)) are now sorted
    end if

! The first coefficient is one for all values of grid_pt below basis(1)
! until grid_pt = basis(1),then it ramps down in the usual triangular sense.
! J is the coefficient index.

    n_coeffs = size(basis)
    eta = 0.0_rp

! first basis calculation

    do i = 1, n_grid
      pi = p(i)
      if ( grid(pi) > basis(1) ) exit
      eta(pi,1) = 1.0_rp
    end do

! Normal triangular function for j=2 to j=n_coeffs-1

    do j = 2 , n_coeffs
      del_basis = 1.0 / (basis(j) - basis(j-1))
      do while ( i <= n_grid )
        pi = p(i)
        if ( grid(pi) > basis(j) ) exit
        if ( basis(j-1) <= grid(pi) ) then
          eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
          eta(pi,j) =   (grid(pi) - basis(j-1)) * del_basis
        end if
        i = i + 1
      end do
    end do

! last basis calculation

    do i = n_grid, i, -1
      pi = p(i)
      if ( basis(n_coeffs) >= grid(pi) ) exit
      eta(pi,n_coeffs) = 1.0_rp
    end do

  end function Eta_Func_2d

!---------------------------------------------  Get_Eta_Sparse_1d  -----
  subroutine Get_Eta_Sparse_1d ( Basis, Grid_Pt, Eta )

! Compute the eta matrix

! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid_pt  ! grid point

! Outputs

    real(rp), intent(out) :: Eta(:)  ! representation basis function

! Internals

    integer(ip) :: J, N_coeffs
    real(rp) :: Del_basis

! The first coefficient is one for all values of grid_pt below basis(1)
! until grid_pt = basis(1),then it ramps down in the usual triangular sense.
! J is the coefficient index.
    n_coeffs = size(basis)
    eta = 0.0_rp

! first basis calculation

    if ( grid_pt <= basis(1) ) eta(1) = 1.0_rp

! Normal triangular function for j=2 to j=n_coeffs-1

    do j = 2 , n_coeffs
      del_basis = 1.0 / (basis(j) - basis(j-1))
       if ( grid_pt <= basis(j) .and. &
         &  basis(j-1) <= grid_pt ) then
        eta(j-1) = (basis(j) - grid_pt) * del_basis
        eta(j) =   (grid_pt - basis(j-1)) * del_basis
      end if
    end do

! last basis calculation

    if ( basis(n_coeffs) < grid_pt ) eta(n_coeffs) = 1.0_rp

  end subroutine Get_Eta_Sparse_1d

!------------------------------------------  Get_Eta_Sparse_1d_fl  -----
  subroutine Get_Eta_Sparse_1d_fl ( Basis, Grid_Pt, Eta, First, Last )

! Compute the eta matrix

! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid_pt  ! grid point

! Outputs

    real(rp), intent(out) :: Eta(:)  ! representation basis function
    integer, intent(out) :: First, Last ! First and last where Eta is not zero

! Internals

    integer(ip) :: J, N_coeffs
    real(rp) :: Del_basis

! The first coefficient is one for all values of grid_pt below basis(1)
! until grid_pt = basis(1),then it ramps down in the usual triangular sense.
! J is the coefficient index.
    n_coeffs = size(basis)
    eta = 0.0_rp

! first basis calculation

    if ( grid_pt <= basis(1) ) then
      eta(1) = 1.0
      first = 1
      last = 1
      return
    end if

! Normal triangular function for j=2 to j=n_coeffs-1.  Basis is sorted.

    do j = 2 , n_coeffs
      if ( grid_pt <= basis(j) .and. &
        &  basis(j-1) <= grid_pt ) then
        del_basis = 1.0 / (basis(j) - basis(j-1))
        eta(j-1) = (basis(j) - grid_pt) * del_basis
        eta(j) =   (grid_pt - basis(j-1)) * del_basis
        first = j - 1
        last = j
        return
      end if
    end do

! last basis calculation

    if ( basis(n_coeffs) < grid_pt ) then
      eta(n_coeffs) = 1.0_rp
      first = n_coeffs
      last = n_coeffs
    end if

  end subroutine Get_Eta_Sparse_1d_fl

!------------------------------------------  Get_Eta_Sparse_1d_nz  -----
  subroutine Get_Eta_Sparse_1d_nz ( Basis, Grid_Pt, Eta, Not_zero )

! Compute the eta matrix

! Inputs

    real(rp), intent(in) :: Basis(:)    ! basis break points
    real(rp), intent(in) :: Grid_pt     ! grid point

! Outputs

    real(rp), intent(out) :: Eta(:)     ! representation basis function
    logical, intent(out) :: Not_zero(:) ! where Eta is not zero

! Internals

    integer(ip) :: J, N_coeffs
    real(rp) :: Del_basis

! The first coefficient is one for all values of grid_pt below basis(1)
! until grid_pt = basis(1),then it ramps down in the usual triangular sense.
! J is the coefficient index.
    n_coeffs = size(basis)
    eta = 0.0_rp
    not_zero = .false.

! first basis calculation

    if ( grid_pt <= basis(1) ) then
      eta(1) = 1.0
      not_zero(1) = .true.
      return
    end if

! Normal triangular function for j=2 to j=n_coeffs-1.  Basis is sorted.

    do j = 2 , n_coeffs
      if ( grid_pt <= basis(j) .and. &
        &  basis(j-1) <= grid_pt ) then
        del_basis = 1.0 / (basis(j) - basis(j-1))
        eta(j-1) = (basis(j) - grid_pt) * del_basis
        eta(j) =   (grid_pt - basis(j-1)) * del_basis
        not_zero(j-1) = .true.
        not_zero(j) = .true.
        return
      end if
    end do

! last basis calculation

    if ( basis(n_coeffs) < grid_pt ) then
      eta(n_coeffs) = 1.0_rp
      not_zero(n_coeffs) = .true.
    end if

  end subroutine Get_Eta_Sparse_1d_nz

!---------------------------------------------  Get_Eta_Sparse_2d  -----
  subroutine Get_Eta_Sparse_2d ( Basis, Grid, Eta, Sorted )

! Compute the eta matrix.  Basis is assumed to be sorted.  Grid need not
! be sorted, but if it is, Sorted can be set .true. to suppress sorting it
! here.

    use Sort_m, only: SortP
! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    logical, optional, intent(in) :: Sorted ! "Grid is sorted"

! Outputs

    real(rp), intent(out) :: Eta(:,:) ! representation basis function

! Internals

    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
    real(rp) :: Del_basis
    logical :: MySorted

! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense,
! then the last coefficient is one for all values of grid above basis(n_coeffs).
! I is the independent variable grid index and J is the coefficient index

    n_coeffs = size(basis)
    eta = 0.0_rp
    ! eta(:,:n_coeffs) = 0.0_rp

! Things below go more efficiently if Grid is sorted

    n_grid = size(grid)

    mySorted = n_grid == 1
    if ( .not. mySorted ) then
      if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
    end if

    if ( mySorted ) then

! first basis calculation

      do i = 1, n_grid
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
      end do

! Normal triangular function for j=2 to j=n_coeffs-1

      do j = 2 , n_coeffs
        del_basis = 1.0 / (basis(j) - basis(j-1))
        do while ( i <= n_grid )
          if ( grid(i) > basis(j) ) exit
          if ( basis(j-1) <= grid(i) ) then
            eta(i,j-1) = (basis(j) - grid(i)) * del_basis
            eta(i,j) =   (grid(i) - basis(j-1)) * del_basis
          end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        if ( basis(n_coeffs) >= grid(i) ) exit
        eta(i,n_coeffs) = 1.0_rp
      end do

    else

      call sortp ( grid, 1, n_grid, p ) ! grid(p(:)) are now sorted

! first basis calculation

      do i = 1, n_grid
        pi = p(i)
        if ( grid(pi) > basis(1) ) exit
        eta(pi,1) = 1.0_rp
      end do

! Normal triangular function for j=2 to j=n_coeffs-1

      do j = 2 , n_coeffs
        del_basis = 1.0 / (basis(j) - basis(j-1))
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
          eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
          eta(pi,j) =   (grid(pi) - basis(j-1)) * del_basis
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        pi = p(i)
        if ( basis(n_coeffs) >= grid(pi) ) exit
        eta(pi,n_coeffs) = 1.0_rp
      end do

    end if

  end subroutine Get_Eta_Sparse_2d

!------------------------------------------  Get_Eta_Sparse_2d_fl  -----
  subroutine Get_Eta_Sparse_2d_fl ( Basis, Grid, Eta, First, Last, Sorted )

! Compute the eta matrix.  Basis is assumed to be sorted.  Grid need not
! be sorted, but if it is, Sorted can be set .true. to suppress sorting it
! here.

!   use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Sort_m, only: SortP

! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    logical, optional, intent(in) :: Sorted ! "Grid is sorted"

! Outputs

    real(rp), intent(out) :: Eta(:,:) ! representation basis function
    integer, intent(out) :: First(:)  ! First nonzero in each row of Eta
    integer, intent(out) :: Last(:)   ! Last nonzero in each row of Eta

! Internals

    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
    real(rp) :: Del_basis
    logical :: MySorted

! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense,
! then the last coefficient is one for all values of grid above basis(n_coeffs).
! I is the independent variable grid index and J is the coefficient index

    n_coeffs = size(basis)
    eta = 0.0_rp

! Things below go more efficiently if Grid is sorted

    n_grid = size(grid)

    mySorted = n_grid == 1
    if ( .not. mySorted ) then
      if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
    end if

    if ( mySorted ) then

! first basis calculation

      do i = 1, n_grid
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        first(i) = 1
        last(i) = 1
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          if ( grid(i) > basis(j) ) exit
!         if ( basis(j-1) <= grid(i) ) then
            eta(i,j-1) = (basis(j) - grid(i)) * del_basis
            eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
            first(i) = j - 1
            last(i) = j
!         else
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & "Grid probably out of order" )
!         end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        eta(i,n_coeffs) = 1.0_rp
        first(i) = n_coeffs
        last(i) = n_coeffs
      end do

    else

      call sortp ( grid, 1, n_grid, p ) ! grid(p(:)) are now sorted

! first basis calculation

      do i = 1, n_grid
        pi = p(i)
        if ( grid(pi) > basis(1) ) exit
        eta(pi,1) = 1.0_rp
        first(pi) = 1
        last(pi) = 1
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
!         if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            first(pi) = j - 1
            last(pi) = j
!         else
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & "Why does the grid appear to be out of order?" )
!         end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        pi = p(i)
        eta(pi,n_coeffs) = 1.0_rp
        first(pi) = n_coeffs
        last(pi) = n_coeffs
      end do

    end if

  end subroutine Get_Eta_Sparse_2d_fl

!---------------------------------------  Get_Eta_Sparse_2d_fl_nz  -----
  subroutine Get_Eta_Sparse_2d_fl_nz ( Basis, Grid, Eta, Not_zero, First, Last, &
    & Sorted )

! Compute the eta matrix.  Basis is assumed to be sorted.  Grid need not
! be sorted, but if it is, Sorted can be set .true. to suppress sorting it
! here.

!   use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Sort_m, only: SortP

! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    logical, optional, intent(in) :: Sorted ! "Grid is sorted"

! Outputs

    real(rp), intent(out) :: Eta(:,:) ! representation basis function
    logical, intent(out) :: Not_zero(:,:) ! where the above is not zero
    integer, intent(out) :: First(:)  ! First nonzero in each row of Eta
    integer, intent(out) :: Last(:)   ! Last nonzero in each row of Eta

! Internals

    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
    real(rp) :: Del_basis
    logical :: MySorted

! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense,
! then the last coefficient is one for all values of grid above basis(n_coeffs).
! I is the independent variable grid index and J is the coefficient index

    n_coeffs = size(basis)
    eta = 0.0_rp
    not_zero = .false.

! Things below go more efficiently if Grid is sorted

    n_grid = size(grid)

    mySorted = n_grid == 1
    if ( .not. mySorted ) then
      if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
    end if

    if ( mySorted ) then

! first basis calculation

      do i = 1, n_grid
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        not_zero(i,1) = .true.
        first(i) = 1
        last(i) = 1
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          if ( grid(i) > basis(j) ) exit
!         if ( basis(j-1) <= grid(i) ) then
            eta(i,j-1) = (basis(j) - grid(i)) * del_basis
            eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
            not_zero(i,j-1) = .true.
            not_zero(i,j) = .true.
            first(i) = j - 1
            last(i) = j
!         else
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & "Grid probably out of order" )
!         end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        eta(i,n_coeffs) = 1.0_rp
        not_zero(i,n_coeffs) = .true.
        first(i) = n_coeffs
        last(i) = n_coeffs
      end do

    else

      call sortp ( grid, 1, n_grid, p ) ! grid(p(:)) are now sorted

! first basis calculation

      do i = 1, n_grid
        pi = p(i)
        if ( grid(pi) > basis(1) ) exit
        eta(pi,1) = 1.0_rp
        not_zero(pi,1) = .true.
        first(pi) = 1
        last(pi) = 1
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
!         if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            not_zero(pi,j-1) = .true.
            not_zero(pi,j) = .true.
            first(pi) = j - 1
            last(pi) = j
!         else
!           call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & "Why does the grid appear to be out of order?" )
!         end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        pi = p(i)
        eta(pi,n_coeffs) = 1.0_rp
        not_zero(pi,n_coeffs) = .true.
        first(pi) = n_coeffs
        last(pi) = n_coeffs
      end do

    end if

  end subroutine Get_Eta_Sparse_2d_fl_nz

!-------------------------------------------  Get_Eta_Sparse_2d_nz  -----
  subroutine Get_Eta_Sparse_2d_nz ( Basis, Grid, Eta, Not_zero, Sorted )

! Compute the eta matrix.  Basis is assumed to be sorted.  Grid need not
! be sorted, but if it is, Sorted can be set .true. to suppress sorting it
! here.

    use Sort_m, only: SortP
! Inputs

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    logical, optional, intent(in) :: Sorted ! "Grid is sorted"

! Outputs

    real(rp), intent(out) :: Eta(:,:) ! representation basis function
    logical, intent(out) :: Not_zero(:,:) ! where the above is not zero

! Internals

    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
    real(rp) :: Del_basis
    logical :: MySorted

! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense,
! then the last coefficient is one for all values of grid above basis(n_coeffs).
! I is the independent variable grid index and J is the coefficient index

    n_coeffs = size(basis)
    eta = 0.0_rp
    not_zero = .false.

! Things below go more efficiently if Grid is sorted

    n_grid = size(grid)

    mySorted = n_grid == 1
    if ( .not. mySorted ) then
      if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
    end if

    if ( mySorted ) then

! first basis calculation

      do i = 1, n_grid
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        not_zero(i,1) = .true.
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          if ( grid(i) > basis(j) ) exit
!         if ( basis(j-1) <= grid(i) ) then
            eta(i,j-1) = (basis(j) - grid(i)) * del_basis
            eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
            not_zero(i,j-1) = .true.
            not_zero(i,j) = .true.
!         else
!           stop "grid not sorted"
!         end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        if ( basis(n_coeffs) >= grid(i) ) exit
        eta(i,n_coeffs) = 1.0_rp
        not_zero(i,n_coeffs) = .true.
      end do

    else

      call sortp ( grid, 1, n_grid, p ) ! grid(p(:)) are now sorted

! first basis calculation

      do i = 1, n_grid
        pi = p(i)
        if ( grid(pi) > basis(1) ) exit
        eta(pi,1) = 1.0_rp
        not_zero(pi,1) = .true.
      end do

! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
          if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            not_zero(pi,j-1) = .true.
            not_zero(pi,j) = .true.
          end if
          i = i + 1
        end do
      end do

! last basis calculation

      do i = i, n_grid
        pi = p(i)
        if ( basis(n_coeffs) >= grid(pi) ) exit
        eta(pi,n_coeffs) = 1.0_rp
        not_zero(pi,n_coeffs) = .true.
      end do

    end if

  end subroutine Get_Eta_Sparse_2d_nz

! ----------------------------------------  Get_Eta_Column_Sparse  -----
  subroutine Get_Eta_Column_Sparse ( Basis, Grid, Eta, Row1, RowN, NZ, NNZ, Update )

  ! Compute rows Row1 to RowN of the eta matrix.  Basis is assumed to be
  ! sorted.  Rows Row1 to RowN of Grid are assumed to be sorted.  Row1 > RowN
  ! is allowed.  If Update is false, set nonzero elements of Eta to zero.
  ! It is assumed that Eta has initially been set to zero by the caller.

    use Sort_m, only: Sort

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    real(rp), intent(inout) :: Eta(:,:)
    integer, intent(in) :: Row1, RowN
    integer, intent(inout) :: NZ(:,:) ! Locations of nonzeros in columns of Eta
    integer, intent(inout) :: NNZ(:)  ! Numbers of nonzeros in columns of Eta
    logical, intent(in) :: Update

    real(rp) :: Del_basis
    integer :: I, J, N_Coeffs, MyRow1, MyRowN

    if ( size(grid) == 0 ) return
    myRow1 = min(row1,ubound(grid,1))
    myRowN = min(rowN,ubound(grid,1))
    if ( grid(myRow1) > grid(myRowN) ) then ! grid is in opposite order.
      myRow1 = min(rowN,ubound(grid,1))
      myRowN = min(row1,ubound(grid,1))
    end if

    if ( .not. update ) then
      do i = 1, size(eta,2)
        eta(nz(:nnz(i),i),i) = 0.0
        nnz(i) = 0
      end do
    end if

    n_coeffs = size(basis)
    if ( n_coeffs <= 0 ) return

    if ( myRow1 <= myRowN ) then

      ! First basis calculation

      do i = myRow1, myRowN
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        nnz(1) = nnz(1) + 1
        nz(nnz(1),1) = i
      end do

      ! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
      ! Grid are sorted, so we don't need to start from i=myRow1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= myRowN )
          if ( grid(i) > basis(j) ) exit
          eta(i,j-1) = (basis(j) - grid(i)) * del_basis
          if ( eta(i,j-1) /= 0.0 ) then
            nnz(j-1) = nnz(j-1) + 1
            nz(nnz(j-1),j-1) = i
          end if
          eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
          if ( eta(i,j) /= 0.0 ) then
            nnz(j) = nnz(j) + 1
            nz(nnz(j),j) = i
          end if
          i = i + 1
        end do
      end do

      ! last basis calculation

      do i = i, myRowN
        if ( basis(n_coeffs) >= grid(i) ) exit
        eta(i,n_coeffs) = 1.0_rp
        nnz(n_coeffs) = nnz(n_coeffs) + 1
        nz(nnz(n_coeffs),n_coeffs) = i
      end do

    else

      ! First basis calculation
      do i = myRow1, myRowN, -1
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        nnz(1) = nnz(1) + 1
        nz(nnz(1),1) = i
      end do

      ! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
      ! Grid are sorted, so we don't need to start from i=myRow1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i >= myRowN )
          if ( grid(i) > basis(j) ) exit
          eta(i,j-1) = (basis(j) - grid(i)) * del_basis
          if ( eta(i,j-1) /= 0.0 ) then
            nnz(j-1) = nnz(j-1) + 1
            nz(nnz(j-1),j-1) = i
          end if
          eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
          if ( eta(i,j) /= 0.0 ) then
            nnz(j) = nnz(j) + 1
            nz(nnz(j),j) = i
          end if
          i = i - 1
        end do
      end do

      ! last basis calculation

      do i = i, myRowN, -1
        if ( basis(n_coeffs) >= grid(i) ) exit
        eta(i,n_coeffs) = 1.0_rp
        nnz(n_coeffs) = nnz(n_coeffs) + 1
        nz(nnz(n_coeffs),n_coeffs) = i
      end do

      ! Indices of nonzeros have come out in reverse order.
      ! If we are updating they're appended to those that were
      ! created in forward order.  It's simplest to sort them.
      do j = 1, n_coeffs
        call sort ( nz(:,j), 1, nnz(j) )
      end do

    end if

  end subroutine Get_Eta_Column_Sparse
  
! ----------------------------------  Get_Eta_Column_Sparse_fl_nz  -----
  subroutine Get_Eta_Column_Sparse_fl_nz ( Basis, Grid, Eta, Row1, RowN, &
    & NZ, NNZ, First, Last, Not_Zero )

  ! Compute rows Row1 to RowN of the eta matrix.  Basis is assumed to be
  ! sorted.  Rows Row1 to RowN of Grid are assumed to be sorted.  Row1 > RowN
  ! is allowed.   It is assumed that Eta has initially been set to zero by the
  ! caller.

    use Sort_m, only: Sort

    real(rp), intent(in) :: Basis(:) ! basis break points
    real(rp), intent(in) :: Grid(:)  ! grid values
    real(rp), intent(inout) :: Eta(:,:)
    integer, intent(in) :: Row1, RowN
    integer, intent(inout) :: NZ(:,:) ! Locations of nonzeros in columns of Eta
    integer, intent(inout) :: NNZ(:)  ! Numbers of nonzeros in columns of Eta
    integer, intent(out) :: First(:)  ! First nonzero in each row of Eta
    integer, intent(out) :: Last(:)   ! Last nonzero in each row of Eta
    logical, intent(inout) :: Not_zero(:,:) ! where Eta is not zero

    real(rp) :: Del_basis
    integer :: I, J, N_Coeffs, MyRow1, MyRowN

    myRow1 = row1
    myRowN = rowN
    if ( grid(row1) > grid(rowN) ) then ! grid is in opposite order.
      myRow1 = rowN
      myRowN = row1
    end if

    do i = 1, size(eta,2)
      eta(nz(:nnz(i),i),i) = 0.0
      not_zero(nz(:nnz(i),i),i) = .true.
      nnz(i) = 0
    end do

    n_coeffs = size(basis)
    if ( n_coeffs <= 0 ) return

    if ( myRow1 <= myRowN ) then

      ! First basis calculation

      do i = myRow1, myRowN
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        nnz(1) = nnz(1) + 1
        nz(nnz(1),1) = i
        not_zero(i,1) = .true.
        first(i) = 1
        last(i) = 1
      end do

      ! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
      ! Grid are sorted, so we don't need to start from i=myRow1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= myRowN )
          if ( grid(i) > basis(j) ) exit
          eta(i,j-1) = (basis(j) - grid(i)) * del_basis
          eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
          nnz(j-1) = nnz(j-1) + 1
          nz(nnz(j-1),j-1) = i
          nnz(j) = nnz(j) + 1
          nz(nnz(j),j) = i
          not_zero(i,j-1) = .true.
          not_zero(i,j) = .true.
          first(i) = j - 1
          last(i) = j
          i = i + 1
        end do
      end do

      ! last basis calculation

      do i = i, myRowN
        eta(i,n_coeffs) = 1.0_rp
        nnz(n_coeffs) = nnz(n_coeffs) + 1
        nz(nnz(n_coeffs),n_coeffs) = i
        not_zero(i,n_coeffs) = .true.
        first(i) = n_coeffs
        last(i) = n_coeffs
      end do

    else

      ! First basis calculation
      do i = myRow1, myRowN, -1
        if ( grid(i) > basis(1) ) exit
        eta(i,1) = 1.0_rp
        nnz(1) = nnz(1) + 1
        nz(nnz(1),1) = i
        not_zero(i,1) = .true.
        first(i) = 1
        last(i) = 1
      end do

      ! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
      ! Grid are sorted, so we don't need to start from i=myRow1.

      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i >= myRowN )
          if ( grid(i) > basis(j) ) exit
          eta(i,j-1) = (basis(j) - grid(i)) * del_basis
          eta(i,j  ) = (grid(i) - basis(j-1)) * del_basis
          nnz(j-1) = nnz(j-1) + 1
          nz(nnz(j-1),j-1) = i
          nnz(j) = nnz(j) + 1
          nz(nnz(j),j) = i
          not_zero(i,j-1) = .true.
          not_zero(i,j) = .true.
          first(i) = j - 1
          last(i) = j
          i = i - 1
        end do
      end do

      ! last basis calculation

      do i = i, myRowN, -1
        eta(i,n_coeffs) = 1.0_rp
        nnz(n_coeffs) = nnz(n_coeffs) + 1
        nz(nnz(n_coeffs),n_coeffs) = i
        not_zero(i,n_coeffs) = .true.
        first(i) = n_coeffs
        last(i) = n_coeffs
      end do

      ! Indices of nonzeros have come out in reverse order.
      ! It's simplest to sort them.
      do j = 1, n_coeffs
        call sort ( nz(:,j), 1, nnz(j) )
      end do

    end if

  end subroutine Get_Eta_Column_Sparse_fl_nz

! ---------------------------------------------  Get_Eta_Stru_D_D  -----
  subroutine Get_Eta_Stru_D_D ( Basis, Grid, Eta )
    ! Compute linear interpolating coefficients from Basis to Grid. It is
    ! assumed that Basis(:) is sorted, but it is not assumed that Grid(:)
    ! is sorted.  It is assumed that Grid(:) changes slowly and smoothly.
    ! It is assumed that Size(Grid) == SIze(Eta).
    ! To interpolate from some T whose coordinates are Basis(:) to
    ! a value corresponding to Grid(k), compute
    ! Basis(eta(k)%l)*eta(k)%eta + Basis(eta(k)%l+1)*(1.0-eta(k)%eta).
    ! If Grid(k) < Basis(1) then Eta(k)%L = 1 and Eta(k)%Eta = 1.0.
    ! If Grid(k) >= Basis(size(basis)) then Eta(k)%L = size(basis-1) and
    ! Eta(k)%Eta = 0.0.  That is, outside the range of Basis(:), constant
    ! extrapolation is used.
    integer, parameter :: KB = kind(0.0d0)
    integer, parameter :: KG = kind(0.0d0)
    include "Get_Eta_Stru.f9h"
  end subroutine Get_Eta_Stru_D_D

! ---------------------------------------------  Get_Eta_Stru_D_S  -----
  subroutine Get_Eta_Stru_D_S ( Basis, Grid, Eta )
    ! Compute linear interpolating coefficients from Basis to Grid. It is
    ! assumed that Basis(:) is sorted, but it is not assumed that Grid(:)
    ! is sorted.  It is assumed that Grid(:) changes slowly and smoothly.
    ! It is assumed that Size(Grid) == SIze(Eta).
    ! To interpolate from some T whose coordinates are Basis(:) to
    ! a value corresponding to Grid(k), compute
    ! Basis(eta(k)%l)*eta(k)%eta + Basis(eta(k)%l+1)*(1.0-eta(k)%eta).
    ! If Grid(k) < Basis(1) then Eta(k)%L = 1 and Eta(k)%Eta = 1.0.
    ! If Grid(k) >= Basis(size(basis)) then Eta(k)%L = size(basis-1) and
    ! Eta(k)%Eta = 0.0.  That is, outside the range of Basis(:), constant
    ! extrapolation is used.
    integer, parameter :: KB = kind(0.0d0)
    integer, parameter :: KG = kind(0.0e0)
    include "Get_Eta_Stru.f9h"
  end subroutine Get_Eta_Stru_D_S

! ---------------------------------------------  Get_Eta_Stru_S_S  -----
  subroutine Get_Eta_Stru_S_S ( Basis, Grid, Eta )
    ! Compute linear interpolating coefficients from Basis to Grid. It is
    ! assumed that Basis(:) is sorted, but it is not assumed that Grid(:)
    ! is sorted.  It is assumed that Grid(:) changes slowly and smoothly.
    ! It is assumed that Size(Grid) == SIze(Eta).
    ! To interpolate from some T whose coordinates are Basis(:) to
    ! a value corresponding to Grid(k), compute
    ! Basis(eta(k)%l)*eta(k)%eta + Basis(eta(k)%l+1)*(1.0-eta(k)%eta).
    ! If Grid(k) < Basis(1) then Eta(k)%L = 1 and Eta(k)%Eta = 1.0.
    ! If Grid(k) >= Basis(size(basis)) then Eta(k)%L = size(basis-1) and
    ! Eta(k)%Eta = 0.0.  That is, outside the range of Basis(:), constant
    ! extrapolation is used.
    integer, parameter :: KB = kind(0.0e0)
    integer, parameter :: KG = kind(0.0e0)
    include "Get_Eta_Stru.f9h"
  end subroutine Get_Eta_Stru_S_S

! ---------------------------------------------------  Get_Eta_ZP  -----
  subroutine Get_Eta_ZP ( Z_Basis, Z_Path, Eta_Z, NZ_Z, NNZ_Z, Tan_Ind, &
                        & P_Basis, P_Path, Eta_P, NZ_P, NNZ_P, &
                        & Eta_ZP, NZ_ZP, NNZ_ZP, NonZero_ZP, Update )

    use GLNP, only: NG, NGP1
    real(rp), intent(in) :: Z_Basis(:)     ! Zeta basis break points
    real(rp), intent(in) :: Z_Path(:)      ! Zeta on the path
    real(rp), intent(inout) :: Eta_Z(:,:)  ! Interpolating coefficients from
                                           ! Z_Basis to Z_Path
    integer, intent(inout) :: NZ_Z(:,:)    ! Nonzeros in Eta_Z
    integer, intent(inout) :: NNZ_Z(:)     ! Numbers of nonzeros in columns of
                                           ! Eta_Z
    integer, intent(in) :: Tan_Ind         ! Index of tangent in Z_Path etc.
    real(rp), intent(in) :: P_Basis(:)     ! Phi basis break points
    real(rp), intent(in) :: P_Path(:)      ! Phi on the path
    real(rp), intent(inout) :: Eta_P(:,:)  ! Interpolating coefficients from
                                           ! P_Basis to P_Path
    integer, intent(inout) :: NZ_P(:,:)    ! Nonzeros in Eta_P
    integer, intent(inout) :: NNZ_P(:)     ! Numbers of nonzeros in columns of
                                           ! Eta_P
    real(rp), intent(inout) :: Eta_ZP(:,:) ! Eta_Z * Eta_P on the path for
                                           ! each state vector Z X P element
    integer, intent(inout) :: NZ_ZP(:,:)   ! Nonzeros in Eta_ZP
    integer, intent(inout) :: NNZ_ZP(:)    ! Numbers of nonzeros in columns of
                                           ! Eta_ZP
    logical, intent(out), optional :: NonZero_ZP(:,:) ! Where Eta_ZP is nonzero
    logical, intent(in), optional :: Update ! Clear nonzeros using NZ_, NNZ_
                                           ! for each Eta first, otherwise
                                           ! clear everything

    integer :: I
    logical :: MyUpdate

    myUpdate = .false.
    if ( present(update) ) myUpdate = update

    if ( myUpdate ) then
      ! Replace previously calculated nonzeros with zeros.
      do i = 1, size(nnz_p)
        eta_p(nz_p(:nnz_p(i),i),i) = 0
      end do
      do i = 1, size(nnz_z)
        eta_z(nz_z(:nnz_z(i),i),i) = 0
      end do
      do i = 1, size(nnz_zp)
        eta_zp(nz_zp(:nnz_zp(i),i),i) = 0
      end do
    else
      eta_p = 0
      eta_z = 0
      eta_zp = 0
    end if
    nnz_p = 0
    nnz_z = 0
    nnz_zp = 0

    call get_eta_sparse ( z_basis, z_path, eta_z, &
    &      tan_ind, 1, nz_z, nnz_z, .false. )
    ! Fine grid points between tangent points, if any, aren't used.
    eta_z(tan_ind+1:tan_ind+ng,:) = 0.0_rp
    call get_eta_sparse ( z_basis, z_path, eta_z, &
      &    tan_ind+ngp1, size(z_path), nz_z, nnz_z, .true. )
    call get_eta_sparse ( p_basis, p_path, eta_p, &
      &    1, size(p_path), nz_p, nnz_p, .false. )
    ! Fine grid points between tangent points, if any, aren't used.
    eta_p(tan_ind+1:tan_ind+ng,:) = 0.0_rp

    if ( present(nonZero_ZP) ) then
      call multiply_eta_column_sparse ( &
        & eta_z, nz_z, nnz_z, eta_p, nz_p, nnz_p, eta_zp, nz_zp, nnz_zp, &
        & nonZero_ZP )
    else
      call multiply_eta_column_sparse ( &
        & eta_z, nz_z, nnz_z, eta_p, nz_p, nnz_p, eta_zp, nz_zp, nnz_zp )
    end if

  end subroutine Get_Eta_ZP

! ----------------------------------------  Interpolate_Stru_1D_D  -----
  subroutine Interpolate_Stru_1D_D ( From, Eta, To )
    ! Interpolate from From to To using interpolating coefficients Eta
    integer, parameter :: RK = kind(0.0d0)
    real(rk), intent(in) :: From(:)
    type (eta_d_t), intent(in) :: Eta(:) ! Gotten from Get_Eta_Stru
    real(rk), intent(out) :: To(:)       ! Eta and To assumed same length
    include "Interpolate_Stru_1D.f9h"
  end subroutine Interpolate_Stru_1D_D

! ----------------------------------------  Interpolate_Stru_1D_S  -----
  subroutine Interpolate_Stru_1D_S ( From, Eta, To )
    ! Interpolate from From to To using interpolating coefficients Eta
    integer, parameter :: RK = kind(0.0e0)
    real(rk), intent(in) :: From(:)
    type (eta_s_t), intent(in) :: Eta(:) ! Gotten from Get_Eta_Stru
    real(rk), intent(out) :: To(:)       ! Eta and To assumed same length
    include "Interpolate_Stru_1D.f9h"
  end subroutine Interpolate_Stru_1D_S

! ----------------------------------------  Interpolate_Stru_2D_D  -----
  subroutine Interpolate_Stru_2D_D ( From, Eta_1, Eta_2, To )
    ! Interpolate from From to To using interpolating coefficients Eta
    integer, parameter :: RK = kind(0.0d0)
    real(rk), intent(in) :: From(:,:)
    type (eta_d_t), intent(in) :: Eta_1(:), Eta_2(:) ! Gotten from Get_Eta_Stru
    real(rk), intent(out) :: To(:)       ! Eta's and To assumed same length
    include "Interpolate_Stru_2D.f9h"
  end subroutine Interpolate_Stru_2D_D

! ----------------------------------------  Interpolate_Stru_2D_S  -----
  subroutine Interpolate_Stru_2D_S ( From, Eta_1, Eta_2, To )
    ! Interpolate from From to To using interpolating coefficients Eta
    integer, parameter :: RK = kind(0.0e0)
    real(rk), intent(in) :: From(:,:)
    type (eta_s_t), intent(in) :: Eta_1(:), Eta_2(:) ! Gotten from Get_Eta_Stru
    real(rk), intent(out) :: To(:)       ! Eta's and To assumed same length
    include "Interpolate_Stru_2D.f9h"
  end subroutine Interpolate_Stru_2D_S

! -----------------------------------  Multiply_Eta_Column_Sparse  -----
  subroutine Multiply_Eta_Column_Sparse (Eta_1, NZ_1, NNZ_1, Eta_2, NZ_2, NNZ_2, &
    & Eta_P, NZ_P, NNZ_P, Not_Zero_P )

  ! Multiply each column of Eta_1 by every column of Eta_2, each product
  ! giving a column of Eta_P, so that the number of columns of Eta_P is
  ! the product of the numbers of columns of Eta_1 and Eta_2.  Columns of
  ! Eta_1 are stepped more rapidly than columns of Eta_2.

  ! It is assumed that NNZ_P(i) and NZ_P(:NNZ_P(i),i) have defined
  ! values for each I from 1 to size(Eta_P,2).

    real(rp), intent(in) :: Eta_1(:,:), Eta_2(:,:) ! Values
    integer, intent(in) :: NZ_1(:,:), NZ_2(:,:)    ! Nonzero elements of Eta_*
    integer, intent(in) :: NNZ_1(:), NNZ_2(:)      ! Numbers of nonzeros
    real(rp), intent(inout) :: Eta_P(:,:)   ! Only the nonzeros are replaced
    integer, intent(inout) :: NZ_P(:,:)     ! Nonzero elements of Eta_P
    integer, intent(inout) :: NNZ_P(:)      ! Numbers of nonzeros
    logical, intent(inout), optional :: Not_Zero_P(:,:) ! Nonzero elements of Eta_P

    integer :: I1, I2, I3, J1, J2, K

    ! First remove nonzero elements from Eta_P
    if ( present(not_zero_p) ) then
      do k = 1, size(eta_p,2)
        not_zero_p(nz_p(:nnz_p(k),k),k) = .false.
      end do
    end if

    do k = 1, size(eta_p,2)
      eta_p(nz_p(:nnz_p(k),k),k) = 0.0
      nnz_p(k) = 0
    end do

    ! Multiply nonzero elements of Eta_1 and Eta_2
    ! Assume elements of each column of NZ_1 and NZ_2 are in order.
    k = 0

    do j2 = 1, size(eta_2,2)
      do j1 = 1, size(eta_1,2)
        k = k + 1
        i1 = 1
        i2 = 1
        do
          if ( i1 > nnz_1(j1) ) exit
          if ( i2 > nnz_2(j2) ) exit
          if ( nz_1(i1,j1) < nz_2(i2,j2) ) then
            i1 = i1 + 1
          else if ( nz_1(i1,j1) > nz_2(i2,j2) ) then
            i2 = i2 + 1
          else ! Both columns have nonzero in the same row
            i3 = nz_1(i1,j1)
            nnz_p(k) = nnz_p(k) + 1
            nz_p(nnz_p(k),k) = i3
            eta_p(i3,k) = eta_1(i3,j1) * eta_2(i3,j2)
            i1 = i1 + 1
            i2 = i2 + 1
          end if
        end do
      end do
    end do

    ! Note where nonzeros are
    if ( present(not_zero_p) ) then
      do k = 1, size(eta_p,2)
        not_zero_p(nz_p(:nnz_p(k),k),k) = .true.
      end do
    end if

  end subroutine Multiply_Eta_Column_Sparse

! -----------------------------------------------  Select_NZ_List  -----
  subroutine Select_NZ_List ( NZ_1, NNZ_1, List, I_start, NZ_2, NNZ_2 )
  ! Select the nonzeros from NZ_1 that are in List(I_start:) and put their
  ! indices in List into NZ_2.
    integer, intent(in) :: NZ_1(:,:)
    integer, intent(in) :: NNZ_1(:)
    integer, intent(in) :: List(:)
    integer, intent(in) :: I_Start
    integer, intent(out) :: NZ_2(:,:)
    integer, intent(out) :: NNZ_2(:)

    integer :: J
    integer :: I1, I2

    nnz_2 = 0
    ! This is just a merge
    do j = 1, size(nz_1,2)
      i1 = 1
      i2 = i_start
      do
        if ( i1 > nnz_1(j) .or. i2 > size(list) ) exit
        if ( nz_1(i1,j) < list(i2) ) then
          i1 = i1 + 1
        else if ( nz_1(i1,j) > list(i2) ) then
          i2 = i2 + 1
        else
          nnz_2(j) = nnz_2(j) + 1
          nz_2(nnz_2(j),j) = i2
          i1 = i1 + 1
          i2 = i2 + 1
        end if
      end do
    end do ! j

  end subroutine Select_NZ_List

!=========================================================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: get_eta_matrix_m.f90,v 2.37 2018/08/07 18:10:15 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Get_Eta_Matrix_m
!---------------------------------------------------
! $Log: get_eta_matrix_m.f90,v $
! Revision 2.37  2018/08/07 18:10:15  vsnyder
! Make Dump_Eta_Transpose more like sparse dump
!
! Revision 2.36  2018/05/17 01:55:00  vsnyder
! Cannonball polishing
!
! Revision 2.35  2018/05/14 23:30:19  vsnyder
! Cannonball polishing
!
! Revision 2.34  2018/04/26 02:58:13  vsnyder
! size(Grids_f%l_z)==size(Grids_f%l_p) so N2 doesn't need to depend on myP
!
! Revision 2.33  2018/04/26 00:09:38  vsnyder
! Add Clean_Out_Nonzeroes, add P_Only to Dump_Eta_Transpose
!
! Revision 2.32  2018/03/21 01:58:10  vsnyder
! Restore NC for each sps in case it was changed by .not. frqDep
!
! Revision 2.31  2017/11/21 00:03:42  vsnyder
! Print the quantity name, print subscripts only for nonzer elements
!
! Revision 2.30  2017/09/20 01:06:04  vsnyder
! Embellish the dump
!
! Revision 2.29  2017/06/01 22:50:25  vsnyder
! Add Get_Column_Sparsity, more dump spiffing
!
! Revision 2.28  2017/05/24 20:29:49  vsnyder
! Spiff a dump
!
! Revision 2.27  2016/10/18 00:29:13  vsnyder
! Add Get_Eta_ZP
!
! Revision 2.26  2013/05/13 23:40:52  vsnyder
! Check for zero size grid
!
! Revision 2.25  2013/02/28 21:06:42  vsnyder
! Try not to access array out of bounds
!
! Revision 2.24  2011/06/23 01:13:31  vsnyder
! Add Get_Eta_1D_Hunt
!
! Revision 2.23  2010/06/07 23:17:20  vsnyder
! Add another representation for and interpolation using etas
!
! Revision 2.22  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.21  2009/04/17 22:41:26  vsnyder
! Repair bug when n_grid == 1
!
! Revision 2.20  2009/01/16 23:44:15  vsnyder
! Add Dump_Eta_Column_Sparse.  Double-check whether things are sorted.
! Corrections to sparse calculations.
!
! Revision 2.19  2008/10/14 20:59:16  vsnyder
! Undo changes to Select_NZ_List for now
!
! Revision 2.18  2008/10/13 23:42:28  vsnyder
! Compute first,last correctly for 2d cases
!
! Revision 2.17  2007/06/25 20:36:08  vsnyder
! Add column sparse representation
!
! Revision 2.16  2007/06/06 01:15:43  vsnyder
! Use the PI variable instead of P(I)
!
! Revision 2.15  2007/01/20 01:06:39  vsnyder
! Add Get_Eta_Sparse_2d_fl_nz
!
! Revision 2.14  2007/01/19 02:38:29  vsnyder
! Separate paths for sorted and unsorted grid
!
! Revision 2.13  2006/12/13 21:53:11  vsnyder
! Delete declaration of unused variable
!
! Revision 2.12  2006/12/09 02:23:45  vsnyder
! Use generic instead of optional, add First, Last
!
! Revision 2.11  2006/06/29 02:51:30  vsnyder
! Correct a recently-introduced bug
!
! Revision 2.10  2006/06/29 01:44:02  vsnyder
! Make the 1d stuff work.  It wasn't used until metrics was revised
!
! Revision 2.9  2005/12/23 03:12:42  vsnyder
! Simplify last basis calculation
!
! Revision 2.8  2005/12/22 20:55:16  vsnyder
! Improve handling of sorted grid, some cannonball polishing
!
! Revision 2.7  2005/12/10 01:52:44  vsnyder
! Added Get_Eta_Sparse_1d, made Get_Eta_Sparse generic
!
! Revision 2.6  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.5  2003/06/20 02:02:11  vsnyder
! Sort GRID and merge with Basis instead of using WHERE
!
! Revision 2.4  2003/03/21 17:02:19  pwagner
! Initalizating whole eta, not_zero arrays instead of sections
!
! Revision 2.3  2002/10/08 17:08:04  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.2  2002/09/06 20:50:28  vsnyder
! Insert copyright notice, bound some array assignments
!
! Revision 2.1  2002/09/06 18:17:19  vsnyder
! Cosmetic changes, move USEs from module scope to procedure scope
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model

! Revision 1.1.2.3  2001/09/12 21:38:49  zvi
! Added CVS stuff


@


2.38
log
@No longer used
@
text
@@


2.37
log
@Make Dump_Eta_Transpose more like sparse dump
@
text
@d1810 1
a1810 1
       "$Id: get_eta_matrix_m.f90,v 2.36 2018/05/17 01:55:00 vsnyder Exp $"
d1820 3
@


2.36
log
@Cannonball polishing
@
text
@d264 1
d266 2
a267 2
      n1 = n
      n2 = n
d273 1
a273 1
        dims(:,sps) = [ size(eta,1), &
d276 2
a277 2
      else if ( myZP ) then
        dims(:,sps) = [ size(eta,1), &
d282 1
a282 1
        dims(:,sps) = [ size(eta,1), &
d290 2
a291 1
      nc = 4 ! Upper bound of useful part of dims(sps,:)
d305 1
a305 2
      if ( frqDep(sps) ) &
        call output ( 'frequency dependent ' )
d321 1
a321 1
                if ( .not. sawNZ ) call output ( i, places=4, after='# ' )
d346 1
a346 1
                call output ( eta3(j,k,l),  format='(1pg14.6)' )
d358 1
a358 1
      call output ( a(1), before='(' )
d1810 1
a1810 1
       "$Id: get_eta_matrix_m.f90,v 2.35 2018/05/14 23:30:19 vsnyder Exp $"
d1820 3
@


2.35
log
@Cannonball polishing
@
text
@d640 1
a640 1
    integer, intent(out) :: First, Last ! First and last where Etae is not zero
d1809 1
a1809 1
       "$Id: get_eta_matrix_m.f90,v 2.34 2018/04/26 02:58:13 vsnyder Exp $"
d1819 3
@


2.34
log
@size(Grids_f%l_z)==size(Grids_f%l_p) so N2 doesn't need to depend on myP
@
text
@d117 1
a117 1
    integer :: Dims(4), I, J, J1, J2, L, M, MP, MySps, MyWidth
d1809 1
a1809 1
       "$Id: get_eta_matrix_m.f90,v 2.33 2018/04/26 00:09:38 vsnyder Exp $"
d1819 3
@


2.33
log
@Add Clean_Out_Nonzeroes, add P_Only to Dump_Eta_Transpose
@
text
@a263 1
    if ( myP ) n2 = ubound(grids_f%l_p,1)
d1809 1
a1809 1
       "$Id: get_eta_matrix_m.f90,v 2.32 2018/03/21 01:58:10 vsnyder Exp $"
d1819 3
@


2.32
log
@Restore NC for each sps in case it was changed by .not. frqDep
@
text
@d20 1
a20 1
  public :: Dump, Dump_Eta_Column_Sparse, Dump_Eta_Transpose
d76 21
d228 1
a228 1
                                & DoBig )
d242 2
d251 1
a251 1
    logical :: MyBig, MyZP, SawNZ
d260 2
d264 1
d272 5
a276 1
      if ( myZP ) then
d290 6
a295 1
      nc = merge(3,4,myZP) ! Upper bound of useful part of dims(sps,:)
d1810 1
a1810 1
       "$Id: get_eta_matrix_m.f90,v 2.31 2017/11/21 00:03:42 vsnyder Exp $"
d1820 3
@


2.31
log
@Print the quantity name, print subscripts only for nonzer elements
@
text
@d20 1
a20 1
  public :: Dump, Dump_Eta_Column_Sparse
d36 1
a36 1
    module procedure Dump_Eta_Column_Sparse
d77 2
a78 2
  subroutine Dump_Eta_Column_Sparse ( Eta, Nz, NNz, Name, Short, Show_NZ, &
    & Grids_f, ZP_only )
d88 1
d91 1
a91 2
    logical, intent(in), optional :: Show_NZ ! "Print zeroes", default true
    type (grids_t), intent(in), optional :: Grids_f ! to compute subscripts
d93 7
a99 2
    integer :: Dims(4), I, J, L, M, MP, Places, Q, Subs(4)
    logical :: MyShort, MyShow_NZ, MyZP
a101 4
    if ( present(name) .and. .not. present(grids_f) ) then
      call output ( name )
      call output ( ' state-vector-index ( path-index eta )*', advance='yes' )
    end if
d104 2
a105 2
    myShow_NZ = .true.
    if ( present(show_NZ) ) myShow_NZ = show_NZ
d108 72
a179 14
    q = 0
    m = 0
    do j = 1, size(eta,2) ! Corresponds to elements of grids_f%l_...
      if ( myShort .and. nnz(j) == 0 ) cycle
      if ( present(grids_f) ) then
        if ( j > m ) then
          do while ( j > m ) ! In case several columns got skipped
            mp = m
            q = q + 1
            if ( myZP ) then
              m = m + ( grids_f%l_z(q) - grids_f%l_z(q-1) ) * &
                      ( grids_f%l_p(q) - grids_f%l_p(q-1) )
            else
              m = grids_f%l_v(q)
d182 1
a182 26
          if ( present(name) ) then
            call output ( name )
            call blanks ( 1 )
          end if
          if ( grids_f%mol(q) /= 0 ) then
            call display_string ( lit_indices(grids_f%mol(q)) )
            call blanks ( 1 )
          end if
          if ( grids_f%qty(q) > 0 ) then
            call display_string ( lit_indices(grids_f%qty(q)), &
              & before='quantity: ' )
            call blanks ( 1 )
          end if
          if ( myZP ) then
            dims = [ size(eta,1), &
                   & grids_f%l_z(q) - grids_f%l_z(q-1), &
                   & grids_f%l_p(q) - grids_f%l_p(q-1), 1 ]
          else
            dims = [ size(eta,1), &
                   & grids_f%l_f(q) - grids_f%l_f(q-1), &
                   & grids_f%l_z(q) - grids_f%l_z(q-1), &
                   & grids_f%l_p(q) - grids_f%l_p(q-1) ]
          end if
          call showList ( dims, dims, '' )
          dims = [dims(2:), 1]
          call output ( ' state-vector-index ( path-index eta )*', advance='yes' )
d184 84
d269 6
a274 4
      places = 5
      if ( present(grids_f) ) then
        subs = subscripts ( j-mp, dims )
        places = sum(int(log10(real(subs)))) + count(dims/=1) + 3
d276 39
a314 25
      if ( nnz(j) == size(eta,1) ) then
        call output ( 'All rows in column ' )
        call showList ( dims, subs, ' are nonzero' )
        call dump ( eta(nz(:nnz(j),j),j), name='Values' )
      else
        l = 0
        saw_nz = .false.
        do i = 1, nnz(j)
          if ( .not. myShow_NZ .and. eta(nz(i,j),j) == 0 ) cycle
          if ( .not. saw_nz ) then
            if ( present(grids_f) ) then
              call showList ( dims, subs, '' )
            else
              call output ( j, places=4, after='#' )
            end if
          end if
          saw_nz = .true.
          l = l + 1
          if ( l > 5 ) then
            l = 1
            call newLine
            call blanks ( places )
          end if
          call output ( nz(i,j), format='(i4)' )
          call output ( eta(nz(i,j),j), format='(1pg14.6)' )
d316 2
a317 2
        if ( saw_nz ) call newLine
      end if
d320 2
a321 4
    subroutine ShowList ( Dims, Subs, After )
      ! Print "(" subs where dims/=1 ")"
      integer, intent(in) :: Dims(4), Subs(4)
      character(*), intent(in) :: After
d323 5
a327 13
      if ( present(grids_f) ) then
        do s = 1, 3
          if ( dims(s) /= 1 ) exit
        end do
        call output ( subs(s), before="(" )
        do while ( s < 4 )
          s = s + 1
          if ( dims(s) /= 1 ) call output ( subs(s), before="," )
        end do
        call output ( ")" )
      else
        call output ( j, places=4, after=after )
      end if
d329 25
a353 1
  end subroutine Dump_Eta_Column_Sparse
d1609 2
d1775 1
a1775 1
       "$Id: get_eta_matrix_m.f90,v 2.30 2017/09/20 01:06:04 vsnyder Exp $"
d1785 3
@


2.30
log
@Embellish the dump
@
text
@d127 9
a135 1
          call display_string ( lit_indices(grids_f%mol(q)) )
a162 1
        call showList ( dims, subs, '' )
d165 7
a171 2
          if ( .not. saw_nz .and. .not. present(grids_f) ) &
            & call output ( j, places=4, after='#' )
d1625 1
a1625 1
       "$Id: get_eta_matrix_m.f90,v 2.29 2017/06/01 22:50:25 vsnyder Exp $"
d1635 3
@


2.29
log
@Add Get_Column_Sparsity, more dump spiffing
@
text
@d77 3
a79 1
  subroutine Dump_Eta_Column_Sparse ( Eta, Nz, NNz, Name, Short, Show_NZ )
d81 4
a84 1
    use Output_m, only: NewLine, Output
d91 4
a94 2
    integer :: I, J, L
    logical :: MyShort, MyShow_NZ
d97 4
a100 1
    if ( present(name) ) call output ( name, advance='yes' )
d105 5
a109 1
    do j = 1, size(eta,2)
d111 37
d149 2
a150 2
        call output ( j, before='All rows in column ', after=' are nonzero', &
            & advance='yes' )
d155 1
d158 2
a159 1
          if ( .not. saw_nz ) call output ( j, before='Nonzeroes in column ', after=':' )
d163 1
a163 1
            l = 0
d165 1
d173 20
d1613 1
a1613 1
       "$Id: get_eta_matrix_m.f90,v 2.28 2017/05/24 20:29:49 vsnyder Exp $"
d1623 3
@


2.28
log
@Spiff a dump
@
text
@d22 1
d77 1
a77 1
  subroutine Dump_Eta_Column_Sparse ( Eta, Nz, NNz, Name, Short )
d84 5
a88 3
    logical, intent(in), optional :: Short ! "Don't print zero columns"
    integer :: I, J, K
    logical :: MyShort
d93 2
d102 13
a114 7
        call output ( j, before='Nonzeroes in column ', after=':' )
        do i = 1, nnz(j), 5
          do k = i, min(nnz(j),i+4)
            call output ( nz(k,j), format='(i4)' )
            call output ( eta(nz(k,j),j), format='(1pg14.6)' )
          end do
          call newLine
d116 1
d168 25
a192 1
!-----------------------------------------------  Get_Eta_1d_Hunt  -----
d1539 1
a1539 1
       "$Id: get_eta_matrix_m.f90,v 2.27 2016/10/18 00:29:13 vsnyder Exp $"
d1549 3
@


2.27
log
@Add Get_Eta_ZP
@
text
@d76 1
a76 1
  subroutine Dump_Eta_Column_Sparse ( Eta, Nz, NNz, Name )
d83 3
a85 1
    integer :: I, J
d88 2
d91 3
a93 3
      if ( nnz(j) > 5 ) then
        if ( nnz(j) == size(eta,1) ) then
          call output ( j, before='All rows in column ', after=' are nonzero', &
a94 8
        else if ( all(nz(2:nnz(j),j) == nz(1:nnz(j)-1,j)+1) ) then
          call output ( nz(1,j), before='Rows ' )
          call output ( nz(nnz(j),j), before=' through ' )
          call output ( j, before=' of column ', after=' are nonzero', advance='yes' )
        else
          call output ( j, before='Nonzero rows in column ', advance='yes' )
          call dump ( nz(:nnz(j),j) )
        end if
d98 6
a103 3
        do i = 1, nnz(j)
          call output ( nz(i,j), format='(i4)' )
          call output ( eta(nz(i,j),j), format='(1pg14.6)' )
a104 1
        call newLine
d1503 1
a1503 1
       "$Id: get_eta_matrix_m.f90,v 2.26 2013/05/13 23:40:52 vsnyder Exp $"
d1513 3
@


2.26
log
@Check for zero size grid
@
text
@d27 1
a27 1
  public :: Get_Eta_1d_Hunt
d1276 77
d1505 1
a1505 1
       "$Id: get_eta_matrix_m.f90,v 2.25 2013/02/28 21:06:42 vsnyder Exp $"
d1515 3
@


2.25
log
@Try not to access array out of bounds
@
text
@d971 1
d1428 1
a1428 1
       "$Id: get_eta_matrix_m.f90,v 2.24 2011/06/23 01:13:31 vsnyder Exp $"
d1438 3
@


2.24
log
@Add Get_Eta_1D_Hunt
@
text
@d971 5
a975 5
    myRow1 = row1
    myRowN = rowN
    if ( grid(row1) > grid(rowN) ) then ! grid is in opposite order.
      myRow1 = rowN
      myRowN = row1
d1427 1
a1427 1
       "$Id: get_eta_matrix_m.f90,v 2.23 2010/06/07 23:17:20 vsnyder Exp $"
d1437 3
@


2.23
log
@Add another representation for and interpolation using etas
@
text
@d27 1
d158 42
d1427 1
a1427 1
       "$Id: get_eta_matrix_m.f90,v 2.22 2009/06/23 18:26:11 pwagner Exp $"
d1437 3
@


2.22
log
@Prevent Intel from optimizing ident string away
@
text
@d14 1
a14 1
  use MLSCommon, only: RP, IP
d19 1
d24 6
a29 1
  public :: Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_fl_nz, Get_Eta_Sparse_2d_nz
d44 2
a45 2
    module procedure Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_fl_nz
    module procedure Get_Eta_Sparse_2d_nz
d48 19
d69 1
a69 1
       "$RCSfile: $"
d508 132
d1178 94
d1384 1
a1384 1
       "$Id: read_apriori.f90 is it here $"
d1394 3
@


2.21
log
@Repair bug when n_grid == 1
@
text
@d44 1
a44 1
       "$RCSfile: get_eta_matrix_m.f90,v $"
d1130 1
a1131 1
!---------------------------- RCS Ident Info -------------------------------
d1133 2
a1134 3
       "$Id: get_eta_matrix_m.f90,v 2.20 2009/01/16 23:44:15 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1136 1
a1136 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1138 1
d1143 3
@


2.20
log
@Add Dump_Eta_Column_Sparse.  Double-check whether things are sorted.
Corrections to sparse calculations.
@
text
@d156 6
a161 2
    mySorted = .false.
    if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
a162 1
    n_grid = size(grid)
d409 6
a414 2
    mySorted = .false.
    if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
a415 1
    n_grid = size(grid)
d524 6
a529 2
    mySorted = .false.
    if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
a530 1
    n_grid = size(grid)
d662 6
a667 2
    mySorted = .false.
    if ( grid(1) <= grid(2) .and. present(sorted) ) mySorted = sorted
a668 1
    n_grid = size(grid)
d1133 1
a1133 1
       "$Id: get_eta_matrix_m.f90,v 2.19 2008/10/14 20:59:16 vsnyder Exp $"
d1143 4
@


2.19
log
@Undo changes to Select_NZ_List for now
@
text
@d19 1
d27 4
d49 37
a85 1
!---------------------------------------------------  Eta_Func_1d  -----
d157 1
a157 1
    if ( present(sorted) ) mySorted = sorted
d407 1
a407 1
    if ( present(sorted) ) mySorted = sorted
d519 1
a519 1
    if ( present(sorted) ) mySorted = sorted
d654 1
a654 1
    if ( present(sorted) ) mySorted = sorted
d757 8
a764 1
    integer :: I, J, N_Coeffs
d776 1
a776 1
    if ( row1 <= rowN ) then
d780 1
a780 1
      do i = row1, rowN
d788 1
a788 1
      ! Grid are sorted, so we don't need to start from i=row1.
d792 1
a792 1
        do while ( i <= rowN )
d795 4
d800 4
a803 4
          nnz(j-1) = nnz(j-1) + 1
          nz(nnz(j-1),j-1) = i
          nnz(j) = nnz(j) + 1
          nz(nnz(j),j) = i
d810 1
a810 1
      do i = i, rowN
d820 1
a820 1
      do i = row1, rowN, -1
d828 1
a828 1
      ! Grid are sorted, so we don't need to start from i=row1.
d832 1
a832 1
        do while ( i >= rowN )
d835 4
d840 4
a843 4
          nnz(j-1) = nnz(j-1) + 1
          nz(nnz(j-1),j-1) = i
          nnz(j) = nnz(j) + 1
          nz(nnz(j),j) = i
d850 1
a850 1
      do i = i, rowN, -1
d890 8
a897 1
    integer :: I, J, N_Coeffs
d908 1
a908 1
    if ( row1 <= rowN ) then
d912 1
a912 1
      do i = row1, rowN
d923 1
a923 1
      ! Grid are sorted, so we don't need to start from i=row1.
d927 1
a927 1
        do while ( i <= rowN )
d945 1
a945 1
      do i = i, rowN
d957 1
a957 1
      do i = row1, rowN, -1
d968 1
a968 1
      ! Grid are sorted, so we don't need to start from i=row1.
d972 1
a972 1
        do while ( i >= rowN )
d990 1
a990 1
      do i = i, rowN, -1
d1081 3
a1083 3
  subroutine Select_NZ_List ( NZ_1, NNZ_1, List, NZ_2, NNZ_2 )
  ! Select the nonzeros from NZ_1 that are in List and put their indices
  ! in List into NZ_2.
d1087 1
d1098 1
a1098 1
      i2 = 1
d1121 1
a1121 1
       "$Id: get_eta_matrix_m.f90,v 2.18 2008/10/13 23:42:28 vsnyder Exp $"
d1131 3
@


2.18
log
@Compute first,last correctly for 2d cases
@
text
@d1018 3
a1020 3
  subroutine Select_NZ_List ( NZ_1, NNZ_1, List, I_start, NZ_2, NNZ_2 )
  ! Select the nonzeros from NZ_1 that are in List(I_start:) and put their
  ! indices in List into NZ_2.
a1023 1
    integer, intent(in) :: I_Start
d1034 1
a1034 1
      i2 = i_start
d1057 1
a1057 1
       "$Id: get_eta_matrix_m.f90,v 2.17 2007/06/25 20:36:08 vsnyder Exp $"
d1067 3
@


2.17
log
@Add column sparse representation
@
text
@a517 1
        if ( basis(n_coeffs) >= grid(i) ) exit
a565 1
        if ( basis(n_coeffs) >= grid(pi) ) exit
a882 1
        if ( basis(n_coeffs) >= grid(i) ) exit
a927 1
        if ( basis(n_coeffs) >= grid(i) ) exit
d1018 3
a1020 3
  subroutine Select_NZ_List ( NZ_1, NNZ_1, List, NZ_2, NNZ_2 )
  ! Select the nonzeros from NZ_1 that are in List and put their indices
  ! in List into NZ_2.
d1024 1
d1035 1
a1035 1
      i2 = 1
d1058 1
a1058 1
       "$Id: get_eta_matrix_m.f90,v 2.16 2007/06/06 01:15:43 vsnyder Exp $"
d1062 1
d1068 3
@


2.16
log
@Use the PI variable instead of P(I)
@
text
@d20 1
a20 1
  public :: Get_Eta_Sparse
d23 2
d31 1
d699 357
d1061 1
a1061 1
       "$Id: get_eta_matrix_m.f90,v 2.15 2007/01/20 01:06:39 vsnyder Exp $"
d1070 3
@


2.15
log
@Add Get_Eta_Sparse_2d_fl_nz
@
text
@d30 2
a31 1
    module procedure Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_fl_nz, Get_Eta_Sparse_2d_nz
d106 1
a106 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid))
d134 3
a136 2
      if ( grid(p(i)) > basis(1) ) exit
      eta(p(i),1) = 1.0_rp
d144 5
a148 4
        if ( grid(p(i)) > basis(j) ) exit
        if ( basis(j-1) <= grid(p(i)) ) then
          eta(p(i),j-1) = (basis(j) - grid(p(i))) * del_basis
          eta(p(i),j) =   (grid(p(i)) - basis(j-1)) * del_basis
d156 4
a159 3
    do j = n_grid, i, -1
      if ( basis(n_coeffs) >= grid(p(j)) ) exit
      eta(p(j),n_coeffs) = 1.0_rp
d347 1
a347 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid))
d403 3
a405 2
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
d413 4
a416 5
          if ( grid(p(i)) > basis(j) ) exit
          if ( basis(j-1) <= grid(p(i)) ) then
            eta(p(i),j-1) = (basis(j) - grid(p(i))) * del_basis
            eta(p(i),j) =   (grid(p(i)) - basis(j-1)) * del_basis
          end if
d424 3
a426 2
        if ( basis(n_coeffs) >= grid(p(i)) ) exit
        eta(p(i),n_coeffs) = 1.0_rp
d441 1
d443 1
d497 1
a497 1
          if ( basis(j-1) <= grid(i) ) then
d504 4
a507 1
          end if
d529 6
a534 5
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
        not_zero(p(i),1) = .true.
        first(p(i)) = 1
        last(p(i)) = 1
d545 1
a545 1
          if ( basis(j-1) <= grid(pi) ) then
d550 6
a555 3
            first(p(i)) = j - 1
            last(p(i)) = j
          end if
d563 6
a568 5
        if ( basis(n_coeffs) >= grid(p(i)) ) exit
        eta(p(i),n_coeffs) = 1.0_rp
        not_zero(p(i),n_coeffs) = .true.
        first(p(i)) = n_coeffs
        last(p(i)) = n_coeffs
d626 1
a626 1
! Grid(p(:)) are sorted, so we don't need to start from i=1.
d632 1
a632 1
          if ( basis(j-1) <= grid(i) ) then
d637 3
a639 1
          end if
d659 4
a662 3
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
        not_zero(p(i),1) = .true.
d686 4
a689 3
        if ( basis(n_coeffs) >= grid(p(i)) ) exit
        eta(p(i),n_coeffs) = 1.0_rp
        not_zero(p(i),n_coeffs) = .true.
d696 2
d701 1
a701 1
       "$Id: get_eta_matrix_m.f90,v 2.14 2007/01/19 02:38:29 vsnyder Exp $"
d710 3
@


2.14
log
@Separate paths for sorted and unsorted grid
@
text
@a18 1
  public :: Eta_2D_T
a19 1
  public :: Eta_Mat_Mat, Eta_Mat_Vec, Eta_Mult
d22 1
a22 2
  public :: Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_nz
  public :: Get_Eta_Sparse_Eta
a27 4
  interface Eta_Mult
    module procedure Eta_Mat_Mat, Eta_Mat_Vec
  end interface Eta_Mult

d30 1
a30 1
    module procedure Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_nz
a32 8
  type Eta_2D_T
    ! Represent 2-d interpolation coefficient matrices
    real(rp), pointer :: Eta(:,:) => Null()     ! interpolation coefficients
                                                ! allocate (n,2)
    integer, pointer :: FirstCol(:) => NULL()   ! first nonzero column in Eta
                                                ! allocate (n)
  end type Eta_2D_T

d428 3
a430 2
!-------------------------------------------  Get_Eta_Sparse_2d_nz  -----
  subroutine Get_Eta_Sparse_2d_nz ( Basis, Grid, Eta, Not_zero, Sorted )
d447 2
d479 2
d489 8
a496 7
          pi = i
          if ( grid(pi) > basis(j) ) exit
          if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            not_zero(pi,j-1) = .true.
            not_zero(pi,j) = .true.
d508 2
d522 2
d539 2
d552 2
d558 1
a558 1
  end subroutine Get_Eta_Sparse_2d_nz
d560 2
a561 2
!--------------------------------------------  Get_Eta_Sparse_Eta  -----
  subroutine Get_Eta_Sparse_Eta ( Basis, Grid, Eta, Sorted )
d576 2
a577 3
    type(Eta_2d_t), intent(inout) :: Eta ! representation basis function.
                                     ! inout so as not to clobber pointers,
                                     ! which it assumes are associated
d581 1
a581 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid))
d585 9
d601 3
d605 28
a632 1
        p(i) = i
d634 1
d636 1
a637 7
    end if

! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense.
! I is the independent variable grid index and J is the coefficient index

    n_coeffs = size(basis)
d641 5
a645 6
    do i = 1, n_grid
      if ( grid(p(i)) > basis(1) ) exit
      eta%eta(p(i),1) = 1.0_rp
      eta%eta(p(i),2) = 0.0_rp
      eta%firstCol(p(i)) = 1
    end do
d647 2
a648 1
! Normal triangular function for j=2 to j=n_coeffs-1
d650 13
a662 10
    do j = 2 , n_coeffs
      del_basis = 1.0 / (basis(j) - basis(j-1))
      do while ( i <= n_grid )
        if ( grid(p(i)) > basis(j) ) exit
        if ( basis(j-1) <= grid(p(i)) ) then
          eta%eta(p(i),1) = (basis(j) - grid(p(i))) * del_basis
          eta%eta(p(i),2) =   (grid(p(i)) - basis(j-1)) * del_basis
          eta%firstCol(p(i)) = j-1
        end if
        i = i + 1
a663 1
    end do
d667 4
a670 22
    do i = i, n_grid
      if ( basis(n_coeffs) >= grid(p(i)) ) exit
      eta%eta(p(i),1) = 0.0_rp
      eta%eta(p(i),2) = 1.0_rp
      eta%firstCol(p(i)) = n_coeffs - 1
    end do

  end subroutine Get_Eta_Sparse_Eta

!---------------------------------------------------  Eta_Mat_Mat  -----
  subroutine Eta_Mat_Mat ( Eta, Mat_in, Mat_out )
    ! Multiply Eta by Mat_in giving Mat_out
    type(eta_2d_t), intent(in) :: Eta
    real(rp), intent(in) :: Mat_in(:,:)
    real(rp), intent(out) :: Mat_out(:,:)

    integer :: I, J

    do i = 1, size(eta%eta,1)
      do j = 1, size(eta%eta,2)
        mat_out(i,j) = dot_product(eta%eta(i,:), &
                                   mat_in(eta%firstCol(i):eta%firstCol(i)+1,j) )
a671 1
    end do
d673 1
a673 1
  end subroutine Eta_Mat_Mat
d675 1
a675 15
!---------------------------------------------------  Eta_Mat_Vec  -----
  subroutine Eta_Mat_Vec ( Eta, Vec_in, Vec_out )
    ! Multiply Eta by Vec_in giving Vec_out
    type(eta_2d_t), intent(in) :: Eta
    real(rp), intent(in) :: Vec_in(:)
    real(rp), intent(out) :: Vec_out(:)

    integer :: i

    do i = 1, size(eta%eta,1)
      vec_out(i) = dot_product(eta%eta(i,:), &
                               vec_in(eta%firstCol(i):eta%firstCol(i)+1) )
    end do

  end subroutine Eta_Mat_Vec
d680 1
a680 1
       "$Id: get_eta_matrix_m.f90,v 2.13 2006/12/13 21:53:11 vsnyder Exp $"
d689 3
@


2.13
log
@Delete declaration of unused variable
@
text
@d19 1
d21 1
d24 2
a25 1
  public ::  Get_Eta_Sparse_2d, Get_Eta_Sparse_2d_nz
d31 4
d40 8
d362 9
d378 3
d382 23
a404 1
        p(i) = i
d406 1
d408 1
d410 29
d441 27
d469 2
a470 1
! until grid = basis(1),then it ramps down in the usual triangular sense.
d475 47
a521 1
    ! eta(:,:n_coeffs) = 0.0_rp
d525 5
a529 4
    do i = 1, n_grid
      if ( grid(p(i)) > basis(1) ) exit
      eta(p(i),1) = 1.0_rp
    end do
d531 2
a532 1
! Normal triangular function for j=2 to j=n_coeffs-1
d534 13
a546 9
    do j = 2 , n_coeffs
      del_basis = 1.0 / (basis(j) - basis(j-1))
      do while ( i <= n_grid )
        if ( grid(p(i)) > basis(j) ) exit
        if ( basis(j-1) <= grid(p(i)) ) then
          eta(p(i),j-1) = (basis(j) - grid(p(i))) * del_basis
          eta(p(i),j) =   (grid(p(i)) - basis(j-1)) * del_basis
        end if
        i = i + 1
a547 1
    end do
d551 7
a557 4
    do i = i, n_grid
      if ( basis(n_coeffs) >= grid(p(i)) ) exit
      eta(p(i),n_coeffs) = 1.0_rp
    end do
d559 1
a559 1
  end subroutine Get_Eta_Sparse_2d
d561 2
a562 2
!-------------------------------------------  Get_Eta_Sparse_2d_nz  -----
  subroutine Get_Eta_Sparse_2d_nz ( Basis, Grid, Eta, Not_zero, Sorted )
d577 3
a579 2
    real(rp), intent(out) :: Eta(:,:) ! representation basis function
    logical, intent(out) :: Not_zero(:,:) ! where the above is not zero
d583 1
a583 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
a605 2
    eta = 0.0_rp
    not_zero = .false.
d611 3
a613 2
      eta(p(i),1) = 1.0_rp
      not_zero(p(i),1) = .true.
d616 1
a616 2
! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.
d618 2
a619 2
    do j = 2, n_coeffs
      del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
d621 5
a625 7
        pi = p(i)
        if ( grid(pi) > basis(j) ) exit
        if ( basis(j-1) <= grid(pi) ) then
          eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
          eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
          not_zero(pi,j-1) = .true.
          not_zero(pi,j) = .true.
d635 21
a655 2
      eta(p(i),n_coeffs) = 1.0_rp
      not_zero(p(i),n_coeffs) = .true.
d658 17
a674 1
  end subroutine Get_Eta_Sparse_2d_nz
d679 1
a679 1
       "$Id: get_eta_matrix_m.f90,v 2.12 2006/12/09 02:23:45 vsnyder Exp $"
d688 3
@


2.12
log
@Use generic instead of optional, add First, Last
@
text
@d343 1
a343 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
d485 1
a485 1
       "$Id: get_eta_matrix_m.f90,v 2.11 2006/06/29 02:51:30 vsnyder Exp $"
d494 3
@


2.11
log
@Correct a recently-introduced bug
@
text
@d20 3
a22 1
  public :: Get_Eta_Sparse, Get_Eta_Sparse_1d, Get_Eta_Sparse_2d
d29 2
a30 1
    module procedure Get_Eta_Sparse_1d, Get_Eta_Sparse_2d
d161 1
a161 1
  subroutine Get_Eta_Sparse_1d ( Basis, Grid_Pt, Eta, Not_zero )
a172 1
    logical, optional, intent(out) :: Not_zero(:) ! where the above is not zero
a183 1
    if ( present(not_zero) ) then
d185 46
a230 2
      ! not_zero(:,:n_coeffs) = .false.
      not_zero = .false.
d234 6
a239 4
      if ( grid_pt <= basis(1) ) then
        eta(1) = 1.0
        not_zero(1) = .true.
      end if
d243 3
a245 1
      do j = 2 , n_coeffs
d247 7
a253 8
         if ( grid_pt <= basis(j) .and. &
           &  basis(j-1) <= grid_pt ) then
           eta(j-1) = (basis(j) - grid_pt) * del_basis
           eta(j) =   (grid_pt - basis(j-1)) * del_basis
           not_zero(j-1) = .true.
           not_zero(j) = .true.
         end if
      end do
d257 27
a283 4
      if ( basis(n_coeffs) < grid_pt ) then
        eta(n_coeffs) = 1.0_rp
        not_zero(n_coeffs) = .true.
      end if
d285 6
a290 1
    else ! not_zero is not present; this is just eta_func inlined
d294 5
a298 1
      if ( grid_pt <= basis(1) ) eta(1) = 1.0_rp
d300 1
a300 1
! Normal triangular function for j=2 to j=n_coeffs-1
d302 3
a304 1
      do j = 2 , n_coeffs
d306 7
a312 6
         if ( grid_pt <= basis(j) .and. &
           &  basis(j-1) <= grid_pt ) then
          eta(j-1) = (basis(j) - grid_pt) * del_basis
          eta(j) =   (grid_pt - basis(j-1)) * del_basis
        end if
      end do
d316 3
a318 2
      if ( basis(n_coeffs) < grid_pt ) eta(n_coeffs) = 1.0_rp

d321 1
a321 1
  end subroutine Get_Eta_Sparse_1d
d324 1
a324 1
  subroutine Get_Eta_Sparse_2d ( Basis, Grid, Eta, Not_zero, Sorted )
a339 1
    logical, optional, intent(out) :: Not_zero(:,:) ! where the above is not zero
a367 4
    if ( present(not_zero) ) then

      ! not_zero(:,:n_coeffs) = .false.
      not_zero = .false.
d371 4
a374 5
      do i = 1, n_grid
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
        not_zero(p(i),1) = .true.
      end do
d376 1
a376 2
! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.
d378 9
a386 13
      do j = 2, n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
          if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            not_zero(pi,j-1) = .true.
            not_zero(pi,j) = .true.
          end if
          i = i + 1
        end do
d388 1
d392 41
a432 4
      do i = i, n_grid
        if ( basis(n_coeffs) >= grid(p(i)) ) exit
        eta(p(i),n_coeffs) = 1.0_rp
        not_zero(p(i),n_coeffs) = .true.
d434 7
d442 3
a444 1
    else ! not_zero is not present; this is just eta_func inlined
d448 5
a452 4
      do i = 1, n_grid
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
      end do
d454 2
a455 1
! Normal triangular function for j=2 to j=n_coeffs-1
d457 12
a468 10
      do j = 2 , n_coeffs
        del_basis = 1.0 / (basis(j) - basis(j-1))
        do while ( i <= n_grid )
          if ( grid(p(i)) > basis(j) ) exit
          if ( basis(j-1) <= grid(p(i)) ) then
            eta(p(i),j-1) = (basis(j) - grid(p(i))) * del_basis
            eta(p(i),j) =   (grid(p(i)) - basis(j-1)) * del_basis
          end if
          i = i + 1
        end do
d470 1
d474 5
a478 4
      do i = i, n_grid
        if ( basis(n_coeffs) >= grid(p(i)) ) exit
        eta(p(i),n_coeffs) = 1.0_rp
      end do
d480 1
a480 3
    end if

  end subroutine Get_Eta_Sparse_2d
d485 1
a485 1
       "$Id: get_eta_matrix_m.f90,v 2.10 2006/06/29 01:44:02 vsnyder Exp $"
d494 3
@


2.10
log
@Make the 1d stuff work.  It wasn't used until metrics was revised
@
text
@d318 4
a321 3
      do j = n_grid, i, -1
        if ( basis(n_coeffs) >= grid(p(j)) ) exit
        eta(p(j),n_coeffs) = 1.0_rp
d349 3
a351 3
      do j = n_grid, i, -1
        if ( basis(n_coeffs) >= grid(p(j)) ) exit
        eta(p(j),n_coeffs) = 1.0_rp
d361 1
a361 1
       "$Id: get_eta_matrix_m.f90,v 2.9 2005/12/23 03:12:42 vsnyder Exp $"
d370 3
@


2.9
log
@Simplify last basis calculation
@
text
@d19 1
d22 4
d37 49
a85 2
!---------------------------------------------  Get_Eta_Sparse_2d  -----
  subroutine Get_Eta_Sparse_2d ( Basis, Grid, Eta, Not_zero, Sorted )
d87 1
a87 3
! Compute the eta matrix.  Basis is assumed to be sorted.  Grid need not
! be sorted, but if it is, Sorted can be set .true. to suppress sorting it
! here.
d98 1
a98 2
    real(rp), intent(out) :: Eta(:,:) ! representation basis function
    logical, optional, intent(out) :: Not_zero(:,:) ! where the above is not zero
d102 1
a102 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid)), PI
d120 3
a122 3
! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense.
! I is the independent variable grid index and J is the coefficient index
a125 5
    ! eta(:,:n_coeffs) = 0.0_rp
    if ( present(not_zero) ) then

      ! not_zero(:,:n_coeffs) = .false.
      not_zero = .false.
d129 4
a132 5
      do i = 1, n_grid
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
        not_zero(p(i),1) = .true.
      end do
d134 1
a134 19
! Normal triangular function for j=2 to j=n_coeffs-1.  Both Basis and
! Grid(p(:)) are sorted, so we don't need to start from i=1.

      do j = 2 , n_coeffs
        del_basis = 1.0_rp / ( basis(j) - basis(j-1) )
        do while ( i <= n_grid )
          pi = p(i)
          if ( grid(pi) > basis(j) ) exit
          if ( basis(j-1) <= grid(pi) ) then
            eta(pi,j-1) = (basis(j) - grid(pi)) * del_basis
            eta(pi,j  ) = (grid(pi) - basis(j-1)) * del_basis
            not_zero(pi,j-1) = .true.
            not_zero(pi,j) = .true.
          end if
          i = i + 1
        end do
      end do

! last basis calculation
d136 2
d139 4
a142 3
        if ( basis(n_coeffs) < grid(p(i)) ) then
          eta(p(i),n_coeffs) = 1.0_rp
          not_zero(p(i),n_coeffs) = .true.
d146 1
a146 23

    else ! not_zero is not present

! first basis calculation

      do i = 1, n_grid
        if ( grid(p(i)) > basis(1) ) exit
        eta(p(i),1) = 1.0_rp
      end do

! Normal triangular function for j=2 to j=n_coeffs-1

      do j = 2 , n_coeffs
        del_basis = basis(j) - basis(j-1)
        do while ( i <= n_grid )
          if ( grid(p(i)) > basis(j) ) exit
          if ( basis(j-1) <= grid(p(i)) ) then
            eta(p(i),j-1) = (basis(j) - grid(p(i))) / del_basis
            eta(p(i),j) =   (grid(p(i)) - basis(j-1)) / del_basis
          end if
          i = i + 1
        end do
      end do
d150 4
a153 4
      do j = n_grid, i, -1
        if ( basis(n_coeffs) >= grid(p(j)) ) exit
        eta(p(j),n_coeffs) = 1.0_rp
      end do
d155 1
a155 3
    end if

  end subroutine Get_Eta_Sparse_2d
a179 1

d197 5
a201 5
        del_basis = basis(j) - basis(j-1)
         if ( grid_pt > basis(j) ) exit
         if ( basis(j-1) <= grid_pt ) then
           eta(j-1) = (basis(j) - grid_pt) / del_basis
           eta(j) =   (grid_pt - basis(j-1)) / del_basis
d214 1
a214 1
    else ! not_zero is not present
d223 5
a227 5
        del_basis = basis(j) - basis(j-1)
        if ( grid_pt > basis(j) ) exit
        if ( basis(j-1) <= grid_pt ) then
          eta(j-1) = (basis(j) - grid_pt) / del_basis
          eta(j) =   (grid_pt - basis(j-1)) / del_basis
d233 1
a233 1
      if ( grid_pt > basis(n_coeffs) ) eta(n_coeffs) = 1.0_rp
d239 118
d360 1
a360 1
       "$Id: get_eta_matrix_m.f90,v 2.8 2005/12/22 20:55:16 vsnyder Exp $"
d369 3
@


2.8
log
@Improve handling of sorted grid, some cannonball polishing
@
text
@d144 3
a146 5
      do while ( i <= n_grid )
        if ( basis(n_coeffs) < grid(p(i)) ) then
          eta(p(i),n_coeffs) = 1.0_rp
        end if
        i = i + 1
d239 1
a239 1
       "$Id: get_eta_matrix_m.f90,v 2.7 2005/12/10 01:52:44 vsnyder Exp $"
d248 3
@


2.7
log
@Added Get_Eta_Sparse_1d, made Get_Eta_Sparse generic
@
text
@d35 3
a37 1
! Compute the eta matrix
d53 1
a53 1
    integer(ip) :: I, J, N_coeffs, N_Grid, P(size(grid))
d68 1
a68 1
      call sortp ( grid, 1, n_grid, p ) ! grid(p(i)) are now sorted
d92 1
a92 1
! Grid are sorted, so we don't need to start from i=1.
d95 1
a95 1
        del_basis = basis(j) - basis(j-1)
d97 7
a103 6
          if ( grid(p(i)) > basis(j) ) exit
          if ( basis(j-1) <= grid(p(i)) ) then
            eta(p(i),j-1) = (basis(j) - grid(p(i))) / del_basis
            eta(p(i),j) =   (grid(p(i)) - basis(j-1)) / del_basis
            not_zero(p(i),j-1) = .true.
            not_zero(p(i),j) = .true.
d241 1
a241 1
       "$Id: get_eta_matrix_m.f90,v 2.6 2005/06/22 18:08:19 pwagner Exp $"
d250 3
@


2.6
log
@Reworded Copyright statement, moved rcs id
@
text
@d19 5
a23 1
  public :: Get_Eta_Sparse
d27 1
a27 1
       "$RCSfile: $"
d31 3
a33 2
!---------------------------------------------------
  subroutine Get_Eta_Sparse ( Basis, Grid, Eta, Not_zero )
d42 1
d53 1
d57 3
d61 7
a67 1
    call sortp ( grid, 1, n_grid, p ) ! grid(p(i)) are now sorted
d150 84
a233 1
  end subroutine Get_Eta_Sparse
d238 1
a238 1
       "$Id: $"
d247 3
@


2.5
log
@Sort GRID and merge with Basis instead of using WHERE
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d21 3
a23 6
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: get_eta_matrix_m.f90,v 2.4 2003/03/21 17:02:19 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: get_eta_matrix_m.f90,v $"
d137 5
d148 3
@


2.4
log
@Initalizating whole eta, not_zero arrays instead of sections
@
text
@d15 1
a15 1
    & "$Id: get_eta_matrix_m.f90,v 2.3 2002/10/08 17:08:04 pwagner Exp $"
d27 1
d40 1
a40 1
    integer(ip) :: J, N_coeffs
d43 5
a59 2
! The wheres could be replaced with a search routine which would speed
! this up some more but you have to worry about sorting grid.
d62 5
a66 4
      where ( grid <= basis(1) )
        eta(:,1) = 1.0_rp
        not_zero(:,1) = .true.
      end where
d68 2
a69 1
! Normal triangular function for j=2 to j=n_coeffs-1
d73 10
a82 6
        where ( basis(j-1) <= grid .and. grid <= basis(j) )
          eta(:,j-1) = (basis(j) - grid) / del_basis
          eta(:,j) =   (grid - basis(j-1)) / del_basis
          not_zero(:,j-1) = .true.
          not_zero(:,j) = .true.
        end where
d87 7
a93 4
      where ( basis(n_coeffs) < grid )
        eta(:,n_coeffs) = 1.0_rp
        not_zero(:,n_coeffs) = .true.
      end where
d95 1
a95 1
    else
d99 4
a102 1
      where ( grid <= basis(1) ) eta(:,1) = 1.0_rp
d108 8
a115 4
        where ( basis(j-1) <= grid .and. grid <= basis(j) )
          eta(:,j-1) = (basis(j) - grid)/ del_basis
          eta(:,j) =   (grid - basis(j-1))/ del_basis
        end where
d120 6
a125 1
      where ( basis(n_coeffs) < grid ) eta(:,n_coeffs) = 1.0_rp
d138 3
@


2.3
log
@Added idents to survive zealous Lahey optimizer
@
text
@d15 1
a15 1
    & "$Id: get_eta_matrix_m.f90,v 2.2 2002/09/06 20:50:28 vsnyder Exp $"
d47 2
a48 1
    eta(:,:n_coeffs) = 0.0_rp
d51 2
a52 1
      not_zero(:,:n_coeffs) = .false.
d113 3
@


2.2
log
@Insert copyright notice, bound some array assignments
@
text
@d15 1
a15 1
    & "$Id: get_eta_matrix_m.f90,v 2.1 2002/09/06 18:17:19 vsnyder Exp $"
d19 1
d104 4
d111 3
@


2.1
log
@Cosmetic changes, move USEs from module scope to procedure scope
@
text
@d1 2
a2 2

! This module computes the eta matrix
d15 1
a15 1
    & "$Id: get_eta_matrix_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d24 2
d46 1
a46 1
    eta = 0.0_rp
d49 1
a49 1
      not_zero = .false.
d65 2
a66 2
          eta(:,j-1) = (basis(j) - grid)/ del_basis
          eta(:,j) =   (grid - basis(j-1))/ del_basis
d74 1
a74 1
      where(basis(n_coeffs) < grid)
d106 3
@


2.0
log
@New forward model
@
text
@d1 1
a1 1
!
a2 6
!
MODULE get_eta_matrix_m
!
 use MLSCommon, only: RP, IP
!
 IMPLICIT none
d4 8
a11 2
 Private
 Public :: get_eta_sparse
d14 5
a18 4
  CHARACTER (LEN=256) :: Id = &
 "$Id: get_eta_matrix_m.f90,v 1.1.2.3 2001/09/12 21:38:49 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
 "$RCSfile: get_eta_matrix_m.f90,v $"
d20 1
a20 1
CONTAINS
d22 2
a23 2
 SUBROUTINE get_eta_sparse(basis,grid,eta,not_zero)
!
d25 4
a28 4
!
  REAL(rp), INTENT(in) :: basis(:) ! basis break points
  REAL(rp), INTENT(in) :: grid(:)  ! grid values
!
d30 4
a33 4
!
  REAL(rp), INTENT(out) :: eta(:,:) ! representation basis function
  LOGICAL, OPTIONAL, INTENT(out) :: not_zero(:,:) ! where the above is not zero
!
d35 4
a38 4
!
  INTEGER(ip) :: j, n_coeffs
  REAL(rp) :: del_basis
!
d40 8
a47 6
! until grid = basis(1),then it ramps down in the usual triangular sense
! i is the independent variable grid index and j is the coefficient index
!
  n_coeffs = SIZE(basis)
  eta = 0.0_rp
  IF(PRESENT(not_zero)) THEN
a48 2
    not_zero = .false.
!
d52 6
a57 6
!
    WHERE(grid <= basis(1))
      eta(:,1) = 1.0_rp
      not_zero(:,1) = .true.
    ENDWHERE
!
d59 11
a69 11
!
    DO j = 2 , n_coeffs
      del_basis = basis(j) - basis(j-1)
      WHERE(basis(j-1) <= grid .AND. grid <= basis(j))
        eta(:,j-1) = (basis(j) - grid)/ del_basis
        eta(:,j) =   (grid - basis(j-1))/ del_basis
        not_zero(:,j-1) = .true.
        not_zero(:,j) = .true.
      ENDWHERE
    ENDDO
!
d71 8
a78 8
!
    WHERE(basis(n_coeffs) < grid)
      eta(:,n_coeffs) = 1.0_rp
      not_zero(:,n_coeffs) = .TRUE.
    ENDWHERE
!
  ELSE
!
d80 3
a82 3
!
    WHERE(grid <= basis(1)) eta(:,1) = 1.0_rp
!
d84 9
a92 9
!
    DO j = 2 , n_coeffs
      del_basis = basis(j) - basis(j-1)
      WHERE(basis(j-1) <= grid .AND. grid <= basis(j))
        eta(:,j-1) = (basis(j) - grid)/ del_basis
        eta(:,j) =   (grid - basis(j-1))/ del_basis
      ENDWHERE
    ENDDO
!
d94 8
a101 8
!
    WHERE(basis(n_coeffs) < grid) eta(:,n_coeffs) = 1.0_rp
!
  ENDIF
!
 END SUBROUTINE get_eta_sparse
!
END MODULE get_eta_matrix_m
d104 3
d109 2
a110 2
!
!
@


1.1
log
@file get_eta_matrix_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 106
@


1.1.2.1
log
@Major Design change..
@
text
@a0 93
!
! This module computes the eta matrix
!
MODULE get_eta_matrix_m
!
! Set the precision
!
 use MLSCommon, only: RP, IP
!
 IMPLICIT none
!
CONTAINS
!
 SUBROUTINE get_eta_sparse(basis,grid,eta,not_zero)
!
! Inputs
!
  REAL(rp), INTENT(in) :: basis(:) ! basis break points
  REAL(rp), INTENT(in) :: grid(:)  ! grid values
!
! Outputs
!
  REAL(rp), INTENT(out) :: eta(:,:) ! representation basis function
  LOGICAL, OPTIONAL, INTENT(out) :: not_zero(:,:) ! where the above is not zero
!
! Internals
!
  INTEGER(ip) :: j, n_coeffs
  REAL(rp) :: del_basis
!
! The first coefficient is one for all values of grid below basis(1)
! until grid = basis(1),then it ramps down in the usual triangular sense
! i is the independent variable grid index and j is the coefficient index
!
  n_coeffs = SIZE(basis)
  eta = 0.0_rp
  IF(PRESENT(not_zero)) THEN

    not_zero = .false.
!
! The wheres could be replaced with a search routine which would speed
! this up some more but you have to worry about sorting grid.
! first basis calculation
!
    WHERE(grid <= basis(1))
      eta(:,1) = 1.0_rp
      not_zero(:,1) = .true.
    ENDWHERE
!
! Normal triangular function for j=2 to j=n_coeffs-1
!
    DO j = 2 , n_coeffs
      del_basis = basis(j) - basis(j-1)
      WHERE(basis(j-1) <= grid .AND. grid <= basis(j))
        eta(:,j-1) = (basis(j) - grid)/ del_basis
        eta(:,j) =   (grid - basis(j-1))/ del_basis
        not_zero(:,j-1) = .true.
        not_zero(:,j) = .true.
      ENDWHERE
    ENDDO
!
! last basis calculation
!
    WHERE(basis(n_coeffs) < grid)
      eta(:,n_coeffs) = 1.0_rp
      not_zero(:,n_coeffs) = .TRUE.
    ENDWHERE
!
  ELSE
!
! first basis calculation
!
    WHERE(grid <= basis(1)) eta(:,1) = 1.0_rp
!
! Normal triangular function for j=2 to j=n_coeffs-1
!
    DO j = 2 , n_coeffs
      del_basis = basis(j) - basis(j-1)
      WHERE(basis(j-1) <= grid .AND. grid <= basis(j))
        eta(:,j-1) = (basis(j) - grid)/ del_basis
        eta(:,j) =   (grid - basis(j-1))/ del_basis
      ENDWHERE
    ENDDO
!
! last basis calculation
!
    WHERE(basis(n_coeffs) < grid) eta(:,n_coeffs) = 1.0_rp
!
  ENDIF
!
 END SUBROUTINE get_eta_sparse
!
END MODULE get_eta_matrix_m
@


1.1.2.2
log
@Minor bug..
@
text
@d6 2
@


1.1.2.3
log
@Added CVS stuff
@
text
@d9 1
a9 10

 Private
 Public :: get_eta_sparse

!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
 "$Id: two_d_hydrostatic_m.f90,v 1.9.2.1 2001/09/10 10:02:32 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
 "$RCSfile: two_d_hydrostatic_m.f90,v $"
!---------------------------------------------------------------------------
d11 1
a11 1
!---------------------------------------------------
a91 3
!---------------------------------------------------
! $Log$
!
@


