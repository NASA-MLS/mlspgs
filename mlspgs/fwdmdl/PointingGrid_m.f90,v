head	2.19;
access;
symbols
	v5-02-NRT-19:2.19
	v6-00:2.19
	v5-02-NRT-18:2.19
	v5-02:2.17
	v5-01-NRT-17:2.19
	v5-01-NRT-16:2.19
	v5-01-NRT-15:2.19
	v5-01-NRT-14:2.19
	neuralnetworks-1-0:2.19.0.4
	cfm-single-freq-0-1:2.19.0.2
	v5-01:2.17
	v5-00:2.17
	v4-23-TA133:2.17.0.6
	mus-emls-1-70:2.17.0.4
	rel-1-0-englocks-work:2.17.0.2
	VUMLS1-00:2.17
	VPL1-00:2.16
	V4-22-NRT-08:2.16
	VAM1-00:2.16
	V4-21:2.15.0.2
	V4-13:2.14
	V4-12:2.13
	V4-11:2.13
	V4-10:2.13
	V3-43:2.11
	M4-00:2.12
	V3-41:2.11
	V3-40-PlusGM57:2.11.0.2
	V2-24-NRT-04:2.10
	V3-33:2.11
	V2-24:2.10
	V3-31:2.11
	V3-30-NRT-05:2.11
	cfm-01-00:2.11
	V3-30:2.11
	V3-20:2.11
	V3-10:2.11
	V2-23-NRT-02:2.10
	V2-23:2.10
	V2-22-NRT-01:2.10
	V2-22:2.10
	V2-21:2.8
	V2-20:2.8
	V2-11:2.8
	V2-10:2.8
	V2-00:2.8
	V1-51:2.7
	V1-50:2.7
	V1-45:2.7
	V1-44:2.7
	V1-43:2.5
	V1-32:2.5
	V1-31:2.5
	V1-30:2.5
	V1-13:2.3
	V1-12:2.3
	V1-11:2.3
	V1-10:2.3
	newfwm-feb03:2.3.0.2
	V1-04:2.0
	V1-03:2.0
	V1-02:2.0
	JointForwardModel:2.1.0.2
	V1-00:2.0
	newfwm-sep01:1.17.0.2
	V0-7:1.17
	V0-5-Level2:1.16
	V0-5-SIPS:1.12;
locks; strict;
comment	@# @;


2.19
date	2020.02.07.01.09.23;	author pwagner;	state Exp;
branches;
next	2.18;

2.18
date	2020.01.27.18.17.26;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2016.09.08.20.52.59;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2015.03.28.02.00.28;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2014.11.06.00.00.09;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2014.09.05.20.51.33;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2013.08.30.03.56.23;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2011.05.09.17.52.15;	author pwagner;	state Exp;
branches;
next	2.11;

2.11
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2007.10.03.23.58.26;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2007.05.23.22.40.20;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2004.05.29.02.49.51;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2004.05.26.23.54.14;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2003.05.19.19.58.07;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2003.05.10.22.20.57;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2002.10.08.17.08.05;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2002.09.13.22.58.22;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2002.05.08.08.53.43;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.26;	author livesey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.07.23.30.33;	author pwagner;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.05.04.00.49.43;	author livesey;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.26.02.36.52;	author vsnyder;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.20.02.55.56;	author zvi;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.19.06.48.14;	author zvi;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.13.22.50.27;	author livesey;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.21.39.15;	author vsnyder;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.30.01.34.33;	author vsnyder;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.30.01.28.13;	author vsnyder;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.23.53.21;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.28.00.42.37;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.20.02.31.32;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.17.19.17.57;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.17.02.34.03;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.17.01.22.23;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.17.00.24.56;	author vsnyder;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.16.23.12.14;	author vsnyder;	state Exp;
branches;
next	;

1.17.2.1
date	2001.09.09.03.06.08;	author livesey;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.09.14.20.14.49;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.19
log
@May Dump a single Grid if so desired
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module PointingGrid_m

  ! Read the pointing grid file.  Make a database of pointing grids.
  ! Link them to and from the Signals database in MLSSignals_m
  
  ! ---------------------- TBD ----------------------------
  
  ! Should point to any relevant documentation on Pointing Grids
  ! How are the files formatted?
  ! How are they created?
  ! ---------------------- TBD ----------------------------

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use MLSKinds, only: R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSSignals_M, only: DisplaysignalName, Maxsiglen, Signals, Signal_T

  ! More USEs below in each procedure, if they're only used therein.

  private
  ! Public procedures:
  public :: Open_Pointing_Grid_File, Read_Pointing_Grid_File
  public :: Close_Pointing_Grid_File, Destroy_Pointing_Grid_Database
  public :: Dump_Pointing_Grid_Database, Dump_Pointing_Grid

  type, public :: OneGrid_T
    real(r8) :: Height                            ! Zeta, actually
    real(r8), allocatable, dimension(:) :: Frequencies
  end type OneGrid_T

  type, public :: PointingGrid_T
    type(signal_T), allocatable, dimension(:) :: Signals
    real(r8) :: CenterFrequency         ! Should be gotten from Bands database
    !??? Maybe not.  The one in the pointing grid file appears to have been
    !??? Doppler shifted.
    type(oneGrid_t), allocatable, dimension(:) :: OneGrid
  end type PointingGrid_T

  type(pointingGrid_t), public, pointer, dimension(:) :: &
    & PointingGrids => NULL()

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: PointingGrid_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! ------------------------------------  Open_Pointing_Grid_File  -----
  subroutine Open_Pointing_Grid_File ( Filename, Lun )

    character(len=*), intent(in) :: Filename ! Name of the pointing grid file
    integer, intent(out) :: Lun              ! Logical unit number to read it

    logical :: Exist, Opened
    character(127) :: IOMSG
    integer :: Status

    do lun = 20, 99
      inquire ( unit=lun, exist=exist, opened=opened )
      if ( exist .and. .not. opened ) EXIT
    end do
    if ( opened .or. .not. exist ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    open ( unit=lun, file=filename, status='old', form='formatted', &
      & access='sequential', iostat=status, iomsg=iomsg )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "Unable to open pointing grid file " // Filename // ": " // trim(iomsg) )
  end subroutine Open_Pointing_Grid_File

  ! ------------------------------------  Read_Pointing_Grid_File  -----
  ! Should document format of Pointing_Grid_File or else
  ! point to location of file format.
  subroutine Read_Pointing_Grid_File ( Lun, Where )
    use Allocate_Deallocate, only: Test_Allocate
    use, Intrinsic :: Iso_C_Binding, only: C_Intptr_T, C_Loc
    use Machine, only: Io_Error
    use MLSStringlists, only: Switchdetail
    use Parse_Signal_M, only: Parse_Signal
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

    integer, intent(in) :: Lun               ! Logical unit number to read it
    integer, intent(in) :: Where             ! In the L2CF tree, for tracing

    integer(c_intptr_t) :: Addr         ! For tracing
    logical, pointer, dimension(:) :: Channels ! Specified in a signal
    real(r8) :: Frequency                    ! Center frequency for the grid.
    !                                          Read from the input file.
    !                                          Should ultimately come from the
    !                                          signals database.
    real(r8) :: Height                       ! Zeta, actually, from the file
    integer, allocatable, dimension(:) :: HowManyGrids  ! per radiometer batch
    integer, allocatable, dimension(:) :: HowManySignals ! per radiometer batch
    integer :: HowManyRadiometers            ! gotten by counting the file
    integer :: I, N                          ! Loop inductor, subscript, temp
    character(127) :: IOMSG
    character(len=MaxSigLen) :: Line         ! From the input file
    integer :: LineNo                        ! In the input file
    integer :: Me = -1                       ! String index for trace
    integer :: NumHeights                    ! Read from the input
    integer :: Sideband                      ! Specified in a signal
    integer :: SignalCount                   ! From Parse_Signal
    integer :: Status                        ! From read or allocate
    integer, pointer, dimension(:) :: Signal_Indices   ! From Parse_Signal, q.v.
    integer, allocatable :: Temp(:)          ! For increasing sizes
    character(3) :: Which                    ! Which I/O statement caused error

    call trace_begin ( me, "Read_Pointing_Grid_File", where, &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    if ( associated(pointingGrids) ) call destroy_pointing_grid_database

    call allocate_test ( howManyGrids, size(signals), 'HowManyGrids', &
      & moduleName )
    call allocate_test ( howManySignals, size(signals), 'HowManySignals', &
      & moduleName )

    ! First, read through the file and count how much stuff is there.
    which = ' A ' ! in case of error
    lineNo = 1
    read ( lun, '(A)', end=98, err=99, iostat=status, iomsg=iomsg ) line
    howManyRadiometers = 0
outer1: do
      howManyRadiometers = howManyRadiometers + 1
      if ( howManyRadiometers > size(howManyGrids) ) then ! Double table sizes
        call allocate_test ( temp, 2*size(howManyGrids), &
          & 'HowManyGrids', moduleName )
        temp(:size(howManyGrids)) = howManyGrids
        call move_alloc ( temp, howManyGrids )
        call allocate_test ( temp, 2*size(howmanySignals), &
          & 'HowmanySignals', moduleName )
        temp(:size(howmanySignals)) = howmanySignals
        call move_alloc ( temp, howmanySignals )
      end if
      howManySignals(howManyRadiometers) = 0
      nullify(signal_indices)
      line = adjustl(line)
      do
        call parse_signal ( line, signal_indices, onlyCountEm = signalCount )
        if ( signalCount == 0 ) call MLSMessage ( MLSMSG_Error, &
          & moduleName, "Improper signal specification: " // trim(line) )
        howManySignals(howManyRadiometers) = &
          & howManySignals(howManyRadiometers) + signalCount
        which = ' B ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, '(A)', end=98, err=99, iostat=status, iomsg=iomsg ) line
        line = adjustl(line)
        if ( verify(line(1:1), ' 0123456789.+-') == 0 ) EXIT ! a number
      end do
      which = ' C ' ! in case of error
      read ( line, *, err=99, iostat=status, iomsg=iomsg ) Frequency
      howManyGrids(howManyRadiometers) = 0
      do
        which = ' D ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, '(A)', err=99, iostat=status, iomsg=iomsg ) line
        if ( status < 0 ) EXIT outer1
        line = adjustl(line)
        if ( verify(line(1:1), ' 0123456789.+-') /= 0 ) EXIT ! not a number
        howManyGrids(howManyRadiometers) = howManyGrids(howManyRadiometers) + 1
        which = ' E ' ! in case of error
        read ( line, *, err=99, iostat=status, iomsg=iomsg ) height, numHeights
        which = ' F ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, *, err=99, end=98, iostat=status, iomsg=iomsg ) ( height, i = 1, numHeights )
      end do
    end do outer1

    rewind ( lun )
    ! Now that we know how much is there, allocate the data structures.
    allocate ( pointingGrids(howManyRadiometers), stat=status )
    addr = 0
    if ( status == 0 .and. howManyRadiometers > 0 ) &
      & addr = transfer(c_loc(pointingGrids(1)), addr)
    call test_allocate ( status, moduleName, "PointingGrids", &
      & uBounds = howManyRadiometers, elementSize = storage_size(pointingGrids) / 8, &
      & address=addr )
    which = ' G ' ! in case of error
    lineNo = 1
    read ( lun, '(A)', iostat=status, iomsg=iomsg ) line  ! Read the first radiometer spec
    if ( status > 0 ) go to 99
    howManyRadiometers = 0
outer2: do
      howManyRadiometers = howManyRadiometers + 1
      allocate ( pointingGrids(howManyRadiometers)%signals( &
        & howManySignals(howManyRadiometers) ), stat=status )
      addr = 0
      if ( status == 0 .and. howManySignals(howManyRadiometers) > 0 ) &
        & addr = transfer(c_loc(pointingGrids(howManyRadiometers)%signals(1)), addr)
      call test_allocate ( status, moduleName, "PointingGrids(?)%signals", &
        & uBounds = howManySignals(howManyRadiometers), &
        & elementSize = storage_size(pointingGrids(howManyRadiometers)%signals) / 8, &
        & address=addr )
      n = 0 ! Counter in pointingGrids(howManyRadiometers)%signals
      nullify ( signal_indices, channels )
      line = adjustl(line)
      do
        call parse_signal ( line, signal_indices, &
          & sideband=sideband, channels=channels )
        ! Errors were checked during the "counting" phase above
        do i = 1, size(signal_indices)
          n = n + 1
          pointingGrids(howManyRadiometers)%signals(n) = &
            & signals(signal_indices(i))
          pointingGrids(howManyRadiometers)%signals(n)%sideband = sideband
          pointingGrids(howManyRadiometers)%signals(n)%channels => channels
        end do
        call deallocate_test ( signal_indices, 'Signal_Indices', moduleName )
        which = ' H ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, '(A)', err=99, iostat=status, iomsg=iomsg ) line
        line = adjustl(line)
        if ( verify(line(1:1), ' 0123456789.+-') == 0 ) EXIT ! a number
      end do
      !??? Should the centerFrequency be gotten from the signals database?
      !??? Maybe not.  The one in the pointing grid file appears to have been
      !??? Doppler shifted.
      which = ' I ' ! in case of error
      read ( line, *, err=99, iostat=status, iomsg=iomsg ) &
        & pointingGrids(howManyRadiometers)%centerFrequency
      allocate ( pointingGrids(howManyRadiometers)% &
        & oneGrid(howManyGrids(howManyRadiometers)), stat=status )
      addr = 0
      if ( status == 0 .and. howManyGrids(howManyRadiometers) > 0 ) &
        & addr = transfer(c_loc(pointingGrids(howManyRadiometers)%oneGrid(1)), addr)
      call test_allocate ( status, moduleName, "PointingGrids(?)%OneGrid", &
        & uBounds = howManyGrids(howManyRadiometers), &
        & elementSize = storage_size(pointingGrids(howManyRadiometers)%oneGrid) / 8, &
        & address=addr )
      n = 0
      do
        which = ' J ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, '(A)', err=99, iostat=status, iomsg=iomsg ) line
        line = adjustl(line)
        if ( status < 0 ) EXIT outer2
        if ( verify(line(1:1), ' 0123456789.+-') /= 0 ) EXIT ! not a number
        n = n + 1
        which = ' K ' ! in case of error
        read ( line, *, iostat=status, err=99, iomsg=iomsg ) height, numHeights
        if ( status < 0 ) EXIT outer2
        if ( status /= 0 ) goto 99
        pointingGrids(howManyRadiometers)%oneGrid(n)%height = height
        call allocate_test ( &
          & pointingGrids(howManyRadiometers)%oneGrid(n)%frequencies, &
          & numHeights, "PointingGrids(?)%oneGrid(?)%frequencies", moduleName )
        which = ' L ' ! in case of error
        lineNo = lineNo + 1
        read ( lun, *, iostat=status, err=99, end=98, iomsg=iomsg ) &
          & pointingGrids(howManyRadiometers)%oneGrid(n)%frequencies
        ! The frequencies are relative to the band center.  Make them
        ! absolute
        pointingGrids(howManyRadiometers)%oneGrid(n)%frequencies = &
            & pointingGrids(howManyRadiometers)%oneGrid(n)%frequencies + &
                & pointingGrids(howManyRadiometers)%centerFrequency
      end do
    end do outer2

    call deallocate_test ( howManySignals, 'HowManySignals', moduleName )
    call deallocate_test ( howManyGrids, 'HowManyGrids', moduleName )

    if ( switchDetail(switches,'point') > -1 ) call dump_pointing_grid_database
    call trace_end ( "Read_Pointing_Grid_File", &
      & cond=toggle(gen) .and. levels(gen) > 0 )

    return

  98 call MLSMessage ( MLSMSG_Error, moduleName, "Unexpected end-of-file" )
  99 write ( line, '(a,i0)' ) ' at line ', lineNo
     call io_error ( "While reading the pointing grid file" // trim(line) // &
                   & ": " // which // trim(iomsg), status )
     call MLSMessage ( MLSMSG_Error, moduleName, "Input error" // trim(line) //&
                     & which // trim(iomsg))
  end subroutine Read_Pointing_Grid_File

  ! -----------------------------------  Close_Pointing_Grid_File  -----
  subroutine Close_Pointing_Grid_File ( Lun )
    close ( lun )
  end subroutine Close_Pointing_Grid_File

  ! -----------------------------  Destroy_Pointing_Grid_Database  -----
  subroutine Destroy_Pointing_Grid_Database
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, J, S, Status
    if (.not. associated(pointingGrids) ) return
    do i = 1, size(pointingGrids)
      ! It used to do this.
      !  call destroySignalDatabase ( pointingGrids(i)%signals )
      ! but that seemed to be a little overzelous, so I've replaced
      ! it with this, until I understand the issues better.
      do j = 1, size(pointingGrids(i)%signals)
        call Deallocate_Test ( pointingGrids(i)%signals(j)%channels, &
          & 'pointingGrids(?)%signals(?)%channels', ModuleName )
      end do
      do j = 1, size(pointingGrids(i)%oneGrid)
        call deallocate_test ( pointingGrids(i)%oneGrid(j)%frequencies, &
          & "PointingGrids(?)%oneGrid(?)%frequencies", moduleName )
      end do ! j
      s = size(pointingGrids(i)%oneGrid) * &
        & storage_size(pointingGrids(i)%oneGrid) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(pointingGrids(i)%oneGrid(1)), addr)
      deallocate ( pointingGrids(i)%oneGrid, stat=status )
      call test_deallocate ( status, moduleName, "PointingGrids(?)%oneGrid(?)", s, &
        & address=addr )
    end do ! i
    s = size(pointingGrids) * storage_size(pointingGrids) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(pointingGrids(1)), addr)
    deallocate ( pointingGrids, stat=status )
    call test_deallocate ( status, moduleName, "PointingGrids", s, address=addr )
  end subroutine Destroy_Pointing_Grid_Database

  ! --------------------------------  Dump_Pointing_Grid_Database  -----
  !
  ! This family of routines Dumps all or just one pointing frequency grid
  subroutine Dump_Pointing_Grid_Database ( where, details )
    use Dump_0, only: Dump
    use Moretree, only: StarterrorMessage
    use Output_M, only: Blanks, Output

    integer, intent(in), optional :: Where   ! Tree node index
    integer, intent(in), optional :: Details ! Show heights, freqs if > 0

    integer :: I, J                     ! Subscripts, loop inductors
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(Details) ) myDetails = Details
    if ( associated(pointingGrids) ) then
      call output ( 'Pointing Grids: SIZE = ' )
      call output ( size(pointingGrids), advance='yes' )
      do i = 1, size(pointingGrids)
        call output ( i, 4 )
        call output ( ':    Signals =', advance='yes' )
        call Dump_Pointing_Grid ( pointingGrids(i), Details )
      end do ! i
    else
      if ( present(where) ) call startErrorMessage ( where )
      call output ( 'No pointing grids database to dump.', advance='yes' )
    end if
  end subroutine Dump_Pointing_Grid_Database

  ! --------------------------------  Dump_Pointing_Grid  -----
  subroutine Dump_Pointing_Grid ( Grid, details )
    use Dump_0, only: Dump
    use Moretree, only: StarterrorMessage
    use Output_M, only: Blanks, Output

    type(PointingGrid_T), intent(in) :: Grid
    integer, intent(in), optional    :: Details ! Show heights, freqs if > 0

    integer :: J                     ! Subscripts, loop inductors
    integer :: myDetails
    ! Executable
    myDetails = 0
    if ( present(Details) ) myDetails = Details
    do j = 1, size(Grid%signals)
      call blanks ( 6 )
      call DisplaySignalName ( Grid%signals(j), advance='yes' )
    end do ! j = 1, size(Grid%signals)
    if ( myDetails < 1 ) return
    call output ( ' Center Frequency = ' )
    call output ( Grid%centerFrequency, advance='yes' )
    do j = 1, size(Grid%oneGrid)
      call output ( j, 4 )
      call output ( ':: Zeta = ' )
      call output ( Grid%oneGrid(j)%height )
      call dump ( Grid%oneGrid(j)%frequencies, &
        & '    Frequencies =' )
    end do ! j = 1, size(Grid%oneGrid)
  end subroutine Dump_Pointing_Grid

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: PointingGrid_m.f90,v 2.18 2020/01/27 18:17:26 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module PointingGrid_m

! $Log: PointingGrid_m.f90,v $
! Revision 2.18  2020/01/27 18:17:26  pwagner
! Noted that docs are sorely needed; Dump_Pointing_Grid_Database now takes optional arg details
!
! Revision 2.17  2016/09/08 20:52:59  vsnyder
! Make components allocatable instead of pointers
!
! Revision 2.16  2015/03/28 02:00:28  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.15  2014/11/06 00:00:09  vsnyder
! Robustify: left adjust LINE before checking for numbers
!
! Revision 2.14  2014/09/05 20:51:33  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.13  2013/08/30 03:56:23  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.12  2011/05/09 17:52:15  pwagner
! Converted to using switchDetail
!
! Revision 2.11  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.10  2007/10/03 23:58:26  vsnyder
! Add 'where' for tracing
!
! Revision 2.9  2007/05/23 22:40:20  vsnyder
! Change tracing level of Read_Pointing_Grid_File from zero to one
!
! Revision 2.8  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.7  2004/05/29 02:49:51  vsnyder
! Simplifications from using DisplaySignalName
!
! Revision 2.6  2004/05/26 23:54:14  vsnyder
! Don't dump the database if it's not allocated
!
! Revision 2.5  2003/05/19 19:58:07  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.4  2003/05/10 22:20:57  livesey
! Tried to calm down -g1..
!
! Revision 2.3  2002/10/08 17:08:05  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.2  2002/09/13 22:58:22  vsnyder
! Cosmetic changes
!
! Revision 2.1  2002/05/08 08:53:43  zvi
! All radiometers grid concept implementation
!
! Revision 2.0  2001/09/17 20:26:26  livesey
! New forward model
!
! Revision 1.17.2.2  2001/09/14 20:14:49  livesey
! Rewrote Destroy_Pointing_Grid_Database to handle the signals
! differently.  Seemed to fix some memory stomping I didn't
! completely understand.
!
! Revision 1.17.2.1  2001/09/09 03:06:08  livesey
! Minor change
!
! Revision 1.17  2001/06/07 23:30:33  pwagner
! Added Copyright statement
!
! Revision 1.16  2001/05/04 00:49:43  livesey
! Let destroy quit if nothing to destroy
!
! Revision 1.15  2001/04/26 02:36:52  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 1.14  2001/04/20 02:55:56  zvi
! Get rid of the 1/48 griiding assumption in the file reader
!
! Revision 1.13  2001/04/19 06:48:14  zvi
! Fixing memory leaks..
!
! Revision 1.12  2001/04/13 22:50:27  livesey
! Tidied up, added some nullifies etc.
!
! Revision 1.11  2001/04/13 21:39:15  vsnyder
! Replace 'indices of signals' by 'array of signals'
!
! Revision 1.10  2001/03/30 01:34:33  vsnyder
! More work on I/O status handling
!
! Revision 1.9  2001/03/30 01:28:13  vsnyder
! Repair handling of I/O status values
!
! Revision 1.8  2001/03/29 23:53:21  vsnyder
! Use MaxSigLen parameter from MLSSignals
!
! Revision 1.7  2001/03/28 00:42:37  livesey
! Got rid of obsolete routines.
!
! Revision 1.6  2001/03/20 02:31:32  livesey
! Modified so always returns at least lowest grid rather than 0
!
! Revision 1.5  2001/03/17 19:17:57  vsnyder
! Destroy database if it exists before reading a new one
!
! Revision 1.4  2001/03/17 02:34:03  vsnyder
! Get rid of "ExtraHeights" -- That's related to tan_press, not frq_grid
!
! Revision 1.3  2001/03/17 01:22:23  vsnyder
! Add Get_Grids_Near_Tan_Pressures
!
! Revision 1.2  2001/03/17 00:24:56  vsnyder
! Add Get_Nearest_Tan_Pressure
!
! Revision 1.1  2001/03/16 23:12:14  vsnyder
! Initial commit
!
@


2.18
log
@Noted that docs are sorely needed; Dump_Pointing_Grid_Database now takes optional arg details
@
text
@d35 1
a35 1
  public :: Dump_Pointing_Grid_Database
d330 2
d351 1
a351 14
        do j = 1, size(pointingGrids(i)%signals)
          call blanks ( 6 )
          call DisplaySignalName ( pointingGrids(i)%signals(j), advance='yes' )
        end do ! j = 1, size(pointingGrids(i)%signals)
        if ( myDetails < 1 ) cycle
        call output ( ' Center Frequency = ' )
        call output ( pointingGrids(i)%centerFrequency, advance='yes' )
        do j = 1, size(pointingGrids(i)%oneGrid)
          call output ( j, 4 )
          call output ( ':: Zeta = ' )
          call output ( pointingGrids(i)%oneGrid(j)%height )
          call dump ( pointingGrids(i)%oneGrid(j)%frequencies, &
            & '    Frequencies =' )
        end do ! j = 1, size(pointingGrids(i)%oneGrid)
d359 30
d392 1
a392 1
       "$Id: PointingGrid_m.f90,v 2.17 2016/09/08 20:52:59 vsnyder Exp $"
d402 3
@


2.17
log
@Make components allocatable instead of pointers
@
text
@d16 12
a27 5

  use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use MLSKINDS, only: R8
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
  use MLSSIGNALS_M, only: DISPLAYSIGNALNAME, MAXSIGLEN, SIGNALS, SIGNAL_T
d84 2
d88 6
a93 6
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use MACHINE, only: IO_ERROR
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use PARSE_SIGNAL_M, only: PARSE_SIGNAL
    use TOGGLES, only: GEN, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d330 4
a333 4
  subroutine Dump_Pointing_Grid_Database ( where )
    use DUMP_0, only: DUMP
    use MORETREE, only: STARTERRORMESSAGE
    use OUTPUT_M, only: BLANKS, OUTPUT
d336 1
d339 4
d353 1
d373 1
a373 1
       "$Id: PointingGrid_m.f90,v 2.16 2015/03/28 02:00:28 vsnyder Exp $"
d383 3
@


2.16
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d32 1
a32 1
    real(r8), pointer, dimension(:) :: Frequencies => NULL()
d36 1
a36 1
    type(signal_T), pointer, dimension(:) :: Signals => NULL()
d40 1
a40 1
    type(oneGrid_t), pointer, dimension(:) :: OneGrid => NULL()
d96 2
a97 2
    integer, pointer, dimension(:) :: HowManyGrids  ! per radiometer batch
    integer, pointer, dimension(:) :: HowManySignals ! per radiometer batch
d109 1
a116 1
    nullify ( howManyGrids, howManySignals )
d130 1
a130 3
        signal_indices => howManyGrids
        nullify ( howManyGrids )
        call allocate_test ( howManyGrids, 2*size(signal_indices), &
d132 6
a137 8
        howManyGrids(:size(signal_indices)) = signal_indices
        call deallocate_test ( signal_indices, 'Old HowManyGrids', moduleName )
        signal_indices => howManySignals
        nullify ( howManySignals )
        call allocate_test ( howManySignals, 2*size(signal_indices), &
          & 'HowManySignals', moduleName )
        howManySignals(:size(signal_indices)) = signal_indices
        call deallocate_test ( signal_indices, 'Old HowManySignals', moduleName )
d199 1
a199 2
      nullify ( signal_indices )
      nullify ( channels )
d358 1
a358 1
       "$Id: PointingGrid_m.f90,v 2.15 2014/11/06 00:00:09 vsnyder Exp $"
d368 3
@


2.15
log
@Robustify: left adjust LINE before checking for numbers
@
text
@d79 1
d89 1
d180 3
d184 2
a185 1
      & uBounds = howManyRadiometers, elementSize = storage_size(pointingGrids) / 8 )
d195 3
d200 2
a201 1
        & elementSize = storage_size(pointingGrids(howManyRadiometers)%signals) / 8 )
d232 3
d237 2
a238 1
        & elementSize = storage_size(pointingGrids(howManyRadiometers)%oneGrid) / 8 )
d293 2
d312 2
d315 2
a316 1
      call test_deallocate ( status, moduleName, "PointingGrids(?)%oneGrid(?)", s )
d319 2
d322 1
a322 1
    call test_deallocate ( status, moduleName, "PointingGrids", s )
d363 1
a363 1
       "$Id: PointingGrid_m.f90,v 2.14 2014/09/05 20:51:33 vsnyder Exp $"
d373 3
@


2.14
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d61 1
d71 1
a71 1
      & access='sequential', iostat=status )
d73 1
a73 1
      & "Unable to open pointing grid file " // Filename )
d98 1
d100 1
d107 1
d121 3
a123 1
    read ( lun, '(A)', end=98, err=99, iostat=status ) line
d143 1
a144 1
        line = adjustl(line)
d150 4
a153 1
        read ( lun, '(A)', end=98, err=99, iostat=status ) line
d156 2
a157 1
      read ( line, *, err=99 ) Frequency
d160 3
a162 1
        read ( lun, '(A)', err=99, iostat=status ) line
d167 5
a171 2
        read ( line, *, err=99 ) height, numHeights
        read ( lun, *, err=99, end=98 ) ( height, i = 1, numHeights )
d180 3
a182 1
    read ( lun, '(A)', iostat=status ) line  ! Read the first radiometer spec
d195 1
d208 4
a211 1
        read ( lun, '(A)', err=99, iostat=status ) line
d217 2
a218 1
      read ( line, *, err=99, iostat=status ) &
d227 4
a230 1
        read ( lun, '(A)', err=99, iostat=status ) line
d234 2
a235 1
        read ( line, *, iostat=status, err=99 ) height, numHeights
d242 3
a244 1
        read ( lun, *, iostat=status, err=99, end=98 ) &
d261 1
a261 1
    Return
d264 5
a268 2
  99 call io_error ( "While reading the pointing grid file", status )
     call MLSMessage ( MLSMSG_Error, moduleName, "Input error" )
d342 1
a342 1
       "$Id: PointingGrid_m.f90,v 2.13 2013/08/30 03:56:23 vsnyder Exp $"
d352 3
@


2.13
log
@Revise use of trace_begin and trace_end
@
text
@d19 1
a19 2
  use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, MLSMSG_DEALLOCATE, &
    & MLSMSG_ERROR
d77 1
d163 2
a164 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // "PointingGrids" )
d172 3
a174 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate // "PointingGrids(?)%signals" )
d200 3
a202 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate // "PointingGrids(?)%OneGrid" )
d247 2
a248 1
    integer :: I, J, Status
d263 2
d266 1
a266 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        MLSMSG_DeAllocate // "PointingGrids(?)%oneGrid(?)" )
d268 1
d270 1
a270 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      MLSMSG_DeAllocate // "PointingGrids" )
d311 1
a311 1
       "$Id: PointingGrid_m.f90,v 2.12 2011/05/09 17:52:15 pwagner Exp $"
d321 3
@


2.12
log
@Converted to using switchDetail
@
text
@d98 1
d105 2
a106 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_begin ( "Read_Pointing_Grid_File", where )
d228 2
a229 2
    if ( toggle(gen) .and. levels(gen) > 0 ) &
      & call trace_end ( "Read_Pointing_Grid_File" )
d307 1
a307 1
       "$Id: PointingGrid_m.f90,v 2.11 2009/06/23 18:26:10 pwagner Exp $"
d317 3
@


2.11
log
@Prevent Intel from optimizing ident string away
@
text
@d17 5
a21 5
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use MLSCommon, only: R8
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_DeAllocate, &
    & MLSMSG_Error
  use MLSSignals_m, only: DisplaySignalName, MaxSigLen, Signals, Signal_T
d49 1
a49 1
       "$RCSfile: $"
d78 5
a82 4
    use Machine, only: IO_Error
    use Parse_Signal_m, only: Parse_Signal
    use Toggles, only: Gen, Levels, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
d226 1
a226 1
    if ( index(switches,'point') /= 0 ) call dump_pointing_grid_database
d270 3
a272 3
    use Dump_0, only: Dump
    use MoreTree, only: StartErrorMessage
    use Output_m, only: Blanks, Output
d306 1
a306 1
       "$Id: read_apriori.f90 is it here $"
d316 3
@


2.10
log
@Add 'where' for tracing
@
text
@d49 1
a49 1
       "$RCSfile: PointingGrid_m.f90,v $"
d302 1
a303 1
!---------------------------- RCS Ident Info -------------------------------
d305 2
a306 3
       "$Id: PointingGrid_m.f90,v 2.9 2007/05/23 22:40:20 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d308 1
d310 1
d315 3
@


2.9
log
@Change tracing level of Read_Pointing_Grid_File from zero to one
@
text
@d77 1
a77 1
  subroutine Read_Pointing_Grid_File ( Lun )
d84 1
d104 1
a104 1
      & call trace_begin ( "Read_Pointing_Grid_File" )
d305 1
a305 1
       "$Id: PointingGrid_m.f90,v 2.8 2005/06/22 18:08:19 pwagner Exp $"
d314 3
@


2.8
log
@Reworded Copyright statement, moved rcs id
@
text
@d49 1
a49 1
       "$RCSfile: $"
d80 1
a80 1
    use Toggles, only: Gen, Switches, Toggle
d102 2
a103 1
    if ( toggle(gen) ) call trace_begin ( "Read_Pointing_Grid_File" )
d225 2
a226 3
    if ( toggle(gen) ) then
      call trace_end ( "Read_Pointing_Grid_File" )
    end if
d304 1
a304 1
       "$Id: $"
d313 3
@


2.7
log
@Simplifications from using DisplaySignalName
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d47 3
a49 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm = &
    & "$Id: PointingGrid_m.f90,v 2.6 2004/05/26 23:54:14 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter, private :: ModuleName = &
    & "$RCSfile: PointingGrid_m.f90,v $"
d51 1
a51 1
  !---------------------------------------------------------------------------
d302 5
d313 3
@


2.6
log
@Don't dump the database if it's not allocated
@
text
@d13 1
a13 1
  use MLSSignals_m, only: GetNameOfSignal, MaxSigLen, Signals, Signal_T
d41 1
a41 1
    & "$Id: PointingGrid_m.f90,v 2.5 2003/05/19 19:58:07 vsnyder Exp $"
a269 1
    character(len=MaxSigLen) :: SigName ! From GetSignalName
d278 1
a278 2
          call getNameOfSignal ( pointingGrids(i)%signals(j), sigName )
          call output ( trim(sigName), advance='yes' )
d303 3
@


2.5
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d41 1
a41 1
    & "$Id: PointingGrid_m.f90,v 2.4 2003/05/10 22:20:57 livesey Exp $"
d262 1
a262 1
  subroutine Dump_Pointing_Grid_Database
d264 1
d267 2
d271 25
a295 20
    call output ( 'Pointing Grids: SIZE = ' )
    call output ( size(pointingGrids), advance='yes' )
    do i = 1, size(pointingGrids)
      call output ( i, 4 )
      call output ( ':    Signals =', advance='yes' )
      do j = 1, size(pointingGrids(i)%signals)
        call blanks ( 6 )
        call getNameOfSignal ( pointingGrids(i)%signals(j), sigName )
        call output ( trim(sigName), advance='yes' )
      end do ! j = 1, size(pointingGrids(i)%signals)
      call output ( ' Center Frequency = ' )
      call output ( pointingGrids(i)%centerFrequency, advance='yes' )
      do j = 1, size(pointingGrids(i)%oneGrid)
        call output ( j, 4 )
        call output ( ':: Zeta = ' )
        call output ( pointingGrids(i)%oneGrid(j)%height )
        call dump ( pointingGrids(i)%oneGrid(j)%frequencies, &
          & '    Frequencies =' )
      end do ! j = 1, size(pointingGrids(i)%oneGrid)
    end do ! i
d305 3
@


2.4
log
@Tried to calm down -g1..
@
text
@d12 1
a12 1
    & MLSMSG_Error, MLSMSG_Info
d41 1
a41 1
    & "$Id$"
d44 1
a44 1
    & "$RCSfile$"
d75 1
a75 2
    use String_Table, only: Display_String
    use Toggles, only: Gen, Levels, Switches, Toggle
d296 4
a299 1
! $Log$
@


2.3
log
@Added idents to survive zealous Lahey optimizer
@
text
@d41 1
a41 1
    & "$Id: PointingGrid_m.f90,v 2.2 2002/09/13 22:58:22 vsnyder Exp $"
d44 1
a44 1
    & "$RCSfile: PointingGrid_m.f90,v $"
d219 1
a220 2
      if ( levels(gen) > 0 .or. index(switches,'P') /= 0 ) &
        & call dump_pointing_grid_database
d297 4
a300 1
! $Log: PointingGrid_m.f90,v $
@


2.2
log
@Cosmetic changes
@
text
@d41 1
a41 1
    & "$Id: PointingGrid_m.f90,v 2.1 2002/05/08 08:53:43 zvi Exp $"
d45 1
d292 4
d299 3
@


2.1
log
@All radiometers grid concept implementation
@
text
@a9 1
  use D_HUNT_M, only: HUNT
d13 1
a13 3
  use MLSSignals_m, only: Bands, DestroySignalDatabase, GetNameOfSignal, &
    & MaxSigLen, Signals, Signal_T
  use Output_m, only: Blanks, MLSMSG_Level, Output, PrUnit
d41 1
a41 1
    & "$Id: PointingGrid_m.f90,v 2.0 2001/09/17 20:26:26 livesey Exp $"
d265 1
d294 3
@


2.0
log
@New forward model
@
text
@d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.17.2.2 2001/09/14 20:14:49 livesey Exp $"
d63 1
a63 1
      if ( exist .and. .not. opened ) exit
d111 1
a111 1
    read ( lun, '(a)', end=98, err=99, iostat=status ) line
d138 2
a139 2
        read ( lun, '(a)', end=98, err=99, iostat=status ) line
        if ( verify(line(1:1), ' 0123456789.+-') == 0 ) exit ! a number
d144 2
a145 2
        read ( lun, '(a)', err=99, iostat=status ) line
        if ( status < 0 ) exit outer1
d147 1
a147 1
        if ( verify(line(1:1), ' 0123456789.+-') /= 0 ) exit ! not a number
d159 1
a159 1
    read ( lun, '(a)', iostat=status ) line  ! Read the first radiometer spec
d183 2
a184 2
        read ( lun, '(a)', err=99, iostat=status ) line
        if ( verify(line(1:1), ' 0123456789.+-') == 0 ) exit ! a number
d197 3
a199 3
        read ( lun, '(a)', err=99, iostat=status ) line
        if ( status < 0 ) exit outer2
        if ( verify(line(1:1), ' 0123456789.+-') /= 0 ) exit ! not a number
d202 1
a202 1
        if ( status < 0 ) exit outer2
d227 2
a228 1
    return
d296 3
@


1.17
log
@Added Copyright statement
@
text
@a27 2
    real(r8) :: NearestTanPress = huge(0.0_r8)/4  ! Nearest tangent pressure
    integer :: WhichTanPress = -1                 ! Which one is nearest
d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.16 2001/05/04 00:49:43 livesey Exp $"
d243 8
a250 1
      call destroySignalDatabase ( pointingGrids(i)%signals )
d295 11
@


1.17.2.1
log
@Minor change
@
text
@d28 2
d46 1
a46 1
    & "$Id: PointingGrid_m.f90,v 1.17 2001/06/07 23:30:33 pwagner Exp $"
a289 3
! Revision 1.17  2001/06/07 23:30:33  pwagner
! Added Copyright statement
!
@


1.17.2.2
log
@Rewrote Destroy_Pointing_Grid_Database to handle the signals
differently.  Seemed to fix some memory stomping I didn't
completely understand.
@
text
@d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.17.2.1 2001/09/09 03:06:08 livesey Exp $"
d243 1
a243 8
      ! It used to do this.
      !  call destroySignalDatabase ( pointingGrids(i)%signals )
      ! but that seemed to be a little overzelous, so I've replaced
      ! it with this, until I understand the issues better.
      do j = 1, size(pointingGrids(i)%signals)
        call Deallocate_Test ( pointingGrids(i)%signals(j)%channels, &
          & 'pointingGrids(?)%signals(?)%channels', ModuleName )
      end do
a287 3
! Revision 1.17.2.1  2001/09/09 03:06:08  livesey
! Minor change
!
@


1.16
log
@Let destroy quit if nothing to destroy
@
text
@d1 3
d46 1
a46 1
    & "$Id: PointingGrid_m.f90,v 1.15 2001/04/26 02:36:52 vsnyder Exp $"
d290 3
@


1.15
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.14 2001/04/20 02:55:56 zvi Exp $"
d240 1
d287 3
@


1.14
log
@Get rid of the 1/48 griiding assumption in the file reader
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.13 2001/04/19 06:48:14 zvi Exp $"
d73 1
a73 1
  subroutine Read_Pointing_Grid_File ( Lun, Spec_Indices )
a80 1
    integer, intent(in) :: Spec_Indices(:)   ! Needed by Parse_Signal, q.v.
d132 1
a132 2
        call parse_signal ( line, signal_indices, spec_indices, &
          & onlyCountEm = signalCount )
d171 1
a171 1
        call parse_signal ( line, signal_indices, spec_indices, &
d286 3
@


1.13
log
@Fixing memory leaks..
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.12 2001/04/13 22:50:27 livesey Exp $"
a88 2
    real(r8) :: z,q                          ! Local variables
    integer :: J                             ! Local variable
a204 3
        j = nint(48.0*abs(height))
        z = (Real(j,r8)/48.0_r8) * Sign(1.0_r8,height)
        if(abs(height-z) < 1.0e-6) height = z
d288 3
@


1.12
log
@Tidied up, added some nullifies etc.
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.11 2001/04/13 21:39:15 vsnyder Exp $"
d89 2
d204 7
a210 2
        read ( line, *, iostat=status, err=99 ) & 
          & pointingGrids(howManyRadiometers)%oneGrid(n)%height, numHeights
d282 1
a282 1
        call output ( ':: Height = ' )
d293 3
@


1.11
log
@Replace 'indices of signals' by 'array of signals'
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.10 2001/03/30 01:34:33 vsnyder Exp $"
d104 1
d130 1
d171 1
d286 3
@


1.10
log
@More work on I/O status handling
@
text
@d11 2
a12 2
  use MLSSignals_m, only: Bands, Dump_Bands, Dump_Signals, GetSignalName, &
    & MaxSigLen, Signals
d31 1
a31 1
    integer, pointer, dimension(:) :: Signals => NULL() ! Database indices
d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.9 2001/03/30 01:28:13 vsnyder Exp $"
d83 1
d89 2
a90 1
    integer, dimension(size(signals)) :: HowManyGrids  ! per radiometer
d95 2
d104 5
d110 1
a110 1
    read ( lun, '(a)', end=98, err=99, iostat=status ) line  ! Skip the first radiometer spec
d114 27
a140 4
      if ( howManyRadiometers > size(howManyGrids) ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
          & "More radiometers in the file than signals in the database" )
      read ( lun, *, err=99 ) Frequency
d163 5
d169 14
a182 23
      call parse_signal ( line, signal_indices, spec_indices )
      if ( .not. associated(signal_indices) ) call MLSMessage ( MLSMSG_Error, &
        & moduleName, "Improper signal specification" )
      ! Check that pointing grids have not already been specified for any
      ! bands implied by the present signal string.
      do i = 1, size(signal_indices)
        if ( signals(signal_indices(i))%pointingGrid /= 0 ) then
          prunit = -2 ! To do output via MLSMessage
          MLSMSG_Level = MLSMSG_Info
          call dump_signals ( (/ signals(signal_indices(i)) /) )
          MLSMSG_Level = MLSMSG_Error
          call output ( "More than one pointing grid specified for signal " )
          call display_string ( signals(signal_indices(i))%name, advance='yes' )
        end if
        if ( bands(signals(signal_indices(i))%band)%pointingGrid /= 0 ) then
          prunit = -2 ! To do output via MLSMessage
          MLSMSG_Level = MLSMSG_Info
          call dump_bands ( (/ bands(signals(signal_indices(i))%band) /) )
          MLSMSG_Level = MLSMSG_Error
          call output ( "More than one pointing grid specified for band " )
          call display_string ( bands(signals(signal_indices(i))%band)%prefix, &
            & advance='yes' )
        end if
d184 1
a184 6
      ! But allow the present signal string to specify the grid for a band
      ! several times.
      signals(signal_indices)%pointingGrid = howManyRadiometers
      bands(signals(signal_indices)%band)%pointingGrid = howManyRadiometers
      pointingGrids(howManyRadiometers)%signals => signal_indices
      ! The next thing should be gotten from the signals database.
d187 1
a187 1
      read ( lun, *, err=99, iostat=status ) &
d214 3
d238 1
a238 2
      call deallocate_test ( pointingGrids(i)%signals, &
        & "PointingGrids(?)%signals", moduleName )
d265 1
a265 1
        call getSignalName ( pointingGrids(i)%signals(j), sigName )
d283 3
@


1.9
log
@Repair handling of I/O status values
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.8 2001/03/29 23:53:21 vsnyder Exp $"
d101 1
a101 3
    read ( lun, '(a)', iostat=status ) line  ! Skip the first radiometer spec
    if ( status < 0 ) go to 98
    if ( status > 0 ) go to 99
d111 1
a111 1
        read ( lun, '(a)', iostat=status ) line
d113 1
a113 1
        if ( status > 0 ) go to 99
d127 1
d164 2
a165 1
      read ( lun, *, err=99 ) pointingGrids(howManyRadiometers)%centerFrequency
d172 1
a172 1
        read ( lun, '(a)', iostat=status ) line
a173 1
        if ( status > 0 ) go to 99
d258 3
@


1.8
log
@Use MaxSigLen parameter from MLSSignals
@
text
@d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.7 2001/03/28 00:42:37 livesey Exp $"
d102 2
d115 1
a115 1
        if ( status > 0 ) go to 98
d174 1
a174 1
        if ( status > 0 ) go to 98
d259 3
@


1.7
log
@Got rid of obsolete routines.
@
text
@d12 1
a12 1
    & Signals
d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.6 2001/03/20 02:31:32 livesey Exp $"
d91 1
a91 1
    character(len=80) :: Line                ! From the input file
d230 2
a231 2
    integer :: I, J                ! Subscripts, loop inductors
    character(len=80) :: SigName   ! From GetSignalName
d257 3
@


1.6
log
@Modified so always returns at least lowest grid rather than 0
@
text
@d21 1
a21 2
  public :: Dump_Pointing_Grid_Database, Get_Grids_Near_Tan_Pressures
  public :: Get_Nearest_Tan_Pressure
d43 1
a43 1
    & "$Id: PointingGrid_m.f90,v 1.5 2001/03/17 19:17:57 vsnyder Exp $"
a48 4
  ! Has Get_Nearest_Tan_Pressure been called?  (Get_Grids_Near_Tan_Pressures
  ! needs it to have been done.)
  logical, private, save :: Got_Nearest_Tan_Press = .false.

a223 1
    Got_Nearest_Tan_Press = .false.
a253 56
  ! -------------------------------  Get_Grids_Near_Tan_Pressures  -----
  subroutine Get_Grids_Near_Tan_Pressures ( Which_Pointing_Grid, Tan_Press, &
    & Tol, Grids )
  ! Get the index of the grid nearest to each tangent pressure, and
  ! within TOL of it.  Assumes that Get_Nearest_Tan_Pressure has been
  ! called already.

    integer, intent(in) :: Which_Pointing_Grid    ! Database index
    real(r8), intent(in), dimension(:) :: Tan_Press
    real(r8), intent(in) :: Tol                   ! How close?
    integer, intent(out) :: Grids(:)              ! Database indices

    integer :: I

    call Get_Nearest_Tan_Pressure ( tan_press ) ! Just in case

    grids = 0
    do i = 1, size(pointingGrids(which_pointing_grid)%oneGrid)
      if ( abs(pointingGrids(which_pointing_grid)%oneGrid(i)%height - &
        &      tan_press(pointingGrids(which_pointing_grid)%oneGrid(i)% &
               & whichTanPress) ) <= tol ) then
        if ( grids(pointingGrids(which_pointing_grid)%oneGrid(i)% &
          & whichTanPress) /= 0 ) &
            & call MLSMessage ( MLSMSG_Error, moduleName, &
              & "More than one frequency grid for a tangent height" )
        grids(pointingGrids(which_pointing_grid)%oneGrid(i)%whichTanPress) = i
      end if
    end do ! i = 1, size(pointingGrids(which_pointing_grid))
    grids = max( grids , 1)             ! Always return lowest at least
  end subroutine Get_Grids_Near_Tan_Pressures
  
  ! -----------------------------------  Get_Nearest_Tan_Pressure  -----
  subroutine Get_Nearest_Tan_Pressure ( Tan_Press )
  ! Find the nearest tangent pressure to each PointingGrids%oneGrid

    real(r8), intent(in), dimension(:) :: Tan_Press

    integer :: I, J, K, L

    if ( got_Nearest_Tan_Press ) return ! No point in doing it twice

    Got_Nearest_Tan_Press = .true.

    do i = 1, size(pointingGrids)
      do j = 1, size(pointingGrids(i)%oneGrid)
        k = -1
        call Hunt ( pointingGrids(i)%oneGrid(j)%height, tan_press, &
          & size(tan_press), k, l )
        if ( abs( pointingGrids(i)%oneGrid(j)%height - tan_press(l) ) < &
             abs( pointingGrids(i)%oneGrid(j)%height - tan_press(k) ) ) k = l
        pointingGrids(i)%oneGrid(j)%nearestTanPress = tan_press(k)
        pointingGrids(i)%oneGrid(j)%whichTanPress = k
      end do ! j = 1, size(pointingGrids%oneGrid)
    end do ! i = 1, size(pointingGrids)

  end subroutine Get_Nearest_Tan_Pressure
d257 3
@


1.5
log
@Destroy database if it exists before reading a new one
@
text
@d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.4 2001/03/17 02:34:03 vsnyder Exp $"
d288 1
d319 3
@


1.4
log
@Get rid of "ExtraHeights" -- That's related to tan_press, not frq_grid
@
text
@d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.3 2001/03/17 01:22:23 vsnyder Exp $"
d103 2
d318 3
@


1.3
log
@Add Get_Grids_Near_Tan_Pressures
@
text
@a38 2
  integer, public :: ExtraHeights = 0   ! How many extra spaces in each
    !                                     frequency grid?
d44 1
a44 1
    & "$Id: PointingGrid_m.f90,v 1.2 2001/03/17 00:24:56 vsnyder Exp $"
d182 1
a182 4
          & numHeights + extraHeights, &
          & "PointingGrids(?)%oneGrid(?)%frequencies", moduleName )
          pointingGrids(howManyRadiometers)%oneGrid(n)% &
            & frequencies(:extraHeights) = -huge(1.0_r8)
d184 1
a184 2
          & pointingGrids(howManyRadiometers)%oneGrid(n)% &
            & frequencies(extraHeights+1:)
d187 2
a188 4
        pointingGrids(howManyRadiometers)%oneGrid(n)% &
          & frequencies(extraHeights+1:) = &
            & pointingGrids(howManyRadiometers)%oneGrid(n)% &
              & frequencies(extraHeights+1:) + &
d316 3
@


1.2
log
@Add Get_Nearest_Tan_Pressure
@
text
@d7 1
d21 2
a22 1
  public :: Dump_Pointing_Grid_Database, Get_Nearest_Tan_Pressure
d27 1
d46 1
a46 1
    & "$Id: PointingGrid_m.f90,v 1.1 2001/03/16 23:12:14 vsnyder Exp $"
d52 4
d235 1
d266 30
a298 1
    use D_HUNT_M, only: HUNT
d304 4
d315 2
a316 1
        pointingGrids(i)%oneGrid(j)%height = tan_press(k)
d324 3
@


1.1
log
@Initial commit
@
text
@a6 2
  use Dump_0, only: Dump
  use Machine, only: IO_Error
d13 2
a14 4
  use Parse_Signal_m, only: Parse_Signal
  use String_Table, only: Display_String
  use Toggles, only: Gen, Levels, Switches, Toggle
  use Trace_M, only: Trace_begin, Trace_end
d20 1
a20 1
  public :: Dump_Pointing_Grid_Database
d23 2
a24 1
    real(r8) :: Height                  ! Zeta, actually
d43 1
a43 1
    & "$Id: MLSSignals_m.f90,v 2.5 2001/03/15 21:02:07 vsnyder Exp $"
d46 1
a46 1
    & "$RCSfile: MLSSignals_m.f90,v $"
d53 1
d56 1
d59 1
d74 6
d184 7
d232 2
d258 21
d281 4
a284 1
! $Log: $
@

