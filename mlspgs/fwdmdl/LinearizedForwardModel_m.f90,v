head	2.93;
access;
symbols
	v5-02-NRT-19:2.93
	v6-00:2.93
	v5-02-NRT-18:2.93
	v5-02:2.93
	v5-01-NRT-17:2.93
	v5-01-NRT-16:2.93
	v5-01-NRT-15:2.93
	v5-01-NRT-14:2.93
	neuralnetworks-1-0:2.93.0.10
	cfm-single-freq-0-1:2.93.0.8
	v5-01:2.93
	v5-00:2.93
	v4-23-TA133:2.93.0.6
	mus-emls-1-70:2.93.0.4
	rel-1-0-englocks-work:2.93.0.2
	VUMLS1-00:2.92
	VPL1-00:2.92
	V4-22-NRT-08:2.92
	VAM1-00:2.91
	V4-21:2.90.0.2
	V4-13:2.90
	V4-12:2.90
	V4-11:2.90
	V4-10:2.90
	V3-43:2.72
	M4-00:2.88
	V3-41:2.72
	V3-40-PlusGM57:2.72.0.2
	V2-24-NRT-04:2.64
	V3-33:2.82
	V2-24:2.64
	V3-31:2.82
	V3-30-NRT-05:2.81
	cfm-01-00:2.81
	V3-30:2.72
	V3-20:2.72
	V3-10:2.72
	V2-23-NRT-02:2.64
	V2-23:2.64
	V2-22-NRT-01:2.64
	V2-22:2.64
	V2-21:2.62
	V2-20:2.62
	V2-11:2.62
	V2-10:2.62
	V2-00:2.59
	V1-51:2.56
	V1-50:2.56
	V1-45:2.55
	V1-44:2.55
	V1-43:2.53
	V1-32:2.51
	V1-31:2.51
	V1-30:2.45
	V1-13:2.39
	V1-12:2.39
	V1-11:2.39
	V1-10:2.37
	newfwm-feb03:2.37.0.2
	V1-04:2.13
	V1-03:2.13
	V1-02:2.13
	JointForwardModel:2.18.0.2
	V1-00:2.13
	newfwm-sep01:1.22.0.2
	V0-7:1.22
	V0-5-Level2:1.15;
locks; strict;
comment	@# @;


2.93
date	2017.10.31.23.49.36;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2016.04.13.00.47.57;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2015.08.25.17.24.32;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2013.08.30.03.56.23;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2013.08.12.23.48.09;	author pwagner;	state Exp;
branches;
next	2.88;

2.88
date	2012.07.31.00.45.02;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2011.11.11.00.42.06;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2011.08.20.02.31.47;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2011.08.20.02.10.06;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2011.05.09.17.50.34;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2011.03.28.17.52.08;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2010.09.25.01.08.39;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2010.06.29.19.57.58;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2010.06.07.23.25.18;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2010.05.19.17.52.53;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2010.05.19.00.33.46;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2010.05.13.23.46.00;	author pwagner;	state Exp;
branches;
next	2.76;

2.76
date	2010.04.30.23.57.40;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2010.04.13.01.42.30;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2010.03.26.23.13.12;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2010.02.25.18.02.17;	author pwagner;	state Exp;
branches;
next	2.72;

2.72
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.71;

2.71
date	2009.04.20.18.44.27;	author pwagner;	state Exp;
branches;
next	2.70;

2.70
date	2008.10.03.16.39.29;	author livesey;	state Exp;
branches;
next	2.69;

2.69
date	2008.10.03.16.31.13;	author livesey;	state Exp;
branches;
next	2.68;

2.68
date	2008.06.06.22.51.44;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2008.05.07.20.55.32;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2008.05.02.20.14.09;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2008.05.02.19.44.39;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2007.06.29.19.32.42;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2007.04.03.17.45.10;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2006.07.19.22.33.02;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2006.06.19.15.53.35;	author livesey;	state Exp;
branches;
next	2.60;

2.60
date	2006.06.16.23.41.57;	author livesey;	state Exp;
branches;
next	2.59;

2.59
date	2006.06.15.17.40.33;	author pwagner;	state Exp;
branches;
next	2.58;

2.58
date	2005.06.30.22.42.34;	author livesey;	state Exp;
branches;
next	2.57;

2.57
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.56;

2.56
date	2004.11.01.20.24.48;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2004.08.06.01.09.49;	author livesey;	state Exp;
branches;
next	2.54;

2.54
date	2004.07.07.19.42.11;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2004.02.07.00.45.36;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2004.02.05.23.30.39;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2003.11.01.18.44.39;	author livesey;	state Exp;
branches;
next	2.50;

2.50
date	2003.10.29.00.44.53;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2003.10.28.23.44.15;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2003.10.09.22.17.10;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2003.09.15.17.42.52;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2003.09.11.23.10.32;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2003.08.20.20.07.22;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.08.14.20.24.08;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2003.08.13.00.48.23;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2003.07.15.22.10.38;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2003.07.09.20.16.26;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2003.05.29.16.37.45;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2003.02.22.00.40.22;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2003.02.17.00.33.41;	author livesey;	state Exp;
branches;
next	2.37;

2.37
date	2003.02.06.01.13.28;	author livesey;	state Exp;
branches;
next	2.36;

2.36
date	2003.02.06.00.46.03;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2003.02.05.21.58.31;	author livesey;	state Exp;
branches;
next	2.34;

2.34
date	2003.01.29.22.43.25;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2003.01.08.23.50.15;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.12.16.15.31.57;	author mjf;	state Exp;
branches;
next	2.31;

2.31
date	2002.11.14.17.54.06;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.11.14.17.46.08;	author livesey;	state Exp;
branches;
next	2.29;

2.29
date	2002.10.08.17.08.05;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.10.02.23.19.51;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2002.10.02.02.42.55;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2002.09.13.22.53.22;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2002.09.13.18.09.09;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2002.09.11.17.43.39;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2002.09.03.23.46.04;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.07.22.03.25.50;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2002.07.17.06.02.01;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2002.07.09.17.37.45;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2002.07.02.19.51.21;	author livesey;	state Exp;
branches;
next	2.18;

2.18
date	2002.06.12.17.46.21;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2002.06.12.17.02.25;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2002.05.28.22.34.21;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.05.14.22.32.53;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2002.05.03.23.29.31;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2002.03.15.21.23.09;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2002.02.20.03.00.23;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2002.02.12.21.48.21;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2002.02.09.21.35.22;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2002.02.09.19.11.19;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2002.02.08.22.51.00;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2002.02.06.01.34.20;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2002.01.21.22.52.21;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2002.01.21.22.46.08;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2002.01.17.02.17.04;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.10.22.16.51.40;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.10.07.00.23.50;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.10.02.16.51.41;	author livesey;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.26;	author livesey;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.04.22.43.26;	author livesey;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.01.20.35.55;	author livesey;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.01.20.09.28;	author livesey;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.25.19.12.21;	author livesey;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.19.01.21.33;	author livesey;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.09.19.46.49;	author vsnyder;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.08.23.26.36;	author livesey;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.03.22.58.38;	author livesey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.03.02.02.54;	author vsnyder;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.02.20.26.17;	author vsnyder;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.02.20.22.13;	author livesey;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.01.06.55.07;	author livesey;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.30.15.50.29;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.28.22.32.07;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.28.21.23.33;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.28.19.40.37;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.28.07.05.25;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.28.04.40.56;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.28.01.54.54;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.27.17.35.42;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.26.23.54.32;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.25.20.49.27;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.93
log
@Make Coefficients a parameterized type
@
text
@
! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module LinearizedForwardModel_m

  ! Approximate a forward model with a first-order Taylor's series.

  implicit none
  private
  public :: LinearizedForwardModel, LinearizedForwardModelAuto

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: LinearizedForwardModel_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  logical, parameter :: EXPECTDELTAXALLZERO = .false.

contains ! =====     Public Procedures     =============================

  ! -------------------------------------  LinearizedForwardModel  -----
  subroutine LinearizedForwardModel ( fmConf, FwdModelIn, FwdModelExtra,&
    & FwdModelOut, fmStat, Jacobian, vectors )

    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use FORWARDMODELINTERMEDIATE, only: FORWARDMODELSTATUS_T
    use INTRINSIC, only: L_RADIANCE, L_OPTICALDEPTH
    use MATRIXMODULE_1, only: MATRIX_T
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSIGNALS_M, only: SIGNAL_T
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T
    use FORWARDMODELVECTORTOOLS, only: GETQUANTITYFORFORWARDMODEL

    ! Dummy arguments
    type(forwardModelConfig_T), intent(in) :: FMCONF
    ! target attribute prevents STATEQ from being undefined when
    ! FindMatchForL2PCQ returns:
    type(vector_T), intent(in), target ::  FWDMODELIN
    type(vector_T), intent(in), target ::  FWDMODELEXTRA
    type(vector_T), intent(inout) :: FWDMODELOUT  ! Radiances, etc.
    type(forwardModelStatus_t), intent(inout) :: FMSTAT ! Reverse comm. stuff
    type(matrix_T), intent(inout), optional :: JACOBIAN
    type(vector_t), dimension(:), target, optional :: VECTORS ! Vectors database

    type(VectorValue_T), pointer :: RADIANCE ! The radiance quantity to fill
    integer :: SIDEBAND
    type(Signal_T), pointer :: SIGNAL   ! Signal from the configuration

    if ( size ( fmConf%signals ) /= 1 ) call MLSMessage ( &
      & MLSMSG_Error, ModuleName, &
      & 'Can only have one signal for linearized models')

    signal => fmConf%signals(1)
    ! Probably access the sideband associated with the signal ...
    sideband = signal%sideband
    ! ... but in certain rare circumstances (when we're called by the hybrid
    ! model) we might want to force the folded one.
    if ( fmConf%forceFoldedOutput ) sideband = 0
    radiance => GetQuantityForForwardModel (fwdModelOut, quantityType=l_radiance, &
      & signal=signal%index, sideband=sideband, noError=.true., config=fmConf )

    ! Now, it's possible we're really being asked to deal with optical depth,
    ! not radiance.
    if ( .not. associated ( radiance ) ) &
      & radiance => GetQuantityForForwardModel (fwdModelOut, quantityType=l_opticalDepth, &
        & signal=signal%index, sideband=sideband, noError=.true., config=fmConf )

    ! Now, some possible error messages
    if ( .not. associated ( radiance ) ) call MLSMessage ( &
      & MLSMSG_Error, ModuleName, &
      & 'Unable to find a radiance or optical depth quantity for this signal' )
    if ( radiance%template%quantityType == l_opticalDepth ) then
      if ( present(jacobian)  ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to ask for derivatives for optical depth' )
      if ( fmConf%xStar /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to supply x/yStar for optical depth' )
      if  ( sideband /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to request optical depth from unfolded signal' )
    end if
    if ( fmConf%xStar /= 0 .and. .not. present(vectors) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'x/yStar supplied by vectors database argument not present' )

    call LinearizedForwardModelAuto ( fmConf, FwdModelIn, FwdModelExtra,&
    & fmStat, radiance, noChans=radiance%template%noChans, &
    & noMifs=radiance%template%noSurfs, &
    & noMifsJ=merge( radiance%template%noSurfs,0,present(Jacobian) ), &
    & Jacobian=Jacobian, Vectors=vectors )

  end subroutine LinearizedForwardModel

  ! ---------------------------------  LinearizedForwardModelAuto  -----
  subroutine LinearizedForwardModelAuto ( fmConf, FwdModelIn, FwdModelExtra,&
    & fmStat, radiance, noChans, noMifs, noMifsJ, Jacobian, Vectors )

    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use DUMP_0, only: DUMP
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T, DUMP
    use FORWARDMODELINTERMEDIATE, only: FORWARDMODELSTATUS_T
    use FORWARDMODELVECTORTOOLS, only: GETQUANTITYFORFORWARDMODEL
    use HESSIANMODULE_1, only: MULTIPLY
    use INTRINSIC, only: L_LIMBSIDEBANDFRACTION, L_OPTICALDEPTH, &
      & L_PTAN, L_RADIANCE, L_TEMPERATURE, L_VMR, PHYQ_Angle
    use L2PC_M, only: L2PC_T, L2PCDATABASE, POPULATEL2PCBIN
    use L2PCBINS_M, only: FINDMATCHFORL2PCQ, SELECTL2PCBINS
    use MANIPULATEVECTORQUANTITIES, only: FINDONECLOSESTINSTANCE
    use MATRIXMODULE_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
      & MATRIXELEMENT_T, CREATEBLOCK, DENSIFY, CHECKFORSIMPLEBANDEDLAYOUT
    use MATRIXMODULE_1, only: MATRIX_T, MULTIPLYMATRIXVECTORNOT, DUMP, &
      & FINDBLOCK, CREATEBLOCK
    use MLSKINDS, only: R8, RM, RV
    use MLSSIGNALS_M, only: SIGNAL_T
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSNUMERICS, only: Coefficients, HUNT, INTERPOLATEARRAYSETUP, &
      & INTERPOLATEARRAYTEARDOWN, INTERPOLATEVALUES
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MOLECULES, only: ISEXTINCTION
    use MOREMESSAGE, only: MLSMESSAGE
    use OUTPUT_M, only: OUTPUT !, OUTPUTNAMEDVALUE
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: EMIT, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use VECTORSMODULE, only: ASSIGNMENT(=), OPERATOR(-), OPERATOR(+), &
      & OPERATOR(/=), CLONEVECTOR,  DESTROYVECTORINFO, DUMP, &
      & GETVECTORQUANTITYINDEXBYNAME, GETVECTORQUANTITYBYTYPE, M_LINALG, &
      & RV, VECTOR_T, VECTORVALUE_T
    use SORT_M, only: SORTP

    ! Dummy arguments
    type(forwardModelConfig_T), intent(in) :: FMCONF
    ! target attribute prevents STATEQ from being undefined when
    ! FindMatchForL2PCQ returns:
    type(vector_T), intent(in), target ::  FWDMODELIN
    type(vector_T), intent(in), target ::  FWDMODELEXTRA
    type(forwardModelStatus_t), intent(inout) :: FMSTAT ! Reverse comm. stuff
    type(vectorvalue_t), intent(inout) :: RADIANCE ! The radiance quantity to fill
    integer, intent(in) :: NoChans, NoMifs, NoMifsJ ! Dimensions
    type(matrix_T), intent(inout), optional :: JACOBIAN
    type(vector_t), dimension(:), target, optional :: VECTORS ! Vectors database

    ! Local variables
    integer :: CENTER                   ! Center instance of l2pc
    integer :: CHAN                     ! Loop counter
    integer :: CLOSESTINSTANCE          ! A closest profile to this MAF
    integer :: COLJBLOCK                ! Column index in jacobian
    integer :: COLLBLOCK                ! Column index in l2pc
    integer :: DELTAINSTANCE            ! Instance offset between center an current
    integer :: I                        ! Array index
    integer :: INSTANCELEN              ! For the state quantity
    integer :: LOWER                    ! Array index
    integer :: MAF                      ! Major frame to do
    integer :: Me = -1                  ! String index for trace
    integer :: MIF                      ! Minor frame loop counter
    integer :: NOPOINTINGS              ! Number of pointings in the l2pc file
    integer :: QTYIND                   ! Loop index for main loop
    integer :: ROWJBLOCK                ! Row index in jacobian
    integer :: ROWLBLOCK                ! Row index in l2pc
    integer :: SIDEBAND                 ! Loop index
    integer :: SIDEBANDSTART            ! For sideband loop
    integer :: SIDEBANDSTEP             ! For sideband loop
    integer :: SIDEBANDSTOP             ! For sideband loop
    integer :: TOP                      ! For interpolating
    integer :: UPPER                    ! Array index
    integer :: XINSTANCE                ! Instance in x corresponding to xStarInstance
    integer :: XSTARINSTANCE            ! Loop counter

    logical :: DODERIVATIVES            ! Flag
    logical :: DOELEMENT                ! Flag
    logical :: FOUNDINFIRST             ! Flag for state quantities
    logical :: PTANINFIRST              ! PTan was found in the first vector

    integer, dimension(-1:1) :: L2PCBINS ! Which l2pc to use
    integer, dimension(noMIFsJ) :: mifPointingsLower ! Result of a hunt
    integer, dimension(size(mifPointingsLower)) :: mifPointingsUpper ! mifPointingsLower+1

    logical, dimension(noChans) :: doChannel ! Do this channel?

    real (r8) :: DELTAPHI               ! Difference in geod Angle in l2pc

    ! The `prime' quantities are important.
    ! - yPrime (yP) contains one maf of the relevant radiances, but on the
    !   l2pc's vertical coordinates
    ! - xPrime (xP) is like xStar but contains state values
    ! - kPrime is the jacobian for these two.

    real (r8), dimension(size(mifPointingsLower)) :: lowerWeight ! For interpolation
    real (r8), dimension(size(mifPointingsLower)) :: upperWeight ! For interpolation
    real (r8), dimension(merge(noMifs,0,radiance%template%quantityType==l_opticalDepth)) &
      & :: tangentTemperature ! For optical depth
    real (r8), dimension(noChans) :: thisFraction ! Sideband fraction values

    real (r8), dimension(noMIFs,noChans) :: resultMapped ! Remapped values of result
    real (r8), dimension(noMIFs,noChans) :: dyByDX ! Raw dRad/dPtan
    real (rm), dimension(:,:), pointer :: dense  ! Densified matrix from l2pc
    real (rm), dimension(:,:), pointer :: kBit ! Remapped values of l2pc

    type(coefficients(rv)) :: Coeffs    ! For interpolation
    type(vector_T) :: XP                ! Same form as xStar, contents as x
    type(vector_T) :: YP                ! Same form as yStar,=kstar*(xp-xStar)
    type(vector_T) :: DELTAX            ! xp-xStar
    type(Signal_T), pointer :: signal   ! Signal from the configuration

    type(L2PC_T), pointer :: L2PC     ! The l2pc to use
    type(MatrixElement_T), pointer :: L2PCBLOCK  ! A block from the l2pc
    type(MatrixElement_T), pointer :: JBLOCK     ! A block from the jacobian

    type(VectorValue_T), pointer :: RADINL2PC ! The relevant radiance part of yStar
    type(VectorValue_T), pointer :: STATEQ ! A state vector quantity
    type(VectorValue_T), pointer :: PTAN ! Tangent pressure quantity
    type(VectorValue_T), pointer :: TEMP ! Temperature quantity
    type(VectorValue_T), pointer :: XSTARPTAN ! Tangent pressure in l2pc
    type(VectorValue_T), pointer :: L2PCQ ! A quantity in the l2pc
    type(VectorValue_T), pointer :: SIDEBANDFRACTION ! From the state vector
    type(VectorValue_T), pointer :: LOWERSIDEBANDFRACTION ! From the state vector
    type(VectorValue_T), pointer :: UPPERSIDEBANDFRACTION ! From the state vector
    type(VectorValue_T), pointer :: THISXSTARQ ! Quantitiy from supplied XStar vector

    ! Executable code

    ! Identify the band/maf we're looking for

    maf = fmStat%maf

    call trace_begin ( me, 'LinearizedForwardModel, MAF=', index=maf, &
      & cond=toggle(emit) )

    nullify ( dense )

    signal => fmConf%signals(1)

    doChannel = .true.
    if ( associated ( signal%channels ) ) doChannel = signal%channels

    call SelectL2PCBins ( fmConf, FwdModelIn, FwdModelExtra, &
      & radiance, signal%sideband, maf, &
      & l2pcBins, sidebandStart, sidebandStop, sidebandStep )

    ! If we're doing a split calculation then get the relevant
    ! sideband information.
    ! Note, this is *NOT* the same decision process as for the full forward model
    ! and deliberately so.
    if ( sidebandStart /= sidebandStop .or. fmConf%forceSidebandFraction ) then
      sidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, &
        & sideband=0, noError=.true. )
      lowerSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, &
        & sideband=-1, noError=.true. )
      upperSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, &
        & sideband=1, noError=.true. )
      if (.not. associated (sidebandFraction) .and. .not. &
        & ( associated ( lowerSidebandFraction) .and. &
        &   associated ( upperSidebandFraction ) ) ) &
        & call MLSMessage( MLSMSG_Error, ModuleName, &
        & "No sideband fraction supplied" )
    end if

    ! --------- Loop over sidebands ------------------------------------------------
    do sideband = sidebandStart, sidebandStop, sidebandStep
      ! Setup a sideband fraction array
      ! Note, this is *NOT* the same decision process as for the full forward model
      ! and deliberately so.
      if ( sidebandStart /= sidebandStop .or. fmConf%forceSidebandFraction ) then !????
        if ( associated ( sidebandFraction ) ) then
          thisFraction = sidebandFraction%values(:,1)
          if ( sideband == 1 ) thisFraction = 1.0 - thisFraction
        else
          if ( sideband == -1 ) then
            thisFraction = lowerSidebandFraction%values(:,1)
          else
            thisFraction = upperSidebandFraction%values(:,1)
          end if
        end if
      else                  ! Otherwise, want just unfolded signal
        thisFraction = 1.0
      end if

      ! Load this bin if necessary
      ! But don't load Hessians if we've elected to ignore them
      call PopulateL2PCBin ( l2pcBins(sideband), fmConf%ignoreHessian )

      ! Work out which l2pc bin we want
      l2pc => l2pcDatabase(l2pcBins(sideband))

      ! Set a dimension
      radInl2pc => GetVectorQuantityByType ( &
        & l2pc%j%row%vec, quantityType=l_radiance, &
        & signal=signal%index, sideband=sideband )
      noPointings = radInL2PC%template%noSurfs
      if ( radInL2PC%template%noChans /= noChans ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Channel dimension in l2pc not same as in measurements" )

      ! Now we loop over the quantities in the l2pc file and construct an xPrime
      ! for them
      call cloneVector ( xP, l2pc%j%col%vec, vectorNameText='_xP' )
      call cloneVector ( deltaX, xP, vectorNameText='_deltaX' ) ! sets values to 0.0

      ! Set up some other stuff before main loop
      ! Get the two ptans; we'll need these for interpolation
      ptan => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra, &
        & quantityType = l_ptan, &
        & instrumentModule = radiance%template%instrumentModule,&
        & foundInFirst = ptanInFirst )

      xStarPtan => GetVectorQuantityByType ( l2pc%j%col%vec, &
        & quantityType = l_ptan )

      rowLBlock = 1
      if ( present (jacobian) ) rowJBlock = &
        & FindBlock ( jacobian%row, radiance%index, maf )

      ! Now, if we need any derivatives, we need to setup some arrays
      if ( present(jacobian) ) then
        call Hunt ( xStarPtan%values(:,1), ptan%values(:,maf), mifPointingsLower )
        mifPointingsUpper = mifPointingsLower + 1

        upperWeight = &
          & ( ptan%values(:,maf) - xStarPtan%values(mifPointingsLower,1) ) / &
          & ( xStarPtan%values(mifPointingsUpper,1) - &
          &   xStarPtan%values(mifPointingsLower,1) )
        lowerWeight = 1.0 - upperWeight
        upperWeight = min ( 1.0_r8, max (upperWeight, 0.0_r8 ) )
        lowerWeight = min ( 1.0_r8, max (lowerWeight, 0.0_r8 ) )
      end if

      ! -------- Main loop over xStar quantities -------------------------------
      quantityLoop: do qtyInd = 1, size ( l2pc%j%col%vec%quantities )

        ! Identify this quantity in xStar
        l2pcQ => l2pc%j%col%vec%quantities(qtyInd)

        ! Now see if we are wanting to deal with this
        if ( l2pcQ%template%quantityType == l_ptan ) cycle ! Get this from interpolation
        if ( l2pcQ%template%quantityType == l_vmr ) then
          if (.not. associated(fmConf%molecules) ) cycle
          if ( .not. any (l2pcQ%template%molecule == &
            &   fmConf%molecules)) cycle
          if ( isExtinction(l2pcQ%template%molecule) ) cycle
        end if

        ! Identify this quantity in x
        call FindMatchForL2PCQ ( l2pcQ, fmConf, fwdModelIn, fwdModelExtra, &
          & stateQ, foundInFirst )

        ! If it's not in the state vector, and the l2pc does contain
        ! derivative information for this then make a fuss.
        if ( .not. associated(stateQ) ) then
          do xStarInstance = 1, l2pcQ%template%noInstances
            colLBlock = FindBlock ( l2pc%j%col, l2pcQ%index, xStarInstance )
            if ( l2pc%j%block(rowLBlock,colLBlock)%kind /= M_Absent ) then
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "No quantity in state vectors found to match %s", &
                & datum=l2pcQ%template%name )
            end if
          end do
          cycle quantityLoop            ! Go to next l2pc quantity
        end if

        if ( toggle(emit) .and. levels(emit) > 1 ) then
          call output ( 'Dealing with xStar Quantity named ' )
          call display_string ( l2pc%j%col%vec%quantities(qtyInd)%template%name, &
            & advance='yes' )
        end if

        ! Do we need derivatives for this?
        doDerivatives = present(jacobian) .and. foundInFirst
        if ( doDerivatives ) then
          select case ( l2pcQ%template%quantityType )
          case ( l_temperature )
            doDerivatives = fmConf%temp_der
          case ( l_vmr )
            doDerivatives = associated(fmConf%molecules) .and. fmConf%atmos_der
            if ( doDerivatives ) then
              doDerivatives = any( l2pcQ%template%molecule == &
                & pack(fmConf%molecules, fmConf%moleculeDerivatives) )
            end if
          case default ! Can we get here?
            doDerivatives = .false.
          end select
        end if

        ! OK, we're legit, let's get going.
        instanceLen = l2pcQ%template%instanceLen
        closestInstance = FindOneClosestInstance ( stateQ, radiance, maf )

        ! Loop over profiles.
        ! Assumes l2pcQ is stacked.
        center = l2pcQ%template%noInstances/2 + 1
        do xStarInstance = 1, l2pcQ%template%noInstances
          ! Identify this instance in state
          if ( sum(fmConf%phiWindow) == 0.0 ) then
            ! If 0, user wants 1D, always choose the closest instance
            deltaInstance = 0
          else
            ! Try to fit within phiWindow
            deltaInstance = xStarInstance - center
            if ( fmConf%windowUnits == PHYQ_Angle ) then
              phiWindowLoop: do
                deltaPhi = l2pcQ%template%phi(1,center+deltaInstance) - &
                  & l2pcQ%template%phi(1,center)
                if ( deltaPhi > fmConf%phiWindow(2) ) then
                  deltaInstance = deltaInstance - 1
                else if ( deltaPhi < -fmConf%phiWindow(1) ) then
                  deltaInstance = deltaInstance + 1
                else
                  exit phiWindowLoop
                end if
              end do phiWindowLoop
            else ! fmConf%windowUnits == PHYQ_Profiles
              deltaInstance = max ( -nint(fmConf%phiWindow(1)), &
                                  & min ( nint(fmConf%phiWindow(2)), &
                                        & deltaInstance ) )
            end if
          end if

          xInstance = closestInstance + deltaInstance
          xInstance = max ( 1, min ( xInstance, stateQ%template%noInstances ) )

          ! Fill this part of xP, if we have been supplied an xStar fill xP with
          ! the delta otherwise, xP is just the direct state
          if ( fmConf%xStar /= 0 ) then
            i = GetVectorQuantityIndexByName ( vectors(fmConf%xStar), stateQ%template%name )
            if ( i == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unable to find quantity in xStar vector supplied' )
            thisXStarQ => vectors(fmConf%xStar)%quantities(i)
            xP%quantities(qtyInd)%values(:,xStarInstance) = &
              & stateQ%values(:,xInstance) - thisXStarQ%values(:,xInstance)
          else
            xP%quantities(qtyInd)%values(:,xStarInstance) = &
              & stateQ%values(:,xInstance)
          end if

          ! Note that we've ignored the mask in stateQ here. We might
          ! in later versions want to apply one mask field?

          ! Interpolate kStar to K if required.
          if ( present ( jacobian ) ) fmStat%rows(rowJBlock) = .true.
          ! We want to set the row flag even if we don't compute derivatives
          ! as we want our contribution to the radiances known.
          if ( doDerivatives ) then
            colLBlock = FindBlock ( l2pc%j%col, l2pcQ%index, xStarInstance )
            colJBlock = FindBlock ( jacobian%col, stateQ%index, xInstance )
            l2pcBlock => l2pc%j%block(rowLBlock,colLBlock)

            if ( l2pcBlock%kind /= M_Absent ) then
              ! OK, before, I was doing transpose / reshapes / 
              ! interpolates / transpose / reshapes.  That was taking too long,
              ! so I'm going to do the interpolations by hand

              ! Get pointer to l2pc information
              if ( any ( l2pcBlock%kind == &
                & (/ M_Column_Sparse, M_Banded /) ) ) then
                call allocate_test ( dense, &
                  & noChans * noPointings, instanceLen, &
                  & 'dense', ModuleName )
                call densify ( dense, l2pcBlock )
                kBit => dense
              else
                kBit => l2pcBlock%values
              end if

              ! Indentify the block in the jacobian
              jBlock => jacobian%block(rowJblock,colJblock)
              select case ( jBlock%kind )
              case ( M_Absent )
                call CreateBlock ( jBlock, &
                  & noChans*noMIFs, instanceLen, &
                  & M_Full, init=0.0_rm )
              case ( M_Banded, M_Column_Sparse )
                call MLSMessage( MLSMSG_Error, ModuleName, &
                  & "Code not written for adding to non full blocks" )
              case default
              end select

              ! Now do the interpolation
!$OMP PARALLEL DO private ( i, lower, upper, chan, doElement )
              do mif = 1, noMIFs
                i = ( mif - 1 ) * noChans + 1
                lower = (mifPointingsLower(mif)-1)*noChans + 1
                upper = (mifPointingsUpper(mif)-1)*noChans + 1
                do chan = 1, noChans
                  doElement = doChannel(chan)
                  if ( doElement .and. associated ( radiance%mask ) ) &
                    & doElement = iand ( ichar ( radiance%mask(i,maf)), m_linAlg ) == 0
                  if ( doElement ) then
                    ! It's tempting to think we need a if sideband==sidebandStart 
                    ! case here where we ensure we zero out jBlock the first time.
                    ! However! The 2D computation makes that a mistake as at the chunk
                    ! edges, all the derivatives need to be piled up on each other.
                    jBlock%values ( i , : ) = &
                      & jBlock%values ( i , : ) + &
                      &   thisFraction(chan) * ( &
                      &     lowerWeight(mif) * kBit( lower, : ) + &
                      &     upperWeight(mif) * kBit( upper, : ) )
                  end if
                  i = i + 1
                  lower = lower + 1
                  upper = upper + 1
                end do
              end do
!$OMP END PARALLEL DO

              call deallocate_test ( dense, 'dense', ModuleName )
            end if                        ! Any matrix here?
          end if                          ! do derivatives?
        end do                            ! End loop over xStar Profiles

        ! Compute this instance of deltaX
        if ( fmConf%xStar /= 0 ) then
          ! The delta has already been done in the xStar supplied case
          deltaX%quantities(qtyInd)%values = xP%quantities(qtyInd)%values
        else
          ! Otherwise, difference it from the l2pc state
          deltaX%quantities(qtyInd)%values = &
            & xP%quantities(qtyInd)%values - &
            & l2pc%j%col%vec%quantities(qtyInd)%values
        end if

      end do quantityLoop               ! End loop over quantities

      ! Now compute yP
      if ( (deltaX /= 0.0_rv) .and. EXPECTDELTAXALLZERO ) then
        call dump ( fmConf )
        call dump ( deltaX, name='deltaX' )
        call MLSMessage( MLSMSG_Error, ModuleName, &
          & "deltaX not all zero" )
      end if

      if ( toggle(emit) .and. levels(emit) > 8 ) then
        call dump ( deltaX, name='deltaX' )
        call dump ( l2pc%j%col%inst, 'l2pc%j%col%inst' )
        call dump ( l2pc%j%col%quant, 'l2pc%j%col%quant' )

        call dump ( l2pc%j%row%inst, 'l2pc%j%row%inst' )
        call dump ( l2pc%j%row%quant, 'l2pc%j%row%quant' )
      end if

      call cloneVector( yp, l2pc%j%row%vec, vectorNameText='_yP' )
      call MultiplyMatrixVectorNoT ( l2pc%j, deltaX, yP, update = .false. )
      if ( .not. fmConf%ignoreHessian .and. l2pc%goth ) &
        ! We have a Hessian and want to use it; add a term to the Taylor series
        & call Multiply ( l2pc%h, deltaX, yP, 0.5_rv, update = .true. )

      if ( toggle(emit) .and. levels(emit) > 8 ) then
        call dump ( yp, name='yP' )
        call dump ( l2pc%j%row%vec, name='l2pc%j%row%vec' )
      end if

      ! Now, if no yStar has been supplied add the one in the l2pc file to yP
      if ( fmConf%yStar == 0 ) yP = yP + l2pc%j%row%vec

      ! Now we interpolate yP to ptan
      ! Do this using setup, loop, teardown instead of using the array
      ! interpolator to avoid allocating and deallocating ypMapped and
      ! ypMapped = transpose ( &
      !   & reshape ( yp%quantities(1)%values(:,1), (/noChans, noPointings/) ) )
      call InterpolateArraySetup ( &
        & xStarPtan%values(:,1), &      ! OldX
        & ptan%values(:,maf), &         ! NewX
        & 'Spline', &                   ! use spline
        & coeffs, &                     ! the coefficients
        & extrapolate='Constant', &     ! no extrapolation
        & dyByDx=.true. )               ! need more coefficients for this

      ! call outputNamedValue( 'shape(xp)', shape(xStarPtan%values) )
      ! call outputNamedValue( 'shape(yp)', shape(yp%quantities(1)%values) )
      ! call outputNamedValue( 'noChans', noChans )
      ! call outputNamedValue( 'noPointings', noPointings )
      do chan = 1, noChans
        top = noChans*noPointings + chan  - noChans
        ! call outputNamedValue( 'chan', chan )
        ! call outputNamedValue( 'top', top )
        ! call outputNamedValue( 'shape(OldX)', shape(xStarPtan%values(:,1)) )
        ! call outputNamedValue( 'shape(OldY)', shape(yp%quantities(1)%values(chan:top:noChans,1)) )
        ! call outputNamedValue( 'shape(NewX)', shape(ptan%values(:,maf)) )
        ! call outputNamedValue( 'shape(NewY)', shape(resultMapped(:,chan)) )
        call InterpolateValues ( coeffs, &
          & xStarPtan%values(:,1), &                       ! OldX
          & yp%quantities(1)%values(chan:top:noChans,1), & ! OldY
          & ptan%values(:,maf), &                          ! NewX
          & resultMapped(:,chan), &                        ! NewY
          & 'Spline', &                                    ! use spline
          & extrapolate='Constant', &                      ! No extrapolation
          & dyByDx=dyByDx(:,chan) )
      end do

      call InterpolateArrayTeardown ( coeffs )

      ! Either place or add, make decision outside loop!
      if ( sideband == sidebandStart ) then
        do chan = 1, noChans
          if ( doChannel ( chan ) ) then
            do mif = 1, noMIFs
              radiance%values( chan + (mif-1)*noChans, maf ) = &
                & thisFraction(chan)*resultMapped ( mif, chan )
            end do
          end if
        end do
      else
        do chan = 1, noChans
          if ( doChannel ( chan ) ) then
            do mif = 1, noMIFs
              radiance%values( chan + (mif-1)*noChans, maf ) = &
                & radiance%values( chan + (mif-1)*noChans, maf ) + &
                &   thisFraction(chan)*resultMapped ( mif, chan )
            end do
          end if
        end do
      end if

      ! Now deal with ptan derivatives
      if ( present( jacobian ) .and. ptanInFirst ) then
        colJBlock = FindBlock ( jacobian%col, ptan%index, maf )
        jBlock => jacobian%block( rowJBlock, colJBlock )
        select case (jBlock%kind)
        case (m_absent)
          call CreateBlock ( jacobian, rowJBlock, colJBlock, m_banded, &
            & noMIFs*noChans, bandHeight=noChans, init=0.0_rm )
        case (m_banded)
          call CheckForSimpleBandedLayout ( jBlock, noChans, 'jBlock in Linearized model' )
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName,&
            & 'Wrong matrix type for ptan derivative')
        end select

        ! Either place or add, make decision outside loop!
        if ( sideband == sidebandStart ) then
          do chan = 1, noChans
            if ( doChannel ( chan ) ) then
              do mif = 1, noMIFs
                jBlock%values( chan + (mif-1)*noChans, 1 ) = &
                  & thisFraction(chan) * dyByDx ( mif, chan )
              end do                    ! Minor frames
            end if                      ! Doing this channel
          end do                        ! Channels
        else                            ! Must be doing second sideband
          do chan = 1, noChans
            if ( doChannel ( chan ) ) then
              do mif = 1, noMIFs
                jBlock%values( chan + (mif-1)*noChans, : ) = &
                  & jBlock%values ( chan + (mif-1)*noChans, : ) + &
                  &   thisFraction(chan) * dyByDx ( mif, chan )
              end do                    ! Minor frames
            end if                      ! Doing this channel
          end do                        ! Channel
        end if                          ! First/second sideband
      end if                            ! Folding

      ! Now think about optical depth
      if ( radiance%template%quantityType == l_opticalDepth ) then
        ! Get temperature and interpolate to tangent points
        temp => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_temperature, config=fmConf )
        closestInstance = FindOneClosestInstance ( temp, radiance, maf )
        call InterpolateValues ( &
          & temp%template%surfs(:,1), &
          & temp%values(:,closestInstance), &
          & ptan%values(:,maf), &
          & tangentTemperature, &
          & 'Spline', extrapolate='Constant' )
        ! Now convert radiance to optical depth
        radiance%values(:,maf) = 1.0 - &
          & radiance%values(:,maf) / reshape ( spread ( &
          & tangentTemperature, 1, noChans ), (/ radiance%template%instanceLen /) )
        where ( radiance%values(:,maf) > 0.0 )
          radiance%values(:,maf) = -log( radiance%values(:,maf) )
        elsewhere
          radiance%values(:,maf) = 1.0e5 ! Choose a suitable large value
        end where
      end if

      call DestroyVectorInfo ( xP )
      call DestroyVectorInfo ( deltaX )
      call DestroyVectorInfo ( yP )

    end do                                ! End of sideband loop

    ! If a yStar has been supplied, we need to add that on.
    ! We also need to add on the impact of any perturbation in tangent pressure
    ! in the xStar/yStar supplied case too
    if ( fmConf%yStar /= 0 ) call Add_y_Star

    if ( switchDetail(switches,'rad') + switchDetail(switches,'RAD') > -2 ) then
      call dump ( radiance, name='Linearized radiances', details=1, options="c" )
      if ( switchDetail(switches,'RAD') > -1 ) stop
    end if

    call trace_end ( 'LinearizedForwardModel', cond=toggle(emit) )

  contains

    ! ======================================== Internal procedures =====

    ! -----------------------------------------------  Add_y_Star  -----
    subroutine Add_y_Star
    ! If a yStar has been supplied, we need to add that on.
    ! We also need to add on the impact of any perturbation in tangent pressure
    ! in the xStar/yStar supplied case too

      real (r8), dimension(noMIFs) :: deltaPtan ! Change of ptan between x and supplied xStar
      real (r8), dimension(noMIFs, noChans) :: dummy ! Workspace
      real (r8), dimension(noMIFs, noChans) :: dYStarByDPtan ! Remapped values of l2pc
      integer, dimension(noMIFs) :: ptanOrder ! Ordering for ptan
      real (r8), dimension(noMIFs) :: sortedPtan ! supplied ptan in ascending order
      real (r8), dimension(noMIFs, noChans) :: sortedDYStarByDPtan ! Remapped values of l2pc
      real (r8), dimension(noMIFs, noChans) :: sortedYStarMapped ! Remapped values of l2pc
      real (r8), dimension(noMIFs, noChans) :: yStarMapped ! Remapped values of l2pc

      type(VectorValue_T), pointer :: THISYSTARQ ! Quantitiy from supplied YStar vector

      ! Identify the radiance in the supplied yStar vector
      thisYStarQ => GetVectorQuantityByType ( vectors(fmConf%yStar), &
        & quantityType=l_radiance, signal=signal%index, sideband=signal%sideband )

      ! We're going to interpolate this in ptan.  Extract it and make
      ! sure ptan is in ascending order.
      yStarMapped = transpose ( reshape ( thisYStarQ%values(:,maf), (/ noChans, noMIFs /) ) )
      call SortP ( ptan%values(:,maf), 1, noMIFs, ptanOrder )
      do i = 1, noMIFs
        sortedPtan ( i ) = ptan%values ( ptanOrder(i), maf )
        sortedyStarMapped ( i, : ) = yStarMapped ( ptanOrder(i), : )
      end do

      ! 'Interpolate' this to get the derivatives
      call InterpolateValues ( &
        & sortedPtan, &                 ! OldX
        & sortedyStarMapped, &          ! OldY
        & sortedPtan, &                 ! NewX (the same as oldX)
        & dummy, &                      ! NewY (don't care about it)
        & 'Spline', &                   ! Use spline
        & extrapolate='Constant', &     ! No extrapolation
        & dyByDx=sortedDyStarByDPtan, & ! This is what we're after
        & skipNewY=.true. )

      ! Now 'unsort' the result
      do i = 1, noMIFs
        dYStarByDptan ( ptanOrder(i), : ) = sortedDyStarByDPtan ( i, : )
      end do

      ! Now compute 'deltaPtan'
      xStarPtan => GetVectorQuantityByType ( vectors ( fmConf%xStar ), quantityType = l_ptan, &
        & instrumentModule = radiance%template%instrumentModule )
      deltaPtan = ptan%values(:,maf) - xStarPtan%values(:,maf)

      ! Add these impacts to our radiances
      do chan = 1, noChans
        if ( doChannel ( chan ) ) then
          do mif = 1, noMIFs
            i = chan + ( mif - 1 ) * noChans
            radiance%values( i, maf ) = radiance%values( i, maf ) + &
              & thisYStarQ%values ( i, maf ) + &
              &   dYStarByDPtan ( mif, chan ) * deltaPtan(mif)
          end do
        end if
      end do

      ! Output the ptan derivatives if they're wanted
      if ( present ( jacobian ) .and. ptanInFirst ) then
        ! We know the block is already of the right type (banded) from our
        ! work above.
        colJBlock = FindBlock ( jacobian%col, ptan%index, maf )
        jBlock => jacobian%block( rowJBlock, colJBlock )

        do chan = 1, noChans
          if ( doChannel ( chan ) ) then
            do mif = 1, noMIFs
              i = chan + (mif-1) * noChans
              jBlock%values( i, 1 ) = jBlock%values( i, 1 ) + &
                & dyStarByDPtan ( mif, chan )
            end do                    ! Minor frames
          end if                      ! Doing this channel
        end do                        ! Channels
      end if

    end subroutine Add_y_Star

  end subroutine LinearizedForwardModelAuto

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: LinearizedForwardModel_m.f90,v 2.92 2016/04/13 00:47:57 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module LinearizedForwardModel_m

! $Log: LinearizedForwardModel_m.f90,v $
! Revision 2.92  2016/04/13 00:47:57  vsnyder
! Use operator(/=) from VectorsModule instead of AreEqual function
!
! Revision 2.91  2015/08/25 17:24:32  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.  Pay attention to the units of
! PhiWindow instead of assuming it's the number of profiles.
!
! Revision 2.90  2013/08/30 03:56:23  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.89  2013/08/12 23:48:09  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.88  2012/07/31 00:45:02  vsnyder
! Comment out OUTPUTNAMEDVALUE in USE since its use is commented out
!
! Revision 2.87  2011/11/11 00:42:06  vsnyder
! Use IsExtinction array from Molecules module
!
! Revision 2.86  2011/08/20 02:31:47  vsnyder
! Delete unused variable declaration
!
! Revision 2.85  2011/08/20 02:10:06  vsnyder
! Simplify emitting an error message
!
! Revision 2.84  2011/05/09 17:50:34  pwagner
! Converted to using switchDetail
!
! Revision 2.83  2011/03/28 17:52:08  pwagner
! Fixed bug in calculating top before call to InterpolateValues
!
! Revision 2.82  2010/09/25 01:08:39  vsnyder
! Cannonball polishing
!
! Revision 2.81  2010/06/29 19:57:58  vsnyder
! Add 0.5 factor to Hessian-Vector-Vector multiply
!
! Revision 2.80  2010/06/07 23:25:18  vsnyder
! Revise how failure to find desired blocks is handled
!
! Revision 2.79  2010/05/19 17:52:53  pwagner
! Removed unused stuff
!
! Revision 2.78  2010/05/19 00:33:46  vsnyder
! Get rid of a temp, hopefully interpolate faster, pass ignoreHessian into
! PopulateL2PCBin, cosmetic changes.
!
! Revision 2.77  2010/05/13 23:46:00  pwagner
! Temporary expedients for l2pc files with Hessians; needs more code
!
! Revision 2.76  2010/04/30 23:57:40  vsnyder
! Remove StateQ from SelectL2PCBins call
!
! Revision 2.75  2010/04/13 01:42:30  vsnyder
! Move FindMatchForL2PCQ, FlushLockedBins, SelectL2PCBins to L2PCBins_m
!
! Revision 2.74  2010/03/26 23:13:12  vsnyder
! Add ignoreHessian field to forward model config
!
! Revision 2.73  2010/02/25 18:02:17  pwagner
! Conforms with changed l2pc structure
!
! Revision 2.72  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.71  2009/04/20 18:44:27  pwagner
! Needed changes when identical types with different names allowed in L2PC files
!
! Revision 2.70  2008/10/03 16:39:29  livesey
! Bug fix with EXTINCTIONV2
!
! Revision 2.69  2008/10/03 16:31:13  livesey
! Added EXTINCTIONV2
!
! Revision 2.68  2008/06/06 22:51:44  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.67  2008/05/07 20:55:32  vsnyder
! OOPS, can't test optional args in specification exprs
!
! Revision 2.66  2008/05/02 20:14:09  vsnyder
! Further simplification using MERGE in dimensions
!
! Revision 2.65  2008/05/02 19:44:39  vsnyder
! Cure three memory leaks, plus some reorg
!
! Revision 2.64  2007/06/29 19:32:42  vsnyder
! Make ForwardModelIntermediate_t private to ScanModelModule
!
! Revision 2.63  2007/04/03 17:45:10  vsnyder
! Add target attribute to FwdModelIn and FwdModelExtra, replace pointer
! attribute on Vectors with Target attribute.
!
! Revision 2.62  2006/07/19 22:33:02  vsnyder
! Cannonball polishing
!
! Revision 2.61  2006/06/19 15:53:35  livesey
! My first 'bug fix' was a mistake
!
! Revision 2.60  2006/06/16 23:41:57  livesey
! Bug fix, if called twice on same band species derivatives doubled rather
! than rewritten
!
! Revision 2.59  2006/06/15 17:40:33  pwagner
! Stops with err instead of continuing with warning if xStar qty not in statevectors
!
! Revision 2.58  2005/06/30 22:42:34  livesey
! Bug fix for split sideband case
!
! Revision 2.57  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.56  2004/11/01 20:24:48  vsnyder
! Reorganization of representation for molecules and beta groups
!
! Revision 2.55  2004/08/06 01:09:49  livesey
! Updated to fix Van's new definition of fmConf%molecules
!
! Revision 2.54  2004/07/07 19:42:11  vsnyder
! Use new Init argument of CreateBlock
!
! Revision 2.53  2004/02/07 00:45:36  livesey
! Fixed a bug in the sideband handling.  Was overzelous yesterday.
!
! Revision 2.52  2004/02/05 23:30:39  livesey
! Fixed long standing problem with single sideband radiometers.
!
! Revision 2.51  2003/11/01 18:44:39  livesey
! Bug fixes in bin selection
!
! Revision 2.50  2003/10/29 00:44:53  livesey
! Bug fix in forceSidebandFraction handling
!
! Revision 2.49  2003/10/28 23:44:15  livesey
! Various changes involved in adding the forceFoldedOutput option to
! support the hybrid model.
!
! Revision 2.48  2003/10/09 22:17:10  livesey
! Various bug fixes, and added the call to CheckForSimpleBandedLayout
!
! Revision 2.47  2003/09/15 17:42:52  livesey
! Various bug fixes associated with getting the polar linear model
! working.
!
! Revision 2.46  2003/09/11 23:10:32  livesey
! Added option to linearize around pre-computed state/radiances instead of
! those in the l2pc file.
!
! Revision 2.45  2003/08/20 20:07:22  livesey
! Bug fix in ptan derivatives (not actually a problem yet but would have
! become one).  Also, more commented out if statements for the single
! sideband case, and some cosmetic changes.
!
! Revision 2.44  2003/08/14 20:24:08  livesey
! Added the exact bin criterion
!
! Revision 2.43  2003/08/13 00:48:23  livesey
! Removed the faking of binSelectors, forwardModelSupport now ensures
! there's always one to hand.
!
! Revision 2.42  2003/07/15 22:10:38  livesey
! Added support for hybrid model
!
! Revision 2.41  2003/07/09 20:16:26  livesey
! Anticipative bug fix in sideband stuff (not really used so far)
!
! Revision 2.40  2003/05/29 16:37:45  livesey
! Renamed sideband fraction
!
! Revision 2.39  2003/02/22 00:40:22  livesey
! Now can use OpenMP
!
! Revision 2.38  2003/02/17 00:33:41  livesey
! Added deallocation of possible/cost to fix memory leak.
!
! Revision 2.37  2003/02/06 01:13:28  livesey
! Added the dump stuff
!
! Revision 2.36  2003/02/06 00:46:03  livesey
! New SelectL2PCBins routine.
!
! Revision 2.35  2003/02/05 21:58:31  livesey
! Just a tidy up in preparation for the new bin selectors stuff
!
! Revision 2.34  2003/01/29 22:43:25  livesey
! More intelligent setting of rows flags.
!
! Revision 2.33  2003/01/08 23:50:15  livesey
! Now doesn't bother to create derivatives for masked radiances
!
! Revision 2.32  2002/12/16 15:31:57  mjf
! Use GetQuantityForForwardModel instead of GetVectorQuantityByType.
!
! Revision 2.31  2002/11/14 17:54:06  livesey
! Changed 'no quantity found' warning message to work better.
!
! Revision 2.30  2002/11/14 17:46:08  livesey
! Bypassed a warning message that was starting to irritate me.
!
! Revision 2.29  2002/10/08 17:08:05  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.28  2002/10/02 23:19:51  livesey
! Various bug fixes associated with extinction
!
! Revision 2.27  2002/10/02 02:42:55  livesey
! Changes to allow the new mixed extinction stuff
!
! Revision 2.26  2002/09/13 22:53:22  vsnyder
! Move USE statements from module scope to procedure scope.  Cosmetic changes.
! Move some loop-invariant allocate/deallocates out of loops.
!
! Revision 2.25  2002/09/13 18:09:09  pwagner
! May change matrix precision rm from r8
!
! Revision 2.24  2002/09/11 17:43:39  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 2.23  2002/09/03 23:46:04  livesey
! Moved debug print statement to location where it will be less verbose.
!
! Revision 2.22  2002/07/22 03:25:50  livesey
! Minor bug fix
!
! Revision 2.21  2002/07/17 06:02:01  livesey
! Got HDF5 l2pcs working
!
! Revision 2.20  2002/07/09 17:37:45  livesey
! Removed ptan extrapolation
!
! Revision 2.19  2002/07/02 19:51:21  livesey
! Embarassing bug, was choosing 'center' wrong, lead to lag
! and all sorts of messyness
!
! Revision 2.18  2002/06/12 17:46:21  livesey
! Better treatment of real phiWindow
!
! Revision 2.17  2002/06/12 17:02:25  livesey
! Very TEMPORARY! change to LinearizedForwardModel to skip round real
! value of phiWindow.  Fix it properly later.
!
! Revision 2.16  2002/05/28 22:34:21  livesey
! Added more useful diagnostic message
!
! Revision 2.15  2002/05/14 22:32:53  livesey
! Added single sideband stuff
!
! Revision 2.14  2002/05/03 23:29:31  livesey
! Added split sideband ratio stuff
!
! Revision 2.13  2002/03/15 21:23:09  livesey
! New bin selectors based on 'latitude' allowed
!
! Revision 2.12  2002/02/20 03:00:23  livesey
! Made the verbose dump more unlikely
!
! Revision 2.11  2002/02/12 21:48:21  livesey
! Fixed minor bug for case when no bin selectors
!
! Revision 2.10  2002/02/09 21:35:22  livesey
! Minor bug fixes
!
! Revision 2.9  2002/02/09 19:11:19  livesey
! Added optical depth calculation etc.
!
! Revision 2.8  2002/02/08 22:51:00  livesey
! Working (hopefully) version of bin selection
!
! Revision 2.7  2002/02/06 01:34:20  livesey
! Changed to use FindOneClosestInstance
!
! Revision 2.6  2002/01/21 22:52:21  livesey
! A few more comments
!
! Revision 2.5  2002/01/21 22:46:08  livesey
! Wrote, but not hooked up SelectL2PCBin
!
! Revision 2.4  2002/01/17 02:17:04  livesey
! Somewhat temporary, skip l2pc state vector components we don't like
!
! Revision 2.3  2001/10/22 16:51:40  livesey
! Allow radiance extrapolation (at least for now).
!
! Revision 2.2  2001/10/07 00:23:50  livesey
! Fixed minor bug with dyByDx
!
! Revision 2.1  2001/10/02 16:51:41  livesey
! Removed fmStat%finished and reordered loops in forward models
!
! Revision 2.0  2001/09/17 20:26:26  livesey
! New forward model
!
! Revision 1.22  2001/06/04 22:43:26  livesey
! Now works when no molecules at all
!
! Revision 1.21  2001/06/01 20:35:55  livesey
! Now obeys the phiWindow parameter to give 1D forward models.
!
! Revision 1.20  2001/06/01 20:09:28  livesey
! Embarassing bug to do with edge effects removed.  This version makes L2 work!
!
! Revision 1.19  2001/05/25 19:12:21  livesey
! Embarassing bug fix.  Was using quantity basis as framework for interpolation,
! not pointings in the l2pc file!
!
! Revision 1.18  2001/05/19 01:21:33  livesey
! Bug fix, was only storing derivatives for second sideband.
!
! Revision 1.17  2001/05/09 19:46:49  vsnyder
! Use new bandHeight argument of createBlock
!
! Revision 1.16  2001/05/08 23:26:36  livesey
! Embarassing typo/bug fixed
!
! Revision 1.15  2001/05/03 22:58:38  livesey
! Removed bug work around
!
! Revision 1.14  2001/05/03 02:02:54  vsnyder
! Use emit toggle.  Add names to cloned vectors
!
! Revision 1.13  2001/05/02 20:26:17  vsnyder
! Give names to cloned vectors.  Use toggle(emit) and levels(emit) to
! control debugging output.
!
! Revision 1.12  2001/05/02 20:22:13  livesey
! Removed some unused variables.
!
! Revision 1.11  2001/05/01 06:55:07  livesey
! Intermediate bug avoiding version.
!
! Revision 1.10  2001/04/30 15:50:29  livesey
! Commented out code associated with mask
!
! Revision 1.9  2001/04/28 22:32:07  livesey
! Nothing much changed apart from comments.
! Need to add code to have it ignore state stuff according to MASK.
!
! Revision 1.8  2001/04/28 21:23:33  livesey
! Working version.  Does folded sidebands (not tested yet), nice and fast
!
! Revision 1.7  2001/04/28 19:40:37  livesey
! Working version. Assembles jacobian in a nice fast manner.
! Next thing is to do sideband folding.
!
! Revision 1.6  2001/04/28 07:05:25  livesey
! Another interim version
!
! Revision 1.5  2001/04/28 04:40:56  livesey
! Another interim version.
!
! Revision 1.4  2001/04/28 01:54:54  livesey
! Interim, non working but compiling version
!
! Revision 1.3  2001/04/27 17:35:42  livesey
! An interim version for some testing.
!
! Revision 1.2  2001/04/26 23:54:32  livesey
! Interim version
!
! Revision 1.1  2001/04/25 20:49:27  vsnyder
! Initial commit
!
@


2.92
log
@Use operator(/=) from VectorsModule instead of AreEqual function
@
text
@d128 1
a128 1
    use MLSNUMERICS, only: COEFFICIENTS_R8, HUNT, INTERPOLATEARRAYSETUP, &
d140 1
a140 1
      & VECTOR_T, VECTORVALUE_T
d211 1
a211 1
    type(coefficients_r8) :: Coeffs     ! For interpolation
d798 1
a798 1
       "$Id: LinearizedForwardModel_m.f90,v 2.91 2015/08/25 17:24:32 vsnyder Exp $"
d808 3
@


2.91
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.  Pay attention to the units of
PhiWindow instead of assuming it's the number of profiles.
@
text
@d138 1
a138 1
      & AREEQUAL, CLONEVECTOR,  DESTROYVECTORINFO, DUMP, &
d538 1
a538 1
      if ( .not. areEqual(deltaX, c=0._rv) .and. EXPECTDELTAXALLZERO ) then
d543 1
a543 1
      endif
d798 1
a798 1
       "$Id: LinearizedForwardModel_m.f90,v 2.90 2013/08/30 03:56:23 vsnyder Exp $"
d808 6
@


2.90
log
@Revise use of trace_begin and trace_end
@
text
@d116 2
a117 2
    use INTRINSIC, only: L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
      & L_LIMBSIDEBANDFRACTION, L_OPTICALDEPTH
a380 4
        ! OK, we're legit, let's get going.
        instanceLen = l2pcQ%template%instanceLen
        closestInstance = FindOneClosestInstance ( stateQ, radiance, maf )

d398 6
a403 1
        ! Loop over profiles
d407 1
a407 1
          if ( fmConf%phiWindow == 0.0 ) then
d411 1
d413 17
a429 12
            ! Try to fit within phiWindow
            phiWindowLoop: do
              deltaPhi = l2pcQ%template%phi(1,center+deltaInstance) - &
                & l2pcQ%template%phi(1,center)
              if ( deltaPhi > fmConf%phiWindow ) then
                deltaInstance = deltaInstance - 1
              else if ( deltaPhi < -fmConf%phiWindow ) then
                deltaInstance = deltaInstance + 1
              else
                exit phiWindowLoop
              end if
            end do phiWindowLoop
d798 1
a798 1
       "$Id: LinearizedForwardModel_m.f90,v 2.89 2013/08/12 23:48:09 pwagner Exp $"
d808 3
@


2.89
log
@FindSomethings moved to MLSFinds module
@
text
@d166 1
d238 2
a239 2
    if ( toggle(emit) ) &
      & call trace_begin ( 'LinearizedForwardModel, MAF=', index=maf )
d697 1
a697 1
    if ( toggle(emit) ) call trace_end ( 'LinearizedForwardModel' )
d791 1
a791 1
       "$Id: LinearizedForwardModel_m.f90,v 2.88 2012/07/31 00:45:02 vsnyder Exp $"
d801 3
@


2.88
log
@Comment out OUTPUTNAMEDVALUE in USE since its use is commented out
@
text
@d28 2
d112 1
a112 1
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
d131 1
a131 1
    use MOLECULES, only: IsExtinction
d138 2
a139 2
      & CLONEVECTOR,  DESTROYVECTORINFO, DUMP, GETVECTORQUANTITYINDEXBYNAME, &
      & GETVECTORQUANTITYBYTYPE, M_LINALG, &
d268 2
a269 2
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband fraction supplied")
d530 7
a538 1

d790 1
a790 1
       "$Id: LinearizedForwardModel_m.f90,v 2.87 2011/11/11 00:42:06 vsnyder Exp $"
d800 3
@


2.87
log
@Use IsExtinction array from Molecules module
@
text
@d131 1
a131 1
    use OUTPUT_M, only: OUTPUT, OUTPUTNAMEDVALUE
d782 1
a782 1
       "$Id: LinearizedForwardModel_m.f90,v 2.86 2011/08/20 02:31:47 vsnyder Exp $"
d792 3
@


2.86
log
@Delete unused variable declaration
@
text
@d129 1
a129 1
    use MOLECULES, only: L_EXTINCTION, L_EXTINCTIONV2
d351 1
a351 3
          if ( ( l2pcQ%template%molecule == l_extinction .or. &
            &    l2pcQ%template%molecule == l_extinctionv2 ) .and. &
            & l2pcQ%template%radiometer /= signal%radiometer ) cycle
d782 1
a782 1
       "$Id: LinearizedForwardModel_m.f90,v 2.85 2011/08/20 02:10:06 vsnyder Exp $"
d792 3
@


2.85
log
@Simplify emitting an error message
@
text
@a190 2
    character (len=80) :: WORD          ! A word to output

d784 1
a784 1
       "$Id: LinearizedForwardModel_m.f90,v 2.84 2011/05/09 17:50:34 pwagner Exp $"
d794 3
@


2.84
log
@Converted to using switchDetail
@
text
@d130 1
d132 1
a132 1
    use STRING_TABLE, only: DISPLAY_STRING, GET_STRING
a367 1
              call get_string ( l2pcQ%template%name, word, strip=.true. )
d369 2
a370 1
                &  "No quantity in state vectors found to match "//trim(word) )
d786 1
a786 1
       "$Id: LinearizedForwardModel_m.f90,v 2.83 2011/03/28 17:52:08 pwagner Exp $"
d796 3
@


2.83
log
@Fixed bug in calculating top before call to InterpolateValues
@
text
@d34 8
a41 8
    use ForwardModelConfig, only: FORWARDMODELCONFIG_T
    use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T
    use Intrinsic, only: L_RADIANCE, L_OPTICALDEPTH
    use MatrixModule_1, only: MATRIX_T
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSignals_m, only: Signal_T
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
d108 7
a114 7
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Dump_0, only: DUMP
    use ForwardModelConfig, only: FORWARDMODELCONFIG_T
    use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use HessianModule_1, only: Multiply
    use Intrinsic, only: L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
d116 4
a119 4
    use L2PC_m, only: L2PC_T, L2PCDATABASE, POPULATEL2PCBIN
    use L2PCBins_m, only: FindMatchForL2PCQ, SelectL2PCBins
    use ManipulateVectorQuantities, only: FINDONECLOSESTINSTANCE
    use MatrixModule_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
d121 1
a121 1
    use MatrixModule_1, only: MATRIX_T, MULTIPLYMATRIXVECTORNOT, DUMP, &
d123 12
a134 11
    use MLSKinds, only: R8, RM, RV
    use MLSSignals_m, only: Signal_T
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSNumerics, only: Coefficients_R8, HUNT, InterpolateArraySetup, &
      & InterpolateArrayTeardown, INTERPOLATEVALUES
    use Molecules, only: L_EXTINCTION, L_EXTINCTIONV2
    use Output_m, only: Output, OUTPUTNAMEDVALUE
    use String_Table, only: Display_String, Get_String
    use Toggles, only: Emit, Levels, Switches, Toggle
    use Trace_m, only: Trace_begin, Trace_end
    use VectorsModule, only: assignment(=), OPERATOR(-), OPERATOR(+), &
d138 1
a138 1
    use Sort_m, only: SORTP
d686 1
a686 1
    if ( index(switches,'rad') + index(switches,'RAD') > 0 ) then
d688 1
a688 1
      if ( index(switches,'RAD') > 0 ) stop
d785 1
a785 1
       "$Id: LinearizedForwardModel_m.f90,v 2.82 2010/09/25 01:08:39 vsnyder Exp $"
d795 3
@


2.82
log
@Cannonball polishing
@
text
@d129 1
a129 1
    use Output_m, only: Output
d567 4
d572 7
a578 1
        top = chan + noPointings - 1
d784 1
a784 1
       "$Id: LinearizedForwardModel_m.f90,v 2.81 2010/06/29 19:57:58 vsnyder Exp $"
d794 3
@


2.81
log
@Add 0.5 factor to Hessian-Vector-Vector multiply
@
text
@a271 4
      ! Load this bin if necessary
      ! But don't load Hessians if we've elected to ignore them
      call PopulateL2PCBin ( l2pcBins(sideband), fmConf%ignoreHessian )

d290 4
d774 1
a774 1
       "$Id: LinearizedForwardModel_m.f90,v 2.80 2010/06/07 23:25:18 vsnyder Exp $"
d784 3
@


2.80
log
@Revise how failure to find desired blocks is handled
@
text
@d123 1
a123 1
    use MLSCommon, only: r8, rm
d544 1
a544 1
        & call Multiply ( l2pc%h, deltaX, yP, update = .true. )
d774 1
a774 1
       "$Id: LinearizedForwardModel_m.f90,v 2.79 2010/05/19 17:52:53 pwagner Exp $"
d784 3
@


2.79
log
@Removed unused stuff
@
text
@a175 1
    logical :: ANYBLOCKS                ! Flag for checking derivatives
a362 1
          anyBlocks = .false.
d366 3
a368 2
              anyBlocks = .true.
              exit
a370 5
          if ( anyBlocks ) then
            call get_string ( l2pcQ%template%name, word, strip=.true. )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              &  "No quantity in state vectors found to match "//trim(word) )
          end if
d448 1
a448 1
          if (doDerivatives) then
d774 1
a774 1
       "$Id: LinearizedForwardModel_m.f90,v 2.78 2010/05/19 00:33:46 vsnyder Exp $"
d784 3
@


2.78
log
@Get rid of a temp, hopefully interpolate faster, pass ignoreHessian into
PopulateL2PCBin, cosmetic changes.
@
text
@a21 3
  ! This array is used to keep track of which bins to use for each (side)band.
  integer, dimension(:,:), pointer, private, save :: lockedBins => NULL()

d40 1
a40 1
    use VectorsModule, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T
d115 1
a115 2
      & L_LIMBSIDEBANDFRACTION, L_ZETA, L_OPTICALDEPTH, L_LATITUDE, L_FIELDSTRENGTH, &
      & L_FIELDELEVATION, L_FIELDAZIMUTH
d124 1
a124 1
    use MLSSignals_m, only: Signal_T, GetSignalName
a129 1
    use QuantityTemplates, only: QuantityTemplate_T
d136 1
a136 1
      & VALIDATEVECTORQUANTITY, VECTOR_T, VECTORVALUE_T
d780 1
a780 1
       "$Id: LinearizedForwardModel_m.f90,v 2.77 2010/05/13 23:46:00 pwagner Exp $"
d790 4
@


2.77
log
@Temporary expedients for l2pc files with Hessians; needs more code
@
text
@d20 1
a20 1
  public :: LinearizedForwardModel
a56 2
    integer :: NOCHANS                  ! Dimension
    integer :: NOMIFS, NOMIFSJ          ! Number of minor frames
d68 2
a69 2
    ! ... but in certain rare circumstances (when we're called by the hybrid model)
    ! we might want to force the folded one.
d74 2
a75 2
    ! Now, it's possible we're really being asked to deal with optical depth, not
    ! radiance.
a98 6
    ! Set some dimensions
    noChans = radiance%template%noChans
    noMIFs = radiance%template%noSurfs
    noMIFsJ = 0
    if ( present(jacobian) ) noMifsJ = noMIFs

d100 4
a103 1
    & fmStat, radiance, noChans, noMifs, noMIFsJ, Jacobian, vectors )
d109 1
a109 1
    & fmStat, radiance, noChans, noMifs, noMIFsJ, Jacobian, vectors )
d130 2
a131 1
    use MLSNumerics, only: HUNT, INTERPOLATEVALUES
d136 1
a136 1
    use Toggles, only: Emit, Levels, Toggle
d139 3
a141 4
      & CLONEVECTOR, &
      & DESTROYVECTORINFO, GETVECTORQUANTITYBYTYPE, VECTOR_T, &
      & VECTORVALUE_T, DUMP, &
      & VALIDATEVECTORQUANTITY, M_LINALG, GETVECTORQUANTITYINDEXBYNAME
d151 1
a151 1
    type(VectorValue_T), intent(inout) :: RADIANCE ! The radiance quantity to fill
d176 1
d188 2
a189 2
    integer, dimension(NoMifsJ) :: mifPointingsLower ! Result of a hunt
    integer, dimension(NoMifsJ) :: mifPointingsUpper ! mifPointingsLower+1
d198 1
a198 1
    ! - yPrime (yP) is contains one maf of the relevant radiances, but on the
d203 4
a206 3
    real (r8), dimension(NoMifsJ) :: lowerWeight ! For interpolation
    real (r8), dimension(NoMifsJ) :: upperWeight ! For interpolation
    real (r8), dimension(merge(noMifs,0,radiance%template%quantityType==l_opticalDepth)) :: tangentTemperature ! For optical depth
a208 1
    real (r8), dimension(:,:), pointer :: yPmapped ! Remapped values of yP
d214 1
d244 1
a244 1
    nullify ( dense, yPmapped )
d280 2
a281 2
      if ( fmConf%ignoreHessian ) l2pcDatabase(l2pcBins(sideband))%goth = .false.
      call PopulateL2PCBin ( l2pcBins(sideband) )
d397 13
a409 9
        if (doDerivatives .and. (l2pcQ%template%quantityType==l_temperature) ) &
          & doDerivatives = fmConf%temp_der
        if (doDerivatives .and. &
          & (l2pcQ%template%quantityType==l_vmr) .and. &
          & associated(fmConf%molecules) ) then
          doDerivatives = fmConf%atmos_der
          if ( doDerivatives .and. .not. any (l2pcQ%template%molecule == &
            & pack(fmConf%molecules, fmConf%moleculeDerivatives))) &
            & doDerivatives = .false.
d438 2
a439 2
          ! Fill this part of xP, if we have been supplied an xStar fill xP with the delta
          ! otherwise, xP is just the direct state
d490 1
a490 1
                  & "Not written code for adding to non full blocks" )
d562 1
a562 1
      ! Now, if no yStar has been supplied add yP to the one in the l2pc file
d566 5
a570 8
      call allocate_test( ypMapped, radInL2PC%template%noSurfs, &
        & noChans, 'ypMapped', ModuleName )

      yPmapped = transpose ( &
        & reshape ( yp%quantities(1)%values(:,1), &
        &           (/radInL2PC%template%noChans, radInL2PC%template%noSurfs/) ) )

      call InterpolateValues ( &
a571 1
        & yPmapped, &                   ! OldY
a572 1
        & resultMapped, &               ! NewY
d574 15
a588 2
        & extrapolate='Constant', &     ! No extrapolation
        & dyByDx=dyByDx )
d590 1
a590 1
      call Deallocate_test ( ypMapped, 'ypMapped', ModuleName )
d686 5
d785 1
a785 1
       "$Id: LinearizedForwardModel_m.f90,v 2.76 2010/04/30 23:57:40 vsnyder Exp $"
d795 3
@


2.76
log
@Remove StateQ from SelectL2PCBins call
@
text
@d282 2
a284 1

d771 1
a771 1
       "$Id: LinearizedForwardModel_m.f90,v 2.75 2010/04/13 01:42:30 vsnyder Exp $"
d781 3
@


2.75
log
@Move FindMatchForL2PCQ, FlushLockedBins, SelectL2PCBins to L2PCBins_m
@
text
@d254 1
a254 1
    call SelectL2PCBins ( fmConf, FwdModelIn, FwdModelExtra, StateQ, &
d770 1
a770 1
       "$Id: LinearizedForwardModel_m.f90,v 2.74 2010/03/26 23:13:12 vsnyder Exp $"
d780 3
@


2.74
log
@Add ignoreHessian field to forward model config
@
text
@d20 1
a20 1
  public :: FlushLockedBins, LinearizedForwardModel
a32 11
  ! --------------------------------------------  FlushLockedBins  -----
  subroutine FlushLockedBins
    use Allocate_Deallocate, only: DEALLOCATE_TEST
    use L2PC_m, only: FLUSHL2PCBINS

    ! This could set them to zero again, but I think I'll deallocate here, just
    ! because otherwise I'd have to write a separate deallocate routine.
    call deallocate_test ( lockedBins, 'lockedBins', moduleName )
    call FlushL2PCBins
  end subroutine FlushLockedBins

d126 2
a127 2
    use ManipulateVectorQuantities, only: FINDONECLOSESTINSTANCE, &
      & DOHGRIDSMATCH, DOVGRIDSMATCH, DOFGRIDSMATCH
d133 1
a133 1
    use MLSSignals_m, only: Signal_T, GetSidebandLoop, GetSignalName
d254 3
a256 2
    call SelectL2PCBins ( radiance, signal%sideband, maf, l2pcBins, &
      & sidebandStart, sidebandStop, sidebandStep )
d520 1
a520 3
              if ( any ( l2pcBlock%kind == &
                & (/ M_Column_Sparse, M_Banded /) ) ) &
                & call deallocate_test ( dense, 'dense', ModuleName )
d540 1
a540 1
        call dump ( (/deltaX/) )
d556 2
a557 1
        call dump ( (/yp, l2pc%j%row%vec/) )
d580 2
a667 1
      call Deallocate_test ( ypMapped, 'ypMapped', ModuleName )
a764 350
    ! ----------------------------------------  FindMatchForL2PCQ  -----
    subroutine FindMatchForL2PCQ ( l2pcQ, fmConf, FwdModelIn, FwdModelExtra, &
      & stateQ, foundInFirst )
      type (VectorValue_T), intent(in) :: L2PCQ ! Quantity to search for
      type (ForwardModelConfig_T), intent(in) :: fmConf ! Forward model config
      type (Vector_T), intent(in), target :: FWDMODELIN ! State vector
      type (Vector_T), intent(in), target :: FWDMODELEXTRA ! Extra state vector
      type (VectorValue_T), pointer :: STATEQ ! Result
      logical, intent(out) :: FOUNDINFIRST ! If set, found in first vector
      ! This routine looks through the supplied state vectors and finds a match
      ! for the supplied quantity from the l2pc state vector.  It then goes on to
      ! test that the HGrids and VGrids for the two quantities match appropriately.

      ! Local variables
      integer :: QTY, VEC
      type (Vector_T), pointer :: V

      ! Executable code
      foundInFirst = .false.
      ! We're going to be fairly picky about this.  I don't want to get into the
      ! habit of blindly accepting quantities that might not be appropriate.
      ! Therefore, I have a list of 'acceptable' quantity types.
      select case ( l2pcQ%template%quantityType )
      case ( l_temperature )
        stateQ => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_temperature, config=fmConf, &
          & foundInFirst = foundInFirst, noError=.true. )
      case ( l_vmr )
        ! Here we may need to be a little more intelligent
        if ( l2pcQ%template%molecule /= l_extinction .and. l2pcQ%template%molecule /= l_extinctionv2 ) then
          stateQ => GetQuantityForForwardModel ( FwdModelIn, FwdModelExtra,&
            & quantityType = l_vmr, config=fmConf, &
            & molecule = l2pcQ%template%molecule, &
            & foundInFirst = foundInFirst, noError=.true., matchQty=l2pcQ )
        else
          searchLoop: do vec = 1, 2
            ! Point to appropriate vector
            if ( vec == 1 ) then
              v => FwdModelIn
            else
              v => FwdModelExtra
            end if
            ! Skip this vector if it doesn't exist
            if ( .not. associated ( v ) ) cycle searchLoop
            ! Loop over this vector
            do qty = 1, size ( v%quantities )
              stateQ => v%quantities(qty)
              if ( stateQ%template%quantityType == l_vmr .and. &
                &  ( stateQ%template%molecule == l_extinction .or. &
                &    stateQ%template%molecule == l_extinctionv2 ) .and. &
                &  stateQ%template%radiometer == l2pcQ%template%radiometer ) then
                if ( DoFGridsMatch ( l2pcQ, stateQ ) ) exit searchLoop
              end if
            end do
          end do searchLoop
          foundInFirst = ( vec == 1 )
        end if
      case ( l_fieldStrength, l_fieldAzimuth, l_fieldElevation )
        ! This is for quantities that are 'easy to get'
        stateQ => GetQuantityForForwardModel ( FwdModelIn, FwdModelExtra,&
          & quantityType = l2pcQ%template%quantityType, config=fmConf, &
          & foundInFirst = foundInFirst, noError=.true. )
      case default
        nullify ( stateQ )
      end select

      ! Now check that these match.
      if ( associated ( stateQ ) ) then
        if ( .not. DoVGridsMatch ( stateQ, l2pcQ ) ) stateQ => NULL()
      end if
      if ( associated ( stateQ ) ) then
        if ( .not. DoHGridsMatch ( stateQ, l2pcQ, spacingOnly=.true. ) ) stateQ => NULL()
      end if

      if ( .not. associated ( stateQ ) ) foundInFirst = .false.

    end subroutine FindMatchForL2PCQ

    ! ---------------------------------------------  NormalizePhi  -----
    elemental real (r8) function NormalizePhi ( phi ) result ( lat )
      ! This does an approximate phi to latitude conversion
      real (r8), intent(in) :: PHI      ! Input geodetic angle
      ! Executable code
      lat = modulo ( phi, 360.0_r8 )
      if ( (lat > 90.0) .and. (lat <= 180.0) ) then
        lat = 180.0 - lat
      else if ( ( lat > 180.0 ) .and. ( lat <= 270.0 ) ) then
        lat = 180.0 - lat
      else if ( lat > 270.0 ) then
        lat = lat - 360.0
      end if
    end function NormalizePhi

    ! --------------------------------------------- SelectL2PCBins -----
    subroutine SelectL2PCBins ( radiance, sideband, maf, l2pcBins, &
      & sidebandStart, sidebandStop, sidebandStep )
      use MLSSignals_m, only: signals
      use L2PC_M, only: BINSELECTORS, BINSELECTOR_T
      use Intrinsic, only: L_NAMEFRAGMENT, L_SZA
      use Toggles, only: SWITCHES
      use MLSFillValues, only: ESSENTIALLYEQUAL

      type (VectorValue_T), intent(in) :: RADIANCE ! The radiance we're after
      integer, intent(in) :: SIDEBAND ! Which sideband (see below)
      integer, intent(in) :: MAF                      ! MAF index
      integer, dimension(-1:1), intent(out) :: L2PCBINS ! Result
      integer, intent(out) :: SIDEBANDSTART ! Resulting loop indices
      integer, intent(out) :: SIDEBANDSTOP
      integer, intent(out) :: SIDEBANDSTEP
      ! We supply the sideband separately because when the Linearized model is being
      ! invoked by the hybrid model, the sideband in radiance is not the one we really want

      ! Local variables
      character (len=132) :: BINNAME      ! The name of the bin
      character (len=132) :: NAMEFRAGMENT ! Fragment of name to try to match

      integer :: BIN                    ! Loop counter
      integer :: L2PCINSTANCE           ! Instance index
      integer :: MAF1                   ! Subset limit
      integer :: MAFN                   ! Subset limit
      integer :: MYMAF                  ! A loop counter
      integer :: NOBINS                 ! Number of l2pc bins
      integer :: NOSELECTORS            ! A loop limit
      integer :: SELECTOR               ! Bin selector index
      integer :: SIGNAL                 ! Signal index
      integer :: STATEINSTANCE          ! Instance index
      integer :: tmpSideband            ! Loop counter
      logical :: SPLIT                  ! Need a split calculation
      logical :: FOUNDINFIRST           ! Flag, not used
      real(r8) :: THISCOST              ! Interim cost

      integer, dimension(1) :: S1, S2   ! Results of minloc
      logical, dimension(-1:1,size(l2pcDatabase)) :: POSSIBLE ! Flags for each bin
      real(r8), dimension(size(l2pcDatabase)) :: COST ! Cost of each bin
      real(r8), dimension(-1:1) :: BESTCOST
      type (QuantityTemplate_T), pointer :: BINRAD ! Quantity template
      type (BinSelector_T), pointer :: SEL ! One bin selector

      ! Executable code

      ! Firstly, if we're in locked bins mode, then just return the locked bin
      signal = radiance%template%signal
      noBins = size ( l2pcDatabase )

      ! Now special code for dealing with the locked bins case
      if ( fmConf%lockBins ) then
        if ( .not. associated ( lockedBins ) ) &
          & call allocate_test ( lockedBins, 1, size(signals), 'lockedBins', &
            & moduleName, low1=-1, fill=0 )
        if ( any ( lockedBins ( :, signal ) /= 0 ) ) then
          l2pcBins = lockedBins ( :, signal )
          ! If got folded, use that by preference (3rd argument below).
          ! Assert that sidebands are present if needed here.
          call GetSidebandLoop ( signal, sideband, &
            & (lockedBins(0,signal)==0), sidebandStart, sidebandStop, &
            & sidebandStep )
          return
        end if
      end if

      ! Code will only get to here if the bins are unlocked, or will be locked
      ! once we've decided on them.

      ! Setup the arrays we need, possible is a flag to indicate (for
      ! each sideband) whether a bin is even worth considering, cost is
      ! the associated cost.

      ! Get a first cut at the 'possible' flag
      possible = .false.
      do bin = 1, noBins
        binRad => l2pcDatabase(bin)%j%row%vec%quantities(1)%template
        possible ( binRad%sideband, bin ) = ( binRad%signal == signal )
      end do
      ! Set the cost to zero by default
      cost = 0.0_r8

      ! Setup some stuff we'll need from time to time
      if ( fmConf%lockBins ) then
        maf1 = 1 + radiance%template%noInstancesLowerOverlap
        mafN = radiance%template%noInstances - &
          & radiance%template%noInstancesUpperOverlap
      else
        maf1 = maf
        mafN = maf
      end if

      ! OK, now we have to loop over the bin selectors for each bin and
      ! apply the rules they give.
      noSelectors = size ( fmConf%binSelectors )
      do bin = 1, noBins
        if ( .not. any ( possible ( :, bin ) ) ) cycle
        binRad => l2pcDatabase(bin)%j%row%vec%quantities(1)%template
        do selector = 1, noSelectors
          sel => binSelectors ( fmConf%binSelectors(selector) )
          select case ( sel%selectorType )
          case ( l_nameFragment )
            if ( l2pcDatabase(bin)%name < 1 ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'l2pc db name missing from string table' )
            if ( sel%nameFragment < 1 ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'l2pc selector name fragment missing from string table' )
            call get_string ( l2pcDatabase(bin)%name, binName, strip=.true., cap=.true. )
            call get_string ( sel%nameFragment, nameFragment, strip=.true., cap=.true. )
            if ( len_trim(nameFragment) /= 0 ) then
              possible ( :, bin ) = possible ( :, bin ) .and. &
                & index ( trim(binName), trim(nameFragment) ) /= 0
            end if
          case ( l_latitude )
            ! When we say latitude, we really mean an empirical phi.
            thisCost = sqrt ( sum ( &
              & (NormalizePhi(radiance%template%phi(1,maf1:mafN)) - &  
              &  NormalizePhi(binRad%phi(1,1)) )**2 ) / (mafN-maf1+1) ) / &
              & sel%cost
            if ( sel%exact ) then
              possible ( :, bin ) = possible ( :, bin ) .and. &
                & EssentiallyEqual ( thisCost, 0.0_r8 )
            else
              cost(bin) = cost(bin) + thisCost
            end if
          case ( l_sza )
            thisCost = sqrt ( sum ( &
              & ( radiance%template%solarZenith(1,maf1:mafN) - &
              &   binRad%solarZenith(1,1) )**2 ) / &
              & (mafN-maf1+1) ) / sel%cost
            if ( sel%exact ) then
              possible ( :, bin ) = possible ( :, bin ) .and. &
                & EssentiallyEqual ( thisCost, 0.0_r8 )
            else
              cost(bin) = cost(bin) + thisCost
            end if
          case ( l_temperature, l_vmr, l_fieldStrength, l_fieldElevation, l_fieldAzimuth )
            ! This one involves matching elements of xStar with x.
            if ( sel%selectorType == l_vmr ) then
              l2pcQ => GetVectorQuantityByType ( &
                & l2pcDatabase(bin)%j%col%vec, quantityType=l_vmr, &
                & molecule=sel%molecule, noError=.true. )
            else
              l2pcQ => GetVectorQuantityByType ( &
                & l2pcDatabase(bin)%j%col%vec, quantityType=sel%selectorType, &
                & noError=.true. )
            end if
            if ( .not. associated ( l2pcQ ) ) then
              possible ( :, bin ) = .false.
            else
              if ( .not. ValidateVectorQuantity ( l2pcQ,&
                & verticalCoordinate = (/ l_zeta /) ) ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Expected zeta coordinate for quantity in binSelector' )
              ! Find the relevant corresponding quantity in the state vector
              call FindMatchForL2PCQ ( l2pcQ, fmConf, fwdModelIn, &
                & fwdModelExtra, stateQ, foundInFirst )
              ! If we've got both of them make sure they match
              if ( associated(stateQ) .and. associated(l2pcQ) ) then
                ! OK, identify height range
                if ( all ( binSelectors(selector)%heightRange > 0.0 ) ) then
                  s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                    & log10(binSelectors(selector)%heightRange(1) ) ) )
                  s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                    & log10(binSelectors(selector)%heightRange(2) ) ) )
                else
                  s1 = 1
                  s2 = stateQ%template%noSurfs
                end if
                ! Here we'll just compare the central profile in the
                ! l2pc with the state profile closest to each maf.
                l2pcInstance = l2pcQ%template%noInstances/2 + 1
                thisCost = 0.0_r8
                do myMaf = maf1, mafN
                  ! Only compare the closest profile to the maf
                  stateInstance = FindOneClosestInstance ( stateQ, radiance, myMaf )
                  thisCost = thisCost + sum ( &
                    & ( stateQ%values ( s1(1):s2(1), stateInstance ) - &
                    &   l2pcQ%values  ( s1(1):s2(1), l2pcInstance  ) ) **2 )
                end do
                ! If we require an exact match set the possible flag,
                ! otherwise just report our cost.
                if ( sel%exact ) then
                  possible ( :, bin ) = possible ( :, bin ) .and. &
                    & EssentiallyEqual ( thisCost, 0.0_r8 )
                else
                  cost ( bin ) = cost ( bin ) + sqrt ( thisCost / &
                    &  ( ( s2(1)-s1(1)+1 ) * ( mafN - maf1 + 1 ) ) ) / sel%cost
                end if
              end if
            end if
          end select                  ! Bin selector type
        end do                        ! Loop over selectors
      end do                          ! Loop over bins

      if ( index ( switches, 'binsel' ) /= 0 ) then
        call output ( 'Choosing bin for ' )
        call GetSignalName ( signal, namefragment, sideband=sideband )
        call output ( trim(nameFragment), advance='yes' )
        do bin = 1, noBins
          if ( any ( possible ( :, bin ) ) ) then
            call output  ( 'Candidate: ' )
            call display_string ( l2pcDatabase(bin)%name, strip=.true. )
            call output ( ' cost = ' )
            call output ( cost(bin), advance='yes' )
          end if
        end do
      end if

      ! OK, now we've surveyed the bins, let's cut things down.
      ! When computing folded radiances I'll always choose folded bins
      ! over unfolded ones, even if they cost more.  I think it's
      ! unlikely that this will really be an issue anyway.
      split = .false.
      if ( sideband == 0 ) then
        ! If we've got a match for the folded case, forget the others.
        if ( any ( possible(0,:) ) ) then
          where ( possible(0,:) ) 
            possible(-1,:) = .false.
            possible(1,:) = .false.
          end where
        else
          split = .true.
        end if
      end if

      ! Work out the range of the sideband loop
      call GetSidebandLoop ( signal, sideband, split, &
        & sidebandStart, sidebandStop, sidebandStep )

      ! Choose the bin(s)
      bestCost = huge ( cost(1) )
      l2pcBins = 0
      do bin = 1, noBins
        ! Reuse the sideband variable here, we don't need it's old
        ! definition anymore
        do tmpSideband = sidebandStart, sidebandStop
          if ( possible(tmpSideband,bin) .and. &
            & cost(bin) < bestCost(tmpSideband) ) then
            bestCost(tmpSideband) = cost(bin)
            l2pcBins(tmpSideband) = bin
          end if
        end do
      end do

      ! Check that we've got the bins we need
      if (any(l2pcBins ((/sidebandStart,sidebandStop/)) == 0 )) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unable to find l2pc bins to match request' )

      ! Record this in the 'locked bins' information
      if ( fmConf%lockBins ) lockedBins ( :, signal ) = l2pcBins

    end subroutine SelectL2PCBins

d770 1
a770 1
       "$Id: LinearizedForwardModel_m.f90,v 2.73 2010/02/25 18:02:17 pwagner Exp $"
d780 3
@


2.73
log
@Conforms with changed l2pc structure
@
text
@d84 2
a85 2
    radiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal=signal%index, sideband=sideband, noError=.true. )
d90 2
a91 2
      & radiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_opticalDepth, &
        & signal=signal%index, sideband=sideband, noError=.true. )
d132 1
d563 3
d1130 1
a1130 1
       "$Id: LinearizedForwardModel_m.f90,v 2.72 2009/06/23 18:26:10 pwagner Exp $"
d1140 3
@


2.72
log
@Prevent Intel from optimizing ident string away
@
text
@d27 1
a27 1
       "$RCSfile: $"
d55 1
d135 1
a135 1
    use L2PC_m, only: L2PCDATABASE, POPULATEL2PCBIN
d233 1
a233 1
    type(Matrix_T), pointer :: L2PC     ! The l2pc to use
d316 1
a316 1
        & l2pc%row%vec, quantityType=l_radiance, &
d325 1
a325 1
      call cloneVector ( xP, l2pc%col%vec, vectorNameText='_xP' )
d335 1
a335 1
      xStarPtan => GetVectorQuantityByType ( l2pc%col%vec, &
d357 1
a357 1
      quantityLoop: do qtyInd = 1, size ( l2pc%col%vec%quantities )
d360 1
a360 1
        l2pcQ => l2pc%col%vec%quantities(qtyInd)
d382 2
a383 2
            colLBlock = FindBlock ( l2pc%col, l2pcQ%index, xStarInstance )
            if ( l2pc%block(rowLBlock,colLBlock)%kind /= M_Absent ) then
d398 1
a398 1
          call display_string ( l2pc%col%vec%quantities(qtyInd)%template%name, &
d467 1
a467 1
            colLBlock = FindBlock ( l2pc%col, l2pcQ%index, xStarInstance )
d469 1
a469 1
            l2pcBlock => l2pc%block(rowLBlock,colLBlock)
d544 1
a544 1
            & l2pc%col%vec%quantities(qtyInd)%values
d553 2
a554 2
        call dump ( l2pc%col%inst, 'l2pc%col%inst' )
        call dump ( l2pc%col%quant, 'l2pc%col%quant' )
d556 2
a557 2
        call dump ( l2pc%row%inst, 'l2pc%row%inst' )
        call dump ( l2pc%row%quant, 'l2pc%row%quant' )
d560 2
a561 2
      call cloneVector( yp, l2pc%row%vec, vectorNameText='_yP' )
      call MultiplyMatrixVectorNoT ( l2pc, deltaX, yP, update = .false. )
d564 1
a564 1
        call dump ( (/yp, l2pc%row%vec/) )
d568 1
a568 1
      if ( fmConf%yStar == 0 ) yP = yP + l2pc%row%vec
d941 1
a941 1
        binRad => l2pcDatabase(bin)%row%vec%quantities(1)%template
d962 1
a962 1
        binRad => l2pcDatabase(bin)%row%vec%quantities(1)%template
d967 6
d1006 1
a1006 1
                & l2pcDatabase(bin)%col%vec, quantityType=l_vmr, &
d1010 1
a1010 1
                & l2pcDatabase(bin)%col%vec, quantityType=sel%selectorType, &
d1126 1
a1126 1
       "$Id: read_apriori.f90 is it here $"
d1136 3
@


2.71
log
@Needed changes when identical types with different names allowed in L2PC files
@
text
@d27 1
a27 1
       "$RCSfile: LinearizedForwardModel_m.f90,v $"
d1116 1
a1117 1
!---------------------------- RCS Ident Info -------------------------------
d1119 2
a1120 3
       "$Id: LinearizedForwardModel_m.f90,v 2.70 2008/10/03 16:39:29 livesey Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1122 1
d1124 1
d1129 3
@


2.70
log
@Bug fix with EXTINCTIONV2
@
text
@d803 1
a803 1
            & foundInFirst = foundInFirst, noError=.true. )
d1119 1
a1119 1
       "$Id: LinearizedForwardModel_m.f90,v 2.69 2008/10/03 16:31:13 livesey Exp $"
d1128 3
@


2.69
log
@Added EXTINCTIONV2
@
text
@d818 2
a819 1
                &  stateQ%template%molecule == l2pcQ%template%molecule .and. &
d1119 1
a1119 1
       "$Id: LinearizedForwardModel_m.f90,v 2.68 2008/06/06 22:51:44 pwagner Exp $"
d1128 3
@


2.68
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d145 1
a145 1
    use Molecules, only: L_EXTINCTION
d367 2
a368 1
          if ( l2pcQ%template%molecule == l_extinction .and. &
d799 1
a799 1
        if ( l2pcQ%template%molecule /= l_extinction ) then
d806 1
a806 1
            ! Point to appropraite vector
d818 1
a818 1
                &  stateQ%template%molecule == l_extinction .and. &
d1118 1
a1118 1
       "$Id: LinearizedForwardModel_m.f90,v 2.67 2008/05/07 20:55:32 vsnyder Exp $"
d1127 3
@


2.67
log
@OOPS, can't test optional args in specification exprs
@
text
@d868 1
a868 1
      use MLSNumerics, only: ESSENTIALLYEQUAL
d1117 1
a1117 1
       "$Id: LinearizedForwardModel_m.f90,v 2.66 2008/05/02 20:14:09 vsnyder Exp $"
d1126 3
@


2.66
log
@Further simplification using MERGE in dimensions
@
text
@d68 1
a68 1
    integer :: NOMIFS                   ! Number of minor frames
d114 2
d118 1
a118 1
    & fmStat, radiance, noChans, noMifs, Jacobian, vectors )
d124 1
a124 1
    & fmStat, radiance, noChans, noMifs, Jacobian, vectors )
d166 1
a166 1
    integer, intent(in) :: NoChans, NoMifs ! Dimensions
d201 2
a202 2
    integer, dimension(merge(noMifs,0,present(jacobian))) :: mifPointingsLower ! Result of a hunt
    integer, dimension(merge(noMifs,0,present(jacobian))) :: mifPointingsUpper ! mifPointingsLower+1
d216 2
a217 2
    real (r8), dimension(merge(noMifs,0,present(jacobian))) :: lowerWeight ! For interpolation
    real (r8), dimension(merge(noMifs,0,present(jacobian))) :: upperWeight ! For interpolation
d1117 1
a1117 1
       "$Id: LinearizedForwardModel_m.f90,v 2.65 2008/05/02 19:44:39 vsnyder Exp $"
d1126 3
@


2.65
log
@Cure three memory leaks, plus some reorg
@
text
@a68 1
    integer :: NOMIFSJ                  ! Dimension, 0 if no Jacobian
a113 2
    noMifsJ = noMifs
    if ( .not. present(jacobian) ) noMifsJ = 0
d116 1
a116 1
    & fmStat, radiance, noChans, noMifs, noMifsJ, Jacobian, vectors )
d122 1
a122 1
    & fmStat, radiance, noChans, noMifs, noMifsJ, Jacobian, vectors )
d164 1
a164 1
    integer, intent(in) :: NoChans, NoMifs, NoMifsJ ! Dimensions
d199 2
a200 2
    integer, dimension(noMifsJ) :: mifPointingsLower ! Result of a hunt
    integer, dimension(noMifsJ) :: mifPointingsUpper ! mifPointingsLower+1
d214 3
a216 3
    real (r8), dimension(noMifsJ) :: lowerWeight ! For interpolation
    real (r8), dimension(noMifsJ) :: upperWeight ! For interpolation
    real (r8), dimension(noMIFs) :: tangentTemperature ! For optical depth
d1115 1
a1115 1
       "$Id: LinearizedForwardModel_m.f90,v 2.64 2007/06/29 19:32:42 vsnyder Exp $"
d1124 3
@


2.64
log
@Make ForwardModelIntermediate_t private to ScanModelModule
@
text
@d1 1
d48 79
d144 1
a144 2
    use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, &
      & MLSMSG_Allocate
d153 1
a153 1
      & CLONEVECTOR,&
d160 1
a160 1
    type(forwardModelConfig_T), intent(inout) :: FMCONF
a164 1
    type(vector_T), intent(inout) :: FWDMODELOUT  ! Radiances, etc.
d166 2
a182 2
    integer :: NOCHANS                  ! Dimension
    integer :: NOMIFS                   ! Number of minor frames
d202 2
a203 3
    integer, dimension(:), pointer :: mifPointingsLower ! Result of a hunt
    integer, dimension(:), pointer :: mifPointingsUpper ! mifPointingsLower+1
    integer, dimension(:), pointer :: ptanOrder ! Ordering for ptan
d205 1
a205 1
    logical, dimension(:), pointer :: doChannel ! Do this channel?
d217 4
a220 6
    real (r8), dimension(:), pointer :: lowerWeight ! For interpolation
    real (r8), dimension(:), pointer :: upperWeight ! For interpolation
    real (r8), dimension(:), pointer :: tangentTemperature ! For optical depth
    real (r8), dimension(:), pointer :: thisFraction ! Sideband fraction values
    real (r8), dimension(:), pointer :: deltaPtan ! Change of ptan between x and supplied xStar
    real (r8), dimension(:), pointer :: sortedPtan ! supplied ptan in ascending order
d223 2
a224 2
    real (r8), dimension(:,:), pointer :: resultMapped ! Remapped values of result
    real (r8), dimension(:,:), pointer :: dyByDX ! Raw dRad/dPtan
a226 5
    real (r8), dimension(:,:), pointer :: dYStarByDPtan ! Remapped values of l2pc
    real (r8), dimension(:,:), pointer :: sortedDYStarByDPtan ! Remapped values of l2pc
    real (r8), dimension(:,:), pointer :: yStarMapped ! Remapped values of l2pc
    real (r8), dimension(:,:), pointer :: sortedYStarMapped ! Remapped values of l2pc
    real (r8), dimension(:,:), pointer :: dummy ! Workspace
d231 1
a231 1
    type(Signal_T) :: signal            ! A signal
a236 1
    type(VectorValue_T), pointer :: RADIANCE ! The radiance quantity to fill
a246 1
    type(VectorValue_T), pointer :: THISYSTARQ ! Quantitiy from supplied YStar vector
d257 1
a257 5
    nullify ( yPmapped, resultMapped, dyByDX )
    nullify ( dense, mifPointingsLower, mifPointingsUpper )
    nullify ( lowerWeight, upperWeight )
    nullify ( thisFraction, doChannel )
    nullify ( tangentTemperature )
d259 1
a259 45
    if ( size ( fmConf%signals ) /= 1 ) call MLSMessage ( &
      & MLSMSG_Error, ModuleName, &
      & 'Can only have one signal for linearized models')

    signal = fmConf%signals(1)
    ! Probably access the sideband associated with the signal ...
    sideband = signal%sideband
    ! ... but in certain rare circumstances (when we're called by the hybrid model)
    ! we might want to force the folded one.
    if ( fmConf%forceFoldedOutput ) sideband = 0
    radiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal=signal%index, sideband=sideband, noError=.true. )

    ! Now, it's possible we're really being asked to deal with optical depth, not
    ! radiance.
    if ( .not. associated ( radiance ) ) then
      radiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_opticalDepth, &
        & signal=signal%index, sideband=sideband, noError=.true. )
    end if

    ! Now, some possible error messages
    if ( .not. associated ( radiance ) ) call MLSMessage ( &
      & MLSMSG_Error, ModuleName, &
      & 'Unable to find a radiance or optical depth quantity for this signal' )
    if ( radiance%template%quantityType == l_opticalDepth ) then
      if ( present(jacobian)  ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to ask for derivatives for optical depth' )
      if ( fmConf%xStar /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to supply x/yStar for optical depth' )
      if  ( sideband /= 0 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Not appropriate to request optical depth from unfolded signal' )
    end if
    if ( fmConf%xStar /= 0 .and. .not. present(vectors) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'x/yStar supplied by vectors database argument not present' )

    ! Set some dimensions
    noChans = radiance%template%noChans
    noMIFs = radiance%template%noSurfs

    call allocate_test ( thisFraction, noChans, 'thisFraction', ModuleName )
    call allocate_test ( doChannel, noChans, 'doChannel', ModuleName )
a287 12
    ! Now, if we need any derivatives, we need to setup some arrays
    if ( present(jacobian) ) then
      call allocate_test ( mifPointingsLower, noMIFs, &
        & 'mifPointingsLower', ModuleName )
      call allocate_test ( mifPointingsUpper, noMIFs, &
        & 'mifPointingsUpper', ModuleName )
      call allocate_test ( lowerWeight, noMIFs, &
        & 'lowerWeight', ModuleName )
      call allocate_test ( upperWeight, noMIFs, &
        & 'upperWeight', ModuleName )
    end if

d401 1
a401 1
        ! OK, we're legit, lets get going.
a571 4
      call allocate_test( resultMapped, radiance%template%noSurfs, &
        & noChans, 'resultMapped', ModuleName )
      call allocate_test( dyByDx, radiance%template%noSurfs, &
        & noChans, 'dyByDX', ModuleName )
a651 2
        call Allocate_test ( tangentTemperature, noMIFs, &
          & 'tangentTemperature', ModuleName )
a671 2
      call Deallocate_test ( dyByDx, 'dyByDx', ModuleName)
      call Deallocate_test ( resultMapped, 'resultMapped', ModuleName )
d679 24
a702 12
    if ( fmConf%yStar /= 0 ) then
      ! Setup arrays etc.
      nullify ( deltaPtan, dummy, dyStarByDPtan, ptanOrder, sortedPtan, sorteddYStarByDPtan, &
        & sortedyStarMapped, yStarMapped )
      call Allocate_test ( deltaPtan, noMIFs, 'deltaPtan', ModuleName )
      call Allocate_test ( dummy, noMIFs, noChans, 'dummy', ModuleName )
      call Allocate_test ( dyStarByDptan, noMIFs, noChans, 'dyStarByDPtan', ModuleName )
      call Allocate_test ( ptanOrder, noMIFs, 'ptanOrder', ModuleName )
      call Allocate_test ( sortedPtan, noMIFs, 'sortedPtan', ModuleName )
      call Allocate_test ( sorteddyStarByDptan, noMIFs, noChans, 'sorteddyStarByDPtan', ModuleName )
      call Allocate_test ( sortedyStarMapped, noMIFs, noChans, 'sortedyStarMapped', ModuleName )
      call Allocate_test ( yStarMapped, noMIFs, noChans, 'yStarMapped', ModuleName )
d705 2
a706 2
      thisYStarQ => GetVectorQuantityByType ( vectors(fmConf%yStar), quantityType=l_radiance, &
        & signal=signal%index, sideband=signal%sideband )
d768 1
a768 22
      ! Extra tidying up in the supplied xStar/yStar case
      call Deallocate_test ( deltaPtan, 'deltaPtan', ModuleName )
      call Deallocate_test ( dummy, 'dummy', ModuleName )
      call Deallocate_test ( dyStarByDptan, 'dyStarByDPtan', ModuleName )
      call Deallocate_test ( ptanOrder, 'ptanOrder', ModuleName )
      call Deallocate_test ( sortedPtan, 'sortedPtan', ModuleName )
      call Deallocate_test ( sorteddyStarByDptan, 'sorteddyStarByDPtan', ModuleName )
      call Deallocate_test ( sortedyStarMapped, 'sortedyStarMapped', ModuleName )
      call Deallocate_test ( yStarMapped, 'yStarMapped', ModuleName )
    end if

    if ( present (jacobian) ) then         ! Destroy working arrays
      call deallocate_test ( mifPointingsLower, 'mifPointingsLower', ModuleName )
      call deallocate_test ( mifPointingsUpper, 'mifPointingsUpper', ModuleName )
      call deallocate_test ( lowerWeight, 'lowerWeight', ModuleName )
      call deallocate_test ( upperWeight, 'upperWeight', ModuleName )
    end if

    if ( toggle(emit) ) call trace_end ( 'LinearizedForwardModel' )

  contains
    ! ======================================== Internal procedures =====
d770 1
a770 1
    ! ------------------------------------------ FindMatchForL2PCQ ---
a894 1
      integer :: STATUS                 ! Flag
d901 2
a902 2
      logical, dimension(:,:), pointer :: POSSIBLE ! Flags for each bin
      real(r8), dimension(:), pointer :: COST ! Cost of each bin
d915 3
a917 6
        if ( .not. associated ( lockedBins ) ) then
          allocate ( lockedBins ( -1:1, size(signals) ), STAT=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Allocate//'lockedBins' )
          lockedBins = 0
        end if
a934 5
      nullify ( possible, cost )
      allocate ( possible ( -1:1, nobins ), STAT=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'possible' )
      call Allocate_test ( cost, noBins, 'cost', ModuleName )
a1110 4
      ! Tidy up
      call Deallocate_test ( cost, 'cost', ModuleName )
      deallocate ( possible )

d1113 1
a1113 1
  end subroutine LinearizedForwardModel
d1118 1
a1118 1
       "$Id: LinearizedForwardModel_m.f90,v 2.63 2007/04/03 17:45:10 vsnyder Exp $"
d1127 3
@


2.63
log
@Add target attribute to FwdModelIn and FwdModelExtra, replace pointer
attribute on Vectors with Target attribute.
@
text
@d45 1
a45 1
    & FwdModelOut, Ifm, fmStat, Jacobian, vectors )
d50 1
a50 2
    use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T, &
      & FORWARDMODELINTERMEDIATE_T
a86 1
    type(forwardModelIntermediate_T), intent(inout) :: IFM ! Workspace
d1140 1
a1140 1
       "$Id: LinearizedForwardModel_m.f90,v 2.62 2006/07/19 22:33:02 vsnyder Exp $"
d1149 4
@


2.62
log
@Cannonball polishing
@
text
@d83 4
a86 2
    type(vector_T), intent(in) ::  FWDMODELIN
    type(vector_T), intent(in) ::  FWDMODELEXTRA
d91 1
a91 1
    type(vector_t), dimension(:), pointer, optional :: VECTORS ! Vectors database
d779 1
a779 1
    ! ======================================== Internal procudures =====
d1142 1
a1142 1
       "$Id: LinearizedForwardModel_m.f90,v 2.61 2006/06/19 15:53:35 livesey Exp $"
d1151 3
@


2.61
log
@My first 'bug fix' was a mistake
@
text
@d53 1
a53 2
    use Intrinsic, only: LIT_INDICES
    use Intrinsic, only: L_NONE, L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
d56 1
a56 1
    use L2PC_m, only: L2PCDATABASE, BINSELECTORS, POPULATEL2PCBIN
d66 1
a66 1
      & MLSMSG_Allocate, MLSMSG_Deallocate, MLSMSG_WARNING
d75 1
a75 1
      & CLONEVECTOR, CONSTRUCTVECTORTEMPLATE, COPYVECTOR, CREATEVECTOR,&
d77 1
a77 1
      & VECTORVALUE_T, VECTORTEMPLATE_T, DUMP, &
a129 1
    real (r8) :: BESTCOST               ! Output from SelectL2PCBin
d181 7
a187 1
    if ( toggle(emit) ) call trace_begin ( 'LinearizedForwardModel' )
a194 8
    ! Identify the band/maf we're looking for

    maf = fmStat%maf

    if ( toggle(emit) .and. levels(emit) > 0 ) then
      call output ( 'Linear model doing maf: ' )
      call output ( maf, advance='yes' )
    end if
d1140 1
a1140 1
       "$Id: LinearizedForwardModel_m.f90,v 2.60 2006/06/16 23:41:57 livesey Exp $"
d1149 3
@


2.60
log
@Bug fix, if called twice on same band species derivatives doubled rather
than rewritten
@
text
@d507 9
a515 12
                    if ( sideband == sidebandStart ) then
                      jBlock%values ( i , : ) = &
                        &   thisFraction(chan) * ( &
                        &     lowerWeight(mif) * kBit( lower, : ) + &
                        &     upperWeight(mif) * kBit( upper, : ) )
                    else
                      jBlock%values ( i , : ) = &
                        & jBlock%values ( i , : ) + &
                        &   thisFraction(chan) * ( &
                        &     lowerWeight(mif) * kBit( lower, : ) + &
                        &     upperWeight(mif) * kBit( upper, : ) )
                    end if
d1144 1
a1144 1
       "$Id: LinearizedForwardModel_m.f90,v 2.59 2006/06/15 17:40:33 pwagner Exp $"
d1153 4
@


2.59
log
@Stops with err instead of continuing with warning if xStar qty not in statevectors
@
text
@d507 12
a518 5
                    jBlock%values ( i , : ) = &
                      & jBlock%values ( i , : ) + &
                      &   thisFraction(chan) * ( &
                      &     lowerWeight(mif) * kBit( lower, : ) + &
                      &     upperWeight(mif) * kBit( upper, : ) )
d1147 1
a1147 1
       "$Id: LinearizedForwardModel_m.f90,v 2.58 2005/06/30 22:42:34 livesey Exp $"
d1156 3
@


2.58
log
@Bug fix for split sideband case
@
text
@d385 1
a385 1
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
d1140 1
a1140 1
       "$Id: LinearizedForwardModel_m.f90,v 2.57 2005/06/22 18:08:19 pwagner Exp $"
d1149 3
@


2.57
log
@Reworded Copyright statement, moved rcs id
@
text
@d26 1
a26 1
       "$RCSfile: $"
d257 2
a258 1
        & quantityType = l_limbSidebandFraction, signal=signal%index, noError=.true. )
d1140 1
a1140 1
       "$Id: $"
d1149 3
@


2.56
log
@Reorganization of representation for molecules and beta groups
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d24 3
a26 6
  !------------------------------- RCS Ident Info ------------------------------
  character(len=*), parameter :: IdParm = & 
    "$Id: LinearizedForwardModel_m.f90,v 2.55 2004/08/06 01:09:49 livesey Exp $"
  character(len=len(idParm)) :: Id = idParm
  character(len=*), parameter :: ModuleName = &
    & "$RCSfile: LinearizedForwardModel_m.f90,v $"
d28 1
a28 1
  !-----------------------------------------------------------------------------
d1137 5
d1148 3
@


2.55
log
@Updated to fix Van's new definition of fmConf%molecules
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.54 2004/07/07 19:42:11 vsnyder Exp $"
d404 1
a404 1
            & pack(fmConf%molecules(1:size(fmConf%molecules)-1), fmConf%moleculeDerivatives))) &
d1138 3
@


2.54
log
@Use new Init argument of CreateBlock
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.53 2004/02/07 00:45:36 livesey Exp $"
d404 1
a404 1
            & pack(fmConf%molecules, fmConf%moleculeDerivatives))) &
d1138 3
@


2.53
log
@Fixed a bug in the sideband handling.  Was overzelous yesterday.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.52 2004/02/05 23:30:39 livesey Exp $"
d483 1
a483 2
                  & M_Full )
                jBlock%values = 0.0_rm
d605 1
a605 2
            & noMIFs*noChans, bandHeight=noChans )
          jBlock%values = 0.0_rm
d1138 3
@


2.52
log
@Fixed long standing problem with single sideband radiometers.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.51 2003/11/01 18:44:39 livesey Exp $"
d247 4
a250 2
    ! sideband information
    if ( signal%sideband == 0 .or. fmConf%forceSidebandFraction ) then
d284 3
a286 1
      if ( signal%sideband == 0 .and. .not. fmConf%forceSidebandFraction ) then !????
d1140 3
@


2.51
log
@Bug fixes in bin selection
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.50 2003/10/29 00:44:53 livesey Exp $"
d248 1
a248 3
    if ( sidebandStart /= sidebandStop .or. fmConf%forceSidebandFraction ) then 
      ! Change to this if statement later !????
      ! if ( signal%sideband == 0 .or. fmConf%forceSidebandFraction ) then
d282 1
a282 3
      if ( sidebandStart /= sidebandStop .or. fmConf%forceSidebandFraction ) then   ! We're folding
        ! Change to this if statement later
        ! if ( signal%sideband == 0 .and. .not. fmConf%forceSidebandFraction ) then !????
d1136 3
@


2.50
log
@Bug fix in forceSidebandFraction handling
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.49 2003/10/28 23:44:15 livesey Exp $"
d973 1
d979 2
a980 2
            call get_string ( l2pcDatabase(bin)%name, binName, strip=.true. )
            call get_string ( sel%nameFragment, nameFragment, strip=.true. )
d982 2
a983 1
              possible ( :, bin ) = index ( trim(binName), trim(nameFragment) ) /= 0
d992 2
a993 1
              possible ( :, bin ) = EssentiallyEqual ( thisCost, 0.0_r8 )
d1003 2
a1004 1
              possible ( :, bin ) = EssentiallyEqual ( thisCost, 0.0_r8 )
d1055 2
a1056 1
                  possible ( :, bin ) = EssentiallyEqual ( thisCost, 0.0_r8 )
d1140 3
@


2.49
log
@Various changes involved in adding the forceFoldedOutput option to
support the hybrid model.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.48 2003/10/09 22:17:10 livesey Exp $"
d284 1
a284 1
      if ( sidebandStart /= sidebandStop ) then   ! We're folding
d1135 4
@


2.48
log
@Various bug fixes, and added the call to CheckForSimpleBandedLayout
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.47 2003/09/15 17:42:52 livesey Exp $"
d199 5
d205 1
a205 1
      & signal=signal%index, sideband=signal%sideband, noError=.true. )
d211 1
a211 1
        & signal=signal%index, sideband=signal%sideband, noError=.true. )
d225 1
a225 1
      if  ( signal%sideband /= 0 ) &
d243 1
a243 1
    call SelectL2PCBins ( radiance, maf, l2pcBins, &
d868 1
a868 1
    subroutine SelectL2PCBins ( radiance, maf, l2pcBins, &
d877 1
d883 2
a896 1
      integer :: SIDEBAND               ! This sideband
d901 1
a916 1
      sideband = radiance%template%sideband
d1103 5
a1107 5
        do sideband = sidebandStart, sidebandStop
          if ( possible(sideband,bin) .and. &
            & cost(bin) < bestCost(sideband) ) then
            bestCost(sideband) = cost(bin)
            l2pcBins(sideband) = bin
d1135 3
@


2.47
log
@Various bug fixes associated with getting the polar linear model
working.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.46 2003/09/11 23:10:32 livesey Exp $"
d56 1
a56 1
      & MATRIXELEMENT_T, CREATEBLOCK, DENSIFY
d213 11
a223 8
    if ( radiance%template%quantityType == l_opticalDepth .and. &
      & present(jacobian)  ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Not appropriate to ask for derivatives for optical depth' )
    if ( radiance%template%quantityType == l_opticalDepth .and. &
      & fmConf%xStar /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Not appropriate to supply x/yStar for optical depth' )
d604 1
d1008 41
a1048 37
            if ( .not. ValidateVectorQuantity ( l2pcQ,&
              & verticalCoordinate = (/ l_zeta /) ) ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Expected zeta coordinate for quantity in binSelector' )
            ! Find the relevant corresponding quantity in the state vector
            call FindMatchForL2PCQ ( l2pcQ, fmConf, fwdModelIn, &
              & fwdModelExtra, stateQ, foundInFirst )
            ! If we've got both of them make sure they match
            if ( associated(stateQ) .and. associated(l2pcQ) ) then
              ! OK, identify height range
              if ( all ( binSelectors(selector)%heightRange > 0.0 ) ) then
                s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                  & log10(binSelectors(selector)%heightRange(1) ) ) )
                s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                  & log10(binSelectors(selector)%heightRange(2) ) ) )
              else
                s1 = 1
                s2 = stateQ%template%noSurfs
              end if
              ! Here we'll just compare the central profile in the
              ! l2pc with the state profile closest to each maf.
              l2pcInstance = l2pcQ%template%noInstances/2 + 1
              thisCost = 0.0_r8
              do myMaf = maf1, mafN
                ! Only compare the closest profile to the maf
                stateInstance = FindOneClosestInstance ( stateQ, radiance, myMaf )
                thisCost = thisCost + sum ( &
                  & ( stateQ%values ( s1(1):s2(1), stateInstance ) - &
                  &   l2pcQ%values  ( s1(1):s2(1), l2pcInstance  ) ) **2 )
              end do
              ! If we require an exact match set the possible flag,
              ! otherwise just report our cost.
              if ( sel%exact ) then
                possible ( :, bin ) = EssentiallyEqual ( thisCost, 0.0_r8 )
              else
                cost ( bin ) = cost ( bin ) + sqrt ( thisCost / &
                  &  ( ( s2(1)-s1(1)+1 ) * ( mafN - maf1 + 1 ) ) ) / sel%cost
d1128 4
@


2.46
log
@Added option to linearize around pre-computed state/radiances instead of
those in the l2pc file.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.45 2003/08/20 20:07:22 livesey Exp $"
d785 3
d822 5
d828 1
a828 2
        ! For the moment, just ignore things we don't understand.
        stateQ => NULL()
d1014 9
a1022 4
              s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                & log10(binSelectors(selector)%heightRange(1) ) ) )
              s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                & log10(binSelectors(selector)%heightRange(2) ) ) )
d1120 4
@


2.45
log
@Bug fix in ptan derivatives (not actually a problem yet but would have
become one).  Also, more commented out if statements for the single
sideband case, and some cosmetic changes.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.44 2003/08/14 20:24:08 livesey Exp $"
d40 1
a40 1
    & FwdModelOut, Ifm, fmStat, Jacobian )
d74 2
a75 1
      & VALIDATEVECTORQUANTITY, M_LINALG
d85 1
d122 1
d141 2
d149 5
d174 2
d206 1
a206 1
      & signal=signal%index, sideband=signal%sideband, noError=.true. )
d217 7
d328 1
a328 1
        
d340 1
a340 1
        
d422 1
a422 1
          
d426 13
a438 3
          ! Fill this part of xP
          xP%quantities(qtyInd)%values(:,xStarInstance) = &
            & stateQ%values(:,xInstance)
d484 1
a484 1
              !$OMP PARALLEL DO private ( i, lower, upper, chan, doElement )
d505 1
a505 1
              !$OMP END PARALLEL DO
d515 9
a523 3
        deltaX%quantities(qtyInd)%values = &
          & xP%quantities(qtyInd)%values - &
          & l2pc%col%vec%quantities(qtyInd)%values
d544 3
a546 1
      yP = yP + l2pc%row%vec
d569 10
a578 3
      if ( sidebandStart == sidebandStop ) then
        radiance%values(:,maf) = reshape(transpose(resultMapped),&
          & (/radiance%template%instanceLen/))
d580 11
a590 23
        ! Either place or add, make decision outside loop!
        if ( sideband == sidebandStart ) then
          do chan = 1, noChans
            if ( doChannel ( chan ) ) then
              do mif = 1, noMIFs
                radiance%values( chan + (mif-1)*noChans, maf ) = &
                  & thisFraction(chan)*resultMapped ( mif, chan )
              end do
            end if
          end do
        else
          do chan = 1, noChans
            if ( doChannel ( chan ) ) then
              do mif = 1, noMIFs
                radiance%values( chan + (mif-1)*noChans, maf ) = &
                  & radiance%values( chan + (mif-1)*noChans, maf ) + &
                  &   thisFraction(chan)*resultMapped ( mif, chan )
              end do
            end if
          end do
        end if
      end if                            ! Doing folded
        
d592 3
a594 3
      if ( present( Jacobian ) .and. ptanInFirst ) then
        colJBlock = FindBlock ( Jacobian%col, ptan%index, maf )
        jBlock => Jacobian%block( rowJBlock, colJBlock )
d597 1
a597 1
          call CreateBlock ( Jacobian, rowJBlock, colJBlock, m_banded, &
d605 3
a607 4
        
        if ( sidebandStart == sidebandStop ) then
          ! Change to this if statement later !????
          ! if ( signal%sideband == 0 ) then
d613 15
a627 27
              end do                  ! Minor frames
            end if                     ! Doing this channel
          end do                       ! Channels
        else
          ! Either place or add, make decision outside loop!
          if ( sideband == sidebandStart ) then
            do chan = 1, noChans
              if ( doChannel ( chan ) ) then
                do mif = 1, noMIFs
                  jBlock%values( chan + (mif-1)*noChans, 1 ) = &
                    & thisFraction(chan) * dyByDx ( mif, chan )
                end do                  ! Minor frames
              end if                     ! Doing this channel
            end do                       ! Channels
          else                          ! Must be doing second sideband
            do chan = 1, noChans
              if ( doChannel ( chan ) ) then
                do mif = 1, noMIFs
                  jBlock%values( chan + (mif-1)*noChans, : ) = &
                    & jBlock%values ( chan + (mif-1)*noChans, : ) + &
                    &   thisFraction(chan) * dyByDx ( mif, chan )
                end do                  ! Minor frames
              end if                    ! Doing this channel
            end do                      ! Channel
          end if                        ! First/second sideband
        end if                          ! Folding
      end if                            ! Want ptan derivatives
d653 1
a653 1
      
d663 91
d763 1
a763 1
    contains
d1108 5
@


2.44
log
@Added the exact bin criterion
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.43 2003/08/13 00:48:23 livesey Exp $"
d233 2
a234 1
        & ( associated ( lowerSidebandFraction) .and. associated ( upperSidebandFraction ) ) ) &
d258 2
d575 2
d581 1
a581 1
                  & dyByDx ( mif, chan )
d604 2
a605 2
              end if                     ! Doing this channel
            end do                       ! Channel
d813 1
a813 1
      ! Setup the arrays we need possible is a flag to indicate (for
a842 4

      ! We have a bit of a hack here to ensure that in the absence of any
      ! other information, it will choose the closest latitude one (the
      ! previous behavior)
a843 1

d877 1
a877 1
            ! This one involves matching elements of xStart with x.
d912 2
d998 3
@


2.43
log
@Removed the faking of binSelectors, forwardModelSupport now ensures
there's always one to hand.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.42 2003/07/15 22:10:38 livesey Exp $"
d743 1
a845 1
        ! This is a bit of a hack, but if there
d857 1
a857 1
            cost(bin) = sqrt ( sum ( &
d861 5
d867 1
a867 1
            cost(bin) = sqrt ( sum ( &
d871 5
d877 1
d912 6
a917 2
              cost ( bin ) = cost ( bin ) + sqrt ( thisCost / &
                &  ( ( s2(1)-s1(1)+1 ) * ( mafN - maf1 + 1 ) ) ) / sel%cost
d996 4
@


2.42
log
@Added support for hybrid model
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.41 2003/07/09 20:16:26 livesey Exp $"
d50 2
a51 1
      & L_LIMBSIDEBANDFRACTION, L_ZETA, L_OPTICALDEPTH, L_LATITUDE
a767 1
      logical :: FAKESELECTORS          ! No selectors, so fake one
d841 1
a841 13
      fakeSelectors = .true.
      noSelectors = 1
      if ( associated ( fmConf%binSelectors ) ) then
        noSelectors = size ( fmConf%binSelectors )
        fakeSelectors = noSelectors == 0
      end if
      if ( fakeSelectors ) then
        allocate ( sel, STAT=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'sel' )
        sel%selectorType = l_latitude
        sel%cost = 1.0
      end if
d847 1
a847 2
          if ( .not. fakeSelectors ) &
            & sel => binSelectors ( fmConf%binSelectors(selector) )
d866 2
a867 8
          case ( l_temperature, l_vmr )
            ! This one requires more thought, I'll do it later
            select case ( sel%selectorType )
            case ( l_temperature )
              l2pcQ => GetVectorQuantityByType ( &
                & l2pcDatabase(bin)%col%vec, quantityType=l_temperature, &
                & noError=.true. )
            case ( l_vmr )
d871 5
a875 1
            end select
a907 6
      if ( fakeSelectors ) then
        deallocate ( sel, STAT=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'sel' )
      end if

d981 3
@


2.41
log
@Anticipative bug fix in sideband stuff (not really used so far)
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.40 2003/05/29 16:37:45 livesey Exp $"
d76 1
a76 1
    type(forwardModelConfig_T), intent(inout) :: fmConf
d220 1
a220 1
    if ( sidebandStart /= sidebandStop ) then 
d222 1
a222 1
      ! if ( signal%sideband == 0 ) then
d1002 3
@


2.40
log
@Renamed sideband fraction
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.39 2003/02/22 00:40:22 livesey Exp $"
d221 2
d1002 3
@


2.39
log
@Now can use OpenMP
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.38 2003/02/17 00:33:41 livesey Exp $"
d50 1
a50 1
      & L_SIDEBANDRATIO, L_ZETA, L_OPTICALDEPTH, L_LATITUDE
d136 1
a136 1
    real (r8), dimension(:), pointer :: thisRatio ! Sideband ratio values
d160 3
a162 3
    type(VectorValue_T), pointer :: SIDEBANDRATIO ! From the state vector
    type(VectorValue_T), pointer :: LOWERSIDEBANDRATIO ! From the state vector
    type(VectorValue_T), pointer :: UPPERSIDEBANDRATIO ! From the state vector
d170 1
a170 1
    nullify ( thisRatio, doChannel )
d209 1
a209 1
    call allocate_test ( thisRatio, noChans, 'thisRatio', ModuleName )
d221 4
a224 4
      sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, noError=.true. )
      lowerSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, &
d226 2
a227 2
      upperSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, &
d229 2
a230 2
      if (.not. associated (sidebandRatio) .and. .not. &
        & ( associated ( lowerSidebandRatio) .and. associated ( upperSidebandRatio ) ) ) &
d232 1
a232 1
        & "No sideband ratio supplied")
d252 1
a252 1
      ! Setup a sideband ratio array
d254 3
a256 3
        if ( associated ( sidebandRatio ) ) then
          thisRatio = sidebandRatio%values(:,1)
          if ( sideband == 1 ) thisRatio = 1.0 - thisRatio
d259 1
a259 1
            thisRatio = lowerSidebandRatio%values(:,1)
d261 1
a261 1
            thisRatio = upperSidebandRatio%values(:,1)
d265 1
a265 1
        thisRatio = 1.0
d461 1
a461 1
                      &   thisRatio(chan) * ( &
d536 1
a536 1
                  & thisRatio(chan)*resultMapped ( mif, chan )
d546 1
a546 1
                  &   thisRatio(chan)*resultMapped ( mif, chan )
d584 1
a584 1
                    & thisRatio(chan) * dyByDx ( mif, chan )
d594 1
a594 1
                    &   thisRatio(chan) * dyByDx ( mif, chan )
d1000 3
@


2.38
log
@Added deallocation of possible/cost to fix memory leak.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.37 2003/02/06 01:13:28 livesey Exp $"
d449 1
a449 1
              i = 1
d451 1
d454 15
a468 15
                  do chan = 1, noChans
                    doElement = doChannel(chan)
                    if ( doElement .and. associated ( radiance%mask ) ) &
                      & doElement = iand ( ichar ( radiance%mask(i,maf)), m_linAlg ) == 0
                    if ( doElement ) then
                      jBlock%values ( i , : ) = &
                        & jBlock%values ( i , : ) + &
                        &   thisRatio(chan) * ( &
                        &     lowerWeight(mif) * kBit( lower, : ) + &
                        &     upperWeight(mif) * kBit( upper, : ) )
                    end if
                    i = i + 1
                    lower = lower + 1
                    upper = upper + 1
                  end do
d470 1
d1000 3
@


2.37
log
@Added the dump stuff
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.36 2003/02/06 00:46:03 livesey Exp $"
d983 4
d998 3
@


2.36
log
@New SelectL2PCBins routine.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.35 2003/02/05 21:58:31 livesey Exp $"
d59 1
a59 1
    use MLSSignals_m, only: Signal_T, GetSidebandLoop
d737 1
d925 14
d994 3
@


2.35
log
@Just a tidy up in preparation for the new bin selectors stuff
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.34 2003/01/29 22:43:25 livesey Exp $"
d39 1
a39 1
  subroutine LinearizedForwardModel ( ForwardModelConfigData, FwdModelIn, FwdModelExtra,&
d76 1
a76 1
    type(forwardModelConfig_T), intent(inout) :: ForwardModelConfigData
d181 1
a181 1
    if ( size ( forwardModelConfigData%signals ) /= 1 ) call MLSMessage ( &
d185 1
a185 1
    signal = forwardModelConfigData%signals(1)
d215 1
a215 1
    call SelectL2PCBins ( radiance, maf, forwardModelConfigData, l2pcBins, &
d322 1
a322 1
          if (.not. associated(forwardModelConfigData%molecules) ) cycle
d324 1
a324 1
            &   forwardModelConfigData%molecules)) cycle
d330 1
a330 1
        call FindMatchForL2PCQ ( l2pcQ, fwdModelIn, fwdModelExtra, &
d365 1
a365 1
          & doDerivatives = forwardModelConfigData%temp_der
d368 2
a369 2
          & associated(forwardModelConfigData%molecules) ) then
          doDerivatives = forwardModelConfigData%atmos_der
d371 1
a371 2
            & pack(ForwardModelConfigData%molecules, &
            &      ForwardModelConfigData%moleculeDerivatives))) &
d379 1
a379 1
          if ( forwardModelConfigData%phiWindow == 0.0 ) then
d388 1
a388 1
              if ( deltaPhi > forwardModelConfigData%phiWindow ) then
d390 1
a390 1
              else if ( deltaPhi < -forwardModelConfigData%phiWindow ) then
d604 1
a604 1
          & quantityType=l_temperature, config=ForwardModelConfigData )
d647 1
a647 1
    subroutine FindMatchForL2PCQ ( l2pcQ, FwdModelIn, FwdModelExtra, &
d650 1
d668 1
a668 1
          & quantityType=l_temperature, config=ForwardModelConfigData, &
d674 1
a674 1
            & quantityType = l_vmr, config=ForwardModelConfigData, &
d732 1
a732 1
    subroutine SelectL2PCBins ( radiance, maf, fmConf, l2pcBins, &
d735 2
a739 1
      type (ForwardModelConfig_T), intent(in) :: FMCONF ! The forwardmodel configuration
d749 21
a769 13
      integer :: BIN                      ! Loop counter
      integer :: MAF1                     ! Subset limit
      integer :: MAFN                     ! Subset limit
      integer :: NOBINS                   ! Number of l2pc bins
      integer :: SIDEBAND                 ! This sideband
      integer :: SIGNAL                   ! Signal index
      integer :: STATUS                   ! Flag
      logical :: SPLIT                    ! Need a split calculation

      logical, dimension(:), pointer :: NAMEMATCHES ! Flags for each bin
      real(r8), dimension(:), pointer :: DELTAPHI ! How far are we away in phi
      real(r8), dimension(-1:1) :: BESTCOST ! Best cost for this sideband
      logical, dimension(:,:), pointer :: SIDEBANDSMATCH ! Flags for each bin/sideband
d771 1
d774 1
a774 1
      
d799 2
a800 2
      ! Code will only get to here if the bins are unlocked, or are
      ! locked but as yet not nailed down.
d802 5
a806 5
      ! Setup the arrays we need
      nullify ( deltaPhi, nameMatches )
      call Allocate_test ( deltaPhi, noBins, 'deltaPhi', ModuleName )
      call Allocate_test ( nameMatches, noBins, 'nameMatches', ModuleName )
      allocate ( sidebandsMatch ( -1:1, nobins ), STAT=status )
d808 2
a809 4
        & MLSMSG_Allocate//'sidebandsMatch' )
      deltaPhi = huge ( 0.0_r8 )
      nameMatches = .false.
      sidebandsMatch = .false.
d811 2
a813 1
        ! Get this radiance quantity
d815 4
d820 29
a848 2
        ! Do the sidebands match
        sidebandsMatch ( binRad%sideband, bin ) = ( binRad%signal == signal )
d850 73
a922 25
        ! Does the 'name' match
        nameMatches ( bin ) = .true.
!         if ( fmConf%nameFragment /= 0 ) then
!           call get_string ( l2pcDatabase(bin)%name, binName, strip=.true. )
!           call get_string ( fmConf%nameFragment, nameFragment, strip=.true. )
!           if ( len_trim(nameFragment) /= 0 ) then
!             nameMatches ( bin ) = index ( trim(binName), trim(nameFragment) ) /= 0
!           end if
!         end if

        ! Does the phi match.  This one is more complicated as we may
        ! have to consider it for all MAFs that are not overlapped, and
        ! then take the most 'popular' match. We'll base this on the
        ! first mif each maf.  That will probably be good enough
        if ( fmConf%lockBins ) then
          maf1 = 1 + radiance%template%noInstancesLowerOverlap
          mafN = radiance%template%noInstances - &
            & radiance%template%noInstancesUpperOverlap
        else
          maf1 = maf
          mafN = maf
        end if
        deltaPhi(bin) = sum( (NormalizePhi(radiance%template%phi(1,maf1:mafN)) - &  
          & NormalizePhi(binRad%phi(1,1)) )**2 ) / (mafN-maf1+1)
      end do                              ! End loop over Bins
d926 2
a927 2
      ! over unfolded ones, even if that means the phi is way off.  I
      ! think this is all a fairly unlikely circumstance anyway.
d931 4
a934 4
        if ( any ( sidebandsMatch(0,:) ) ) then
          where ( sidebandsMatch(0,:) ) 
            sidebandsMatch(-1,:) = .false.
            sidebandsMatch(1,:) = .false.
d946 2
a947 2
      bestCost = huge ( deltaPhi(1) )
      l2pcBins = (/ 0, 0, 0 /)
d952 3
a954 3
          if ( sidebandsMatch(sideband,bin) .and. nameMatches(bin) .and. &
            & deltaPhi(bin) < bestCost(sideband) ) then
            bestCost(sideband) = deltaPhi(bin)
d979 3
@


2.34
log
@More intelligent setting of rows flags.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.33 2003/01/08 23:50:15 livesey Exp $"
d764 2
a765 2

      ! If we're in locked bins mode, then just return the locked bin
d811 8
a818 12
        if ( fmConf%nameFragment /= 0 ) then
          call get_string ( l2pcDatabase(bin)%name, binName, strip=.true. )
          call get_string ( fmConf%nameFragment, nameFragment, strip=.true. )
          if ( len_trim(nameFragment) /= 0 ) then
            if ( index ( trim(binName), trim(nameFragment) ) /= 0 ) &
              & nameMatches ( bin ) = .true.
          else
            nameMatches ( bin ) = .true.
          end if
        else
          nameMatches ( bin ) = .true.
        end if
d891 3
@


2.33
log
@Now doesn't bother to create derivatives for masked radiances
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.32 2002/12/16 15:31:57 mjf Exp $"
d409 4
a412 1
          ! Interpolate kStart to K if required.
a413 1
            fmStat%rows(rowJBlock) = .true.
d895 3
@


2.32
log
@Use GetQuantityForForwardModel instead of GetVectorQuantityByType.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.31 2002/11/14 17:54:06 livesey Exp $"
d73 1
a73 1
      & VALIDATEVECTORQUANTITY
d112 1
d453 4
a456 1
                    if ( doChannel(chan) ) then
d893 3
@


2.31
log
@Changed 'no quantity found' warning message to work better.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.30 2002/11/14 17:46:08 livesey Exp $"
d47 1
d598 2
a599 2
        temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_temperature )
d661 2
a662 2
        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
          & quantityType = l_temperature, &
d667 2
a668 2
          stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
            & quantityType = l_vmr, &
d889 3
@


2.30
log
@Bypassed a warning message that was starting to irritate me.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.29 2002/10/08 17:08:05 pwagner Exp $"
d109 1
d312 2
a313 2
      do qtyInd = 1, size ( l2pc%col%vec%quantities )

d331 2
a332 1
        ! If it's not in the state vector, perhaps make a fuss
d334 14
a347 14
          ! I'm commenting out the 'make a fuss' code, as it can't
          ! distinguish between tropH2O and H2O.
          ! One could be clever and see if the l2pc actually has some derivatives
          ! for this quantity, but I'll postpone that level of complexity for the moment.
          
!           if ( any(l2pcQ%template%quantityType == &
!             & (/ l_temperature, l_vmr /)) .and. &
!             & l2pcQ%template%molecule /= l_extinction ) then
!             call get_string ( l2pcQ%template%name, word, strip=.true. )
!             call MLSMessage ( MLSMSG_Warning, ModuleName, &
!               &  "No quantity in state vectors found to match "//trim(word) )
!           end if

          cycle                         ! Go to next l2pc quantity
d476 1
a476 1
      end do                              ! End loop over quantities
d888 3
@


2.29
log
@Added idents to survive zealous Lahey optimizer
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.28 2002/10/02 23:19:51 livesey Exp $"
d332 13
a344 7
          if ( any(l2pcQ%template%quantityType == &
            & (/ l_temperature, l_vmr /)) .and. &
            & l2pcQ%template%molecule /= l_extinction ) then
            call get_string ( l2pcQ%template%name, word, strip=.true. )
            call MLSMessage ( MLSMSG_Warning, ModuleName, &
              &  "No quantity in state vectors found to match "//trim(word) )
          end if
d886 3
@


2.28
log
@Various bug fixes associated with extinction
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.27 2002/10/02 02:42:55 livesey Exp $"
d22 1
d873 4
d880 3
@


2.27
log
@Changes to allow the new mixed extinction stuff
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.26 2002/09/13 22:53:22 vsnyder Exp $"
d321 2
d648 1
d681 1
d696 2
d875 3
@


2.26
log
@Move USE statements from module scope to procedure scope.  Cosmetic changes.
Move some loop-invariant allocate/deallocates out of loops.
@
text
@d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.25 2002/09/13 18:09:09 pwagner Exp $"
d51 1
a51 1
      & DOHGRIDSMATCH, DOVGRIDSMATCH
d59 1
a59 1
      & MLSMSG_Allocate, MLSMSG_Deallocate
d121 2
d330 6
a335 3
            & (/ l_temperature, l_vmr /))) &
            &   call MLSMessage ( MLSMSG_Error, ModuleName, &
            &  "Temperature or vmr quantity absent from state")
d633 2
a634 2
      type (Vector_T), intent(in) :: FWDMODELIN ! State vector
      type (Vector_T), intent(in) :: FWDMODELEXTRA ! Extra state vector
d641 4
d652 27
a678 10
        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
          & quantityType = l_vmr, &
          & molecule = l2pcQ%template%molecule, &
          & foundInFirst = foundInFirst, noError=.true. )
      case ( l_extinction )
  !       stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
  !         & quantityType = l_extinction, &
  !         & radiometer = l2pcQ%template%radiometer, &
  !         & foundInFirst = foundInFirst, noError=.true. )
        stateQ => NULL() ! Temporary
a681 3
  !       stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
  !         & quantityType = l2pcQ%template%quantityType, &
  !         & foundInFirst = foundInFirst, noError=.true. )
d869 4
@


2.25
log
@May change matrix precision rm from r8
@
text
@a8 32
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use Dump_0, only: DUMP
  use ForwardModelConfig, only: FORWARDMODELCONFIG_T
  use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T, &
    & FORWARDMODELINTERMEDIATE_T
  use Intrinsic, only: LIT_INDICES
  use Intrinsic, only: L_NONE, L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
    & L_SIDEBANDRATIO, L_ZETA, L_OPTICALDEPTH, L_LATITUDE
  use L2PC_m, only: L2PCDATABASE, BINSELECTORS, FLUSHL2PCBINS, POPULATEL2PCBIN
  use ManipulateVectorQuantities, only: FINDONECLOSESTINSTANCE, &
    & DOHGRIDSMATCH, DOVGRIDSMATCH
  use MatrixModule_0, only: M_ABSENT, M_BANDED, M_COLUMN_SPARSE, M_FULL, &
    & MATRIXELEMENT_T, CREATEBLOCK, DENSIFY
  use MatrixModule_1, only: MATRIX_T, MULTIPLYMATRIXVECTORNOT, DUMP, &
    & FINDBLOCK, CREATEBLOCK
  use MLSCommon, only: r8, rm
  use MLSSignals_m, only: Signal_T, GetSidebandLoop
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR, &
    & MLSMSG_Allocate, MLSMSG_Deallocate
  use MLSNumerics, only: HUNT, INTERPOLATEVALUES
  use Molecules, only: L_EXTINCTION
  use Output_m, only: Output
  use QuantityTemplates, only: QuantityTemplate_T
  use String_Table, only: Display_String, Get_String
  use Toggles, only: Emit, Levels, Toggle
  use Trace_m, only: Trace_begin, Trace_end
  use VectorsModule, only: assignment(=), OPERATOR(-), OPERATOR(+), &
    & CLONEVECTOR, CONSTRUCTVECTORTEMPLATE, COPYVECTOR, CREATEVECTOR,&
    & DESTROYVECTORINFO, GETVECTORQUANTITYBYTYPE, VECTOR_T, &
    & VECTORVALUE_T, VECTORTEMPLATE_T, DUMP, &
    & VALIDATEVECTORQUANTITY

d18 1
a18 1
    "$Id: LinearizedForwardModel_m.f90,v 2.24 2002/09/11 17:43:39 pwagner Exp $"
d26 1
a26 1
  ! ------------------------------------ FlushLockedBins
d28 3
a30 3
    ! Local variables
    integer :: STATUS ! Flag from allocate
    ! Executable code
d33 1
a33 4
    deallocate ( lockedBins, STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//"lockedBins" )
    lockedBins => NULL()
d38 1
a38 1
  subroutine LinearizedForwardModel ( ForwardModelConfig, FwdModelIn, FwdModelExtra,&
d40 33
d74 1
a74 1
    type(forwardModelConfig_T), intent(inout) :: FORWARDMODELCONFIG
a112 1
    integer, dimension(:), pointer :: closestInstances ! Of qty to radiance
d161 1
a161 1
    nullify ( yPmapped, resultMapped, dyByDX, closestInstances )
d175 1
a175 1
    if ( size ( forwardModelConfig%signals ) /= 1 ) call MLSMessage ( &
d179 1
a179 1
    signal = forwardModelConfig%signals(1)
d209 1
a209 1
    call SelectL2PCBins ( radiance, maf, forwardModelConfig, l2pcBins, &
d229 12
d280 1
a280 4
      call Allocate_test ( closestInstances, radiance%template%noInstances, &
        & 'closestInstances', ModuleName )

      ! Get the two ptans, we'll need these for interpolation
a294 9
        call allocate_test ( mifPointingsLower, noMIFs, &
          & 'mifPointingsLower', ModuleName )
        call allocate_test ( mifPointingsUpper, noMIFs, &
          & 'mifPointingsUpper', ModuleName )
        call allocate_test ( lowerWeight, noMIFs, &
          & 'lowerWeight', ModuleName )
        call allocate_test ( upperWeight, noMIFs, &
          & 'upperWeight', ModuleName )

d316 1
a316 1
          if (.not. associated(forwardModelConfig%molecules) ) cycle
d318 1
a318 1
            &   forwardModelConfig%molecules)) cycle
d347 1
a347 1
          & doDerivatives = forwardModelConfig%temp_der
d350 2
a351 2
          & associated(forwardModelConfig%molecules) ) then
          doDerivatives = forwardModelConfig%atmos_der
d353 2
a354 2
            & pack(ForwardModelConfig%molecules, &
            &      ForwardModelConfig%moleculeDerivatives))) &
d362 1
a362 1
          if ( forwardModelConfig%phiWindow == 0.0 ) then
d371 1
a371 1
              if ( deltaPhi > forwardModelConfig%phiWindow ) then
d373 1
a373 1
              else if ( deltaPhi < -forwardModelConfig%phiWindow ) then
d413 1
a413 1
              endif
d441 1
a441 1
                    endif
a461 11
      if ( present (jacobian) ) then         ! Destroy working arrays
        call deallocate_test ( mifPointingsLower, &
          & 'mifPointingsLower', ModuleName )
        call deallocate_test ( mifPointingsUpper, &
          & 'mifPointingsUpper', ModuleName )
        call deallocate_test ( lowerWeight, &
          & 'lowerWeight', ModuleName )
        call deallocate_test ( upperWeight, &
          & 'upperWeight', ModuleName )
      end if

d514 2
a515 2
            endif
          enddo
d524 2
a525 2
            endif
          enddo
d551 2
a552 2
            endif                     ! Doing this channel
          enddo                       ! Channels
d562 2
a563 2
              endif                     ! Doing this channel
            enddo                       ! Channels
d572 2
a573 2
              endif                     ! Doing this channel
            enddo                       ! Channel
a605 1
      call Deallocate_test ( closestInstances, 'closestInstances', ModuleName )
d612 7
d621 2
a622 1
  end subroutine LinearizedForwardModel
d624 11
a634 1
  ! ======================================= Private procudures
d636 32
a667 11
  ! ------------------------------------ FindMatchForL2PCQ ---
  subroutine FindMatchForL2PCQ ( l2pcQ, FwdModelIn, FwdModelExtra, &
    & stateQ, foundInFirst )
    type (VectorValue_T), intent(in) :: L2PCQ ! Quantity to search for
    type (Vector_T), intent(in) :: FWDMODELIN ! State vector
    type (Vector_T), intent(in) :: FWDMODELEXTRA ! Extra state vector
    type (VectorValue_T), pointer :: STATEQ ! Result
    logical, intent(out) :: FOUNDINFIRST ! If set, found in first vector
    ! This routine looks through the supplied state vectors and finds a match
    ! for the supplied quantity from the l2pc state vector.  It then goes on to
    ! test that the HGrids and VGrids for the two quantities match appropriately.
d669 1
a669 32
    ! Executable code
    select case ( l2pcQ%template%quantityType )
    case ( l_temperature )
      stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
        & quantityType = l_temperature, &
        & foundInFirst = foundInFirst, noError=.true. )
    case ( l_vmr )
      stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
        & quantityType = l_vmr, &
        & molecule = l2pcQ%template%molecule, &
        & foundInFirst = foundInFirst, noError=.true. )
    case ( l_extinction )
!       stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
!         & quantityType = l_extinction, &
!         & radiometer = l2pcQ%template%radiometer, &
!         & foundInFirst = foundInFirst, noError=.true. )
      stateQ => NULL() ! Temporary
    case default
      ! For the moment, just ignore things we don't understand.
      stateQ => NULL()
!       stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
!         & quantityType = l2pcQ%template%quantityType, &
!         & foundInFirst = foundInFirst, noError=.true. )
    end select

    ! Now check that these match.
    if ( associated ( stateQ ) ) then
      if ( .not. DoVGridsMatch ( stateQ, l2pcQ ) ) stateQ => NULL()
    end if
    if ( associated ( stateQ ) ) then
      if ( .not. DoHGridsMatch ( stateQ, l2pcQ, spacingOnly=.true. ) ) stateQ => NULL()
    end if
d671 14
a684 1
  end subroutine FindMatchForL2PCQ
d686 4
a689 12
  ! ------------------------------------ SelectL2PCBins -----
  subroutine SelectL2PCBins ( radiance, maf, fmConf, l2pcBins, &
    & sidebandStart, sidebandStop, sidebandStep )
    use MLSSignals_m, only: signals

    type (VectorValue_T), intent(in) :: RADIANCE ! The radiance we're after
    integer, intent(in) :: MAF                      ! MAF index
    type (ForwardModelConfig_T), intent(in) :: FMCONF ! The forwardmodel configuration
    integer, dimension(-1:1), intent(out) :: L2PCBINS ! Result
    integer, intent(out) :: SIDEBANDSTART ! Resulting loop indices
    integer, intent(out) :: SIDEBANDSTOP
    integer, intent(out) :: SIDEBANDSTEP
d691 26
a716 3
    ! Local variables
    character (len=132) :: BINNAME      ! The name of the bin
    character (len=132) :: NAMEFRAGMENT ! Fragment of name to try to match
d718 1
a718 14
    integer :: BIN                      ! Loop counter
    integer :: MAF1                     ! Subset limit
    integer :: MAFN                     ! Subset limit
    integer :: NOBINS                   ! Number of l2pc bins
    integer :: SIDEBAND                 ! This sideband
    integer :: SIGNAL                   ! Signal index
    integer :: STATUS                   ! Flag
    logical :: SPLIT                    ! Need a split calculation

    logical, dimension(:), pointer :: NAMEMATCHES ! Flags for each bin
    real(r8), dimension(:), pointer :: DELTAPHI ! How far are we away in phi
    real(r8), dimension(-1:1) :: BESTCOST ! Best cost for this sideband
    logical, dimension(:,:), pointer :: SIDEBANDSMATCH ! Flags for each bin/sideband
    type (QuantityTemplate_T), pointer :: BINRAD ! Quantity template
d720 4
a723 1
    ! Executable code
d725 17
a741 21
    ! If we're in locked bins mode, then just return the locked bin
    signal = radiance%template%signal
    sideband = radiance%template%sideband
    noBins = size ( l2pcDatabase )

    ! Now special code for dealing with the locked bins case
    if ( fmConf%lockBins ) then
      if ( .not. associated ( lockedBins ) ) then
        allocate ( lockedBins ( -1:1, size(signals) ), STAT=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'lockedBins' )
        lockedBins = 0
      end if
      if ( any ( lockedBins ( :, signal ) /= 0 ) ) then
        l2pcBins = lockedBins ( :, signal )
        ! If got folded, use that by preference (3rd argument below).
        ! Assert that sidebands are present if needed here.
        call GetSidebandLoop ( signal, sideband, &
          & (lockedBins(0,signal)==0), sidebandStart, sidebandStop, &
          & sidebandStep )
        return
a742 1
    end if
d744 2
a745 2
    ! Code will only get to here if the bins are unlocked, or are
    ! locked but as yet not nailed down.
d747 28
a774 25
    ! Setup the arrays we need
    nullify ( deltaPhi, nameMatches )
    call Allocate_test ( deltaPhi, noBins, 'deltaPhi', ModuleName )
    call Allocate_test ( nameMatches, noBins, 'nameMatches', ModuleName )
    allocate ( sidebandsMatch ( -1:1, nobins ), STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'sidebandsMatch' )
    deltaPhi = huge ( 0.0_r8 )
    nameMatches = .false.
    sidebandsMatch = .false.
    
    do bin = 1, noBins
      ! Get this radiance quantity
      binRad => l2pcDatabase(bin)%row%vec%quantities(1)%template
      
      ! Do the sidebands match
      sidebandsMatch ( binRad%sideband, bin ) = ( binRad%signal == signal )

      ! Does the 'name' match
      if ( fmConf%nameFragment /= 0 ) then
        call get_string ( l2pcDatabase(bin)%name, binName, strip=.true. )
        call get_string ( fmConf%nameFragment, nameFragment, strip=.true. )
        if ( len_trim(nameFragment) /= 0 ) then
          if ( index ( trim(binName), trim(nameFragment) ) /= 0 ) &
            & nameMatches ( bin ) = .true.
a777 3
      else
        nameMatches ( bin ) = .true.
      end if
d779 31
a809 30
      ! Does the phi match.  This one is more complicated as we may
      ! have to consider it for all MAFs that are not overlapped, and
      ! then take the most 'popular' match. We'll base this on the
      ! first mif each maf.  That will probably be good enough
      if ( fmConf%lockBins ) then
        maf1 = 1 + radiance%template%noInstancesLowerOverlap
        mafN = radiance%template%noInstances - &
          & radiance%template%noInstancesUpperOverlap
      else
        maf1 = maf
        mafN = maf
      endif
      deltaPhi(bin) = sum( (NormalizePhi(radiance%template%phi(1,maf1:mafN)) - &  
        & NormalizePhi(binRad%phi(1,1)) )**2 ) / (mafN-maf1+1)
    end do                              ! End loop over Bins

    ! OK, now we've surveyed the bins, let's cut things down.
    ! When computing folded radiances I'll always choose folded bins
    ! over unfolded ones, even if that means the phi is way off.  I
    ! think this is all a fairly unlikely circumstance anyway.
    split = .false.
    if ( sideband == 0 ) then
      ! If we've got a match for the folded case, forget the others.
      if ( any ( sidebandsMatch(0,:) ) ) then
        where ( sidebandsMatch(0,:) ) 
          sidebandsMatch(-1,:) = .false.
          sidebandsMatch(1,:) = .false.
        end where
      else
        split = .true.
a810 1
    end if
d812 18
a829 3
    ! Work out the range of the sideband loop
    call GetSidebandLoop ( signal, sideband, split, &
      & sidebandStart, sidebandStop, sidebandStep )
d831 4
a834 19
    ! Choose the bin(s)
    bestCost = huge ( deltaPhi(1) )
    l2pcBins = (/ 0, 0, 0 /)
    do bin = 1, noBins
      ! Reuse the sideband variable here, we don't need it's old
      ! definition anymore
      do sideband = sidebandStart, sidebandStop
        if ( sidebandsMatch(sideband,bin) .and. nameMatches(bin) .and. &
          & deltaPhi(bin) < bestCost(sideband) ) then
          bestCost(sideband) = deltaPhi(bin)
          l2pcBins(sideband) = bin
        end if
      end do
    end do
    
    ! Check that we've got the bins we need
    if (any(l2pcBins ((/sidebandStart,sidebandStop/)) == 0 )) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Unable to find l2pc bins to match request' )
d836 2
a837 2
    ! Record this in the 'locked bins' information
    if ( fmConf%lockBins ) lockedBins ( :, signal ) = l2pcBins
d839 1
a839 14
  contains
    ! This does an approximate phi to latitude conversion
    elemental real (r8) function NormalizePhi ( phi ) result ( lat )
      real (r8), intent(in) :: PHI      ! Input geodetic angle
      ! Executable code
      lat = modulo ( phi, 360.0_r8 )
      if ( (lat > 90.0) .and. (lat <= 180.0) ) then
        lat = 180.0 - lat
      else if ( ( lat > 180.0 ) .and. ( lat <= 270.0 ) ) then
        lat = 180.0 - lat
      else if ( lat > 270.0 ) then
        lat = lat - 360.0
      end if
    end function NormalizePhi
d841 1
a841 1
  end subroutine SelectL2PCBins
d846 3
@


2.24
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d50 1
a50 1
    "$Id: LinearizedForwardModel_m.f90,v 2.23 2002/09/03 23:46:04 livesey Exp $"
d138 2
a139 2
    real (r8), dimension(:,:), pointer :: dense  ! Densified matrix from l2pc
    real (r8), dimension(:,:), pointer :: kBit ! Remapped values of l2pc
d853 3
@


2.23
log
@Moved debug print statement to location where it will be less verbose.
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d24 1
a24 1
  use MLSCommon, only: r8
d50 1
a50 1
    "$Id: LinearizedForwardModel_m.f90,v 2.22 2002/07/22 03:25:50 livesey Exp $"
d425 1
a425 1
                jBlock%values = 0.0_r8
d551 1
a551 1
          jBlock%values = 0.0_r8
d853 3
@


2.22
log
@Minor bug fix
@
text
@d50 1
a50 1
    "$Id: LinearizedForwardModel_m.f90,v 2.21 2002/07/17 06:02:01 livesey Exp $"
a312 6
        if ( toggle(emit) .and. levels(emit) > 1 ) then
          call output ( 'Dealing with xStar Quantity named ' )
          call display_string ( l2pc%col%vec%quantities(qtyInd)%template%name, &
            & advance='yes' )
        end if

d337 6
d853 3
@


2.21
log
@Got HDF5 l2pcs working
@
text
@d50 1
a50 1
    "$Id: LinearizedForwardModel_m.f90,v 2.20 2002/07/09 17:37:45 livesey Exp $"
d259 1
a259 1
        & signal=signal%index, sideband=sideband, noError=.true. )
d853 3
@


2.20
log
@Removed ptan extrapolation
@
text
@d17 3
a19 2
  use L2PC_m, only: L2PCDATABASE, BINSELECTORS
  use ManipulateVectorQuantities, only: FINDONECLOSESTINSTANCE
d25 3
a27 2
  use MLSSignals_m, only: Signal_T
  use MLSMessageModule, only: MLSMESSAGE, MLSMSG_ERROR
d32 1
a32 1
  use String_Table, only: Display_String
d43 4
a46 1
  public :: LinearizedForwardModel
d50 1
a50 1
    "$Id: LinearizedForwardModel_m.f90,v 2.19 2002/07/02 19:51:21 livesey Exp $"
d58 14
d77 2
a78 1
    type(vector_T), intent(in) ::  FWDMODELIN, FwdModelExtra
a92 1
    integer :: L2PCBIN                  ! Which l2pc to use
d114 1
d212 19
a230 49
    if ( signal%sideband == 0 ) then
      ! User wants folded.  Can we find this in the l2pc file?
      ! If we have a choice between unfoled or folded l2pc bins,
      ! we'll always choose the folded one for speed, and only think about bin
      ! matching later on.  I imagine most of the time we won't have 'mixed'
      ! l2pc files.
      do l2pcBin = 1, size ( l2pcDatabase ) 
        radInl2pc => GetVectorQuantityByType ( &
          & l2pcDatabase(l2pcBin)%row%vec, quantityType=l_radiance, &
          & signal=signal%index, sideband=signal%sideband, noError=.true. )
        if ( associated ( radInL2PC ) ) exit
      end do
      if ( associated ( radInL2PC ) ) then
        ! We have a folded signal in the l2pc
        thisRatio = 1.0
        sidebandStart = 0
        sidebandStop = 0
        sidebandStep = 1
      else
        ! We have to fold it ourselves
        sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_sidebandRatio, signal=signal%index, noError=.true. )
        lowerSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_sidebandRatio, signal=signal%index, &
          & sideband=-1, noError=.true. )
        upperSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_sidebandRatio, signal=signal%index, &
          & sideband=1, noError=.true. )
        if (.not. associated (sidebandRatio) .and. .not. &
          & ( associated ( lowerSidebandRatio) .and. associated ( upperSidebandRatio ) ) ) &
          & call MLSMessage(MLSMSG_Error,ModuleName, &
          & "No sideband ratio supplied")
        if ( signal%singleSideband == 0 ) then
          ! This is not a single sideband radiometer
          sidebandStart = -1
          sidebandStop = 1
          sidebandStep = 2
        else
          ! This is a single sideband radiometer
          sidebandStart = signal%singleSideband
          sidebandStop = sidebandStart
          sidebandStep = 1
        end if
      end if
    else
      sidebandStart = forwardModelConfig%signals(1)%sideband
      sidebandStop = sideBandStart
      sidebandStep = 1
    endif
d234 2
d238 7
a244 4
        if ( sidebandStart /= sidebandStop ) then   ! We're folding
          if ( associated ( sidebandRatio ) ) then
            thisRatio = sidebandRatio%values(:,1)
            if ( sideband == 1 ) thisRatio = 1.0 - thisRatio
d246 1
a246 5
            if ( sideband == -1 ) then
              thisRatio = lowerSidebandRatio%values(:,1)
            else
              thisRatio = upperSidebandRatio%values(:,1)
            end if
a247 2
        else                  ! Otherwise, want just unfolded signal
          thisRatio = 1.0
d249 3
d254 1
a254 12
      l2pcBin = SelectL2PCBin ( FwdModelIn, FwdModelExtra, radiance, &
        & sideband, maf, bestCost )
      if ( l2pcBin == 0 ) &
        & call MLSMessage( MLSMSG_Error, ModuleName, &
        &  "No appropriate l2pc bin found" )
      l2pc => l2pcDatabase(l2pcBin)
      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call output ( 'Choosing l2pc bin: ' )
        call output ( l2pcBin )
        call output ( ' Cost was: ' )
        call output ( bestCost, advance='yes' )
      end if
d258 1
a258 1
        & l2pcDatabase(l2pcBin)%row%vec, quantityType=l_radiance, &
d331 2
a332 25
        select case ( l2pcQ%template%quantityType )
        case ( l_temperature )
          stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
            & quantityType = l_temperature, &
            & foundInFirst = foundInFirst, noError=.true. )
        case ( l_vmr )
          stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
            & quantityType = l_vmr, &
            & molecule = l2pcQ%template%molecule, &
            & foundInFirst = foundInFirst, noError=.true. )
        case ( l_extinction )
!           stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
!             & quantityType = l_extinction, &
!             & radiometer = l2pcQ%template%radiometer, &
!             & foundInFirst = foundInFirst, noError=.true. )

          ! Temporary
          stateQ => NULL()
        case default
          ! For the moment, just ignore things we don't understand.
          stateQ => NULL()
!           stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
!             & quantityType = l2pcQ%template%quantityType, &
!             & foundInFirst = foundInFirst, noError=.true. )
        end select
a342 15
        ! Now check that surfaces are the same
        if (stateQ%template%noSurfs /= l2pcQ%template%noSurfs) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Number of state vector surfaces not same as l2pc" )
        ! The l2pc writer insisted that things were on zeta coords or none
        ! at all, so check surfaces OK.
        if ( any (abs (stateQ%template%surfs-l2pcQ%template%surfs) > 0.01)) &
          & call MLSMessage(MLSMSG_Error,ModuleName,&
          & 'State vector surface values not same as l2pc')

        ! Check that no. chans. is the same (will it ever /=1!!?)
        if (stateQ%template%noChans /= l2pcQ%template%noChans) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "State vector channels not same as l2pc" )

a462 6
        ! NOTE FOR FUTURE ******************************************
        ! Now make sure that the deltaX's where mask is set are zero
        ! Write this bit later!!!!! !?????? ***********************
        ! Also, do we need to zero out the corresponding columns of K.
        ! I think not as Van's code skips them already.

a476 1

a495 1

d633 52
a684 6
  ! ------------------------------------- SelectL2PCBin -----
  integer function SelectL2PCBin ( FwdModelIn, FwdModelExtra, &
    & radiance, sideband, maf, bestCost )
    ! Dummy arguments
    type (Vector_T), intent(in) :: FWDMODELIN ! Main state vector
    type (Vector_T), intent(in) :: FWDMODELEXTRA ! Other state vector
d686 6
a691 3
    integer, intent(in) :: SIDEBAND     ! What sideband of that radiance
    integer, intent(in) :: MAF          ! What maf for that radiance
    real (r8), intent(out), optional :: BESTCOST ! Best cost
d694 8
a701 10
    integer :: L2PCBIN                  ! Loop counter
    integer :: SELECTOR                 ! Loop counter
    integer :: S1(1), S2(1)             ! Surface range
    type (VectorValue_T), pointer :: RADINL2PC ! Radiance vector quantity
    type (VectorValue_T), pointer :: STATEQ ! Radiance vector quantity
    type (VectorValue_T), pointer :: L2PCQ ! Radiance vector quantity
    real(r8) :: COSTS(size(L2PCDatabase)) ! Cost for each bin
    logical :: FLAG                     ! Flag to simplify an if
    integer :: RESULTASARRAY(1)         ! Result
    integer :: L2PCINSTANCE             ! Instance index in l2pc
d703 8
a710 4
    integer :: STATEINSTANCE            ! Instance index in state vector
    logical :: APPROPRIATE(size(L2PCDatabase)) ! Is this bin appropriate
    real (r8) :: MEANRADPHI             ! Mean value of phi for this maf
    real (r8) :: MEANL2PCPHI            ! Mean value of phi in center scan of bin
d713 2
a714 2
    costs = 0.0_r8
    appropriate = .true.
d716 88
a803 103
    do l2pcBin = 1, size(l2pcDatabase)
      radInL2PC => GetVectorQuantityByType ( &
        & l2pcDatabase(l2pcBin)%row%vec, quantityType=l_radiance, &
        & signal=signal, sideband=sideband, noError=.true. )
      if ( associated(radInL2PC) ) then
        ! OK this signal is present in the l2pc file.
        ! Now loop over the bin selectors and apply the relevant rules
        if ( associated(binSelectors) ) then
          do selector = 1, size(binSelectors)
            ! Only deal with the selectors for this band etc.
            if ( any ( &
              & ( binSelectors(selector)%signals == signal ) .and. &
              & ( ( binSelectors(selector)%sidebands == 0 ) .or. &
              &   ( binSelectors(selector)%sidebands == sideband ) ) ) ) then

              ! Some bin selectors are based on quantities, other on positions
              ! Do the position based ones first

              if ( binSelectors(selector)%selectorType == l_latitude ) then
                ! --------------------------- Position based selectors
                ! When we say latitude, we really mean phi 
                ! (at least for the moment)
                ! WORRY LATER ABOUT MISSING MINOR FRAMES?
                l2pcInstance = radInL2PC%template%noInstances/2 + 1
                meanRadPhi = sum ( radiance%template%phi(:,maf) ) / &
                  & radiance%template%noSurfs
                meanL2PCPhi = sum ( radInL2PC%template%phi(:,l2pcInstance) ) / &
                  & radInL2PC%template%noSurfs
                costs(l2pcBin) = costs(l2pcBin) + &
                  & binSelectors(selector)%cost * abs ( &
                  &   phiToLat(meanRadPhi) - phiToLat(meanL2PCPhi) )
              else
                ! --------------------------- Value based selectors
                ! Locate the quantities in the state and l2pc xStar vectors
                select case ( binSelectors(selector)%selectorType )
                case ( l_temperature )
                  stateQ => GetVectorQuantityByType ( &
                    & fwdModelIn, fwdModelExtra, quantityType=l_temperature, &
                    & noError=.true. )
                  l2pcQ => GetVectorQuantityByType ( &
                    & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_temperature, &
                    & noError=.true. )
                case ( l_vmr )
                  stateQ => GetVectorQuantityByType ( &
                    & fwdModelIn, fwdModelExtra, quantityType=l_vmr, &
                    & molecule=binSelectors(selector)%molecule, noError=.true. )
                  l2pcQ => GetVectorQuantityByType ( &
                    & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_vmr, &
                    & molecule=binSelectors(selector)%molecule, noError=.true. )
                case default
                  call MLSMessage ( MLSMSG_Error, ModuleName, &
                    & 'Unexpected problem with bin selection' )
                end select
                ! If we've got both of them make sure they match
                if ( associated(stateQ) .and. associated(l2pcQ) ) then
                  flag = &
                    & ValidateVectorQuantity ( stateQ, coherent=.true., &
                    & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
                  flag = flag .and. &
                    & ValidateVectorQuantity ( l2pcQ, coherent=.true., &
                    & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
                  if ( flag ) flag = flag .and. &
                    & (stateQ%template%noSurfs == l2pcQ%template%noSurfs)
                  if ( flag ) flag = flag .and. &
                    & all (abs (stateQ%template%surfs-l2pcQ%template%surfs) < 0.01)
                  if ( flag ) then
                    ! OK, identify height range
                    s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                      & log10(binSelectors(selector)%heightRange(1) ) ) )
                    s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                      & log10(binSelectors(selector)%heightRange(2) ) ) )
                    ! We're at last ready to go.  Just compare central profiles in
                    ! each l2pc bin with each state vector profile
                    l2pcInstance = l2pcQ%template%noInstances/2 + 1
                    ! Only compare the closest profile to the maf
                    stateInstance = FindOneClosestInstance ( stateQ, radiance, maf )
                    costs ( l2pcBin ) = costs ( l2pcBin ) + sum ( abs ( &
                      & stateQ%values ( s1(1):s2(1), stateInstance ) - &
                      & l2pcQ%values ( s1(1):s2(1), l2pcInstance ) ) ) / &
                      & ( binSelectors(selector)%cost * ( s2(1)-s1(1)+1 ) )
                  else
                    ! This l2pcBin doesn't match the quantity dimensions etc.
                    appropriate ( l2pcBin ) = .false.
                  end if                ! OK to do the test
                end if                  ! Quantity in both state and l2pc
              end if                    ! A quantity based selector
            end if                      ! This selector relevant
          end do                        ! End loop over selectors
        end if                          ! Any selectors
      else                              ! This l2pc bin not relevant
        appropriate ( l2pcBin ) = .false.
      end if
    end do                              ! End loop over l2pc bins
    if ( any ( appropriate ) ) then 
      where ( .not. appropriate )
        costs = huge ( 0.0_r8)
      end where
      resultAsArray = minloc ( costs, appropriate )
      SelectL2PCBin = resultAsArray(1)
      if ( present(bestCost) ) bestCost = costs( resultAsArray(1) )
    else
      SelectL2PCBin = 0
      if ( present(bestCost) ) bestCost = huge( costs(1) )
d806 27
a833 1
    
d835 1
a835 1
    real (r8) function PhiToLat ( phi ) result ( lat )
d846 3
a848 1
    end function Phitolat
a849 1
  end function SelectL2PCBin
d853 3
@


2.19
log
@Embarassing bug, was choosing 'center' wrong, lead to lag
and all sorts of messyness
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.18 2002/06/12 17:46:21 livesey Exp $"
d573 6
a578 6
        & xStarPtan%values(:,1), &        ! OldX
        & yPmapped, &                     ! OldY
        & ptan%values(:,maf), &           ! NewX
        & resultMapped, &                 ! NewY
        & 'Spline', &                     ! use spline
        & extrapolate='Allow', &          ! Allow extrapolation in radiance
d670 1
a670 1
          & 'Spline', extrapolate='Allow' )
d855 4
@


2.18
log
@Better treatment of real phiWindow
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.17 2002/06/12 17:02:25 livesey Exp $"
d419 1
a419 1
        center = l2pcQ%template%noInstances/2 - 1
d855 3
@


2.17
log
@Very TEMPORARY! change to LinearizedForwardModel to skip round real
value of phiWindow.  Fix it properly later.
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.16 2002/05/28 22:34:21 livesey Exp $"
d65 1
d102 1
d419 1
d422 19
a440 3
          deltaInstance = xStarInstance - l2pcQ%template%noInstances/2 - 1
          deltaInstance = max ( nint(-forwardModelConfig%phiWindow/2), &
            &                   min ( deltaInstance, nint(forwardModelConfig%phiWindow/2)) )
d855 4
@


2.16
log
@Added more useful diagnostic message
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.15 2002/05/14 22:32:53 livesey Exp $"
d420 2
a421 2
          deltaInstance = max ( -forwardModelConfig%phiWindow/2, &
            &                   min ( deltaInstance, forwardModelConfig%phiWindow/2) )
d836 3
@


2.15
log
@Added single sideband stuff
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.14 2002/05/03 23:29:31 livesey Exp $"
d330 6
d386 1
a386 1
          & "State vector surfaces not same as l2pc" )
d391 1
a391 1
          & 'State vector surfaces not same as l2pc')
d836 3
@


2.14
log
@Added split sideband ratio stuff
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.13 2002/03/15 21:23:09 livesey Exp $"
d222 11
a232 3
        sidebandStart = -1
        sidebandStop = 1
        sidebandStep = 2
d830 3
@


2.13
log
@New bin selectors based on 'latitude' allowed
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.12 2002/02/20 03:00:23 livesey Exp $"
d136 2
d211 11
a221 2
          & quantityType = l_sidebandRatio, signal=signal%index )
        thisRatio = sidebandRatio%values(:,1)
a226 1
      thisRatio = 1.0
d236 15
a250 5
      if ( sidebandStart /= sidebandStop ) then
        thisRatio = sidebandRatio%values(:,1)
        if ( sideband == 1 ) thisRatio = 1.0 - thisRatio
      end if
      
d822 3
@


2.12
log
@Made the verbose dump more unlikely
@
text
@d16 1
a16 1
    & L_SIDEBANDRATIO, L_ZETA, L_OPTICALDEPTH
d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.11 2002/02/12 21:48:21 livesey Exp $"
d670 2
d691 72
a762 52
              ! Locate the quantities in the state and l2pc xStar vectors
              select case ( binSelectors(selector)%quantityType )
              case ( l_temperature )
                stateQ => GetVectorQuantityByType ( &
                  & fwdModelIn, fwdModelExtra, quantityType=l_temperature, &
                  & noError=.true. )
                l2pcQ => GetVectorQuantityByType ( &
                  & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_temperature, &
                  & noError=.true. )
              case ( l_vmr )
                stateQ => GetVectorQuantityByType ( &
                  & fwdModelIn, fwdModelExtra, quantityType=l_vmr, &
                  & molecule=binSelectors(selector)%molecule, noError=.true. )
                l2pcQ => GetVectorQuantityByType ( &
                  & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_vmr, &
                  & molecule=binSelectors(selector)%molecule, noError=.true. )
              case default
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                  & 'Unexpected problem with bin selection' )
              end select
              ! If we've got both of them make sure they match
              if ( associated(stateQ) .and. associated(l2pcQ) ) then
                flag = &
                  & ValidateVectorQuantity ( stateQ, coherent=.true., &
                  & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
                flag = flag .and. &
                  & ValidateVectorQuantity ( l2pcQ, coherent=.true., &
                  & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
                if ( flag ) flag = flag .and. &
                  & (stateQ%template%noSurfs == l2pcQ%template%noSurfs)
                if ( flag ) flag = flag .and. &
                  & all (abs (stateQ%template%surfs-l2pcQ%template%surfs) < 0.01)
                if ( flag ) then
                  ! OK, identify height range
                  s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                    & log10(binSelectors(selector)%heightRange(1) ) ) )
                  s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                    & log10(binSelectors(selector)%heightRange(2) ) ) )
                  ! We're at last ready to go.  Just compare central profiles in
                  ! each l2pc bin with each state vector profile
                  l2pcInstance = l2pcQ%template%noInstances/2 + 1
                  ! Only compare the closest profile to the maf
                  stateInstance = FindOneClosestInstance ( stateQ, radiance, maf )
                  costs ( l2pcBin ) = costs ( l2pcBin ) + sum ( abs ( &
                    & stateQ%values ( s1(1):s2(1), stateInstance ) - &
                    & l2pcQ%values ( s1(1):s2(1), l2pcInstance ) ) ) / &
                    & ( binSelectors(selector)%cost * ( s2(1)-s1(1)+1 ) )
                else
                  ! This l2pcBin doesn't match the quantity dimensions etc.
                  appropriate ( l2pcBin ) = .false.
                end if                  ! OK to do the test
              end if                    ! Quantity in both state and l2pc
d782 16
d802 3
@


2.11
log
@Fixed minor bug for case when no bin selectors
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.10 2002/02/09 21:35:22 livesey Exp $"
d488 1
a488 1
      if ( toggle(emit) .and. levels(emit) > 2 ) then
d501 1
a501 1
      if ( toggle(emit) .and. levels(emit) > 2 ) then
d764 3
@


2.10
log
@Minor bug fixes
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.9 2002/02/09 19:11:19 livesey Exp $"
d395 2
a396 8
          ! If the state vector part has a mask, copy it to DeltaX
! *************** MORE WORK NEEDED HERE NJL
!           if ( associated ( stateQ%mask ) ) then
!             if ( .not. associated ( deltaX%quantities(qtyInd)%mask ) ) &
!               & CreateMask ( deltaX%quantities(qtyInd) )
!             deltaX%mask(qtyInd)%values(:,xStarInstance) = &
!               stateQ%mask(:,xInstance)
!           endif
d398 1
a398 1
          ! If so, interpolate this block of kStar and place in jacobian
d446 1
a446 1
                        &     lowerWeight(mif) * kBit( lower , : ) + &
d682 62
a743 60
        do selector = 1, size(binSelectors)
          ! Only deal with the selectors for this band etc.
          if ( any ( &
            & ( binSelectors(selector)%signals == signal ) .and. &
            & ( ( binSelectors(selector)%sidebands == 0 ) .or. &
            &   ( binSelectors(selector)%sidebands == sideband ) ) ) ) then
            ! Locate the quantities in the state and l2pc xStar vectors
            select case ( binSelectors(selector)%quantityType )
            case ( l_temperature )
              stateQ => GetVectorQuantityByType ( &
                & fwdModelIn, fwdModelExtra, quantityType=l_temperature, &
                & noError=.true. )
              l2pcQ => GetVectorQuantityByType ( &
                & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_temperature, &
                & noError=.true. )
            case ( l_vmr )
              stateQ => GetVectorQuantityByType ( &
                & fwdModelIn, fwdModelExtra, quantityType=l_vmr, &
                & molecule=binSelectors(selector)%molecule, noError=.true. )
              l2pcQ => GetVectorQuantityByType ( &
                & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_vmr, &
                & molecule=binSelectors(selector)%molecule, noError=.true. )
            case default
              call MLSMessage ( MLSMSG_Error, ModuleName, &
                & 'Unexpected problem with bin selection' )
            end select
            ! If we've got both of them make sure they match
            if ( associated(stateQ) .and. associated(l2pcQ) ) then
              flag = &
                & ValidateVectorQuantity ( stateQ, coherent=.true., &
                & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
              flag = flag .and. &
                & ValidateVectorQuantity ( l2pcQ, coherent=.true., &
                & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
              if ( flag ) flag = flag .and. &
                & (stateQ%template%noSurfs == l2pcQ%template%noSurfs)
              if ( flag ) flag = flag .and. &
                & all (abs (stateQ%template%surfs-l2pcQ%template%surfs) < 0.01)
              if ( flag ) then
                ! OK, identify height range
                s1 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                  & log10(binSelectors(selector)%heightRange(1) ) ) )
                s2 = minloc ( abs ( stateQ%template%surfs(:,1) + &
                  & log10(binSelectors(selector)%heightRange(2) ) ) )
                ! We're at last ready to go.  Just compare central profiles in
                ! each l2pc bin with each state vector profile
                l2pcInstance = l2pcQ%template%noInstances/2 + 1
                ! Only compare the closest profile to the maf
                stateInstance = FindOneClosestInstance ( stateQ, radiance, maf )
                costs ( l2pcBin ) = costs ( l2pcBin ) + sum ( abs ( &
                  & stateQ%values ( s1(1):s2(1), stateInstance ) - &
                  & l2pcQ%values ( s1(1):s2(1), l2pcInstance ) ) ) / &
                  & ( binSelectors(selector)%cost * ( s2(1)-s1(1)+1 ) )
              else
                ! This l2pcBin doesn't match the quantity dimensions etc.
                appropriate ( l2pcBin ) = .false.
              end if                    ! OK to do the test
            end if                      ! Quantity in both state and l2pc
          end if                        ! This selector relevant
        end do                          ! End loop over selectors
d764 3
@


2.9
log
@Added optical depth calculation etc.
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.8 2002/02/08 22:51:00 livesey Exp $"
d615 1
a615 1
        closestInstance = FindOneClosestInstance ( temp, radiance, mif )
d625 2
a626 2
        radiance%values(:,mif) = 1.0 - &
          & radiance%values(:,mif) / reshape ( spread ( &
d628 2
a629 2
        where ( radiance%values(:,mif) > 0.0 )
          radiance%values(:,mif) = -log( radiance%values(:,mif) )
d631 1
a631 1
          radiance%values(:,mif) = 1.0e5 ! Choose a suitable large value
d768 3
@


2.8
log
@Working (hopefully) version of bin selection
@
text
@d16 1
a16 1
    & L_SIDEBANDRATIO, L_ZETA
d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.7 2002/02/06 01:34:20 livesey Exp $"
d110 1
d132 1
d144 1
d160 17
a176 1
      & signal= signal%index, sideband=signal%sideband )
d609 25
d768 3
@


2.7
log
@Changed to use FindOneClosestInstance
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.6 2002/01/21 22:52:21 livesey Exp $"
d100 2
d170 1
a170 1
      ! Use wants folded.  Can we find this in the l2pc file?
d182 1
a182 1
        ! We have a folded signal in the l2p
d211 5
a215 10

      ! Find an l2pc bin containing this signal.
      ! DO SOMETHING MORE CLEVER LATER!
      do l2pcBin = 1, size ( l2pcDatabase ) 
        radInl2pc => GetVectorQuantityByType ( &
          & l2pcDatabase(l2pcBin)%row%vec, quantityType=l_radiance, &
          & signal=signal%index, sideband=sideband, noError=.true. )
        if ( associated ( radInL2PC ) ) exit
      end do
      if ( .not. associated ( radInL2PC ) ) &
d219 6
d227 3
d609 1
a609 1
    & signal, sideband )
d613 4
a616 2
    type (Signal_T), intent(in) :: SIGNAL ! What signal are we considering
    integer, intent(in) :: SIDEBAND     ! What sideband of that signal
d629 1
d631 1
d635 2
d640 1
a640 1
        & signal=signal%index, sideband=sideband, noError=.true. )
d645 48
a692 44

          ! Locate the quantities in the state and l2pc xStar vectors
          select case ( binSelectors(selector)%quantityType )
          case ( l_temperature )
            stateQ = GetVectorQuantityByType ( &
              & fwdModelIn, fwdModelExtra, quantityType=l_temperature, &
              & noError=.true. )
            l2pcQ = GetVectorQuantityByType ( &
              & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_temperature, &
              & noError=.true. )
          case ( l_vmr )
            stateQ = GetVectorQuantityByType ( &
              & fwdModelIn, fwdModelExtra, quantityType=l_vmr, &
              & molecule=binSelectors(selector)%molecule, noError=.true. )
            l2pcQ = GetVectorQuantityByType ( &
              & l2pcDatabase(l2pcBin)%col%vec, quantityType=l_vmr, &
              & molecule=binSelectors(selector)%molecule, noError=.true. )
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Unexpected problem with bin selection' )
          end select
          ! If we've got both of them make sure they match
          if ( associated(stateQ) .and. associated(l2pcQ) ) then
            flag = &
              & ValidateVectorQuantity ( stateQ, coherent=.true., &
              & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
            flag = flag .and. &
              & ValidateVectorQuantity ( l2pcQ, coherent=.true., &
              & verticalCoordinate=(/l_zeta/), frequencyCoordinate=(/l_none/) )
            if ( flag ) flag = flag .and. &
              & (stateQ%template%noSurfs /= l2pcQ%template%noSurfs)
            if ( flag ) flag = flag .and. &
              & all (abs (stateQ%template%surfs-l2pcQ%template%surfs) < 0.01)
            if ( flag ) then
              ! OK, identify height range
              s1 = minloc ( abs ( stateQ%template%surfs(:,1) - &
                & log10(binSelectors(selector)%heightRange(1) ) ) )
              s2 = minloc ( abs ( stateQ%template%surfs(:,1) - &
                & log10(binSelectors(selector)%heightRange(2) ) ) )
              ! We're at last ready to go.  Just compare central profiles in
              ! each l2pc bin with each state vector profile
              l2pcInstance = l2pcQ%template%noInstances/2 + 1
              ! THINK MORE CAREFULLY ABOUT THIS WHEN WE GET ASYMMETRIC L2PCs
              do stateInstance = 1, stateQ%template%noInstances
d696 7
a702 4
                  & binSelectors(selector)%cost
              end do                    ! End loop over state vector instances
            end if                      ! OK to do the test
          end if                        ! Quantity in both state and l2pc
d705 1
a705 1
        costs ( l2pcBin ) = huge ( costs(1) )
d708 11
a718 3

    resultAsArray = minloc ( costs )
    SelectL2PCBin = resultAsArray(1)
d724 3
@


2.6
log
@A few more comments
@
text
@d18 1
a18 1
  use ManipulateVectorQuantities, only: FINDCLOSESTINSTANCES
d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.5 2002/01/21 22:46:08 livesey Exp $"
d341 1
a341 2
        call FindClosestInstances ( stateQ, radiance, closestInstances)
        closestInstance=closestInstances(maf)
d697 3
@


2.5
log
@Wrote, but not hooked up SelectL2PCBin
@
text
@d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.4 2002/01/17 02:17:04 livesey Exp $"
d682 5
a686 5
              end do
            end if
          end if
        end do
      else
d689 1
a689 1
    end do
d698 3
@


2.4
log
@Somewhat temporary, skip l2pc state vector components we don't like
@
text
@d15 3
a17 3
  use Intrinsic, only: L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
    & L_SIDEBANDRATIO
  use L2PC_m, only: L2PCDATABASE
d36 2
a37 1
    & VECTORVALUE_T, VECTORTEMPLATE_T, DUMP
d45 1
a45 1
    "$Id: LinearizedForwardModel_m.f90,v 2.3 2001/10/22 16:51:40 livesey Exp $"
d169 4
a172 1
      ! Later in multi bin case think more carefully here.
d599 96
d698 3
@


2.3
log
@Allow radiance extrapolation (at least for now).
@
text
@d27 1
d44 1
a44 1
    "$Id: LinearizedForwardModel_m.f90,v 2.2 2001/10/07 00:23:50 livesey Exp $"
d295 8
d304 5
a308 3
          stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
            & quantityType = l2pcQ%template%quantityType, &
            & foundInFirst = foundInFirst, noError=.true. )
d317 1
d598 3
@


2.2
log
@Fixed minor bug with dyByDx
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 2.1 2001/10/02 16:51:41 livesey Exp $"
d491 1
a491 1
        & extrapolate='Constant', &       ! dont extrapolate, clamp
d586 3
@


2.1
log
@Removed fmStat%finished and reordered loops in forward models
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 2.0 2001/09/17 20:26:26 livesey Exp $"
d537 8
a544 2
          jBlock%values(:,1) = reshape(transpose(dyByDx),&
            & (/radiance%template%instanceLen/))
d586 3
@


2.0
log
@New forward model
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.22 2001/06/04 22:43:26 livesey Exp $"
a573 2
    if ( maf == radiance%template%noInstances ) fmStat%finished = .true.

d580 3
@


1.22
log
@Now works when no molecules at all
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.21 2001/06/01 20:35:55 livesey Exp $"
d582 3
@


1.21
log
@Now obeys the phiWindow parameter to give 1D forward models.
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.20 2001/06/01 20:09:28 livesey Exp $"
d278 3
a280 2
          if ( .not. any &
            & (l2pcQ%template%molecule == forwardModelConfig%molecules)) cycle
d332 3
a334 1
        if (doDerivatives .and. (l2pcQ%template%quantityType==l_vmr) ) then
d582 3
@


1.20
log
@Embarassing bug to do with edge effects removed.  This version makes L2 work!
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.19 2001/05/25 19:12:21 livesey Exp $"
d67 1
d342 4
a345 3
          xInstance = closestInstance - &
            & l2pcQ%template%noInstances/2 + &
            & xStarInstance - 1
d579 3
@


1.19
log
@Embarassing bug fix.  Was using quantity basis as framework for interpolation,
not pointings in the l2pc file!
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.18 2001/05/19 01:21:33 livesey Exp $"
d390 1
d404 5
a408 12
                      if ( sideband == sidebandStart ) then
                        jBlock%values ( i , : ) = &
                          &   thisRatio(chan) * ( &
                          &     lowerWeight(mif) * kBit( lower , : ) + &
                          &     upperWeight(mif) * kBit( upper, : ) )
                      else
                        jBlock%values ( i , : ) = &
                          & jBlock%values ( i , : ) + &
                          &   thisRatio(chan) * ( &
                          &     lowerWeight(mif) * kBit( lower , : ) + &
                          &     upperWeight(mif) * kBit( upper, : ) )
                      endif
d577 4
@


1.18
log
@Bug fix, was only storing derivatives for second sideband.
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.17 2001/05/09 19:46:49 vsnyder Exp $"
d245 23
a337 29
        ! If so, set up some arrays
        if (doDerivatives) then
          call allocate_test ( mifPointingsLower, noMIFs, &
            & 'mifPointingsLower', ModuleName )
          call allocate_test ( mifPointingsUpper, noMIFs, &
            & 'mifPointingsUpper', ModuleName )
          call allocate_test ( lowerWeight, noMIFs, &
            & 'lowerWeight', ModuleName )
          call allocate_test ( upperWeight, noMIFs, &
            & 'upperWeight', ModuleName )
          if ( l2pcQ%template%noSurfs /= 1 ) then
            call Hunt ( l2pcQ%template%surfs(:,1), ptan%values(:,maf), mifPointingsLower )
            mifPointingsUpper = mifPointingsLower + 1

            upperWeight = &
              & ( ptan%values(:,maf) - l2pcQ%template%surfs(mifPointingsLower,1) ) / &
              & ( l2pcQ%template%surfs(mifPointingsUpper,1) - &
              &   l2pcQ%template%surfs(mifPointingsLower,1) )
            lowerWeight = 1.0 - upperWeight
            upperWeight = min ( 1.0_r8, max (upperWeight, 0.0_r8 ) )
            lowerWeight = min ( 1.0_r8, max (lowerWeight, 0.0_r8 ) )
          else
            mifPointingsLower = 1
            mifPointingsUpper = 1
            lowerWeight = 1.0
            upperWeight = 0.0
          end if
        end if

d418 1
a418 1
                    upper = upper
a428 10
        if ( doDerivatives ) then         ! Destroy working arrays
          call deallocate_test ( mifPointingsLower, &
            & 'mifPointingsLower', ModuleName )
          call deallocate_test ( mifPointingsUpper, &
            & 'mifPointingsUpper', ModuleName )
          call deallocate_test ( lowerWeight, &
            & 'lowerWeight', ModuleName )
          call deallocate_test ( upperWeight, &
            & 'upperWeight', ModuleName )
        end if
d442 11
d567 1
d583 3
@


1.17
log
@Use new bandHeight argument of createBlock
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.16 2001/05/08 23:26:36 livesey Exp $"
d407 19
a425 11
                do chan = 1, noChans
                  if ( doChannel(chan) ) then
                    jBlock%values ( i , : ) = &
                      & thisRatio(chan) * ( &
                      &   lowerWeight(mif) * kBit( lower , : ) + &
                      &   upperWeight(mif) * kBit( upper, : ) )
                  endif
                  i = i + 1
                  lower = lower + 1
                  upper = upper
                end do
d587 3
@


1.16
log
@Embarassing typo/bug fixed
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.15 2001/05/03 22:58:38 livesey Exp $"
d526 1
a526 1
            &   noMIFs*noChans )
a527 4
          do mif = 1, noMIFs
            jBlock%r1(mif) = 1 + noChans * (mif-1)
            jBlock%r2(mif) = noChans * mif
          end do
d579 3
@


1.15
log
@Removed bug work around
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.14 2001/05/03 02:02:54 vsnyder Exp $"
d333 1
a333 1
            lowerWeight = 1.0 - lowerWeight
d583 3
@


1.14
log
@Use emit toggle.  Add names to cloned vectors
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.13 2001/05/02 20:26:17 vsnyder Exp $"
a253 8



          cycle!????????????????????******************************** DEBUG!!!!!!!




a441 7
        !!!!!!!!!!!!!!!! AVOID BUG !!!!!!!!!!!!!!!!!!!!11
        if (deltaX%quantities(qtyInd)%template%quantityType == l_temperature) &
          & deltaX%quantities(qtyInd)%values(:, &
          & deltaX%quantities(qtyInd)%template%noInstances) = 0.0
          !!!!!!!!!!!!!!!!!!! DEBUG


d583 3
@


1.13
log
@Give names to cloned vectors.  Use toggle(emit) and levels(emit) to
control debugging output.
@
text
@d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.12 2001/05/02 20:22:13 livesey Exp $"
d467 2
a468 2
      print*,'Delta X:'
      call dump ( (/deltaX/) )
d470 6
a475 9
      print*,'l2pc%col%inst'
      call dump(l2pc%col%inst)
      print*,'l2pc%col%quant'
      call dump(l2pc%col%quant)

      print*,'l2pc%row%inst'
      call dump(l2pc%row%inst)
      print*,'l2pc%row%quant'
      call dump(l2pc%row%quant)
d479 4
a482 1
      call dump ( (/yp, l2pc%row%vec/) )
d598 4
@


1.12
log
@Removed some unused variables.
@
text
@a10 2
  use Intrinsic, only: LIT_INDICES
  use L2PC_m, only: L2PCDATABASE
d14 4
d27 5
a35 4
  use QuantityTemplates, only: QuantityTemplate_T
  use String_Table, only: Display_String
  use Intrinsic, only: L_RADIANCE, L_TEMPERATURE, L_PTAN, L_VMR, &
    & L_SIDEBANDRATIO
d43 1
a43 1
    "$Id: LinearizedForwardModel_m.f90,v 1.11 2001/05/01 06:55:07 livesey Exp $"
d129 1
d131 1
d142 4
a145 1
    print*,'Linear model doing maf:',maf
d225 2
a226 2
      call cloneVector ( xP, l2pc%col%vec )
      call cloneVector ( deltaX, xP )     ! Note sets values to 0.0
d480 1
a480 1
      call cloneVector( yp, l2pc%row%vec )
d592 2
d598 3
@


1.11
log
@Intermediate bug avoiding version.
@
text
@d40 1
a40 1
    "$Id: LinearizedForwardModel_m.f90,v 1.10 2001/04/30 15:50:29 livesey Exp $"
a59 1
    integer :: CENTERPROF               ! Center profile corresponding to MAF
a64 1
    integer :: INSTANCE                 ! Loop index
a79 3
    integer :: STARTJ                   ! An index into the first index of jacobian
    integer :: STARTL                   ! An index into the first index of jBit lower
    integer :: STARTU                   ! An index into the first index of jBit upper
d246 8
a303 1
        doDerivatives = present(jacobian)
d334 2
d459 13
d473 2
a474 2
      call MultiplyMatrixVectorNoT ( l2pc, deltaX, yP )

d588 3
@


1.10
log
@Commented out code associated with mask
@
text
@d40 1
a40 1
    "$Id: LinearizedForwardModel_m.f90,v 1.9 2001/04/28 22:32:07 livesey Exp $"
d438 6
d571 3
@


1.9
log
@Nothing much changed apart from comments.
Need to add code to have it ignore state stuff according to MASK.
@
text
@d40 1
a40 1
    "$Id: LinearizedForwardModel_m.f90,v 1.8 2001/04/28 21:23:33 livesey Exp $"
d353 7
a359 6
          if ( associated ( stateQ%mask ) ) then
            if ( .not. associated ( deltaX%quantities(qtyInd)%mask ) ) &
              & CreateMask ( deltaX%quantities(qtyInd) )
            deltaX%mask(qtyInd)%values(:,xStarInstance) = &
              stateQ%mask(:,xInstance)
          endif
d565 4
@


1.8
log
@Working version.  Does folded sidebands (not tested yet), nice and fast
@
text
@d40 1
a40 1
    "$Id: LinearizedForwardModel_m.f90,v 1.7 2001/04/28 19:40:37 livesey Exp $"
d347 1
d349 1
a349 1
          xP%quantities(qtyInd)%values(:,xStarInstance) =&
d352 7
d437 7
d564 3
d571 2
a572 1
! Revision 1.6  2001/04/28 07:05:25  livesey! Another interim version
@


1.7
log
@Working version. Assembles jacobian in a nice fast manner.
Next thing is to do sideband folding.
@
text
@d31 2
a32 1
  use Intrinsic, only: L_RADIANCE, L_TEMPERATURE, L_PTAN,L_VMR
d40 1
a40 1
       "$Id: LinearizedForwardModel_m.f90,v 1.6 2001/04/28 07:05:25 livesey Exp $"
d61 1
d65 1
d69 1
d78 4
d85 1
d97 2
d107 1
d130 1
d136 1
a147 2
    if ( signal%sideband /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName,&
      & "Linearized forward model can only do folded signals for now")
d155 2
a156 37
    ! Here in later versions, we'd identify which l2pc bin to use
    ! It has to go here as we need to know yStar%noSurfs for the next
    ! part.
    ! For the moment choose the first
    l2pcBin = 1
    l2pc => l2pcDatabase(l2pcBin)

    radInl2pc => GetVectorQuantityByType (l2pc%row%vec, quantityType=l_radiance, &
      & signal=signal%index, sideband=signal%sideband )

    ! Set a dimension
    noPointings = radInL2PC%template%noSurfs
    if ( radInL2PC%template%noChans /= noChans ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Channel dimension in l2pc not same as in measurements" )

    ! Now we loop over the quantities in the l2pc file and construct an xPrime
    ! for them
    call cloneVector ( xP, l2pc%col%vec )
    call cloneVector ( deltaX, xP )     ! Note sets values to 0.0

    ! Set up some other stuff before main loop
    call Allocate_test ( closestInstances, radiance%template%noInstances, &
      & 'closestInstances', ModuleName )

    ! Get the two ptans, we'll need these for interpolation
    ptan => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra, &
      & quantityType = l_ptan, &
      & instrumentModule = radiance%template%instrumentModule,&
      & foundInFirst = ptanInFirst )

    xStarPtan => GetVectorQuantityByType ( l2pc%col%vec, &
      & quantityType = l_ptan )

    rowLBlock = 1
    if ( present (jacobian) ) rowJBlock = &
      & FindBlock ( jacobian%row, radiance%index, maf )
d158 2
a159 2
    ! -------- Main loop over xStar quantities -------------------------------
    do qtyInd = 1, size ( l2pc%col%vec%quantities )
d161 23
a183 8
      ! Identify this quantity in xStar
      l2pcQ => l2pc%col%vec%quantities(qtyInd)
      
      ! Now see if we are wanting to deal with this
      if ( l2pcQ%template%quantityType == l_ptan ) cycle ! Get this from interpolation
      if ( l2pcQ%template%quantityType == l_vmr ) then
        if ( .not. any &
          & (l2pcQ%template%molecule == forwardModelConfig%molecules)) cycle
d185 9
d195 4
a198 23
      ! Identify this quantity in x
      select case ( l2pcQ%template%quantityType )
      case ( l_temperature )
        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
          & quantityType = l_temperature, &
          & foundInFirst = foundInFirst, noError=.true. )
      case ( l_vmr )
        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
          & quantityType = l_vmr, &
          & molecule = l2pcQ%template%molecule, &
          & foundInFirst = foundInFirst, noError=.true. )
      case default
        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
          & quantityType = l2pcQ%template%quantityType, &
          & foundInFirst = foundInFirst, noError=.true. )
      end select

      ! If it's not in the state vector, perhaps make a fuss
      if ( .not. associated(stateQ) ) then
        if ( any(l2pcQ%template%quantityType == &
          & (/ l_temperature, l_vmr /))) &
          &   call MLSMessage ( MLSMSG_Error, ModuleName, &
          &  "Temperature or vmr quantity absent from state")
d201 16
a216 2
      ! Now check that surfaces are the same
      if (stateQ%template%noSurfs /= l2pcQ%template%noSurfs) &
d218 1
a218 6
        & "State vector surfaces not same as l2pc" )
      ! The l2pc writer insisted that things were on zeta coords or none
      ! at all, so check surfaces OK.
      if ( any (abs (stateQ%template%surfs-l2pcQ%template%surfs) > 0.01)) &
        & call MLSMessage(MLSMSG_Error,ModuleName,&
        & 'State vector surfaces not same as l2pc')
d220 59
a278 4
      ! Check that no. chans. is the same (will it ever /=1!!?)
      if (stateQ%template%noChans /= l2pcQ%template%noChans) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "State vector channels not same as l2pc" )
d280 24
a303 9
      ! OK, we're legit, lets get going.
      instanceLen = l2pcQ%template%instanceLen
      call FindClosestInstances ( stateQ, radiance, closestInstances)
      closestInstance=closestInstances(maf)

      ! Do we need derivatives for this?
      doDerivatives = present(jacobian)
      doDerivatives = present(jacobian) .and. foundInFirst
      if (doDerivatives .and. (l2pcQ%template%quantityType==l_temperature) ) &
d305 34
a338 7
      if (doDerivatives .and. (l2pcQ%template%quantityType==l_vmr) ) then
        doDerivatives = forwardModelConfig%atmos_der
        if ( doDerivatives .and. .not. any (l2pcQ%template%molecule == &
          & pack(ForwardModelConfig%molecules, &
          &      ForwardModelConfig%moleculeDerivatives))) &
          & doDerivatives = .false.
      end if
d340 134
a473 19
      ! If so, set up some arrays
      if (doDerivatives) then
        call allocate_test ( mifPointingsLower, noMIFs, &
          & 'mifPointingsLower', ModuleName )
        call allocate_test ( mifPointingsUpper, noMIFs, &
          & 'mifPointingsUpper', ModuleName )
        call allocate_test ( lowerWeight, noMIFs, &
          & 'lowerWeight', ModuleName )
        call allocate_test ( upperWeight, noMIFs, &
          & 'upperWeight', ModuleName )
        if ( l2pcQ%template%noSurfs /= 1 ) then
          call Hunt ( l2pcQ%template%surfs(:,1), ptan%values(:,maf), mifPointingsLower )
          mifPointingsUpper = mifPointingsLower + 1
          
          upperWeight = &
            & ( ptan%values(:,maf) - l2pcQ%template%surfs(mifPointingsLower,1) ) / &
            & ( l2pcQ%template%surfs(mifPointingsUpper,1) - &
            &   l2pcQ%template%surfs(mifPointingsLower,1) )
          lowerWeight = 1.0 - lowerWeight
d475 9
a483 4
          mifPointingsLower = 1
          mifPointingsUpper = 1
          lowerWeight = 1.0
          upperWeight = 0.0
d485 20
a504 13
      end if        

      ! Loop over profiles
      do xStarInstance = 1, l2pcQ%template%noInstances
        ! Identify this instance in state
        xInstance = closestInstance - &
          & l2pcQ%template%noInstances/2 + &
          & xStarInstance - 1
        xInstance = max ( 1, min ( xInstance, stateQ%template%noInstances ) )
        ! Fill this part of xP
        xP%quantities(qtyInd)%values(:,xStarInstance) =&
          & stateQ%values(:,xInstance)

d506 34
a539 127
        ! If so, interpolate this block of kStar and place in jacobian
        if (doDerivatives) then
          fmStat%rows(rowJBlock) = .true.
          colLBlock = FindBlock ( l2pc%col, l2pcQ%index, xStarInstance )
          colJBlock = FindBlock ( jacobian%col, stateQ%index, xInstance )
          l2pcBlock => l2pc%block(rowLBlock,colLBlock)

          if ( l2pcBlock%kind /= M_Absent ) then
            ! OK, before, I was doing transpose / reshapes / 
            ! interpolates / transpose / reshapes.  That was taking too long,
            ! so I'm going to do the interpolations by hand

            ! Get pointer to l2pc information
            if ( any ( l2pcBlock%kind == &
              & (/ M_Column_Sparse, M_Banded /) ) ) then
              call allocate_test ( dense, &
                & noChans * noPointings, instanceLen, &
                & 'dense', ModuleName )
              call densify ( dense, l2pcBlock )
              kBit => dense
            else
              kBit => l2pcBlock%values
            endif

            ! Indentify the block in the jacobian
            jBlock => jacobian%block(rowJblock,colJblock)
            select case ( jBlock%kind )
            case ( M_Absent )
              call CreateBlock ( jBlock, &
                & noChans*noMIFs, instanceLen, &
                & M_Full )
            case ( M_Banded, M_Column_Sparse )
              call MLSMessage( MLSMSG_Error, ModuleName, &
                & "Not written code for adding to non full blocks" )
            case default
            end select

            ! Now do the interpolation
            do mif = 1, noMIFs
              startJ = (mif-1) * noChans + 1
              startL = (mifPointingsLower(mif)-1) * noChans + 1
              startU = (mifPointingsUpper(mif)-1) * noChans + 1
              jBlock%values ( startJ : startJ+noChans-1, : ) = &
                & lowerWeight(mif)*kBit( startL : startL+noChans-1, : ) + &
                & upperWeight(mif)*kBit( startU : startU+noChans-1, : )
            end do

            if ( any ( l2pcBlock%kind == &
              & (/ M_Column_Sparse, M_Banded /) ) ) &
              & call deallocate_test ( dense, 'dense', ModuleName )
          end if                        ! Any matrix here?
        end if                          ! do derivatives?
      end do                            ! End loop over xStar Profiles

      if ( doDerivatives ) then         ! Destroy working arrays
        call deallocate_test ( mifPointingsLower, &
          & 'mifPointingsLower', ModuleName )
        call deallocate_test ( mifPointingsUpper, &
          & 'mifPointingsUpper', ModuleName )
        call deallocate_test ( lowerWeight, &
          & 'lowerWeight', ModuleName )
        call deallocate_test ( upperWeight, &
          & 'upperWeight', ModuleName )
      end if
      ! Compute this instance of deltaX
      deltaX%quantities(qtyInd)%values = &
        & xP%quantities(qtyInd)%values - &
        & l2pc%col%vec%quantities(qtyInd)%values

    end do                              ! End loop over quantities

    ! Now compute yP

    call cloneVector( yp, l2pc%row%vec )
    call MultiplyMatrixVectorNoT ( l2pc, deltaX, yP )

    yP = yP + l2pc%row%vec

    ! Now we interpolate yP to ptan

    call allocate_test( ypMapped, radInL2PC%template%noSurfs, &
      & noChans, 'ypMapped', ModuleName )
    call allocate_test( resultMapped, radiance%template%noSurfs, &
      & noChans, 'resultMapped', ModuleName )
    call allocate_test( dyByDx, radiance%template%noSurfs, &
      & noChans, 'dyByDX', ModuleName )

    yPmapped = transpose ( &
      & reshape ( yp%quantities(1)%values(:,1), &
      &           (/radInL2PC%template%noChans, radInL2PC%template%noSurfs/) ) )

    call InterpolateValues ( &
      & xStarPtan%values(:,1), &        ! OldX
      & yPmapped, &                     ! OldY
      & ptan%values(:,maf), &           ! NewX
      & resultMapped, &                 ! NewY
      & 'Spline', &                     ! use spline
      & extrapolate='Constant', &       ! dont extrapolate, clamp
      & dyByDx=dyByDx )

    ! For the moment, overwrite, may make it an addition later for unfolded
    ! cases

    radiance%values(:,maf) = reshape(transpose(resultMapped),&
      & (/radiance%template%instanceLen/))

    ! Put ptan derivatives here. !?????????
    if ( present( Jacobian ) .and. ptanInFirst ) then
      colJBlock = FindBlock ( Jacobian%col, ptan%index, maf )
      jBlock => Jacobian%block( rowJBlock, colJBlock )
      select case (jBlock%kind)
      case (m_absent)
        call CreateBlock ( Jacobian, rowJBlock, colJBlock, m_banded, &
          &   noMIFs*noChans )
        jBlock%values = 0.0_r8
        do mif = 1, noMIFs
          jBlock%r1(mif) = 1 + noChans * (mif-1)
          jBlock%r2(mif) = noChans * mif
        end do
      case (m_banded)
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName,&
          & 'Wrong matrix type for ptan derivative')
      end select
      jBlock%values(:,1) = reshape(transpose(dyByDx), &
        & (/radiance%template%instanceLen/))
    endif
d541 1
a541 6
    call DestroyVectorInfo ( xP )
    call DestroyVectorInfo ( deltaX )
    call Deallocate_test ( closestInstances, 'closestInstances', ModuleName )
    call Deallocate_test ( dyByDx, 'dyByDx', ModuleName)
    call Deallocate_test ( resultMapped, 'resultMapped', ModuleName )
    call Deallocate_test ( ypMapped, 'ypMapped', ModuleName )
d549 4
@


1.6
log
@Another interim version
@
text
@d17 4
a20 1
  use MatrixModule_1, only:  MATRIX_T, MULTIPLYMATRIXVECTORNOT, DUMP
d24 1
a24 1
  use MLSNumerics, only: INTERPOLATEVALUES
d39 1
a39 1
       "$Id: LinearizedForwardModel_m.f90,v 1.5 2001/04/28 04:40:56 livesey Exp $"
a58 1
    integer :: MAF                      ! Major frame to do
d61 2
d64 1
d66 5
d72 6
a78 1
    integer :: XINSTANCE                ! Instance in x corresponding to xStarInstance
d82 1
d85 2
d94 3
d100 2
d108 4
a111 1
    type(Matrix_T), pointer :: L2PC       ! The l2pc to use
d121 2
d127 1
d139 4
d153 6
d168 13
d234 2
d238 41
a289 12
        ! Do we need derivatives for this?
        doDerivatives = .true.
        if ( .not. foundInFirst ) doDerivatives = .false.
        if (doDerivatives .and. (l2pcQ%template%quantityType==l_temperature) ) &
          & doDerivatives = forwardModelConfig%temp_der
        if (doDerivatives .and. (l2pcQ%template%quantityType==l_vmr) ) then
          doDerivatives = forwardModelConfig%atmos_der
          if ( doDerivatives .and. .not. any (l2pcQ%template%molecule == &
            & pack(ForwardModelConfig%molecules, &
            &      ForwardModelConfig%moleculeDerivatives))) &
            & doDerivatives = .false.
        end if
d293 62
a354 4
          !??????????? Code here.
        endif
      end do
      ! End loop over profiles
a359 5
      !???? SPECIAL TESTS, NJL
      if ( l2pcQ%template%quantityType == l_Temperature ) then
        deltaX%quantities(qtyInd)%values(max(1,l2pcQ%template%noSurfs-maf):,:) = 0.0
      endif

a370 7
    ptan => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra, &
      & quantityType = l_ptan, &
      & instrumentModule = radiance%template%instrumentModule )

    xStarPtan => GetVectorQuantityByType ( l2pc%col%vec, &
      & quantityType = l_ptan )

d372 1
a372 1
      & radInL2PC%template%noChans, 'ypMapped', ModuleName )
d374 1
a374 1
      & radInL2PC%template%noChans, 'resultMapped', ModuleName )
d376 1
a376 1
      & radInL2PC%template%noChans, 'dyByDX', ModuleName )
d398 20
d432 2
@


1.5
log
@Another interim version.
@
text
@d22 1
a22 1
  use VectorsModule, only: assignment(=), OPERATOR(-),&
d25 1
a25 1
    & VECTORVALUE_T, VECTORTEMPLATE_T
d36 1
a36 1
       "$Id: LinearizedForwardModel_m.f90,v 1.4 2001/04/28 01:54:54 livesey Exp $"
d90 1
a131 1
      print*,'Doing l2pc quantity:',qtyInd
a133 5
      call display_string(lit_indices(l2pcQ%template%quantityType), &
        & advance='yes')
      if (l2pcQ%template%quantityType == l_vmr) &
        & call display_string(lit_indices(l2pcQ%template%molecule), &
        &    advance='yes')
d219 6
a224 1
    end do
a228 8
    print*,'Got to the multiply'
    do qtyInd = 1, size(yp%quantities)
      print*,qtyInd,&
        & yp%quantities(qtyInd)%template%noInstances, &
        & yp%quantities(qtyInd)%template%instanceLen, &
        & shape(yp%quantities(qtyInd)%values )
    end do
    print*,'OK doing it'
d230 2
a231 1
    print*,'Survived the multiply'
d239 3
a241 2
    print*,0
    
a247 1
    print*,1
a251 1
    print*,2
d254 6
a259 6
      & radInL2PC%template%surfs(:,1), & ! OldX
      & yPmapped, &                      ! OldY
      & ptan%values(:,maf), &            ! NewX
      & resultMapped, &                  ! NewY
      & 'Spline', &                      ! use spline
      & extrapolate='Constant', &        ! dont extrapolate, clamp
a261 3
    print*,3


d264 1
a266 3
    print*,'Result:'
    call dump ( radiance%values(:,maf) )
    stop
d277 2
d283 3
@


1.4
log
@Interim, non working but compiling version
@
text
@d36 1
a36 1
       "$Id: LinearizedForwardModel_m.f90,v 1.3 2001/04/27 17:35:42 livesey Exp $"
a90 3
    type(QuantityTemplate_T) :: yP_QT   ! Quantity template for yPrime
    type(VectorTemplate_T) :: yP_T      ! Vector template for yPrime

a118 14
    ! Create a boring vector containing only this MAF for this band but with
    ! the surfaces from the l2pc file. For speed, we'll do this by hand
    ! quantity template first
    yP_qt%noSurfs = radInL2PC%template%noSurfs
    yP_qt%noInstances = 1
    yP_qt%noChans = radiance%template%noChans
    yP_qt%instanceLen = yP_qt%noSurfs*yP_qt%noChans

    ! Create a boring vector template for this
    call ConstructVectorTemplate ( 0, (/yp_qt/), (/1/), yP_t )

    ! Finally, create a yPrime vector
    yp = CreateVector ( 0, yP_t, (/yp_qt/) )

d228 1
d230 7
d294 3
@


1.3
log
@An interim version for some testing.
@
text
@d12 1
a12 1
  use L2PC_m, only: L2PC_T, L2PCDATABASE
d36 1
a36 1
       "$Id: LinearizedForwardModel_m.f90,v 1.2 2001/04/26 23:54:32 livesey Exp $"
d85 1
a85 1
    type(L2PC_T), pointer :: L2PC       ! The l2pc to use
a117 2
!    print*,'Before l2pc forward model:'
!    call dump (l2pc%kStar)
d119 1
a119 1
    radInl2pc => GetVectorQuantityByType (l2pc%yStar, quantityType=l_radiance, &
d138 1
a138 1
    call cloneVector ( xP, l2pc%xStar )
d146 1
a146 1
    do qtyInd = 1, size ( l2pc%xStar%quantities )
d150 1
a150 1
      l2pcQ => l2pc%xStar%quantities(qtyInd)
d239 1
a239 1
        & l2pc%xStar%quantities(qtyInd)%values
a243 11
    print*,'Testing earlier:',&
      & associated(l2pc%xStar%template, l2pc%kStar%col%vec%template), &
      & associated(l2pc%yStar%template, l2pc%kStar%row%vec%template)
    print*,'Just testing:', associated (deltaX%template, l2pc%kStar%col%vec%template)
    print*,'One more test:',&
      & associated(l2pc%xStar%template), associated(l2pc%kStar%col%vec%template), &
      & associated(l2pc%yStar%template), associated(l2pc%kStar%row%vec%template)

    l2pc%kStar%col%vec%template => deltaX%template
    print*,"Now, having forced it:",&
      & associated(deltaX%template, l2pc%kStar%col%vec%template)
d245 3
a247 1
    call MultiplyMatrixVectorNoT ( l2pc%kStar, deltaX, yP )
d254 2
d263 1
d268 1
d279 3
d303 3
@


1.2
log
@Interim version
@
text
@d17 1
a17 1
  use MatrixModule_1, only:  MATRIX_T, MULTIPLYMATRIXVECTORNOT
d36 1
a36 1
       "$Id: LinearizedForwardModel_m.f90,v 1.1 2001/04/25 20:49:27 vsnyder Exp $"
d118 2
d250 8
d307 3
@


1.1
log
@Initial commit
@
text
@d9 20
a28 5
  use L2PC_m, only: L2PC_T
  use MatrixModule_1, only: CopyMatrix, DestroyMatrix, Matrix_T, &
    & MultiplyMatrixVectorNoT
  use VectorsModule, only: assignment(=), CopyVector, DestroyVectorInfo, &
    & operator(-), Vector_T
d36 1
a36 1
       "$Id: $"
d39 1
a39 1
    & "$RCSfile: $"
d45 248
a292 29
  subroutine LinearizedForwardModel ( L2PC, State, Radiance, Jacobian )
    type(l2PC_T), intent(in) :: L2PC
    type(vector_T), intent(in) :: State
    type(vector_T), intent(inout) :: Radiance
    type(matrix_T), intent(inout) :: Jacobian

    type(matrix_T) :: KP                ! Intermediate Jacobian
    type(vector_T) :: XP, YP            ! Intermediate State and Radiance

    ! XP = Appropriate subset of State
    ! XP = XP - x*
    xp = xp - l2pc%xStar
    ! YP = y* + K* \times ( XP - x*)
    call copyVector ( yp, l2pc%yStar, clone=.true. )
    call MultiplyMatrixVectorNoT ( l2pc%kStar, xp, yp, update=.true. )
    ! KP = K*
    call copyMatrix ( kp, l2pc%kStar )

    ! Interpolate YP to the ptans for X and the correct MAF.
    ! Fill Jacobian for these ptans with free output from the
    !  interpolator.
    ! Fill the rest of Jacobian by interpolating KP to the ptans for
    !  X and the correct MAF.

    call copyVector ( radiance, yp )

    call destroyMatrix ( kp )
    call destroyVectorInfo ( xp )
    call destroyVectorInfo ( yp )
d296 4
a299 1
! $Log: $
@

