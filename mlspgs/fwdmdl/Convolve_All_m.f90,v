head	2.27;
access;
symbols
	v5-02-NRT-19:2.27
	v6-00:2.27
	v5-02-NRT-18:2.27
	v5-02:2.27
	v5-01-NRT-17:2.27
	v5-01-NRT-16:2.27
	v5-01-NRT-15:2.27
	v5-01-NRT-14:2.27
	neuralnetworks-1-0:2.27.0.8
	cfm-single-freq-0-1:2.27.0.6
	v5-01:2.27
	v5-00:2.27
	v4-23-TA133:2.27.0.4
	mus-emls-1-70:2.27.0.2
	rel-1-0-englocks-work:2.26.0.2
	VUMLS1-00:2.24
	VPL1-00:2.24
	V4-22-NRT-08:2.24
	VAM1-00:2.24
	V4-21:2.24.0.2
	V4-13:2.24
	V4-12:2.24
	V4-11:2.24
	V4-10:2.24
	V3-43:2.11
	M4-00:2.21
	V3-41:2.11
	V3-40-PlusGM57:2.11.0.2
	V2-24-NRT-04:2.5
	V3-33:2.16
	V2-24:2.5
	V3-31:2.16
	V3-30-NRT-05:2.14
	cfm-01-00:2.11
	V3-30:2.11
	V3-20:2.11
	V3-10:2.7
	V2-23-NRT-02:2.5
	V2-23:2.5
	V2-22-NRT-01:2.5
	V2-22:2.5
	V2-21:2.5
	V2-20:2.5
	V2-11:2.4
	V2-10:2.4
	V2-00:2.4;
locks; strict;
comment	@# @;


2.27
date	2018.05.14.23.43.16;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2017.10.31.23.49.35;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2017.03.31.00.47.10;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2014.01.09.00.26.39;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2013.08.02.01.24.06;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2013.06.12.02.19.16;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2012.07.10.04.10.59;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2012.07.07.00.14.33;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2012.07.06.21.30.31;	author yanovsky;	state Exp;
branches;
next	2.18;

2.18
date	2011.12.17.00.35.29;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2011.08.20.00.44.32;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2010.11.09.01.01.25;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2010.10.13.22.18.22;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2010.08.27.05.53.23;	author yanovsky;	state Exp;
branches;
next	2.13;

2.13
date	2010.07.27.01.12.56;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2010.07.18.23.39.19;	author yanovsky;	state Exp;
branches;
next	2.11;

2.11
date	2010.02.05.03.18.11;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2009.12.22.03.23.05;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2009.12.15.03.17.07;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2009.11.17.23.40.08;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2008.08.27.19.56.51;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2006.08.02.19.55.33;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2005.08.06.01.40.45;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2005.08.03.18.03.20;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2005.07.08.00.12.11;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2005.07.06.02.16.54;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.27
log
@Move Hessians stuff to Hessians_m
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Convolve_All_m

  ! Subprograms CONVOLVE_... add the effects of antenna smearing.
  ! Call FOV_Convolve_Setup before them, and FOV_Convolve_Teardown after them.

  ! Subprograms INTERPOLATE_... simply interpolate from the calculation grid
  ! to the output grid.  Call InterpolateArraySetup with METHOD='S',
  ! EXTRAPOLATE='C', dyByDx=ptan_der before them, and InterpolateArrayTeardown
  ! after them.

  implicit NONE
  private
  public :: Convolve_Other_Deriv, Convolve_Radiance, Convolve_Temperature_Deriv
  public :: Convolve_Radiance_Normalization, Convolve_Temperature_Deriv_Normalization
  public :: Interpolate_Radiance, Interpolate_Other_Deriv
  public :: Interpolate_Temperature_Deriv, LoadMatrixValue
  public :: Store_Other_Deriv, Store_Temperature_Deriv

  interface Store_Other_Deriv
    module procedure Store_Other_Deriv_1D, Store_Other_Deriv_2D
  end interface

  interface Store_Temperature_Deriv
    module procedure Store_Temperature_Deriv_1D, Store_Temperature_Deriv_2D
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Convolve_All_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! ---------------------------------  Convolve_Radiance  -----
  subroutine Convolve_Radiance ( Convolve_Support, MAF, Channel, Rad_In, &
           & SbRatio, Update, Ptan, Radiance, MIF_Times, DeadTime, &
           & Jacobian, RowFlags, dh_dz_out, dx_dh_out, ptan_Der, Rad_FFT )

  ! Convolve the radiance, and maybe dRadiance/dPtan, with the antenna pattern

    use FOV_Convolve_m, only: Convolve_Support_t, FOV_Convolve_1d
    use MatrixModule_1, only: FindBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use VectorsModule, only: VectorValue_T

    ! Required inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(rp), intent(in) :: Rad_In(:)   ! input radiances
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update       ! "add to radiance, don't overwrite"
    type(vectorvalue_t), intent(in) :: PTAN ! Only to get some indices
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.

    ! Output
    type (VectorValue_T), intent(inout) :: Radiance   ! Output radiances

    ! Optional if PTan derivative processed.  All or none.
    type (Matrix_t), optional, intent(inout) :: Jacobian
    logical, optional, intent(inout) :: rowFlags(:) ! Flag to calling code
    real(rp), optional, intent(in) :: dh_dz_out(:) ! dh/dz on the output pointing grid
    real(rp), optional, intent(in) :: dx_dh_out(:) ! dx/dh on the output pointing grid
    logical, optional, intent(in) :: Ptan_der ! "Process PTAN derivatives"

    ! Temperature derivatives need this
    real(r8), intent(out), optional :: Rad_FFT(:) ! Convolved radiances on FFT grid

    logical :: my_ptan_der
    integer :: Col, NoChans, NoPtan, Row
    real(rv), pointer :: MIF_Times_for_MAF(:)
    real(r8) :: SRad(ptan%template%noSurfs), di_dx(ptan%template%noSurfs)

    my_ptan_der = .false.
    if ( present ( ptan_der ) ) my_ptan_der = ptan_der

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans
    noPtan = ptan%template%nosurfs

    ! Convolve the radiances (and maybe the derivative w.r.t. PTan):

    if ( my_ptan_der ) then ! Convolve radiance and get di_dx
      call fov_convolve_1d ( convolve_support, rad_in, MIF_Times_for_MAF, DeadTime, &
        & SRad, dRad_dx_out=di_dx, rad_fft_out=rad_fft )
    else
      call fov_convolve_1d ( convolve_support, rad_in, MIF_Times_for_MAF, DeadTime, &
        & SRad, rad_fft_out=rad_fft )
    end if

    ! Load the Radiance values into the Radiance structure:

    call loadVectorValue ( sRad, Radiance%values(channel::noChans,maf), &
      & sbRatio, update )

    if ( my_ptan_der ) then ! Jacobian better be present!

      ! First, find index location in Jacobian and set the derivative flags

      row = FindBlock( Jacobian%row, radiance%index, maf )
      rowFlags(row) = .TRUE.

      ! Compute dI/dPtan using the chain rule:
      SRad = di_dx * dx_dh_out * dh_dz_out

      col = FindBlock ( Jacobian%col, ptan%index, maf )
      call getBandedBlock ( jacobian, row, col, noChans, noPtan )
      call loadMatrixValue ( sRad, Jacobian%block(row,col)%values(channel::noChans,1), &
        & sbRatio, update )

    end if ! present(jacobian) .and. my_ptan_der

  end subroutine Convolve_Radiance

  ! ---------------------------------  Convolve_Temperature_Deriv  -----
  subroutine Convolve_Temperature_Deriv ( Convolve_Support, MAF, Channel, &
           & Rad_In, Rad_FFT, SbRatio, Update, Radiance, Temp, Grids_Tmp, &
           & surf_angle, MIF_Times, DeadTime, di_dT, dx_dT, d2x_dxdT, &
           & dxdt_tan, dxdt_surface, F_and_V, Jacobian, RowFlags )

    use Fov_Convolve_m, only: Convolve_Support_T, &
      & FOV_Convolve_Temp_Derivs
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(rp), intent(in) :: Rad_In(:)  ! input radiances
    real(r8), intent(in) :: Rad_FFT(:) ! convolved radiance on FFT grid
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type (vectorvalue_t), intent(in) :: Temp     ! Only to get some indices
    type (Grids_T), intent(in) :: Grids_Tmp      ! Temperature's grids, etc.
    real(rp), intent(in) :: Surf_angle ! An angle that defines the
    !                      Earth surface.
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: dI_dT(:,:) ! derivative of radiance wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: dx_dT(:,:) ! derivative of angle wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: d2x_dxdT(:,:) ! 2nd derivative wrt angle and
    !                      temperature on chi_in
    real(rp), intent(in) :: dxdT_tan(:,:) ! derivative of angle wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: dxdT_surface(:,:) ! derivative of angle
    !                      wrt temperature at the surface
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Local variables
    integer :: Cols(grids_tmp%windowStart(1):grids_tmp%windowFinish(1))
    integer :: Col, JF, K, NoChans, NoPtan, N_T_Zeta, Row, SV_I
    real(r8) :: dRad_dT_out(size(convolve_support%del_chi_out), &
                & temp%template%noSurfs*( &
                  & grids_tmp%windowFinish(1) - grids_tmp%windowStart(1) + 1))
    real(rv), pointer :: MIF_Times_for_MAF(:)

    ! Start here

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans
    noPtan = size(convolve_support%del_chi_out)
    n_t_zeta = temp%template%noSurfs

    call fov_convolve_temp_derivs ( convolve_support, rad_in, &
      & rad_fft, surf_angle, MIF_Times_for_MAF, DeadTime, dI_dT, dx_dT, &
      & d2x_dxdT, dxdt_tan - SPREAD(dxdt_surface(1,:),1,noPtan), &
      & grids_tmp%deriv_flags, dRad_dT_out )

    ! Load the Temperature derivative values into the Jacobian.
    ! First, find index location in Jacobian and set the derivative flags.

    row = FindBlock( Jacobian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      cols(jf) = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, cols(jf), 'temperature' )

    end do

    sv_i = 0
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      if ( allocated(f_and_v(1)%vertices) ) then

        do k = 1, n_t_zeta

          ! Load derivatives for this (zeta & phi) if needed :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            col = cols(f_and_v(k)%vertices(jf))
            call loadMatrixValue ( dRad_dT_out(:,sv_i), &
              & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
              & update )
          end if
        end do

      else

        do k = 1, n_t_zeta

          ! Load derivatives for this (zeta & phi) if needed :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) &
            & call loadMatrixValue ( dRad_dT_out(:,sv_i), &
              & jacobian%block(row,cols(jf))%values(channel::noChans,k), sbRatio, &
              & update )
        end do

      end if

    end do

  end subroutine Convolve_Temperature_Deriv

  ! ---------------------------------  Convolve_Radiance_Normalization  -----
  ! Convolves Radiance, similar to Convolve_Radiance subroutine.
  ! This implemenation also computes Rad_Diff and Rad_Diff_FFT that 
  ! are required for Convolve_Temperature_Deriv_Normalization subroutine.

  subroutine Convolve_Radiance_Normalization ( Convolve_Support, MAF, Channel, Rad_In, &
           & SbRatio, Update, Ptan, Radiance, MIF_Times, DeadTime, &
           & Jacobian, RowFlags, dh_dz_out, dx_dh_out, ptan_Der, Rad_FFT, Rad_Diff, Rad_Diff_FFT )

  ! Convolve the radiance, and maybe dRadiance/dPtan, with the antenna pattern

    use FOV_Convolve_m, only: Convolve_Support_t, FOV_Convolve_1d
    use MatrixModule_1, only: FindBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use MLSNumerics, only: InterpolateValues    ! IGOR
    use VectorsModule, only: VectorValue_T

    ! Required inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(rp), intent(in) :: Rad_In(:)   ! input radiances, I
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update       ! "add to radiance, don't overwrite"
    type(vectorvalue_t), intent(in) :: PTan ! Only to get some indices
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.

    ! Output
    type (VectorValue_T), intent(inout) :: Radiance   ! Output radiances, IA = I*G

    ! Optional if PTan derivative processed.  All or none.
    type (Matrix_t), optional, intent(inout) :: Jacobian
    logical, optional, intent(inout) :: rowFlags(:) ! Flag to calling code
    real(rp), optional, intent(in) :: dh_dz_out(:) ! dh/dz on the output pointing grid
    real(rp), optional, intent(in) :: dx_dh_out(:) ! dx/dh on the output pointing grid
    logical, optional, intent(in) :: Ptan_der ! "Process PTAN derivatives"

    ! Temperature derivatives need this    IGOR - in new version, rad_fft will not be needed,
    !        but rad_diff (= I-IA) and rad_diff_FFT (= FFT(I-IA)) will be 
    real(r8),             intent(out)  , optional :: Rad_FFT(:)      ! FFT(I), on FFT grid
    real(rp),             intent(out)  , optional :: Rad_Diff(:)     ! Output radiance differences, I-IA    ! IGOR
    real(r8),             intent(out)  , optional :: Rad_Diff_FFT(:) ! FFT(Rad_Diff) = FFT(I-IA)            ! IGOR

    logical :: my_ptan_der
    integer :: Col, NoChans, NoPtan, Row
    real(rv), pointer :: MIF_Times_for_MAF(:)
    real(r8) :: SRad(ptan%template%noSurfs), di_dx(ptan%template%noSurfs)
    real(r8) :: SRad_out(size(rad_in))                             ! IGOR
    real(r8) :: SRad_temp(ptan%template%noSurfs)                   ! IGOR

    my_ptan_der = .false.
    if ( present ( ptan_der ) ) my_ptan_der = ptan_der

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans
    noPtan = ptan%template%nosurfs

    ! Convolve the radiances (and maybe the derivative w.r.t. PTan):

    if ( my_ptan_der ) then ! Convolve radiance and get di_dx
      call fov_convolve_1d ( convolve_support, rad_in, MIF_Times_for_MAF, DeadTime, &
        & SRad, dRad_dx_out=di_dx, rad_fft_out=rad_fft )
    else
      call fov_convolve_1d ( convolve_support, rad_in, MIF_Times_for_MAF, DeadTime, &
        & SRad, rad_fft_out=rad_fft )
    end if

    ! Load the Radiance values into the Radiance structure:

    call loadVectorValue ( sRad, Radiance%values(channel::noChans,maf), &
      & sbRatio, update )

    ! IGOR
    call InterpolateValues ( convolve_support%del_chi_out, sRad, convolve_support%del_chi_in, sRad_out, &
                           & METHOD='S', extrapolate='C' )

    ! I_diff = I - IA                 ! IGOR:
    
    rad_diff = rad_in - sRad_out      ! IGOR

    ! IGOR:
    if ( my_ptan_der ) then ! Get FFT(I-IA)
      call fov_convolve_1d ( convolve_support, rad_diff, MIF_Times_for_MAF, DeadTime, &
        & sRad_temp, rad_fft_out=Rad_Diff_FFT )
    end if

    ! Load the I-IA values into the Radiance_Diff structure:

    !call loadVectorValue ( rad_diff, Radiance_diff%values(channel::noChans,maf), &
    !  & sbRatio, update )          ! IGOR


    if ( my_ptan_der ) then ! Jacobian better be present!

      ! First, find index location in Jacobian and set the derivative flags

      row = FindBlock( Jacobian%row, radiance%index, maf )
      rowFlags(row) = .TRUE.

      ! Compute dI/dPtan using the chain rule:
      SRad = di_dx * dx_dh_out * dh_dz_out

      col = FindBlock ( Jacobian%col, ptan%index, maf )
      call getBandedBlock ( jacobian, row, col, noChans, noPtan )
      call loadMatrixValue ( sRad, Jacobian%block(row,col)%values(channel::noChans,1), &
        & sbRatio, update )

    end if ! present(jacobian) .and. my_ptan_der

  end subroutine Convolve_Radiance_Normalization

  ! ---------------------------------  Convolve_Temperature_Deriv_Normalization  -----
  ! Performs convolution of Temperature derivatives (with normalization)
  subroutine Convolve_Temperature_Deriv_Normalization ( Convolve_Support, MAF, Channel, &
           & Rad_Diff, Rad_Diff_FFT, SbRatio, Update, Radiance, Temp, Grids_Tmp, &
           & surf_angle, MIF_Times, DeadTime, di_dT, dx_dT, d2x_dxdT, &
           & dxdt_tan, dxdt_surface, F_and_V, Jacobian, RowFlags )

    use Fov_Convolve_m, only: Convolve_Support_T, &
!     & FOV_Convolve_Temp_Derivs, &
      & FOV_Convolve_Temp_Derivs_Normalization
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: CHANNEL
    real(rp), intent(in) :: Rad_Diff(:)  ! Input radiance differences, I-IA        ! IGOR
    real(r8), intent(in) :: Rad_Diff_FFT(:) ! FFT(Rad_Diff) = FFT(I-IA)            ! IGOR
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type (vectorvalue_t), intent(in) :: Temp     ! Only to get some indices
    type (Grids_T), intent(in) :: Grids_Tmp      ! Temperature's grids, etc.
    real(rp), intent(in) :: Surf_angle ! An angle that defines the
    !                      Earth surface.
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: dI_dT(:,:) ! derivative of radiance wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: dx_dT(:,:) ! derivative of angle wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: d2x_dxdT(:,:) ! 2nd derivative wrt angle and
    !                      temperature on chi_in
    real(rp), intent(in) :: dxdT_tan(:,:) ! derivative of angle wrt
    !                      temperature on chi_in
    real(rp), intent(in) :: dxdT_surface(:,:) ! derivative of angle
    !                      wrt temperature at the surface
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Local variables
    integer :: Cols(grids_tmp%windowStart(1):grids_tmp%windowFinish(1))
    integer :: Col, JF, K, NoChans, NoPtan, N_T_Zeta, Row, SV_I
    real(r8) :: dRad_dT_out(size(convolve_support%del_chi_out), &
                & temp%template%noSurfs*( &
                  & grids_tmp%windowFinish(1) - grids_tmp%windowStart(1) + 1))
    real(rv), pointer :: MIF_Times_for_MAF(:)

    ! Start here

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans
    noPtan = size(convolve_support%del_chi_out)
    n_t_zeta = temp%template%noSurfs

    !call fov_convolve_temp_derivs ( convolve_support, rad_in, &
    !  & rad_fft, surf_angle, MIF_Times_for_MAF, DeadTime, dI_dT, dx_dT, &
    !  & d2x_dxdT, dxdt_tan - SPREAD(dxdt_surface(1,:),1,noPtan), &
    !  & grids_tmp%deriv_flags, dRad_dT_out )                          ! IGOR

    call fov_convolve_temp_derivs_normalization ( convolve_support, rad_diff, &
      & rad_diff_fft, surf_angle, MIF_Times_for_MAF, DeadTime, dI_dT, dx_dT, &
      & d2x_dxdT, dxdt_tan - SPREAD(dxdt_surface(1,:),1,noPtan), &
      & grids_tmp%deriv_flags, dRad_dT_out )   ! IGOR

    ! Load the Temperature derivative values into the Jacobian.
    ! First, find index location in Jacobian and set the derivative flags.

    row = FindBlock( Jacobian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      cols(jf) = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, cols(jf), 'temperature' )

    end do

    sv_i = 0
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      if ( allocated(f_and_v(1)%vertices) ) then

        do k = 1, n_t_zeta

          ! Load derivatives for this (zeta & phi) if needed :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            col = cols(f_and_v(k)%vertices(jf))
            call loadMatrixValue ( dRad_dT_out(:,sv_i), &
              & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
              & update )
          end if
        end do

      else

        do k = 1, n_t_zeta

          ! Load derivatives for this (zeta & phi) if needed :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) &
            & call loadMatrixValue ( dRad_dT_out(:,sv_i), &
              & jacobian%block(row,cols(jf))%values(channel::noChans,k), sbRatio, &
              & update )
        end do

      end if

    end do

  end subroutine Convolve_Temperature_Deriv_Normalization

  ! ----------------------------------------  Convolve_OtherDeriv  -----
  subroutine Convolve_Other_Deriv ( Convolve_Support, MAF, Channel, &
             & SbRatio, Update, Radiance, Qtys, Grids_f, MIF_Times, &
             & DeadTime, dI_df, F_and_V, Jacobian, RowFlags, &
             & ExtraJacobian, Derivs )

    use ForwardModelConfig, only: QtyStuff_T
    use Fov_Convolve_m, only: Convolve_Support_T, &
      & FOV_Convolve_2d
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type(QtyStuff_T), intent(in) :: Qtys(:)
    type (Grids_T), intent(in) :: Grids_f
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: dI_df(:,:) ! mixing ratio derivatives or any
    !                                    parameter for which a simple
    !                                    convolution will suffice
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout), target :: Jacobian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Optional output
    type (Matrix_t), intent(inout), optional, target :: ExtraJacobian

    ! Optional input
    logical, intent(in), optional :: Derivs(:) ! Same size as Qtys; if not
                                               ! present, do all columns.  Use
                                               ! in case grids_f%deriv_flags
                                               ! hasn't been set.

    ! Local variables
    integer :: Cols(minval(grids_f%windowStart(:),1):maxval(grids_f%windowFinish(:),1))
    integer :: Row, Col
    integer :: JF
    integer :: K
    integer :: NFZ    ! # frequency elements times # z elements in a specie
    integer :: NoChans
    integer :: SPS_I  ! species index
    integer :: SV_F   ! index of final element in a state vector
    real(r8) :: drad_df_out(size(convolve_support%del_chi_out), &
      &                     size(di_df,dim=2))
    real(rv), pointer :: MIF_Times_for_MAF(:)
    type (Matrix_t), pointer :: MyJacobian

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans

    ! do the convolution

    call fov_convolve_2d ( convolve_support, di_df, MIF_Times_for_MAF, DeadTime, &
      & grids_f%deriv_flags, drad_df_out )

    ! load derivatives into jacobian
    ! First, find index location in Jacobian and set the derivative flags

    row = FindBlock( Jacobian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    do sps_i = 1, size(qtys)

      if ( present(derivs) ) then
        if ( .not. derivs(sps_i) ) cycle
      end if

      if ( qtys(sps_i)%foundInFirst ) then
        myJacobian => jacobian
      else
        if ( .not. present(extraJacobian) ) cycle
        myJacobian => extraJacobian
      end if

      sv_f = grids_f%l_v(sps_i-1)
      nfz = (Grids_f%l_f(sps_i) - Grids_f%l_f(sps_i-1)) * &
          & (Grids_f%l_z(sps_i) - Grids_f%l_z(sps_i-1))

      do jf = Grids_f%windowStart(sps_i), Grids_f%windowfinish(sps_i)

        cols(jf) = FindBlock ( myJacobian%col, qtys(sps_i)%qty%index, jf)
        call getFullBlock ( myJacobian, row, cols(jf), 'atmospheric' )

      end do

      do jf = Grids_f%windowStart(sps_i), Grids_f%windowfinish(sps_i)

        if ( allocated(f_and_v(1)%vertices) ) then

          do k = 1, nfz

            ! load derivatives for this (zeta & phi) if needed:

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) then
              col = cols(f_and_v(k)%vertices(jf))
              call loadMatrixValue ( drad_df_out(:,sv_f), &
                & myJacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
                & update )
            end if
          end do

        else

          do k = 1, nfz

            ! load derivatives for this (zeta & phi) if needed:

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) &
              & call loadMatrixValue ( drad_df_out(:,sv_f), &
                & myJacobian%block(row,cols(jf))%values(channel::noChans,k), sbRatio, &
                & update )
          end do

        end if

      end do

    end do

  end subroutine Convolve_Other_Deriv

  ! ---------------------------------------  Interpolate_Radiance  -----
  subroutine Interpolate_Radiance ( Coeffs, MAF, Channel, Chi_In, Rad_In, &
           & SbRatio, Update, Ptan, Chi_Out, Radiance, MIF_Times, DeadTime, &
           & Jacobian, RowFlags, dh_dz_out, dx_dh_out, ptan_Der )

    ! Interpolate the radiance from Chi_In to Chi_Out, and maybe dI/dPTan too.

    use MatrixModule_1, only: FindBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use MLSNumerics, only: Coefficients, InterpolateValues
    use ScanAverage_m, only: ScanAverage
    use VectorsModule, only: VectorValue_T

    ! Required inputs
    type(coefficients(rp)), intent(in) :: Coeffs
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(rp), intent(in) :: Chi_In(:)  ! input pointing angles radians
    real(rp), intent(in) :: Rad_In(:)   ! input radiances
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update       ! "add to radiance, don't overwrite"
    type(vectorvalue_t), intent(in) :: PTan ! Only to get some indices
    real(rp), intent(in) :: Chi_Out(:) ! output pointing angles radians

    ! output
    type (VectorValue_T), intent(inout) :: RADIANCE   ! Output radiances
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.

    ! Optional if PTan derivative processed.  All or none.
    type (Matrix_t), optional, intent(inout) :: Jacobian
    logical, optional, intent(inout) :: rowFlags(:) ! Flag to calling code
    real(rp), optional, intent(in) :: dh_dz_out(:) ! dh/dz on the output pointing grid
    real(rp), optional, intent(in) :: dx_dh_out(:) ! dx/dh on the output pointing grid
    logical, optional, intent(in) :: Ptan_der ! "Process PTAN derivatives"

    logical :: my_ptan_der
    integer :: Col, NoChans, NoPtan, Row
    real(r8), dimension(ptan%template%noSurfs) :: SRad, dI_dx, Rad_Out
    real(rv), pointer :: MIF_Times_for_MAF(:)

    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)

    my_ptan_der = .false.
    if ( present ( ptan_der ) ) my_ptan_der = ptan_der

    noPtan = ptan%template%noSurfs
    noChans = radiance%template%noChans

    if ( my_ptan_der ) then
      row = FindBlock ( Jacobian%row, radiance%index, maf )
      rowFlags(row) = .TRUE.
      col = FindBlock ( Jacobian%col, ptan%index, maf )

      if ( associated(MIF_Times) ) then
        call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
          & chi_in, chi_out, rad_in, rad_out, dY_dX_out=di_dx )
      else
        call InterpolateValues ( coeffs, chi_in, rad_in, chi_out, rad_out, &
                               & METHOD='S', extrapolate='C', dyByDx=di_dx )
      end if

      ! Use the chain rule to compute dI/dPtan on the output grid:

      SRad = di_dx * dx_dh_out * dh_dz_out
      call getBandedBlock ( jacobian, row, col, noChans, noPtan )
      call loadMatrixValue ( sRad, Jacobian%block(row,col)%values(channel::noChans,1), &
                           & sbRatio, update )

    else

        if ( associated(MIF_Times) ) then
          call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
            & chi_in, chi_out, rad_in, rad_out )
        else
          call InterpolateValues ( coeffs, chi_in, rad_in, chi_out, rad_out, &
                                 & METHOD='S', extrapolate='C' )
        end if

    end if

    ! Load the Radiance values into the Radiance structure:

    call loadVectorValue ( rad_out, Radiance%values(channel::noChans,maf), &
                         & sbRatio, update )

  end subroutine Interpolate_Radiance

  ! ------------------------------  Interpolate_Temperature_Deriv  -----
  subroutine Interpolate_Temperature_Deriv ( Coeffs, MAF, Channel, Chi_In, &
           & SbRatio, Update, Chi_Out, Radiance, Temp, Grids_Tmp, &
           & MIF_Times, DeadTime, di_dT, F_and_V, Jacobian, RowFlags )

    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
    use MLSKinds, only: R8, RP, RV
    use MLSNumerics, only: Coefficients, InterpolateValues
    use Path_Representation_m, only: Facets_and_Vertices_t
    use ScanAverage_m, only: ScanAverage
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(coefficients(rp)), intent(in) :: Coeffs
    integer, intent(in) :: MAF
    integer, intent(in) :: CHANNEL
    real(rp), intent(in) :: Chi_In(:)  ! input pointing angles radians
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    real(rp), intent(in) :: Chi_Out(:) ! output pointing angles radians
    type (VectorValue_T), intent(in) :: RADIANCE ! Only to get some indices
    type (vectorvalue_t), intent(in) :: TEMP     ! Only to get some indices
    type (Grids_T), intent(in) :: Grids_Tmp      ! Temperature's grids, etc.
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: dI_dT(:,:) ! derivative of radiance wrt
    !                      temperature on chi_in
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Local variables
    integer :: Cols(grids_tmp%windowStart(1):grids_tmp%windowFinish(1))
    integer :: Col, JF, JZ, K, NoChans, Row, SV_I
    real(r8) :: dRad_dT_in(size(chi_in)), dRad_dT_out(size(chi_out))
    real(rv), pointer :: MIF_Times_for_MAF(:)

    ! Start here

    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)

    k = size(chi_in)
    noChans = radiance%template%noChans

    row = FindBlock ( Jacobian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      cols(jf) = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, cols(jf), 'temperature' )

    end do

    sv_i = 0
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      if ( allocated(f_and_v(1)%vertices) ) then

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            dRad_dT_in = di_dt(1:k,sv_i)
            if ( associated(MIF_Times) ) then
              call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
                & chi_in, chi_out, dRad_dT_in, dRad_dT_out )
            else
              call InterpolateValues ( coeffs, chi_in, dRad_dT_in, &
                                     & chi_out, dRad_dT_out, &
                                     & method = 'S', extrapolate = 'C' )
            end if
            col = cols(f_and_v(jz)%vertices(jf))
            call loadMatrixValue ( dRad_dT_out, &
              & jacobian%block(row,col)%values(channel::noChans,jz), sbRatio, &
              & update )
          end if

        end do

      else

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            dRad_dT_in = di_dt(1:k,sv_i)
            if ( associated(MIF_Times) ) then
              call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
                & chi_in, chi_out, dRad_dT_in, dRad_dT_out )
            else
              call InterpolateValues ( coeffs, chi_in, dRad_dT_in, &
                                     & chi_out, dRad_dT_out, &
                                     & method = 'S', extrapolate = 'C' )
            end if
            call loadMatrixValue ( dRad_dT_out, &
              & jacobian%block(row,cols(jf))%values(channel::noChans,jz), sbRatio, &
              & update )
          end if

        end do

      end if

    end do

  end subroutine Interpolate_Temperature_Deriv

  ! ------------------------------------  Interpolate_Other_Deriv  -----
  subroutine Interpolate_Other_Deriv ( Coeffs, MAF, Channel, Chi_In, &
             & SbRatio, Update, Chi_Out, Radiance, Qtys, Grids_f, &
             & MIF_Times, DeadTime, dI_df, F_and_V, Jacobian, RowFlags, Linear, &
             & Derivs, ExtraJacobian )

    use ForwardModelConfig, only: QtyStuff_T
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: R8, RP, RV
    use MLSNumerics, only: Coefficients, InterpolateValues
    use Path_Representation_m, only: Facets_and_Vertices_t
    use ScanAverage_m, only: ScanAverage
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(coefficients(rp)), intent(in) :: Coeffs
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(rp), intent(in) :: Chi_In(:)  ! input pointing angles radians
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    real(rp), intent(in) :: Chi_Out(:) ! output pointing angles radians
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type(QtyStuff_T), intent(in) :: Qtys(:)
    type (Grids_T), intent(in) :: Grids_f
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: dI_df(:,:) ! mixing ratio derivatives or any
    !                                    parameter for which a simple
    !                                    convolution will suffice
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout), target :: Jacobian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Optional inputs
    logical, intent(in), optional :: Linear ! "Use linear interpolation"
                                            ! Deafult true.
    logical, intent(in), optional :: Derivs(:) ! Same size as Qtys; if not
                                               ! present, do all columns.  Use
                                               ! in case grids_f%deriv_flags
                                               ! hasn't been set.
    ! Optional outputs
    type (Matrix_t), intent(inout), optional, target :: ExtraJacobian

    ! Local variables
    integer :: Cols(minval(grids_f%windowStart(:),1):maxval(grids_f%windowFinish(:),1))
    integer :: Col, IS, JF, K, NFZ, NoChans, Row, SV_F
    type (Matrix_t), pointer :: MyJacobian
    logical :: MyLinear

    real(r8) :: dRad_df_in(size(chi_in)), dRad_df_out(size(chi_out))
    real(rv), pointer :: MIF_Times_for_MAF(:)

    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)

    myLinear = .true.
    if ( present(linear) ) myLinear = linear

    noChans = Radiance%template%noChans

    row = FindBlock ( Jacobian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    do is = 1, size(qtys)

      if ( present(derivs) ) then
        if ( .not. derivs(is) ) cycle
      end if

      if ( qtys(is)%foundInFirst ) then
        myJacobian => jacobian
      else
        if ( .not. present(extraJacobian) ) cycle
        myJacobian => extraJacobian
      end if

      sv_f = grids_f%l_v(is-1)
      nfz = (Grids_f%l_f(is) - Grids_f%l_f(is-1)) * &
          & (Grids_f%l_z(is) - Grids_f%l_z(is-1))

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        cols(jf) = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row, cols(jf), 'atmospheric' )

      end do

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        if ( allocated(f_and_v(1)%vertices) ) then

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) then
              dRad_df_in = di_df(:,sv_f)
              if ( associated(MIF_Times) ) then
                call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
                  & chi_in, chi_out, dRad_df_in, dRad_df_out )
              else if ( myLinear ) then
                call InterpolateValues ( chi_in, dRad_df_in, &
                                       & chi_out, dRad_df_out, &
                                       & method = 'L', extrapolate = 'C' )
              else
                call InterpolateValues ( coeffs, chi_in, dRad_df_in, &
                                       & chi_out, dRad_df_out, &
                                       & method = 'S', extrapolate = 'C' )
              end if
              col = cols(f_and_v(k)%vertices(jf))
              call loadMatrixValue ( dRad_df_out, &
                & myJacobian%block(row,col)%values(channel::noChans,k), &
                & sbRatio, update )
            end if

          end do

        else

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) then
              dRad_df_in = di_df(:,sv_f)
              if ( associated(MIF_Times) ) then
                call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
                  & chi_in, chi_out, dRad_df_in, dRad_df_out )
              else if ( myLinear ) then
                call InterpolateValues ( chi_in, dRad_df_in, &
                                       & chi_out, dRad_df_out, &
                                       & method = 'L', extrapolate = 'C' )
              else
                call InterpolateValues ( coeffs, chi_in, dRad_df_in, &
                                       & chi_out, dRad_df_out, &
                                       & method = 'S', extrapolate = 'C' )
              end if
              call loadMatrixValue ( dRad_df_out, &
                & myJacobian%block(row,cols(jf))%values(channel::noChans,k), &
                & sbRatio, update )
            end if

          end do

        end if

      end do

    end do

  end subroutine Interpolate_Other_Deriv

  ! ---------------------------------  Store_Temperature_Deriv_1D  -----
  subroutine Store_Temperature_Deriv_1d ( MAF, Row_0, Radiance, Temp, &
                                        & Grids_Tmp, di_dT, F_and_V, Jacobian )

    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: RP
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    integer, intent(in) :: MAF
    integer, intent(in) :: Row_0 ! within the block, (channel-1)*noChans+zeta
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type (Vectorvalue_t), intent(in) :: Temp     ! Only to get some indices
    type (Grids_T), intent(in) :: Grids_Tmp      ! Temperature's grids, etc.
    real(rp), intent(in) :: dI_dT(:) ! derivative of radiance in Row_0 wrt
    !                                  temperature state vector coordinates
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian

    ! Local variables
    integer :: Cols(grids_tmp%windowStart(1):grids_tmp%windowFinish(1))
    integer :: Col, JF, JZ, Row_1, SV_I

    ! Start here

    row_1 = FindBlock ( Jacobian%row, radiance%index, maf )

    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      cols(jf) = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row_1, cols(jf), 'temperature' )

    end do

    sv_i = 0
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      if ( allocated(f_and_v(1)%vertices) ) then

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            col = cols(f_and_v(jz)%vertices(jf))
            jacobian%block(row_1,col)%values(row_0,jz) = dI_dT(sv_i)
          end if

        end do

      else

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) &
            & jacobian%block(row_1,cols(jf))%values(row_0,jz) = dI_dT(sv_i)

        end do

      end if

    end do

  end subroutine Store_Temperature_Deriv_1D

  ! ------------------------------------  Store_Temperature_Deriv_2D  -----
  subroutine Store_Temperature_Deriv_2D ( MAF, Channel, Radiance, Temp, &
                                        & Grids_Tmp, di_dT, F_and_V, Jacobian )

    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: RP
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type (vectorvalue_t), intent(in) :: Temp     ! Only to get some indices
    type (Grids_T), intent(in) :: Grids_Tmp      ! Temperature's grids, etc.
    real(rp), intent(in) :: dI_dT(:,:) ! derivative of radiance wrt
    !                      temperature on chi_in
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian

    ! Local variables
    integer :: Cols(grids_tmp%windowStart(1):grids_tmp%windowFinish(1))
    integer :: Col, JF, JZ, NoChans, Row, SV_I

    ! Start here

    noChans = radiance%template%noChans

    row = FindBlock ( Jacobian%row, radiance%index, maf )

    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      cols(jf) = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, cols(jf), 'temperature' )

    end do

    sv_i = 0
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)

      if ( allocated(f_and_v(1)%vertices) ) then

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) then
            col = cols(f_and_v(jz)%vertices(jf))
            jacobian%block(row,col)%values(channel::noChans,jz) = dI_dT(:,sv_i)
          end if

        end do

      else

        do jz = 1, temp%template%noSurfs

          ! Check if derivatives are needed for this (zeta & phi) :

          sv_i = sv_i + 1
          if ( grids_tmp%deriv_flags(sv_i) ) &
            & jacobian%block(row,cols(jf))%values(channel::noChans,jz) = dI_dT(:,sv_i)

        end do

      end if

    end do

  end subroutine Store_Temperature_Deriv_2D

  ! ---------------------------------------  Store_Other_Deriv_1D  -----
  subroutine Store_Other_Deriv_1D ( MAF, Row_0, Radiance, Qtys, Grids_f, &
                                  & dI_df, F_and_V, Jacobian, ExtraJacobian, &
                                  & Derivs )

    use ForwardModelConfig, only: QtyStuff_T
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: RP
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    integer, intent(in) :: MAF
    integer, intent(in) :: Row_0 ! within the block, (channel-1)*noChans+zeta
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type(QtyStuff_T), intent(in) :: Qtys(:)
    type (Grids_T), intent(in) :: Grids_f
    real(rp), intent(in) :: dI_df(:) ! mixing ratio derivatives or any
    !                                  parameter for which a simple
    !                                  convolution will suffice
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Output
    type (Matrix_t), intent(inout), target :: Jacobian

    ! Optional output
    type (Matrix_t), intent(inout), optional, target :: ExtraJacobian

    ! Optional input
    logical, intent(in), optional :: Derivs(:) ! Same size as Qtys; if not
                                               ! present, do all columns.  Use
                                               ! in case grids_f%deriv_flags
                                               ! hasn't been set.

    ! Local variables
    integer :: Cols(minval(grids_f%windowStart(:),1):maxval(grids_f%windowFinish(:),1))
    integer :: Col, IS, JF, K, NFZ, Row_1, SV_F
    type (Matrix_t), pointer :: MyJacobian

    row_1 = FindBlock ( Jacobian%row, radiance%index, maf )

    do is = 1, size(qtys)

      if ( present(derivs) ) then
        if ( .not. derivs(is) ) cycle
      end if

      if ( qtys(is)%foundInFirst ) then
        myJacobian => jacobian
      else
        if ( .not. present(extraJacobian) ) cycle
        myJacobian => extraJacobian
      end if

      sv_f = grids_f%l_v(is-1)
      nfz = (Grids_f%l_f(is) - Grids_f%l_f(is-1)) * &
          & (Grids_f%l_z(is) - Grids_f%l_z(is-1))

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        cols(jf) = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row_1, cols(jf), 'atmospheric' )

      end do

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        if ( allocated(f_and_v(1)%vertices) ) then

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) then
              col = cols(f_and_v(k)%vertices(jf))
              myJacobian%block(row_1,col)%values(row_0,k) = di_df(sv_f)
            end if

          end do

        else

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) &
              & myJacobian%block(row_1,cols(jf))%values(row_0,k) = di_df(sv_f)

          end do

      end if

      end do

    end do

  end subroutine Store_Other_Deriv_1D

  ! ---------------------------------------  Store_Other_Deriv_2D  -----
  subroutine Store_Other_Deriv_2D ( MAF, Channel, Radiance, Qtys, Grids_f, &
                                  & dI_df, F_and_V, Jacobian, ExtraJacobian, &
                                  & Derivs )

    use ForwardModelConfig, only: QtyStuff_T
    use Load_sps_data_m, only: Grids_T
    use MatrixModule_1, only: FindBlock, GetFullBlock, Matrix_t
    use MLSKinds, only: RP
    use Path_Representation_m, only: Facets_and_Vertices_t
    use VectorsModule, only: VectorValue_T

    ! Inputs
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type(QtyStuff_T), intent(in) :: Qtys(:)
    type (Grids_T), intent(in) :: Grids_f
    real(rp), intent(in) :: dI_df(:,:) ! mixing ratio derivatives or any
    !                                    parameter for which a simple
    !                                    convolution will suffice
    type (Facets_and_Vertices_t) :: F_and_V(:) ! Facets and vertices under each
    !                      path through a QTM.  Used to map columns of dI_dT
    !                      etc. to columns of Jacobian.  If not QTM,
    !                      F_and_V()%vertices is not allocated.

    ! Outputs
    type (Matrix_t), intent(inout), target :: Jacobian

    ! Optional outputs
    type (Matrix_t), intent(inout), optional, target :: ExtraJacobian

    ! Optional input
    logical, intent(in), optional :: Derivs(:) ! Same size as Qtys; if not
                                               ! present, do all columns.  Use
                                               ! in case grids_f%deriv_flags
                                               ! hasn't been set.

    ! Local variables
    integer :: Cols(minval(grids_f%windowStart(:),1):maxval(grids_f%windowFinish(:),1))
    integer :: Col, IS, JF, K, NFZ, NoChans, Row, SV_F
    type (Matrix_t), pointer :: MyJacobian

    noChans = Radiance%template%noChans

    row = FindBlock ( Jacobian%row, radiance%index, maf )

    do is = 1, size(qtys)

      if ( present(derivs) ) then
        if ( .not. derivs(is) ) cycle
      end if

      if ( qtys(is)%foundInFirst ) then
        myJacobian => jacobian
      else
        if ( .not. present(extraJacobian) ) cycle
        myJacobian => extraJacobian
      end if

      sv_f = grids_f%l_v(is-1)
      nfz = (Grids_f%l_f(is) - Grids_f%l_f(is-1)) * &
          & (Grids_f%l_z(is) - Grids_f%l_z(is-1))

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        cols(jf) = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row, cols(jf), 'atmospheric' )

      end do

      do jf = Grids_f%windowStart(is), Grids_f%windowfinish(is)

        if ( allocated(f_and_v(1)%vertices) ) then

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) then
              col = cols(f_and_v(k)%vertices(jf))
              myJacobian%block(row,col)%values(channel::noChans,k) = di_df(:,sv_f)
            end if

          end do

        else

          do k = 1, nfz

            ! Check if derivatives are needed for this (zeta & phi) :

            sv_f = sv_f + 1
            if ( Grids_f%deriv_flags(sv_f) ) &
              & myJacobian%block(row,cols(jf))%values(channel::noChans,k) = di_df(:,sv_f)

          end do

        end if

      end do

    end do

  end subroutine Store_Other_Deriv_2D

! =====     Private Procedures     =====================================

  subroutine GetBandedBlock ( Jacobian, Row, Col, NoChans, NoPtan )
    use MatrixModule_0, only: M_ABSENT, M_BANDED, CHECKFORSIMPLEBANDEDLAYOUT
    use MatrixModule_1, only: CREATEBLOCK, MATRIX_T
     use MLSKinds, only: RM
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use String_Table, only: Get_String
    type (Matrix_t), intent(inout) :: Jacobian
    integer, intent(in) :: Row, Col, NoChans, NoPtan
    character(len=63) :: ForWhom
    if ( jacobian%name /= 0 ) then
      call get_string ( jacobian%name, forWhom )
      forWhom = trim(forWhom) // " in GetBandedBlock"
    else
      forWhom = "GetBandedBlock"
    end if
    select case (jacobian%block(Row,col)%kind)
      case (m_absent)
        call CreateBlock ( Jacobian, row, col, m_banded, noPtan*noChans, &
                         & bandHeight=noChans, init=0.0_rm, forWhom=forWhom )
      case (m_banded)
        call CheckForSimpleBandedLayout ( jacobian%block(row,col), noChans, &
          & 'd[radiance]/d[ptan] in convolution' )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Wrong matrix block type for ptan derivative' )
    end select
  end subroutine GetBandedBlock

  subroutine LoadMatrixValue ( In, Out, SbRatio, Update, err )
    ! If Update add SbRatio*In to Out else assign SbRatio*In to Out.
    ! Identical to LoadVectorValue except for kind of Out.
    use MLSFillValues, only: isNaN
    use MLSKinds, only: R8, RM
    real(r8), intent(in) :: In(:)
    real(rm), intent(inout) :: Out(:)
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update
    integer, optional, intent(out) :: err
    integer :: myErr ! poss. values: 0, 1, 2, 4, 5, 6
    integer :: N
    n = size(in)
    myErr = 0
    if ( n > size(out) ) then
      myErr = 1
    end if
    if ( n < size(out) ) then
      myErr = myErr + 2
    end if
    if ( any(isNaN(in)) ) then
      myErr = myErr + 4
    end if
    if ( present(err) ) err = myErr
    if ( any(myErr == (/1, 4, 5, 6/)) ) return
    if ( update ) then
      out(:n) = out(:n) + sbRatio * in
    else
      out(:n) = sbRatio * in
    end if
  end subroutine LoadMatrixValue

  subroutine LoadVectorValue ( In, Out, SbRatio, Update )
    ! If Update add SbRatio*In to Out else assign SbRatio*In to Out.
    ! Identical to LoadMatrixValue except for kind of Out.
    use MLSKinds, only: R8, RV
    real(r8), intent(in) :: In(:)
    real(rv), intent(inout) :: Out(:)
    real(r8), intent(in) :: SbRatio
    logical, intent(in) :: Update
    integer :: N
    n = size(in)
    if ( update ) then
      out(:n) = out(:n) + sbRatio * in
    else
      out(:n) = sbRatio * in
    end if
  end subroutine LoadVectorValue

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Convolve_All_m.f90,v 2.26 2017/10/31 23:49:35 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Convolve_All_m

! $Log: Convolve_All_m.f90,v $
! Revision 2.26  2017/10/31 23:49:35  vsnyder
! Make Coefficients a parameterized type
!
! Revision 2.25  2017/03/31 00:47:10  vsnyder
! Use F_and_V to map to Jacobian
!
! Revision 2.24  2014/01/09 00:26:39  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.23  2013/08/02 01:24:06  vsnyder
! Add ExtraJacobian to compute derivatives not in state vector
!
! Revision 2.22  2013/06/12 02:19:16  vsnyder
! Cruft removal
!
! Revision 2.21  2012/07/10 04:10:59  vsnyder
! Remove noChans from Store_*_Deriv_1D because it's not used
!
! Revision 2.20  2012/07/07 00:14:33  vsnyder
! Shorten some comments to avoid gripes about long lines
!
! Revision 2.19  2012/07/06 21:30:31  yanovsky
! Added Convolve_Radiance_Normalization and
! Convolve_Temperature_Deriv_Normalization subroutines that compute
! normalized Temperature derivatives
!
! Revision 2.18  2011/12/17 00:35:29  vsnyder
! Move GetFullBlock to MatrixModule_1
!
! Revision 2.17  2011/08/20 00:44:32  vsnyder
! Remove unused USE statements
!
! Revision 2.16  2010/11/09 01:01:25  vsnyder
! Get RH from HessianModule_0 instead of RM from MLSKinds.  Delete unused
! declarations.  Remove explicit copy-out for loadMatrixValue (should have
! been copy-in/copy-out anyway).  Don't get strings that aren't needed.
!
! Revision 2.15  2010/10/13 22:18:22  pwagner
! Intermediate steps in eliminating NaNs from analytic Hessians
!
! Revision 2.14  2010/08/27 05:53:23  yanovsky
! Fixed the order of do loops in Convolve_Other_Second_Deriv subroutine.  Added comments.
!
! Revision 2.13  2010/07/27 01:12:56  vsnyder
! Fold some lines the compiler said were too long
!
! Revision 2.12  2010/07/18 23:39:19  yanovsky
! Add Convolve_Other_Second_Deriv and GetFullBlock_Hessian
!
! Revision 2.11  2010/02/05 03:18:11  vsnyder
! Remove USE for unreferenced names
!
! Revision 2.10  2009/12/22 03:23:05  vsnyder
! Add Store_Other_Deriv, Store_Temp_Deriv versions
!
! Revision 2.9  2009/12/15 03:17:07  vsnyder
! Get kinds from MLSKinds instead of MLSCommon
!
! Revision 2.8  2009/11/17 23:40:08  vsnyder
! Add Store_*_Deriv routines
!
! Revision 2.7  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.6  2008/08/27 19:56:51  vsnyder
! Add PRINT to not_used_here
!
! Revision 2.5  2006/08/02 19:55:33  vsnyder
! Tell CreateBlock that Convolve creates it, for leak tracking
!
! Revision 2.4  2005/08/06 01:40:45  vsnyder
! ScanAverage doesn't need coeffs
!
! Revision 2.3  2005/08/03 18:03:20  vsnyder
! Scan averaging
!
! Revision 2.2  2005/07/08 00:12:11  vsnyder
! Get Rad_FFT from Convolve_Radiance to Convolve_Temperature_Deriv
!
! Revision 2.1  2005/07/06 02:16:54  vsnyder
! Initial commit, replacing convolve_all_m.f90 and no_conv_at_all.f90
!
@


2.26
log
@Make Coefficients a parameterized type
@
text
@a25 1
  public :: Convolve_Other_Second_Deriv
d27 1
a27 1
  public :: Interpolate_Temperature_Deriv
a624 164
  ! -------------------------------------  Convolve_Other_Second_Deriv -----
  subroutine Convolve_Other_Second_Deriv ( Convolve_Support, MAF, Channel, &
             & SbRatio, Update, Radiance, Qtys, Grids_f, &
             & MIF_Times, DeadTime, d2I_df2, Hessian, RowFlags )
    use Dump_0, only: DUMP
    use ForwardModelConfig, only: QtyStuff_T
    use Fov_Convolve_m, only: Convolve_Support_T, &
      & FOV_Convolve_3d
    use HessianModule_0, only: Dump
    use HessianModule_1, only: Hessian_t
    use HighOutput, only: OutputNamedValue
    use Load_sps_data_m, only: Grids_T, Dump
    use MLSFillValues, only: isNaN
    use MLSKinds, only: R8, RP, RV
    use MatrixModule_1, only: FindBlock
    use MLSStringLists, only: switchDetail
    use MLSMessageModule, only: MLSMessage, MLSMsg_Warning
    use Output_m, only: ResumeOutput, SuspendOutput
    use Toggles, only: Switches
    use VectorsModule, only: VectorValue_T

    ! Inputs
    type(convolve_support_t), intent(in) :: Convolve_Support
    integer, intent(in) :: MAF
    integer, intent(in) :: Channel
    real(r8), intent(in) :: SbRatio    ! Sideband ratio
    logical, intent(in) :: Update      ! "add to Jacobian, don't overwrite"
    type (VectorValue_T), intent(in) :: Radiance ! Only to get some indices
    type(QtyStuff_T), intent(in) :: Qtys(:)
    type (Grids_T), intent(in) :: Grids_f
    real(rv), pointer :: MIF_Times(:,:) ! Disassociated if no scan average, q.v.
    real(rv), pointer :: DeadTime(:,:)  ! Disassociated if no scan average, q.v.
    real(rp), intent(in) :: d2I_df2(:,:,:) ! mixing ratio derivatives or any
    !                                    parameter for which a simple
    !                                    convolution will suffice

    ! Outputs
    type (Hessian_t), intent(inout) :: Hessian
    logical, intent(inout) :: rowFlags(:) ! Flag to calling code

    ! Local variables
    integer :: Row, Col1, Col2
    integer :: err
    integer :: JF_I, JF_J
    integer :: KI, KJ
    integer :: NFZ_I, NFZ_J ! # frequency elements times # z elements in species
    integer :: NoChans
    integer :: SPS_I, SPS_J ! species indices
    integer :: q, r         ! indices of final elements in state vectors
    real(r8) :: d2rad_df2_out( size(convolve_support%del_chi_out), &
                             & size(d2i_df2,dim=2), size(d2i_df2,dim=3))
    real(rv), pointer :: MIF_Times_for_MAF(:)

    nullify ( MIF_Times_for_MAF )
    if ( associated(MIF_Times) ) MIF_Times_for_MAF => MIF_Times(:,maf)
    noChans = Radiance%template%noChans

    ! do the convolution
    if ( any(isNaN(d2i_df2)) ) then
      call dump( d2i_df2, 'd2i_df2', options='-H' )
      call MLSMessage( MLSMSG_Warning, ModuleName // 'Convolve_Other_Second_Deriv', &
        & 'NaNs found in d2i_df2' )
    endif

    call fov_convolve_3d ( convolve_support, d2i_df2, MIF_Times_for_MAF, &
                         & DeadTime, grids_f%deriv_flags, d2rad_df2_out )

    ! load second derivatives into Hessian
    ! First, find index location in Hessian and set the derivative flags

    row = FindBlock( Hessian%row, radiance%index, maf )
    rowFlags(row) = .TRUE.

    if ( switchDetail( switches, 'hnan', options='-fc' ) > -1 ) then
      call outputNamedValue( 'MAF', MAF )
      call outputNamedValue( 'Channel', Channel )
      call outputNamedValue( 'row', row )
      call outputNamedValue( 'noChans', noChans )
      call outputNamedValue( 'size(qtys)', size(qtys) )
      if ( .not. update) then
        call dump( Grids_f, details=2 )
      endif
    endif

    do sps_i = 1, size(qtys)

      if ( .not. qtys(sps_i)%foundInFirst ) cycle

      q = grids_f%l_v(sps_i-1)
      nfz_i = (Grids_f%l_f(sps_i) - Grids_f%l_f(sps_i-1)) * &
            & (Grids_f%l_z(sps_i) - Grids_f%l_z(sps_i-1))

      do jf_i = Grids_f%windowStart(sps_i), Grids_f%windowfinish(sps_i)

        col1 = FindBlock ( Hessian%col, qtys(sps_i)%qty%index, jf_i)

        do ki = 1, nfz_i

          q = q + 1

          do sps_j = 1, size(qtys)

            if ( .not. qtys(sps_j)%foundInFirst ) cycle

            r = grids_f%l_v(sps_j-1)
            nfz_j = (Grids_f%l_f(sps_j) - Grids_f%l_f(sps_j-1)) * &
                  & (Grids_f%l_z(sps_j) - Grids_f%l_z(sps_j-1))

            do jf_j = Grids_f%windowStart(sps_j), Grids_f%windowfinish(sps_j)

              col2 = FindBlock ( Hessian%col, qtys(sps_j)%qty%index, jf_j)
        
              call getFullBlock_Hessian ( hessian, row, col1, col2, 'atmospheric' )

              do kj = 1, nfz_j
            
                r = r + 1

                ! load derivatives for this (zeta & phi) if needed:

                if ( Grids_f%deriv_flags(q) .and. Grids_f%deriv_flags(r) ) then

                  call loadMatrixValue ( d2rad_df2_out(:,q,r), &
                  & hessian%block(row,col1,col2)%values(channel::noChans,ki,kj), &
                  & sbRatio, update, ERR )

                  select case ( err ) 
                  case (1)
                    call MLSMessage( MLSMSG_Warning, ModuleName, &
                      & 'd2rad_df2_out bigger than hessian slice' )
                  case (2)
                    call MLSMessage( MLSMSG_Warning, ModuleName, &
                      & 'd2rad_df2_out smaller than hessian slice' )
                  case (4)
                    call MLSMessage( MLSMSG_Warning, ModuleName, &
                      & 'NaNs found in d2rad_df2_out' )
                  case (5)
                    call MLSMessage( MLSMSG_Warning, ModuleName, &
                      & 'd2rad_df2_out bigger than hessian slice; NaNs, too' )
                  case (6)
                    call MLSMessage( MLSMSG_Warning, ModuleName, &
                      & 'd2rad_df2_out smaller than hessian slice; NaNs, too' )
                  case default
                  end select
                endif
              end do
              if ( switchDetail( switches, 'hnan', options='-fc' ) > -1) then
                call suspendOutput
                call dump( hessian%block(row,col1,col2), details=-3 )
                call resumeOutput
              endif
   
            end do
        
          end do

        end do

      end do

    end do

  end subroutine Convolve_Other_Second_Deriv

a1386 23
  subroutine GetFullBlock_Hessian ( Hessian, Row, Col1, Col2, What )
    use HessianModule_0, only: H_ABSENT, H_FULL, RH
    use HessianModule_1, only: CREATEBLOCK, HESSIAN_T
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    type (Hessian_t), intent(inout) :: Hessian
    integer, intent(in) :: Row, Col1, Col2
    character(len=*), intent(in) :: What

    select case ( Hessian%block(row,col1,col2)%kind )
      case ( h_absent )
        ! If profiling shows we're spending too much time filling the block,
        ! we could send in a signal and only fill for the channels for which
        ! we are not computing results.
        call CreateBlock ( Hessian, row, col1, col2, h_full, inittuples=0, fill=0.0_rh )
      case ( h_full )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Wrong matrix block type for ' // what // ' second derivative matrix' )
    end select

  end subroutine GetFullBlock_Hessian


d1439 1
a1439 1
       "$Id: Convolve_All_m.f90,v 2.25 2017/03/31 00:47:10 vsnyder Exp $"
d1449 3
@


2.25
log
@Use F_and_V to map to Jacobian
@
text
@d799 1
a799 1
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateValues
d804 1
a804 1
    type(coefficients), intent(in) :: Coeffs
d886 1
a886 1
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateValues
d892 1
a892 1
    type(coefficients), intent(in) :: Coeffs
d1006 1
a1006 1
    use MLSNumerics, only: Coefficients => Coefficients_r8, InterpolateValues
d1012 1
a1012 1
    type(coefficients), intent(in) :: Coeffs
d1627 1
a1627 1
       "$Id: Convolve_All_m.f90,v 2.24 2014/01/09 00:26:39 pwagner Exp $"
d1637 3
@


2.24
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d24 6
a29 6
  public :: CONVOLVE_OTHER_DERIV, CONVOLVE_RADIANCE, CONVOLVE_TEMPERATURE_DERIV
  public :: CONVOLVE_RADIANCE_NORMALIZATION, CONVOLVE_TEMPERATURE_DERIV_NORMALIZATION
  public :: CONVOLVE_OTHER_SECOND_DERIV
  public :: INTERPOLATE_RADIANCE, INTERPOLATE_OTHER_DERIV
  public :: INTERPOLATE_TEMPERATURE_DERIV
  public :: STORE_OTHER_DERIV, STORE_TEMPERATURE_DERIV
d55 1
a55 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d62 1
a62 1
    integer, intent(in) :: CHANNEL
d66 1
a66 1
    type(vectorvalue_t), intent(in) :: PTAN ! Only for some indices
d71 1
a71 1
    type (VectorValue_T), intent(inout) :: RADIANCE   ! Output radiances
d134 1
a134 1
           & dxdt_tan, dxdt_surface, Jacobian, RowFlags )
d139 1
a139 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d141 1
d147 1
a147 1
    integer, intent(in) :: CHANNEL
d152 2
a153 2
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
    type (vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d169 4
d179 1
d199 2
a200 2
    ! Load the Temp. derivative values into the Jacobian
    ! First, find index location in Jacobian and set the derivative flags
d205 7
d215 16
a230 2
      col = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, col, 'temperature' )
d232 1
a232 1
      do k = 1, n_t_zeta
d234 8
a241 1
        ! Load derivatives for this (zeta & phi) if needed :
d243 1
a243 6
        sv_i = sv_i + 1
        if ( grids_tmp%deriv_flags(sv_i) ) &
          & call loadMatrixValue ( dRad_dT_out(:,sv_i), &
            & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
            & update )
      end do
d261 1
a261 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d269 1
a269 1
    integer, intent(in) :: CHANNEL
d273 1
a273 1
    type(vectorvalue_t), intent(in) :: PTAN ! Only for some indices
d278 1
a278 1
    type (VectorValue_T), intent(inout) :: RADIANCE   ! Output radiances, IA = I*G
d325 1
a325 1
                                 & METHOD='S', extrapolate='C' )
d327 1
a327 1
    ! I_diff = I - IA            ! IGOR:
d367 1
a367 1
           & dxdt_tan, dxdt_surface, Jacobian, RowFlags )
d370 2
a371 1
      & FOV_Convolve_Temp_Derivs, FOV_Convolve_Temp_Derivs_Normalization
d373 1
a373 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d375 1
d386 2
a387 2
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
    type (vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d403 4
d413 1
d438 2
a439 3

    ! Load the Temp. derivative values into the Jacobian
    ! First, find index location in Jacobian and set the derivative flags
d444 7
d454 5
a458 2
      col = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, col, 'temperature' )
d460 8
a467 1
      do k = 1, n_t_zeta
d469 1
a469 1
        ! Load derivatives for this (zeta & phi) if needed :
d471 12
a482 6
        sv_i = sv_i + 1
        if ( grids_tmp%deriv_flags(sv_i) ) &
          & call loadMatrixValue ( dRad_dT_out(:,sv_i), &
            & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
            & update )
      end do
d491 2
a492 2
             & DeadTime, dI_df, Jacobian, RowFlags, ExtraJacobian, &
             & Derivs )
d498 1
a498 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d500 1
d506 1
a506 1
    integer, intent(in) :: CHANNEL
d509 1
a509 1
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
d517 4
d536 1
d583 2
a584 2
        col = FindBlock ( myJacobian%col, qtys(sps_i)%qty%index, jf)
        call getFullBlock ( myJacobian, row, col, 'atmospheric' )
d586 1
a586 1
        do k = 1, nfz
d588 5
a592 1
          ! load derivatives for this (zeta & phi) if needed:
d594 25
a618 6
          sv_f = sv_f + 1
          if ( Grids_f%deriv_flags(sv_f) ) &
            & call loadMatrixValue ( drad_df_out(:,sv_f), &
              & myJacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
              & update )
        end do
d634 3
a636 3
    use HessianModule_0, only: DUMP
    use HessianModule_1, only: HESSIAN_T
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
d640 1
a640 1
    use MatrixModule_1, only: FINDBLOCK
d642 3
a644 3
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
    use output_m, only: resumeOutput, suspendOutput
    use TOGGLES, only: switches
d650 1
a650 1
    integer, intent(in) :: CHANNEL
d653 1
a653 1
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
d797 1
a797 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d806 1
a806 1
    integer, intent(in) :: CHANNEL
d811 1
a811 1
    type(vectorvalue_t), intent(in) :: PTAN ! Only for some indices
d881 1
a881 1
           & MIF_Times, DeadTime, di_dT, Jacobian, RowFlags )
d887 1
d899 2
a900 2
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
    type (vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d906 4
d916 1
a924 1
    sv_i = 0
d933 34
a966 2
      col = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, col, 'temperature' )
d968 1
a968 1
      do jz = 1, temp%template%noSurfs
d970 1
a970 1
        ! Check if derivatives are needed for this (zeta & phi) :
d972 14
a985 10
        sv_i = sv_i + 1
        if ( grids_tmp%deriv_flags(sv_i) ) then
          dRad_dT_in = di_dt(1:k,sv_i)
          if ( associated(MIF_Times) ) then
            call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
              & chi_in, chi_out, dRad_dT_in, dRad_dT_out )
          else
            call InterpolateValues ( coeffs, chi_in, dRad_dT_in, &
                                   & chi_out, dRad_dT_out, &
                                   & method = 'S', extrapolate = 'C' )
a986 4
          call loadMatrixValue ( dRad_dT_out, &
            & jacobian%block(row,col)%values(channel::noChans,jz), sbRatio, &
            & update )
        end if
d988 3
a990 1
      end do
d999 1
a999 1
             & MIF_Times, DeadTime, dI_df, Jacobian, RowFlags, Linear, &
d1004 1
a1004 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d1007 1
d1014 1
a1014 1
    integer, intent(in) :: CHANNEL
d1019 1
a1019 1
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
d1027 4
d1047 1
d1084 10
a1093 2
        col = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row, col, 'atmospheric' )
d1095 1
a1095 1
        do k = 1, nfz
d1097 28
a1124 1
          ! Check if derivatives are needed for this (zeta & phi) :
d1126 18
a1143 14
          sv_f = sv_f + 1
          if ( Grids_f%deriv_flags(sv_f) ) then
            dRad_df_in = di_df(:,sv_f)
            if ( associated(MIF_Times) ) then
              call scanAverage ( MIF_Times_for_MAF, deadTime(1,1), &
                & chi_in, chi_out, dRad_df_in, dRad_df_out )
            else if ( myLinear ) then
              call InterpolateValues ( chi_in, dRad_df_in, &
                                     & chi_out, dRad_df_out, &
                                     & method = 'L', extrapolate = 'C' )
            else
              call InterpolateValues ( coeffs, chi_in, dRad_df_in, &
                                     & chi_out, dRad_df_out, &
                                     & method = 'S', extrapolate = 'C' )
a1144 4
            call loadMatrixValue ( dRad_df_out, &
              & myJacobian%block(row,col)%values(channel::noChans,k), &
              & sbRatio, update )
          end if
d1146 3
a1148 1
        end do
d1158 1
a1158 1
                                        & Grids_Tmp, di_dT, Jacobian )
d1161 1
a1161 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d1163 1
d1169 2
a1170 2
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
    type (Vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d1174 4
d1183 1
d1188 9
d1198 5
d1204 9
a1212 1
    row_1 = FindBlock ( Jacobian%row, radiance%index, maf )
d1214 1
a1214 1
    do jf = grids_tmp%windowStart(1), grids_tmp%windowFinish(1)
d1216 1
a1216 2
      col = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row_1, col, 'temperature' )
d1218 1
a1218 1
      do jz = 1, temp%template%noSurfs
d1220 3
a1222 1
        ! Check if derivatives are needed for this (zeta & phi) :
d1224 1
a1224 3
        sv_i = sv_i + 1
        if ( grids_tmp%deriv_flags(sv_i) ) &
          & jacobian%block(row_1,col)%values(row_0,jz) = dI_dT(sv_i)
d1226 1
a1226 1
      end do
d1234 1
a1234 1
                                        & Grids_Tmp, di_dT, Jacobian )
d1237 1
a1237 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d1239 1
d1244 3
a1246 3
    integer, intent(in) :: CHANNEL
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
    type (vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d1250 4
d1259 1
a1263 1
    sv_i = 0
d1270 2
a1271 2
      col = FindBlock ( Jacobian%col, temp%index, jf )
      call getFullBlock ( jacobian, row, col, 'temperature' )
d1273 1
a1273 1
      do jz = 1, temp%template%noSurfs
d1275 2
a1276 1
        ! Check if derivatives are needed for this (zeta & phi) :
d1278 15
a1292 3
        sv_i = sv_i + 1
        if ( grids_tmp%deriv_flags(sv_i) ) &
          & jacobian%block(row,col)%values(channel::noChans,jz) = dI_dT(:,sv_i)
d1294 11
a1304 1
      end do
d1312 2
a1313 1
                                  & dI_df, Jacobian, ExtraJacobian, Derivs )
d1317 1
a1317 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d1319 1
d1325 1
a1325 1
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
d1331 4
d1349 1
d1374 8
a1381 2
        col = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row_1, col, 'atmospheric' )
d1383 1
a1383 1
        do k = 1, nfz
d1385 19
a1403 1
          ! Check if derivatives are needed for this (zeta & phi) :
d1405 1
a1405 3
          sv_f = sv_f + 1
          if ( Grids_f%deriv_flags(sv_f) ) &
            & myJacobian%block(row_1,col)%values(row_0,k) = di_df(sv_f)
d1407 1
a1407 1
        end do
d1417 2
a1418 1
                                  & dI_df, Jacobian, ExtraJacobian, Derivs )
d1422 1
a1422 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock, MATRIX_T
d1424 1
d1429 2
a1430 2
    integer, intent(in) :: CHANNEL
    type (VectorValue_T), intent(in) :: RADIANCE ! Only for some indices
d1436 4
d1454 1
d1481 8
a1488 2
        col = FindBlock ( myJacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( myJacobian, row, col, 'atmospheric' )
d1490 13
a1502 1
        do k = 1, nfz
d1504 7
a1510 1
          ! Check if derivatives are needed for this (zeta & phi) :
d1512 1
a1512 3
          sv_f = sv_f + 1
          if ( Grids_f%deriv_flags(sv_f) ) &
            & myJacobian%block(row,col)%values(channel::noChans,k) = di_df(:,sv_f)
d1514 1
a1514 1
        end do
d1591 1
a1591 1
    endif
d1594 1
a1594 1
    endif
d1597 1
a1597 1
    endif
d1627 1
a1627 1
       "$Id: Convolve_All_m.f90,v 2.23 2013/08/02 01:24:06 vsnyder Exp $"
d1637 3
@


2.23
log
@Add ExtraJacobian to compute derivatives not in state vector
@
text
@d549 1
d556 1
a556 1
    use output_m, only: outputNamedValue, resumeOutput, suspendOutput
d1345 1
a1345 1
       "$Id: Convolve_All_m.f90,v 2.22 2013/06/12 02:19:16 vsnyder Exp $"
d1355 3
@


2.22
log
@Cruft removal
@
text
@d432 3
a434 2
             & SbRatio, Update, Radiance, Qtys, Grids_f, &
             & MIF_Times, DeadTime, dI_df, Jacobian, RowFlags )
d460 1
a460 1
    type (Matrix_t), intent(inout) :: Jacobian
d463 9
d483 1
d502 10
a511 1
      if ( .not. qtys(sps_i)%foundInFirst ) cycle
d519 2
a520 2
        col = FindBlock ( Jacobian%col, qtys(sps_i)%qty%index, jf)
        call getFullBlock ( jacobian, row, col, 'atmospheric' )
d529 1
a529 1
              & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
d872 2
a873 1
             & MIF_Times, DeadTime, dI_df, Jacobian, RowFlags, Linear )
d901 1
a901 1
    type (Matrix_t), intent(inout) :: Jacobian
d907 6
d916 1
d934 10
a943 1
      if ( .not. qtys(is)%foundInFirst ) cycle
d951 2
a952 2
        col = FindBlock ( Jacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( jacobian, row, col, 'atmospheric' )
d974 2
a975 2
              & jacobian%block(row,col)%values(channel::noChans,k), sbRatio, &
              & update )
d1087 1
a1087 1
                                  & dI_df, Jacobian )
d1105 11
a1115 2
    ! Outputs
    type (Matrix_t), intent(inout) :: Jacobian
d1119 1
d1125 10
a1134 1
      if ( .not. qtys(is)%foundInFirst ) cycle
d1142 2
a1143 2
        col = FindBlock ( Jacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( jacobian, row_1, col, 'atmospheric' )
d1151 1
a1151 1
            & jacobian%block(row_1,col)%values(row_0,k) = di_df(sv_f)
d1163 1
a1163 1
                                  & dI_df, Jacobian )
d1182 10
a1191 1
    type (Matrix_t), intent(inout) :: Jacobian
d1195 1
d1203 10
a1212 1
      if ( .not. qtys(is)%foundInFirst ) cycle
d1220 2
a1221 2
        col = FindBlock ( Jacobian%col, qtys(is)%qty%index, jf)
        call getFullBlock ( jacobian, row, col, 'atmospheric' )
d1229 1
a1229 1
            & jacobian%block(row,col)%values(channel::noChans,k) = di_df(:,sv_f)
d1344 1
a1344 1
       "$Id: Convolve_All_m.f90,v 2.21 2012/07/10 04:10:59 vsnyder Exp $"
d1354 3
@


2.21
log
@Remove noChans from Store_*_Deriv_1D because it's not used
@
text
@d532 1
a532 1
    use MatrixModule_1, only: FINDBLOCK, GetFullBlock
d1269 1
a1269 1
       "$Id: Convolve_All_m.f90,v 2.20 2012/07/07 00:14:33 vsnyder Exp $"
d1279 3
@


2.20
log
@Shorten some comments to avoid gripes about long lines
@
text
@d962 1
a962 1
    type (vectorvalue_t), intent(in) :: TEMP     ! Only for some indices
d971 1
a971 1
    integer :: Col, JF, JZ, NoChans, Row_1, SV_I
a975 1
    noChans = radiance%template%noChans
d1072 1
a1072 3
    integer :: Col, IS, JF, K, NFZ, NoChans, Row_1, SV_F

    noChans = Radiance%template%noChans
d1269 1
a1269 1
       "$Id: Convolve_All_m.f90,v 2.19 2012/07/06 21:30:31 yanovsky Exp $"
d1279 3
@


2.19
log
@Added Convolve_Radiance_Normalization and Convolve_Temperature_Deriv_Normalization subroutines that compute normalized Temperature derivatives
@
text
@d1272 1
a1272 1
       "$Id: Convolve_All_m.f90,v 2.18 2011/12/17 00:35:29 vsnyder Exp $"
d1282 5
@


2.18
log
@Move GetFullBlock to MatrixModule_1
@
text
@d25 1
d47 1
d220 210
d1272 1
a1272 1
       "$Id: Convolve_All_m.f90,v 2.17 2011/08/20 00:44:32 vsnyder Exp $"
d1282 3
@


2.17
log
@Remove unused USE statements
@
text
@d137 1
a137 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d227 1
a227 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d320 1
a320 1
    use MatrixModule_1, only: FINDBLOCK
d564 1
a564 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d644 1
a644 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d742 1
a742 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d792 1
a792 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d843 1
a843 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
d902 1
a902 1
    use MatrixModule_1, only: FINDBLOCK, MATRIX_T
a984 28

  subroutine GetFullBlock ( Jacobian, Row, Col, What )
    use MatrixModule_0, only: M_ABSENT, M_FULL
    use MatrixModule_1, only: CREATEBLOCK, MATRIX_T
    use MLSKinds, only: RM
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use String_Table, only: Get_String
    type (Matrix_t), intent(inout) :: Jacobian
    integer, intent(in) :: Row, Col
    character(len=*), intent(in) :: What
    character(len=63) :: ForWhom
    select case ( Jacobian%block(row,col)%kind )
      case ( m_absent )
        if ( jacobian%name /= 0 ) then
          call get_string ( jacobian%name, forWhom )
          forWhom = trim(forWhom) // " in GetFullBlock"
        else
          forWhom = "GetFullBlock"
        end if
        call CreateBlock ( Jacobian, row, col, m_full, init=0.0_rm, forWhom=forWhom )
      case ( m_full )
      case default
        call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Wrong matrix block type for ' // what // ' derivative matrix' )
    end select
  end subroutine GetFullBlock


d1060 1
a1060 1
       "$Id: Convolve_All_m.f90,v 2.16 2010/11/09 01:01:25 vsnyder Exp $"
d1070 3
@


2.16
log
@Get RH from HessianModule_0 instead of RM from MLSKinds.  Delete unused
declarations.  Remove explicit copy-out for loadMatrixValue (should have
been copy-in/copy-out anyway).  Don't get strings that aren't needed.
@
text
@a310 1
    use Allocate_Deallocate, only: Allocate_test, Deallocate_test
d315 1
a315 1
    use HessianModule_0, only: DUMP, RH
a1016 1
    use String_Table, only: Get_String
d1088 1
a1088 1
       "$Id: Convolve_All_m.f90,v 2.15 2010/10/13 22:18:22 pwagner Exp $"
d1098 5
@


2.15
log
@Intermediate steps in eliminating NaNs from analytic Hessians
@
text
@d316 1
a316 1
    use HessianModule_0, only: DUMP
d320 1
a320 1
    use MLSKinds, only: R8, RM, RP, RV
d323 1
a323 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
a358 13
    real(rm), pointer :: hvalues(:)
    
    ! Debugging variables
    integer, save :: channelMin = 0
    integer, save :: channelMax = 0
    integer, save :: kiMin = 0
    integer, save :: kiMax = 0
    integer, save :: kjMin = 0
    integer, save :: kjMax = 0
    integer, save :: qMin = 0
    integer, save :: qMax = 0
    integer, save :: rMin = 0
    integer, save :: rMax = 0
a359 1
    nullify ( hValues )
d390 1
a390 3
    ! Use temp hValues 
    call allocate_test( hValues, size(d2rad_df2_out), 'hValues', ModuleName // &
      & 'Convolve_Other_Second_Deriv' )
d428 4
a431 6
!                  call loadMatrixValue ( d2rad_df2_out(:,q,r), &
!                  & hessian%block(row,col1,col2)%values(channel::noChans,ki,kj), &
!                  & sbRatio, update, ERR )
                    call loadMatrixValue ( d2rad_df2_out(:,q,r), &
                    & hValues, &
                    & sbRatio, update, ERR )
d448 1
a448 1
                      & 'd2rad_df2_out smallerer than hessian slice; NaNs, too' )
a451 1
                hessian%block(row,col1,col2)%values(channel::noChans,ki,kj) = hValues
a467 2
    call Deallocate_test( hValues, 'hValues', ModuleName // &
      & 'Convolve_Other_Second_Deriv' )
d961 1
a961 1
    use MLSKinds, only: RM
a996 6
    if ( jacobian%name /= 0 ) then
      call get_string ( jacobian%name, forWhom )
      forWhom = trim(forWhom) // " in GetFullBlock"
    else
      forWhom = "GetFullBlock"
    end if
d999 6
d1015 1
a1015 1
    use HessianModule_0, only: H_ABSENT, H_FULL
a1016 1
    use MLSKinds, only: RM
d1022 1
a1022 7
    character(len=63) :: ForWhom
    if ( hessian%name /= 0 ) then
      call get_string ( hessian%name, forWhom )
      forWhom = trim(forWhom) // " in GetFullBlock"
    else
      forWhom = "GetFullBlock"
    end if
d1025 4
a1028 1
        call CreateBlock ( Hessian, row, col1, col2, h_full, inittuples=0 )
d1034 1
d1090 1
a1090 1
       "$Id: Convolve_All_m.f90,v 2.14 2010/08/27 05:53:23 yanovsky Exp $"
d1100 3
@


2.14
log
@Fixed the order of do loops in Convolve_Other_Second_Deriv subroutine.  Added comments.
@
text
@d311 2
a312 1

d316 5
a320 1
    use Load_sps_data_m, only: Grids_T
d322 4
a325 2
    use HessianModule_1, only: HESSIAN_T
    use MLSKinds, only: R8, RP, RV
d349 1
d359 13
d373 1
d379 5
d394 13
d443 28
a470 5
                if ( Grids_f%deriv_flags(q) .and. Grids_f%deriv_flags(r) ) &
                    & call loadMatrixValue ( d2rad_df2_out(:,q,r), &
                    & hessian%block(row,col1,col2)%values(channel::noChans,ki,kj), &
                    & sbRatio, update )

d472 5
d487 2
d1062 1
a1062 1
  subroutine LoadMatrixValue ( In, Out, SbRatio, Update )
d1065 1
d1071 2
d1075 12
d1114 1
a1114 1
       "$Id: Convolve_All_m.f90,v 2.13 2010/07/27 01:12:56 vsnyder Exp $"
d1124 3
@


2.13
log
@Fold some lines the compiler said were too long
@
text
@d251 7
a257 1
    integer :: Col, JF, K, NFZ, NoChans, Row, SPS_I, SV_F
a306 2
  ! Added by IGOR

d325 1
a325 1
    real(r8), intent(in) :: SbRatio
d344 1
a344 1
    integer :: NFZ_I, NFZ_J
d346 2
a347 2
    integer :: SPS_I, SPS_J             ! species indices
    integer :: q, r                     ! state vector indices
d379 1
a379 1
        do sps_j = 1, size(qtys)
d381 1
a381 1
          if ( .not. qtys(sps_j)%foundInFirst ) cycle
d383 1
a383 3
          r = grids_f%l_v(sps_j-1)
          nfz_j = (Grids_f%l_f(sps_j) - Grids_f%l_f(sps_j-1)) * &
                & (Grids_f%l_z(sps_j) - Grids_f%l_z(sps_j-1))
d385 1
a385 1
          do jf_j = Grids_f%windowStart(sps_j), Grids_f%windowfinish(sps_j)
d387 3
a389 3
            col2 = FindBlock ( Hessian%col, qtys(sps_j)%qty%index, jf_j)
        
            call getFullBlock_Hessian ( hessian, row, col1, col2, 'atmospheric' )
d391 1
a391 1
            do ki = 1, nfz_i
d393 3
a395 1
              q = q + 1
d937 1
a964 3
  !
  ! Added by IGOR
  !
d1029 1
a1029 1
       "$Id: Convolve_All_m.f90,v 2.12 2010/07/18 23:39:19 yanovsky Exp $"
d1039 3
@


2.12
log
@Add Convolve_Other_Second_Deriv and GetFullBlock_Hessian
@
text
@d344 2
a345 1
    real(r8) :: d2rad_df2_out(size(convolve_support%del_chi_out), size(d2i_df2,dim=2), size(d2i_df2,dim=3))
d354 2
a355 1
    call fov_convolve_3d ( convolve_support, d2i_df2, MIF_Times_for_MAF, DeadTime, grids_f%deriv_flags, d2rad_df2_out )
d400 3
a402 1
                    & call loadMatrixValue ( d2rad_df2_out(:,q,r), hessian%block(row,col1,col2)%values(channel::noChans,ki,kj), sbRatio, update )
d1027 1
a1027 1
       "$Id: Convolve_All_m.f90,v 2.11 2010/02/05 03:18:11 vsnyder Exp $"
d1037 3
@


2.11
log
@Remove USE for unreferenced names
@
text
@d25 1
d301 113
d955 31
d1023 1
a1023 1
       "$Id: Convolve_All_m.f90,v 2.10 2009/12/22 03:23:05 vsnyder Exp $"
d1033 3
@


2.10
log
@Add Store_Other_Deriv, Store_Temp_Deriv versions
@
text
@d674 1
a674 1
    use MLSKinds, only: R8, RP, RV
d733 1
a733 1
    use MLSKinds, only: R8, RP, RV
d878 1
a878 1
       "$Id: Convolve_All_m.f90,v 2.9 2009/12/15 03:17:07 vsnyder Exp $"
d888 3
@


2.9
log
@Get kinds from MLSKinds instead of MLSCommon
@
text
@d29 8
d567 53
a619 3
  ! ------------------------------------  Store_Temperature_Deriv  -----
  subroutine Store_Temperature_Deriv ( MAF, Channel, Radiance, Temp, &
                                     & Grids_Tmp, di_dT, Jacobian )
d665 60
a724 1
  end subroutine Store_Temperature_Deriv
d726 3
a728 3
  ! ------------------------------------------  Store_Other_Deriv  -----
  subroutine Store_Other_Deriv ( MAF, Channel, Radiance, Qtys, Grids_f, &
                               & dI_df, Jacobian )
d783 1
a783 1
  end subroutine Store_Other_Deriv
d827 1
a827 1
      forWhom = trim(forWhom) // " in GetBandedBlock"
d829 1
a829 1
      forWhom = "GetBandedBlock"
d878 1
a878 1
       "$Id: Convolve_All_m.f90,v 2.8 2009/11/17 23:40:08 vsnyder Exp $"
d888 3
@


2.8
log
@Add Store_*_Deriv routines
@
text
@d45 1
a45 1
    use MLSCommon, only: R8, RP, RV
d129 1
a129 1
    use MLSCommon, only: R8, RP, RV
d219 1
a219 1
    use MLSCommon, only: R8, RP, RV
d300 1
a300 1
    use MLSCommon, only: R8, RP, RV
d387 1
a387 1
    use MLSCommon, only: R8, RP, RV
d467 1
a467 1
    use MLSCommon, only: R8, RP, RV
d565 1
a565 1
    use MLSCommon, only: RP
d616 1
a616 1
    use MLSCommon, only: R8, RP, RV
d673 1
a673 1
    use MLSCommon, only: RM
d701 1
a701 1
    use MLSCommon, only: RM
d727 1
a727 1
    use MLSCommon, only: R8, RM
d744 1
a744 1
    use MLSCommon, only: R8, RV
d761 1
a761 1
       "$Id: Convolve_All_m.f90,v 2.7 2009/06/23 18:26:10 pwagner Exp $"
d771 3
@


2.7
log
@Prevent Intel from optimizing ident string away
@
text
@d24 4
a27 3
  public :: CONVOLVE_RADIANCE, CONVOLVE_TEMPERATURE_DERIV, CONVOLVE_OTHER_DERIV
  public :: INTERPOLATE_RADIANCE, INTERPOLATE_TEMPERATURE_DERIV
  public :: INTERPOLATE_OTHER_DERIV
d31 1
a31 1
       "$RCSfile: $"
d559 109
d761 1
a761 1
       "$Id: read_apriori.f90 is it here $"
d771 3
@


2.6
log
@Add PRINT to not_used_here
@
text
@d30 1
a30 1
       "$RCSfile: Convolve_All_m.f90,v $"
d648 1
a649 1
!---------------------------- RCS Ident Info -------------------------------
d651 2
a652 3
       "$Id: Convolve_All_m.f90,v 2.5 2006/08/02 19:55:33 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d654 1
a654 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d656 1
d661 3
@


2.5
log
@Tell CreateBlock that Convolve creates it, for leak tracking
@
text
@d296 1
a296 1
    ! Interpolate the radiance from Chi_In to Chi_Out, and maybe dI/PTan too.
d651 1
a651 1
       "$Id: Convolve_All_m.f90,v 2.4 2005/08/06 01:40:45 vsnyder Exp $"
d655 1
d661 3
@


2.4
log
@ScanAverage doesn't need coeffs
@
text
@d565 1
d568 7
d578 1
a578 1
                         & bandHeight=noChans, init=0.0_rm )
d593 1
d597 7
d606 1
a606 1
        call CreateBlock ( Jacobian, row, col, m_full, init=0.0_rm )
d651 1
a651 1
       "$Id: Convolve_All_m.f90,v 2.3 2005/08/03 18:03:20 vsnyder Exp $"
d660 3
@


2.3
log
@Scan averaging
@
text
@d346 1
a346 1
        call scanAverage ( coeffs, MIF_Times_for_MAF, deadTime(1,1), &
d363 1
a363 1
          call scanAverage ( coeffs, MIF_Times_for_MAF, deadTime(1,1), &
d440 1
a440 1
            call scanAverage ( coeffs, MIF_Times_for_MAF, deadTime(1,1), &
d534 1
a534 1
              call scanAverage ( coeffs, MIF_Times_for_MAF, deadTime(1,1), &
d635 1
a635 1
       "$Id: Convolve_All_m.f90,v 2.2 2005/07/08 00:12:11 vsnyder Exp $"
d644 3
@


2.2
log
@Get Rad_FFT from Convolve_Radiance to Convolve_Temperature_Deriv
@
text
@d37 1
a37 1
           & SbRatio, Update, Ptan, Radiance, &
d44 1
a44 1
    use MLSCommon, only: R8, RP
d55 2
d58 1
a58 1
    ! output
d73 1
d79 2
d87 2
a88 2
      call fov_convolve_1d ( convolve_support, rad_in, SRad, dRad_dx_out=di_dx, &
        & rad_fft_out=rad_fft )
d90 2
a91 1
      call fov_convolve_1d ( convolve_support, rad_in, SRad, rad_fft_out=rad_fft )
d121 2
a122 2
           & surf_angle, di_dT, dx_dT, d2x_dxdT, dxdt_tan, dxdt_surface, &
           & Jacobian, RowFlags )
d128 1
a128 1
    use MLSCommon, only: R8, RP
d144 2
d166 1
d170 2
d176 3
a178 3
    call fov_convolve_temp_derivs ( convolve_support, rad_in,  &
      & rad_fft, surf_angle, dI_dT, dx_dT, d2x_dxdT,   &
      & dxdt_tan - SPREAD(dxdt_surface(1,:),1,noPtan), &
d210 2
a211 2
             & SbRatio, Update, Radiance, Qtys, Grids_f, dI_df, &
             & Jacobian, RowFlags )
d218 1
a218 1
    use MLSCommon, only: R8, RP
d230 2
d244 1
d246 2
d252 2
a253 2
    call fov_convolve_2d ( convolve_support, di_df, grids_f%deriv_flags, &
      & drad_df_out )
d293 1
a293 1
           & SbRatio, Update, Ptan, Chi_Out, Radiance, &
d299 1
a299 1
    use MLSCommon, only: R8, RP
d301 1
d317 2
d330 3
d345 7
a351 2
      call InterpolateValues ( coeffs, chi_in, rad_in, chi_out, rad_out, &
                             & METHOD='S', extrapolate='C', dyByDx=di_dx )
d362 7
a368 2
      call InterpolateValues ( coeffs, chi_in, rad_in, chi_out, rad_out, &
                             & METHOD='S', extrapolate='C' )
d382 1
a382 1
           & di_dT, Jacobian, RowFlags )
d386 1
a386 1
    use MLSCommon, only: R8, RP
d388 1
d402 2
d414 1
d418 2
d439 8
a446 3
          call InterpolateValues ( coeffs, chi_in, dRad_dT_in, &
                                 & chi_out, dRad_dT_out, &
                                 & method = 'S', extrapolate = 'C' )
d460 2
a461 2
             & SbRatio, Update, Chi_Out, Radiance, Qtys, Grids_f, dI_df, &
             & Jacobian, RowFlags, Linear )
d466 1
a466 1
    use MLSCommon, only: R8, RP
d468 1
d482 2
d501 3
d533 4
a536 1
            if ( myLinear ) then
d635 1
a635 1
       "$Id: Convolve_All_m.f90,v 2.1 2005/07/06 02:16:54 vsnyder Exp $"
d644 3
@


2.1
log
@Initial commit, replacing convolve_all_m.f90 and no_conv_at_all.f90
@
text
@d30 1
a30 1
       "$RCSfile: convolve_all_m.f90,v $"
d38 1
a38 1
           & Jacobian, RowFlags, dh_dz_out, dx_dh_out, ptan_Der )
d66 3
d82 2
a83 1
      call fov_convolve_1d ( convolve_support, rad_in, SRad, dRad_dx_out=di_dx )
d85 1
a85 1
      call fov_convolve_1d ( convolve_support, rad_in, SRad )
d114 1
a114 1
           & Rad_In, SbRatio, Update, Radiance, Temp, Grids_Tmp, &
d130 1
d165 2
a166 2
    call fov_convolve_temp_derivs ( convolve_support,  &
      & rad_in, surf_angle, dI_dT, dx_dT, d2x_dxdT,    &
d583 1
a583 1
       "$Id: convolve_all_m.f90,v 2.34 2005/06/22 18:08:18 pwagner Exp $"
d591 4
a594 1
! $Log: $
@

