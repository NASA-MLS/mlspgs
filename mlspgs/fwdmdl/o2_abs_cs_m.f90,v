head	2.23;
access;
symbols
	v5-02-NRT-19:2.23
	v6-00:2.23
	v5-02-NRT-18:2.23
	v5-02:2.23
	v5-01-NRT-17:2.23
	v5-01-NRT-16:2.23
	v5-01-NRT-15:2.23
	v5-01-NRT-14:2.23
	neuralnetworks-1-0:2.23.0.12
	cfm-single-freq-0-1:2.23.0.10
	v5-01:2.23
	v5-00:2.23
	v4-23-TA133:2.23.0.8
	mus-emls-1-70:2.23.0.6
	rel-1-0-englocks-work:2.23.0.4
	VUMLS1-00:2.23
	VPL1-00:2.23
	V4-22-NRT-08:2.23
	VAM1-00:2.23
	V4-21:2.23.0.2
	V4-13:2.23
	V4-12:2.23
	V4-11:2.23
	V4-10:2.23
	V3-43:2.19
	M4-00:2.19
	V3-41:2.19
	V3-40-PlusGM57:2.19.0.2
	V2-24-NRT-04:2.16
	V3-33:2.19
	V2-24:2.16
	V3-31:2.19
	V3-30-NRT-05:2.19
	cfm-01-00:2.19
	V3-30:2.19
	V3-20:2.19
	V3-10:2.18
	V2-23-NRT-02:2.16
	V2-23:2.16
	V2-22-NRT-01:2.16
	V2-22:2.16
	V2-21:2.15
	V2-20:2.15
	V2-11:2.15
	V2-10:2.15
	V2-00:2.15
	V1-51:2.12
	V1-50:2.12
	V1-45:2.12
	V1-44:2.12
	V1-43:2.12
	V1-32:2.9
	V1-31:2.9
	V1-30:2.9
	V1-13:2.1
	V1-12:2.1
	V1-11:2.1
	V1-10:2.1
	newfwm-feb03:2.1.0.2;
locks; strict;
comment	@# @;


2.23
date	2014.04.04.19.43.10;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2014.04.02.17.05.59;	author wgread;	state Exp;
branches;
next	2.21;

2.21
date	2013.06.12.02.33.02;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2013.04.27.01.10.54;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2010.02.04.23.09.28;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.17;

2.17
date	2009.05.13.20.03.02;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2007.05.23.22.45.08;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2005.07.06.02.13.31;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2005.06.09.02.34.16;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2005.01.20.02.51.28;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2004.04.24.02.26.54;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2004.04.17.00.37.00;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2004.04.02.01.00.20;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2003.08.15.00.17.45;	author michael;	state Exp;
branches;
next	2.8;

2.8
date	2003.08.14.02.15.03;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2003.06.03.23.58.38;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2003.05.19.19.58.07;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2003.05.17.00.30.39;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2003.05.16.23.52.53;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2003.05.16.02.45.08;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2003.05.05.23.00.26;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2003.02.03.22.55.26;	author vsnyder;	state Exp;
branches
	2.1.2.1;
next	;

2.1.2.1
date	2003.02.27.23.35.24;	author vsnyder;	state Exp;
branches;
next	2.1.2.2;

2.1.2.2
date	2003.03.01.03.11.02;	author vsnyder;	state Exp;
branches;
next	2.1.2.3;

2.1.2.3
date	2003.03.01.03.13.47;	author vsnyder;	state Exp;
branches;
next	2.1.2.4;

2.1.2.4
date	2003.03.01.03.15.19;	author vsnyder;	state Exp;
branches;
next	2.1.2.5;

2.1.2.5
date	2003.03.05.03.29.59;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.23
log
@Move computation of QN from get_beta_path to o2_abs_cs.  This avoids the
need for an array temp.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module O2_Abs_CS_M

  implicit NONE
  private
  public :: O2_Abs_CS, D_O2_Abs_CS_dT

  integer :: O2_in_catalog = -1   ! Index in Spectroscopy catalog of O2 line.

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: ModuleName= &
    &  "$RCSfile: o2_abs_cs_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------

contains

! ----------------------------------------------------  O2_Abs_CS  -----
  pure subroutine O2_Abs_CS ( Freq, H, Slabs, Sigma_p, Pi, Sigma_m )

! Compute the complex absorption cross section.
! Modified to use Voigt with interfered lineshape

    use MLSKinds, only: IP, R8, Rk => RP
    use SpectroscopyCatalog_m, only: Lines
    use Slabs_SW_m, only: SLABS_STRUCT
    use Constants, only: SqrtPi

    real(r8), intent(in) :: Freq              ! Observation frequency
    real(rk), intent(in) :: H                 ! Magnetic field
    type(slabs_struct), intent(in) :: Slabs   ! contains, among others:
!    v0s(:)         ! pressure shifted line centers
!    x1(:)          ! Doppler width
!    y(:)           ! ratio Pressure to Doppler widths
!    yi(:)          ! Interference coefficients
!    slabs1(:)      ! strengths

    complex(rk), intent(out) :: Sigma_p       ! Output Beta values
    complex(rk), intent(out) :: Pi
    complex(rk), intent(out) :: Sigma_m

    integer(ip) :: J, K, No_lines
    integer :: QN                             ! Quantum number
    real(rk) :: F_o_v0, Z, Denomm
    real(r8) :: V0                            ! zero field line center frequency

    complex(rk) :: Wing

    no_lines = size(slabs%catalog%lines)
    associate ( polarized => slabs%catalog%polarized )

      sigma_p = 0.0_rk
      pi = 0.0_rk
      sigma_m = 0.0_rk
      wing = 0.0_rk

! Do magnetic calculation even if h = 0 for all of the Zeeman-split lines

      do j = 1, no_lines

        if ( .not. polarized(j) ) cycle

        v0 = lines(slabs%catalog%lines(j))%v0
        ! Compute the quantum number.  Unfortunately, we can't put this in
        ! a function because the dummy argument corresponding to
        ! lines(slabs%catalog%lines(j))%qn would be a pointer.  This falls
        ! afoul of Constraint C1293, item (6) in the 2008 Fortran standard.
        k = 0
        qn = -1 ! ??? Is this a reasonable default ???
        if ( associated(lines(slabs%catalog%lines(j))%qn) ) &
          & k = size(lines(slabs%catalog%lines(j))%qn)
        if ( k >= 3 ) qn = sign( lines(slabs%catalog%lines(j))%qn(2), &
                               & lines(slabs%catalog%lines(j))%qn(k) - &
                               & lines(slabs%catalog%lines(j))%qn((k+1)/2) )

        call mag_o2_abs_cs ( qn, freq, v0, h,                             &
          &                  slabs%s(j)%x1, slabs%s(j)%slabs1,            &
          &                  slabs%s(j)%y, slabs%s(j)%yi, slabs%s(j)%v0s, &
          &                  sigma_p, pi, sigma_m )

!{ Fill in negative frequency part of VVW lineshape for jth line
!
!  $W = \frac12 S \frac{\nu}{\nu_0} \left[
!         \frac{y-y_i z}D +
!       i \left(\frac{z + \frac{y}{\nu_{0_s}} \left( \frac{y}{x_1} - \nu y_i \right)}{D} -
!               \frac2{x_1 \nu_{0_s}} \right) \right]$, where
!  $z = x_1 ( \nu + \nu_{0_s} )$ and $D = \sqrt{\pi} ( z^2 + y^2 )$

        f_o_v0 = freq / v0
        z = slabs%s(j)%x1 * (slabs%s(j)%v0s + freq)
        denomm = sqrtPi * (z*z + slabs%s(j)%y*slabs%s(j)%y)
        wing = wing + ( 0.5_rk * slabs%s(j)%slabs1 * f_o_v0 ) * cmplx( &
          &  (slabs%s(j)%y - slabs%s(j)%yi*z) / denomm, & ! Real part
          & (z + slabs%s(j)%y * (slabs%s(j)%y/slabs%s(j)%x1 -   & ! Imaginary part...
          &   freq*slabs%s(j)%yi) / slabs%s(j)%v0s) / denomm -  &
          &   2.0_rk/(slabs%s(j)%x1 * slabs%s(j)%v0s),          &
          & kind=rk)

      end do

      sigma_p = sigma_p + 0.5_rk * wing
      pi = pi + wing
      sigma_m = sigma_m + 0.5_rk * wing

    end associate

! Contribution from non-Zeeman-split lines is done in get_beta_path_scalar.

! Non resonant contribution is done in get_beta_path_scalar too.

  end subroutine O2_Abs_CS

! -----------------------------------------------  D_O2_Abs_CS_dT  -----
  pure subroutine D_O2_Abs_CS_dT ( Freq, H, Slabs, Sigma_p, Pi, Sigma_m, &
    &                         dSigma_p_dT, dPi_dT, dSigma_m_dT )

! Compute the complex absorption cross section and its temperature derivative.
! Modified to use Voigt with interfered lineshape

    use MLSCommon, only: IP, R8, Rk => RP
    use Slabs_SW_m, only: SLABS_STRUCT
    use SpectroscopyCatalog_m, only: Lines
    use Constants, only: SqrtPi

    real(r8), intent(in) :: Freq              ! Observation frequency
    real(rk), intent(in) :: H                 ! Magnetic field
    type(slabs_struct), intent(in) :: Slabs   ! contains, among others:
!    v0s(:)         ! pressure shifted line centers
!    x1(:)          ! Doppler width
!    y(:)           ! ratio Pressure to Doppler widths
!    yi(:)          ! Interference coefficients
!    slabs1(:)      ! strengths

    complex(rk), intent(out) :: Sigma_p       ! Output Beta values
    complex(rk), intent(out) :: Pi
    complex(rk), intent(out) :: Sigma_m

    complex(rk), intent(out) :: dSigma_p_dT   ! Output dBeta_dT values
    complex(rk), intent(out) :: dPi_dT
    complex(rk), intent(out) :: dSigma_m_dT

    integer(ip) :: J, K, No_lines
    integer :: QN                             ! Quantum number

    real(r8) :: V0                            ! zero field line center frequency

    real(rk) ::  D,  I1,  I2,  I3,  I4,  R1,  R2,  S, S1, SIGMA, Y2, Z
    real(rk) :: dD, dI1, dI2, dI3, dI4, dR1, dR2,         dZ ! 1/p dp/dT
    real(rk) :: dv0 ! 1/v0s dv0s/dT
    real(rk), parameter :: OneOvSqpi = 1.0_rk / sqrtPi
    complex(rk) :: Wing, dWing

    no_lines = size(slabs%catalog%lines)
    associate ( polarized => slabs%catalog%polarized )

      sigma_p = 0.0_rk
      pi = 0.0_rk
      sigma_m = 0.0_rk
      wing = 0.0_rk
      dSigma_p_dT = 0.0_rk
      dPi_dT = 0.0_rk
      dSigma_m_dT = 0.0_rk
      dWing = 0.0_rk

! Do magnetic calculation even if h = 0 for all of the Zeeman-split lines

      do j = 1, no_lines

        if ( .not. polarized(j) ) cycle

        v0 = lines(slabs%catalog%lines(j))%v0
        ! Compute the quantum number.  Unfortunately, we can't put this in
        ! a function because the dummy argument corresponding to
        ! lines(slabs%catalog%lines(j))%qn would be a pointer.  This falls
        ! afoul of Constraint C1293, item (6) in the 2008 Fortran standard.
        k = 0
        qn = -1 ! ??? Is this a reasonable default ???
        if ( associated(lines(slabs%catalog%lines(j))%qn) ) &
          & k = size(lines(slabs%catalog%lines(j))%qn)
        if ( k >= 3 ) qn = sign( lines(slabs%catalog%lines(j))%qn(2), &
                               & lines(slabs%catalog%lines(j))%qn(k) - &
                               & lines(slabs%catalog%lines(j))%qn((k+1)/2) )

        call d_mag_o2_abs_cs_dT ( qn, freq, v0, h,                      &
          &  slabs%s(j)%x1,     slabs%s(j)%slabs1,     slabs%s(j)%y,    &
          &  slabs%s(j)%yi,     slabs%s(j)%v0s,                         &
          & slabs%d(j)%dx1_dT, slabs%d(j)%dslabs1_dT, slabs%d(j)%dy_dT, &
          & slabs%d(j)%dyi_dT, slabs%d(j)%dv0s_dT,                      &
          &  sigma_p,     pi,     sigma_m,                              &
          & dSigma_p_dT, dPi_dT, dSigma_m_dT )

!{ Fill in negative frequency part of VVW lineshape for jth line
!
!  $W = \frac12 S \frac{\nu}{\nu_0} \left[
!         \frac{y-y_i z}D +
!       i \left(\frac{z + \frac{y}{\nu_{0_s}} \left( \frac{y}{x_1} - \nu y_i \right)}{D} -
!               \frac2{x_1 \nu_{0_s}} \right) \right]$, where
!  $z = x_1 \sigma$, $\sigma = \nu + \nu_{0_s}$ and
!  $D = \sqrt{\pi} ( z^2 + y^2 )$.
!
!  Expanding the terms we have $W = R_1 - R_2 + i(I_1 + I_2 - I_3 - I_4)$
!  where $R_1 = \frac12 S \frac{\nu}{\nu_0} \frac{y}D$,
!        $R_2 = \frac12 S \frac{\nu}{\nu_0} \frac{y_i z}D$,
!        $I_1 = \frac12 S \frac{\nu}{\nu_0} \frac{z}{D}$,
!        $I_2 = \frac12 S \frac{\nu}{\nu_0} \frac{y^2}{D x_1 \nu_{0_s}}$,
!        $I_3 = \frac12 S \frac{\nu}{\nu_0} \frac{\nu y y_i}{D \nu_{0_s}}$, and
!        $I_4 = \frac12 S \frac{\nu}{\nu_0} \frac2{x_1 \nu_{0_s}}$, from which
!  $\frac1{R_1}\frac{\partial R_1}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} + \frac1y \frac{\partial y}{\partial T}
!      - \frac1D \frac{\partial D}{\partial T}$,
!  $\frac1{R_2}\frac{\partial R_2}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} + \frac1{y_i} \frac{\partial y_i}{\partial T}
!      + \frac1z \frac{\partial z}{\partial T} - \frac1D \frac{\partial D}{\partial T}$,
!  $\frac1{I_1}\frac{\partial I_1}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} + \frac1z \frac{\partial z}{\partial T}
!      - \frac1D \frac{\partial D}{\partial T}$,
!  $\frac1{I_2}\frac{\partial I_2}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} + 2\frac1y \frac{\partial y}{\partial T}
!      - \frac1D \frac{\partial D}{\partial T} - \frac1{\nu_{0_s}} \frac{\partial \nu_{0_s}}{\partial T}
!      - \frac1{x_1} \frac{\partial x_1}{\partial T}$,
!  $\frac1{I_3}\frac{\partial I_3}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} + \frac1y \frac{\partial y}{\partial T}
!      + \frac1{y_i} \frac{\partial y_i}{\partial T} - \frac1D \frac{\partial D}{\partial T}
!      - \frac1{\nu_{0_s}} \frac{\partial \nu_{0_s}}{\partial T}$,
!  $\frac1{I_4}\frac{\partial I_4}{\partial T}
!      = \frac1S \frac{\partial S}{\partial T} - \frac1{x_1} \frac{\partial x_1}{\partial T}
!      - \frac1{\nu_{0_s}} \frac{\partial \nu_{0_s}}{\partial T}$,
!  $\frac1D \frac{\partial D}{\partial T}
!    = 2 \frac{ z \frac{\partial z}{\partial T} + y \frac{\partial y}{\partial T}}
!             {z^2+y^2}
!    = \frac{2 \sqrt{\pi}}D
!      \left(z^2 \frac1z \frac{\partial z}{\partial T}
!          + y^2 \frac1y \frac{\partial y}{\partial T} \right)$ and
!  $\frac1z \frac{\partial z}{\partial T}
!    = \frac1{x_1} \frac{\partial x_1}{\partial T}
!    + \frac1{\sigma} \frac{\partial \nu_{0_s}}{\partial T}$.
!  Finally, we have
!  $\frac{\partial W}{\partial T} =
!     R_1 \left( \frac1{R_1}\frac{\partial R_1}{\partial T} \right)
!   + R_2 \left( \frac1{R_1}\frac{\partial R_2}{\partial T} \right)
!   + i \left[
!     I_1 \left( \frac1{I_1}\frac{\partial I_1}{\partial T} \right)
!   + I_2 \left( \frac1{I_2}\frac{\partial I_2}{\partial T} \right)
!   + I_3 \left( \frac1{I_3}\frac{\partial I_3}{\partial T} \right)
!   + I_4 \left( \frac1{I_4}\frac{\partial I_4}{\partial T} \right)
!     \right]$.
!  The quantities $\frac{\partial \nu_{0_s}}{\partial T}$,
!                 $\frac1{x_1} \frac{\partial x_1}{\partial T}$,
!                 $\frac1{y} \frac{\partial y}{\partial T}$,
!                 $\frac1{y_i} \frac{\partial y_i}{\partial T}$ and
!                 $\frac1{S} \frac{\partial S}{\partial T}$
!  are gotten from the {\tt slabs} structure.

        s = 0.5_rk * slabs%s(j)%slabs1 * freq / v0
        sigma = freq + slabs%s(j)%v0s
        z = slabs%s(j)%x1 * sigma
        r1 = slabs%s(j)%y
        y2 = r1**2
        r2 = slabs%s(j)%yi*z
        i1 = 1.0_rk / slabs%s(j)%v0s
        i4 = 2.0_rk * i1 / slabs%s(j)%x1
        i2 = y2 * 0.5_rk * i4
        i3 = freq * r1 * slabs%s(j)%yi * i1
        dv0 = slabs%d(j)%dv0s_dT * i1 ! 1/v0s dv0s/dT
        i1 = z
        d = oneOvSqpi / (z*z + y2)

        wing = wing + s * cmplx ( d * (r1 - r2), d * (i1 + i2 - i3) - i4, kind=rk )

        dz = slabs%d(j)%dx1_dT + slabs%d(j)%dv0s_dT / sigma
        dD = (2.0_rk * sqrtPi) * ( z**2 * dz + y2 * slabs%d(j)%dy_dT ) * d
        s1 = slabs%d(j)%dslabs1_dT - dD ! 1/S dS/dT - 1/D dD/dT

        dr1 = s1 + slabs%d(j)%dy_dT
        dr2 = s1 + slabs%d(j)%dyi_dT + dz

        di1 = s1 + dz
        di2 = s1 - dv0 + 2.0_rk * slabs%d(j)%dy_dT - slabs%d(j)%dx1_dT
        di3 = s1 - dv0 + slabs%d(j)%dy_dT + slabs%d(j)%dyi_dT
        di4 = slabs%d(j)%dslabs1_dT - slabs%d(j)%dx1_dT - dv0

        dWing = dWing + s * &
          &             cmplx ( d * (r1 * dr1 - r2 * dr2), &
          &                     d * (i1 * di1 + i2 * di2 - i3 * di3) - i4 * di4, &
          &                     kind=rk )

      end do

      sigma_p = sigma_p + 0.5_rk * wing
      pi =      pi      + wing
      sigma_m = sigma_m + 0.5_rk * wing

      dsigma_p_dT = dsigma_p_dT + 0.5_rk * dWing
      dpi_dT      = dpi_dT      + dWing
      dsigma_m_dT = dsigma_m_dT + 0.5_rk * dWing

    end associate

! Contribution from non-Zeeman-split lines is done in get_beta_path_scalar.

! Non resonant contribution is done in get_beta_path_scalar too.

  end subroutine D_O2_Abs_CS_dT

! ------------------------------------------------  Mag_O2_Abs_CS  -----
  pure subroutine Mag_O2_Abs_CS ( n, nu, v0, h, x1, s, w, y, v0s, &
    &                        sigma_p, pi, sigma_m )

! Compute the frequency dependent absorption cross section for magnetic o2.

! Other notes:
! Document refers to "MLS Spectroscopic Data Base" W. G. Read, Version 1.0
! October 19, 1990.

    use MLSCommon, only: IP, R8, Rk => RP
    use Physics, only: Bohr, G_e
    use Voigt_m, only: Simple_Voigt

    integer, intent(in) :: N    ! rotational quantum number, sign indicates delta J
    real(r8), intent(in) :: Nu  ! transmission frequency in MHz
    real(r8), intent(in) :: V0  ! zero magnetic field line position
    real(rk), intent(in) :: H   ! magnetic field in Gauss
    real(r8), intent(in) :: X1  ! Doppler width factor sqrt(ln 2) / D_width
    real(r8), intent(in) :: S   ! strength factor slabs1 from slabs routine
    real(r8), intent(in) :: W   ! collision to doppler width ratio in the
                                ! document corrected for temperature and pressure
    real(r8), intent(in) :: Y   ! interference coefficient in the document
                                ! corrected for pressure and temperature
    real(r8), intent(in) :: V0S ! Pressure-shifted zero magnetic field line position

    complex(rk), intent(inout) :: Sigma_P ! absorption coefficient at unity mixing
                                ! ratio for Delta M = +1
    complex(rk), intent(inout) :: Pi ! absorption coefficient at unity mixing
                                ! ratio for Delta M = 0
    complex(rk), intent(inout) :: Sigma_M ! absorption coefficient at unity mixing
                                ! ratio for Delta M = -1
    integer(ip) :: M

    real(rk), parameter :: Kappa = Bohr * G_e ! ~ 2.8024

    real(rk) :: Del_nu, Denom1, Denom2, F_o_v0, KappaH, Nu_offst
    real(rk) :: U, V, WW, Z, Zr, Zi
    real(rk) :: X

    real(rk) :: Xi ! This is actually 0.5 \xi \frac{\nu}{\nu_0} from the
                   ! ATBD, not just \xi.

! Compute the absorption coefficient at unity mixing ratio for N transition

    if ( n == 0 ) return

    f_o_v0 = nu / v0
    del_nu = v0s - nu
    kappaH = kappa * h ! H is magnetic field in Gauss here, not Planck's constant
    x = w / ( x1 * nu )
    ww = w

    if ( n == -1 ) then

!     n = -1 => denom1 = =  n * (n - 1) == 2,
!               denom2 = -n * (4 * n * n - 1) == 3

!     denom1 =  2 ! n * (n - 1)
!     denom2 =  3 ! -n * (4 * n * n - 1)

!     m = n

! sigma_p transition

! m == n == -1 => ((m+1)*(2-n)-1) == -1
!     nu_offst = x1*(del_nu + kappa*((m+1)*(2-n)-1)*h / denom1)
      nu_offst = x1 * ( del_nu - 0.5_rk*kappaH )
      call simple_voigt ( nu_offst, ww, u, v )
! m == n == -1 and denom2 == 3 => xi == 0.5
!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
!     xi = 0.5_rk
!     z  = 0.5_rk * s * xi * f_o_v0
      z  = 0.25_rk * s * f_o_v0
      zr = z * (u - y*v)
      zi = z * (v + u * (x + y))
      sigma_p = sigma_p + cmplx(zr, zi, kind=rk)

!     m = -n

! sigma_m transition

! m == -n == 1 => ((m-1)*(2-n)+1) == +1
!     nu_offst = x1*(del_nu + kappa*((m-1)*(2-n)+1)*h / denom1)
      nu_offst = x1 * (del_nu + 0.5_rk*kappaH )
      call simple_voigt ( nu_offst, ww, u, v )
! m == -n == 1 and denom2 == 3 => xi == 0.5
!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
!     xi = 0.5_rk
!     z  =  0.5_rk * s * xi * f_o_v0
!     z  =  0.25_rk * s * f_o_v0
      zr = z * (u - y*v)
      zi = z * (v + u * (x + y))
      sigma_m = sigma_m + cmplx(zr, zi, kind=rk)

!     m = n + 1

! pi transition

! m == n + 1 == 0 => kappa*m*(2-n)*h == 0
!     nu_offst = x1*(del_nu + kappa*m*(2-n)*h / denom1)
      nu_offst = x1 * del_nu
      call simple_voigt ( nu_offst, ww, u, v )
! m == n + 1 == 0 and denom2 == 3 => xi == 1.0
!     xi = 3.0_rk * (n * n - m * m) / denom2
!     z  = 0.5_rk * s * xi * f_o_v0
!     z  = 0.5_rk * s * f_o_v0
      z = 2.0_rk * z
      zr = z * (u - y*v)
      zi = z * (v + u * (x + y))
      pi = pi + cmplx(zr, zi, kind=rk)

    else if ( n > 0 ) then

! Delta J = +1

      denom1 = n * (n + 1)
      denom2 = (n + 1) * (2 * n +1) * (2 * n + 3)

      do m = -n , n

! pi transition

        nu_offst = x1*(del_nu + kappaH*m*(1-n) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * ((n + 1) * (n + 1) - m * m) / denom2
        xi = 1.5_rk * ((n + 1) * (n + 1) - m * m) / denom2 * f_o_v0
        z  = s * xi
        zr = z * (u - y * v)
        zi = z * (v + u  * (w / (x1*nu) + y))
        pi = pi + cmplx(zr, zi, kind=rk)

! sigma_p transition

        nu_offst = x1*(del_nu + kappaH*(m*(1-n)-n) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * (n + m + 1) * (n + m + 2) / (4.0_rk * denom2)
        xi = 0.375_rk * (n + m + 1) * (n + m + 2) / denom2 * f_o_v0
        z  = s * xi
        zr = z  * (u - y * v)
        zi = z * (v + u  * (w/(x1 * nu) + y))
        sigma_p = sigma_p + cmplx(zr, zi, kind=rk)

! sigma_m transition

        nu_offst = x1*(del_nu + kappaH*(m*(1-n)+n) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * (n - m + 1) * (n - m + 2) / (4.0_rk * denom2)
        xi = 0.375_rk * (n - m + 1) * (n - m + 2) / denom2 * f_o_v0
        z  = s * xi
        zr = z * (u - y * v)
        zi = z * (v + u  * (x + y))
        sigma_m = sigma_m + cmplx(zr, zi, kind=rk)

      end do

    else ! n < -1

! Delta J = -1 n is a negative number

      denom1 =  n * (n - 1)
      denom2 = -n * (4 * n * n - 1)

      do m = n+2 , -(n+2)

! pi transition

        nu_offst = x1*(del_nu + kappaH*m*(2-n) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * (n * n - m * m) / denom2
        xi = 1.5_rk * (n * n - m * m) / denom2 * f_o_v0
        z  = s * xi
        zr = z * (u - y * v)
        zi = z * (v + u  * (x + y))
        pi = pi + cmplx(zr, zi, kind=rk)

! sigma_p transition

        nu_offst = x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
        xi = 0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0
        z  = s * xi
        zr = z * (u - y*v)
        zi = z * (v + u  * (x + y))
        sigma_p = sigma_p + cmplx(zr, zi, kind=rk)

! sigma_m transition

        nu_offst = x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1)
        call simple_voigt ( nu_offst, ww, u, v )
!       xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
        xi = 0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0
        z  = s * xi
        zr = z * (u - y * v)
        zi = z * (v + u  * (x + y))
        sigma_m = sigma_m + cmplx(zr, zi, kind=rk)

      end do

! Finish off special transition cases for pi and sigmas
! m = -n

      m = n

! sigma_p transition

      nu_offst = x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      xi = 0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      sigma_p = sigma_p + cmplx(zr, zi, kind=rk)

! m = n

      m = -n

! sigma_m transition

      nu_offst = x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      xi = 0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      sigma_m = sigma_m + cmplx(zr, zi, kind=rk)

! m = -(n-1)

      m = n + 1

! pi transition

      nu_offst = x1*(del_nu + kappaH*m*(2-n) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (n * n - m * m) / denom2
      xi = 1.5_rk * (n * n - m * m) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      pi = pi + cmplx(zr, zi, kind=rk)

! sigma_p transition

      nu_offst = x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      xi = 0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      sigma_p = sigma_p + cmplx(zr, zi,kind=r8)

! m = n - 1

      m = -(n + 1)

! pi transition

      nu_offst = x1*(del_nu + kappaH*m*(2-n) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (n * n - m * m) / denom2
      xi = 1.5_rk * (n * n - m * m) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      pi = pi + cmplx(zr, zi, kind=rk)

! sigma_m transition

      nu_offst = x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1)
      call simple_voigt ( nu_offst, ww, u, v )
!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      xi = 0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0
      z  = s * xi
      zr = z * (u - y*v)
      zi = z * (v + u  * (x + y))
      sigma_m = sigma_m + cmplx(zr, zi, kind=rk)

    end if

  end subroutine Mag_O2_Abs_CS

! -------------------------------------------  d_Mag_O2_Abs_CS_dT  -----
  pure subroutine d_Mag_O2_Abs_CS_dT ( n, nu, v0, h, x1,  s,  w,  y,  v0s, &
    &                                                dx1, ds, dw, dy, dv0s, &
    &                                  sigma_p,     pi,     sigma_m,      &
    &                                 dSigma_p_dT, dPi_dT, dSigma_m_dT )

! Compute the frequency dependent absorption cross section for magnetic o2
! and its temperature derivative.

! Other notes:
! Document refers to "MLS Spectroscopic Data Base" W. G. Read, Version 1.0
! October 19, 1990.

    use MLSCommon, only: IP, R8, Rk => RP
    use Physics, only: Bohr, G_e
    use Voigt_m, only: D_Simple_Voigt

    integer, intent(in) :: N     ! rotational quantum number, sign indicates delta J
    real(r8), intent(in) :: Nu   ! transmission frequency in MHz
    real(r8), intent(in) :: V0   ! zero magnetic field line position
    real(rk), intent(in) :: H    ! magnetic field in Gauss
    real(r8), intent(in) :: X1   ! Doppler width factor sqrt(ln 2) / D_width
    real(r8), intent(in) :: S    ! strength factor slabs1 from slabs routine
    real(r8), intent(in) :: W    ! collision to doppler width ratio in the
                                 ! document corrected for temperature and pressure
    real(r8), intent(in) :: Y    ! interference coefficient in the document
                                 ! corrected for pressure and temperature
    real(r8), intent(in) :: V0S  ! Pressure-shifted zero magnetic field line position

    real(r8), intent(in) :: dx1  ! 1/x1 dx1/dT
    real(r8), intent(in) :: ds   ! 1/S  dS/dT
    real(r8), intent(in) :: dw   ! 1/w  dw/dT
    real(r8), intent(in) :: dy   ! 1/y  dy/dT
    real(r8), intent(in) :: dv0s ! dv0s/dT, not 1/v0s dv0s/dT

    complex(rk), intent(inout) :: Sigma_P ! absorption coefficient at unity mixing
                                 ! ratio for Delta M = +1
    complex(rk), intent(inout) :: Pi ! absorption coefficient at unity mixing
                                 ! ratio for Delta M = 0
    complex(rk), intent(inout) :: Sigma_M ! absorption coefficient at unity mixing
                                 ! ratio for Delta M = -1

    complex(rk), intent(inout) :: dSigma_P_dT ! d sigma_p / dT
    complex(rk), intent(inout) :: dPi_dT      ! d pi      / dT
    complex(rk), intent(inout) :: dSigma_M_dT ! d sigma_m /dT
    integer(ip) :: M

    real(rk), parameter :: Kappa = Bohr * G_e ! ~ 2.8024

    real(rk) :: Del_nu, Denom1, Denom2, F_o_v0, KappaH! , Nu_offst
    real(rk) :: dNu_offst, dDel_nu
    real(rk) :: X, dX, WW, WdW

! Compute the absorption coefficient at unity mixing ratio for N transition

    if ( n == 0 ) return

    f_o_v0 = nu / v0
    del_nu = v0s - nu
    dDel_nu = dv0s
    dNu_offst = x1 * ( dx1 * del_nu + dDel_nu ) ! dx1 = 1/x1 d x1 / dT
    kappaH = kappa * h
    x = w / ( x1 * nu )
    dX = x * ( dw - dx1 ) ! dw is 1/w dw/dT, dx1 is 1/dx1 dx1/dT
    ww = w
    wdw = w * dw

    if ( n == -1 ) then

!     n = -1 => denom1 = =  n * (n - 1) == 2,
!               denom2 = -n * (4 * n * n - 1) == 3

!     denom1 =  2 ! n * (n - 1)
!     denom2 =  3 ! -n * (4 * n * n - 1)

!     m = n

! sigma_p transition

! m == n == -1 => ((m+1)*(2-n)-1) == -1
!     nu_offst = x1*(del_nu + kappa*((m+1)*(2-n)-1)*h / denom1)
! m == n == -1 and denom2 == 3 => xi == 0.5
!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      call absorption ( x1 * ( del_nu - 0.5_rk*kappaH ), &
        &               0.25_rk * f_o_v0, sigma_p, dSigma_p_dT )

!     m = -n

! sigma_m transition

! m == -n == 1 => ((m-1)*(2-n)+1) == +1
!     nu_offst = x1*(del_nu + kappa*((m-1)*(2-n)+1)*h / denom1)
! m == -n == 1 and denom2 == 3 => xi == 0.5
!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      call absorption ( x1 * (del_nu + 0.5_rk*kappaH), &
        &               0.25_rk * f_o_v0, sigma_m, dSigma_m_dT )

!     m = n + 1

! pi transition

! m == n + 1 == 0 => kappa*m*(2-n)*h == 0
!     nu_offst = x1*(del_nu + kappa*m*(2-n)*h / denom1)
! m == n + 1 == 0 and denom2 == 3 => xi == 1.0
!     xi = 3.0_rk * (n * n - m * m) / denom2
      call absorption ( x1 * del_nu, 0.5_rk * f_o_v0, pi, dPi_dT )

    else if ( n > 0 ) then

! Delta J = +1

      denom1 = n * (n + 1)
      denom2 = (n + 1) * (2 * n +1) * (2 * n + 3)

      do m = -n , n

! pi transition

!       xi = 3.0_rk * ((n + 1) * (n + 1) - m * m) / denom2
        call absorption ( x1*(del_nu + kappaH*m*(1-n) / denom1), &
          &               1.5_rk * ((n + 1) * (n + 1) - m * m) / denom2 * f_o_v0, &
          &               pi, dPi_dT )

! sigma_p transition

!       xi = 3.0_rk * (n + m + 1) * (n + m + 2) / (4.0_rk * denom2)
        call absorption ( x1*(del_nu + kappaH*(m*(1-n)-n) / denom1), &
          &               0.375_rk * (n + m + 1) * (n + m + 2) / denom2 * f_o_v0, &
          &               sigma_p, dSigma_p_dT )

! sigma_m transition

!       xi = 3.0_rk * (n - m + 1) * (n - m + 2) / (4.0_rk * denom2)
        call absorption ( x1*(del_nu + kappaH*(m*(1-n)+n) / denom1), &
          &               0.375_rk * (n - m + 1) * (n - m + 2) / denom2 * f_o_v0, &
          &               sigma_m, dSigma_m_dT )

      end do

    else ! n < -1

! Delta J = -1 n is a negative number

      denom1 =  n * (n - 1)
      denom2 = -n * (4 * n * n - 1)

      do m = n+2 , -(n+2)

! pi transition

!       xi = 3.0_rk * (n * n - m * m) / denom2
        call absorption ( x1*(del_nu + kappaH*m*(2-n) / denom1), &
          &               1.5_rk * (n * n - m * m) / denom2 * f_o_v0, pi, dPi_dT )

! sigma_p transition

!       xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
        call absorption ( x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1), &
          &               0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0, &
          &               sigma_p, dSigma_p_dT )

! sigma_m transition

!       xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
        call absorption ( x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1), &
          &               0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0, &
          &               sigma_m, dSigma_m_dT )

      end do

! Finish off special transition cases for pi and sigmas
! m = -n

      m = n

! sigma_p transition

!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      call absorption ( x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1), &
        &               0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0, &
        &               sigma_p, dSigma_p_dT )

! m = n

      m = -n

! sigma_m transition

!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      call absorption ( x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1), &
        &               0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0, &
        &               sigma_m, dSigma_m_dT )

! m = -(n-1)

      m = n + 1

! pi transition

!     xi = 3.0_rk * (n * n - m * m) / denom2
      call absorption ( x1*(del_nu + kappaH*m*(2-n) / denom1), &
        &               1.5_rk * (n * n - m * m) / denom2 * f_o_v0, pi, dPi_dT )

! sigma_p transition

!     xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      call absorption ( x1*(del_nu + kappaH*((m+1)*(2-n)-1) / denom1), &
        &               0.375_rk * (n + m) * (n + m + 1) / denom2 * f_o_v0, &
        &               sigma_p, dSigma_p_dT )

! m = n - 1

      m = -(n + 1)

! pi transition

!     xi = 3.0_rk * (n * n - m * m) / denom2
      call absorption ( x1*(del_nu + kappaH*m*(2-n) / denom1), &
                        1.5_rk * (n * n - m * m) / denom2 * f_o_v0, pi, dPi_dT )

! sigma_m transition

!     xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      call absorption ( x1*(del_nu + kappaH*((m-1)*(2-n)+1) / denom1), &
        &               0.375_rk * (m - n) * (m - n - 1) / denom2 * f_o_v0, &
        &               sigma_m, dSigma_m_dT )

    end if

  contains

    pure subroutine Absorption ( nu_offst, xi, r, dr ) ! Update r ("result"), dr

      real(rk), intent(in) :: nu_offst ! x1*(del_nu + kappa*...*h/...)
      real(rk), intent(in) :: Xi ! This is actually 0.5 \xi \frac{\nu}{\nu_0}
        !                          from the ATBD, not just \xi.
      complex(rk), intent(inout) :: R, dR

      real(rk) :: U, dU, v, dV, Z, Zr, dZr, Zi, dZi
      ! dNu_offst, S, dS, w, dW, X, dX, X1, dX1, Y, dY by host association

!{ Compute absorption
!  $A = S \xi \left[ ( u - y_i v) + i ( v + u ( x + y_i ) ) \right]$ where
!  $x = \frac{y}{x_1\nu}$, $u + i v = w(\nu_o+i y)$, and $w(z)$ is the
!  Fadeeva function, and its derivative $\frac{\partial A}{\partial T}$. 
!  Here, $y_i$ is given by the variable {\tt y}, $y$ is given by the
!  variable {\tt ww}, and $\nu_o$ is given by the variable {\tt nu\_offst}.
!
!  $\frac{\partial x}{\partial T} =
!    x \left( \frac1y \frac{\partial y}{\partial T} -
!             \frac1{x_1} \frac{\partial x_1}{\partial T} \right)$.
!
!  $\Re \frac{\partial A}{\partial T} =
!   S \xi \left( \frac1S \frac{\partial S}{\partial T} ( u - y_i v ) +
!                \frac{\partial u}{\partial T} - y_i \left(\frac{\partial v}{\partial T}
!                - v \frac1{y_i} \frac{\partial y_i}{\partial T}\right) \right)$.
!
!  $\Im \frac{\partial A}{\partial T} =
!   S \xi \left( \frac1S \frac{\partial S}{\partial T}
!     (v + u (x + y_i) ) + \frac{\partial v}{\partial T} +
!    \frac{\partial u}{\partial T} ( x + y_i ) +
!    u \left( \frac{\partial x}{\partial T} +
!    y_i \frac1{y_i}\frac{\partial y_i}{\partial T} \right) \right)$

      call d_simple_voigt ( nu_offst, ww, u, v, du, dv, dNu_offst, wdw )
      zr = u - y*v
      dZr = ds * zr + du - y*(dv + dy*v)
      z = x + y
      zi = v + u * z
      dZi = ds * zi + dv + du * z + u * ( dx + y * dy )

      z  = s * xi
      r  =  r + z * cmplx( zr,  zi, kind=rk)
      dr = dr + z * cmplx(dZr, dZi, kind=rk)
    end subroutine Absorption

  end subroutine d_Mag_O2_Abs_CS_dT

! ------------------------------------------------------  Find_O2  -----
  subroutine Find_O2
  ! Find the O2 in the spectroscopy catalog

    use Molecules, only: l_o2
    use SpectroscopyCatalog_m, only: Catalog

    do o2_in_catalog = 1, size(catalog)
      if ( catalog(o2_in_catalog)%molecule == l_o2 ) return
    end do

    o2_in_catalog = -1 ! Not found
  end subroutine Find_O2

! ------------------------------------------------  not_used_here  -----
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: o2_abs_cs_m.f90,v 2.22 2014/04/02 17:05:59 wgread Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module O2_Abs_CS_M

! $Log: o2_abs_cs_m.f90,v $
! Revision 2.22  2014/04/02 17:05:59  wgread
! deleted unused subroutine-wgr
!
! Revision 2.21  2013/06/12 02:33:02  vsnyder
! Cruft removal
!
! Revision 2.20  2013/04/27 01:10:54  vsnyder
! Make routines pure, needed to use ASSOCIATE construct twice
!
! Revision 2.19  2010/02/04 23:09:28  vsnyder
! Use kind= in CMPLX
!
! Revision 2.18  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.17  2009/05/13 20:03:02  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.16  2007/05/23 22:45:08  vsnyder
! New slabs structure
!
! Revision 2.15  2005/07/06 02:13:31  vsnyder
! Correct a comment
!
! Revision 2.14  2005/06/09 02:34:16  vsnyder
! Move stuff from l2pc_pfa_structures to slabs_sw_m
!
! Revision 2.13  2005/01/20 02:51:28  vsnyder
! Delete unused stuff
!
! Revision 2.12  2004/04/24 02:26:54  vsnyder
! Move Voigt stuff to its own module
!
! Revision 2.11  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.10  2004/04/02 01:00:20  vsnyder
! Inching toward analytic temperature derivatives
!
! Revision 2.9  2003/08/15 00:17:45  michael
! Removed extra f_o_v0 terms from mag_o2_abs_cs.  Now zero-field polarized and scalar are consistent.
!
! Revision 2.8  2003/08/14 02:15:03  vsnyder
! Optimize n=-1 special case
!
! Revision 2.7  2003/06/03 23:58:38  vsnyder
! Cosmetic changes
!
! Revision 2.6  2003/05/19 19:58:07  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.5  2003/05/17 00:30:39  pwagner
! Ousted last bogus ref to sp_o2
!
! Revision 2.4  2003/05/16 23:52:53  livesey
! Now uses molecule indices rather than spectags
!
! Revision 2.3  2003/05/16 02:45:08  vsnyder
! Removed USE's for unreferenced symbols
!
! Revision 2.2  2003/05/05 23:00:26  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.1.2.5  2003/03/05 03:29:59  vsnyder
! Add in the wing calculation
!
! Revision 2.1.2.4  2003/03/01 03:15:19  vsnyder
! Finish deleting Get_QN -- form the PUBLIC statement
!
! Revision 2.1.2.3  2003/03/01 03:13:47  vsnyder
! Delete unused procedure Get_QN so we won't need o2_DBase
!
! Revision 2.1.2.2  2003/03/01 03:11:02  vsnyder
! Use 'polarized' array for size, delete nonresonant computation
!
! Revision 2.1.2.1  2003/02/27 23:35:24  vsnyder
! Process all Zeeman-split lines, and no others
!
! Revision 2.1  2003/02/03 22:55:26  vsnyder
! Initial commit
!
@


2.22
log
@deleted unused subroutine-wgr
@
text
@d29 1
a29 1
  pure subroutine O2_Abs_CS ( Freq, Qn, H, Slabs, Sigma_p, Pi, Sigma_m )
d34 1
a34 1
    use MLSCommon, only: IP, R8, Rk => RP
a39 1
    integer(ip), intent(in) :: Qn(:)          ! Quantum numbers
d52 2
a53 1
    integer(ip) :: J, No_lines
d74 14
a87 1
        call mag_o2_abs_cs ( qn(j), freq, v0, h, slabs%s(j)%x1, slabs%s(j)%slabs1, &
d124 1
a124 1
  pure subroutine D_O2_Abs_CS_dT ( Freq, Qn, H, Slabs, Sigma_p, Pi, Sigma_m, &
a135 1
    integer(ip), intent(in) :: Qn(:)          ! Quantum numbers
d152 2
a153 1
    integer(ip) :: J, No_lines
d182 13
a194 1
        call d_mag_o2_abs_cs_dT ( qn(j), freq, v0, h,                   &
d898 1
a898 1
       "$Id: o2_abs_cs_m.f90,v 2.21 2013/06/12 02:33:02 vsnyder Exp $"
d908 3
@


2.21
log
@Cruft removal
@
text
@d16 1
a16 1
  public :: O2_Abs_CS, D_O2_Abs_CS_dT, Get_QN_By_Frequency
a868 37
! ------------------------------------------  Get_QN_By_Frequency  -----
  subroutine Get_QN_By_Frequency ( V0, N )

    ! Get the quantum number for the O2 line that has a center frequency
    ! nearest to V0.  The quantum number of interest is given by the
    ! difference between the fourth and second numbers in the QN field
    ! of the line specification of the spectroscopy database.

    use MLSCommon, only: IP, R8, Rk => RP
    use SpectroscopyCatalog_M, only: Catalog, Lines

    real(r8), intent(in) :: V0
    integer(ip), intent(out) :: N

    integer(ip) :: I, J, K
    real(rk) :: Q, R

    ! Find O2 line the spectroscopy catalog
    if ( o2_in_catalog < 0 ) call find_o2
    n = -1
    ! Find the O2 line that has a center frequency nearest to V0
    j = catalog(o2_in_catalog)%lines(1)
    r = abs(v0-lines(j)%v0)
    do i = 2, size(catalog(o2_in_catalog)%lines)
      k = catalog(o2_in_catalog)%lines(i)
      q = abs(v0-lines(k)%v0)
      if ( q < r ) then
        r = q
        j = k
      end if
    end do
    if ( associated(lines(j)%qn) ) then
      if ( size(lines(j)%qn) >= 4 ) n = lines(j)%qn(4) - lines(j)%qn(2)
    end if
  end subroutine Get_QN_By_Frequency


d873 1
a873 1
       "$Id: o2_abs_cs_m.f90,v 2.20 2013/04/27 01:10:54 vsnyder Exp $"
d883 3
@


2.20
log
@Make routines pure, needed to use ASSOCIATE construct twice
@
text
@a140 2
    logical, pointer :: Polarized(:)          ! Which lines to use.  Same
                                              ! as Slabs%catalog%polarized.
d910 1
a910 1
       "$Id: o2_abs_cs_m.f90,v 2.19 2010/02/04 23:09:28 vsnyder Exp $"
d920 3
@


2.19
log
@Use kind= in CMPLX
@
text
@d29 1
a29 1
  subroutine O2_Abs_CS ( Freq, Qn, H, Slabs, Sigma_p, Pi, Sigma_m )
a53 3
    logical, pointer :: Polarized(:)          ! Which lines to use.  Same
                                              ! as Slabs%catalog%polarized.

d60 1
a60 1
    polarized => slabs%catalog%polarized
d62 4
a65 4
    sigma_p = 0.0_rk
    pi = 0.0_rk
    sigma_m = 0.0_rk
    wing = 0.0_rk
d69 1
a69 1
    do j = 1, no_lines
d71 1
a71 1
      if ( .not. polarized(j) ) cycle
d73 4
a76 4
      v0 = lines(slabs%catalog%lines(j))%v0
      call mag_o2_abs_cs ( qn(j), freq, v0, h, slabs%s(j)%x1, slabs%s(j)%slabs1, &
        &                  slabs%s(j)%y, slabs%s(j)%yi, slabs%s(j)%v0s, &
        &                  sigma_p, pi, sigma_m )
d86 11
a96 9
      f_o_v0 = freq / v0
      z = slabs%s(j)%x1 * (slabs%s(j)%v0s + freq)
      denomm = sqrtPi * (z*z + slabs%s(j)%y*slabs%s(j)%y)
      wing = wing + ( 0.5_rk * slabs%s(j)%slabs1 * f_o_v0 ) * cmplx( &
        &  (slabs%s(j)%y - slabs%s(j)%yi*z) / denomm, & ! Real part
        & (z + slabs%s(j)%y * (slabs%s(j)%y/slabs%s(j)%x1 -   & ! Imaginary part...
        &   freq*slabs%s(j)%yi) / slabs%s(j)%v0s) / denomm -  &
        &   2.0_rk/(slabs%s(j)%x1 * slabs%s(j)%v0s),          &
        & kind=rk)
d98 3
a100 1
    end do
d102 1
a102 3
    sigma_p = sigma_p + 0.5_rk * wing
    pi = pi + wing
    sigma_m = sigma_m + 0.5_rk * wing
d111 1
a111 1
  subroutine D_O2_Abs_CS_dT ( Freq, Qn, H, Slabs, Sigma_p, Pi, Sigma_m, &
d153 1
a153 1
    polarized => slabs%catalog%polarized
d155 8
a162 8
    sigma_p = 0.0_rk
    pi = 0.0_rk
    sigma_m = 0.0_rk
    wing = 0.0_rk
    dSigma_p_dT = 0.0_rk
    dPi_dT = 0.0_rk
    dSigma_m_dT = 0.0_rk
    dWing = 0.0_rk
d166 1
a166 1
    do j = 1, no_lines
d168 1
a168 1
      if ( .not. polarized(j) ) cycle
d170 8
a177 8
      v0 = lines(slabs%catalog%lines(j))%v0
      call d_mag_o2_abs_cs_dT ( qn(j), freq, v0, h,                   &
        &  slabs%s(j)%x1,     slabs%s(j)%slabs1,     slabs%s(j)%y,    &
        &  slabs%s(j)%yi,     slabs%s(j)%v0s,                         &
        & slabs%d(j)%dx1_dT, slabs%d(j)%dslabs1_dT, slabs%d(j)%dy_dT, &
        & slabs%d(j)%dyi_dT, slabs%d(j)%dv0s_dT,                      &
        &  sigma_p,     pi,     sigma_m,                              &
        & dSigma_p_dT, dPi_dT, dSigma_m_dT )
d241 34
a274 32
      s = 0.5_rk * slabs%s(j)%slabs1 * freq / v0
      sigma = freq + slabs%s(j)%v0s
      z = slabs%s(j)%x1 * sigma
      r1 = slabs%s(j)%y
      y2 = r1**2
      r2 = slabs%s(j)%yi*z
      i1 = 1.0_rk / slabs%s(j)%v0s
      i4 = 2.0_rk * i1 / slabs%s(j)%x1
      i2 = y2 * 0.5_rk * i4
      i3 = freq * r1 * slabs%s(j)%yi * i1
      dv0 = slabs%d(j)%dv0s_dT * i1 ! 1/v0s dv0s/dT
      i1 = z
      d = oneOvSqpi / (z*z + y2)

      wing = wing + s * cmplx ( d * (r1 - r2), d * (i1 + i2 - i3) - i4, kind=rk )

      dz = slabs%d(j)%dx1_dT + slabs%d(j)%dv0s_dT / sigma
      dD = (2.0_rk * sqrtPi) * ( z**2 * dz + y2 * slabs%d(j)%dy_dT ) * d
      s1 = slabs%d(j)%dslabs1_dT - dD ! 1/S dS/dT - 1/D dD/dT

      dr1 = s1 + slabs%d(j)%dy_dT
      dr2 = s1 + slabs%d(j)%dyi_dT + dz

      di1 = s1 + dz
      di2 = s1 - dv0 + 2.0_rk * slabs%d(j)%dy_dT - slabs%d(j)%dx1_dT
      di3 = s1 - dv0 + slabs%d(j)%dy_dT + slabs%d(j)%dyi_dT
      di4 = slabs%d(j)%dslabs1_dT - slabs%d(j)%dx1_dT - dv0

      dWing = dWing + s * &
        &             cmplx ( d * (r1 * dr1 - r2 * dr2), &
        &                     d * (i1 * di1 + i2 * di2 - i3 * di3) - i4 * di4, &
        &                     kind=rk )
d276 7
a282 1
    end do
d284 1
a284 7
    sigma_p = sigma_p + 0.5_rk * wing
    pi =      pi      + wing
    sigma_m = sigma_m + 0.5_rk * wing

    dsigma_p_dT = dsigma_p_dT + 0.5_rk * dWing
    dpi_dT      = dpi_dT      + dWing
    dsigma_m_dT = dsigma_m_dT + 0.5_rk * dWing
d293 1
a293 1
  subroutine Mag_O2_Abs_CS ( n, nu, v0, h, x1, s, w, y, v0s, &
d580 4
a583 4
  subroutine d_Mag_O2_Abs_CS_dT ( n, nu, v0, h, x1,  s,  w,  y,  v0s, &
    &                                          dx1, ds, dw, dy, dv0s, &
    &                              sigma_p,     pi,     sigma_m,      &
    &                             dSigma_p_dT, dPi_dT, dSigma_m_dT )
d810 1
a810 1
    subroutine Absorption ( nu_offst, xi, r, dr ) ! Update r ("result"), dr
d912 1
a912 1
       "$Id: o2_abs_cs_m.f90,v 2.18 2009/06/23 18:26:11 pwagner Exp $"
d922 3
@


2.18
log
@Prevent Intel from optimizing ident string away
@
text
@d96 2
a97 2
        &   2.0_rk/(slabs%s(j)%x1 * slabs%s(j)%v0s) &
        & )
d256 1
a256 1
      wing = wing + s * cmplx ( d * (r1 - r2), d * (i1 + i2 - i3) - i4 )
d272 2
a273 1
        &                     d * (i1 * di1 + i2 * di2 - i3 * di3) - i4 * di4 )
d367 1
a367 1
      sigma_p = sigma_p + cmplx(zr, zi)
d384 1
a384 1
      sigma_m = sigma_m + cmplx(zr, zi)
d401 1
a401 1
      pi = pi + cmplx(zr, zi)
d421 1
a421 1
        pi = pi + cmplx(zr, zi)
d432 1
a432 1
        sigma_p = sigma_p + cmplx(zr, zi)
d443 1
a443 1
        sigma_m = sigma_m + cmplx(zr, zi)
d465 1
a465 1
        pi = pi + cmplx(zr, zi)
d476 1
a476 1
        sigma_p = sigma_p + cmplx(zr, zi)
d487 1
a487 1
        sigma_m = sigma_m + cmplx(zr, zi)
d505 1
a505 1
      sigma_p = sigma_p + cmplx(zr, zi)
d520 1
a520 1
      sigma_m = sigma_m + cmplx(zr, zi)
d535 1
a535 1
      pi = pi + cmplx(zr, zi)
d546 1
a546 1
      sigma_p = sigma_p + cmplx(zr, zi)
d561 1
a561 1
      pi = pi + cmplx(zr, zi)
d572 1
a572 1
      sigma_m = sigma_m + cmplx(zr, zi)
d850 2
a851 2
      r  =  r + z * cmplx( zr,  zi)
      dr = dr + z * cmplx(dZr, dZi)
d911 1
a911 1
       "$Id: read_apriori.f90 is it here $"
d921 3
@


2.17
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d907 1
d909 3
a911 5
    !---------------------------- RCS Ident Info -------------------------------
      character (len=*), parameter :: IdParm = &
        &  "$Id: o2_abs_cs_m.f90,v 2.16 2007/05/23 22:45:08 vsnyder Exp $"
      character (len=len(idParm)) :: Id = idParm
    !---------------------------------------------------------------------------
d913 1
d915 1
d920 3
@


2.16
log
@New slabs structure
@
text
@d37 1
a37 1
    use Units, only: SqrtPi
d121 1
a121 1
    use Units, only: SqrtPi
d910 1
a910 1
        &  "$Id: o2_abs_cs_m.f90,v 2.15 2005/07/06 02:13:31 vsnyder Exp $"
d919 3
@


2.15
log
@Correct a comment
@
text
@d77 2
a78 2
      call mag_o2_abs_cs ( qn(j), freq, v0, h, slabs%x1(j), slabs%slabs1(j), &
        &                  slabs%y(j), slabs%yi(j), slabs%v0s(j), &
d90 7
a96 7
      z = slabs%x1(j) * (slabs%v0s(j) + freq)
      denomm = sqrtPi * (z*z + slabs%y(j)*slabs%y(j))
      wing = wing + ( 0.5_rk * slabs%slabs1(j) * f_o_v0 ) * cmplx( &
        &  (slabs%y(j) - slabs%yi(j)*z) / denomm, & ! Real part
        & (z + slabs%y(j) * (slabs%y(j)/slabs%x1(j) -   & ! Imaginary part...
        &   freq*slabs%yi(j)) / slabs%v0s(j)) / denomm -  &
        &   2.0_rk/(slabs%x1(j) * slabs%v0s(j)) &
d172 6
a177 6
      call d_mag_o2_abs_cs_dT ( qn(j), freq, v0, h,             &
        &  slabs%x1(j),     slabs%slabs1(j),     slabs%y(j),    &
        &  slabs%yi(j),     slabs%v0s(j),                       &
        & slabs%dx1_dT(j), slabs%dslabs1_dT(j), slabs%dy_dT(j), &
        & slabs%dyi_dT(j), slabs%dv0s_dT(j),                    &
        &  sigma_p,     pi,     sigma_m,                        &
d242 4
a245 4
      s = 0.5_rk * slabs%slabs1(j) * freq / v0
      sigma = freq + slabs%v0s(j)
      z = slabs%x1(j) * sigma
      r1 = slabs%y(j)
d247 3
a249 3
      r2 = slabs%yi(j)*z
      i1 = 1.0_rk / slabs%v0s(j)
      i4 = 2.0_rk * i1 / slabs%x1(j)
d251 2
a252 2
      i3 = freq * r1 * slabs%yi(j) * i1
      dv0 = slabs%dv0s_dT(j) * i1 ! 1/v0s dv0s/dT
d258 3
a260 3
      dz = slabs%dx1_dT(j) + slabs%dv0s_dT(j) / sigma
      dD = (2.0_rk * sqrtPi) * ( z**2 * dz + y2 * slabs%dy_dT(j) ) * d
      s1 = slabs%dslabs1_dT(j) - dD ! 1/S dS/dT - 1/D dD/dT
d262 2
a263 2
      dr1 = s1 + slabs%dy_dT(j)
      dr2 = s1 + slabs%dyi_dT(j) + dz
d266 3
a268 3
      di2 = s1 - dv0 + 2.0_rk * slabs%dy_dT(j) - slabs%dx1_dT(j)
      di3 = s1 - dv0 + slabs%dy_dT(j) + slabs%dyi_dT(j)
      di4 = slabs%dslabs1_dT(j) - slabs%dx1_dT(j) - dv0
d841 1
a841 1
      call d_simple_voigt ( nu_offst, ww, dNu_offst, wdw, u, v, du, dv )
d910 1
a910 1
        &  "$Id: o2_abs_cs_m.f90,v 2.14 2005/06/09 02:34:16 vsnyder Exp $"
d919 3
@


2.14
log
@Move stuff from l2pc_pfa_structures to slabs_sw_m
@
text
@d610 1
a610 1
    real(r8), intent(in) :: dv0s ! dv0s/dT, not 1/dv0s dv0s/dT
d910 1
a910 1
        &  "$Id: o2_abs_cs_m.f90,v 2.13 2005/01/20 02:51:28 vsnyder Exp $"
d919 3
@


2.13
log
@Delete unused stuff
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a20 3
  character (len=*), parameter :: IdParm = &
    &  "$Id: o2_abs_cs_m.f90,v 2.12 2004/04/24 02:26:54 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
a33 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d36 1
a117 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d119 1
d908 5
d919 3
@


2.12
log
@Move Voigt stuff to its own module
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.11 2004/04/17 00:37:00 vsnyder Exp $"
a52 1
    real(rk) :: Slabs_nonres                  ! Nonresonant absorption
a53 1
    real(rk) :: Y_nonres                      ! Nonresonant ratio
a58 2
    slabs_nonres = slabs%catalog%continuum(1)
    y_nonres = slabs%catalog%continuum(3)
a139 1
    real(rk) :: Slabs_nonres                  ! Nonresonant absorption
a140 1
    real(rk) :: Y_nonres                      ! Nonresonant ratio
a149 2
    slabs_nonres = slabs%catalog%continuum(1)
    y_nonres = slabs%catalog%continuum(3)
d909 3
@


2.11
log
@Analytic temperature derivatives
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.10 2004/04/02 01:00:20 vsnyder Exp $"
d305 1
a305 1
    use SLabs_SW_M, only: Simple_Voigt
d595 1
a595 1
    use SLabs_SW_M, only: D_Simple_Voigt
d917 3
@


2.10
log
@Inching toward analytic temperature derivatives
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.9 2003/08/15 00:17:45 michael Exp $"
d84 1
a84 1
!       i \left(\frac{z + y \left( \frac{y}{x_1} - \nu y_i \right)}{D \nu_{0_s}} -
d148 1
a148 1
    real(rk) ::  D,  I1,  I2,  I3,  I4,  R1,  R2,  S, S1,  Z
d151 1
d163 4
d187 1
a187 1
!       i \left(\frac{z + y \left( \frac{y}{x_1} - \nu y_i \right)}{D \nu_{0_s}} -
d189 2
a190 1
!  $z = x_1 ( \nu + \nu_{0_s} )$ and $D = \sqrt{\pi} ( z^2 + y^2 )$.
d195 1
a195 1
!        $I_1 = \frac12 S \frac{\nu}{\nu_0} \frac{z}{D \nu_{0_s}}$,
d207 1
a207 1
!      - \frac1D \frac{\partial D}{\partial T} - \frac1{\nu_{0_s}} \frac{\partial \nu_{0_s}}{\partial T}$,
d227 1
a227 1
!    + \frac1{\nu+\nu_{0_s}} \frac{\partial \nu_{0_s}}{\partial T}$.
d246 2
a247 1
      z = slabs%x1(j) * (freq + slabs%v0s(j))
d249 1
d253 1
a253 1
      i2 = r2 * 0.5_rk * i4
d256 2
a257 2
      i1 = z * i1
      d = 1.0_rk / (sqrtPi * (z*z + r1**2))
d261 3
a263 3
      dz = slabs%dx1_dT(j) + slabs%dv0s_dT(j) / ( freq + slabs%v0s(j) )
      dd = z**2 * dz + r1**2 * slabs%dy_dT(j)
      s1 = slabs%dslabs1_dT(j) - dd ! 1/S dS/dT - 1/D dD/dT
d268 1
a268 1
      di1 = s1 - dv0 + dz
d330 2
a331 1
    real(rk) :: U, V, Z, Zr, Zi
d342 3
a344 1
    kappaH = kappa * h
d361 1
a361 1
      call simple_voigt ( nu_offst, w, u, v )
d368 1
a368 1
      zi = z * (v + u * (w/(x1*nu) + y))
d378 1
a378 1
      call simple_voigt ( nu_offst, w, u, v )
d385 1
a385 1
      zi = z * (v + u * (w/(x1*nu) + y))
d395 1
a395 1
      call simple_voigt ( nu_offst, w, u, v )
d402 1
a402 1
      zi = z * (v + u * (w/(x1*nu) + y))
d417 1
a417 1
        call simple_voigt ( nu_offst, w, u, v )
d428 1
a428 1
        call simple_voigt ( nu_offst, w, u, v )
d439 1
a439 1
        call simple_voigt ( nu_offst, w, u, v )
d444 1
a444 1
        zi = z * (v + u  * (w/(x1*nu) + y))
d461 1
a461 1
        call simple_voigt ( nu_offst, w, u, v )
d466 1
a466 1
        zi = z * (v + u  * (w/(x1*nu) + y))
d472 1
a472 1
        call simple_voigt ( nu_offst, w, u, v )
d477 1
a477 1
        zi = z * (v + u  * (w/(x1*nu) + y))
d483 1
a483 1
        call simple_voigt ( nu_offst, w, u, v )
d488 1
a488 1
        zi = z * (v + u  * (w/(x1*nu) + y))
d501 1
a501 1
      call simple_voigt ( nu_offst, w, u, v )
d506 1
a506 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d516 1
a516 1
      call simple_voigt ( nu_offst, w, u, v )
d521 1
a521 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d531 1
a531 1
      call simple_voigt ( nu_offst, w, u, v )
d536 1
a536 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d542 1
a542 1
      call simple_voigt ( nu_offst, w, u, v )
d547 1
a547 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d557 1
a557 1
      call simple_voigt ( nu_offst, w, u, v )
d562 1
a562 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d568 1
a568 1
      call simple_voigt ( nu_offst, w, u, v )
d573 1
a573 1
      zi = z * (v + u  * (w/(x1*nu) + y))
d597 17
a613 13
    integer, intent(in) :: N    ! rotational quantum number, sign indicates delta J
    real(r8), intent(in) :: Nu  ! transmission frequency in MHz
    real(r8), intent(in) :: V0  ! zero magnetic field line position
    real(rk), intent(in) :: H   ! magnetic field in Gauss
    real(r8), intent(in) :: X1  ! Doppler width factor sqrt(ln 2) / D_width
    real(r8), intent(in) :: S   ! strength factor slabs1 from slabs routine
    real(r8), intent(in) :: W   ! collision to doppler width ratio in the
                                ! document corrected for temperature and pressure
    real(r8), intent(in) :: Y   ! interference coefficient in the document
                                ! corrected for pressure and temperature
    real(r8), intent(in) :: V0S ! Pressure-shifted zero magnetic field line position

    real(r8), intent(in) :: dx1, ds, dw, dy, dv0s
d616 1
a616 1
                                ! ratio for Delta M = +1
d618 1
a618 1
                                ! ratio for Delta M = 0
d620 1
a620 1
                                ! ratio for Delta M = -1
d629 1
a629 1
    real(rk) :: Del_nu, Denom1, Denom2, F_o_v0, KappaH, Nu_offst
d631 1
d642 4
d818 27
a844 5
      real(rk) :: U, dU, v, dV, X, dX, Z, dZ, Zr, dZr, Zi, dZi
      ! S, dS, w, dW, X1, dX1, Y, dY by host association
      call d_simple_voigt ( nu_offst, w, dNu_offst, dw, u, v, du, dv )
      z  = s * xi
      dz = ds * xi
d846 4
a849 10
      dZr = dz * zr + z * ( du - y*dv - y*dy*v )
      zr = z * zr
      x = w/(x1*nu)
      dx = x * ( dw - dx1 )
      zi = v + u * ( x + y )
      dZi = dz * zi + z * ( dv + du * x + u * ( dx + y * dy ) )
      zi = z * zi

      r  =  r + cmplx( zr,  zi)
      dr = dr + cmplx(dZr, dZi)
d851 3
d917 3
@


2.9
log
@Removed extra f_o_v0 terms from mag_o2_abs_cs.  Now zero-field polarized and scalar are consistent.
@
text
@d8 1
a8 1
  public :: O2_Abs_CS, Get_QN_By_Frequency
d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.8 2003/08/14 02:15:03 vsnyder Exp $"
d24 1
a24 3
  subroutine O2_Abs_CS ( Freq, Qn, H, Slabs_0, Polarized, &
    &                    Slabs_nonres, Y_nonres, &
    &                    Sigma_p, Pi, Sigma_m )
d31 1
d37 1
a37 1
    type(slabs_struct), intent(in) :: Slabs_0 ! contains, among others:
d43 1
a43 4
    logical, intent(in) :: Polarized(:)       ! Which lines to use.  Same
                                              ! size as Slabs_0%v0s.
    real(rk), intent(in) :: Slabs_nonres      ! Nonresonant absorption
    real(rk), intent(in) :: Y_nonres          ! Nonresonant ratio
d49 2
d53 3
d59 4
a62 1
    no_lines = size(polarized)
d75 3
a77 2
      call mag_o2_abs_cs ( qn(j), freq, slabs_0%x1(j), slabs_0%slabs1(j),  &
        &                  slabs_0%y(j), slabs_0%yi(j), h, slabs_0%v0s(j), &
d80 16
a95 10
! Fill in negative frequency part of VVW lineshape for jth line

      f_o_v0 = freq / slabs_0%v0s(j)
      z = slabs_0%x1(j) * (slabs_0%v0s(j) + freq)
      denomm = sqrtPi * (z*z + slabs_0%y(j)*slabs_0%y(j))
      wing = wing + ( 0.5_rk * slabs_0%slabs1(j) * f_o_v0 ) * cmplx( &
        &  (slabs_0%y(j) - slabs_0%yi(j)*z) / denomm, & ! Real part
        & (z + slabs_0%y(j) * (slabs_0%y(j)/slabs_0%x1(j) -   & ! Imaginary part...
        &   freq*slabs_0%yi(j)) / slabs_0%v0s(j)) / denomm -  &
        &   2.0_rk/(slabs_0%x1(j) * slabs_0%v0s(j)) &
d110 175
d286 2
a287 1
  subroutine Mag_O2_Abs_CS ( n, nu, x1, s, w, y, h, v0, sigma_p, pi, sigma_m )
d296 1
d301 5
a305 3
    real(rk), intent(in) :: X1  ! Doppler width factor sqrt(ln 2) / D_width
    real(rk), intent(in) :: S   ! strength factor slabs1 from slabs routine
    real(rk), intent(in) :: W   ! collision to doppler width ratio in the
d307 1
a307 1
    real(rk), intent(in) :: Y   ! interference coefficient in the document
d309 1
a309 2
    real(rk), intent(in) :: H   ! magnetic field in Gauss
    real(rk), intent(in) :: V0  ! zero magnetic field line position
d319 7
a325 1
    real(rk) :: Nu_offst, Del_nu, Xi, Denom1, Denom2, Z, F_o_v0, U, V, Zr, Zi
d332 2
a333 1
    del_nu = v0 - nu
d348 2
a349 2
!     nu_offst = x1*(del_nu + 2.803_rk*((m+1)*(2-n)-1)*h / denom1)
      nu_offst = x1 * ( del_nu - (0.5_rk*2.803_rk) * h )
d365 2
a366 2
!     nu_offst = x1*(del_nu + 2.803_rk*((m-1)*(2-n)+1)*h / denom1)
      nu_offst = x1 * (del_nu + (0.5_rk*2.803_rk) * h )
d381 2
a382 2
! m == n + 1 == 0 => 2.803_rk*m*(2-n)*h == 0
!     nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
d405 1
a405 1
        nu_offst = x1*(del_nu + 2.803_rk*m*(1-n)*h / denom1)
d407 4
a410 3
        xi = 3.0_rk * ((n + 1) * (n + 1) - m * m) / denom2
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z  * (u - y * v)
d416 1
a416 1
        nu_offst = x1*(del_nu + 2.803_rk*(m*(1-n)-n)*h / denom1)
d418 3
a420 2
        xi = 3.0_rk * (n + m + 1) * (n + m + 2) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
d427 1
a427 1
        nu_offst = x1*(del_nu + 2.803_rk*(m*(1-n)+n)*h / denom1)
d429 4
a432 3
        xi = 3.0_rk * (n - m + 1) * (n - m + 2) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z  * (u - y * v)
d449 1
a449 1
        nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
d451 4
a454 3
        xi = 3.0_rk * (n * n - m * m) / denom2
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z  * (u - y * v)
d460 1
a460 1
        nu_offst = x1*(del_nu + 2.803_rk*((m+1)*(2-n)-1)*h / denom1)
d462 4
a465 3
        xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z  * (u - y*v)
d471 1
a471 1
        nu_offst = x1*(del_nu + 2.803_rk*((m-1)*(2-n)+1)*h / denom1)
d473 4
a476 3
        xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z  * (u - y * v)
d489 1
a489 1
      nu_offst = x1*(del_nu + 2.803_rk*((m+1)*(2-n)-1)*h / denom1)
d491 4
a494 3
      xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      z  = 0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d504 1
a504 1
      nu_offst = x1*(del_nu + 2.803_rk*((m-1)*(2-n)+1)*h / denom1)
d506 4
a509 3
      xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      z  =  0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d519 1
a519 1
      nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
d521 4
a524 3
      xi = 3.0_rk * (n * n - m * m) / denom2
      z  = 0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d530 1
a530 1
      nu_offst = x1*(del_nu + 2.803_rk*((m+1)*(2-n)-1)*h / denom1)
d532 4
a535 3
      xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
      z  = 0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d545 1
a545 1
      nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
d547 4
a550 3
      xi = 3.0_rk * (n * n - m * m) / denom2
      z  = 0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d556 1
a556 1
      nu_offst = x1*(del_nu + 2.803_rk*((m-1)*(2-n)+1)*h / denom1)
d558 4
a561 3
      xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
      z  = 0.5_rk * s * xi * f_o_v0
      zr = z  * (u - y*v)
d569 250
d878 3
@


2.8
log
@Optimize n=-1 special case
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.7 2003/06/03 23:58:38 vsnyder Exp $"
d81 1
a81 1
        & f_o_v0 * (slabs_0%y(j) - slabs_0%yi(j)*z) / denomm, & ! Real part
d160 2
a161 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d177 2
a178 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d194 2
a195 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d213 2
a214 2
        zr = z * f_o_v0 * (u - y * v)
        zi = z * (v + u * f_o_v0 * (w / (x1*nu) + y))
d223 2
a224 2
        zr = z * f_o_v0 * (u - y * v)
        zi = z * (v + u * f_o_v0 * (w/(x1 * nu) + y))
d233 2
a234 2
        zr = z * f_o_v0 * (u - y * v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d254 2
a255 2
        zr = z * f_o_v0 * (u - y * v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d264 2
a265 2
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d274 2
a275 2
        zr = z * f_o_v0 * (u - y * v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d291 2
a292 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d305 2
a306 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d319 2
a320 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d329 2
a330 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d343 2
a344 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d353 2
a354 2
      zr = z * f_o_v0 * (u - y*v)
      zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
d420 3
@


2.7
log
@Cosmetic changes
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.6 2003/05/19 19:58:07 vsnyder Exp $"
d139 60
a198 1
    if ( n > 0 ) then
d239 1
a239 1
    else
a308 2
      if ( n /= -1 ) then

d311 1
a311 1
        m = n + 1
d315 7
a321 7
        nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
        call simple_voigt ( nu_offst, w, u, v )
        xi = 3.0_rk * (n * n - m * m) / denom2
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
        pi = pi + cmplx(zr, zi)
d325 7
a331 7
        nu_offst = x1*(del_nu + 2.803_rk*((m+1)*(2-n)-1)*h / denom1)
        call simple_voigt ( nu_offst, w, u, v )
        xi = 3.0_rk * (n + m) * (n + m + 1) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
        sigma_p = sigma_p + cmplx(zr, zi)
d335 1
a335 1
        m = -(n + 1)
d339 7
a345 7
        nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
        call simple_voigt ( nu_offst, w, u, v )
        xi = 3.0_rk * (n * n - m * m) / denom2
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
        pi = pi + cmplx(zr, zi)
d349 7
a355 23
        nu_offst = x1*(del_nu + 2.803_rk*((m-1)*(2-n)+1)*h / denom1)
        call simple_voigt ( nu_offst, w, u, v )
        xi = 3.0_rk * (m - n) * (m - n - 1) / (4.0_rk * denom2)
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
        sigma_m = sigma_m + cmplx(zr, zi)

      else

        m = n + 1

! pi transition

        nu_offst = x1*(del_nu + 2.803_rk*m*(2-n)*h / denom1)
        call simple_voigt ( nu_offst, w, u, v )
        xi = 3.0_rk * (n * n - m * m) / denom2
        z  = 0.5_rk * s * xi * f_o_v0
        zr = z * f_o_v0 * (u - y*v)
        zi = z * (v + u * f_o_v0 * (w/(x1*nu) + y))
        pi = pi + cmplx(zr, zi)

      end if
d420 3
@


2.6
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.5 2003/05/17 00:30:39 pwagner Exp $"
d154 1
a154 1
        zr = z * f_o_v0 * (u - y*v)
d195 1
a195 1
        zr = z * f_o_v0 * (u - y*v)
d215 1
a215 1
        zr = z * f_o_v0 * (u - y*v)
d379 3
@


2.5
log
@Ousted last bogus ref to sp_o2
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.4 2003/05/16 23:52:53 livesey Exp $"
d54 1
a54 1
    real(rk) :: F_o_v0, X, Z, U, V, Denomm
d379 3
@


2.4
log
@Now uses molecule indices rather than spectags
@
text
@d14 1
a14 1
    &  "$Id$"
d17 1
a17 1
    &  "$RCSfile$"
d324 1
a324 1
    use Molecules, only: l_o2, sp_o2
d378 4
a381 1
! $Log$
@


2.3
log
@Removed USE's for unreferenced symbols
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.2 2003/05/05 23:00:26 livesey Exp $"
d17 1
a17 1
    &  "$RCSfile: o2_abs_cs_m.f90,v $"
d324 1
a324 1
    use Molecules, only: SP_O2
d328 1
a328 1
      if ( catalog(o2_in_catalog)%spec_tag == sp_o2 ) return
d378 4
a381 1
! $Log: o2_abs_cs_m.f90,v $
@


2.2
log
@Merged in feb03 newfwm branch
@
text
@d14 1
a14 1
    &  "$Id$"
d17 1
a17 1
    &  "$RCSfile$"
a32 1
    use SLabs_SW_M, only: Simple_Voigt
d378 4
a381 1
! $Log$
@


2.1
log
@Initial commit
@
text
@d8 1
a8 1
  public :: O2_Abs_CS, Get_QN, Get_QN_By_Frequency
d14 1
a14 1
    &  "$Id: freq_avg_m.f90,v 2.5 2002/10/08 17:08:03 pwagner Exp $"
d17 1
a17 1
    &  "$RCSfile: freq_avg_m.f90,v $"
d24 3
a26 2
  subroutine O2_Abs_CS ( freq, qn, h, slabs_0, slabs_nonres, y_nonres, &
    &                    sigma_p, pi, sigma_m )
d37 1
a37 1
    integer(ip), intent(in) :: qn(:)          ! Quantum numbers
d39 1
a39 1
    type(slabs_struct), intent(in) :: slabs_0 ! contains, among others:
d45 24
a68 26
    real(rk), intent(in) :: slabs_nonres      ! Nonresonant absorption
    real(rk), intent(in) :: y_nonres          ! Nonresonant ratio
    complex(rk), intent(out) :: sigma_p       ! Output Beta values
    complex(rk), intent(out) :: pi
    complex(rk), intent(out) :: sigma_m

    integer(ip) :: i, j, no_lines

    real(rk) :: f_o_v0, x, z, u, v, denomm

    complex(rk) :: wing

    no_lines = size(slabs_0%v0s)

! Find index of nearest line that line will be treated as if it were
! magnetically split regardless of field and pressure

    j = 1
    x = abs(slabs_0%v0s(1) - freq)
    do i = 2 , no_lines
      z = abs(slabs_0%v0s(i) - freq)
      if ( z < x ) then
        x = z
        j = i
      end if
    end do
d70 1
a70 7
! Do magnetic calculation even if h = 0
! The nearest line has been found so continue with cross section
! calculation

    call mag_o2_abs_cs ( qn(j), freq, slabs_0%x1(j), slabs_0%slabs1(j),  &
      &                  slabs_0%y(j), slabs_0%yi(j), h, slabs_0%v0s(j), &
      &                  sigma_p, pi, sigma_m )
d72 3
a74 2
! Add contribution from nearby lines excluding the already computed
! magnetic line
d78 8
a85 24
    f_o_v0 = freq / slabs_0%v0s(j)
    z = slabs_0%x1(j) * (slabs_0%v0s(j) + freq)
    denomm = sqrtPi * (z*z + slabs_0%y(j)*slabs_0%y(j))
    wing = ( 0.5_rk * slabs_0%slabs1(j) * f_o_v0 ) * cmplx( &
      & f_o_v0 * (slabs_0%y(j) - slabs_0%yi(j)*z) / denomm, & ! Real part
      & (z + slabs_0%y(j) * (slabs_0%y(j)/slabs_0%x1(j) - &  ! Imaginary part...
      &   freq*slabs_0%yi(j)) / slabs_0%v0s(j)) / denomm - &
      &   2.0_rk/(slabs_0%x1(j) * slabs_0%v0s(j)) &
      & )

! Now for the other lines (do the same thing on both sides of j).

    do i = 1 , j - 1
      f_o_v0 = freq / slabs_0%v0s(i)
      x = slabs_0%x1(i) * (slabs_0%v0s(i) - freq)
      call simple_voigt ( x, slabs_0%y(i), u, v )
      z = slabs_0%x1(i) * (slabs_0%v0s(i) + freq)
      denomm = sqrtPi * (z*z + slabs_0%y(i)*slabs_0%y(i))
      wing = wing + ( 0.5_rk * slabs_0%slabs1(i) * f_o_v0 ) * cmplx( &
        & f_o_v0 * (u - slabs_0%yi(i)*v + (slabs_0%y(i) - slabs_0%yi(i)*z) / denomm), & ! Real
        & u * (slabs_0%y(i)/slabs_0%x1(i) + freq*slabs_0%yi(i)) / slabs_0%v0s(i) + v + & ! Imag...
        &  (z + slabs_0%y(i) * (slabs_0%y(i) / slabs_0%x1(i) - freq*slabs_0%yi(i)) / &
        &   slabs_0%v0s(i)) / denomm -                                               &
        &   2.0_rk / (slabs_0%x1(i) * slabs_0%v0s(i))                                &
a86 1
    end do
a87 13
    do i = j + 1 , no_lines
      f_o_v0 = freq / slabs_0%v0s(i)
      x = slabs_0%x1(i) * (slabs_0%v0s(i) - freq)
      call simple_voigt ( x, slabs_0%y(i), u, v )
      z = slabs_0%x1(i) * (slabs_0%v0s(i) + freq)
      denomm = sqrtPi * (z*z + slabs_0%y(i)*slabs_0%y(i))
      wing = wing + ( 0.5_rk * slabs_0%slabs1(i) * f_o_v0 ) * cmplx( &
        & f_o_v0 * (u - slabs_0%yi(i)*v + (slabs_0%y(i) - slabs_0%yi(i)*z) / denomm), & ! Real
        & u * (slabs_0%y(i)/slabs_0%x1(i) + freq*slabs_0%yi(i)) / slabs_0%v0s(i) + v + & ! Imag...
        &  (z + slabs_0%y(i) * (slabs_0%y(i) / slabs_0%x1(i) - freq*slabs_0%yi(i)) / &
        &   slabs_0%v0s(i)) / denomm -                                               &
        &   2.0_rk / (slabs_0%x1(i) * slabs_0%v0s(i))                                &
        & )
d90 3
a92 1
! Now add non resonant contribution:
d94 1
a94 4
    u = freq * freq
    v = y_nonres * y_nonres
    wing = cmplx( real(wing) + 0.5_rk * slabs_nonres * u * y_nonres / (u + v), &
      &          aimag(wing) )
d96 1
a96 3
    pi = pi + wing
    sigma_p = sigma_p + 0.5_rk * wing
    sigma_m = sigma_m + 0.5_rk * wing
d123 1
a123 1
    complex(rk), intent(out) :: Sigma_P ! absorption coefficient at unity mixing
d125 1
a125 1
    complex(rk), intent(out) :: Pi ! absorption coefficient at unity mixing
d127 1
a127 1
    complex(rk), intent(out) :: Sigma_M ! absorption coefficient at unity mixing
d129 1
a129 1
    integer(ip) :: m
d131 1
a131 1
    real(rk) :: nu_offst, del_nu, xi, denom1, denom2, z, f_o_v0, u, v, zr, zi
a134 4
    pi      = 0.0
    sigma_p = 0.0
    sigma_m = 0.0

a334 26
! -------------------------------------------------------  Get_QN  -----
  subroutine Get_QN ( V0, N )

    use MLSCommon, only: IP, R8, Rk => RP
    use O2_DBase, only: O2_Freq, O2_Data

    real(r8), intent(in) :: V0
    integer(ip), intent(out) :: N

    integer(ip) :: I, J
    real(rk) :: Q, R

    j = 1
    r = abs(v0-o2_freq(i))
    do i = 2, size(o2_freq)
      q = abs(v0-o2_freq(i))
      if ( q < r ) then
        r = q
        j = i
      end if
    end do

    n = nint(o2_data(1,j))           ! Quantum number

  end subroutine Get_QN

d379 19
a397 1
! $Log: $
@


2.1.2.1
log
@Process all Zeeman-split lines, and no others
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.1 2003/02/03 22:55:26 vsnyder Exp $"
d17 1
a17 1
    &  "$RCSfile: o2_abs_cs_m.f90,v $"
d24 2
a25 3
  subroutine O2_Abs_CS ( Freq, Qn, H, Slabs_0, Polarized, &
    &                    Slabs_nonres, Y_nonres, &
    &                    Sigma_p, Pi, Sigma_m )
d36 1
a36 1
    integer(ip), intent(in) :: Qn(:)          ! Quantum numbers
d38 1
a38 1
    type(slabs_struct), intent(in) :: Slabs_0 ! contains, among others:
d44 5
a48 7
    logical, intent(in) :: Polarized(:)       ! Which lines to use.  Same
                                              ! size as Slabs_0%v0s.
    real(rk), intent(in) :: Slabs_nonres      ! Nonresonant absorption
    real(rk), intent(in) :: Y_nonres          ! Nonresonant ratio
    complex(rk), intent(out) :: Sigma_p       ! Output Beta values
    complex(rk), intent(out) :: Pi
    complex(rk), intent(out) :: Sigma_m
d50 1
a50 1
    integer(ip) :: J, No_lines
d52 1
a52 1
    real(rk) :: F_o_v0, X, Z, U, V, Denomm
d54 1
a54 1
    complex(rk) :: Wing
d58 2
a59 4
    sigma_p = 0.0_rk
    pi = 0.0_rk
    sigma_m = 0.0_rk
    wing = 0.0_rk
d61 9
a69 3
! Do magnetic calculation even if h = 0 for all of the Zeeman-split lines

    do j = 1, no_lines
d71 7
a77 1
      if ( .not. polarized(j) ) cycle
d79 2
a80 3
      call mag_o2_abs_cs ( qn(j), freq, slabs_0%x1(j), slabs_0%slabs1(j),  &
        &                  slabs_0%y(j), slabs_0%yi(j), h, slabs_0%v0s(j), &
        &                  sigma_p, pi, sigma_m )
d84 24
a107 8
      f_o_v0 = freq / slabs_0%v0s(j)
      z = slabs_0%x1(j) * (slabs_0%v0s(j) + freq)
      denomm = sqrtPi * (z*z + slabs_0%y(j)*slabs_0%y(j))
      wing = wing + ( 0.5_rk * slabs_0%slabs1(j) * f_o_v0 ) * cmplx( &
        & f_o_v0 * (slabs_0%y(j) - slabs_0%yi(j)*z) / denomm, & ! Real part
        & (z + slabs_0%y(j) * (slabs_0%y(j)/slabs_0%x1(j) -   & ! Imaginary part...
        &   freq*slabs_0%yi(j)) / slabs_0%v0s(j)) / denomm -  &
        &   2.0_rk/(slabs_0%x1(j) * slabs_0%v0s(j)) &
d109 1
d111 13
a125 2
! Contribution from non-Zeeman-split lines is done in get_beta_path.

d162 1
a162 1
    complex(rk), intent(inout) :: Sigma_P ! absorption coefficient at unity mixing
d164 1
a164 1
    complex(rk), intent(inout) :: Pi ! absorption coefficient at unity mixing
d166 1
a166 1
    complex(rk), intent(inout) :: Sigma_M ! absorption coefficient at unity mixing
d168 1
a168 1
    integer(ip) :: M
d170 1
a170 1
    real(rk) :: Nu_offst, Del_nu, Xi, Denom1, Denom2, Z, F_o_v0, U, V, Zr, Zi
d174 4
d448 1
a448 4
! $Log: o2_abs_cs_m.f90,v $
! Revision 2.1  2003/02/03 22:55:26  vsnyder
! Initial commit
!
@


2.1.2.2
log
@Use 'polarized' array for size, delete nonresonant computation
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.1.2.1 2003/02/27 23:35:24 vsnyder Exp $"
d59 1
a59 1
    no_lines = size(polarized)
d90 1
a90 1
! Contribution from non-Zeeman-split lines is done in get_beta_path_scalar.
d92 10
a101 1
! Non resonant contribution is done in get_beta_path_scalar too.
a410 3
! Revision 2.1.2.1  2003/02/27 23:35:24  vsnyder
! Process all Zeeman-split lines, and no others
!
@


2.1.2.3
log
@Delete unused procedure Get_QN so we won't need o2_DBase
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.1.2.2 2003/03/01 03:11:02 vsnyder Exp $"
d331 26
a401 3
! Revision 2.1.2.2  2003/03/01 03:11:02  vsnyder
! Use 'polarized' array for size, delete nonresonant computation
!
@


2.1.2.4
log
@Finish deleting Get_QN -- form the PUBLIC statement
@
text
@d8 1
a8 1
  public :: O2_Abs_CS, Get_QN_By_Frequency
d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.1.2.3 2003/03/01 03:13:47 vsnyder Exp $"
a375 3
! Revision 2.1.2.3  2003/03/01 03:13:47  vsnyder
! Delete unused procedure Get_QN so we won't need o2_DBase
!
@


2.1.2.5
log
@Add in the wing calculation
@
text
@d14 1
a14 1
    &  "$Id: o2_abs_cs_m.f90,v 2.1.2.4 2003/03/01 03:15:19 vsnyder Exp $"
a89 4
    sigma_p = sigma_p + 0.5_rk * wing
    pi = pi + wing
    sigma_m = sigma_m + 0.5_rk * wing

a375 3
! Revision 2.1.2.4  2003/03/01 03:15:19  vsnyder
! Finish deleting Get_QN -- form the PUBLIC statement
!
@


