head	2.40;
access;
symbols
	v5-02-NRT-19:2.40
	v6-00:2.40
	v5-02-NRT-18:2.40
	v5-02:2.40
	v5-01-NRT-17:2.40
	v5-01-NRT-16:2.40
	v5-01-NRT-15:2.40
	v5-01-NRT-14:2.40
	neuralnetworks-1-0:2.40.0.6
	cfm-single-freq-0-1:2.40.0.4
	v5-01:2.40
	v5-00:2.40
	v4-23-TA133:2.40.0.2
	mus-emls-1-70:2.37.0.2
	rel-1-0-englocks-work:2.35.0.2
	VUMLS1-00:2.32
	VPL1-00:2.32
	V4-22-NRT-08:2.32
	VAM1-00:2.32
	V4-21:2.32.0.2
	V4-13:2.32
	V4-12:2.31
	V4-11:2.31
	V4-10:2.31
	V3-43:2.6
	M4-00:2.29
	V3-41:2.6
	V3-40-PlusGM57:2.6.0.2
	V2-24-NRT-04:2.3
	V3-33:2.19
	V2-24:2.3
	V3-31:2.19
	V3-30-NRT-05:2.14
	cfm-01-00:2.11
	V3-30:2.6
	V3-20:2.6
	V3-10:2.5
	V2-23-NRT-02:2.3
	V2-23:2.3
	V2-22-NRT-01:2.3
	V2-22:2.3;
locks; strict;
comment	@# @;


2.40
date	2018.11.19.21.55.37;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2018.09.12.22.50.44;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2018.09.12.22.03.38;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2018.05.24.03.24.36;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2018.05.14.23.40.58;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2017.08.09.20.47.34;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2017.03.31.00.46.30;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2017.03.17.20.19.23;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2014.09.05.21.26.38;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2013.07.13.00.03.21;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2013.05.18.00.34.44;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2011.11.09.00.17.44;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2011.08.20.00.44.02;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2011.07.29.01.59.24;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2011.07.08.21.25.58;	author yanovsky;	state Exp;
branches;
next	2.25;

2.25
date	2011.06.02.22.43.12;	author yanovsky;	state Exp;
branches;
next	2.24;

2.24
date	2011.03.25.20.46.59;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2011.03.24.00.17.34;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2011.03.23.23.45.32;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2011.03.11.03.09.08;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2011.03.04.03.41.25;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2011.02.12.03.57.40;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2011.02.05.01.18.06;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2011.01.28.19.17.11;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2010.12.07.01.20.57;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2010.11.05.20.28.13;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2010.08.27.23.17.11;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2010.08.27.05.51.03;	author yanovsky;	state Exp;
branches;
next	2.12;

2.12
date	2010.08.19.02.04.03;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2010.06.12.01.27.59;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2010.06.11.02.20.46;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2010.06.09.23.13.01;	author yanovsky;	state Exp;
branches;
next	2.8;

2.8
date	2010.06.09.22.04.14;	author yanovsky;	state Exp;
branches;
next	2.7;

2.7
date	2010.05.14.02.41.08;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2010.01.23.01.21.24;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2009.06.16.17.37.09;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2009.06.13.01.11.55;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2007.07.11.22.26.45;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2007.06.26.00.40.01;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2007.06.08.22.05.13;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.40
log
@Make Get_d_Delta_df private
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Rad_Tran_m

  implicit NONE
  private
  public :: Rad_Tran, Rad_Tran_Pol
  public :: dRad_Tran_dF, dRad_Tran_dT, dRad_Tran_dX
  public :: Get_Do_Calc

  public :: Get_Do_Calc_Indexed, Get_Inds ! Used only by Hessians_m

  private :: Get_d_Delta_df, Get_d_Delta_df_f, Get_d_Delta_df_linlog
  private :: Get_d_Delta_df_linlog_f
  private :: N_Eta_Rows

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: rad_tran_m.F90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------

!------------------------------------------------------  Rad_Tran  -----
! This is the radiative transfer model, radiances only !

  subroutine Rad_Tran ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
                      & alpha_path, ref_cor, incoptdepth, ds_dz_gw,    &
                      & t_script, tau, inc_rad_path, rad, i_stop )

    use GL_Update_Incoptdepth_m
    use MLSKinds, only: RP
    use SCRT_dN_m, ONLY: SCRT

  ! Inputs

    integer, intent(in) :: Tan_pt            ! Tangent point index in Del_Zeta
    integer, intent(in) :: gl_inds(:)        ! Gauss-Legendre grid indices
    integer, intent(in) :: more_inds(:)      ! Places in the coarse path
                                             ! where GL is needed
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just the part up
                                             ! to the black-out
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
                                             ! length ratios.
    real(rp), intent(inout) :: incoptdepth(:) ! incremental path opacities
                                             ! from one-sided layer calculation
                                             ! on output. it is the full
                                             ! integrated layer opacity.
    real(rp), intent(in), target :: alpha_path(:) ! absorption coefficient on
                                             ! coarse & fine grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
    real(rp), intent(in) :: t_script(:)      ! differential temperatures (K)
                                             ! on coarse grid.

  ! Outputs

    real(rp), intent(out) :: tau(:)          ! transmission function.
    real(rp), intent(out) :: inc_rad_path(:) ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(out) :: rad             ! radiance (K)
    integer, intent(out) :: i_stop           ! path stop index

  ! Begin code

  ! See if anything needs to be gl-d

    call GL_update_incoptdepth ( gl_inds, more_inds, 1, del_zeta, alpha_path, &
                               & ds_dz_gw, ref_cor, incoptdepth )

    call scrt ( tan_pt, t_script, e_rflty, incoptdepth, tau, rad, inc_rad_path, &
      &         i_stop )

  end subroutine Rad_Tran

!--------------------------------------------------  Rad_Tran_Pol  -----

  subroutine Rad_Tran_Pol ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta,    &
                          & alpha_path, ref_cor, incoptdepth_pol, deltau_pol, &
                          & ds_dz_gw, ct, stcp, stsp, t_script, do_dumps,     &
                          & prod_pol, tau_pol, rad_pol, p_stop )

    ! Polarized radiative transfer.  Radiances only, no derivatives.

    use CS_Expmat_m, only: CS_Expmat
    use Dump_0, only: Dump, Dump_2x2xN
    use GLNP, ONLY: NG, NGP1
    use MCRT_M, ONLY: MCRT
    use MLSKinds, only: RP
    use Opacity_m, only: Opacity

  ! Inputs

    integer, intent(in) :: Tan_pt            ! Tangent point index in Del_Zeta
    integer, intent(in) :: Gl_inds(:)        ! Gauss-Legendre grid indices
    integer, intent(in) :: More_inds(:)      ! Places in the coarse path
                                             ! where GL is needed
    real(rp), intent(in) :: E_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: Del_zeta(:)      ! path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just part up to
                                             ! the black-out
    complex(rp), intent(in), target :: Alpha_path(-1:,:)  ! absorption
                                             ! coefficient on composite coarse &
                                             ! fine grid.
    complex(rp), intent(inout) :: Deltau_pol(:,:,:) ! 2 X 2 X path.  Incremental
                                             ! transmissivity on the coarse path.
                                             ! Called E in some notes.
    real(rp), intent(in) :: Ref_cor(:)       ! refracted to unrefracted path
                                             ! length ratios.
    complex(rp), intent(inout) :: Incoptdepth_pol(:,:,:) ! incremental path
                                             ! opacities from one-sided layer
                                             ! calculation on output. it is the
                                             ! full integrated layer opacity.
                                             ! 2x2xPath
    real(rp), intent(in) :: ds_dz_Gw(:)      ! path length wrt zeta derivative *
                                             ! gw on the entire grid.  Only the
                                             ! gl_inds part is used.
    real(rp), intent(in) :: CT(:)            ! Cos theta          for Mag field
    real(rp), intent(in) :: STCP(:)          ! Sin theta Cos Phi  for Mag field
    real(rp), intent(in) :: STSP(:)          ! Sin theta Sin Phi  for Mag field
    real(rp), intent(in) :: T_script(:)      ! differential temperatures (K)
                                             ! on coarse path.
    integer, intent(in) :: Do_Dumps          ! Dump intermediate results if > 0

  ! Outputs

    complex(rp), intent(out) :: Prod_pol(:,:,:) ! product of E matrices. 2x2xPath
    complex(rp), intent(out) :: Tau_pol(:,:,:)  ! transmission function. 2x2xPath
    complex(rp), intent(out) :: Rad_pol(:,:)    ! radiance (K). 2x2.
    integer, intent(out) :: P_Stop           ! path stop index if >= 0, else
                                             ! -index in incoptdepth_pol where
                                             ! cs_expmat failed.

  ! Internals

    integer :: A, AA
    complex(rp), pointer :: Alpha_Path_c(:,:)
    real(rp), save :: E_Stop  = 1.0_rp ! X for which Exp(X) is too small to worry
    complex(rp) :: gl_Delta_Polarized(-1:1,size(gl_inds)/ng)
    complex(rp) :: Incoptdepth_Pol_gl(2,2,size(gl_inds)/ng)
    integer :: I, J
    integer :: N_Path
    integer :: Status ! from cs_expmat

  ! Begin code

    n_path = size(del_zeta)
    alpha_path_c(-1:,1:) => alpha_path ( -1:1, 1::ngp1 )

    if ( e_stop > 0.0_rp ) e_stop = log(epsilon(0.0_rp)) ! only once

  ! See if anything needs to be gl-d

    if ( size(gl_inds) > 0 ) then

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt More\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  We don't use it here.
      !  In the second integral, $G(\zeta)$ is {\tt funct} -- which has
      !  already been evaluated at the appropriate abscissae -- and
      !  $G(\zeta_i)$ is {\tt singularity}.  The weights are {\tt gw}.

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        do j = -1, 1
          gl_delta_polarized(j,i) = del_zeta(more_inds(i)) *                             &
                 &  sum( ( alpha_path(j,aa:aa+ng-1) - &
                 &         alpha_path_c(j,more_inds(i))) * &
                 &       ds_dz_gw(aa:aa+ng-1) )
        end do 
        a = a + ng
      end do

      ! Turn sigma-, pi, sigma+ GL corrections into 2X2 matrix of
      ! GL corrections to incoptdepth_pol
      call opacity ( ct(more_inds), stcp(more_inds), stsp(more_inds), &
        & gl_delta_polarized, incoptdepth_pol_gl )

      ! add GL corrections to incoptdepth_pol
      incoptdepth_pol(:,:,more_inds) = incoptdepth_pol(:,:,more_inds) - &
        & incoptdepth_pol_gl

      if ( do_dumps > 1 ) then
        call dump ( more_inds, name='More_Inds' )
        call dump ( gl_inds, name='GL_Inds' )
        call dump ( gl_delta_polarized, name='GL_Delta_Polarized', width=3, &
          & options='p' ) ! transpose=.TRUE.
        call Dump_2x2xN ( incoptdepth_pol_gl, name='IncoptDepth_Pol_GL' )
        call Dump_2x2xN ( incoptdepth_pol, name='Incoptdepth_Pol' )
        call dump ( ref_cor, name='Ref_Cor' )
        if ( do_dumps > 2 ) stop
      end if
    end if

    ! At this point, incoptdepth_pol(:,:,1:tan_pt_c) should be nearly
    ! identical to incoptdepth_pol(:,:,1:tan_pt_c+1) (tan_pt_c is the
    ! zero-thickness tangent layer).

    do p_stop = 0, n_path-1
      incoptdepth_pol(:,:,p_stop+1) = incoptdepth_pol(:,:,p_stop+1) * &
        &                             ref_cor(p_stop+1)
      ! exp(A) = exp(s) * ((sinh d)/d (A - s I) + cosh d I) where
      ! s is the sum of A's eigenvalues and d is their difference.
      ! (sinh d)/d and cosh d can be large and positive even when
      ! s is large and negative, so we can't stop just because s
      ! is large and negative.  Well, we could if we knew d was small,
      ! but once we have both eigenvalues we've almost finished the
      ! exponential anyway.
      call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), &
        &              deltau_pol(:,:,p_stop+1), status )  
      if ( status /= 0 ) go to 99 ! because we can't change p_stop in the loop
    end do

    call mcrt ( t_script, sqrt(e_rflty), deltau_pol, &
      & tan_pt, p_stop, prod_pol, tau_pol, rad_pol )

    return

  ! Error exit if cs_expmat detected an overflow
 99 if ( do_dumps > 0 ) then
      call dump ( more_inds, name='More_Inds' )
      call dump ( gl_inds, name='GL_Inds' )
      call dump ( gl_delta_polarized, name='GL_Delta_Polarized', width=3 )
      call Dump_2x2xN ( incoptdepth_pol_gl, name='IncoptDepth_Pol_GL' )
      call Dump_2x2xN ( incoptdepth_pol(:,:,:p_stop), name='Incoptdepth_Pol' )
      call dump ( ref_cor, name='Ref_Cor' )
      if ( do_dumps > 2 ) stop
    end if
    p_stop = - p_stop - 1

  end subroutine Rad_Tran_Pol

!--------------------------------------------------  DRad_Tran_df  -----
! This is the radiative transfer derivative wrt mixing ratio model

  subroutine DRad_Tran_df ( gl_inds, del_zeta, Grids_f, Eta_FZP, do_gl,    &
                          & del_s, ref_cor, ds_dz_gw, inc_rad_path,        &
                          & dAlpha_df, i_start, tan_pt, i_stop, drad_df,   &
                          & dB_df,                                         &
                          ! Optional for polarized
                          & Sparse_d_delta_df,                             &
                          ! Optionals for TScat
                          & Tau, alpha_path_c, Beta_c_e, dBeta_c_a_dIWC,   &
                          & dBeta_c_s_dIWC, dTScat_df, W0 )

    use d_T_Script_dTnp_m, only: dT_Script
    use GLNP, only: NGP1
    use Load_SPS_Data_m, ONLY: Grids_t
    use MLSKinds, only: RP
    use SCRT_dN_m, ONLY: dSCRT_dT, dSCRT_dX
    use Sparse_m, only: Sparse_t
    use TScat_Support_m, only: Get_dB_df

! Inputs

    integer, intent(in) :: GL_Inds(:)        ! Gauss-Legendre grid indices
    real(rp), intent(in) :: Del_Zeta(:)      ! path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just the part up
                                             ! to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    class(sparse_t), intent(in) :: Eta_FZP(:) ! Interpolating coefficients
                                             ! from state vector to combined
                                             ! coarse & fine path for each sps
    logical, intent(in) :: Do_GL(:)          ! A logical indicating where to
                                             ! do gl integrations
    real(rp), intent(in) :: Ref_Cor(:)       ! refracted to unrefracted path
                                             ! length ratios.
    real(rp), intent(in) :: Del_s(:)         ! unrefracted coarse path panel
                                             ! length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
                                             ! gw on the entire grid.  Only the
                                             ! gl_inds part is used.
    real(rp), intent(in) :: Inc_Rad_Path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(in) :: dAlpha_df(:,:) ! On the
                                             ! composite coarse & GL path
    integer, intent(in) :: I_start           ! path_start_index + 1 in coarse path
    integer, intent(in) :: Tan_Pt            ! Tangent point index in Del_Zeta
    integer, intent(in) :: I_stop            ! path stop index in coarse path

    ! Optional for polarized
    class(sparse_t), intent(inout), optional :: Sparse_d_delta_df(:)

    ! Optionals for TScat
    real(rp), intent(inout) :: dB_df(:) ! scratch, on the path, size=0 for no TScat
    real(rp), intent(in), optional :: Tau(:)
    real(rp), intent(in), optional :: Alpha_path_c(:)
    real(rp), intent(in), optional :: Beta_c_e(:)
    real(rp), intent(in), optional :: dBeta_c_a_dIWC(:)  ! on the path, w.r.t. IWC on the path
    real(rp), intent(in), optional :: dBeta_c_s_dIWC(:)  ! on the path, w.r.t. IWC on the path
    real(rp), intent(in), optional :: dTScat_df(:,:) ! Path X SV.  On the path, w.r.t.
                                                 ! f == Molecules on the grid
    real(rp), intent(in), optional :: W0(:)

! Outputs

    real(rp), intent(out) :: drad_df(:)         ! derivative of radiances wrt
                                                ! mixing ratio state vector
                                                ! element. (K)

! Internals

    integer, pointer :: All_inds(:)   ! all_inds => part of all_inds_B;
                                      ! Indices on GL grid for stuff
                                      ! used to make GL corrections
    integer, target :: All_inds_B(1:size(del_s))
    real(rp) :: d_Delta_B_df(size(dB_df))
    real(rp) :: d_Delta_df(1:size(del_s)) ! 1:max_c
    logical :: Do_Calc(1:size(del_s)) ! Flags on coarse path where do_calc_fzp
                                      ! for the coarse path or (do_gl and any
                                      ! corresponding do_calc_fzp on the fine
                                      ! path).
    logical :: Do_Calc_FZP(n_eta_rows(eta_fzp,.true.))
    logical :: Do_TScat                   ! Include dependence upon dB_df
    real(rp) :: Eta_FZP_Col(n_eta_rows(eta_fzp,.true.))
    integer, pointer :: Inds(:)       ! inds => part_of_nz_d_delta_df;
                                      ! Indices on coarse path where do_calc.
    integer :: I, I_Begin, SPS_i, SV_i
    ! NZ_ZXP and NNZ are used to project dB_df from the path to the grid
    integer, target :: More_inds_B(1:size(del_s))
    integer, pointer :: More_inds(:)  ! more_inds => part of more_inds_B;
                                      ! Indices on the coarse path where GL
                                      ! corrections get applied.
    integer :: NNZ_d_Delta_df
    integer :: NNZ_ZXP ! number of elements used in NZ_ZPX
    integer :: No_To_GL
    integer, target :: NZ_d_Delta_df(1:size(d_Delta_df))
    integer :: NZ_ZXP(n_eta_rows(eta_fzp,.true.))
    logical :: Save_Sparse            ! Save d_delta_df in sparse_d_delta_df
    real(rp) :: Singularity(1:size(del_s)) ! integrand on left edge of coarse
                                      ! grid panel -- singular at tangent pt.
    integer :: Sparse_Col             ! Column index in Eta_FZP(sps_i)

! Begin code

    save_sparse = present(sparse_d_delta_df)
    if ( save_sparse ) save_sparse = size(sparse_d_delta_df) > 0

    ! Get pointer to coarse grid subset of dAlpha_df

    d_delta_df = 0
    do_calc_fzp = .false.
    do_TScat = size(dB_df) > 0
    eta_fzp_col = 0
    nnz_d_delta_df = 0
    nz_d_delta_df = 0

    do sps_i = 1, ubound(Grids_f%l_z,1)
      sparse_col = 0
      if ( save_sparse ) call sparse_d_delta_df(sps_i)%empty

      if ( Do_TScat ) then

        !{ $\frac{\partial I}{\partial f^\text{iwc}_{lm}} =
        !   \sum_{i=1}^{N_p}
        !   \frac{\partial \overline{\Delta B_i}}{\partial f^\text{iwc}_{lm}}
        !   \mathcal{T}_i + \overline{\Delta B_i}
        !   \frac{\partial \mathcal{T}_i}{\partial f^\text{iwc}_{lm}}$
        !   where $\overline{\Delta B} = \Delta B^g + \Delta B^s$,
        !   $\Delta B^g = \Delta \left[ ( 1-\omega_0 ) B \right]$,
        !   $\Delta B^s = \Delta \left[ \omega_0 T_\text{scat} \right]$
        ! and
        !   $\frac{\partial \mathcal{T}_i}{\partial f^k_{lm}} =
        !    -\mathcal{T}_i \int_{s_0}^{s_m}
        !      \frac{\partial \alpha(\sigma)}{\partial f^k_{lm}}
        !       \, \text{d} \sigma \approx
        !    -\mathcal{T}_i \sum_{j=i}^{N_p}
        !      \frac{\partial \delta^k_j}{\partial f^k_{lm}}
        !   = -\mathcal{T}_i \sum_{j=i}^{N_p} \beta^k_j
        !       \eta^k_{lm}(s_i) \Delta s_j$.
        !
        !   {\tt dB_df(i)} =
        !   $\frac{\partial \overline{\Delta B_i}}{\partial f^k_{lm}}
        !    \text{ where } \frac{\partial \overline{B_i}}
        !                        {\partial f^k_{lm}(\zeta_i)} =
        !    \frac{\partial \omega_{0_i}}{\partial f^k_{lm}(\zeta_i)}
        !     \left( T_{\text{scat}_i} - B_i \right) +
        !    \omega_{0_i} \frac{\partial T_{\text{scat}_i}}
        !                      {\partial f^k_{lm}(\zeta_i)}
        !   = \left(\frac{\partial \omega_{0_i}}{\partial f^k}
        !     \left( T_{\text{scat}_i} - B_i \right) +
        !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
        !     \right)
        !     \frac{\partial f^k}{\partial f^k_{lm}(\zeta_i)}
        !   = \left( \frac{\partial \omega_{0_i}}{\partial f^k}
        !      \left( T_{\text{scat}_i} - B_i \right) +
        !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
        !      \right) \eta^k_{lm}(\zeta_i)$ (see wvs-095 and {\tt Get_dB_df}.
        !
        ! {\tt inc_rad_path(i)} = $\mathcal{T}_i \overline{\Delta B}_i$

        call get_dB_df ( alpha_path_c, beta_c_e, dBeta_c_a_dIWC,       &
                       & dBeta_c_s_dIWC, dAlpha_df(1::ngp1,sps_i), w0, &
                       & grids_f%mol(sps_i), dB_df )

      end if

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
        sparse_col = sparse_col + 1

        ! We keep track of where we create nonzeros in d_delta_df, and replace
        ! them by zeros on the next iteration.  This is done because the vast
        ! majority of d_delta_df elements are zero, and setting all of
        ! d_Delta_df was found to be a significant expense.

        ! Everything in d_delta_df not indexed by nz_d_delta_df is already zero

        d_delta_df(nz_d_delta_df(:nnz_d_delta_df)) = 0
        nnz_d_delta_df = 0

        ! Skip the masked derivatives, according to the l2cf inputs

        drad_df(sv_i) = 0.0
        if ( .not. Grids_f%deriv_flags(sv_i) ) cycle

        ! Get the interpolating coefficients along the path
        call eta_fzp(sps_i)%get_flags ( sparse_col, do_calc_fzp )
        call get_do_calc_indexed ( size(do_gl), tan_pt, do_calc_fzp, gl_inds, &
          & do_gl, do_calc, nnz_d_delta_df, nz_d_delta_df )
        call eta_fzp(sps_i)%clear_flags ( sparse_col, do_calc_fzp )
        if ( nnz_d_delta_df == 0 ) cycle

        inds => nz_d_delta_df(1:nnz_d_delta_df)

        if ( save_sparse ) then
          do i = 1, nnz_d_delta_df
            call sparse_d_delta_df(sps_i)%add_element ( d_delta_df(inds(i)), &
              & inds(i), sparse_col )
          end do
        end if

        no_to_gl = count(do_gl(inds))

        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)

        ! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

        !{ Get d_Delta_df for one state-vector element.  This is
        !  $\frac{\partial \delta_i}{\partial f^k_{lm}}$ where $i$ is the
        !  index of a path point, $k$ is the species index, and $lm$ are indices
        !  for $(\phi_l,\zeta_m)$.  {\tt sv_i} flattens $(k,l,m)$ to one index.
        if ( eta_fzp(sps_i)%cols(sparse_col) /= 0 ) then ! process only non-empty columns
          call eta_fzp(sps_i)%get_col ( sparse_col, eta_fzp_col )
          call get_d_delta_df ( inds, gl_inds, all_inds, more_inds,     &
            & eta_fzp_col, dAlpha_df(:,sps_i), del_s, del_zeta, ds_dz_gw,        &
            & singularity, d_delta_df, ref_cor, grids_f%lin_log(sps_i), grids_f%values(sv_i) )
          call eta_fzp(sps_i)%clear_col ( sparse_col, eta_fzp_col )
        end if

        i_begin = max(i_start,min(nz_d_delta_df(1),i_stop))

        !{ $I(s_m) = \mathcal{T}(s_0,s_m) \left( I(s_0)-B(s_0) \right) +
        !  B(s_m) - \int_{B(s_0)}^{B(s_m)} \mathcal{T}(s,s_m)
        !            \frac{\partial B(s)}{\partial s} \,\text{d} s$ with
        !  $\mathcal{T}(s,s_m) =
        !    \exp\left( -\int_s^{s_m} \alpha(\sigma) \,\text{d} \sigma \right)$,
        !  $s_0$ is the end of the path away from the instrument,
        !  $s_m$ is the location of the instrument, $\beta^k(\sigma)$ is the
        !  absorption coefficient for the $k^\text{th}$ species, and
        !  $\eta^k_{lm}(\sigma)$ is an interpolation coefficient from
        !  $(\phi^k_l,\zeta^k_m)$ to $\sigma$. $(\phi^k_l,\zeta^k_m)$ is
        !  specified by {\tt sv_i}.
        !  
        !  The integral is approximated by
        !  $\sum_{i=1}^{N_p} \mathcal{T}_i \Delta B_i$ where $\Delta B_i =
        !  \frac12 \left( B_{i+1} - B_{i-1} \right)$.  The end-point terms
        !  are incorporated into special values of $\Delta B_0$ and $\Delta B_{s_m}$.
        !
        !  {\tt inc_rad_path(i)} = $\mathcal{T}_i \Delta B_i$.
        !  $\frac{\partial \mathcal{T}}{\partial f^k_{lm}} =
        !  -\mathcal{T} \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}.$
        !  {\tt d_delta_df} =
        !  $ \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}
        !   \,\text{d} s$

        if ( Do_TScat ) then

          !{ We got $\frac{\partial \omega_{0_i}}{\partial f^k_i}
          !     \left( T_{\text{scat}_i} - B_i \right)$ from {\tt Get_dB_df}.
          !  Now to finish we need to multiply by
          !  $\frac{\partial f^k_i}{\partial f^k_{lm}} = \eta^k_{lm}(\zeta_i)$
          !  and add $\omega_{0_i}
          !  \frac{\partial T_{\text{scat}_i}}{\partial f^k_{lm}}$ to finish
          !  computing $\frac{\partial \overline{B}_i}{\partial f^k_{lm}}$, and
          !  then compute $\Delta \frac{\partial \overline{B}_i}{\partial f^k_{lm}}$
          !  from that.

          nnz_zxp = 0
          if ( eta_fzp(sps_i)%cols(sparse_col) /= 0 ) then ! process only non-empty columns
            ! Copy nonzero elements from Eta_FZP to Eta_FZP_Col, and fill
            ! the sparsity indicators NZ_ZXP and NNZ_ZXP.  We need to
            ! do this because dT_Script doesn't understand Sparse_t.
            call eta_fzp(sps_i)%get_col ( sparse_col, eta_fzp_col, nnz_zxp, nz_zxp )
          end if
          call dt_script ( dB_df, eta_fzp_col, nz_zxp, nnz_zxp, d_delta_B_df, &
            & w0, dTScat_df(:,sv_i) )
          ! Now put zeroes into Eta_FZP_Col were there were nonzeros
          eta_fzp_col(nz_zxp(:nnz_zxp)) = 0

          !{ Now do the path integration
          !  $\sum \frac{\partial}{\partial f^k_{lm}}
          !     \mathcal{T}_i \overline{\Delta B_i}$

          call dscrt_dt ( tan_pt, d_delta_df, tau, inc_rad_path,&
                        & d_delta_B_df, i_begin, i_stop, drad_df(sv_i) )
        else
          call dscrt_dx ( tan_pt, d_delta_df, inc_rad_path, &
                       &  i_begin, i_stop, drad_df(sv_i))
        end if

      end do ! sv_i

    end do ! sps_i

  end subroutine DRad_Tran_df

!--------------------------------------------------  DRad_Tran_dT  -----
! This is the radiative transfer derivative wrt temperature model

  subroutine DRad_Tran_dT ( gl_inds, del_zeta, h_path_c, dh_dt_path,          &
                         &  alpha_path, dAlpha_dT_path, eta_zxp, del_s,       &
                         &  ref_cor, h_tan, tan_pt_f, do_gl, h_path, t_path,  &
                         &  ds_dh, dh_dz_gw, ds_dz_gw, dt_scr_dt, tau,        &
                         &  inc_rad_path, i_start, tan_pt, i_stop,            &
                         &  deriv_flags, pfa_update, drad_dt )

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP
    use SCRT_dN_m, only: dSCRT_dT, dSCRT_dX
    use Sparse_m, only: Sparse_t

! Inputs

    integer, intent(in) :: gl_inds(:)       ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: h_path_c(:)     ! path heights + req on main grid km.
    type(sparse_t), intent(in) :: dh_dt_path ! derivative of path height wrt
                                            ! temperature(km/K) on composite
                                            ! coarse & fine path.
    real(rp), intent(in), target :: alpha_path(:) ! path absorption(km^-1)
                                            ! on composite coarse & fine path
    real(rp), intent(in) :: dAlpha_dT_path(:) ! path dAlpha/dT on composite
                                            ! coarse & fine grid
    class(sparse_t), intent(in) :: Eta_ZxP  ! Interpolating coefficients from
                                            ! state vector to combined coarse &
                                            ! fine path for temperature only
    real(rp), intent(in) :: del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
                                            ! length ratios.
    real(rp), intent(in) :: h_tan           ! tangent height + req (km).
    integer, intent(in) :: tan_pt_f         ! Tangent point in the composite path
    logical, intent(in) :: do_gl(:)         ! Indicates where on the coarse path
                                            ! to do gl integrations.
    real(rp), intent(in) :: h_path(:)       ! path heights + req (km) on
                                            ! composite coarse & fine path.
    real(rp), intent(in) :: t_path(:)       ! path temperature(K) on 
                                            ! composite coarse & fine path.
    real(rp), intent(in) :: ds_dh(:)        ! path length wrt height derivative
                                            ! on complete grid.  Only the
                                            ! gl_inds part is used.
    real(rp), intent(in) :: dh_dz_gw(:)     ! path height wrt zeta derivative * gw
                                            ! on complete grid.  Only the
                                            ! gl_inds part is used.
    real(rp), intent(in) :: ds_dz_gw(:)     ! path length wrt zeta derivative * gw
                                            ! on complete grid.  Only the
                                            ! gl_inds part is used.
    real(rp), intent(in) :: dt_scr_dt(:,:)  ! d t_script / d T * d T / d eta.
    real(rp), intent(in) :: tau(:)          ! transmission function.
    real(rp), intent(in) :: inc_rad_path(:) ! incremental radiance along the
                                            ! path.  t_script * tau.
    integer, intent(in) :: i_start          ! path start index + 1
    integer, intent(in) :: Tan_pt           ! Tangent point index in Del_Zeta
    integer, intent(in) :: i_stop           ! path stop index
    logical, intent(in) :: deriv_flags(:)   ! Indicates which temperature
                                            ! derivatives to do
    logical, intent(in) :: PFA_Update       ! Use DSCRT_DX instead of DSCRT_DT.

! Output
    real(rp), intent(out) :: drad_dt(:)     ! derivative of radiances wrt
                                            ! temperature state vector
                                            ! element. (K)

! Internals

    integer :: A, B, GA
    real(rp), target :: dh_dt_path_col(dh_dt_path%nRows)
    real(rp), pointer :: Alpha_Path_c(:), dh_dt_path_c(:)
    real(rp) :: dh_dt_tan
    integer :: i, i_begin, n_inds, n_path, no_to_gl, p_i, sv_i
    integer, target, dimension(1:size(inc_rad_path)) :: All_inds_B
    integer, target, dimension(1:size(inc_rad_path)) :: Inds_B, more_inds_B
    integer, pointer :: All_inds(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
    integer, pointer :: Inds(:)      ! inds => part_of_inds_B;  Indices
                                     ! on coarse path where do_calc.
    integer, pointer :: More_inds(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.
    integer :: NPF                   ! Number of points in fine path

    real(rp) :: d_Delta_dt(size(del_s,1)) ! path x sve.
      ! derivative of delta (incremental opacity) wrt temperature. (K)
    real(rp) :: Eta_ZxP_col(eta_zxp%nRows)
    real(rp) :: fa, fb
    real(rp) :: S_DEl_S                  ! Running sum of Del_S
    real(rp) :: Singularity(1:size(del_zeta)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

    logical, pointer :: Do_Calc_c(:)
    logical, target :: Do_Calc_f(eta_zxp%nRows)
    logical, target :: Do_Calc_Hyd(dh_dt_path%nRows) ! On the whole path
    logical, pointer :: Do_Calc_Hyd_c(:)             ! On the coarse path
    logical :: Do_Calc_t(size(GL_Inds))
    logical :: Do_calc(1:size(del_zeta)) ! do_calc_c .or. ( do_gl .and. any
                                         ! of the corresponding do_calc_f ).
    logical :: NeedFA                    ! Need F(A) for hydrostatic

! Begin code

    n_path = size(del_zeta)

    alpha_path_c => alpha_path ( 1 :: ngp1 )
    dh_dt_path_col = 0
    dh_dt_path_c => dh_dt_path_col ( 1 :: ngp1 )
    do_calc_c => do_calc_f ( 1 :: ngp1 )
    do_calc_f = .false.
    do_calc_hyd_c => do_calc_hyd ( 1 :: ngp1 )
    do_calc_hyd_c = .false.
    eta_zxp_col = 0
    npf = size(alpha_path)

! Compute the opacity derivative singularity value

    do sv_i = 1, size(eta_zxp%cols)
      d_delta_dt = 0.0_rp
      drad_dt(sv_i) = 0.0
      if ( .not. deriv_flags(sv_i)) cycle  ! No derivatives for this column
      i_begin = i_start
      call dh_dt_path%get_col ( sv_i, dh_dt_path_col, do_calc_hyd )
      dh_dt_tan = dh_dt_path_col(tan_pt_f)
      if ( eta_zxp%cols(sv_i) /= 0 ) then  ! Column isn't empty
        call eta_zxp%get_col_vec_and_flags ( sv_i, eta_zxp_col, do_calc_f, &
                                           & last=npf )
        do_calc_t = do_calc_f(gl_inds)

! Do the absorption part
! Combine non zeros flags for both the main and gl parts

        call get_do_calc ( do_calc_c, do_calc_t, do_gl, do_calc, n_inds, inds_B )
        if ( n_inds > 0 ) then ! Column isn't empty up to NPF

          inds => inds_B(1:n_inds)

          no_to_gl = count(do_gl(inds))

          all_inds => all_inds_B(1:no_to_gl)
          more_inds => more_inds_B(1:no_to_gl)

          ! see if anything needs to be gl-d
          if ( no_to_gl > 0 ) &
            & call get_inds ( do_gl, do_calc, more_inds, all_inds )

          ! No ref_cor yet, no Lin_Log for temperature
          call get_d_delta_df ( inds, gl_inds, all_inds, more_inds,   &
            & eta_zxp_col, dAlpha_dT_path, del_s, del_zeta, ds_dz_gw, &
            & singularity, d_delta_dt )

          i_begin = max(inds(1)-1, i_start)

        end if ! n_inds > 0

      end if ! eta_zxp%cols(sv_i) /= 0

! Now do the hydrostatic part
! Combine boundaries flags

!????? Can the parts of the path to be calculated, and the Do_Calc flags,
!????? be handled as in Get_D_Deltau_Pol_dT?

      do_calc = do_calc_hyd_c
      do_calc(2:tan_pt) =          do_calc(tan_pt)   .or. do_calc(2:tan_pt)          .or. do_calc(1:tan_pt-1)
      do_calc(tan_pt+1:n_path-1) = do_calc(tan_pt+1) .or. do_calc(tan_pt+1:n_path-1) .or. do_calc(tan_pt+2:n_path)

! This is a layer calculation.  Before the tangent point, boundary J refers
! to the layer from J-1 to J.  After the tangent point, boundary J refers
! to the layer from J to J+1.  Therefore, we must require:

      do_calc((/1,n_path/)) = .false.

! Find where the non zeros are along the path

      n_inds = count(do_calc)
      needFA = .true.
      fa = 0.0_rp ! in case n_path <= 4
      if ( n_inds > 0 ) then
        inds => inds_B(1:n_inds)
        i = 1
        inds = 0
        s_del_s = sum(del_s(2:tan_pt))
        do p_i = 2 , tan_pt - 1
          if ( do_calc(p_i) ) then
            if ( needFA ) then ! only once in this loop
              fa = (h_path_c(p_i-1) * dh_dt_path_c(p_i-1) - &
                 &  h_tan * dh_dt_tan) / s_del_s
              needFA = .false.
            end if
            s_del_s = s_del_s - del_s(p_i)
            fb = (h_path_c(p_i) * dh_dt_path_c(p_i) - &
                & h_tan * dh_dt_tan) / s_del_s
            inds(i) = p_i
            d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i) * (fa - fb)
            fa = fb
            i = i + 1
          else
            s_del_s = s_del_s - del_s(p_i)
          end if
        end do ! p_i

! Special processing at tangent.  fb is zero

        if ( do_calc(tan_pt) ) then
          d_delta_dt(tan_pt) = d_delta_dt(tan_pt) + alpha_path_c(tan_pt) * fa
          inds(i) = tan_pt
          i = i + 1
        end if

        needFA = .not. do_calc(tan_pt+1)
        s_del_s = del_s(tan_pt+1)
        if ( do_calc(tan_pt+1) ) then
          fa = (h_path_c(tan_pt+2) * dh_dt_path_c(tan_pt+2) - &
              & h_tan * dh_dt_tan) / s_del_s
          d_delta_dt(tan_pt+1) = d_delta_dt(tan_pt+1) + &
              &                  alpha_path_c(tan_pt+1) * fa
          inds(i) = tan_pt + 1
          i = i + 1
        end if

        ! Several subscripts in this loop are offset by 1 from the nearly-
        ! identical loop above, and we use (fb-fa) here instead of (fa-fb).
        do p_i = tan_pt + 2, n_path - 1
          if ( do_calc(p_i) ) then
            if ( needFA ) then ! only once in this loop
              fa = (h_path_c(p_i) * dh_dt_path_c(p_i) - &
                 &  h_tan * dh_dt_tan) / s_del_s
              needFA = .false.
            end if
            s_del_s = s_del_s + del_s(p_i)
            fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1) - &
               &  h_tan * dh_dt_tan) / s_del_s
            inds(i) = p_i
            d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i) * (fb - fa)
            fa = fb
            i = i + 1
          else
            s_del_s = s_del_s + del_s(p_i)
          end if
        end do ! p_i

        ! Do GL for hydrostatic for any panels that need it; the singularity
        ! correction is alpha_path_c.
        a = 1
        do p_i = 2, n_path-1           ! along the path
          if ( do_gl(p_i) ) then
            b = a + ng
            ga = gl_inds(a)
            ! Don't test do_calc: There may be GL corrections even if
            ! dh_dt_path_c (from whence came do_calc) is zero.
            d_delta_dt(p_i) = d_delta_dt(p_i) +                              &  
              & del_zeta(p_i) *                                              &  
              &  sum( ( alpha_path(ga:ga+ng-1) - alpha_path_c(p_i) ) *       &  
              &  (((2.0_rp*h_path(ga:ga+ng-1)**2 - 3.0_rp*h_tan**2) *        &  
              &    dh_dt_path_col(ga:ga+ng-1) +                              &  
              &    h_path(ga:ga+ng-1) * h_tan * dh_dt_tan) /                 &     
              &   (sqrt(h_path(ga:ga+ng-1)**2 - h_tan**2))**3                &
              &   + eta_zxp_col(ga:ga+ng-1) * ds_dh(ga:ga+ng-1) /            &
              &   t_path(ga:ga+ng-1)) * dh_dz_gw(ga:ga+ng-1) )
            a = b
          end if
        end do ! p_i

        i_begin = min(i_begin,inds(1))

      end if ! n_inds for hydrostatic > 0

! Correct for path length refraction

      d_delta_dt = ref_cor * d_delta_dt

! Accumulate the incremental opacity derivatives to get drad_dt

      if ( PFA_update ) then
        ! If we're doing a PFA update, we do not want to include
        ! dt_scr_dt again.

        call dscrt_dx ( tan_pt, d_delta_dt, inc_rad_path, i_begin, i_stop, &
                     &  drad_dt(sv_i) )

      else

        call dscrt_dt ( tan_pt, d_delta_dt, tau, inc_rad_path,&
                      & dt_scr_dt(:,sv_i),  i_begin, i_stop, drad_dt(sv_i) )

      end if

      call dh_dt_path%clear_col ( sv_i, dh_dt_path_col, do_calc_hyd )
      call eta_zxp%clear_col ( sv_i, eta_zxp_col, do_calc_f )

    end do ! sv_i

  end subroutine DRad_Tran_dT

!-----------------------------------------_______--  dRad_Tran_dX  -----
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )

  subroutine dRad_Tran_dX ( GL_Inds, Del_Zeta, Grids_f, Eta_fzp, Sps_Path,     &
                          & Sps_Map, dBeta_Path_c, dBeta_Path_f, Do_GL, Del_S, &
                          & Ref_Cor, ds_dz_gw, Inc_Rad_Path, Tan_Pt, I_Stop,   &
                          & dRad_dx )

    use Load_SPS_Data_m, ONLY: Grids_t
    use MLSKinds, only: RP
    use SCRT_dN_m, ONLY: dSCRT_dx
    use Sparse_m, only: Sparse_t

! Inputs

    integer, intent(in) :: GL_Inds(:)        ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: Del_Zeta(:)      ! path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just the part up
                                             ! to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    class(sparse_t), intent(in) :: Eta_FZP(:) ! Interpolating coefficients
                                             ! from state vector to combined
                                             ! coarse & fine path for each sps
    real(rp), intent(in) :: Sps_Path(:,:)    ! Path species function, path X species.
    integer, intent(in) :: Sps_Map(:)        ! second-dimension subscripts for sps_path.
    real(rp), intent(in) :: dBeta_Path_c(:,:) ! derivative of beta wrt dx
                                             ! on main grid.
    real(rp), intent(in) :: dBeta_Path_f(:,:) ! derivative of beta wrt dx
    logical, intent(in) :: Do_GL(:)          ! A logical indicating where to
                                             ! do gl integrations
    real(rp), intent(in) :: Del_S(:)         ! unrefracted path length.
    real(rp), intent(in) :: Ref_Cor(:)       ! refracted to unrefracted path
                                             ! length ratios.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
                                             ! gw on the entire grid.  Only the
                                             ! gl_inds part is used.
    real(rp), intent(in) :: Inc_Rad_Path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    integer, intent(in) :: Tan_pt            ! Tangent point index in inc_rad_path
    integer, intent(in) :: I_Stop            ! path stop index

! Outputs

    real(rp), intent(out) :: dRad_dx(:)      ! derivative of radiances wrt x
!                                              state vector element. (K)
! Internals

    integer :: n_inds, no_to_gl, sps_i, sps_m, sps_n, sv_i
    integer, target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer, target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer, pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
    real(rp) :: d_delta_dx(1:size(inc_rad_path))  ! derivative of delta
      !              wrt spectroscopy parameter. (K)
    logical :: do_calc(1:size(inc_rad_path)) ! Flags on coarse path where
                                     ! do_calc_fzp on the coarse path or (do_gl
                                     ! and any corresponding do_calc_fzp on the
                                     ! fine path).
    logical :: Do_Calc_FZP(n_eta_rows(eta_fzp,.true.))
    real(rp) :: Eta_FZP_Col(n_eta_rows(eta_fzp,.true.))
    integer, pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                     ! on coarse path where do_calc.
    integer, pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.
    integer :: NNZ_d_Delta_dx
    integer, target :: NZ_d_Delta_dx(1:size(d_Delta_dx))
    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.
    integer :: Sparse_Col

! Begin code

    d_delta_dx = 0.0_rp
    do_calc_fzp = .false.
    eta_fzp_col = 0
    nnz_d_delta_dx = 0
    nz_d_delta_dx = 0
    sps_n = ubound(grids_f%l_z,1)

    do sps_i = 1 , sps_n
      sparse_col = 0
      sps_m = sps_map(sps_i)

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
        sparse_col = sparse_col + 1

        ! We keep track of where we create nonzeros in d_delta_dx, and replace
        ! them by zeros on the next iteration.  This is done because the vast
        ! majority of d_delta_dx elements are zero, and setting all of
        ! d_Delta_dx was found to be a significant expense.

        ! Everything in d_delta_dx not indexed by nz_d_delta_dx is already zero

        d_delta_dx(nz_d_delta_dx(:nnz_d_delta_dx)) = 0
        nnz_d_delta_dx = 0

        ! Skip the masked derivatives, according to the l2cf inputs

        drad_dx(sv_i) = 0.0

        ! Get the interpolating coefficients along the path
        call eta_fzp(sps_i)%get_flags ( sparse_col, do_calc_fzp )
        call get_do_calc_indexed ( size(do_gl), tan_pt, do_calc_fzp, gl_inds, &
          & do_gl, do_calc, nnz_d_delta_dx, nz_d_delta_dx )
        call eta_fzp(sps_i)%clear_flags ( sparse_col, do_calc_fzp )
        if ( nnz_d_delta_dx == 0 ) cycle

        inds => nz_d_delta_dx(1:nnz_d_delta_dx)
        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)

        ! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

        ! Get d_Delta_dx for one state-vector element.

        if ( eta_fzp(sps_i)%cols(sparse_col) /= 0 ) then
          ! process only non-empty columns
          call eta_fzp(sps_i)%get_col ( sparse_col, eta_fzp_col )
          ! We're not really computing d_delta_df for lin-log mixing
          ! ratio.  It turns out that get_d_delta_df_linlog does the
          ! correct computation if we substitute dbeta_path for beta_path.
          call get_d_delta_df_linlog ( inds, gl_inds, all_inds, more_inds, &
            & eta_fzp_col, sps_path(:,sps_m), dbeta_path_c(:,sps_i),   &
            & dbeta_path_f(:,sps_i), del_s, del_zeta, ds_dz_gw, ref_cor,   &
            & grids_f%values(sv_i), singularity, d_delta_dx )
          call eta_fzp(sps_i)%clear_col ( sparse_col, eta_fzp_col )
        end if

        call dscrt_dx ( tan_pt, d_delta_dx, inc_rad_path, &
                      & 1, i_stop, drad_dx(sv_i))

      end do

    end do

  end subroutine dRad_Tran_dX

  ! ------------------------------------------------  Get_Do_Calc  -----
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_fzp, Do_GL, Do_Calc, N_Inds, Inds )

  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do_Calc_fzp
  ! flags are set.

    use GLNP, ONLY: Ng

    logical, intent(in) :: Do_Calc_c(:)   ! On the coarse grid
    logical, intent(in) :: Do_Calc_fzp(:) ! On the GL grid
    logical, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.
    integer, intent(out), optional :: N_Inds  ! count(do_calc)
    integer, intent(out), optional :: Inds(:) ! Indices where do_calc is true

    integer :: I, P_I

    i = 1
    do_calc = do_calc_c
    do p_i = 1 , size(do_gl)
      if ( do_gl(p_i) ) then
        do_calc(p_i) = do_calc(p_i) .or. any(do_calc_fzp(i:i+ng-1))
        i = i + Ng
      end if
    end do

    if ( present(n_inds) ) then
      n_inds = 0
      do p_i = 1 , size(do_gl)
        if ( do_calc(p_i) ) then
          n_inds = n_inds + 1
          inds(n_inds) = p_i
        end if
      end do
    end if
  end subroutine Get_Do_Calc

  ! .............................................  Get_d_Delta_df  .....
  subroutine Get_d_Delta_df ( Inds, GL_Inds, All_inds, More_inds, eta_fzp, &
    & dAlpha_df_path, Del_s, Del_Zeta, ds_dz_gw, &
    & Singularity, d_delta_df, Ref_cor, lin_log, grids_v )

    ! Get d_delta_df or d_delta_dT.  For species for which beta does not
    ! depend upon mixing ratio this gets d_delta_df if dAlpha_df_path_* is
    ! beta_path_*.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:)       ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)    ! Indices of GL points within combined
                                         ! coarse & fine path that are GL points
                                         ! for panels needing GL -- subset of
                                         ! f_inds (q.v. in  FullForwardModel).
    integer, intent(in) :: All_inds(:)   ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer, intent(in) :: More_inds(:)  ! Indices on the coarse path where
                                         ! GL corrections get applied.
    real(rp), intent(in) :: Eta_fzp(:)   ! Interpolation coefficients from state
                                         ! vector coordinates for one species to
                                         ! points on the combined coarse & fine
                                         ! path.
    real(rp), intent(in), target :: dAlpha_df_path(:) ! dAlpha_df on GL grid within
                                         ! subset of coarse path that needs GL.
    real(rp), intent(in) :: Del_s(:)     ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)  ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:)  ! ds/dh * dh/dz * GL weights
    real(rp), intent(out) :: Singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_Delta_df(:) ! Derivative of delta.
                               ! intent(inout) so the unreferenced
                               ! elements do not become undefined.
    real(rp), intent(in), optional :: Ref_cor(:) ! refracted to unrefracted
                                         !  path length ratios.
    logical, intent(in), optional :: lin_log  ! logarithmic interpolation was used
    real(rp), intent(in), optional :: Grids_v ! Grids_f%values(sv_i)

    integer :: AA, GA, I, II
    real(rp), pointer :: dAlpha_df_path_c(:)

    ! Get a pointer to dAlpha_df on the coarse path only, to compute the
    ! initial rectangular estimate of d_delta_df
    dAlpha_df_path_c => dAlpha_df_path( 1 :: ngp1 )

    do i = 1, size(inds)
      ii = inds(i)
      singularity(ii) = dAlpha_df_path_c(ii) * eta_fzp(ii*ngp1-ng)
      d_delta_df(ii) = singularity(ii) * del_s(ii)
    end do ! i

    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d}
    !  s}{\text{d} h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the
    !  panels indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \beta^k(s) \eta^k_{lm}(s)$.  We
    !  remove the singularity introduced at the tangent point by
    !  $\frac{\text{d} s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta = G(\zeta_i)
    !  \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !  \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !  \text{d}\zeta$.  The first integral is easy -- it's just $G(\zeta_i)
    !  (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}. In the
    !  second integral, $G(\zeta)$ is {\tt dAlpha_df_path\_f * eta\_zxp\_f
    !  * sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}. The weights  are
    !  {\tt gw}.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_df(ii) = d_delta_df(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) * dAlpha_df_path(ga:ga+ng-1) - &
             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    if ( present(ref_cor) ) d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)

    if ( present(lin_log) ) then
      ! Logarithmic interpolation correction
      if ( lin_log ) d_delta_df(inds) = d_delta_df(inds) * exp(-grids_v)
    end if

  end subroutine Get_d_Delta_df

  ! .............................................  Get_d_delta_df_old  .....
  subroutine Get_d_Delta_df_old ( Inds, GL_Inds, All_inds, More_inds, eta_fzp, &
    & dAlpha_df_path_c, dAlpha_df_path_f, Del_s, Del_Zeta, ds_dz_gw, &
    & Singularity, d_delta_df, Ref_cor, lin_log, grids_v )

    ! Get d_delta_df or d_delta_dT.  For species for which beta does not
    ! depend upon mixing ratio this gets d_delta_df if dAlpha_dx_path_* is
    ! beta_path_*.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:)       ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)    ! Indices of GL points within combined
                                         ! coarse & fine path that are GL points
                                         ! for panels needing GL -- subset of
                                         ! f_inds (q.v. in  FullForwardModel).
    integer, intent(in) :: All_inds(:)   ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer, intent(in) :: More_inds(:)  ! Indices on the coarse path where
                                         ! GL corrections get applied.
    real(rp), intent(in) :: Eta_fzp(*)   ! Interpolation coefficients from state
                                         ! vector coordinates for one species to
                                         ! points on the combined coarse & fine
                                         ! path.
    real(rp), intent(in) :: dAlpha_df_path_c(*) ! dAlpha_df on coarse grid.
    real(rp), intent(in) :: dAlpha_df_path_f(*) ! dAlpha_df on GL grid within
                                         ! subset of coarse path that needs GL.
    real(rp), intent(in) :: Del_s(:)     ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)  ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:)  ! ds/dh * dh/dz * GL weights
    real(rp), intent(out) :: Singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_Delta_df(:) ! Derivative of delta.
                               ! intent(inout) so the unreferenced
                               ! elements do not become undefined.
    real(rp), intent(in), optional :: Ref_cor(:) ! refracted to unrefracted
                                         !  path length ratios.
    logical, intent(in), optional :: lin_log  ! logarithmic interpolation was used
    real(rp), intent(in), optional :: Grids_v ! Grids_f%values(sv_i)

    integer :: AA, GA, I, II

    do i = 1, size(inds)
      ii = inds(i)
      singularity(ii) = dAlpha_df_path_c(ii) * eta_fzp(ii*ngp1-ng)
      d_delta_df(ii) = singularity(ii) * del_s(ii)
    end do ! i

    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d}
    !  s}{\text{d} h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the
    !  panels indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \beta^k(s) \eta^k_{lm}(s)$.  We
    !  remove the singularity introduced at the tangent point by
    !  $\frac{\text{d} s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta = G(\zeta_i)
    !  \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !  \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !  \text{d}\zeta$.  The first integral is easy -- it's just $G(\zeta_i)
    !  (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}. In the
    !  second integral, $G(\zeta)$ is {\tt dAlpha_df_path\_f * eta\_zxp\_f
    !  * sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}. The weights  are
    !  {\tt gw}.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_df(ii) = d_delta_df(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) * dAlpha_df_path_f(aa:aa+ng-1) - &
             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    if ( present(ref_cor) ) d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)

    if ( present(lin_log) ) then
      ! Logarithmic interpolation correction
      if ( lin_log ) d_delta_df(inds) = d_delta_df(inds) * exp(-grids_v)
    end if

  end subroutine Get_d_delta_df_old

  ! ...........................................  Get_d_delta_df_f  .....
  subroutine Get_d_delta_df_f ( Inds, GL_Inds, All_inds, More_inds, eta_fzp, &
    & Sps_path, Beta_path_c, Beta_path_f, dBeta_df_c, dBeta_df_f, Del_s,     &
    & Del_Zeta, ds_dz_gw, Ref_cor, Singularity, d_delta_df )

    ! Get d_delta_df for the case of species for which beta
    ! depends upon mixing ratio.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:)      ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Indices of GL points within combined
                                        ! coarse & fine path that are GL points
                                        ! for panels needing GL -- subset of
                                        ! f_inds (q.v. in  FullForwardModel).
    integer, intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                        ! used to make GL corrections
    integer, intent(in) :: More_inds(:) ! Indices on the coarse path where
                                        ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp(*)  ! representation basis function.
    real(rp), intent(in) :: Sps_path(:) ! Path mixing ratios
    real(rp), intent(in) :: Beta_path_c(*)  ! cross section on coarse grid.
    real(rp), intent(in) :: Beta_path_f(*)  ! cross section on GL grid.
    real(rp), intent(in) :: dBeta_df_c(*)   ! beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)   ! beta depends on mixing ratio
    real(rp), intent(in) :: Del_s(:)    ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:) ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:)     ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
                                            !  length ratios.
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_delta_df(:) ! Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
                               ! elements do not become undefined.

    integer :: AA, GA, I, II, III

    do i = 1, size(inds)
      ii = inds(i)
      iii = ii*ngp1 - ng
      singularity(ii) = eta_fzp(iii) &
                & * ( beta_path_c(ii) + &
                &     sps_path(iii) * dBeta_df_c(ii) )
      d_delta_df(ii) = singularity(ii) * del_s(ii)
    end do ! i
    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d}
    !  s}{\text{d} h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the
    !  panels indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \left( \beta^k(s) + f^k(s)
    !  \frac{\partial \beta(s)}{\partial f^k(s)} \right) \eta^k_{lm}(s)$.  We
    !  remove the singularity introduced at the tangent point by
    !  $\frac{\text{d} s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta = G(\zeta_i)
    !  \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !  \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !  \text{d}\zeta$.  The first integral is easy -- it's just $G(\zeta_i)
    !  (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}. In the second
    !  integral, $G(\zeta)$ is {\tt eta\_zxp\_f * ( beta\_path\_f + sps\_path
    !  * dBeta\_df )} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights are
    !  {\tt gw}.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_df(ii) = d_delta_df(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) &
             &  * ( beta_path_f(aa:aa+ng-1) &
             &      + sps_path(aa:aa+ng-1) * dBeta_df_f(aa:aa+ng-1) ) &
             &  - singularity(ii)) &
             & * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)

  end subroutine Get_d_delta_df_f

  ! ......................................  Get_d_delta_df_linlog  .....
  subroutine Get_d_delta_df_linlog ( Inds, GL_Inds, All_inds, More_inds, &
    & eta_fzp, Sps_path, Beta_path_c, Beta_path_f, Del_s, Del_Zeta,      &
    & ds_dz_gw, Ref_cor, Grids_v, Singularity, d_delta_df )

    ! Get d_delta_df for the case of lin_log species for which beta
    ! does not depend upon mixing ratio.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer, intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                        ! used to make GL corrections
    integer, intent(in) :: More_inds(:) ! Indices on the coarse path where
                                        ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp(*)  ! representation basis function.
    real(rp), intent(in) :: Sps_path(:) ! exp(Path mixing ratios)
    real(rp), intent(in) :: Beta_path_c(*)  ! cross section on coarse grid.
    real(rp), intent(in) :: Beta_path_f(*)  ! cross section on GL grid.
    real(rp), intent(in) :: Del_s(:)    ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:) ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:) ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)  ! refracted to unrefracted path
                                        !  length ratios.
    real(rp), intent(in) :: Grids_v     ! Grids_f%values(sv_i)
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_delta_df(:) ! Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
                               ! elements do not become undefined.

    integer :: AA, GA, I, II, III

    do i = 1, size(inds)
      ii = inds(i)
      iii = ii*ngp1 - ng
      singularity(ii) = eta_fzp(iii) * sps_path(iii) * &
                & beta_path_c(ii)
      d_delta_df(ii) = singularity(ii) * del_s(ii)
    end do ! i

    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d} s}{\text{d}
    !  h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the panels
    !  indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \hat{f}^k(s) \beta^k(s)
    !  \frac{\eta^k_{lm}(s)}{f^k_{lm}}$, where $\hat{f}^k(s) = \exp\left(
    !  \sum_{lm} \eta^k_{lm}(s) \ln f^k_{lm} \right)$.  We remove the
    !  singularity introduced at the tangent point by $\frac{\text{d}
    !  s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
    !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !   \text{d}\zeta$.  The first integral is easy -- it's just
    !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
    !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
    !  sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
    !  are {\tt gw}.  {\tt sps\_path} is $\hat{f}^k(s)$, and {\tt grids_v}
    !  is $\ln f^k_{lm}$.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_df(ii) = d_delta_df(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
             &  * beta_path_f(aa:aa+ng-1) - &
             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds) * exp(-grids_v)

  end subroutine Get_d_delta_df_linlog

  ! ....................................  Get_d_delta_df_linlog_f  .....
  subroutine Get_d_delta_df_linlog_f ( Inds, GL_Inds, All_inds, More_inds, &
    & eta_fzp, Sps_path, Beta_path_c, Beta_path_f, dBeta_df_c, dBeta_df_f, &
    & Del_s, Del_Zeta, ds_dz_gw, Ref_cor, Grids_v,  Singularity, d_delta_df )

    ! Get d_delta_df for the case of lin_log species for which beta
    ! depends upon mixing ratio.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer, intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                        ! used to make GL corrections
    integer, intent(in) :: More_inds(:) ! Indices on the coarse path where
                                        ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp(*)  ! representation basis function.
    real(rp), intent(in) :: Sps_path(:) ! exp(Path mixing ratios)
    real(rp), intent(in) :: Beta_path_c(*)  ! cross section on coarse grid.
    real(rp), intent(in) :: Beta_path_f(*)  ! cross section on GL grid.
    real(rp), intent(in) :: dBeta_df_c(*)   ! beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)   ! beta depends on mixing ratio
    real(rp), intent(in) :: Del_s(:)    ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:) ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:) ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)  ! refracted to unrefracted path
                                        !  length ratios.
    real(rp), intent(in) :: Grids_v     ! Grids_f%values(sv_i)
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_delta_df(:) ! Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
                               ! elements do not become undefined.

    integer :: AA, GA, I, II, III

    do i = 1, size(inds)
      ii = inds(i)
      iii = ii*ngp1 - ng
      singularity(ii) = eta_fzp(iii) * sps_path(iii) * &
                & ( beta_path_c(ii) + sps_path(iii) * dBeta_df_c(ii) )
      d_delta_df(ii) = singularity(ii) * del_s(ii)
    end do ! i

    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d} s}{\text{d}
    !  h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the panels
    !  indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \left( \beta^k(s) + \hat{f}^k(s)
    !  \frac{\partial \beta(s)}{\partial \hat{f}^k(s)} \right) \hat{f}^k(s)
    !  \frac{\eta^k_{lm}(s)}{f^k_{lm}}$, where $\hat{f}^k(s) = \exp\left(
    !  \sum_{lm} \eta^k_{lm}(s) \ln f^k_{lm} \right)$.  We remove the
    !  singularity introduced at the tangent point by $\frac{\text{d}
    !  s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
    !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !   \text{d}\zeta$.  The first integral is easy -- it's just
    !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
    !  In the second integral, $G(\zeta)$ is {\tt eta\_zxp\_f * sps\_path
    !  ( beta\_path\_f + dBeta_df )} -- which have already been evaluated at
    !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt singularity}. 
    !  The weights are {\tt gw}.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_df(ii) = d_delta_df(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
             &  * ( beta_path_f(aa:aa+ng-1) + &
             &      sps_path(ga:ga+ng-1) * dBeta_df_f(aa:aa+ng-1) ) &
             &  - singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds) * exp(-grids_v)

  end subroutine Get_d_delta_df_linlog_f

! =====     Private Procedures     =====================================

  ! ----------------------------------------  Get_Do_Calc_Indexed  -----
  subroutine Get_Do_Calc_Indexed ( N, Tan_Pt_C, Do_Calc_All, F_Inds, Do_GL, &
    & Do_Calc, N_Inds, Inds )

  ! Set Do_Calc if Do_Calc_All(1::ngp1), or Do_GL and any of the corresponding
  ! Do_Calc_All(f_inds) flags are set.
  ! Get_Do_Calc_Indexed determines that Get_d_Delta_df needs to integrate a
  ! panel if Do_Calc_All(1::ngp1) is true, which means the interpolating
  ! coefficient is nonzero, or if Do_GL is true and Do_Calc_All(f_inds) is
  ! true, which means that GL was needed, even if some interpolating
  ! coefficient is zero.

    use GLNP, ONLY: Ng, NGP1

    integer, intent(in) :: N              ! sizes on coarse grid
    integer, intent(in) :: Tan_Pt_C       ! Index of tangent point in coarse grid

#if defined NAG
!   Assumed-shape arguments are slower than assumed size
    logical, intent(in) :: Do_Calc_all(*) ! On the entire path
    integer, intent(in) :: F_Inds(*)      ! Indices in Do_Calc_All for fine grid
                                          ! GL points on panels needing GL.
    logical, intent(in) :: Do_GL(*)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(*)    ! Where on coarse grid to do calc.
    integer, intent(out) :: N_Inds        ! count(do_calc)
    integer, intent(out) :: Inds(*)       ! Indices where do_calc is true
#elif defined IFC
!   Contiguous assumed-shape arguments are no slower than assumed size
    logical, contiguous, intent(in) :: Do_Calc_all(:) ! On the entire path
    integer, contiguous, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for fine grid
                                                      ! GL points on panels needing GL.
    logical, contiguous, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, contiguous, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.
    integer,             intent(out) :: N_Inds        ! count(do_calc)
    integer, contiguous, intent(out) :: Inds(:)       ! Indices where do_calc is true
#elif defined LF95
!   Assumed-shape arguments are faster than assumed size because of copying
    logical, intent(in) :: Do_Calc_all(:) ! On the entire path
    integer, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for fine grid
                                          ! GL points on panels needing GL.
    logical, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.
    integer, intent(out) :: N_Inds        ! count(do_calc)
    integer, intent(out) :: Inds(:)       ! Indices where do_calc is true
#else
!   We don't know whether assumed-shape or assumed size arguments are faster
    logical, intent(in) :: Do_Calc_all(:) ! On the entire path
    integer, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for fine grid
                                          ! GL points on panels needing GL.
    logical, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.
    integer, intent(out) :: N_Inds        ! count(do_calc)
    integer, intent(out) :: Inds(:)       ! Indices where do_calc is true
#endif

    integer :: I, P_I
!     integer :: J
    integer :: K
!     logical :: T_calc(size(f_inds)/ng)

!     do_calc = do_calc_all(1::ngp1)
    i = 1 - Ng
    n_inds = 0
!     do_calc(1:n) = do_calc_all(ngp1-ng:n*ngp1:ngp1)
!     do_calc(tan_pt_c) = .false. ! Don't do GL between tangent points
    do p_i = 1, n
      do_calc(p_i) = do_calc_all(ngp1*p_i-ng)
      if ( do_gl(p_i) ) then
        i = i + Ng
        k = f_inds(i)
!       This is fastest with NAG -g, NAG -O and lf95 -O but it needs to be
!       changed by hand if NG is changed
        do_calc(p_i) = do_calc(p_i) .or. &
          & do_calc_all(k) .or. do_calc_all(k+1) .or. do_calc_all(k+2)
! !       This isn't quite as fast
!         do j = 0, ng-1
!           do_calc(p_i) = do_calc(p_i) .or. do_calc_all(k+j)
!         end do
! !       These are even slower
!         k = f_inds(i)
!         do_calc(p_i) = do_calc(p_i) .or. any(do_calc_all(k:k+ng-1))
!         if ( any(do_calc_all(f_inds(i:i+ng-1))) ) do_calc(p_i)=.true.
      end if
      if ( do_calc(p_i) ) then
        n_inds = n_inds + 1
        inds(n_inds) = p_i
      end if
    end do
! !   This is much slower
!     do p_i = 1, size(t_calc)
!       k = f_inds((p_i-1)*ng+1)
!       t_calc(p_i) = do_calc_all(k)
!       do j = 1, ng-1
!         t_calc(p_i) = t_calc(p_i) .or. do_calc_all(k+j)
!       end do
!     end do
!     do_calc = do_calc .or. unpack(t_calc,do_gl,.false.)

  end subroutine Get_Do_Calc_Indexed

  ! ---------------------------------------------------  Get_Inds  -----
  subroutine Get_Inds ( Do_GL, Do_Calc, More_Inds, All_Inds )

    ! More_Inds are the places in the coarse path where both Do_Calc and Do_GL.
    ! All_Inds are the corresponding places in the GL-extracted fine path.

    ! Get_Inds is similar to Get_Do_Calc_Indexed, but computes indices 
    ! for the coarse path, or the coarse path points in the composite path.

    use GLNP, ONLY: Ng

    implicit NONE

  ! Inputs
    logical, intent(in) :: Do_GL(:)      ! Coarse path flag indicating where to
      !                                    do gl integrations.
    logical, intent(in) :: Do_Calc(:)    ! Coarse path flag indicating where
                                         ! any interpolating coeffient is nonzero
  ! Outputs
    integer, intent(out) :: More_Inds(:) ! Indices on coarse path where GL is
                                         ! to be used.
    integer, intent(out) :: All_Inds(:)  ! First index in GL_Inds of a fine-path
                                         ! point where a GL ordinate is to be
                                         ! computed.  The remaining NG-1 indices
                                         ! are consecutive.

    integer :: I, J, L, P_I
!   integer :: K

    i = 1
    j = 1
    l = 1
    do p_i = 2 , size(do_gl)-1
      if ( do_gl(p_i) ) then
        if ( do_calc(p_i) ) then
          more_inds(i) = p_i
! !         all_inds(j:j+ng-1) = (/ ( (p_i-2)*ng+k, k = 1, ng ) /)
!           all_inds(j:j+ng-1) = (/ ( l + k, k = 0, ng-1 ) /)
!           forall( k = 0: ng - 1 ) all_inds(j+k) = l + k
          ! OK, here be dragons.
          ! Van originally had this line:
          !         all_inds(j:j+ng-1) = (/ ( (p_i-2)*ng+k, k = 1, ng ) /)
          ! Then he replaced it with this one
          !         all_inds(j:j+ng-1) = (/ ( l + k, k = 0, ng-1 ) /)
          ! It turns out, through a bizarre and worrying series of discoveries about Lahey
          ! that that was really slow under some repeatable, but totally unjustifiable circumstances.
          ! hence the regular do loop below - NJL / WVS
!           do k = 0, ng - 1
!             all_inds(j+k) = l+k
!           end do
          ! We actually only need the first of the GL inds, since the rest
          ! are consecutive.
          all_inds(j) = l
          i = i + 1
          j = j + 1
        end if
        l = l + Ng
      end if
    end do

  end subroutine Get_Inds

  pure integer function N_Eta_Rows ( Eta_FZP, Need ) result ( N )
    use Sparse_m, only: Sparse_t
    class(sparse_t), intent(in) :: Eta_FZP(:) ! Interpolating coefficients
                                              ! from state vector to combined
                                              ! coarse & fine path for each sps.
    logical, intent(in) :: Need               ! Need to do the computation
    n = 0
    if ( need ) then ! need space for stuff; Some stuff is needed only for TScat
      n = maxval(eta_fzp%nRows)
    end if
  end function N_Eta_Rows

!----------------------------------------------------------------------
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: rad_tran_m.F90,v 2.39 2018/09/12 22:50:44 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, not_used_here ! .mod files sometimes change if PRINT is added
  end function not_used_here

end module RAD_TRAN_M

! $Log: rad_tran_m.F90,v $
! Revision 2.39  2018/09/12 22:50:44  vsnyder
! Delete dRad_Tran_dX.  Change the name of dRad_Tran_dX_Sparse to dRad_Tran_dX.
!
! Revision 2.38  2018/09/12 22:03:38  vsnyder
! Add dRad_Tran_dX_Sparse.  Inline code from do_delta_m.
!
! Revision 2.37  2018/05/24 03:24:36  vsnyder
! Use sparse representation for dh_dt_path
!
! Revision 2.36  2018/05/14 23:40:58  vsnyder
! Change to sparse eta representation
!
! Revision 2.35  2017/08/09 20:47:34  vsnyder
! Add Tan_Pt_C argument, but it isn't actually used yet
!
! Revision 2.34  2017/03/31 00:46:30  vsnyder
! Remove Get_d_delta_dx because it's subsumed by Get_d_delta_df
!
! Revision 2.33  2017/03/17 20:19:23  vsnyder
! Cannonball polishing -- changed two variable names
!
! Revision 2.32  2014/09/05 21:26:38  vsnyder
! Use the CONTIGUOUS attribute with ifort
!
! Revision 2.31  2013/07/13 00:03:21  vsnyder
! Remove LD argument from get_all_d2_delta_df2
!
! Revision 2.30  2013/05/18 00:34:44  vsnyder
! Insert NG fine-grid (GL) points between tangent points, thereby
! regularizing coarse-grid spacing, and reducing significantly the need
! to use c_inds to extract coarse-grid points from the composite grid.
!
! Revision 2.29  2011/11/09 00:17:44  vsnyder
! Remove non-standard TAB characters
!
! Revision 2.28  2011/08/20 00:44:02  vsnyder
! Get rid of DOS line ends
!
! Revision 2.27  2011/07/29 01:59:24  vsnyder
! Cannonball polishing
!
! Revision 2.26  2011/07/08 21:25:58  yanovsky
! Use d2Alpha_df2
!
! Revision 2.25  2011/06/02 22:43:12  yanovsky
! In d2Rad_tran_df2 subroutine, add computations of analytical 
! mixing ratio Hessians in logarithmic basis
!
! Revision 2.24  2011/03/25 20:46:59  vsnyder
! Delete declarations of unused objects
!
! Revision 2.23  2011/03/24 00:17:34  vsnyder
! Add TScat derivatives to dRad_tran_df
!
! Revision 2.22  2011/03/23 23:45:32  vsnyder
! This log entry is bogus.  Check in again to get the right one.
! FOV_Convolve_m.f90
!
! Revision 2.21  2011/03/11 03:09:08  vsnyder
! Use Get_dAlpha_df
!
! Revision 2.20  2011/03/04 03:41:25  vsnyder
! Remove declaration for unused variable
!
! Revision 2.19  2011/02/12 03:57:40  vsnyder
! Add mixing-ratio dependence for H2O derivatives
!
! Revision 2.18  2011/02/05 01:18:06  vsnyder
! Correct bugs where dBeta_df is used
!
! Revision 2.17  2011/01/28 19:17:11  vsnyder
! Lots of stuff for TScat derivatives
!
! Revision 2.16  2010/12/07 01:20:57  vsnyder
! dRad_tran_dx needs to call dscrt_dx
!
! Revision 2.15  2010/11/05 20:28:13  vsnyder
! Delete unused declarations
!
! Revision 2.14  2010/08/27 23:17:11  vsnyder
! Remove '(ip)' from all integer declarations
!
! Revision 2.13  2010/08/27 05:51:03  yanovsky
! Changed types of indices_c and gl_inds dummy arguments from integer(ip) to integer.
!
! Revision 2.12  2010/08/19 02:04:03  vsnyder
! Change some variable names, restructure dRad_tran_dT
!
! Revision 2.11  2010/06/12 01:27:59  vsnyder
! Use get_d_delta_df_linlog in drad_tran_dx because it does the right
! calculation if it's given dbeta_df instead of beta.
!
! Revision 2.10  2010/06/11 02:20:46  vsnyder
! Integrated Igor's latest changes with mine
!
! Revision 2.9  2010/06/09 23:13:01  yanovsky
! Removed code implementing d_delta_df computations from drad_tran_df. 
! Drad_tran_df now calls get_d_delta_df
!
! Revision 2.8  2010/06/09 22:04:14  yanovsky
! Added d2Rad_tran_df2 and get_d_delta_df subroutines
!
! Revision 2.7  2010/05/14 02:41:08  vsnyder
! Changed intent for [n]nz_d_delta_df from out to inout.  Replaced
! indices_c(ii) by iii at a place where iii == indices(ii)
!
! Revision 2.6  2010/01/23 01:21:24  vsnyder
! Handle derivatives for betas that depend upon mixing ratio
!
! Revision 2.5  2009/06/16 17:37:09  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.4  2009/06/13 01:11:55  vsnyder
! Specify start and end of path, simplify some index calculations
!
! Revision 2.3  2007/07/11 22:26:45  vsnyder
! Dumps
!
! Revision 2.2  2007/06/26 00:40:01  vsnyder
! Minor improvement in Get_Do_Calc_Indexed
!
! Revision 2.1  2007/06/08 22:05:13  vsnyder
! Replacing rad_tran_m.f90 by rad_tran_m.F90
!
!
! Deleted rad_tran_m.f90 to replace it with rad_tran_m.F90
!
! Revision 2.52  2006/12/13 02:32:03  vsnyder
! Drag the tangent point around instead of assuming it's the middle one
!
! Revision 2.51  2006/07/20 01:09:27  vsnyder
! Make sure drad_df gets a value
!
! Revision 2.50  2006/04/11 18:31:58  vsnyder
! Cannonball polishing
!
! Revision 2.49  2006/02/08 01:02:01  vsnyder
! More stuff for spectroscopy derivatives
!
! Revision 2.48  2005/11/21 22:57:27  vsnyder
! PFA derivatives stuff
!
! Revision 2.47  2005/11/01 23:02:21  vsnyder
! PFA Derivatives
!
! Revision 2.46  2005/09/17 00:49:54  vsnyder
! Revise arrays for spectroscopic derivatives, plus some cannonball polishing
!
! Revision 2.45  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.44  2005/04/26 15:35:54  livesey
! Minor changes necessitated by wierdo problems with LF95.  Probably won't
! fix the problem but might as well keep them.
!
! Revision 2.43  2005/03/28 20:24:37  vsnyder
! Taus past the black-out are zero, not one!
!
! Revision 2.42  2005/03/03 02:07:42  vsnyder
! Remove USEs for unreferenced symbols
!
! Revision 2.41  2004/11/01 20:25:44  vsnyder
! Reorganization of representation for molecules and beta groups; PFA may be broken for now
!
! Revision 2.40  2004/10/06 21:18:24  vsnyder
! Add rad_tran_PFA
!
! Revision 2.39  2004/08/03 22:06:46  vsnyder
! Inching further toward PFA
!
! Revision 2.38  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.37  2004/03/20 01:15:39  jonathan
!  remove rad_tran_cld
!
! Revision 2.36  2004/03/08 22:58:03  vsnyder
! Remove D_Delta_DT, which was schlepped from drad_tran_dt to
! Get_D_Delta_Pol_DT, but is no longer needed in the latter place.
!
! Revision 2.35  2004/02/03 02:47:55  vsnyder
! Progress (hopefully) on polarized temperature derivatives
!
! Revision 2.34  2004/01/23 01:16:05  vsnyder
! Repair mistakes in polarized radiance calculation:  CS_EXPMAT needs to be
! applied to incoptdepth_pol even if no GL is done, because the earlier
! calculation (in FullForwardModel) didn't have ref_cor.  We can't stop
! doing CS_EXPMAT when the sum of the eigenvalues gets large and negative,
! because the terms in the matrix are large if the difference of the
! eigenvalues is large.  If we had both eigenvalues, we'd be nearly done
! with CS_EXPMAT, so avoiding it would be as expensive as doing it.
!
! Revision 2.33  2003/12/08 17:52:47  jonathan
! update for 2d cldfwm
!
! Revision 2.32  2003/12/03 00:25:32  vsnyder
! Corrections to hydrostatic calculation
!
! Revision 2.31  2003/11/04 02:49:50  vsnyder
! Use GC_INDS calculated in FullForwardModel for more_inds
!
! Revision 2.30  2003/11/04 01:55:50  vsnyder
! Add 'FA = 0.0' in case n_path <= 4, cosmetic changes
!
! Revision 2.29  2003/11/01 03:04:02  vsnyder
! Use ds_dz_gw instead of ds_dh, dh_dz and gw; use del_zeta from FullForwardModel
!
! Revision 2.28  2003/10/30 20:36:41  vsnyder
! Get del_zeta from FullForwardModel
!
! Revision 2.27  2003/10/16 23:06:09  vsnyder
! Polish up some comments
!
! Revision 2.26  2003/10/15 02:04:08  vsnyder
! Simplifications possible after inlining path_opacity.  Cosmetic changes.
! Make Get_Del_Zeta_All public.  Don't bother checking do_calc(1) and
! do_calc(n_path) because we know it's false there.
!
! Revision 2.25  2003/10/09 21:04:38  vsnyder
! Fix typos generated while inlining path_opacity
!
! Revision 2.23  2003/09/25 20:06:03  vsnyder
! Insert TeXnicalities.  Insert many more comments too.  Inline path_opacity,
! which results in substantial savings in derivative calculations because it
! avoids constructing an array temp within a doubly-nested loop.  It doesn't
! make much differences for radiance calculations.
!
! Revision 2.22  2003/09/24 22:19:55  vsnyder
! Get rid of some array temps
!
! Revision 2.21  2003/09/09 22:34:45  vsnyder
! Don't look at status from cs_expmat if it isn't called
!
! Revision 2.20  2003/09/09 00:02:55  vsnyder
! Make deltau_pol inout, only compute it where needed
!
! Revision 2.19  2003/08/15 18:50:22  vsnyder
! Preparing the way for polarized vmr derivatives
!
! Revision 2.18  2003/06/27 22:05:48  vsnyder
! Check status from cs_expmat
!
! Revision 2.17  2003/06/18 17:24:05  bill
! added temperature derivative subsetting
!
! Revision 2.16  2003/06/09 20:52:37  vsnyder
! More work on polarized derivatives
!
! Revision 2.15  2003/05/20 00:04:28  vsnyder
! Collect common stuff into subroutines
!
! Revision 2.14  2003/05/15 03:29:00  vsnyder
! Moved some stuff up to FullForwardModel because Get_d_Deltau_pol_dT needs it
!
! Revision 2.13  2003/05/05 23:00:26  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.12.2.2  2003/03/20 01:42:26  vsnyder
! Revise Grids_T structure
!
! Revision 2.12.2.1  2003/03/05 03:31:13  vsnyder
! Get rid of unused variables, use 'any' instead of 'count'
!
! Revision 2.12  2003/02/07 02:35:48  vsnyder
! OOPS, forgot to move one down
!
! Revision 2.11  2003/02/07 02:12:00  vsnyder
! Move some USE statements down
!
! Revision 2.10  2003/02/03 19:00:52  bill
! changed interface to rad tran to speed up program
!
! Revision 2.9  2003/01/08 00:15:42  vsnyder
! Moved path_contrib to its own module
!
! Revision 2.8  2002/10/08 17:08:06  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.7  2002/10/02 20:09:48  vsnyder
! Use automatic arrays to move allocate/deallocate out of loops.  Numerous
! cosmetic changes.
!
! Revision 2.6  2002/07/05 07:52:52  zvi
! Some cosmetic changes
!
! Revision 2.5  2002/06/13 22:38:40  bill
! some variable name changes--wgr
!
! Revision 2.4  2002/06/04 10:28:04  zvi
! rename n_sps to: no_mol, more correctly
!
! Revision 2.3  2002/02/16 06:38:05  zvi
! Some cosmetic changes..
!
! Revision 2.2  2002/01/30 01:11:22  zvi
! Fix bug in user selectable coeff. code
!
! Revision 2.1  2002/01/27 08:37:51  zvi
! Adding Users selected coefficients for derivatives
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.11.2.3  2001/09/13 22:51:24  zvi
! Separating allocation stmts
!
! Revision 1.11.2.2  2001/09/11 00:00:46  zvi
! Adding dt_script code
!
! Revision 1.11.2.1  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
! Revision 1.1  2000/05/04 18:12:05  vsnyder
! Initial conversion to Fortran 90
@


2.39
log
@Delete dRad_Tran_dX.  Change the name of dRad_Tran_dX_Sparse to dRad_Tran_dX.
@
text
@d22 1
a22 1
  private :: Get_d_Delta_df_f, Get_d_Delta_df_linlog
d1660 1
a1660 1
       "$Id: rad_tran_m.F90,v 2.38 2018/09/12 22:03:38 vsnyder Exp $"
d1670 3
@


2.38
log
@Add dRad_Tran_dX_Sparse.  Inline code from do_delta_m.
@
text
@d17 1
a17 1
  public :: dRad_Tran_dF, dRad_Tran_dT, dRad_Tran_dX, dRad_Tran_dX_Sparse
d841 1
a841 1
!--------------------------------------------------  DRad_Tran_dx  -----
d845 4
a848 126
  subroutine DRad_Tran_dx ( GL_Inds, Del_Zeta, Grids_f, Eta_fzp, Sps_Path,    &
                         &  Sps_Map, Do_Calc_fzp, dBeta_Path_c, dBeta_Path_f, &
                         &  Do_GL, Del_S, Ref_Cor, ds_dz_gw, Inc_Rad_Path,    &
                         &  Tan_Pt, I_Stop, dRad_dx )

    use Load_SPS_Data_m, ONLY: Grids_t
    use MLSKinds, only: RP
    use SCRT_dN_m, ONLY: dSCRT_dx

! Inputs

    integer, intent(in) :: GL_Inds(:)        ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: Del_Zeta(:)      ! path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just the part up
                                             ! to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: Eta_fzp(:,:)     ! representation basis function,
      !                                        composite path.
    real(rp), intent(in) :: Sps_Path(:,:)    ! Path species function, path X species.
    integer, intent(in) :: Sps_Map(:)        ! second-dimension subscripts for sps_path.
    logical, intent(in) :: Do_Calc_fzp(:,:)  ! Where the representation basis
                                             ! function is not zero, composite
                                             ! path.
    real(rp), intent(in) :: dBeta_Path_c(:,:) ! derivative of beta wrt dx
                                             ! on main grid.
    real(rp), intent(in) :: dBeta_Path_f(:,:) ! derivative of beta wrt dx
    logical, intent(in) :: Do_GL(:)          ! A logical indicating where to
                                             ! do gl integrations
    real(rp), intent(in) :: Del_S(:)         ! unrefracted path length.
    real(rp), intent(in) :: Ref_Cor(:)       ! refracted to unrefracted path
                                             ! length ratios.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
                                             ! gw on the entire grid.  Only the
                                             ! gl_inds part is used.
    real(rp), intent(in) :: Inc_Rad_Path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    integer, intent(in) :: Tan_pt            ! Tangent point index in inc_rad_path
    integer, intent(in) :: I_Stop            ! path stop index

! Outputs

    real(rp), intent(out) :: dRad_dx(:)      ! derivative of radiances wrt x
!                                              state vector element. (K)
! Internals

    integer :: n_inds, no_to_gl, sps_i, sps_m, sps_n, sv_i
    integer, target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer, target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer, pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
    integer, pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                     ! on coarse path where do_calc.
    integer, pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.

    real(rp) :: d_delta_dx(1:size(inc_rad_path))  ! derivative of delta
      !              wrt spectroscopy parameter. (K)

    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

    logical :: do_calc(1:size(inc_rad_path))      ! Flags on coarse path where
                                         ! do_calc_c or (do_gl and any
                                         ! corresponding do_calc_fzp).

! Begin code

    sps_n = ubound(grids_f%l_z,1)

    do sps_i = 1 , sps_n
      sps_m = sps_map(sps_i)

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

! find where the non zeros are along the path

        call get_do_calc_indexed ( size(do_gl), tan_pt, do_calc_fzp(:,sv_i), &
          & gl_inds, do_gl, do_calc, n_inds, inds_B )

        d_delta_dx = 0.0_rp

        if ( n_inds == 0 ) then
           drad_dx(sv_i) = 0.0
           cycle
        end if


        inds => inds_B(1:n_inds)

        no_to_gl = count(do_gl(inds))

        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)

! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

        ! We're not really computing d_delta_df for lin-log mixing
        ! ratio.  It turns out that get_d_delta_df_linlog does the
        ! correct computation if we substitute dbeta_path for beta_path.
        call get_d_delta_df_linlog ( inds, gl_inds, all_inds, more_inds, &
          & eta_fzp(:,sv_i), sps_path(:,sps_m), dbeta_path_c(:,sps_i),   &
          & dbeta_path_f(:,sps_i), del_s, del_zeta, ds_dz_gw, ref_cor,   &
          & grids_f%values(sv_i), singularity, d_delta_dx )

        call dscrt_dx ( tan_pt, d_delta_dx, inc_rad_path, &
                     &  1, i_stop, drad_dx(sv_i))

      end do

    end do

  end subroutine DRad_Tran_dx

!-------------------------------------------  DRad_Tran_dx_Sparse  -----
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )

  subroutine DRad_Tran_dx_Sparse ( GL_Inds, Del_Zeta, Grids_f, Eta_fzp,    &
                         &  Sps_Path, Sps_Map, dBeta_Path_c, dBeta_Path_f, &
                         &  Do_GL, Del_S, Ref_Cor, ds_dz_gw, Inc_Rad_Path, &
                         &  Tan_Pt, I_Stop, dRad_dx )
d986 1
a986 1
  end subroutine DRad_Tran_dx_Sparse
d1647 3
a1649 3
                                           ! from state vector to combined
                                           ! coarse & fine path for each sps
    logical, intent(in) :: Need            ! Need to do the computation
d1660 1
a1660 1
       "$Id: rad_tran_m.F90,v 2.37 2018/05/24 03:24:36 vsnyder Exp $"
d1670 3
@


2.37
log
@Use sparse representation for dh_dt_path
@
text
@d17 1
a17 1
  public :: dRad_Tran_dF, dRad_Tran_dT, dRad_Tran_dX
a97 1
    use Do_Delta_m, ONLY: Polarized_Path_Opacity
d149 1
d154 1
d169 26
a194 4
      call polarized_path_opacity ( del_zeta,    &
                 &  alpha_path_c, alpha_path,    &
                 &  ds_dz_gw,                    &
                 &  gl_delta_polarized, more_inds, gl_inds )
d330 1
a330 1
    real(rp) :: d_delta_B_df(size(dB_df))
d332 4
a335 3
    logical :: Do_calc(1:size(del_s)) ! Flags on coarse path where do_calc_c
                                      ! or (do_gl and any corresponding
                                      ! do_calc_fzp).
d355 1
a355 1
    integer :: Sparse_Col                 ! Column index in Eta_FZP(sps_i)
d963 147
d1782 1
a1782 1
       "$Id: rad_tran_m.F90,v 2.36 2018/05/14 23:40:58 vsnyder Exp $"
d1792 3
@


2.36
log
@Change to sparse eta representation
@
text
@d341 1
d523 5
a527 5
                         &  alpha_path, dAlpha_dT_path, eta_zxp,              &
                         &  do_calc_hyd_c, del_s, ref_cor, h_tan, dh_dt_tan,  &
                         &  do_gl, h_path, t_path, ds_dh, dh_dz_gw, ds_dz_gw, &
                         &  dt_scr_dt, tau, inc_rad_path, i_start, tan_pt,    &
                         &  i_stop, deriv_flags, pfa_update, drad_dt )
d531 1
a531 1
    use SCRT_dN_m, ONLY: dSCRT_dT, dSCRT_dX
d541 3
a543 3
    real(rp), intent(in), target :: dh_dt_path(:,:) ! derivative of path height
                                            ! wrt temperature(km/K) on
                                            ! composite coarse & fine path.
a550 2
    logical, intent(in) :: do_calc_hyd_c(:,:) ! Indicates where dh_dt is not
                                            ! zero on main grid.
d555 1
a555 2
    real(rp), intent(in) :: dh_dt_tan(:)    ! derivative of path height wrt
                                            ! temperature at the tangent (km/K).
d590 3
a592 1
    real(rp), pointer :: Alpha_Path_c(:), dh_dt_path_c(:,:)
d616 2
d628 2
a629 1
    dh_dt_path_c => dh_dt_path ( 1 :: ngp1, : )
d632 2
d644 2
d682 4
a685 1
      do_calc = do_calc_hyd_c(:,sv_i)
d708 2
a709 2
              fa = (h_path_c(p_i-1) * dh_dt_path_c(p_i-1,sv_i) - &
                 &  h_tan * dh_dt_tan(sv_i)) / s_del_s
d713 2
a714 2
            fb = (h_path_c(p_i) * dh_dt_path_c(p_i,sv_i) - &
                & h_tan * dh_dt_tan(sv_i)) / s_del_s
d735 2
a736 2
          fa = (h_path_c(tan_pt+2) * dh_dt_path_c(tan_pt+2,sv_i) - &
              & h_tan * dh_dt_tan(sv_i)) / s_del_s
d748 2
a749 2
              fa = (h_path_c(p_i) * dh_dt_path_c(p_i,sv_i) - &
                 &  h_tan * dh_dt_tan(sv_i)) / s_del_s
d753 2
a754 2
            fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1,sv_i) - &
               &  h_tan * dh_dt_tan(sv_i)) / s_del_s
d773 8
a780 8
            d_delta_dt(p_i) = d_delta_dt(p_i) +                        &
              & del_zeta(p_i) *                                        &
              &  sum( ( alpha_path(ga:ga+ng-1) - alpha_path_c(p_i) ) * &
              &  (((2.0_rp*h_path(ga:ga+ng-1)**2 - 3.0_rp*h_tan**2) *  &     
              &    dh_dt_path(ga:ga+ng-1,sv_i) +                       &     
              &    h_path(ga:ga+ng-1) * h_tan * dh_dt_tan(sv_i)) /     &     
              &   (sqrt(h_path(ga:ga+ng-1)**2 - h_tan**2))**3          &     
              &   + eta_zxp_col(ga:ga+ng-1) * ds_dh(ga:ga+ng-1) /      &     
d809 3
a811 1
      call eta_zxp%clear_col_and_flags ( sv_i, eta_zxp_col, do_calc_f )
d1611 1
a1611 1
       "$Id: rad_tran_m.F90,v 2.35 2017/08/09 20:47:34 vsnyder Exp $"
d1621 3
@


2.35
log
@Add Tan_Pt_C argument, but it isn't actually used yet
@
text
@a17 5
  public :: d2Rad_Tran_dF2
  public :: Get_All_d_Delta_df
  public :: Get_d_Delta_df_f, Get_d_Delta_df_linlog
  public :: Get_d_Delta_df_linlog_f
  public :: Get_d2_Delta_df2_linlog
d19 6
a24 1
  private :: Get_Do_Calc_Indexed, Get_Inds
d38 2
a39 3
                      & alpha_path_c, ref_cor, incoptdepth,            &
                      & alpha_path_gl, ds_dz_gw, t_script,             &
                      & tau, inc_rad_path, rad, i_stop )
d41 1
a41 1
    use GLNP, only: NG
d45 1
a45 1
  ! inputs
d50 1
a50 1
  !                                            where GL is needed
d53 3
a55 4
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient on coarse
  !                                            grid.
d57 1
a57 1
  !                                            length ratios.
d59 5
a63 4
  !                            from one-sided layer calculation on output.
  !                            it is the full integrated layer opacity.
    real(rp), intent(in) :: alpha_path_gl(:) ! absorption coefficient on gl
  !                                            grid.
d66 3
a68 2
  !                                            on coarse grid.
  ! outputs
a75 5
  ! Internals

    integer :: A, AA, I
  !                                            where GL is needed

d78 1
a78 1
  ! see if anything needs to be gl-d
d80 2
a81 30
    if ( size(gl_inds) > 0 ) then

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt incoptdepth}.
      !  In the second integral, $G(\zeta)$ is {\tt alpha\_path\_gl} --
      !  which has already been evaluated at the appropriate abscissae -- and
      !  $G(\zeta_i)$ is {\tt alpha\_path\_c}.  The weights are {\tt gw}.

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        incoptdepth(more_inds(i)) = incoptdepth(more_inds(i)) + &
          & del_zeta(more_inds(i)) * &
          & dot_product( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))), &
               & ds_dz_gw(aa:aa+ng-1) )
        a = a + ng
      end do ! i

    end if

    incoptdepth = ref_cor * incoptdepth
d90 4
a93 4
  subroutine Rad_Tran_Pol ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
                     &  alpha_path_c, ref_cor, incoptdepth_pol, deltau_pol, &
                     &  alpha_path_gl, ds_dz_gw, ct, stcp, stsp, t_script, &
                     &  do_dumps, prod_pol, tau_pol, rad_pol, p_stop )
d98 1
a98 1
    use DO_DELTA_M, ONLY: POLARIZED_PATH_OPACITY
d100 1
a100 1
    use GLNP, ONLY: Ng
d105 1
a105 1
  ! inputs
d108 24
a131 20
    integer, intent(in) :: gl_inds(:)        ! Gauss-Legendre grid indices
    integer, intent(in) :: more_inds(:)      ! Places in the coarse path
  !                                            where GL is needed
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    complex(rp), intent(in) :: alpha_path_c(-1:,:)  ! absorption coefficient
      !              on coarse grid.
    complex(rp), intent(inout) :: deltau_pol(:,:,:) ! 2 X 2 X path.  Incremental
      !              transmissivity on the coarse path. Called E in some notes.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !              length ratios.
    complex(rp), intent(inout) :: incoptdepth_pol(:,:,:) ! incremental path
      !              opacities from one-sided layer calculation on output. it
      !              is the full integrated layer opacity. 2x2xPath
    complex(rp), intent(in) :: alpha_path_gl(-1:,:) ! absorption coefficient on
      !              gl grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
d136 1
a136 1
      !              on coarse path.
d139 1
a139 1
  ! outputs
d141 6
a146 5
    complex(rp), intent(out) :: prod_pol(:,:,:) ! product of E matrices. 2x2xPath
    complex(rp), intent(out) :: tau_pol(:,:,:)  ! transmission function. 2x2xPath
    complex(rp), intent(out) :: rad_pol(:,:)    ! radiance (K). 2x2.
    integer, intent(out) :: p_stop           ! path stop index if >= 0, else
      !              -index in incoptdepth_pol where cs_expmat failed.
d150 1
d152 3
a154 3
    complex(rp) :: gl_delta_polarized(-1:1,size(gl_inds)/ng)
    complex(rp) :: incoptdepth_pol_gl(2,2,size(gl_inds)/ng)
    integer :: N_PATH
d160 1
d164 1
a164 1
  ! see if anything needs to be gl-d
d169 1
a169 1
                 &  alpha_path_c, alpha_path_gl, &
d235 8
a242 6
  subroutine DRad_Tran_df ( max_f, gl_inds, del_zeta, Grids_f,  eta_fzp,     &
                          & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw,    &
                          & inc_rad_path, dAlpha_df_c, dAlpha_df_f, i_start, &
                          & tan_pt, i_stop, LD, d_delta_df, nz_d_delta_df,   &
                          & nnz_d_delta_df, drad_df, dB_df, Tau, nz_zxp,     &
                          & nnz_zxp, alpha_path_c, Beta_c_e, dBeta_c_a_dIWC, &
d246 1
d250 1
d255 5
a259 5
    integer, intent(in) :: Max_f            ! Leading dimension of dAlpha_df_f
    integer, intent(in) :: GL_Inds(:)       ! Gauss-Legendre grid indices
    real(rp), intent(in) :: Del_Zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
d261 3
a263 4
    real(rp), intent(in) :: Eta_fzp(max_f,*) ! representation basis function.
    logical, intent(in) :: Do_Calc_fzp(:,:)  ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero on the fine path.
d265 1
a265 1
      !                                        do gl integrations
d267 1
a267 1
      !                                        length ratios.
d269 1
a269 1
      !                                        length.
d271 2
a272 1
      !              gw on the entire grid.  Only the gl_inds part is used.
d275 3
a277 3
    real(rp), intent(in) :: dAlpha_df_c(:,:) ! On the coarse path
    real(rp), intent(in) :: dAlpha_df_f(max_f,*) ! On the GL path
    integer, intent(in) :: I_start           ! path_start_index + 1
d279 1
a279 1
    integer, intent(in) :: I_stop            ! path stop index
d281 2
a282 1
    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF
a286 3
    ! To project dB_df from the path to the grid:
    integer, intent(in), optional :: NZ_ZXP(:,:) ! for eta_fzp: path X 1 SV
    integer, intent(in), optional :: NNZ_ZXP(:)  ! for eta_fzp: SV
d297 3
a299 7
    real(rp), intent(inout) :: d_delta_df(ld,*) ! path x sve.  derivative of
      !              delta wrt mixing ratio state vector element. (K)
      !              Initially set to zero by caller.
    integer, intent(inout), target :: nz_d_delta_df(:,:) ! Nonzeros in d_delta_df
    integer, intent(inout) :: nnz_d_delta_df(:) ! Column lengths in nz_delta_df
    real(rp), intent(out) :: drad_df(:)      ! derivative of radiances wrt
      !              mixing ratio state vector element. (K)
d303 29
a331 4
    integer :: i_begin, sps_i, sv_i
    real(rp) :: d_delta_B_df(size(dB_df),1)
    logical Nothing(Grids_f%l_v(ubound(Grids_f%l_z,1))) ! "Nothing to do here"
    logical :: Do_TScat              ! Include dependence upon dB_df
d335 2
a336 5
    call get_all_d_delta_df ( max_f, tan_pt, gl_inds, del_zeta, grids_f,   & 
                            & eta_fzp, do_calc_fzp, do_gl, del_s, ref_cor, & 
                            & ds_dz_gw, dAlpha_df_c, dAlpha_df_f, LD,      & 
                            & d_delta_df, nz_d_delta_df, nnz_d_delta_df,   &
                            &  nothing )
d338 7
a344 1
    Do_TScat = size(dB_df) > 0
d347 2
d351 1
d390 2
a391 2
        call get_dB_df ( alpha_path_c, beta_c_e, dBeta_c_a_dIWC, &
                       & dBeta_c_s_dIWC, dAlpha_df_c(:,sps_i), w0, &
d397 32
d430 19
a448 3
        if ( nothing(sv_i) ) then
          drad_df(sv_i) = 0.0
          cycle
d451 1
a451 1
        i_begin = max(i_start,min(nz_d_delta_df(1,sv_i),i_stop))
d489 11
a499 2
          call dt_script ( dB_df, eta_fzp(:,sv_i:sv_i), nz_zxp(:,sv_i:sv_i), &
            & nnz_zxp(sv_i:sv_i), d_delta_B_df, w0, dTScat_df(:,sv_i:sv_i) )
d505 2
a506 2
          call dscrt_dt ( tan_pt, d_delta_df(:,sv_i), tau, inc_rad_path,&
                        & d_delta_B_df(:,1), i_begin, i_stop, drad_df(sv_i) )
d508 1
a508 1
          call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
a517 289
!------------------------------------------------  D2Rad_Tran_df2  -----
! This is the radiative transfer second derivative wrt mixing ratio model

  subroutine D2Rad_Tran_df2 ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,   &
                            & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw, &
                            & inc_rad_path, d2Alpha_df2_c, d2Alpha_df2_f,   &
                            & i_start, tan_pt, i_stop, LD, d_delta_df,      &
                            & nz_d_delta_df, nnz_d_delta_df,d2_delta_df2,   &
                            & d2rad_df2 )

    use Load_SPS_Data_m, ONLY: Grids_t
    use MLSKinds, only: RP
    use SCRT_dN_m, ONLY: d2SCRT_dX2

! Inputs

    integer, intent(in) :: Max_f             ! Leading dimension of d2Alpha_df2_f
    integer, intent(in) :: gl_inds(:)        ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid. This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: eta_fzp(max_f,*) ! representation basis function.
    logical, intent(in) :: do_calc_fzp(:,:)  ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero on the fine path.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
      !                                       length ratios.
    real(rp), intent(in) :: ds_dz_gw(:)     ! path length wrt zeta derivative *
      !              gw on the entire grid. Only the gl_inds part is used.
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(in) :: d2Alpha_df2_c(:,:) ! On the coarse path
    real(rp), intent(in) :: d2Alpha_df2_f(max_f,*) ! On the GL path
    integer, intent(in) :: I_start           ! path_start_index + 1
    integer, intent(in) :: tan_pt            ! Tangent point index
    integer, intent(in) :: I_stop            ! path stop index
    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF
    ! integer, intent(in) :: min_nz_d_delta_df(:) ! First Nonzeros in d_delta_df

    real(rp), intent(inout) :: d_delta_df(ld,*) ! path x sve. derivative of
      !              delta wrt mixing ratio state vector element. (K)
      !              Initially set to zero by caller.




! Outputs

    integer, intent(inout), target :: nz_d_delta_df(:,:) ! Nonzeros in d_delta_df
    integer, intent(inout) :: nnz_d_delta_df(:) ! Column lengths in nz_delta_df
    real(rp), intent(inout) :: d2_delta_df2(:,:,:) ! path x sve x sve.  Second 
      !               derivative of delta wrt mixing ratio state vector element.
    real(rp), intent(out) :: d2rad_df2(:,:)    ! second derivative of radiances wrt
                                               ! mixing ratio state vector element. (K)

! Internals

    logical :: Nothing(Grids_f%l_v(ubound(Grids_f%l_z,1))) ! "Nothing to do here"
    integer :: i_begin
    integer :: sps_i, sps_j          ! species indices
    integer :: q, r                  ! state vector indices

! Begin code

    call get_all_d2_delta_df2( max_f, tan_pt, gl_inds, del_zeta, Grids_f,    &
                             & eta_fzp, do_calc_fzp, do_gl, del_s, ref_cor,  &
                             & ds_dz_gw, d2Alpha_df2_c, d2Alpha_df2_f,       &
                             & nz_d_delta_df, nnz_d_delta_df, d2_delta_df2,  &
                             & nothing )

    do sps_i = 1, ubound(Grids_f%l_z,1)

      do sps_j = 1, ubound(Grids_f%l_z,1)
    
        ! do q = 1,  Grids_f%l_v(sps_i)
        do q = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

          if ( nothing(q) ) then
            d2rad_df2(q,:) = 0.0
            d2rad_df2(:,q) = 0.0
            cycle
          end if

          ! do r = 1,  Grids_f%l_v(sps_j)
          do r = Grids_f%l_v(sps_j-1)+1, Grids_f%l_v(sps_j)

            i_begin = max(i_start,min(max(nz_d_delta_df(1,q),nz_d_delta_df(1,r)),i_stop))            
            !i_begin = max(i_start,min(max(min_nz_d_delta_df(r),min_nz_d_delta_df(q)),i_stop))
            ! i_begin = max(i_start,min(max(inds_q(1),inds_r(1)),i_stop))
            
            
            call d2scrt_dx2 ( tan_pt, d_delta_df(:,q), d_delta_df(:,r), d2_delta_df2(:,q,r), &
                            & inc_rad_path, i_begin, i_stop, d2rad_df2(q,r) )

          end do ! r

        end do ! q
      
      end do ! sps_j

    end do ! sps_i

  end subroutine D2Rad_Tran_df2

!-------------------------------------------- Get_All_d2_Delta_df2 -----

  subroutine Get_All_d2_Delta_df2 ( max_f, tan_pt_c, gl_inds, del_zeta,       &
                              & Grids_f, eta_fzp, do_calc_fzp, do_gl, del_s,  &
                              & ref_cor, ds_dz_gw, d2Alpha_df2_c,             &
                              & d2Alpha_df2_f, nz_d_delta_df, nnz_d_delta_df, &
                              & d2_delta_df2, nothing )

    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP

! Inputs

    integer, intent(in) :: Max_f             ! Leading dimension of d2Alpha_df2_f
    integer, intent(in) :: Tan_Pt_C          ! Index of tangent point in coarse
      !                                        path
    integer, intent(in) :: gl_inds(:)        ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: eta_fzp(max_f,*) ! representation basis function.
    logical, intent(in) :: do_calc_fzp(:,:)  ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero on the fine path.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: d2Alpha_df2_c(:,:)  ! On the coarse path
    real(rp), intent(in) :: d2Alpha_df2_f(max_f,*)  ! On the GL path

! Outputs

    integer, intent(inout), target :: nz_d_delta_df(:,:)  ! Nonzeros in d_delta_df
    integer, intent(inout) :: nnz_d_delta_df(:)           ! Column lengths in nz_delta_df

    ! IGOR: Compare it with declaration  d_delta_df(ld,*)  in Get_all_d_delta_df .
    real(rp), intent(inout) :: d2_delta_df2(:,:,:) ! path x sve x sve.  Second Derivative
      !              of delta wrt mixing ratio state vector elements. (K)
      !              Initially set to zero by caller.
    logical, intent(out) :: nothing(:) ! "Nothing to do for this s.v. element

! Internals

    integer :: n_inds_q, n_inds_r
    integer :: no_to_gl_q, no_to_gl_r
    integer :: sps_i, sps_j          ! species indices
    integer :: sps_n
    integer :: q, r                  ! state vector indices: sv_i, sv_j
    integer :: diracDelta            !   =1 if q=r;  =0 otherwise
    integer, target, dimension(1:size(del_s)) ::  all_inds_B_q,  all_inds_B_r
    integer, target, dimension(1:size(del_s)) :: more_inds_B_q, more_inds_B_r
    integer, pointer :: all_inds_q(:), all_inds_r(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
    integer, pointer :: inds_q(:), inds_r(:)      ! inds => part_of_nz_d_delta_df;
                                     ! Indices on coarse path where do_calc.
    integer, pointer :: more_inds_q(:), more_inds_r(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.

    real(rp) :: singularity(1:size(del_s)) ! integrand on left edge of coarse
                                     ! grid panel -- singular at tangent pt.
    logical :: do_calc_q(1:size(del_s)) ! Flags on coarse path where do_calc_c
                                     ! or (do_gl and any corresponding
                                     ! do_calc_fzp).
    logical :: do_calc_r(1:size(del_s)) ! Flags on coarse path where do_calc_c
                                     ! or (do_gl and any corresponding
                                     ! do_calc_fzp).

! Begin code

    ! d2_delta_df2 is set to zero by the caller outside of all its loops.

    sps_n = ubound(Grids_f%l_z,1)

    do sps_i = 1, sps_n

      do sps_j = 1, sps_n

        do q = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

          !d_delta_df(nz_d_delta_df(:nnz_d_delta_df(q),q),q) = 0.0
          nnz_d_delta_df(q) = 0

          do r = Grids_f%l_v(sps_j-1)+1, Grids_f%l_v(sps_j)

            !d_delta_df(nz_d_delta_df(:nnz_d_delta_df(r),r),r) = 0.0
            nnz_d_delta_df(r) = 0

            ! Skip the masked derivatives, according to the l2cf inputs
      
            nothing(q) = .not. Grids_f%deriv_flags(q)
            nothing(r) = .not. Grids_f%deriv_flags(r)
            if ( nothing(q) .or. nothing(r) )   cycle
        
            ! find where the non zeros are along the path (for q)

            call get_do_calc_indexed ( size(do_gl), tan_pt_c, do_calc_fzp(:,q), &
              & gl_inds, do_gl, do_calc_q, n_inds_q, nz_d_delta_df(:,q) )
            
            nnz_d_delta_df(q) = n_inds_q
            nothing(q) = n_inds_q == 0
            if ( nothing(q) ) cycle

            inds_q => nz_d_delta_df(1:n_inds_q,q)

            no_to_gl_q = count(do_gl(inds_q))

            all_inds_q =>  all_inds_B_q(1:no_to_gl_q)
            more_inds_q => more_inds_B_q(1:no_to_gl_q)

            ! see if anything needs to be gl-d (for q)
            if ( no_to_gl_q > 0 ) &
              & call get_inds ( do_gl, do_calc_q, more_inds_q, all_inds_q )

            !
            ! find where the non zeros are along the path (for r)
            !
            call get_do_calc_indexed ( size(do_gl), tan_pt_c, do_calc_fzp(:,r), &
              & gl_inds, do_gl, do_calc_r, n_inds_r, nz_d_delta_df(:,r) )

            nnz_d_delta_df(r) = n_inds_r
            nothing(r) = n_inds_r == 0
            if ( nothing(r) ) cycle

            inds_r => nz_d_delta_df(1:n_inds_r,r)

            no_to_gl_r = count(do_gl(inds_r))

            all_inds_r =>  all_inds_B_r(1:no_to_gl_r)
            more_inds_r => more_inds_B_r(1:no_to_gl_r)

            if ( no_to_gl_r > 0 ) &
            ! see if anything needs to be gl-d (for r)
              & call get_inds ( do_gl, do_calc_r, more_inds_r, all_inds_r )

     ! IGOR - May not need to enter this subroutine for NON log basis sps, 
     ! since d2_delta_df2 for linear basis is zero.

            ! For molecules in logarithmic basis, calculate d2_delta_df2:

            if ( grids_f%lin_log(sps_i) ) then

              if( sps_i == sps_j ) then    ! otherwise, d2_delta_df2 = 0

                ! For same species, the following quantities should be the same
                ! for different sve:
                !   inds, all_inds, more_inds, sps.  Thus, only q quantities
                ! are passed.

                if ( q == r ) then
                  diracDelta = 1.0
                else
                  diracDelta = 0.0
                end if

                call get_d2_delta_df2( diracDelta, inds_q, gl_inds,        &
                  & all_inds_q, more_inds_q, eta_fzp(:,q), eta_fzp(:,r),   &
                  & d2Alpha_df2_c(:,sps_i), d2Alpha_df2_f(:,sps_i), del_s, &
                  & del_zeta, ds_dz_gw, grids_f%values(q), grids_f%values(r), &
                  & singularity, d2_delta_df2(:,q,r), ref_cor )

              end if   ! sps_i == sps_j

            end if   ! lin_log

          end do   ! r

        end do   ! q

      end do   ! sps_j

    end do   ! sps_i

  end subroutine Get_All_d2_Delta_df2

d521 5
a525 7
  subroutine DRad_Tran_dT ( gl_inds, del_zeta, h_path_c, dh_dt_path_c,     &
                         &  alpha_path_c, dAlpha_dT_path_c, eta_fzp,       &
                         &  do_calc_t_c, do_calc_hyd_c, del_s, ref_cor,    &
                         &  h_tan, dh_dt_tan, do_gl, h_path_f, t_path_f,   &
                         &  dh_dt_path_f, alpha_path_f, dAlpha_dT_path_f,  &
                         &  do_calc_t_f, ds_dh, dh_dz_gw, ds_dz_gw,        &
                         &  dt_scr_dt, tau, inc_rad_path, i_start, tan_pt, &
d528 1
a528 1
    use GLNP, only: NG
d531 1
d535 1
a535 1
    integer, intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
d540 10
a549 9
    real(rp), intent(in) :: dh_dt_path_c(:,:) ! derivative of path height wrt
!                                               temperature(km/K) on main grid.
    real(rp), intent(in) :: alpha_path_c(:) ! path absorption(km^-1)
!                                             on main grid.
    real(rp), intent(in) :: dAlpha_dT_path_c(:) ! path dAlpha/dT on main grid
    real(rp), intent(in) :: eta_fzp(:,:)    ! representation basis function
!                                              combined grid.
    logical, intent(in) :: do_calc_t_c(:,:) ! Indicates where the
!                    representation basis function is not zero on main grid.
d551 1
a551 1
!                                             zero on main grid.
d554 1
a554 1
!                                             length ratios.
d557 1
a557 1
!                                             temperature at the tangent (km/K).
d559 5
a563 9
!                                             to do gl integrations.
    real(rp), intent(in) :: h_path_f(:)     ! path heights + req on gl grid km.
    real(rp), intent(in) :: t_path_f(:)     ! path temperature(K) on gl grid.
    real(rp), intent(in) :: dh_dt_path_f(:,:) ! derivative of path height wrt
!                                               temperature(km/K) on gl grid.
    real(rp), intent(in) :: alpha_path_f(:) ! path absorption(km^-1) on gl grid.
    real(rp), intent(in) :: dAlpha_dT_path_f(:) ! path dAlpha/dT on gl grid
    logical, intent(in) :: do_calc_t_f(:,:) ! Indicates where the
!                    representation basis function is not zero on gl grid.
d565 2
a566 2
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
d568 2
a569 2
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
d571 2
a572 2
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
d581 1
a581 1
!                                             derivatives to do
d586 2
a587 2
!                                             temperature state vector
!                                             element. (K)
d592 1
d594 3
a596 3
    integer, target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer, target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer, pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
d599 1
a599 1
    integer, pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
d601 1
a601 1
    integer, pointer :: more_inds(:) ! more_inds => part of more_inds_B;
d604 1
d606 1
a606 1
    real(rp) :: d_delta_dt(size(del_s,1),size(eta_fzp,2)) ! path x sve.
d608 1
a608 1

d611 1
a611 1
    real(rp) :: singularity(1:size(del_zeta)) ! integrand on left edge of coarse
d614 5
a618 2
    logical :: do_calc(1:size(del_zeta)) ! do_calc_t_c .or. ( do_gl .and. any
                                         ! of the corresponding do_calc_t_f ).
d625 7
d634 2
a635 3
    d_delta_dt = 0.0_rp

    do sv_i = 1, size(eta_fzp,dim=2)
d637 1
a637 1
      if ( .not. deriv_flags(sv_i)) cycle
d639 4
d647 2
a648 2
      call get_do_calc ( do_calc_t_c(:,sv_i), do_calc_t_f(:,sv_i), do_gl, &
        & do_calc, n_inds, inds_B )
d650 1
a650 1
      if ( n_inds > 0 ) then
d652 1
a652 1
        inds => inds_B(1:n_inds)
d654 2
a655 1
        no_to_gl = count(do_gl(inds))
d657 3
a659 2
        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)
d661 4
a664 3
        ! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )
d666 1
a666 4
        call get_d_delta_df ( inds, gl_inds, all_inds, more_inds, &
          & eta_fzp(:,sv_i), dAlpha_dT_path_c, dAlpha_dT_path_f,  &
          & del_s, del_zeta, ds_dz_gw, singularity, &
          & d_delta_dt(:,sv_i) ) ! No ref_cor yet, no Lin_Log for temperature
d668 1
a668 1
        i_begin = max(inds(1)-1, i_start)
d670 1
a670 1
      end if ! n_inds > 0
d681 1
a681 1
! to the layer from J to J+1.  Therefore, we must require
d706 1
a706 2
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              &                    alpha_path_c(p_i) * (fa - fb)
d717 1
a717 1
          d_delta_dt(tan_pt,sv_i) = d_delta_dt(tan_pt,sv_i) + alpha_path_c(tan_pt) * fa
d727 2
a728 2
          d_delta_dt(tan_pt+1,sv_i) = d_delta_dt(tan_pt+1,sv_i) + &
            &                      alpha_path_c(tan_pt+1) * fa
d746 1
a746 2
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              &                    alpha_path_c(p_i) * (fb - fa)
d763 9
a771 9
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) +            &
              & del_zeta(p_i) *                                      &
              &  sum( ( alpha_path_f(a:b-1) - alpha_path_c(p_i) ) *  &
              &  (((2.0_rp*h_path_f(a:b-1)**2 - 3.0_rp*h_tan**2)     &     
              &    * dh_dt_path_f(a:b-1,sv_i) +                      &     
              &    h_path_f(a:b-1) * h_tan * dh_dt_tan(sv_i)) /      &     
              &   (sqrt(h_path_f(a:b-1)**2 - h_tan**2))**3           &     
              &   + eta_fzp(ga:ga+ng-1,sv_i) * ds_dh(ga:ga+ng-1) /   &     
              &   t_path_f(a:b-1)) * dh_dz_gw(ga:ga+ng-1) )
d782 1
a782 1
      d_delta_dt(:,sv_i) = ref_cor(:) * d_delta_dt(:,sv_i)
d790 1
a790 1
        call dscrt_dx ( tan_pt, d_delta_dt(:,sv_i), inc_rad_path, i_begin, i_stop, &
d795 1
a795 1
        call dscrt_dt ( tan_pt, d_delta_dt(:,sv_i), tau, inc_rad_path,&
d799 1
d822 3
a824 2
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
d831 2
a832 2
      !                                        function is not zero, composite
      !                                        path.
d834 1
a834 1
      !                                        on main grid.
d837 1
a837 1
      !                                        do gl integrations
d840 1
a840 1
      !                                        length ratios.
d842 2
a843 1
      !              gw on the entire grid.  Only the gl_inds part is used.
a926 131
!--------------------------------------------  Get_All_d_Delta_df  -----

  subroutine Get_All_d_Delta_df ( Max_f, Tan_Pt_C, GL_Inds, Del_Zeta, Grids_f, &
                                & Eta_fzp, Do_Calc_fzp, Do_GL, Del_s, Ref_Cor, &
                                & ds_dz_gw, dAlpha_df_c, dAlpha_df_f, LD,      &
                                & d_Delta_df, Nz_d_Delta_df, NNz_d_Delta_df,   &
                                & Nothing )

    !{ Compute
    !  \begin{equation}
    !  \frac{\partial \delta_{i \rightarrow i-1}}{\partial f^k_{lm}} =
    !  \int_{\zeta_i}^{\zeta_i-1} \frac{\partial \alpha(s)}{\partial f^k(s)}
    !  \eta^k_{lm}(s) \,\text{d}s
    !  \end{equation}
    !  where $k$ is a species index, and $lm$ index $(\phi^k_l,\zeta^k_m)$.
    !  The second dimensions of {\tt dAlpha_df_c, dAlpha_df_f, d_delta_df}, and
    !  {\tt nz_d_delta_df} flatten out $(k,l,m)$ to a single index.  The complication
    !  here arises because $\eta^k_{lm}(s)$ is very sparse.

    use Load_SPS_Data_m, ONLY: Grids_t
    use MLSKinds, only: RP

! Inputs

    integer, intent(in) :: Max_f            ! Leading dimension of dAlpha_df_f
    integer, intent(in) :: Tan_Pt_C         ! Index of tangent point in coarse
      !                                       path
    integer, intent(in) :: GL_Inds(:)       ! Gauss-Legendre grid indices
    real(rp), intent(in) :: Del_Zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: Eta_fzp(max_f,*) ! representation basis function.
    logical, intent(in) :: Do_Calc_fzp(:,:)  ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero on the fine path.
    logical, intent(in) :: Do_GL(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: Del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: Ref_Cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: dAlpha_df_c(:,:) ! On the coarse path
    real(rp), intent(in) :: dAlpha_df_f(max_f,*) ! On the GL path

    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF

! Outputs

    real(rp), intent(inout) :: d_Delta_df(ld,*) ! coarse path x sve.
      !              Derivative of delta wrt mixing ratio state vector element.
      !              (K). Initially set to zero by caller.
    integer, intent(inout), target :: Nz_d_Delta_df(:,:) ! Nonzeros in d_delta_df
    integer, intent(inout) :: NNz_d_Delta_df(:) ! Column lengths in nz_delta_df
    logical, intent(out) :: Nothing(:)      ! "Nothing to do for this s.v. element

! Internals

    integer :: n_inds, no_to_gl, sps_i, sv_i
    integer, target, dimension(1:size(del_s)) :: all_inds_B
    integer, target, dimension(1:size(del_s)) :: more_inds_B
    integer, pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
    integer, pointer :: inds(:)      ! inds => part_of_nz_d_delta_df;
                                     ! Indices on coarse path where do_calc.
    integer, pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.

    real(rp) :: singularity(1:size(del_s)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.
    logical :: do_calc(1:size(del_s))    ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_fzp).

! Begin code

    ! d_delta_df is set to zero by the caller outside of all its loops.
    ! We keep track of where we create nonzeros, and replace them by zeros
    ! on the next call.  This is done because the vast majority of
    ! d_delta_df elements are zero.

    do sps_i = 1, ubound(Grids_f%l_z,1)

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
 
        ! Everything in d_delta_df not indexed by nz_d_delta_df is already zero
        d_delta_df(nz_d_delta_df(:nnz_d_delta_df(sv_i),sv_i),sv_i) = 0.0
        nnz_d_delta_df(sv_i) = 0 ! Number of nonzeros in column sv_i is now zero

        ! Skip the masked derivatives, according to the l2cf inputs

        nothing(sv_i) = .not. Grids_f%deriv_flags(sv_i)
        if ( nothing(sv_i) ) cycle

        ! find where the non zeros are along the path

        call get_do_calc_indexed ( size(do_gl), tan_pt_c, do_calc_fzp(:,sv_i), &
          & gl_inds, do_gl, do_calc, n_inds, nz_d_delta_df(:,sv_i) )
        nnz_d_delta_df(sv_i) = n_inds
        nothing(sv_i) = n_inds == 0
        if ( nothing(sv_i) ) cycle

        inds => nz_d_delta_df(1:n_inds,sv_i)

        no_to_gl = count(do_gl(inds))

        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)

        ! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

        !{ Get d_Delta_df for one state-vector element.  This is
        !  $\frac{\partial \delta_i}{\partial f^k_{lm}}$ where $i$ is the
        !  index of a path point, $k$ is the species index, and $lm$ are indices
        !  for $(\phi_l,\zeta_m)$.  {\tt sv_i} flattens $(k,l,m)$ to one index.
        call get_d_delta_df ( inds, gl_inds, all_inds, more_inds, &
          & eta_fzp(:,sv_i), dAlpha_df_c(:,sps_i), dAlpha_df_f(:,sps_i), &
          & del_s, del_zeta, ds_dz_gw, singularity, d_delta_df(:,sv_i), &
          & ref_cor, grids_f%lin_log(sps_i), grids_f%values(sv_i) )

      end do ! sv_i

    end do ! sps_i

  end subroutine Get_All_d_Delta_df

d964 99
a1062 2
  ! .............................................  Get_d_delta_df  .....
  subroutine Get_d_delta_df ( Inds, GL_Inds, All_inds, More_inds, eta_fzp, &
d1074 4
a1077 1
    integer, intent(in) :: GL_Inds(:)    ! Gauss-Legendre grid indices
d1082 4
a1085 2
    real(rp), intent(in) :: Eta_fzp(*)   ! representation basis function on
                                         ! entire grid.
d1152 1
a1152 1
  end subroutine Get_d_delta_df
d1165 5
a1169 2
    integer, intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
a1418 149

! .............................................  Get_d2_delta_df2  .....
  subroutine Get_d2_delta_df2 ( diracDelta, Inds, GL_Inds, All_inds, &
    & More_inds, eta_fzp_q, eta_fzp_r, d2Alpha_df2_path_c, d2Alpha_df2_path_f, &
    & Del_s, Del_Zeta, ds_dz_gw, &
    & Grids_v_q, Grids_v_r, Singularity, d2_delta_df2, Ref_cor )

    ! Get d2_delta_df2 for the case of lin_log species for which beta
    ! does not depend upon mixing ratio.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: diracDelta   !   =1 if q=r;  =0 otherwise
    integer, intent(in) :: Inds(:)      ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer, intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                        ! used to make GL corrections
    integer, intent(in) :: More_inds(:) ! Indices on the coarse path where
                                        ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp_q(*), eta_fzp_r(*)  ! representation basis function.
    real(rp), intent(in) :: d2Alpha_df2_path_c(*)  ! d2Alpha_df2 on coarse grid.
    real(rp), intent(in) :: d2Alpha_df2_path_f(*)  ! d2Alpha_df2 on GL grid.
    real(rp), intent(in) :: Del_s(:)    ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:) ! path -log(P) differences on the
                       !  main grid.  This is for the whole coarse path, not just
                       !  the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:) ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: Grids_v_q, Grids_v_r     ! Grids_f%values(sv_i),  
                                                     ! Grids_f%values(sv_j)
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d2_delta_df2(:) ! Second Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
                               ! elements do not become undefined.
    real(rp), intent(in), optional :: ref_cor(:)  ! refracted to unrefracted path
                                                  !  length ratios.

    integer :: AA, GA, I, II, III

    do i = 1, size(inds)

      ii = inds(i)
      iii = ii*ngp1 - ng

      singularity(ii) = d2Alpha_df2_path_c(ii) * eta_fzp_q(iii) * (eta_fzp_r(iii) - diracDelta)
      d2_delta_df2(ii) = singularity(ii) * del_s(ii)

    end do ! i


    do i = 1, size(all_inds)

      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)

      d2_delta_df2(ii) = d2_delta_df2(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp_q(ga:ga+ng-1) * (eta_fzp_r(ga:ga+ng-1) - diracDelta) * &
             & d2Alpha_df2_path_f(aa:aa+ng-1) - singularity(ii)) &
             & * ds_dz_gw(ga:ga+ng-1) )

    end do

    ! Refraction correction
    if( present(ref_cor) ) d2_delta_df2(inds) = ref_cor(inds) * d2_delta_df2(inds)

    d2_delta_df2(inds) = d2_delta_df2(inds) * exp(-grids_v_q) * exp(-grids_v_r)

  end subroutine Get_d2_delta_df2


! ......................................  Get_d2_delta_df2_linlog  .....
  subroutine Get_d2_delta_df2_linlog ( diracDelta, Inds, GL_Inds, All_inds, &
    & More_inds, eta_fzp_q, eta_fzp_r, Sps_path, Beta_path_c, Beta_path_f,  &
    & Del_s, Del_Zeta, ds_dz_gw, Ref_cor, Grids_v_q, Grids_v_r, &
    & Singularity, d2_delta_df2 )

    ! Get d2_delta_df2 for the case of lin_log species for which beta
    ! does not depend upon mixing ratio.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: diracDelta   !   =1 if q=r;  =0 otherwise
    integer, intent(in) :: Inds(:)   ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer, intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                        ! used to make GL corrections
    integer, intent(in) :: More_inds(:) ! Indices on the coarse path where
                                        ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp_q(*), eta_fzp_r(*)  ! representation basis function.
    real(rp), intent(in) :: Sps_path(:) ! exp(Path mixing ratios)
    real(rp), intent(in) :: Beta_path_c(*)  ! cross section on coarse grid.
    real(rp), intent(in) :: Beta_path_f(*)  ! cross section on GL grid.
    real(rp), intent(in) :: Del_s(:)    ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:) ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:) ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)  ! refracted to unrefracted path
                                        !  length ratios.
    real(rp), intent(in) :: Grids_v_q, Grids_v_r     ! Grids_f%values(sv_i)
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d2_delta_df2(:) ! Second Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
                               ! elements do not become undefined.

    integer :: AA, GA, I, II, III

    do i = 1, size(inds)

      ii = inds(i)
      iii = ii*ngp1 - ng

      singularity(ii) = eta_fzp_q(iii) * (eta_fzp_r(iii) - diracDelta) * &
                      & sps_path(iii) * beta_path_c(ii)
      d2_delta_df2(ii) = singularity(ii) * del_s(ii)

    end do ! i


    do i = 1, size(all_inds)

      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)

      d2_delta_df2(ii) = d2_delta_df2(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp_q(ga:ga+ng-1) * (eta_fzp_r(ga:ga+ng-1) - diracDelta) * &
             & sps_path(ga:ga+ng-1) * beta_path_f(aa:aa+ng-1) - singularity(ii)) &
             & * ds_dz_gw(ga:ga+ng-1) )

    end do

    ! Refraction correction
    d2_delta_df2(inds) = ref_cor(inds) * d2_delta_df2(inds) * exp(-grids_v_q) * exp(-grids_v_r)

  end subroutine Get_d2_delta_df2_linlog



d1583 12
d1599 1
a1599 1
       "$Id: rad_tran_m.F90,v 2.34 2017/03/31 00:46:30 vsnyder Exp $"
d1609 3
@


2.34
log
@Remove Get_d_delta_dx because it's subsumed by Get_d_delta_df
@
text
@d261 7
a267 7
  subroutine DRad_Tran_df ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,       & 
                          & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw,     & 
                          & inc_rad_path, dAlpha_df_c, dAlpha_df_f, i_start,  & 
                          & tan_pt, i_stop, LD, d_delta_df, nz_d_delta_df,    &
                          & nnz_d_delta_df, drad_df, dB_df, Tau, nz_zxp,      &
                          & nnz_zxp, alpha_path_c, Beta_c_e,                  &
                          & dBeta_c_a_dIWC, dBeta_c_s_dIWC, dTScat_df, W0 )
d291 2
a292 1
    real(rp), intent(in) :: Del_s(:)         ! unrefracted path length.
d338 5
a342 4
    call get_all_d_delta_df ( max_f, gl_inds, del_zeta, grids_f, eta_fzp,    & 
                            & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw,  & 
                            & dAlpha_df_c, dAlpha_df_f, LD, d_delta_df,      & 
                            & nz_d_delta_df, nnz_d_delta_df, nothing )
d465 2
a466 2
                            & nz_d_delta_df, nnz_d_delta_df,                &
                            & d2_delta_df2, d2rad_df2 )
d526 5
a530 4
    call get_all_d2_delta_df2( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,   &
                             & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw, &
                             & d2Alpha_df2_c, d2Alpha_df2_f, nz_d_delta_df,  &
                             & nnz_d_delta_df, d2_delta_df2, nothing )
d568 5
a572 5
  subroutine Get_All_d2_Delta_df2 ( max_f, gl_inds, del_zeta, Grids_f,       &
                              & eta_fzp, do_calc_fzp, do_gl, del_s, ref_cor, &
                              & ds_dz_gw, d2Alpha_df2_c, d2Alpha_df2_f,      &
                              & nz_d_delta_df, nnz_d_delta_df, d2_delta_df2, &
                              & nothing )
d580 2
d668 1
a668 1
            call get_do_calc_indexed ( size(do_gl), do_calc_fzp(:,q), &
d689 1
a689 1
            call get_do_calc_indexed ( size(do_gl), do_calc_fzp(:,r), &
d897 3
a899 1
! Since this is a layer boundary calculation we must require
d1105 1
a1105 1
        call get_do_calc_indexed ( size(do_gl), do_calc_fzp(:,sv_i), &
d1146 5
a1150 4
  subroutine Get_All_d_Delta_df ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,   &
                                & do_calc_fzp, do_gl, del_s, ref_cor, ds_dz_gw, &
                                & dAlpha_df_c, dAlpha_df_f, LD, d_delta_df,     &
                                & nz_d_delta_df, nnz_d_delta_df, nothing )
d1169 2
d1172 1
a1172 1
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
d1182 1
a1184 1
    real(rp), intent(in) :: Del_s(:)         ! unrefracted path length.
d1194 3
a1196 3
    real(rp), intent(inout) :: d_Delta_df(ld,*) ! path x sve.  derivative of
      !              delta wrt mixing ratio state vector element. (K)
      !              Initially set to zero by caller.
d1231 1
a1231 1

d1243 1
a1243 1
        call get_do_calc_indexed ( size(do_gl), do_calc_fzp(:,sv_i), &
a1244 1

d1276 1
a1276 1
  subroutine Get_Do_Calc ( Do_Calc_c, do_calc_fzp, Do_GL, Do_Calc, N_Inds, Inds )
d1814 1
a1814 1
  subroutine Get_Do_Calc_Indexed ( N, Do_Calc_All, F_Inds, Do_GL, &
d1827 2
a1828 1
    integer, intent(in) :: N ! sizes on coarse grid
d1834 1
d1843 1
d1852 1
d1861 1
d1876 2
d1927 4
a1930 4
    logical, intent(in) :: Do_GL(:)          ! path flag indicating where to do
      !                                        gl integrations.
    logical, intent(in) :: Do_Calc(:)

d1932 6
a1937 2
    integer, intent(out) :: More_Inds(:)
    integer, intent(out) :: All_Inds(:)
d1979 1
a1979 1
       "$Id: rad_tran_m.F90,v 2.33 2017/03/17 20:19:23 vsnyder Exp $"
d1989 3
@


2.33
log
@Cannonball polishing -- changed two variable names
@
text
@d21 1
a21 1
  public :: Get_d_Delta_df_linlog_f, Get_d_Delta_dx
d337 1
a337 1
    call get_all_d_delta_df ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,    & 
d876 1
a876 1
        call get_d_delta_dx ( inds, gl_inds, all_inds, more_inds, &
d879 1
a879 1
          & d_delta_dt(:,sv_i) ) ! No ref_cor yet
d1224 1
a1224 1
        nnz_d_delta_df(sv_i) = 0
d1257 2
a1258 2
          & del_s, del_zeta, ds_dz_gw, grids_f%lin_log(sps_i),    &
          & grids_f%values(sv_i), singularity, d_delta_df(:,sv_i), ref_cor )
a1302 78
  ! .............................................  Get_d_delta_dx  .....
  subroutine Get_d_delta_dx ( Inds, GL_Inds, All_inds, More_inds, eta_fzp, &
    & dAlpha_dx_path_c, dAlpha_dx_path_f, Del_s, Del_Zeta, ds_dz_gw,       &
    & Singularity, d_delta_dx, Ref_cor )

    ! Get d_delta_dx.  For species for which beta does not depend upon
    ! mixing ratio this gets d_delta_df if dAlpha_dx_path_* is beta_path_*.

    use GLNP, only: NG, NGP1
    use MLSKinds, only: RP

    integer, intent(in) :: Inds(:)       ! Indices on coarse path needing calc
    integer, intent(in) :: GL_Inds(:)    ! Gauss-Legendre grid indices
    integer, intent(in) :: All_inds(:)   ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer, intent(in) :: More_inds(:)  ! Indices on the coarse path where
                                         ! GL corrections get applied.
    real(rp), intent(in) :: eta_fzp(*)   ! representation basis function.
    real(rp), intent(in) :: dAlpha_dx_path_c(*) ! on coarse grid.
    real(rp), intent(in) :: dAlpha_dx_path_f(*) ! cross section on GL grid.
    real(rp), intent(in) :: Del_s(:)     ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)  ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: ds_dz_gw(:)  ! ds/dh * dh/dz * GL weights
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
                               ! grid panel -- singular at tangent pt.
                               ! Actually just work space we don't want
                               ! to allocate on every invocation.
    real(rp), intent(inout) :: d_delta_dx(:) ! Derivative of delta.
                               ! intent(inout) so the unreferenced
                               ! elements do not become undefined.
    real(rp), intent(in), optional :: Ref_cor(:) ! refracted to unrefracted
                                           !  path length ratios.

    integer :: AA, GA, I, II

    do i = 1, size(inds)
      ii = inds(i)
      singularity(ii) = dAlpha_dx_path_c(ii) * eta_fzp(ii*ngp1-ng)
      d_delta_dx(ii) = singularity(ii) * del_s(ii)
    end do ! i

    !{ Apply Gauss-Legendre quadrature to compute $\int_{\zeta_i}^{\zeta_{i-1}}
    !  \frac{\partial \alpha(s)}{\partial f^k_{lm}} \frac{\text{d}
    !  s}{\text{d} h} \frac{\text{d}h}{\text{d}\zeta} \, \text{d} s$ to the
    !  panels indicated by {\tt more\_inds}.  Here, $\frac{\partial
    !  \alpha(s)}{\partial f^k_{lm}} = \beta^k(s) \eta^k_{lm}(s)$.  We
    !  remove the singularity introduced at the tangent point by
    !  $\frac{\text{d} s}{\text{d} h}$ by writing
    !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta = G(\zeta_i)
    !  \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !  \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
    !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
    !  \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !  \text{d}\zeta$.  The first integral is easy -- it's just $G(\zeta_i)
    !  (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}. In the
    !  second integral, $G(\zeta)$ is {\tt dAlpha_dx_path\_f * eta\_zxp\_f
    !  * sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}. The weights  are
    !  {\tt gw}.

    do i = 1, size(all_inds)
      aa = all_inds(i)
      ga = gl_inds(aa)
      ii = more_inds(i)
      d_delta_dx(ii) = d_delta_dx(ii) + &
        & del_zeta(ii) * &
        & sum( (eta_fzp(ga:ga+ng-1) * dAlpha_dx_path_f(aa:aa+ng-1) - &
             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
    end do

    ! Refraction correction
    if ( present(ref_cor) ) d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)

  end subroutine Get_d_delta_dx

d1305 2
a1306 2
    & dAlpha_df_path_c, dAlpha_df_path_f, Del_s, Del_Zeta, ds_dz_gw, lin_log, grids_v, &
    & Singularity, d_delta_dx, Ref_cor )
d1308 3
a1310 2
    ! Get d_delta_dx.  For species for which beta does not depend upon
    ! mixing ratio this gets d_delta_df if dAlpha_dx_path_* is beta_path_*.
d1322 1
a1322 1
                                         ! fine grid.
d1324 2
a1325 1
    real(rp), intent(in) :: dAlpha_df_path_f(*) ! dAlpha_df on GL grid.
a1330 2
    logical, intent(in) :: lin_log       ! logarithmic interpolation was used
    real(rp), intent(in) :: Grids_v      ! Grids_f%values(sv_i)
d1335 1
a1335 1
    real(rp), intent(inout) :: d_Delta_dx(:) ! Derivative of delta.
d1339 3
a1341 1
                                           !  path length ratios.
d1348 1
a1348 1
      d_delta_dx(ii) = singularity(ii) * del_s(ii)
d1366 1
a1366 1
    !  second integral, $G(\zeta)$ is {\tt dAlpha_dx_path\_f * eta\_zxp\_f
d1375 1
a1375 1
      d_delta_dx(ii) = d_delta_dx(ii) + &
d1382 1
a1382 1
    if ( present(ref_cor) ) d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)
d1384 4
a1387 2
    ! Logarithmic interpolation correction
    if ( lin_log ) d_delta_dx(inds) = d_delta_dx(inds) * exp(-grids_v)
d1810 1
a1810 1
  ! Get_Do_Calc_Indexed determines that get_d_Delta_df needs to integrate a
d1813 1
a1813 1
  ! true, which means that GL was needed, even if an interpolating
d1959 1
a1959 1
       "$Id: rad_tran_m.F90,v 2.32 2014/09/05 21:26:38 vsnyder Exp $"
d1969 3
@


2.32
log
@Use the CONTIGUOUS attribute with ifort
@
text
@d12 1
a12 1
module RAD_TRAN_M
d16 7
a22 7
  public :: RAD_TRAN, RAD_TRAN_POL
  public :: DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
  public :: D2RAD_TRAN_DF2
  public :: Get_all_d_delta_df
  public :: Get_d_delta_df_f, Get_d_delta_df_linlog
  public :: Get_d_delta_df_linlog_f, Get_d_delta_dx
  public :: Get_d2_delta_df2_linlog
d34 1
a34 1
!------------------------------------------------------  Rad_tran  -----
d37 1
a37 1
  subroutine Rad_tran ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
d44 1
a44 1
    use SCRT_DN_M, ONLY: SCRT
d119 1
a119 1
  end subroutine Rad_tran
d123 1
a123 1
  subroutine Rad_tran_Pol ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
d256 1
a256 1
  end subroutine Rad_tran_Pol
d258 1
a258 1
!--------------------------------------------------  DRad_tran_df  -----
d261 2
a262 2
  subroutine DRad_tran_df ( max_f, gl_inds, del_zeta, Grids_f, eta_zxp,       & 
                          & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw,       & 
d269 2
a270 2
    use d_t_script_dtnp_m, only: dT_script
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
d272 1
a272 1
    use SCRT_DN_M, ONLY: DSCRT_DT, DSCRT_DX
d278 2
a279 2
    integer, intent(in) :: gl_inds(:)       ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
d283 2
a284 2
    real(rp), intent(in) :: eta_zxp(max_f,*) ! representation basis function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
d286 2
a287 2
      !                                        not zero.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
d289 1
a289 1
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
d291 1
a291 1
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
d294 1
a294 1
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
d299 1
a299 1
    integer, intent(in) :: tan_pt            ! Tangent point index in Del_Zeta
d308 2
a309 2
    integer, intent(in), optional :: NZ_ZXP(:,:) ! for eta_zxp: path X 1 SV
    integer, intent(in), optional :: NNZ_ZXP(:)  ! for eta_zxp: SV
d337 2
a338 2
    call get_all_d_delta_df ( max_f, gl_inds, del_zeta, Grids_f, eta_zxp,    & 
                            & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw,    & 
d436 1
a436 1
          call dt_script ( dB_df, eta_zxp(:,sv_i:sv_i), nz_zxp(:,sv_i:sv_i), &
d454 1
a454 1
  end subroutine drad_tran_df
d456 1
a456 1
!------------------------------------------------  D2Rad_tran_df2  -----
d459 5
a463 5
  subroutine D2Rad_tran_df2 ( max_f, gl_inds, del_zeta, Grids_f, eta_zxp, &
                            & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw, &
                            & inc_rad_path, d2Alpha_df2_c, d2Alpha_df2_f, &
                            & i_start, tan_pt, i_stop, LD, d_delta_df,    &
                            & nz_d_delta_df, nnz_d_delta_df,              &
d466 1
a466 1
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
d468 1
a468 1
    use SCRT_DN_M, ONLY: D2SCRT_DX2
d478 2
a479 2
    real(rp), intent(in) :: eta_zxp(max_f,*)   ! representation basis function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
d481 1
a481 1
      !                                        not zero.
d524 2
a525 2
    call get_all_d2_delta_df2( max_f, gl_inds, del_zeta, Grids_f, eta_zxp,   &
                             & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw,   &
d561 1
a561 1
  end subroutine d2rad_tran_df2
d563 1
a563 1
!-------------------------------------------- Get_all_d2_delta_df2 -----
d565 2
a566 2
  subroutine Get_all_d2_delta_df2 ( max_f, gl_inds, del_zeta, Grids_f,       &
                              & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,   &
d582 2
a583 2
    real(rp), intent(in) :: eta_zxp(max_f,*) ! representation basis function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
d585 1
a585 1
      !                                        not zero.
d630 1
a630 1
                                     ! do_calc_f).
d633 1
a633 1
                                     ! do_calc_f).
d663 1
a663 1
            call get_do_calc_indexed ( size(do_gl), do_calc_f(:,q), &
d684 1
a684 1
            call get_do_calc_indexed ( size(do_gl), do_calc_f(:,r), &
d723 1
a723 1
                  & all_inds_q, more_inds_q, eta_zxp(:,q), eta_zxp(:,r),   &
d740 1
a740 1
  end subroutine Get_all_d2_delta_df2
d742 1
a742 1
!--------------------------------------------------  drad_tran_dt  -----
d745 2
a746 2
  subroutine DRad_tran_dt ( gl_inds, del_zeta, h_path_c, dh_dt_path_c,     &
                         &  alpha_path_c, dAlpha_dT_path_c, eta_zxp,       &
d756 1
a756 1
    use SCRT_DN_M, ONLY: DSCRT_DT, DSCRT_DX
d770 1
a770 1
    real(rp), intent(in) :: eta_zxp(:,:)    ! representation basis function
d832 1
a832 1
    real(rp) :: d_delta_dt(size(del_s,1),size(eta_zxp,2)) ! path x sve.
d848 1
a848 1
! compute the opacity derivative singularity value
d852 1
a852 1
    do sv_i = 1, size(eta_zxp,dim=2)
d857 2
a858 2
! do the absorption part
! combine non zeros flags for both the main and gl parts
d877 1
a877 1
          & eta_zxp(:,sv_i), dAlpha_dT_path_c, dAlpha_dT_path_f,  &
d885 2
a886 2
! now do the hydrostatic part
! combine boundaries flags
d892 1
a892 1
! since this is a layer boundary calculation we must require
d896 1
a896 1
! find where the non zeros are along the path
d926 1
a926 1
! special processing at tangent.  fb is zero
d983 1
a983 1
              &   + eta_zxp(ga:ga+ng-1,sv_i) * ds_dh(ga:ga+ng-1) /   &     
d993 1
a993 1
! correct for path length refraction
d1015 1
a1015 1
  end subroutine DRad_tran_dt
d1017 1
a1017 1
!--------------------------------------------------  drad_tran_dx  -----
d1021 4
a1024 4
  subroutine DRad_tran_dx ( gl_inds, del_zeta, Grids_f, eta_zxp, sps_path,  &
                         &  sps_map, do_calc_f, dbeta_path_c, dbeta_path_f, &
                         &  do_gl, del_s, ref_cor, ds_dz_gw, inc_rad_path,  &
                         &  tan_pt, i_stop, drad_dx )
d1026 1
a1026 1
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
d1028 1
a1028 1
    use SCRT_DN_M, ONLY: DSCRT_DX
d1032 2
a1033 2
    integer, intent(in) :: gl_inds(:)        ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
d1037 1
a1037 1
    real(rp), intent(in) :: eta_zxp(:,:)     ! representation basis function,
d1039 3
a1041 3
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function, path X species.
    integer, intent(in) :: sps_map(:)        ! second-dimension subscripts for sps_path.
    logical, intent(in) :: do_calc_f(:,:)    ! Where the representation basis
d1044 1
a1044 1
    real(rp), intent(in) :: dbeta_path_c(:,:) ! derivative of beta wrt dx
d1046 2
a1047 2
    real(rp), intent(in) :: dbeta_path_f(:,:) ! derivative of beta wrt dx
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
d1049 2
a1050 1
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
a1051 1
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
d1054 1
a1054 1
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
d1057 1
a1057 1
    integer, intent(in) :: i_stop            ! path stop index
d1061 1
a1061 1
    real(rp), intent(out) :: drad_dx(:)      ! derivative of radiances wrt x
d1085 1
a1085 1
                                         ! corresponding do_calc_f).
d1098 1
a1098 1
        call get_do_calc_indexed ( size(do_gl), do_calc_f(:,sv_i), &
d1124 1
a1124 1
          & eta_zxp(:,sv_i), sps_path(:,sps_m), dbeta_path_c(:,sps_i),   &
d1135 1
a1135 1
  end subroutine DRad_tran_dx
d1137 1
a1137 1
!--------------------------------------------  Get_all_d_delta_df  -----
d1139 3
a1141 3
  subroutine Get_all_d_delta_df ( max_f, gl_inds, del_zeta, Grids_f, eta_zxp, & 
                                & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw, & 
                                & dAlpha_df_c, dAlpha_df_f, LD, d_delta_df,   & 
d1155 1
a1155 1
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
d1161 1
a1161 1
    integer, intent(in) :: gl_inds(:)       ! Gauss-Legendre grid indices
d1166 2
a1167 2
    real(rp), intent(in) :: eta_zxp(max_f,*) ! representation basis function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
d1169 2
a1170 2
      !                                        not zero.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
d1172 1
a1172 1
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
d1174 1
a1174 1
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
d1184 1
a1184 1
    real(rp), intent(inout) :: d_delta_df(ld,*) ! path x sve.  derivative of
d1187 3
a1189 3
    integer, intent(inout), target :: nz_d_delta_df(:,:) ! Nonzeros in d_delta_df
    integer, intent(inout) :: nnz_d_delta_df(:) ! Column lengths in nz_delta_df
    logical, intent(out) :: nothing(:)      ! "Nothing to do for this s.v. element
d1209 1
a1209 1
                                         ! do_calc_f).
d1233 1
a1233 1
        call get_do_calc_indexed ( size(do_gl), do_calc_f(:,sv_i), &
d1251 1
a1251 1
        !{ Get d_delta_df for one state-vector element.  This is
d1256 1
a1256 1
          & eta_zxp(:,sv_i), dAlpha_df_c(:,sps_i), dAlpha_df_f(:,sps_i), &
d1264 1
a1264 1
  end subroutine Get_all_d_delta_df
d1267 1
a1267 1
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_f, Do_GL, Do_Calc, N_Inds, Inds )
d1269 1
a1269 1
  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do-Calc_f
d1274 4
a1277 4
    logical, intent(in) :: Do_Calc_c(:) ! On the coarse grid
    logical, intent(in) :: Do_Calc_f(:) ! On the GL grid
    logical, intent(in) :: Do_GL(:)     ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)  ! Where on coarse grid to do calc.
d1287 1
a1287 1
        do_calc(p_i) = do_calc(p_i) .or. any(do_calc_f(i:i+ng-1))
d1304 1
a1304 1
  subroutine Get_d_delta_dx ( Inds, GL_Inds, All_inds, More_inds, eta_zxp, &
d1320 1
a1320 1
    real(rp), intent(in) :: eta_zxp(*)   ! representation basis function.
d1342 1
a1342 1
      singularity(ii) = dAlpha_dx_path_c(ii) * eta_zxp(ii*ngp1-ng)
d1372 1
a1372 1
        & sum( (eta_zxp(ga:ga+ng-1) * dAlpha_dx_path_f(aa:aa+ng-1) - &
d1382 1
a1382 1
  subroutine Get_d_delta_df ( Inds, GL_Inds, All_inds, More_inds, eta_zxp, &
d1398 1
a1398 1
    real(rp), intent(in) :: eta_zxp(*)   ! representation basis function on
d1408 2
a1409 2
    real(rp), intent(in) :: grids_v      ! Grids_f%values(sv_i)
    real(rp), intent(out) :: singularity(:) ! integrand on left edge of coarse
d1413 1
a1413 1
    real(rp), intent(inout) :: d_delta_dx(:) ! Derivative of delta.
d1423 1
a1423 1
      singularity(ii) = dAlpha_df_path_c(ii) * eta_zxp(ii*ngp1-ng)
d1453 1
a1453 1
        & sum( (eta_zxp(ga:ga+ng-1) * dAlpha_df_path_f(aa:aa+ng-1) - &
d1466 1
a1466 1
  subroutine Get_d_delta_df_f ( Inds, GL_Inds, All_inds, More_inds, Eta_zxp, &
d1482 1
a1482 1
    real(rp), intent(in) :: Eta_zxp(*)  ! representation basis function.
d1508 1
a1508 1
      singularity(ii) = eta_zxp(iii) &
d1540 1
a1540 1
        & sum( (eta_zxp(ga:ga+ng-1) &
d1554 1
a1554 1
    & Eta_zxp, Sps_path, Beta_path_c, Beta_path_f, Del_s, Del_Zeta,      &
d1569 1
a1569 1
    real(rp), intent(in) :: Eta_zxp(*)  ! representation basis function.
d1594 1
a1594 1
      singularity(ii) = eta_zxp(iii) * sps_path(iii) * &
d1628 1
a1628 1
        & sum( (eta_zxp(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
d1640 1
a1640 1
    & Eta_zxp, Sps_path, Beta_path_c, Beta_path_f, dBeta_df_c, dBeta_df_f, &
d1655 1
a1655 1
    real(rp), intent(in) :: Eta_zxp(*)  ! representation basis function.
d1682 1
a1682 1
      singularity(ii) = eta_zxp(iii) * sps_path(iii) * &
d1716 1
a1716 1
        & sum( (eta_zxp(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
d1730 1
a1730 1
    & More_inds, Eta_zxp_q, Eta_zxp_r, d2Alpha_df2_path_c, d2Alpha_df2_path_f, &
d1747 1
a1747 1
    real(rp), intent(in) :: Eta_zxp_q(*), Eta_zxp_r(*)  ! representation basis function.
d1774 1
a1774 1
      singularity(ii) = d2Alpha_df2_path_c(ii) * eta_zxp_q(iii) * (eta_zxp_r(iii) - diracDelta)
d1788 1
a1788 1
        & sum( (eta_zxp_q(ga:ga+ng-1) * (eta_zxp_r(ga:ga+ng-1) - diracDelta) * &
d1804 1
a1804 1
    & More_inds, Eta_zxp_q, Eta_zxp_r, Sps_path, Beta_path_c, Beta_path_f,  &
d1821 1
a1821 1
    real(rp), intent(in) :: Eta_zxp_q(*), Eta_zxp_r(*)  ! representation basis function.
d1848 1
a1848 1
      singularity(ii) = eta_zxp_q(iii) * (eta_zxp_r(iii) - diracDelta) * &
d1863 1
a1863 1
        & sum( (eta_zxp_q(ga:ga+ng-1) * (eta_zxp_r(ga:ga+ng-1) - diracDelta) * &
d1879 1
a1879 1
  subroutine Get_Do_Calc_Indexed ( N, Do_Calc_all, F_Inds, Do_GL, &
d1882 1
a1882 1
  ! Set Do_Calc if Do_Calc_All(1::ngp1) or Do_GL and any of the corresponding
d1884 3
a1886 3
  ! Get_Do_Calc_Indexed determines that get_d_delta_df needs to integrate a
  ! panel if do_calc_all(1::ngp1) is true, which means the interpolating
  ! coefficient is nonzero, or if do_gl is true and do_calc_all(f_inds) is
d1888 1
a1888 1
  ! coefficient is nonzero.
d1897 1
a1897 1
    integer, intent(in) :: F_Inds(*)      ! Indices in Do_Calc_All for find grid
d1913 1
a1913 1
    integer, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for find grid
d1919 1
a1919 1
!   We don't know whether ssumed-shape or assumed size arguments are faster
d2033 1
a2033 1
       "$Id: rad_tran_m.F90,v 2.31 2013/07/13 00:03:21 vsnyder Exp $"
d2043 3
@


2.31
log
@Remove LD argument from get_all_d2_delta_df2
@
text
@d1894 2
a1895 2
#if (defined NAG) || defined (IFC)
!     Assumed-shape arguments are slower than assumed size
d1902 8
d1911 1
a1911 1
!     Assumed-shape arguments are faster than assumed size
d1919 1
a1919 1
!     Assumed-shape arguments are faster than assumed size
d2033 1
a2033 1
       "$Id: rad_tran_m.F90,v 2.30 2013/05/18 00:34:44 vsnyder Exp $"
d2043 3
@


2.30
log
@Insert NG fine-grid (GL) points between tangent points, thereby
regularizing coarse-grid spacing, and reducing significantly the need
to use c_inds to extract coarse-grid points from the composite grid.
@
text
@d524 4
a527 5
    call get_all_d2_delta_df2( max_f, gl_inds, del_zeta, Grids_f, eta_zxp,  &
                             & do_calc_f, do_gl, del_s, ref_cor, ds_dz_gw,  &
                             & d2Alpha_df2_c, d2Alpha_df2_f, LD,            &
                             & nz_d_delta_df, nnz_d_delta_df, d2_delta_df2, &
                             & nothing )
d565 4
a568 4
  subroutine Get_all_d2_delta_df2 ( max_f, gl_inds, del_zeta, Grids_f,     &
                              & eta_zxp, do_calc_f, do_gl, del_s, ref_cor, &
                              & ds_dz_gw, d2Alpha_df2_c, d2Alpha_df2_f,    &
                              & LD, nz_d_delta_df, nnz_d_delta_df, d2_delta_df2, &
a595 2
    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF

d1985 2
a1986 1
    integer :: I, J, K, L, P_I
d2025 1
a2025 1
       "$Id: rad_tran_m.F90,v 2.29 2011/11/09 00:17:44 vsnyder Exp $"
d2035 5
@


2.29
log
@Remove non-standard TAB characters
@
text
@d261 6
a266 7
  subroutine DRad_tran_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,     & 
                          & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,        & 
                          & ds_dz_gw, inc_rad_path, dAlpha_df_c, dAlpha_df_f, & 
                          & i_start, tan_pt, i_stop,                          &
                          & LD, d_delta_df, nz_d_delta_df, nnz_d_delta_df,    &
                          & drad_df, dB_df, Tau, nz_zxp, nnz_zxp,             & 
                          & alpha_path_c, Beta_c_e,                           &
a277 1
    integer, intent(in) :: indices_c(:)     ! coarse grid indicies
d337 4
a340 5
    call get_all_d_delta_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,  & 
                            & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,     & 
                            & ds_dz_gw, dAlpha_df_c, dAlpha_df_f,            & 
                            & LD, d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
                            & nothing )
d459 6
a464 8
  subroutine D2Rad_tran_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f,     &
                            & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,        &
                            & ds_dz_gw, inc_rad_path,                           &
                            & d2Alpha_df2_c, d2Alpha_df2_f,                     &
                            & i_start, tan_pt, i_stop, LD, d_delta_df,          &
                            & nz_d_delta_df, nnz_d_delta_df,                    &
                            & d2_delta_df2,                                     &
                            & d2rad_df2 )
a472 1
    integer, intent(in) :: indices_c(:)      ! coarse grid indicies
d524 5
a528 5
    call get_all_d2_delta_df2( max_f, indices_c, gl_inds, del_zeta, Grids_f,     &
                              & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,       &
                              & ds_dz_gw, d2Alpha_df2_c, d2Alpha_df2_f,          &
                              & LD, nz_d_delta_df, nnz_d_delta_df, d2_delta_df2, &
                              & nothing )
d566 3
a568 3
  subroutine Get_all_d2_delta_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f,  &
                              & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,     &
                              & ds_dz_gw, d2Alpha_df2_c, d2Alpha_df2_f,            &
a577 1
    integer, intent(in) :: indices_c(:)      ! coarse grid indicies
d618 2
a619 2
    integer, target, dimension(1:size(indices_c)) ::  all_inds_B_q,  all_inds_B_r
    integer, target, dimension(1:size(indices_c)) :: more_inds_B_q, more_inds_B_r
d629 1
a629 1
    real(rp) :: singularity(1:size(indices_c)) ! integrand on left edge of coarse
d631 1
a631 1
    logical :: do_calc_q(1:size(indices_c)) ! Flags on coarse path where do_calc_c
d634 1
a634 1
    logical :: do_calc_r(1:size(indices_c)) ! Flags on coarse path where do_calc_c
d666 1
a666 1
            call get_do_calc_indexed ( size(do_gl), do_calc_f(:,q), indices_c, &
d687 1
a687 1
            call get_do_calc_indexed ( size(do_gl), do_calc_f(:,r), indices_c, &
d725 4
a728 5
                call get_d2_delta_df2( diracDelta, inds_q, indices_c, gl_inds, &
                  & all_inds_q, more_inds_q, eta_zxp(:,q), eta_zxp(:,r), &
                  & d2Alpha_df2_c(:,sps_i), d2Alpha_df2_f(:,sps_i), &
                  & del_s, del_zeta, &
                  & ds_dz_gw, grids_f%values(q), grids_f%values(r), &
d748 8
a755 10
  subroutine DRad_tran_dt ( indices_c, gl_inds, del_zeta, h_path_c, &
                         &  dh_dt_path_c, alpha_path_c, dAlpha_dT_path_c, &
                         &  eta_zxp, do_calc_t_c, &
                         &  do_calc_hyd_c, del_s, ref_cor, h_tan, dh_dt_tan, &
                         &  do_gl, h_path_f, t_path_f, dh_dt_path_f, &
                         &  alpha_path_f, dAlpha_dT_path_f, &
                         &  do_calc_t_f, &
                         &  ds_dh, dh_dz_gw, ds_dz_gw, dt_scr_dt, &
                         &  tau, inc_rad_path, i_start, tan_pt, i_stop, &
                         &  deriv_flags, pfa_update, drad_dt )
a762 1
    integer, intent(in) :: indices_c(:) ! coarse grid indicies
d835 1
a835 1
    real(rp) :: d_delta_dt(size(indices_c,1),size(eta_zxp,2)) ! path x sve.
d879 4
a882 4
        call get_d_delta_dx ( inds, indices_c, gl_inds, &
          & all_inds, more_inds, eta_zxp(:,sv_i), &
          & dAlpha_dT_path_c, dAlpha_dT_path_f, del_s, del_zeta, &
          & ds_dz_gw, singularity, d_delta_dt(:,sv_i) ) ! No ref_cor yet
d1024 5
a1028 5
  subroutine DRad_tran_dx ( indices_c, gl_inds, del_zeta, Grids_f,        &
                         &  eta_zxp, sps_path, sps_map, do_calc_f,        &
                         &  dbeta_path_c, dbeta_path_f, do_gl, del_s,     &
                         &  ref_cor, ds_dz_gw, inc_rad_path, tan_pt,      &
                         &  i_stop, drad_dx )
a1034 1
    integer, intent(in) :: indices_c(:)      ! coarse grid indicies
d1101 1
a1101 1
        call get_do_calc_indexed ( size(do_gl), do_calc_f(:,sv_i), indices_c, &
d1126 4
a1129 5
        call get_d_delta_df_linlog ( inds, indices_c, gl_inds, &
          & all_inds, more_inds, eta_zxp(:,sv_i), sps_path(:,sps_m), &
          & dbeta_path_c(:,sps_i), dbeta_path_f(:,sps_i), del_s, del_zeta, &
          & ds_dz_gw, ref_cor, grids_f%values(sv_i), singularity, &
          & d_delta_dx )
d1142 4
a1145 5
  subroutine Get_all_d_delta_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,  & 
                                & eta_zxp, do_calc_f, do_gl, del_s, ref_cor,     & 
                                & ds_dz_gw, dAlpha_df_c, dAlpha_df_f,            & 
                                & LD, d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
                                & nothing )
a1163 1
    integer, intent(in) :: indices_c(:)     ! coarse grid indicies
d1197 2
a1198 2
    integer, target, dimension(1:size(indices_c)) :: all_inds_B
    integer, target, dimension(1:size(indices_c)) :: more_inds_B
d1208 1
a1208 1
    real(rp) :: singularity(1:size(indices_c)) ! integrand on left edge of coarse
d1210 1
a1210 1
    logical :: do_calc(1:size(indices_c)) ! Flags on coarse path where do_calc_c
d1236 1
a1236 1
        call get_do_calc_indexed ( size(do_gl), do_calc_f(:,sv_i), indices_c, &
d1258 4
a1261 5
        call get_d_delta_df ( inds, indices_c, gl_inds, &
          & all_inds, more_inds, eta_zxp(:,sv_i), &
          & dAlpha_df_c(:,sps_i), dAlpha_df_f(:,sps_i), del_s, del_zeta, &
          & ds_dz_gw, grids_f%lin_log(sps_i), grids_f%values(sv_i), &
          & singularity, d_delta_df(:,sv_i), ref_cor )
d1307 2
a1308 3
  subroutine Get_d_delta_dx ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, eta_zxp, &
    & dAlpha_dx_path_c, dAlpha_dx_path_f, Del_s, Del_Zeta, ds_dz_gw, &
d1314 1
a1314 1
    use GLNP, only: NG
a1317 1
    integer, intent(in) :: Indices_c(:)  ! Subset from gl to coarse
d1345 1
a1345 1
      singularity(ii) = dAlpha_dx_path_c(ii) * eta_zxp(indices_c(ii))
d1385 1
a1385 2
  subroutine Get_d_delta_df ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, eta_zxp, &
d1392 1
a1392 1
    use GLNP, only: NG
a1395 1
    integer, intent(in) :: Indices_c(:)  ! Subset from gl to coarse
d1401 2
a1402 1
    real(rp), intent(in) :: eta_zxp(*)   ! representation basis function.
d1426 1
a1426 1
      singularity(ii) = dAlpha_df_path_c(ii) * eta_zxp(indices_c(ii))
d1469 3
a1471 4
  subroutine Get_d_delta_df_f ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp, Sps_path, &
    & Beta_path_c, Beta_path_f, dBeta_df_c, dBeta_df_f, &
    & Del_s, Del_Zeta, ds_dz_gw, Ref_cor, Singularity, d_delta_df )
d1476 1
a1476 1
    use GLNP, only: NG
a1479 1
    integer, intent(in) :: Indices_c(:) ! Subset from gl to coarse
d1510 1
a1510 1
      iii = indices_c(ii)
d1556 3
a1558 4
  subroutine Get_d_delta_df_linlog ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp, Sps_path, &
    & Beta_path_c, Beta_path_f, Del_s, Del_Zeta, ds_dz_gw, Ref_cor, &
    & Grids_v, Singularity, d_delta_df )
d1563 1
a1563 1
    use GLNP, only: NG
a1566 1
    integer, intent(in) :: Indices_c(:) ! Subset from gl to coarse
d1596 1
a1596 1
      iii = indices_c(ii)
d1642 2
a1643 3
  subroutine Get_d_delta_df_linlog_f ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp, Sps_path, &
    & Beta_path_c, Beta_path_f, dBeta_df_c, dBeta_df_f, &
d1649 1
a1649 1
    use GLNP, only: NG
a1652 1
    integer, intent(in) :: Indices_c(:) ! Subset from gl to coarse
d1684 1
a1684 1
      iii = indices_c(ii)
d1731 3
a1733 4
! ......................................  Get_d2_delta_df2_linlog  .....
  subroutine Get_d2_delta_df2 ( diracDelta, Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp_q, Eta_zxp_r, &
    & d2Alpha_df2_path_c, d2Alpha_df2_path_f, &
d1740 1
a1740 1
    use GLNP, only: NG
d1744 1
a1744 2
    integer, intent(in) :: Inds(:)   ! Indices on coarse path needing calc
    integer, intent(in) :: Indices_c(:) ! Subset from gl to coarse
d1775 1
a1775 1
      iii = indices_c(ii)
d1806 4
a1809 4
  subroutine Get_d2_delta_df2_linlog ( diracDelta, Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp_q, Eta_zxp_r, Sps_path, &
    & Beta_path_c, Beta_path_f, Del_s, Del_Zeta, ds_dz_gw, Ref_cor, &
    & Grids_v_q, Grids_v_r, Singularity, d2_delta_df2 )
d1814 1
a1814 1
    use GLNP, only: NG
a1818 1
    integer, intent(in) :: Indices_c(:) ! Subset from gl to coarse
d1849 1
a1849 1
      iii = indices_c(ii)
d1882 1
a1882 1
  subroutine Get_Do_Calc_Indexed ( N, Do_Calc_all, C_Inds, F_Inds, Do_GL, &
d1885 1
a1885 1
  ! Set Do_Calc if Do_Calc_All(c_inds) or Do_GL and any of the corresponding
d1888 1
a1888 1
  ! panel if do_calc_all(c_inds) is true, which means the interpolating
d1893 1
a1893 1
    use GLNP, ONLY: Ng
a1899 1
    integer, intent(in) :: C_Inds(*)      ! Indices in Do_Calc_All for coarse grid
a1907 1
    integer, intent(in) :: C_Inds(:)      ! Indices in Do_Calc_All for coarse grid
a1915 1
    integer, intent(in) :: C_Inds(:)      ! Indices in Do_Calc_All for coarse grid
d1928 1
a1928 1
!     do_calc = do_calc_all(c_inds)
d1932 1
a1932 1
      do_calc(p_i) = do_calc_all(c_inds(p_i))
d2027 1
a2027 1
       "$Id: rad_tran_m.F90,v 2.28 2011/08/20 00:44:02 vsnyder Exp $"
d2037 3
@


2.28
log
@Get rid of DOS line ends
@
text
@d572 1
a572 1
subroutine Get_all_d2_delta_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f,  &
d578 2
a579 2
use LOAD_SPS_DATA_M, ONLY: GRIDS_T
use MLSKinds, only: RP
d751 1
a751 1
end subroutine Get_all_d2_delta_df2
d2058 1
a2058 1
       "$Id: rad_tran_m.F90,v 2.27 2011/07/29 01:59:24 vsnyder Exp $"
d2068 3
@


2.27
log
@Cannonball polishing
@
text
@d459 3
a461 3
!------------------------------------------------  D2Rad_tran_df2  -----
! This is the radiative transfer second derivative wrt mixing ratio model

d468 7
a474 7
                            & d2_delta_df2,                                     &
                            & d2rad_df2 )

    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP
    use SCRT_DN_M, ONLY: D2SCRT_DX2

d476 1
a476 1

d483 1
a483 1
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
d495 2
a496 2
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
d498 5
a502 5
    real(rp), intent(in) :: d2Alpha_df2_f(max_f,*) ! On the GL path
    integer, intent(in) :: I_start           ! path_start_index + 1
    integer, intent(in) :: tan_pt            ! Tangent point index
    integer, intent(in) :: I_stop            ! path stop index
    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF
d510 2
a511 2


d513 1
a513 1

d515 1
a515 1
    integer, intent(inout) :: nnz_d_delta_df(:) ! Column lengths in nz_delta_df
d517 5
a521 5
      !               derivative of delta wrt mixing ratio state vector element.
    real(rp), intent(out) :: d2rad_df2(:,:)    ! second derivative of radiances wrt
                                               ! mixing ratio state vector element. (K)

! Internals
d523 1
a523 1
    logical :: Nothing(Grids_f%l_v(ubound(Grids_f%l_z,1))) ! "Nothing to do here"
d525 4
a528 4
    integer :: sps_i, sps_j          ! species indices
    integer :: q, r                  ! state vector indices

! Begin code
d538 1
a538 1
      do sps_j = 1, ubound(Grids_f%l_z,1)
d541 8
a548 8
        do q = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

          if ( nothing(q) ) then
            d2rad_df2(q,:) = 0.0
            d2rad_df2(:,q) = 0.0
            cycle
          end if

d550 1
a550 1
          do r = Grids_f%l_v(sps_j-1)+1, Grids_f%l_v(sps_j)
d552 2
a553 2
            i_begin = max(i_start,min(max(nz_d_delta_df(1,q),nz_d_delta_df(1,r)),i_stop))            
            !i_begin = max(i_start,min(max(min_nz_d_delta_df(r),min_nz_d_delta_df(q)),i_stop))
d555 1
a555 1
            
d558 4
a561 4
                            & inc_rad_path, i_begin, i_stop, d2rad_df2(q,r) )

          end do ! r

d566 2
a567 2
    end do ! sps_i

a618 2
    integer :: i_begin
    integer :: I_dBeta_df_i, I_dBeta_df_j ! Which column of dBeta_df_* to use if /= 0
d669 1
a669 1
            if ( nothing(q) .or. nothing(r) )   cycle
d2058 1
a2058 1
       "$Id: rad_tran_m.F90,v 2.26 2011/07/08 21:25:58 yanovsky Exp $"
d2068 3
@


2.26
log
@Use d2Alpha_df2
@
text
@d721 1
a721 1
              if( sps_i == sps_j )	then    ! otherwise, d2_delta_df2 = 0
d723 4
a726 2
                ! For same specie, the following quantities should be the same for different q:
                !   inds, all_inds, more_inds, sps.   Thus, only q quantities are passed.
d728 1
a728 1
                if ( q == r )   then
d992 9
a1000 9
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              & del_zeta(p_i) * &
              & sum( ( alpha_path_f(a:b-1) - alpha_path_c(p_i) ) *   &
              & (((2.0_rp*h_path_f(a:b-1)**2 - 3.0_rp*h_tan**2)      &     
              &   * dh_dt_path_f(a:b-1,sv_i) +                       &     
              &   h_path_f(a:b-1) * h_tan * dh_dt_tan(sv_i)) /       &     
              &  (sqrt(h_path_f(a:b-1)**2 - h_tan**2))**3            &     
              &  + eta_zxp(ga:ga+ng-1,sv_i) * ds_dh(ga:ga+ng-1) /   &     
              &  t_path_f(a:b-1)) * dh_dz_gw(ga:ga+ng-1) )
d2060 1
a2060 1
       "$Id: rad_tran_m.F90,v 2.25 2011/06/02 22:43:12 yanovsky Exp $"
d2070 3
@


2.25
log
@In d2Rad_tran_df2 subroutine, add computations of analytical mixing ratio Hessians in logarithmic basis
@
text
@d459 49
a507 2
!------------------------------------------------  D2Rad_tran_df2  -----
! This is the radiative transfer second derivative wrt mixing ratio model
a508 9
  subroutine d2Rad_tran_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                            & beta_path_c, eta_zxp, sps_path, do_calc_f,      &
                            & beta_path_f, do_gl, del_s, ref_cor,             &
                            & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                            & i_start, tan_pt, i_stop, LD,                    &
                            & d_delta_df,                                     &
                            & nz_d_delta_df, nnz_d_delta_df,                  &
                            & d2_delta_df2,                                   &
                            & d2rad_df2 )
d510 70
a579 3
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP
    use SCRT_DN_M, ONLY: D2SCRT_DX2
d583 1
a583 1
    integer, intent(in) :: Max_f             ! Leading dimension of Beta_Path_f
d590 1
a590 4
    real(rp), intent(in) :: beta_path_c(:,:) ! cross section for each species
      !                                        on coarse grid.
    real(rp), intent(in) :: eta_zxp(max_f,*)   ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
a593 2
    real(rp), intent(in) :: beta_path_f(max_f,*) ! cross section for each species
      !                                        on gl grid.
d601 2
a602 7
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(in) :: dBeta_df_c(:,:)  ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(:,:)  ! In case beta depends on mixing ratio
    integer, intent(in) :: I_start           ! path_start_index + 1
    integer, intent(in) :: tan_pt            ! Tangent point index in Del_Zeta
    integer, intent(in) :: I_stop            ! path stop index
a607 3
    real(rp), intent(inout) :: d_delta_df(ld,*) ! path x sve.  derivative of
      !              delta wrt mixing ratio state vector element. (K)
      !              Initially set to zero by caller.
d610 2
d615 1
a615 3

    real(rp), intent(out) :: d2rad_df2(:,:)    ! second derivative of radiances wrt
                                               ! mixing ratio state vector element. (K)
d627 2
a628 2
    integer, target, dimension(1:size(inc_rad_path)) ::  all_inds_B_q,  all_inds_B_r
    integer, target, dimension(1:size(inc_rad_path)) :: more_inds_B_q, more_inds_B_r
d638 1
a638 1
    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
d640 1
a640 1
    logical :: do_calc_q(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
d643 1
a643 1
    logical :: do_calc_r(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
a646 6
    integer :: What_i, What_j
               ! 0 = linear beta, no mixing ratio dependence
               ! 1 = log linear beta, no mixing ratio dependence
               ! 2 = linear beta, mixing ratio dependence
               ! 3 = log linear beta, mixing ratio dependence

d649 1
a649 4
    ! d_delta_df is set to zero by the caller outside of all its loops.
    ! We keep track of where we create nonzeros, and replace them by zeros
    ! on the next call.  This is done because the vast majority of
    ! d_delta_df elements are zero.
a654 4
      i_dBeta_df_i = grids_f%where_dBeta_df(sps_i)
      what_i =     merge(1,0,grids_f%lin_log(sps_i)) + &
             & 2 * merge(1,0,i_dBeta_df_i /= 0)

a656 4
        i_dBeta_df_j = grids_f%where_dBeta_df(sps_j)
        what_j =     merge(1,0,grids_f%lin_log(sps_j)) + &
               & 2 * merge(1,0,i_dBeta_df_j /= 0)

d659 1
a659 1
          d_delta_df(nz_d_delta_df(:nnz_d_delta_df(q),q),q) = 0.0
d664 1
a664 1
            d_delta_df(nz_d_delta_df(:nnz_d_delta_df(r),r),r) = 0.0
d668 5
a672 7
 
            if ( ( .not. Grids_f%deriv_flags(q) ) .or. &
               & ( .not. Grids_f%deriv_flags(r) ) ) then
              d2rad_df2(q,r) = 0.0
              cycle
            end if

d679 2
a680 4
            if ( n_inds_q == 0 ) then
              d2rad_df2(q,r) = 0.0
              cycle
            end if
a692 29

            select case ( what_i )
            case ( 0 ) ! linear beta, no mixing ratio dependence
              call get_d_delta_dx ( inds_q, indices_c, gl_inds, &
                & all_inds_q, more_inds_q, eta_zxp(:,q), &
                & beta_path_c(:,sps_i), beta_path_f(:,sps_i), del_s, del_zeta, &
                & ds_dz_gw, singularity, d_delta_df(:,q), ref_cor )
            case ( 1 ) ! log linear beta, no mixing ratio dependence
              call get_d_delta_df_linlog ( inds_q, indices_c, gl_inds, &
                & all_inds_q, more_inds_q, eta_zxp(:,q), sps_path(:,sps_i), &
                & beta_path_c(:,sps_i), beta_path_f(:,sps_i), del_s, del_zeta, &
                & ds_dz_gw, ref_cor, grids_f%values(q), singularity, &
                & d_delta_df(:,q) )
            case ( 2 ) ! linear beta, mixing ratio dependence
              call get_d_delta_df_f ( inds_q, indices_c, gl_inds, &
                & all_inds_q, more_inds_q, eta_zxp(:,q), sps_path(:,sps_i), &
                & beta_path_c(:,sps_i), beta_path_f(:,sps_i), &
                & dbeta_df_c(:,i_dBeta_df_i), dbeta_df_f(:,i_dBeta_df_i), &
                & del_s, del_zeta, ds_dz_gw, ref_cor, singularity, &
                & d_delta_df(:,q) )
            case ( 3 ) ! log linear beta, mixing ratio dependence
              call get_d_delta_df_linlog_f ( inds_q, indices_c, gl_inds, &
                & all_inds_q, more_inds_q, eta_zxp(:,q), sps_path(:,sps_i), &
                & beta_path_c(:,sps_i), beta_path_f(:,sps_i), &
                & dbeta_df_c(:,i_dBeta_df_i), dbeta_df_f(:,i_dBeta_df_i), &
                & del_s, del_zeta, ds_dz_gw, ref_cor, grids_f%values(q), &
                & singularity, d_delta_df(:,q) )
            end select

d700 2
a701 4
            if ( n_inds_r == 0 ) then
              d2rad_df2(q,r) = 0.0
              cycle
            end if
d714 2
a715 27
            select case ( what_j )
            case ( 0 ) ! linear beta, no mixing ratio dependence
              call get_d_delta_dx ( inds_r, indices_c, gl_inds, &
                & all_inds_r, more_inds_r, eta_zxp(:,r), &
                & beta_path_c(:,sps_j), beta_path_f(:,sps_j), del_s, del_zeta, &
                & ds_dz_gw, singularity, d_delta_df(:,r), ref_cor )
            case ( 1 ) ! log linear beta, no mixing ratio dependence
              call get_d_delta_df_linlog ( inds_r, indices_c, gl_inds, &
                & all_inds_r, more_inds_r, eta_zxp(:,r), sps_path(:,sps_j), &
                & beta_path_c(:,sps_j), beta_path_f(:,sps_j), del_s, del_zeta, &
                & ds_dz_gw, ref_cor, grids_f%values(r), singularity, &
                & d_delta_df(:,r) )
            case ( 2 ) ! linear beta, mixing ratio dependence
              call Get_d_delta_df_f ( inds_r, Indices_c, gl_inds, &
                & All_inds_r, More_inds_r, eta_zxp(:,r), Sps_path(:,sps_j), &
                & Beta_path_c(:,sps_j), Beta_path_f(:,sps_j), &
                & dBeta_df_c(:,i_dBeta_df_j), dBeta_df_f(:,i_dBeta_df_j), &
                & Del_s, del_zeta, ds_dz_gw, ref_cor, Singularity, &
                & d_delta_df(:,r) )
            case ( 3 ) ! log linear beta, mixing ratio dependence
              call Get_d_delta_df_linlog_f ( inds_r, Indices_c, gl_inds, &
                & All_inds_r, More_inds_r, eta_zxp(:,r), Sps_path(:,sps_j), &
                & Beta_path_c(:,sps_j), Beta_path_f(:,sps_j), &
                & dBeta_df_c(:,i_dBeta_df_j), dBeta_df_f(:,i_dBeta_df_j), &
                & Del_s, del_zeta, ds_dz_gw, ref_cor, grids_f%values(r), &
                & Singularity, d_delta_df(:,r) )
            end select
d717 1
a717 1
            ! For molecules in logarithmic basis (what = 1 or 3), calculate d2_delta_df2:
d719 1
a719 1
            if ( (what_i == 1 .or. what_i == 3) .and. (what_j == 1 .or. what_j == 3) ) then
d723 1
a723 1
                ! For same specie, the following quantities should be the same for different sve:
d732 6
a737 9
                call get_d2_delta_df2_linlog ( diracDelta, inds_q, indices_c, gl_inds, &
                  & all_inds_q, more_inds_q, eta_zxp(:,q), eta_zxp(:,r), sps_path(:,sps_i), &
                  & beta_path_c(:,sps_i), beta_path_f(:,sps_i), del_s, del_zeta, &
                  & ds_dz_gw, ref_cor, grids_f%values(q), grids_f%values(r), singularity, &
                  & d2_delta_df2(:,q,r) )

              end if

            end if
d739 1
a739 1
            ! i_begin = max(i_start,min(inds(1),i_stop))
d741 1
a741 1
            i_begin = max(i_start,min(max(inds_q(1),inds_r(1)),i_stop))
d743 1
a743 3
            call d2scrt_dx2 ( tan_pt, d_delta_df(:,q), d_delta_df(:,r), &
                            &  d2_delta_df2(:,q,r), inc_rad_path, &
                            &  i_begin, i_stop, d2rad_df2(q,r) )
d745 1
a745 5
            ! Since d2_delta_df2 is not computed when either one of eta(q) or eta(r) is zero.
             !  d_delta_df(nz_d_delta_df(:nnz_d_delta_df(r),r), r)   <- compare with this
            ! d2_delta_df2(nz_d_delta_df(:nnz_d_delta_df(r),r), q, r) = 0.0
            ! d2_delta_df2(nz_d_delta_df(:nnz_d_delta_df(q),q), q, r) = 0.0
            d2_delta_df2(:,q,r) = 0.0
d747 1
a747 5
          end do ! sv_j = r

        end do ! sv_i = q

      end do ! sps_j
d749 1
a749 1
    end do ! sps_i
d751 1
a751 1
  end subroutine d2rad_tran_df2
d1422 2
a1423 2
    real(rp), intent(in) :: dAlpha_df_path_c(*) ! cross section on coarse grid.
    real(rp), intent(in) :: dAlpha_df_path_f(*) ! cross section on GL grid.
d1755 77
d2058 1
a2058 1
       "$Id: rad_tran_m.F90,v 2.24 2011/03/25 20:46:59 vsnyder Exp $"
d2068 4
@


2.24
log
@Delete declarations of unused objects
@
text
@d22 1
d469 1
d518 4
d534 1
d702 25
d731 2
a732 1
            call d2scrt_dx2 ( tan_pt, d_delta_df(:,q), d_delta_df(:,r), inc_rad_path, &
d735 6
d1753 75
d1836 5
d1924 3
d1979 1
a1979 1
       "$Id: rad_tran_m.F90,v 2.23 2011/03/24 00:17:34 vsnyder Exp $"
d1989 3
@


2.23
log
@Add TScat derivatives to dRad_tran_df
@
text
@d266 2
a267 2
                          & alpha_path_c, B, Beta_c_e,                        &
                          & dBeta_c_a_dIWC, dBeta_c_s_dIWC, TScat, dTScat_df, W0 )
a271 1
    use Molecules, only: L_Cloud_a
a311 1
    real(rp), intent(in), optional :: B(:)
a314 1
    real(rp), intent(in), optional :: TScat(:)
d387 2
a388 2
        call get_dB_df ( alpha_path_c, B, beta_c_e, dBeta_c_a_dIWC, &
                       & dBeta_c_s_dIWC, dAlpha_df_c(:,sps_i), TScat, w0, &
a1112 1
! This is the radiative transfer derivative wrt mixing ratio model
d1857 1
a1857 1
       "$Id: rad_tran_m.F90,v 2.22 2011/03/23 23:45:32 vsnyder Exp $"
d1867 3
@


2.22
log
@FOV_Convolve_m.f90
@
text
@a981 12
!       else if ( do_TScat ) then

!         call Get_dB_dT ( alpha_path_c, B, beta_c_e, dBeta_c_a_dIWC, &
!                        & dBeta_c_s_dIWC, TScat, dTScat_df(:,sv_i), w0, &
!                        & grids_f%qty(sv_i) == l_cloud_a, dB_df )
! 
!         call dt_script ( dB_df, eta_zxp(:,sv_i:sv_i), nz_zxp(:,sv_i:sv_i), &
!           & nnz_zxp(sv_i:sv_i), d_delta_B_df )
! 
!         call dscrt_dt ( tan_pt, d_delta_df(:,sv_i), tau, inc_rad_path,&
!                       & d_delta_B_df(:,1), i_begin, i_stop, drad_df(sv_i) )

d1861 1
a1861 1
       "$Id: rad_tran_m.F90,v 2.21 2011/03/11 03:09:08 vsnyder Exp $"
d1871 4
@


2.21
log
@Use Get_dAlpha_df
@
text
@d267 1
a267 1
                          & dBeta_c_e_dIWC, dBeta_c_s_dIWC, TScat, dTScat_df, W0 )
d315 2
a316 2
    real(rp), intent(in), optional :: dBeta_c_e_dIWC(:)
    real(rp), intent(in), optional :: dBeta_c_s_dIWC(:)
d318 2
a319 1
    real(rp), intent(in), optional :: dTScat_df(:,:) ! path X sv
d334 1
a334 1
    integer :: i_begin, sv_i
d349 1
a349 6
    do sv_i = 1, Grids_f%l_v(ubound(Grids_f%l_z,1))

      if ( nothing(sv_i) ) then
        drad_df(sv_i) = 0.0
        cycle
      end if
a350 28
      i_begin = max(i_start,min(nz_d_delta_df(1,sv_i),i_stop))

      !{ $I(s_m) = \mathcal{T}(s_0,s_m) \left( I(s_0)-B(s_0) \right) +
      !  B(s_m) - \int_{B(s_0)}^{B(s_m)} \mathcal{T}(s,s_m)
      !            \frac{\partial B(s)}{\partial s} \,\text{d} s$ with
      !  $\mathcal{T}(s,s_m) =
      !    \exp\left( -\int_s^{s_m} \alpha(\sigma) \,\text{d} \sigma \right)$,
      !  $\alpha(\sigma) = \sum_k \beta^k(\sigma) f^k_{lm} \eta^k_{lm}(\sigma)$,
      !  $s_0$ is the end of the path away from the instrument,
      !  $s_m$ is the location of the instrument, $\beta^k(\sigma)$ is the
      !  absorption coefficient for the $k^\text{th}$ species, and
      !  $\eta^k_{lm}(\sigma)$ is an interpolation coefficient from
      !  $(\phi^k_l,\zeta^k_m)$ to $\sigma$. $(\phi^k_l,\zeta^k_m)$ is
      !  specified by {\tt sv_i}.
      !  
      !  The integral is approximated by
      !  $\sum_{i=1}^{N_p} \mathcal{T}_i \Delta B_i$ where $\Delta B_i =
      !  \frac12 \left( B_{i+1} - B_{i-1} \right)$.  The end-point terms
      !  are incorporated into special values of $\Delta B_0$ and $\Delta B_{s_m}$.
      !
      !  {\tt inc_rad_path(i)} = $\mathcal{T}_i \Delta B_i$.
      !  $\frac{\partial \mathcal{T}}{\partial f^k_{lm}} =
      !  -\mathcal{T} \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}.$
      !  {\tt d_delta_df} =
      !  $ \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}
      !   \,\text{d} s =
      !   \int_s^{s_m} \beta^k(s) \eta^k_{lm}(s) \,\text{d} s \approx
      !   \sum_{j=i}^{s_m} \beta^k(s_j) \eta^k_{lm}(s_j) \Delta s_j$
d370 17
a386 18
  !   {\tt dB_df(i)} =
  !   $\frac{\partial \overline{\Delta B_i}}{\partial f^k_{lm}}
  !    \text{ where } \frac{\partial \overline{B_i}}
  !                        {\partial f^k_{lm}(\zeta_i)} =
  !    \frac{\partial \omega_{0_i}}{\partial f^k_{lm}(\zeta_i)}
  !     \left( T_{\text{scat}_i} - B_i \right) +
  !    \omega_{0_i} \frac{\partial T_{\text{scat}_i}}
  !                      {\partial f^k_{lm}(\zeta_i)}
  !   = \left(\frac{\partial \omega_{0_i}}{\partial f^k}
  !     \left( T_{\text{scat}_i} - B_i \right) +
  !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
  !     \right)
  !     \frac{\partial f^k}{\partial f^k_{lm}(\zeta_i)}
  !   = \left( \frac{\partial \omega_{0_i}}{\partial f^k}
  !      \left( T_{\text{scat}_i} - B_i \right) +
  !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
  !      \right) \eta^k_{lm}(\zeta_i)$ (see {\tt Get_dB_df} in the
  !     {\tt TScat_Support_m} module).
d390 14
a403 3
        call Get_dB_df ( alpha_path_c, B, beta_c_e, dBeta_c_e_dIWC, &
                       & dBeta_c_s_dIWC, TScat, dTScat_df(:,sv_i), w0, &
                       & grids_f%qty(sv_i) == l_cloud_a, dB_df )
d405 49
a453 2
        call dt_script ( dB_df, eta_zxp(:,sv_i:sv_i), nz_zxp(:,sv_i:sv_i), &
          & nnz_zxp(sv_i:sv_i), d_delta_B_df )
d455 1
a455 6
        call dscrt_dt ( tan_pt, d_delta_df(:,sv_i), tau, inc_rad_path,&
                      & d_delta_B_df(:,1), i_begin, i_stop, drad_df(sv_i) )
      else
        call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
                     &  i_begin, i_stop, drad_df(sv_i))
      end if
d457 1
a457 1
    end do ! sv_i
d984 1
a984 1
!         call Get_dB_dT ( alpha_path_c, B, beta_c_e, dBeta_c_e_dIWC, &
d1377 1
a1377 1
  ! .............................................  Get_d_delta_dx  .....
d1873 1
a1873 1
       "$Id: rad_tran_m.F90,v 2.20 2011/03/04 03:41:25 vsnyder Exp $"
d1883 3
@


2.20
log
@Remove declaration for unused variable
@
text
@d19 1
d23 1
a23 1
  private ::  Get_Do_Calc_Indexed, Get_Inds
d37 3
a39 3
                     &  alpha_path_c, ref_cor, incoptdepth, &
                     &  alpha_path_gl, ds_dz_gw, t_script, &
                     &  tau, inc_rad_path, rad, i_stop )
d260 8
a267 9
  subroutine DRad_tran_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,   & 
                          & beta_path_c, eta_zxp, sps_path, do_calc_f,      & 
                          & beta_path_f, do_gl, del_s, ref_cor,             & 
                          & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, & 
                          & i_start, tan_pt, i_stop, LD,                    & 
                          & d_delta_df, nz_d_delta_df, nnz_d_delta_df,      & 
                          & drad_df, dB_df, Tau, nz_zxp, nnz_zxp,           & 
                          & alpha_path_c, B, Beta_c_e, dBeta_c_e_dIWC,      &
                          & dBeta_c_s_dIWC, TScat, dTScat_df, W0 )
d278 1
a278 1
    integer, intent(in) :: Max_f            ! Leading dimension of Beta_Path_f
a284 2
    real(rp), intent(in) :: beta_path_c(:,:) ! cross section for each species
      !                                        on coarse grid.
a285 1
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
a288 2
    real(rp), intent(in) :: beta_path_f(max_f,*) ! cross section for each species
      !                                        on gl grid.
d298 2
a299 2
    real(rp), intent(in) :: dBeta_df_c(:,:)  ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(:,:)  ! In case beta depends on mixing ratio
d333 1
a333 7
    integer :: i_begin, n_inds, no_to_gl, sps_i, sv_i
    integer :: I_dBeta_df            ! Which column of dBeta_df_* to use if /= 0
    integer, target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer, target, dimension(1:size(inc_rad_path)) :: more_inds_B
    integer, pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                     ! Indices on GL grid for stuff
                                     ! used to make GL corrections
d335 1
a336 16
    integer, pointer :: inds(:)      ! inds => part_of_nz_d_delta_df;
                                     ! Indices on coarse path where do_calc.
    integer, pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                     ! Indices on the coarse path where GL
                                     ! corrections get applied.

    integer :: What ! 0 = linear beta, no mixing ratio dependence
                    ! 1 = log linear beta, no mixing ratio dependence
                    ! 2 = linear beta, mixing ratio dependence
                    ! 3 = log linear beta, mixing ratio dependence

    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.
    logical :: do_calc(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).
d340 5
a344 4
    ! d_delta_df is set to zero by the caller outside of all its loops.
    ! We keep track of where we create nonzeros, and replace them by zeros
    ! on the next call.  This is done because the vast majority of
    ! d_delta_df elements are zero.
d348 1
a348 1
    do sps_i = 1, ubound(Grids_f%l_z,1)
d350 4
a353 5
      i_dBeta_df = grids_f%where_dBeta_df(sps_i)
      what =     merge(1,0,grids_f%lin_log(sps_i)) + &
           & 2 * merge(1,0,i_dBeta_df/=0)

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
d355 1
a355 2
        d_delta_df(nz_d_delta_df(:nnz_d_delta_df(sv_i),sv_i),sv_i) = 0.0
        nnz_d_delta_df(sv_i) = 0
d357 65
a421 1
! Skip the masked derivatives, according to the l2cf inputs
d423 3
a425 4
        if ( .not. Grids_f%deriv_flags(sv_i) ) then
          drad_df(sv_i) = 0.0
          cycle
        end if
d427 2
a428 1
        ! find where the non zeros are along the path
d430 6
a435 2
        call get_do_calc_indexed ( size(do_gl), do_calc_f(:,sv_i), indices_c, &
          & gl_inds, do_gl, do_calc, n_inds, nz_d_delta_df(:,sv_i) )
d437 1
a437 130
        nnz_d_delta_df(sv_i) = n_inds
        if ( n_inds == 0 ) then
          drad_df(sv_i) = 0.0
          cycle
        end if

        inds => nz_d_delta_df(1:n_inds,sv_i)

        no_to_gl = count(do_gl(inds))

        all_inds => all_inds_B(1:no_to_gl)
        more_inds => more_inds_B(1:no_to_gl)

        ! see if anything needs to be gl-d
        if ( no_to_gl > 0 ) &
          & call get_inds ( do_gl, do_calc, more_inds, all_inds )

        select case ( what )
        case ( 0 ) ! linear beta, no mixing ratio dependence
          call get_d_delta_dx ( inds, indices_c, gl_inds, &
            & all_inds, more_inds, eta_zxp(:,sv_i), &
            & beta_path_c(:,sps_i), beta_path_f(:,sps_i), del_s, del_zeta, &
            & ds_dz_gw, singularity, d_delta_df(:,sv_i), ref_cor )
        case ( 1 ) ! log linear beta, no mixing ratio dependence
          call get_d_delta_df_linlog ( inds, indices_c, gl_inds, &
            & all_inds, more_inds, eta_zxp(:,sv_i), sps_path(:,sps_i), &
            & beta_path_c(:,sps_i), beta_path_f(:,sps_i), del_s, del_zeta, &
            & ds_dz_gw, ref_cor, grids_f%values(sv_i), singularity, &
            & d_delta_df(:,sv_i) )
        case ( 2 ) ! linear beta, mixing ratio dependence
          call Get_d_delta_df_f ( Inds, Indices_c, GL_Inds, &
            & All_inds, More_inds, eta_zxp(:,sv_i), Sps_path(:,sps_i), &
            & Beta_path_c(:,sps_i), Beta_path_f(:,sps_i), &
            & dBeta_df_c(:,i_dBeta_df), dBeta_df_f(:,i_dBeta_df), &
            & Del_s, del_zeta, ds_dz_gw, ref_cor, Singularity, &
            & d_delta_df(:,sv_i) )
        case ( 3 ) ! log linear beta, mixing ratio dependence
          call Get_d_delta_df_linlog_f ( Inds, Indices_c, GL_Inds, &
            & All_inds, More_inds, eta_zxp(:,sv_i), Sps_path(:,sps_i), &
            & Beta_path_c(:,sps_i), Beta_path_f(:,sps_i), &
            & dBeta_df_c(:,i_dBeta_df), dBeta_df_f(:,i_dBeta_df), &
            & Del_s, del_zeta, ds_dz_gw, ref_cor, grids_f%values(sv_i), &
            & Singularity, d_delta_df(:,sv_i) )
        end select

        i_begin = max(i_start,min(inds(1),i_stop))

        !{ $I(s_m) = \mathcal{T}(s_0,s_m) \left( I(s_0)-B(s_0) \right) +
        !  B(s_m) - \int_{B(s_0)}^{B(s_m)} \mathcal{T}(s,s_m)
        !            \frac{\partial B(s)}{\partial s} \,\text{d} s$ with
        !  $\mathcal{T}(s,s_m) =
        !    \exp\left( -\int_s^{s_m} \alpha(\sigma) \,\text{d} \sigma \right)$,
        !  $\alpha(\sigma) = \sum_k \beta^k(\sigma) f^k_{lm} \eta^k_{lm}(\sigma)$,
        !  $s_0$ is the end of the path away from the instrument,
        !  $s_m$ is the location of the instrument, $\beta^k(\sigma)$ is the
        !  absorption coefficient for the $k^\text{th}$ species, and
        !  $\eta^k_{lm}(\sigma)$ is an interpolation coefficient from
        !  $(\phi^k_l,\zeta^k_m)$ to $\sigma$. $(\phi^k_l,\zeta^k_m)$ is
        !  specified by {\tt sv_i}.
        !  
        !  The integral is approximated by
        !  $\sum_{i=1}^{N_p} \mathcal{T}_i \Delta B_i$ where $\Delta B_i =
        !  \frac12 \left( B_{i+1} - B_{i-1} \right)$.  The end-point terms
        !  are incorporated into special values of $\Delta B_0$ and $\Delta B_{s_m}$.
        !
        !  {\tt inc_rad_path(i)} = $\mathcal{T}_i \Delta B_i$.
        !  $\frac{\partial \mathcal{T}}{\partial f^k_{lm}} =
        !  -\mathcal{T} \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}.$
        !  {\tt d_delta_df} =
        !  $ \int_s^{s_m} \frac{\partial \alpha(s)}{\partial f^k_{lm}}
        !   \,\text{d} s =
        !   \int_s^{s_m} \beta^k(s) \eta^k_{lm}(s) \,\text{d} s \approx
        !   \sum_{j=i}^{s_m} \beta^k(s_j) \eta^k_{lm}(s_j) \Delta s_j$
        if ( Do_TScat ) then
          !{ $\frac{\partial I}{\partial f^\text{iwc}_{lm}} =
          !   \sum_{i=1}^{N_p}
          !   \frac{\partial \overline{\Delta B_i}}{\partial f^\text{iwc}_{lm}}
          !   \mathcal{T}_i + \overline{\Delta B_i}
          !   \frac{\partial \mathcal{T}_i}{\partial f^\text{iwc}_{lm}}$
          !   where $\overline{\Delta B} = \Delta B^g + \Delta B^s$,
          !   $\Delta B^g = \Delta \left[ ( 1-\omega_0 ) B \right]$,
          !   $\Delta B^s = \Delta \left[ \omega_0 T_\text{scat} \right]$
          ! and
          !   $\frac{\partial \mathcal{T}_i}{\partial f^k_{lm}} =
          !    -\mathcal{T}_i \int_{s_0}^{s_m}
          !      \frac{\partial \alpha(\sigma)}{\partial f^k_{lm}}
          !       \, \text{d} \sigma \approx
          !    -\mathcal{T}_i \sum_{j=i}^{N_p}
          !      \frac{\partial \delta^k_j}{\partial f^k_{lm}}
          !   = -\mathcal{T}_i \sum_{j=i}^{N_p} \beta^k_j
          !       \eta^k_{lm}(s_i) \Delta s_j$.
          !
    !   {\tt dB_df(i)} =
    !   $\frac{\partial \overline{\Delta B_i}}{\partial f^k_{lm}}
    !    \text{ where } \frac{\partial \overline{B_i}}
    !                        {\partial f^k_{lm}(\zeta_i)} =
    !    \frac{\partial \omega_{0_i}}{\partial f^k_{lm}(\zeta_i)}
    !     \left( T_{\text{scat}_i} - B_i \right) +
    !    \omega_{0_i} \frac{\partial T_{\text{scat}_i}}
    !                      {\partial f^k_{lm}(\zeta_i)}
    !   = \left(\frac{\partial \omega_{0_i}}{\partial f^k}
    !     \left( T_{\text{scat}_i} - B_i \right) +
    !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
    !     \right)
    !     \frac{\partial f^k}{\partial f^k_{lm}(\zeta_i)}
    !   = \left( \frac{\partial \omega_{0_i}}{\partial f^k}
    !      \left( T_{\text{scat}_i} - B_i \right) +
    !     \omega_{0_i} \frac{\partial T_{\text{scat}_i}}{\partial f^k}
    !      \right) \eta^k_{lm}(\zeta_i)$ (see {\tt Get_dB_df} in the
    !     {\tt TScat_Support_m} module).
          !
          ! {\tt inc_rad_path(i)} = $\mathcal{T}_i \overline{\Delta B}_i$

          call Get_dB_df ( alpha_path_c, B, beta_c_e, dBeta_c_e_dIWC, &
                         & dBeta_c_s_dIWC, TScat, dTScat_df(:,sv_i), w0, &
                         & grids_f%qty(sv_i) == l_cloud_a, dB_df )

          call dt_script ( dB_df, eta_zxp(:,sv_i:sv_i), nz_zxp(:,sv_i:sv_i), &
            & nnz_zxp(sv_i:sv_i), d_delta_B_df )

          call dscrt_dt ( tan_pt, d_delta_df(:,sv_i), tau, inc_rad_path,&
                        & d_delta_B_df(:,1), i_begin, i_stop, drad_df(sv_i) )
        else
          call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
                       &  i_begin, i_stop, drad_df(sv_i))
        end if

      end do ! sv_i

    end do ! sps_i
d1107 133
d1357 85
d1853 1
a1853 1
       "$Id: rad_tran_m.F90,v 2.19 2011/02/12 03:57:40 vsnyder Exp $"
d1863 3
@


2.19
log
@Add mixing-ratio dependence for H2O derivatives
@
text
@d1122 1
a1122 1
    integer :: i_start, n_inds, no_to_gl, sps_i, sps_m, sps_n, sv_i
d1723 1
a1723 1
       "$Id: rad_tran_m.F90,v 2.18 2011/02/05 01:18:06 vsnyder Exp $"
d1733 3
@


2.18
log
@Correct bugs where dBeta_df is used
@
text
@d263 1
a263 1
                          & i_dBeta_df, i_start, tan_pt, i_stop, LD,        & 
d303 2
a304 3
    real(rp), intent(in) :: dBeta_df_c(*)    ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)    ! In case beta depends on mixing ratio
    integer, intent(in) :: I_dBeta_df        ! If nonzero, which beta depends on mixing ratio
d339 1
d375 1
d377 1
a377 1
           & 2 * merge(1,0,sps_i == i_dBeta_df)
d429 1
a429 1
            & dBeta_df_c, dBeta_df_f, &
d436 1
a436 1
            & dBeta_df_c, dBeta_df_f, &
d536 1
a536 1
                            & i_dBeta_df, i_start, tan_pt, i_stop, LD,        &
d572 2
a573 3
    real(rp), intent(in) :: dBeta_df_c(*)    ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)    ! In case beta depends on mixing ratio
    integer, intent(in) :: I_dBeta_df        ! If nonzero, which beta depends on mixing ratio
d593 1
d636 1
d638 1
a638 1
             & 2 * merge(1,0,sps_i == i_dBeta_df)
d642 1
d644 1
a644 1
               & 2 * merge(1,0,sps_j == i_dBeta_df)
d703 1
a703 1
                & dbeta_df_c, dbeta_df_f, &
d710 1
a710 1
                & dbeta_df_c, dbeta_df_f, &
d754 1
a754 1
                & dBeta_df_c, dBeta_df_f, &
d761 1
a761 1
                & dBeta_df_c, dBeta_df_f, &
d1723 1
a1723 1
       "$Id: rad_tran_m.F90,v 2.17 2011/01/28 19:17:11 vsnyder Exp $"
d1733 3
@


2.17
log
@Lots of stuff for TScat derivatives
@
text
@d1274 7
a1280 3
    !{ Apply Gauss-Legendre quadrature to the panels indicated by
    !  {\tt more\_inds}.  We remove a singularity (which actually only
    !  occurs at the tangent point) by writing
d1282 3
a1284 3
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
    !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
d1286 7
a1292 7
    !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !   \text{d}\zeta$.  The first integral is easy -- it's just
    !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
    !  In the second integral, $G(\zeta)$ is {\tt dAlpha_dx_path\_f
    !  * eta\_zxp\_f * sps\_path} -- which have already been evaluated at
    !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.
    !  The weights  are {\tt gw}.
d1359 8
a1366 4

    !{ Apply Gauss-Legendre quadrature to the panels indicated by
    !  {\tt more\_inds}.  We remove a singularity (which actually only
    !  occurs at the tangent point) by writing
d1368 3
a1370 3
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
    !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
    !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
d1372 7
a1378 7
    !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
    !   \text{d}\zeta$.  The first integral is easy -- it's just
    !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
    !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
    !  sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
    !  are {\tt gw}.
d1388 1
a1388 1
             &      + dBeta_df_f(aa:aa+ng-1) ) &
d1447 9
a1455 3
    !{ Apply Gauss-Legendre quadrature to the panels indicated by
    !  {\tt more\_inds}.  We remove a singularity (which actually only
    !  occurs at the tangent point) by writing
d1467 2
a1468 1
    !  are {\tt gw}.
d1533 1
a1533 1
                & ( beta_path_c(ii) + dBeta_df_c(ii) )
d1537 10
a1546 3
    !{ Apply Gauss-Legendre quadrature to the panels indicated by
    !  {\tt more\_inds}.  We remove a singularity (which actually only
    !  occurs at the tangent point) by writing
d1555 4
a1558 4
    !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
    !  sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
    !  are {\tt gw}.
d1567 2
a1568 1
             &  * ( beta_path_f(aa:aa+ng-1) + dBeta_df_f(aa:aa+ng-1) ) &
d1720 1
a1720 1
       "$Id: rad_tran_m.F90,v 2.16 2010/12/07 01:20:57 vsnyder Exp $"
d1730 3
@


2.16
log
@dRad_tran_dx needs to call dscrt_dx
@
text
@d259 9
a267 7
  subroutine DRad_tran_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                          & beta_path_c, eta_zxp, sps_path, do_calc_f,      &
                          & beta_path_f, do_gl, del_s, ref_cor,             &
                          & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                          & i_dBeta_df, i_start, tan_pt, i_stop, LD,        &
                          & d_delta_df, nz_d_delta_df, nnz_d_delta_df,      &
                          & drad_df )
d269 1
d272 3
a274 1
    use SCRT_DN_M, ONLY: DSCRT_DX
d312 15
d345 2
d371 2
d442 79
a520 2
        call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
                     &  i_begin, i_stop, drad_df(sv_i))
d1046 13
d1061 2
a1062 2
        call dscrt_dt ( tan_pt, d_delta_dt(:,sv_i), tau, inc_rad_path, dt_scr_dt(:,sv_i), &
                      & i_begin, i_stop, drad_dt(sv_i) )
d1697 1
a1697 1
       "$Id: rad_tran_m.F90,v 2.15 2010/11/05 20:28:13 vsnyder Exp $"
d1707 3
@


2.15
log
@Delete unused declarations
@
text
@d967 1
d1069 3
d1583 1
a1583 1
       "$Id: rad_tran_m.F90,v 2.14 2010/08/27 23:17:11 vsnyder Exp $"
d1593 3
@


2.14
log
@Remove '(ip)' from all integer declarations
@
text
@a266 1
    use GLNP, only: NG
a318 1
    integer :: AA, GA, I, II, III
a438 1
    use GLNP, only: NG
a490 1
    integer :: AA, GA, I, II, III
d759 1
a759 1
    integer :: A, AA, B, GA
a964 1
    use GLNP, only: NG
a966 1
    use SCRT_DN_M, ONLY: DSCRT_DX
a1003 1
    integer :: AA, GA, I, II, III
d1579 1
a1579 1
       "$Id: rad_tran_m.F90,v 2.13 2010/08/27 05:51:03 yanovsky Exp $"
d1589 3
@


2.13
log
@Changed types of indices_c and gl_inds dummy arguments from integer(ip) to integer.
@
text
@d41 1
a41 1
    use MLSKinds, only: RP, IP
d47 2
a48 2
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
d72 1
a72 1
    integer(ip), intent(out) :: i_stop       ! path stop index
d133 1
a133 1
    use MLSKinds, only: RP, IP
d139 2
a140 2
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
d171 1
a171 1
    integer(ip), intent(out) :: p_stop       ! path stop index if >= 0, else
d179 1
a179 1
    integer(ip) :: N_PATH
d269 1
a269 1
    use MLSKinds, only: RP, IP
d275 2
a276 2
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
d320 12
a331 12
    integer(ip) :: AA, GA, I, II, III
    integer(ip) :: i_begin, n_inds, no_to_gl, sps_i, sv_i
    integer(ip), target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_nz_d_delta_df;
                                         ! Indices on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.
d443 1
a443 1
    use MLSKinds, only: RP, IP
d448 4
a451 4
    integer, intent(in) :: Max_f            ! Leading dimension of Beta_Path_f
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
d494 17
a510 17
    integer(ip) :: AA, GA, I, II, III
    integer(ip) :: i_begin
    integer(ip) :: n_inds_q, n_inds_r
    integer(ip) :: no_to_gl_q, no_to_gl_r
    integer(ip) :: sps_i, sps_j          ! species indices
    integer(ip) :: sps_n
    integer(ip) :: q, r                 ! state vector indices: sv_i, sv_j
    integer(ip), target, dimension(1:size(inc_rad_path)) ::  all_inds_B_q,  all_inds_B_r
    integer(ip), target, dimension(1:size(inc_rad_path)) :: more_inds_B_q, more_inds_B_r
    integer(ip), pointer :: all_inds_q(:), all_inds_r(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds_q(:), inds_r(:)      ! inds => part_of_nz_d_delta_df;
                                         ! Indices on coarse path where do_calc.
    integer(ip), pointer :: more_inds_q(:), more_inds_r(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.
d513 1
a513 1
                                         ! grid panel -- singular at tangent pt.
d515 2
a516 2
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).
d518 2
a519 2
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).
d698 1
a698 1
    use MLSKinds, only: RP, IP
d763 12
a774 12
    integer(ip) :: A, AA, B, GA
    integer(ip) :: i, i_begin, n_inds, n_path, no_to_gl, p_i, sv_i
    integer(ip), target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.
d971 1
a971 1
    use MLSKinds, only: RP, IP
d976 2
a977 2
    integer(ip), intent(in) :: indices_c(:)  ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d1002 1
a1002 1
    integer(ip), intent(in) :: i_stop        ! path stop index
d1010 12
a1021 12
    integer(ip) :: AA, GA, I, II, III
    integer(ip) :: i_start, n_inds, no_to_gl, sps_i, sps_m, sps_n, sv_i
    integer(ip), target, dimension(1:size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.
d1128 1
a1128 1
    use MLSKinds, only: RP, IP
d1130 8
a1137 8
    integer(ip), intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer(ip), intent(in) :: Indices_c(:)  ! Subset from gl to coarse
    integer(ip), intent(in) :: GL_Inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: All_inds(:)   ! Indices on GL grid for stuff
                                             ! used to make GL corrections
    integer(ip), intent(in) :: More_inds(:)  ! Indices on the coarse path where
                                             ! GL corrections get applied.
    real(rp), intent(in) :: eta_zxp(*)       ! representation basis function.
d1140 2
a1141 2
    real(rp), intent(in) :: Del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)      ! path -log(P) differences on the
d1144 1
a1144 1
    real(rp), intent(in) :: ds_dz_gw(:)     ! ds/dh * dh/dz * GL weights
d1153 1
a1153 1
                                            !  path length ratios.
d1204 1
a1204 1
    use MLSKinds, only: RP, IP
d1206 9
a1214 9
    integer(ip), intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer(ip), intent(in) :: Indices_c(:) ! Subset from gl to coarse
    integer(ip), intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                            ! used to make GL corrections
    integer(ip), intent(in) :: More_inds(:) ! Indices on the coarse path where
                                            ! GL corrections get applied.
    real(rp), intent(in) :: Eta_zxp(*)      ! representation basis function.
    real(rp), intent(in) :: Sps_path(:)     ! Path mixing ratios
d1219 2
a1220 2
    real(rp), intent(in) :: Del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)     ! path -log(P) differences on the
d1289 1
a1289 1
    use MLSKinds, only: RP, IP
d1291 9
a1299 9
    integer(ip), intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer(ip), intent(in) :: Indices_c(:) ! Subset from gl to coarse
    integer(ip), intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                            ! used to make GL corrections
    integer(ip), intent(in) :: More_inds(:) ! Indices on the coarse path where
                                            ! GL corrections get applied.
    real(rp), intent(in) :: Eta_zxp(*)      ! representation basis function.
    real(rp), intent(in) :: Sps_path(:)     ! exp(Path mixing ratios)
d1302 2
a1303 2
    real(rp), intent(in) :: Del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)     ! path -log(P) differences on the
d1306 4
a1309 4
    real(rp), intent(in) :: ds_dz_gw(:)     ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
                                            !  length ratios.
    real(rp), intent(in) :: Grids_v         ! Grids_f%values(sv_i)
d1370 1
a1370 1
    use MLSKinds, only: RP, IP
d1372 9
a1380 9
    integer(ip), intent(in) :: Inds(:) ! Indices on coarse path needing calc
    integer(ip), intent(in) :: Indices_c(:) ! Subset from gl to coarse
    integer(ip), intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                            ! used to make GL corrections
    integer(ip), intent(in) :: More_inds(:) ! Indices on the coarse path where
                                            ! GL corrections get applied.
    real(rp), intent(in) :: Eta_zxp(*)      ! representation basis function.
    real(rp), intent(in) :: Sps_path(:)     ! exp(Path mixing ratios)
d1385 2
a1386 2
    real(rp), intent(in) :: Del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)     ! path -log(P) differences on the
d1389 4
a1392 4
    real(rp), intent(in) :: ds_dz_gw(:)     ! ds/dh * dh/dz * GL weights
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
                                            !  length ratios.
    real(rp), intent(in) :: Grids_v         ! Grids_f%values(sv_i)
a1452 1
    use MLSKinds, only: IP
d1459 2
a1460 2
    integer(ip), intent(in) :: C_Inds(*)  ! Indices in Do_Calc_All for coarse grid
    integer(ip), intent(in) :: F_Inds(*)  ! Indices in Do_Calc_All for find grid
d1468 2
a1469 2
    integer(ip), intent(in) :: C_Inds(:)  ! Indices in Do_Calc_All for coarse grid
    integer(ip), intent(in) :: F_Inds(:)  ! Indices in Do_Calc_All for find grid
d1477 2
a1478 2
    integer(ip), intent(in) :: C_Inds(:)  ! Indices in Do_Calc_All for coarse grid
    integer(ip), intent(in) :: F_Inds(:)  ! Indices in Do_Calc_All for fine grid
a1534 1
    use MLSKinds, only: IP
d1544 2
a1545 2
    integer(ip), intent(out) :: More_Inds(:)
    integer(ip), intent(out) :: All_Inds(:)
d1586 1
a1586 1
       "$Id: rad_tran_m.F90,v 2.12 2010/08/19 02:04:03 vsnyder Exp $"
d1596 3
@


2.12
log
@Change some variable names, restructure dRad_tran_dT
@
text
@d703 2
a704 2
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
d1588 1
a1588 1
       "$Id: rad_tran_m.F90,v 2.11 2010/06/12 01:27:59 vsnyder Exp $"
d1598 3
d1608 7
@


2.11
log
@Use get_d_delta_df_linlog in drad_tran_dx because it does the right
calculation if it's given dbeta_df instead of beta.
@
text
@d19 2
a20 2
  public :: Get_d_delta_df, Get_d_delta_df_linlog, Get_d_delta_df_f
  public :: Get_d_delta_df_linlog_f
d260 1
a260 1
                          & beta_path_c, eta_zxp_f, sps_path, do_calc_f,    &
d283 1
a283 1
    real(rp), intent(in) :: eta_zxp_f(max_f,*)   ! representation basis function.
d392 2
a393 2
          call get_d_delta_df ( inds, indices_c, gl_inds, &
            & all_inds, more_inds, eta_zxp_f(:,sv_i), sps_path(:,sps_i), &
d395 1
a395 1
            & ds_dz_gw, ref_cor, singularity, d_delta_df(:,sv_i) )
d398 1
a398 1
            & all_inds, more_inds, eta_zxp_f(:,sv_i), sps_path(:,sps_i), &
d404 1
a404 1
            & All_inds, More_inds, Eta_zxp_f(:,sv_i), Sps_path(:,sps_i), &
d411 1
a411 1
            & All_inds, More_inds, Eta_zxp_f(:,sv_i), Sps_path(:,sps_i), &
d432 2
a433 2
  subroutine d2Rad_tran_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f, &
                            & beta_path_c, eta_zxp_f, sps_path, do_calc_f,    &
d457 1
a457 1
    real(rp), intent(in) :: eta_zxp_f(max_f,*)   ! representation basis function.
d589 2
a590 2
              call get_d_delta_df ( inds_q, indices_c, gl_inds, &
                & all_inds_q, more_inds_q, eta_zxp_f(:,q), sps_path(:,sps_i), &
d592 1
a592 1
                & ds_dz_gw, ref_cor, singularity, d_delta_df(:,q) )
d595 1
a595 1
                & all_inds_q, more_inds_q, eta_zxp_f(:,q), sps_path(:,sps_i), &
d601 1
a601 1
                & all_inds_q, more_inds_q, eta_zxp_f(:,q), sps_path(:,sps_i), &
d608 1
a608 1
                & all_inds_q, more_inds_q, eta_zxp_f(:,q), sps_path(:,sps_i), &
d640 2
a641 2
              call get_d_delta_df ( inds_r, indices_c, gl_inds, &
                & all_inds_r, more_inds_r, eta_zxp_f(:,r), sps_path(:,sps_j), &
d643 1
a643 1
                & ds_dz_gw, ref_cor, singularity, d_delta_df(:,r) )
d646 1
a646 1
                & all_inds_r, more_inds_r, eta_zxp_f(:,r), sps_path(:,sps_j), &
d652 1
a652 1
                & All_inds_r, More_inds_r, Eta_zxp_f(:,r), Sps_path(:,sps_j), &
d659 1
a659 1
                & All_inds_r, More_inds_r, Eta_zxp_f(:,r), Sps_path(:,sps_j), &
d686 3
a688 3
  subroutine DRad_tran_dt ( del_zeta, h_path_c, dh_dt_path_c, &
                         &  alpha_path_c, dAlpha_dT_path_c, &
                         &  eta_zxp_c, do_calc_t_c, &
d690 1
a690 1
                         &  do_gl, gl_inds, h_path_f, t_path_f, dh_dt_path_f, &
d692 1
a692 1
                         &  eta_zxp_f, do_calc_t_f, &
d703 2
d714 2
a715 2
    real(rp), intent(in) :: eta_zxp_c(:,:)  ! representation basis function
!                                              main grid.
a727 1
    integer, intent(in) :: GL_Inds(:)       ! Where is do_gl true?
a733 2
    real(rp), intent(in) :: eta_zxp_f(:,:)  ! representation basis function
!                                             gl grid.
d764 1
a764 1
    integer(ip) :: i, ii, i_begin, n_inds, n_path, no_to_gl, p_i, sv_i
d776 1
a776 1
    real(rp) :: d_delta_dt(size(eta_zxp_c,1),size(eta_zxp_c,2)) ! path x sve.
d796 1
a796 1
    do sv_i = 1 , size(eta_zxp_c,dim=2)
d808 1
d811 1
a811 1
        i_begin = max(inds(1)-1, i_start)
d813 2
a814 5
        do i = 1, n_inds ! Don't trust the compiler to fuse loops
          ii = inds(i)
          singularity(ii) = dAlpha_dT_path_c(ii) * eta_zxp_c(ii,sv_i)
          d_delta_dt(ii,sv_i) = singularity(ii) * del_s(ii)
        end do ! i
d816 3
a818 4
! see if anything needs to be gl-d

        no_to_gl = count(do_gl(inds))
        if ( no_to_gl > 0 ) then
d820 4
a823 2
          all_inds => all_inds_B(1:no_to_gl)
          more_inds => more_inds_B(1:no_to_gl)
d825 1
a825 29
          call get_inds ( do_gl, do_calc, more_inds, all_inds )

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_dt}.
      !  In the second integral, $G(\zeta)$ is {\tt alphaxn\_path\_f *
      !  eta\_zxp\_f / t\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

          do i = 1, no_to_gl
            aa = all_inds(i)
            ga = gl_inds(aa)
            ii = more_inds(i)
            d_delta_dt(ii,sv_i) = d_delta_dt(ii,sv_i) + &
              & del_zeta(ii) * &
              & sum( (dAlpha_dT_path_f(aa:aa+ng-1) * eta_zxp_f(aa:aa+ng-1,sv_i) - &
                   &  singularity(ii)) * &
                   & ds_dz_gw(ga:ga+ng-1) )
          end do
        end if ! no_to_gl > 0
d917 1
d927 2
a928 2
              &  + eta_zxp_f(a:b-1,sv_i) * ds_dh(gl_inds(a:b-1)) /   &     
              &  t_path_f(a:b-1)) * dh_dz_gw(gl_inds(a:b-1)) )
d1118 5
a1122 5
  ! .............................................  Get_d_delta_df  .....
  subroutine Get_d_delta_df ( Inds, Indices_c, GL_Inds, &
    & All_inds, More_inds, Eta_zxp_f, Sps_path, &
    & Beta_path_c, Beta_path_f, Del_s, Del_Zeta, ds_dz_gw, Ref_cor, &
    & Singularity, d_delta_df )
d1124 2
a1125 2
    ! Get d_delta_df for species for which beta does not depend upon
    ! mixing ratio.
d1131 11
a1141 12
    integer(ip), intent(in) :: Indices_c(:) ! Subset from gl to coarse
    integer(ip), intent(in) :: GL_Inds(:)   ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: All_inds(:)  ! Indices on GL grid for stuff
                                            ! used to make GL corrections
    integer(ip), intent(in) :: More_inds(:) ! Indices on the coarse path where
                                            ! GL corrections get applied.
    real(rp), intent(in) :: Eta_zxp_f(*)    ! representation basis function.
    real(rp), intent(in) :: Sps_path(:)     ! Path mixing ratios
    real(rp), intent(in) :: Beta_path_c(*)  ! cross section on coarse grid.
    real(rp), intent(in) :: Beta_path_f(*)  ! cross section on GL grid.
    real(rp), intent(in) :: Del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: Del_zeta(:)     ! path -log(P) differences on the
a1144 2
    real(rp), intent(in) :: Ref_cor(:)      ! refracted to unrefracted path
                                            !  length ratios.
d1149 2
a1150 2
    real(rp), intent(inout) :: d_delta_df(:) ! Derivative of delta w.r.t.
                               ! Sps_Path.  intent(inout) so the unreferenced
d1152 2
d1159 2
a1160 3
      singularity(ii) = eta_zxp_f(indices_c(ii)) &
                & * beta_path_c(ii)
      d_delta_df(ii) = singularity(ii) * del_s(ii)
d1174 4
a1177 4
    !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
    !  sps\_path} -- which have already been evaluated at the appropriate
    !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
    !  are {\tt gw}.
d1183 1
a1183 1
      d_delta_df(ii) = d_delta_df(ii) + &
d1185 1
a1185 1
        & sum( (eta_zxp_f(ga:ga+ng-1) * beta_path_f(aa:aa+ng-1) - &
d1190 1
a1190 1
    d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)
d1192 1
a1192 1
  end subroutine Get_d_delta_df
d1196 1
a1196 1
    & All_inds, More_inds, Eta_zxp_f, Sps_path, &
d1213 1
a1213 1
    real(rp), intent(in) :: Eta_zxp_f(*)    ! representation basis function.
d1239 1
a1239 1
      singularity(ii) = eta_zxp_f(iii) &
d1267 1
a1267 1
        & sum( (eta_zxp_f(ga:ga+ng-1) &
d1281 1
a1281 1
    & All_inds, More_inds, Eta_zxp_f, Sps_path, &
d1298 1
a1298 1
    real(rp), intent(in) :: Eta_zxp_f(*)    ! representation basis function.
d1323 1
a1323 1
      singularity(ii) = eta_zxp_f(iii) * sps_path(iii) * &
d1350 1
a1350 1
        & sum( (eta_zxp_f(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
d1362 1
a1362 1
    & All_inds, More_inds, Eta_zxp_f, Sps_path, &
d1379 1
a1379 1
    real(rp), intent(in) :: Eta_zxp_f(*)    ! representation basis function.
d1406 1
a1406 1
      singularity(ii) = eta_zxp_f(iii) * sps_path(iii) * &
d1433 1
a1433 1
        & sum( (eta_zxp_f(ga:ga+ng-1) * sps_path(ga:ga+ng-1) &
d1588 1
a1588 1
       "$Id: rad_tran_m.F90,v 2.10 2010/06/11 02:20:46 vsnyder Exp $"
d1598 4
@


2.10
log
@Integrated Igor's latest changes with mine
@
text
@a1070 2
        d_delta_dx = 0.0_rp

d1076 1
a1076 1
        if ( n_inds > 0 ) then
d1078 4
a1081 1
          inds => inds_B(1:n_inds)
a1082 7
          do i = 1, n_inds ! Don't trust the compiler to fuse loops
            ii = inds(i)
            iii = indices_c(ii)
            singularity(ii) = dbeta_path_c(ii,sps_i) &
                            &  * eta_zxp(iii,sv_i) * sps_path(iii,sps_m)
            d_delta_dx(ii) = singularity(ii) * del_s(ii)
          end do ! i
d1084 1
a1084 2
          no_to_gl = count(do_gl(inds))
          if ( no_to_gl > 0 ) then
d1086 1
a1086 1
! see if anything needs to be gl-d
d1088 2
a1089 2
            all_inds => all_inds_B(1:no_to_gl)
            more_inds => more_inds_B(1:no_to_gl)
d1091 3
a1093 1
            call get_inds ( do_gl, do_calc, more_inds, all_inds )
d1095 8
a1102 40
      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_dx}.
      !  In the second integral, $G(\zeta)$ is {\tt dbeta\_path\_f *
      !  eta\_zxp\_f\_f * sps\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

            do i = 1, no_to_gl
              aa = all_inds(i)
              ga = gl_inds(aa)
              ii = more_inds(i)
              d_delta_dx(ii) = d_delta_dx(ii) + &
                & del_zeta(ii) * &
                & sum( (dbeta_path_f(aa:aa+ng-1,sps_i) &
                     &   * eta_zxp(ga:ga+ng-1,sv_i) * sps_path(ga:ga+ng-1,sps_m) - &
                     &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
            end do

          end if

          ! Refraction correction
          d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)

          i_start = min(inds(1),i_stop)

          call dscrt_dx ( tan_pt, d_delta_dx, inc_rad_path, i_start, i_stop, &
                       &  drad_dx(sv_i) )

        else
          drad_dx(sv_i) = 0.0
        end if
d1619 1
a1619 1
       "$Id: rad_tran_m.F90,v 2.7 2010/05/14 02:41:08 vsnyder Exp $"
d1629 3
@


2.9
log
@Removed code implementing d_delta_df computations from drad_tran_df. Drad_tran_df now calls get_d_delta_df
@
text
@d19 2
d321 1
a321 1
    integer(ip) :: i_begin, n_inds, no_to_gl, npc, sps_i, sps_n, sv_i
d333 6
a338 1
     real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
d340 1
a340 1
     logical :: do_calc(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
d351 1
a351 1
    npc = size(indices_c)
d353 2
a354 3
    sps_n = ubound(Grids_f%l_z,1)

    do sps_i = 1, sps_n
d368 1
a368 1
! find where the non zeros are along the path
d374 240
a613 1
        if ( n_inds > 0 ) then
d615 5
a619 1
          inds => nz_d_delta_df(1:n_inds,sv_i)
d621 5
a625 1
          no_to_gl = count(do_gl(inds))
d627 1
a627 1
          if ( no_to_gl > 0 ) then
d629 1
a629 1
! see if anything needs to be gl-d
d631 2
a632 2
            all_inds => all_inds_B(1:no_to_gl)
            more_inds => more_inds_B(1:no_to_gl)
d634 33
a666 2
            call get_inds ( do_gl, do_calc, more_inds, all_inds )
          end if
d668 1
a668 6
          call get_d_delta_df( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                             & beta_path_c, eta_zxp_f, sps_path,               &
                             & beta_path_f, del_s, ref_cor,                    &
                             & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                             & i_dBeta_df, LD, sv_i,                           &
                             & d_delta_df(:,sv_i) )
d670 2
a671 1
          i_begin = max(i_start,min(inds(1),i_stop))
d673 1
a673 2
          call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
                       &  i_begin, i_stop, drad_df(sv_i))
d675 1
a675 3
        else
          drad_df(sv_i) = 0.0
        end if
d677 1
a677 1
      end do ! sv_i
d681 1
a681 1
  end subroutine drad_tran_df
a1146 413

!--------------------------------------------------  D2Rad_tran_df2  -----
! This is the radiative transfer second derivative wrt mixing ratio model

  subroutine d2Rad_tran_df2 ( max_f, indices_c, gl_inds, del_zeta, Grids_f, &
                            & beta_path_c, eta_zxp_f, sps_path, do_calc_f,    &
                            & beta_path_f, do_gl, del_s, ref_cor,             &
                            & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                            & i_dBeta_df, i_start, tan_pt, i_stop, LD,        &
                            & d_delta_df,                                     &
			    & nz_d_delta_df, nnz_d_delta_df,                  &
                            & d2rad_df2 )

    use GLNP, only: NG
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP, IP
    use SCRT_DN_M, ONLY: D2SCRT_DX2

! Inputs

    integer, intent(in) :: Max_f            ! Leading dimension of Beta_Path_f
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: beta_path_c(:,:) ! cross section for each species
      !                                        on coarse grid.
    real(rp), intent(in) :: eta_zxp_f(max_f,*)   ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero.
    real(rp), intent(in) :: beta_path_f(max_f,*) ! cross section for each species
      !                                        on gl grid.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(in) :: dBeta_df_c(*)    ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)    ! In case beta depends on mixing ratio
    integer, intent(in) :: I_dBeta_df        ! If nonzero, which beta depends on mixing ratio
    integer, intent(in) :: I_start           ! path_start_index + 1
    integer, intent(in) :: tan_pt            ! Tangent point index in Del_Zeta
    integer, intent(in) :: I_stop            ! path stop index

    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF

! Outputs

    real(rp), intent(inout) :: d_delta_df(ld,*) ! path x sve.  derivative of
      !              delta wrt mixing ratio state vector element. (K)
      !              Initially set to zero by caller.
    integer, intent(inout), target :: nz_d_delta_df(:,:)  ! Nonzeros in d_delta_df
    integer, intent(inout) :: nnz_d_delta_df(:)           ! Column lengths in nz_delta_df
    real(rp), intent(out) :: d2rad_df2(:,:)    ! second derivative of radiances wrt
	                                       ! mixing ratio state vector element. (K)

! Internals

    integer(ip) :: AA, GA, I, II, III
    integer(ip) :: i_begin
    integer(ip) :: n_inds_q, n_inds_r
    integer(ip) :: no_to_gl_q, no_to_gl_r
    integer(ip) :: npc
    integer(ip) :: sps_i, sps_j          ! species indices
    integer(ip) :: sps_n
    integer(ip) :: q, r                 ! state vector indices: sv_i, sv_j
    integer(ip), target, dimension(1:size(inc_rad_path)) ::  all_inds_B_q,  all_inds_B_r
    integer(ip), target, dimension(1:size(inc_rad_path)) :: more_inds_B_q, more_inds_B_r
    integer(ip), pointer :: all_inds_q(:), all_inds_r(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds_q(:), inds_r(:)      ! inds => part_of_nz_d_delta_df;
                                         ! Indices on coarse path where do_calc.
    integer(ip), pointer :: more_inds_q(:), more_inds_r(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.
    logical :: do_calc_q(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).
    logical :: do_calc_r(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).

! Begin code

    ! d_delta_df is set to zero by the caller outside of all its loops.
    ! We keep track of where we create nonzeros, and replace them by zeros
    ! on the next call.  This is done because the vast majority of
    ! d_delta_df elements are zero.

    npc = size(indices_c)

    sps_n = ubound(Grids_f%l_z,1)

    do sps_i = 1, sps_n
      do sps_j = 1, sps_n

        do q = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
	  do r = Grids_f%l_v(sps_j-1)+1, Grids_f%l_v(sps_j)
            
            d_delta_df(nz_d_delta_df(:nnz_d_delta_df(q),q),q) = 0.0
	    nnz_d_delta_df(q) = 0
			
	    d_delta_df(nz_d_delta_df(:nnz_d_delta_df(r),r),r) = 0.0
            nnz_d_delta_df(r) = 0
            	
            !
            ! Skip the masked derivatives, according to the l2cf inputs
            !
            if ( ( .not. Grids_f%deriv_flags(q) ) .or. ( .not. Grids_f%deriv_flags(r) ) ) then
              d2rad_df2(q,r) = 0.0
              cycle
            end if
            	  
            !
            ! find where the non zeros are along the path (for q)
            !
            call get_do_calc_indexed ( size(do_gl), do_calc_f(:,q), indices_c, &
              & gl_inds, do_gl, do_calc_q, n_inds_q, nz_d_delta_df(:,q) )
            
            nnz_d_delta_df(q) = n_inds_q
            if ( n_inds_q > 0 ) then
            
              inds_q => nz_d_delta_df(1:n_inds_q,q)					  		  
              
              no_to_gl_q = count(do_gl(inds_q))			
              
              if ( no_to_gl_q > 0 ) then
              
              ! see if anything needs to be gl-d (for q)
              
                 all_inds_q =>  all_inds_B_q(1:no_to_gl_q)
                more_inds_q => more_inds_B_q(1:no_to_gl_q)
                
                call get_inds ( do_gl, do_calc_q, more_inds_q, all_inds_q )
              end if
              
              call get_d_delta_df( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                                 & beta_path_c, eta_zxp_f, sps_path,               &
                                 & beta_path_f, del_s, ref_cor,                    &
                                 & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                                 & i_dBeta_df, LD, q,                              &
                                 & d_delta_df(:,q) )
              
              !
              ! find where the non zeros are along the path (for r)
              !
              call get_do_calc_indexed ( size(do_gl), do_calc_f(:,r), indices_c, &
                & gl_inds, do_gl, do_calc_r, n_inds_r, nz_d_delta_df(:,r) )
              
              nnz_d_delta_df(r) = n_inds_r
              if ( n_inds_r > 0 ) then
              
                inds_r => nz_d_delta_df(1:n_inds_r,r)
                
                no_to_gl_r = count(do_gl(inds_r))
                		
                if ( no_to_gl_r > 0 ) then
                
                ! see if anything needs to be gl-d (for r)
                
                   all_inds_r =>  all_inds_B_r(1:no_to_gl_r)
                  more_inds_r => more_inds_B_r(1:no_to_gl_r)
                  
                  call get_inds ( do_gl, do_calc_r, more_inds_r, all_inds_r )
                end if
                
                call get_d_delta_df( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                                   & beta_path_c, eta_zxp_f, sps_path,               &
                                   & beta_path_f, del_s, ref_cor,                    &
                                   & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                                   & i_dBeta_df, LD, r,                              &
                                   & d_delta_df(:,r) )
                
                ! i_begin = max(i_start,min(inds(1),i_stop))
                
                i_begin = max(i_start,min(max(inds_q(1),inds_r(1)),i_stop))
                
                call d2scrt_dx2 ( tan_pt, d_delta_df(:,q), d_delta_df(:,r), inc_rad_path, &
                                &  i_begin, i_stop, d2rad_df2(q,r) )
              
              else
                d2rad_df2(q,r) = 0.0
              end if  ! if/else ( n_inds_r > 0 )
            	  
            else
              d2rad_df2(q,:) = 0.0
            end if  ! if/else ( n_inds_q > 0 )
	    
          end do ! sv_j

        end do ! sv_i

      end do ! sps_j

    end do ! sps_i

  end subroutine d2rad_tran_df2


  !--------------------------------------------------  get_d_delta_df  -----
  
  
  subroutine get_d_delta_df( max_f, indices_c, gl_inds, del_zeta, Grids_f,   &
                           & beta_path_c, eta_zxp_f, sps_path,               &
                           & beta_path_f, del_s, ref_cor,                    &
                           & ds_dz_gw, inc_rad_path, dBeta_df_c, dBeta_df_f, &
                           & i_dBeta_df, LD, q,                              &
                           & d_delta_df )
    
    use GLNP, only: NG
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP, IP
    
! Inputs
    
    integer, intent(in) :: Max_f            ! Leading dimension of Beta_Path_f
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indices
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: beta_path_c(:,:) ! cross section for each species
      !                                        on coarse grid.
    real(rp), intent(in) :: eta_zxp_f(max_f,*)   ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
    real(rp), intent(in) :: beta_path_f(max_f,*) ! cross section for each species
      !                                        on gl grid.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(in) :: dBeta_df_c(*)    ! In case beta depends on mixing ratio
    real(rp), intent(in) :: dBeta_df_f(*)    ! In case beta depends on mixing ratio
    integer, intent(in) :: I_dBeta_df        ! If nonzero, which beta depends on mixing ratio
    
    integer, intent(in) :: LD                ! Leading dimension of D_Delta_dF
    
    integer, intent(in) :: q				 ! state vector element (sv_i)

    ! Outputs
    
    real(rp), intent(inout) :: d_delta_df(ld) ! ld is path.  derivative of
      !              delta wrt mixing ratio state vector element.
    
! Internals

    integer(ip) :: AA, GA, I, II, III
    integer(ip) :: n_inds, no_to_gl, sps_i
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_nz_d_delta_df;
                                         ! Indices on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

! Begin code


                if ( grids_f%lin_log(sps_i) ) then
                ! sps_path is actually exp(mixing ratio) here

                  if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
                    do i = 1, n_inds ! Don't trust the compiler to fuse loops
                      ii = inds(i)
                      iii = indices_c(ii)
                      singularity(ii) = eta_zxp_f(iii,q) * sps_path(iii,sps_i) * &
                                & beta_path_c(ii,sps_i)
                      d_delta_df(ii) = singularity(ii) * del_s(ii)
                    end do ! i
                  else ! beta is a function of mixing ratio
                    do i = 1, n_inds ! Don't trust the compiler to fuse loops
                      ii = inds(i)
                      iii = indices_c(ii)
                      singularity(ii) = eta_zxp_f(iii,q) * sps_path(iii,sps_i) * &
                                & ( beta_path_c(ii,sps_i) + dBeta_df_c(ii) )
                      d_delta_df(ii) = singularity(ii) * del_s(ii)
                    end do ! i
                  end if

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
      !  sps\_path} -- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

                  if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
                    do i = 1, no_to_gl
                      aa = all_inds(i)
                      ga = gl_inds(aa)
                      ii = more_inds(i)
                      d_delta_df(ii) = d_delta_df(ii) + &
                        & del_zeta(ii) * &
                        & sum( (eta_zxp_f(ga:ga+ng-1,q) * sps_path(ga:ga+ng-1,sps_i) &
                             &  * beta_path_f(aa:aa+ng-1,sps_i) - &
                             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
                    end do
                  else ! beta is a function of mixing ratio
                    do i = 1, no_to_gl
                      aa = all_inds(i)
                      ga = gl_inds(aa)
                      ii = more_inds(i)
                      d_delta_df(ii) = d_delta_df(ii) + &
                        & del_zeta(ii) * &
                        & sum( (eta_zxp_f(ga:ga+ng-1,q) * sps_path(ga:ga+ng-1,sps_i) &
                             &  * ( beta_path_f(aa:aa+ng-1,sps_i) + dBeta_df_f(aa:aa+ng-1) ) &
                             &  - singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
                    end do
                  end if

                  ! Refraction correction
                  d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds) * &
                                      & exp(-grids_f%values(q))

                else

                  if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
                    do i = 1, n_inds
                      ii = inds(i)
                      singularity(ii) = eta_zxp_f(indices_c(ii),q) &
                                & * beta_path_c(ii,sps_i)
                      d_delta_df(ii) = singularity(ii) * del_s(ii)
                    end do ! i
                  else
                    do i = 1, n_inds
                      ii = inds(i)
                      iii = indices_c(ii)
                      singularity(ii) = eta_zxp_f(indices_c(ii),q) &
                                & * ( beta_path_c(ii,sps_i) + &
                                &     sps_path(iii,sps_i) * dBeta_df_c(ii) )
                      d_delta_df(ii) = singularity(ii) * del_s(ii)
                    end do ! i
                  end if

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f *
      !  eta\_zxp\_f}~-- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

                  if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
                    do i = 1, no_to_gl
                      aa = all_inds(i)
                      ga = gl_inds(aa)
                      ii = more_inds(i)
                      d_delta_df(ii) = d_delta_df(ii) + &
                        & del_zeta(ii) * &
                        & sum( (eta_zxp_f(ga:ga+ng-1,q) * beta_path_f(aa:aa+ng-1,sps_i) - &
                             &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
                    end do
                  else
                    do i = 1, no_to_gl
                      aa = all_inds(i)
                      ga = gl_inds(aa)
                      ii = more_inds(i)
                      d_delta_df(ii) = d_delta_df(ii) + &
                        & del_zeta(ii) * &
                        & sum( (eta_zxp_f(ga:ga+ng-1,q) &
                             &  * ( beta_path_f(aa:aa+ng-1,sps_i) &
                             &      + dBeta_df_f(aa:aa+ng-1) ) &
                             &  - singularity(ii)) &
                             & * ds_dz_gw(ga:ga+ng-1) )
                    end do
                  end if

                  ! Refraction correction
                  d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)

                end if  ! if/else ( grids_f%lin_log(sps_i) )
  
  
  end subroutine get_d_delta_df

d1184 327
d1656 1
a1656 1
       "$Id: rad_tran_m.F90,v 2.8 2010/06/09 22:04:14 yanovsky Exp $"
a1665 3
! Revision 2.8  2010/06/09 22:04:14  yanovsky
! Added d2Rad_tran_df2 and get_d_delta_df subroutines
!
@


2.8
log
@Added d2Rad_tran_df2 and get_d_delta_df subroutines
@
text
@d384 6
a389 130
          if ( grids_f%lin_log(sps_i) ) then
          ! sps_path is actually exp(mixing ratio) here

            if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
              do i = 1, n_inds ! Don't trust the compiler to fuse loops
                ii = inds(i)
                iii = indices_c(ii)
                singularity(ii) = eta_zxp_f(iii,sv_i) * sps_path(iii,sps_i) * &
                          & beta_path_c(ii,sps_i)
                d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
              end do ! i
            else ! beta is a function of mixing ratio
              do i = 1, n_inds ! Don't trust the compiler to fuse loops
                ii = inds(i)
                iii = indices_c(ii)
                singularity(ii) = eta_zxp_f(iii,sv_i) * sps_path(iii,sps_i) * &
                          & ( beta_path_c(ii,sps_i) + dBeta_df_c(ii) )
                d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
              end do ! i
            end if

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
      !  sps\_path} -- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
              do i = 1, no_to_gl
                aa = all_inds(i)
                ga = gl_inds(aa)
                ii = more_inds(i)
                d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                  & del_zeta(ii) * &
                  & sum( (eta_zxp_f(ga:ga+ng-1,sv_i) * sps_path(ga:ga+ng-1,sps_i) &
                       &  * beta_path_f(aa:aa+ng-1,sps_i) - &
                       &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
              end do
            else ! beta is a function of mixing ratio
              do i = 1, no_to_gl
                aa = all_inds(i)
                ga = gl_inds(aa)
                ii = more_inds(i)
                d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                  & del_zeta(ii) * &
                  & sum( (eta_zxp_f(ga:ga+ng-1,sv_i) * sps_path(ga:ga+ng-1,sps_i) &
                       &  * ( beta_path_f(aa:aa+ng-1,sps_i) + dBeta_df_f(aa:aa+ng-1) ) &
                       &  - singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
              end do
            end if

            ! Refraction correction
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) * &
                                  & exp(-grids_f%values(sv_i))

          else

            if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
              do i = 1, n_inds
                ii = inds(i)
                singularity(ii) = eta_zxp_f(indices_c(ii),sv_i) &
                          & * beta_path_c(ii,sps_i)
                d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
              end do ! i
            else
              do i = 1, n_inds
                ii = inds(i)
                iii = indices_c(ii)
                singularity(ii) = eta_zxp_f(iii,sv_i) &
                          & * ( beta_path_c(ii,sps_i) + &
                          &     sps_path(iii,sps_i) * dBeta_df_c(ii) )
                d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
              end do ! i
            end if

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f *
      !  eta\_zxp\_f}~-- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            if ( sps_i /= i_dBeta_df ) then ! don't want the test in the loop
              do i = 1, no_to_gl
                aa = all_inds(i)
                ga = gl_inds(aa)
                ii = more_inds(i)
                d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                  & del_zeta(ii) * &
                  & sum( (eta_zxp_f(ga:ga+ng-1,sv_i) * beta_path_f(aa:aa+ng-1,sps_i) - &
                       &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
              end do
            else
              do i = 1, no_to_gl
                aa = all_inds(i)
                ga = gl_inds(aa)
                ii = more_inds(i)
                d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                  & del_zeta(ii) * &
                  & sum( (eta_zxp_f(ga:ga+ng-1,sv_i) &
                       &  * ( beta_path_f(aa:aa+ng-1,sps_i) &
                       &      + dBeta_df_f(aa:aa+ng-1) ) &
                       &  - singularity(ii)) &
                       & * ds_dz_gw(ga:ga+ng-1) )
              end do
            end if

            ! Refraction correction
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i)

          end if
d1465 1
a1465 1
       "$Id: rad_tran_m.F90,v 2.7 2010/05/14 02:41:08 vsnyder Exp $"
d1475 3
@


2.7
log
@Changed intent for [n]nz_d_delta_df from out to inout.  Replaced
indices_c(ii) by iii at a place where iii == indices(ii)
@
text
@d18 1
d994 413
d1589 1
a1589 1
       "$Id: rad_tran_m.F90,v 2.6 2010/01/23 01:21:24 vsnyder Exp $"
d1599 4
@


2.6
log
@Handle derivatives for betas that depend upon mixing ratio
@
text
@d310 2
a311 2
    integer, intent(out), target :: nz_d_delta_df(:,:) ! Nonzeros in d_delta_df
    integer, intent(out) :: nnz_d_delta_df(:) ! Column lengths in nz_delta_df
d461 1
a461 1
                singularity(ii) = eta_zxp_f(indices_c(ii),sv_i) &
d1175 1
a1175 1
       "$Id: rad_tran_m.F90,v 2.5 2009/06/16 17:37:09 pwagner Exp $"
d1185 3
@


2.5
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d256 7
a262 6
  subroutine DRad_tran_df ( max_f, indices_c, gl_inds, del_zeta, Grids_f,  &
                         &  beta_path_c, eta_zxp_f, sps_path, do_calc_f,   &
                         &  beta_path_f, do_gl, del_s, ref_cor,            &
                         &  ds_dz_gw, inc_rad_path, i_start, tan_pt,       &
                         &  i_stop, LD, d_delta_df, nz_d_delta_df,         &
                         &  nnz_d_delta_df, drad_df )
d296 4
a299 1
    integer, intent(in) :: i_start           ! path_start_index + 1
d301 1
a301 1
    integer, intent(in) :: i_stop            ! path stop index
d384 1
d386 17
a402 7
            do i = 1, n_inds ! Don't trust the compiler to fuse loops
              ii = inds(i)
              iii = indices_c(ii)
              singularity(ii) = beta_path_c(ii,sps_i) &
                        & * eta_zxp_f(iii,sv_i) * sps_path(iii,sps_i)
              d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
            end do ! i
d420 23
a442 10
            do i = 1, no_to_gl
              aa = all_inds(i)
              ga = gl_inds(aa)
              ii = more_inds(i)
              d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                & del_zeta(ii) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) &
                     &   * eta_zxp_f(ga:ga+ng-1,sv_i) * sps_path(ga:ga+ng-1,sps_i) - &
                     &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
            end do
d450 17
a466 6
            do i = 1, n_inds
              ii = inds(i)
              singularity(ii) = beta_path_c(ii,sps_i) &
                        & * eta_zxp_f(indices_c(ii),sv_i)
              d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
            end do ! i
d484 24
a507 9
            do i = 1, no_to_gl
              aa = all_inds(i)
              ga = gl_inds(aa)
              ii = more_inds(i)
              d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                & del_zeta(ii) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) * eta_zxp_f(ga:ga+ng-1,sv_i) - &
                     &  singularity(ii)) * ds_dz_gw(ga:ga+ng-1) )
            end do
d1175 1
a1175 1
       "$Id: rad_tran_m.F90,v 2.4 2009/06/13 01:11:55 vsnyder Exp $"
d1185 3
@


2.4
log
@Specify start and end of path, simplify some index calculations
@
text
@d207 1
a207 1
          & transpose=.true. )
d1121 1
a1121 1
       "$Id: rad_tran_m.F90,v 2.3 2007/07/11 22:26:45 vsnyder Exp $"
d1131 3
@


2.3
log
@Dumps
@
text
@d259 3
a261 3
                         &  ds_dz_gw, inc_rad_path, tan_pt, i_stop,        &
                         &  LD, d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
                         &  drad_df )
a266 1
    use Where_M, only: Where
d272 1
a272 1
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indicies
d295 3
a297 2
    integer, intent(in) :: tan_pt            ! path stop index
    integer(ip), intent(in) :: i_stop        ! path stop index
d300 1
d310 1
d313 3
a315 3
    integer(ip) :: A, AA, GA, I, II, III
    integer(ip) :: i_start, n_inds, no_to_gl, npc, sps_i, sps_n, sv_i
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
d357 2
d360 1
a360 3
          & gl_inds, do_gl, do_calc )

! find where the non zeros are along the path
a361 1
        n_inds = count(do_calc)
a366 2
          call where ( do_calc, inds )

d373 1
a373 1
            all_inds => all_inds_B(1:ng*no_to_gl)
a404 1
            a = 1
d406 1
a406 1
              aa = all_inds(a)
a413 1
              a = a + ng
a444 1
            a = 1
d446 1
a446 1
              aa = all_inds(a)
a452 1
              a = a + ng
d460 1
a460 1
          i_start = MIN(inds(1),i_stop)
d463 1
a463 1
                       &  i_start, i_stop, drad_df(sv_i))
d486 2
a487 2
                         &  tau, inc_rad_path, tan_pt, i_stop, deriv_flags, &
                         &  pfa_update, drad_dt )
a491 1
    use Where_M, only: Where
d542 1
d544 1
a544 1
    integer(ip), intent(in) :: i_stop       ! path stop index
d553 1
d556 3
a558 3
    integer(ip) :: A, AA, B, BB
    integer(ip) :: i, j, i_start, n_inds, n_path, no_to_gl, p_i, sv_i
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
d592 1
a592 1
      i_start = 1
d598 1
a598 3
        & do_calc )

! find where the non zeros are along the path
a599 1
      n_inds = count(do_calc)
d603 1
a603 2
        call where ( do_calc, inds )
        i_start = max(inds(1)-1,1)
d606 3
a608 3
          j = inds(i)
          singularity(j) = dAlpha_dT_path_c(j) * eta_zxp_c(j,sv_i)
          d_delta_dt(j,sv_i) = singularity(j) * del_s(j)
d616 1
a616 1
          all_inds => all_inds_B(1:ng*no_to_gl)
a636 1
          a = 1
d638 8
a645 9
            aa = all_inds(a)
            bb = aa + ng - 1
            j = more_inds(i)
            d_delta_dt(j,sv_i) = d_delta_dt(j,sv_i) + &
              & del_zeta(j) * &
              & sum( (dAlpha_dT_path_f(aa:bb) * eta_zxp_f(aa:bb,sv_i) - &
                   &  singularity(j)) * &
                   & ds_dz_gw(gl_inds(aa:bb)) )
            a = a + ng
d754 1
a754 1
        i_start = min(i_start,inds(1))
d768 1
a768 1
        call dscrt_dx ( tan_pt, d_delta_dt(:,sv_i), inc_rad_path, i_start, i_stop, &
d773 1
a773 1
                      & i_start, i_stop, drad_dt(sv_i) )
d786 1
a786 1
                         &  eta_zxp_f, sps_path, sps_map, do_calc_f,      &
a793 1
    use Where_M, only: Where
d803 2
a804 1
    real(rp), intent(in) :: eta_zxp_f(:,:)   ! representation basis function.
d807 3
a809 3
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero.
d831 1
a831 1
    integer(ip) :: A, AA, GA, I, II, III
d833 1
a833 1
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
d850 3
a852 3
    logical :: do_calc(1:size(inc_rad_path))      ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).
d865 2
d868 1
a868 3
          & gl_inds, do_gl, do_calc )

! find where the non zeros are along the path
a869 1
        n_inds = count(do_calc)
a873 2
          call where ( do_calc, inds )

d878 1
a878 1
                            &  * eta_zxp_f(iii,sv_i) * sps_path(iii,sps_m)
d887 1
a887 1
            all_inds => all_inds_B(1:Ng*no_to_gl)
a907 1
            a = 1
d909 2
a911 2
              aa = all_inds(a)
              ga = gl_inds(aa)
d915 1
a915 1
                     &   * eta_zxp_f(ga:ga+ng-1,sv_i) * sps_path(ga:ga+ng-1,sps_m) - &
a916 1
              a = a + ng
d940 1
a940 1
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_f, Do_GL, Do_Calc )
d951 2
d960 1
a960 1
        if ( any(do_calc_f(i:i+ng-1)) ) do_calc(p_i)=.true.
d965 9
d979 2
a980 1
  subroutine Get_Do_Calc_Indexed ( N, Do_Calc_all, C_Inds, F_Inds, Do_GL, Do_Calc )
d997 2
d1006 2
d1012 1
a1012 1
    integer(ip), intent(in) :: F_Inds(:)  ! Indices in Do_Calc_All for find grid
d1015 2
d1026 1
d1045 4
d1102 6
a1107 3
          do k = 0, ng - 1
            all_inds(j+k) = l+k
          end do
d1109 1
a1109 1
          j = j + Ng
d1121 1
a1121 1
       "$Id: rad_tran_m.F90,v 2.2 2007/06/26 00:40:01 vsnyder Exp $"
d1125 1
d1131 3
@


2.2
log
@Minor improvement in Get_Do_Calc_Indexed
@
text
@d121 1
a121 1
                     &  prod_pol, tau_pol, rad_pol, p_stop )
d127 1
d161 1
d203 10
d240 10
a249 1
  99 p_stop = - p_stop - 1
d1110 1
a1110 1
       "$Id: rad_tran_m.F90,v 2.1 2007/06/08 22:05:13 vsnyder Exp $"
d1119 3
@


2.1
log
@Replacing rad_tran_m.f90 by rad_tran_m.F90
@
text
@d23 1
a23 1
       "$RCSfile: rad_tran_m.f90,v $"
d334 2
a335 2
        call get_do_calc_indexed ( do_calc_f(:,sv_i), indices_c, gl_inds, &
          & do_gl, do_calc, size(do_gl) )
d854 2
a855 2
        call get_do_calc_indexed ( do_calc_f(:,sv_i), indices_c, gl_inds, &
          & do_gl, do_calc, size(do_gl) )
d962 1
a962 1
  subroutine Get_Do_Calc_Indexed ( Do_Calc_all, C_Inds, F_Inds, Do_GL, Do_Calc, N )
a1000 1
    forall ( i = 1: n ) do_calc(i) = do_calc_all(c_inds(i))
d1003 1
d1089 1
a1089 1
       "$Id: rad_tran_m.f90,v 2.52 2006/12/13 02:32:03 vsnyder Exp $"
d1097 4
a1100 1
! $Log: rad_tran_m.f90,v $
@

