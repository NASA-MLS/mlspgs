head	2.30;
access;
symbols
	v5-02-NRT-19:2.30
	v6-00:2.30
	v5-02-NRT-18:2.30
	v5-02:2.30
	v5-01-NRT-17:2.30
	v5-01-NRT-16:2.30
	v5-01-NRT-15:2.30
	v5-01-NRT-14:2.30
	neuralnetworks-1-0:2.30.0.6
	cfm-single-freq-0-1:2.30.0.4
	v5-01:2.30
	v5-00:2.30
	v4-23-TA133:2.30.0.2
	mus-emls-1-70:2.29.0.4
	rel-1-0-englocks-work:2.29.0.2
	VUMLS1-00:2.28
	VPL1-00:2.28
	V4-22-NRT-08:2.28
	VAM1-00:2.28
	V4-21:2.28.0.2
	V4-13:2.28
	V4-12:2.28
	V4-11:2.28
	V4-10:2.28
	V3-43:2.24
	M4-00:2.26
	V3-41:2.24
	V3-40-PlusGM57:2.24.0.2
	V2-24-NRT-04:2.21
	V3-33:2.24
	V2-24:2.21
	V3-31:2.24
	V3-30-NRT-05:2.24
	cfm-01-00:2.24
	V3-30:2.24
	V3-20:2.24
	V3-10:2.24
	V2-23-NRT-02:2.21
	V2-23:2.21
	V2-22-NRT-01:2.21
	V2-22:2.21
	V2-21:2.21
	V2-20:2.21
	V2-11:2.21
	V2-10:2.21
	V2-00:2.17
	V1-51:2.1
	V1-50:2.1;
locks; strict;
comment	@# @;


2.30
date	2018.08.06.19.56.48;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2017.12.07.02.42.49;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2013.08.30.03.56.23;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2013.07.26.22.19.04;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2011.08.26.00.31.39;	author pwagner;	state Exp;
branches;
next	2.25;

2.25
date	2011.05.09.17.44.26;	author pwagner;	state Exp;
branches;
next	2.24;

2.24
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.23;

2.23
date	2008.10.03.16.26.32;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2008.09.04.19.59.32;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2006.07.29.03.01.41;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2006.07.10.22.26.20;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2006.07.08.01.14.17;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2006.06.15.20.39.29;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2006.04.26.00.39.26;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2006.04.25.23.25.36;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2006.04.21.22.24.19;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2006.01.26.03.08.05;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2005.06.09.02.34.15;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2005.06.03.01.58.53;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2005.05.24.01.54.29;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2005.05.12.20.49.28;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2005.05.02.23.02.18;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2005.04.04.19.52.46;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2005.03.28.20.22.59;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2005.03.17.01.32.26;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2005.03.16.23.59.56;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2005.01.27.21.20.08;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2005.01.12.03.17.26;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2004.12.31.02.41.01;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2004.12.13.23.54.46;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.30
log
@Use ASSOCIATE construct to avoid necessity for Lines database to have the
TARGET attribute.  Some cannonball polishing.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Create_PFAData_m

  implicit NONE
  private
  public :: Create_PFAData

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Create_PFAData_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains ! =====     Public Procedures     =============================

  ! ---------------------------------------------  Create_PFAData  -----
  integer function Create_PFAData ( Molecules, Signals, Temperatures, &
    & Pressures, LosVel, WhichLines, Oversample, Where )

    ! Create PFAData tables for the specified molecules, signals, temperatures
    ! and pressures.  Tables for DACS are calculated using unpolarized betas
    ! (we have no provision for magnetic field in the PFA tables).  Add the
    ! tables to PFADataBase%PFAData.  Return the index of the last created PFA
    ! datum.

    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use MLSNUMERICS, only: SIMPS => SIMPSONSSUB
    use DUMP_0, only: DUMP
    use FILTERSHAPES_M, only: DACSFILTERSHAPES, FILTERSHAPES, FILTERSHAPE_T
    use INTRINSIC, only: LIT_INDICES, L_NONE
    use MLSKINDS, only: RP, R8
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSIGNALS_M, only: GETNAMEOFSIGNAL, MATCHSIGNAL, MAXSIGLEN, SIGNAL_T
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MORETREE, only: GETSTRINGINDEXFROMSTRING
    use OUTPUT_M, only: OUTPUT
    use PFADATABASE_M, only: ADDPFADATUMTODATABASE, HOOKTABLETOFINDPFA, &
      & PFADATA, PFADATA_T
    use PHYSICS, only: H_OVER_K, SPEEDOFLIGHT ! M/S
    use SLABS_SW_M, only: ALLOCATEONESLABS, DEALLOCATEONESLABS, &
      & SLABS_STRUCT, SLABS_PREP_STRUCT
    use SPECTROSCOPYCATALOG_M, only: CATALOG, CATALOG_T, LINE_T, LINES, &
      & MOSTLINES, SPECTROSCOPYFILE
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: EMIT, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use VGRIDSDATABASE, only: VGRID_T

    type(filterShape_t), pointer :: Filters(:)
    integer, intent(in) :: Molecules(:)
    type(filterShape_t), pointer :: MyFilter
    type(signal_t), intent(in), target :: Signals(:) ! Derived signals, not from database
    type(vGrid_t), intent(in) :: Temperatures
    type(vGrid_t), intent(in) :: Pressures
    real(rp), intent(in) :: LosVel ! Line-of-sight velocity
    integer, intent(in) :: WhichLines ! 0 => Lines for channel,
                                      ! 1 => Lines for radiometer,
                                      ! 2 => All lines in catalog
    integer, intent(in) :: Oversample ! How much to oversample the filter grid
    integer, intent(in) :: Where   ! In the parse tree, for error messages
    

    integer :: C, Chan  ! Indices for channels
    integer, pointer :: Channel(:)  ! Index of channel for signal/channel pair
    real(r8) :: DF      ! Spacing in filter bank's frequency grid
    integer :: DumpIt   ! Dump Beta, dBetaD... if nonzero.  Stop after first
                        !   one if > 1.
    logical :: Error
    integer :: I        ! Index for signals associated with a line, or lines in catalog
    integer :: Ix       ! Position in PFAData of a sought PFADatum if nonzero
    logical, pointer :: LINEFLAG(:) ! Use this line
    integer :: M        ! Index for Molecules
    logical, target :: MaxLineFlag(mostLines)
    integer :: Me = -1  ! String index for trace
    type(catalog_t) :: MyCatalog
    integer :: N        ! A molecule name
    integer :: NFP      ! Number of points in filter bank's frequency grid
    real(r8) :: Norm    ! Normalization for filter grid
    integer :: NumChannels
    real(rp) :: P       ! Pressure
    type(PFAData_T) :: PFADatum
    logical :: Progress ! Dump signal/molecule
    integer :: PX       ! Index for pressures
    integer :: S        ! Index for signals
    integer :: ShapeInd ! Index of filter shape for signal/sideband/channel
    integer, pointer :: SigInd(:)   ! Index of signal for signal/channel pair
    type(signal_t), pointer :: Signal
    character(len=maxSigLen) :: SignalText
    logical :: SkipIt   ! No lines or continuum for molecule/signal combination
    type(slabs_struct) :: Slabs
    real(rp) :: T       ! Temperature from temperature grid
    real :: T0, T1, T2  ! for timing
    integer :: TX       ! Index for temperature grid
    real(rp) :: VelCor  ! Velocity correction = 1 - velRel
    real(rp) :: VelRel  ! LosVel/c

    integer, parameter :: DupSignals = 1
    integer, parameter :: NoCat = dupSignals + 1
    integer, parameter :: NoFilter = noCat + 1
    integer, parameter :: NoLines = noFilter + 1


    call trace_begin ( me, 'Create_PFAData', &
      & cond=toggle(emit) ) ! set by -f command-line switch
    progress = switchDetail(switches,'pfag') > -1
    dumpIt =  switchDetail(switches,'pfab')

    error = .false.

    ! Opposite sign convention here from ATBD
    velRel = losVel / speedOfLight ! losVel & speedOfLight both M/s
    velCor = 1.0_rp - velRel

    ! Work out the signal/channel combinations.  Flatten the representation.
    ! Check for duplicate signals
    numChannels = 0
    do s = 1, size(signals)
      numChannels = numChannels + count(signals(s)%channels)
      do i = 1, s-1
        if ( matchSignal(signals(s),signals(i)) > 0 ) then
          call getNameOfSignal ( signals(s), signalText )
          call announce_error ( where, dupSignals, signalText )
          error = .true.
        end if
      end do
    end do
    nullify ( channel, sigInd )
    if ( error ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, 'Duplicate signals' )

    call allocate_test ( channel, numChannels, 'Channel', moduleName )
    call allocate_test ( sigInd, numChannels, 'SigInd', moduleName )

    chan = 0
    do s = 1, size(signals)
      do c = 1, size(signals(s)%frequencies)
        if ( signals(s)%channels(c) ) then
          chan = chan + 1
          sigInd(chan) = s
          channel(chan) = c - 1 + lbound(signals(s)%frequencies,1)
        end if
      end do ! c
    end do ! s

    ! Now, for all the channels....
    if ( progress ) then
      call cpu_time ( t0 )
      t1 = t0
    end if
    pfaDatum%name = 0
    do c = 1, numChannels
      signal => signals(sigind(c))

      ! Create an empty PFA Datum
      call getNameOfSignal ( signal, signalText, channel=channel(c) )
      pfaDatum%channel = channel(c)
      pfaDatum%signal = getStringIndexFromString ( trim(signalText) )
      pfaDatum%signalIndex = signal%index
      pfaDatum%spectroscopyFile = spectroscopyFile
      pfaDatum%theSignal = signal
      pfaDatum%tGrid = temperatures
      pfaDatum%vel_Rel = velRel
      pfaDatum%vGrid = pressures
      pfaDatum%whichLines = whichLines
      ! Get the filter shape for the signal
      nullify ( filters )
      if ( signal%dacs ) then
        if (  associated(DACSFilterShapes)) filters => DACSFilterShapes%filter
      else
        filters => filterShapes
      end if
      if ( .not. associated(filters) ) &
        & call announce_error ( where, noFilter, signalText )
      shapeInd = matchSignal ( filters%signal, signal, &
        & sideband=signal%sideband, channel=channel(c) )
      if ( shapeInd == 0 ) then
        call announce_error ( where, noFilter, signalText )
        cycle
      end if
      myFilter => filters(shapeInd)
      pfaDatum%filterFile = myFilter%file
      nfp = size(myFilter%filterGrid)
      df = myFilter%filterGrid(2) - myFilter%filterGrid(1)
      ! Compute integral of filter shape, for normalization.  Should be 1.0,
      ! but maybe the input file didn't get normalized....
      call simps ( myFilter%filterShape, df, nfp, norm )
      df = df / oversample

      ! Now, for all the molecules....
      do m = 1, size(molecules)
        n = molecules(m)
        pfaDatum%molecule = n
        ! The channels field is allocated here so each one in the
        ! database will have a separate one, even if they are the same.
        ! Otherwise, when it comes time to destroy them, the first one
        ! will work, and the next one will fail with a dangling pointer.
        nullify ( pfaDatum%theSignal%channels )
        call allocate_test ( pfaDatum%theSignal%channels, channel(c), &
          & 'PFADatum%theSignal%channels', moduleName, lowBound=channel(c) )
        pfaDatum%theSignal%channels = .true.
        px = pfaDatum%vGrid%noSurfs
        tx = pfaDatum%tGrid%noSurfs
        nullify ( pfaDatum%absorption, pfaDatum%dAbsDnc, pfaDatum%dAbsDnu, pfaDatum%dAbsDwc )
        call allocate_test ( pfaDatum%absorption, tx, px, 'pfaDatum%absorption', moduleName )
        call allocate_test ( pfaDatum%dAbsDnc,    tx, px, 'pfaDatum%dAbsDnc',    moduleName )
        call allocate_test ( pfaDatum%dAbsDnu,    tx, px, 'pfaDatum%dAbsDnu',    moduleName )
        call allocate_test ( pfaDatum%dAbsDwc,    tx, px, 'pfaDatum%dAbsDwc',    moduleName )

        ! Work out the required spectroscopy
        myCatalog = catalog(n)
        if ( myCatalog%molecule == l_none ) then
          call announce_error ( where, noCat, more=lit_indices(n) )
          cycle
        end if
        call work_out_spectroscopy
        if ( skipIt ) then
          if ( progress ) call cpu_time ( t1 )
          cycle
        end if

        ! Then for all the pressures and temperatures....
        do tx = 1, temperatures%noSurfs
          ! temperatures%surfs is really log temperature
          t = exp(temperatures%surfs(tx,1))
          do px = 1, pressures%noSurfs
            p = 10.0_rp**(-pressures%surfs(px,1))
            call allocateOneSlabs ( slabs, myCatalog, moduleName, .false. )
            call slabs_prep_struct ( t, p, myCatalog, velCor, .false., slabs )
            call get_beta_etc
            call deallocateOneSlabs ( slabs, moduleName )
          end do ! px
        end do ! tx

        ! Look for it
        ix = HookTableToFindPFA ( 0, 0, PFADatum, 0, replace=.true. )

        ! Put it away
        if ( ix /= 0 ) then
          PFAData(ix) = PFADatum
        else
          create_PFAData = AddPFADatumToDatabase ( PFAData, PFADatum )
          call deallocate_test ( myCatalog%lines, 'myCatalog%lines', moduleName )
          ix = HookTableToFindPFA ( 0, 0, PFADatum, create_PFAData )
        end if

        if ( progress .or. dumpIt >= 0 ) then
          call output ( 'Created PFA for ' )
          call display_string ( lit_indices(n) )
          call output ( ' / ' )
          call output ( trim(signalText) )
          call cpu_time ( t2 )
          call output ( t2-t1, before=' using ', after=' seconds', &
            & format='(f0.2)', advance='yes' )
          t1 = t2
        end if

        if ( dumpIt >= 0 ) then
          call dump ( pfaDatum%Absorption, name='Absorption' )
          call dump ( pfaDatum%dAbsDwc, name='DAbsDwc' )
          call dump ( pfaDatum%dAbsDnc, name='DAbsDnc' )
          call dump ( pfaDatum%dAbsDnu, name='DAbsDnu' )
          if ( dumpIt > 1 ) stop
        end if
      end do ! m
    end do ! c
    if ( error ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Errors while hooking up and finding PFA tables' )

    call deallocate_test ( channel, 'Channel', moduleName )
    call deallocate_test ( sigInd, 'SigInd', moduleName )

    if ( progress ) then
      call cpu_time ( t2 )
      call output ( t2-t0, before='Total CPU time for CreatePFA = ', advance='yes' )
    end if

    call trace_end ( 'Create_PFAData', cond=toggle(emit) )

  contains

    ! ...........................................  Announce_Error  .....
    subroutine Announce_Error ( Where, What, String, More )
      use MORETREE, only: STARTERRORMESSAGE
      use OUTPUT_M, only: OUTPUT
      use STRING_TABLE, only: DISPLAY_STRING
      integer, intent(in) :: Where             ! Tree node index
      integer, intent(in) :: What              ! Error index
      character(len=*), intent(in), optional :: String
      integer, intent(in), optional :: More
      call startErrorMessage ( where )
      select case ( what )
      case ( dupSignals )
        call output ( 'Signal ' )
        call output ( trim(string) )
        call output (' duplicates a previously-specified signal.', advance='yes' )
      case ( noCat )
        call output ( 'No catalog for ' )
        call display_string ( more, advance='yes' )
      case ( noFilter )
        call output ( 'No filter for ' )
        call output ( trim(string), advance='yes' )
      case ( noLines )
        call output ( 'No lines or continuum for ' )
        call display_string ( more )
        call output ( ' / ' )
        call output ( trim(string), advance='yes' )
      end select
    end subroutine Announce_Error

    ! .............................................  Get_Beta_Etc  .....
    subroutine Get_Beta_Etc
      ! Get Beta, dBeta_dw, dBeta_dn and dBeta_dv.  Don't need dBeta_dT.
      ! Frequency average them.
      use Get_Beta_Path_m, only: Create_Beta
      real(r8) :: Avg, dAvg
      real(rp), dimension((nfp-1)*oversample+1) :: &
        & Beta, dBeta_dw, dBeta_dn, dBeta_dv, Frqs, Shapes
      integer :: F    ! Index for frequencies
      real(r8) :: FRQ ! Frequency from filter grid
      real(rp), parameter :: h_over_2K = 0.5 * h_over_K
      integer :: I    ! Index for filling oversamples
      integer :: NQP  ! Number of quadrature points = (nfp-1)*oversample+1
      real(r8) :: Temp(size(Shapes))
      ! Oversample the filter grid using linear interpolation
      nqp = size(frqs)
      frqs(1) = myFilter%filterGrid(1)
      shapes(1) = myFilter%filterShape(1)
      do f = 1+oversample, nqp, oversample
        frqs(f) = myFilter%filterGrid((f+oversample-1)/oversample)
        shapes(f) = myFilter%filterShape((f+oversample-1)/oversample)
        do i = 1, oversample-1
          frqs(f-oversample+i) = frqs(f-oversample) + &
            & real(i)/oversample * (frqs(f)-frqs(f-oversample))
          shapes(f-oversample+i) = shapes(f-oversample) + &
            & real(i)/oversample * (shapes(f)-shapes(f-oversample))
        end do ! i
      end do ! f
      ! Compute Beta and its derivatives
      do f = 1, nqp
        frq = frqs(f)
        beta(f) = 0.0
        call create_beta ( p, T, frq, signals(1)%lo, slabs, &
          & real(tanh(h_over_2K * frq / T),rp), beta(f), noPolarized=.false., &
          & dBeta_dw=dBeta_dw(f), dBeta_dn=dBeta_dn(f), dBeta_dv=dBeta_dv(f) )
      end do ! f
      ! Average.  Assumes filter grid's frequencies are evenly spaced.
      temp = beta * shapes
      call simps ( temp, df, nqp, avg )
      pfaDatum%Absorption(tx,px) = log( avg / norm )
      temp = dBeta_dw * shapes
      call simps ( temp, df, nqp, dAvg )  ! normalization cancels for derivs
      pfaDatum%dAbsDwc(tx,px) = dAvg / avg ! d ln beta / d w = 1 / beta d beta / d w
      temp = dBeta_dn * shapes
      call simps ( temp, df, nqp, dAvg )
      pfaDatum%dAbsDnc(tx,px) = dAvg / avg ! d ln beta / d n = 1 / beta d beta / d n
      temp = dBeta_dv * shapes
      call simps ( temp, df, nqp, dAvg )
      pfaDatum%dAbsDnu(tx,px) = dAvg / avg ! d ln beta / d v = 1 / beta d beta / d v
    end subroutine Get_Beta_Etc

    ! ....................................  Work_Out_Spectroscopy  .....
    subroutine Work_Out_Spectroscopy
      use MLSSignals_m, only: GETRADIOMETERFROMSIGNAL
      integer :: I, L
      skipIt = .false. ! Assume there will be lines and/or continuum
      ! Don't deallocate lines by mistake -- myCatalog is a shallow copy
      nullify ( myCatalog%lines )
      if ( associated ( catalog(n)%lines ) ) then
        ! Subset the lines according to the signal
        lineFlag => MaxLineFlag(:size(catalog(n)%lines))
        if ( whichLines > 1 ) then
          lineFlag = .true.
        else
          do l = 1, size ( catalog(n)%lines )
            lineFlag(l) = .false.
            associate ( thisLine => lines(catalog(n)%lines(l)) )
              if ( associated(thisLine%signals) ) then
                do i = 1, size(thisLine%signals)
                  if ( whichLines > 0 .and. &
                      & getRadiometerFromSignal(thisLine%signals(i)) == &
                      & signal%radiometer .or. &
                    & thisLine%signals(i) == signal%index .and. &
                    &  ( thisLine%sidebands(i) * signal%sideband == 0 .or. &
                    &    thisline%sidebands(i) == signal%sideband ) ) then
                    lineFlag(l) = .true.
                    exit
                  end if
                end do ! i
              end if ! associated(thisLine%signals)
            end associate
          end do ! l
        end if
        ! Check we have at least one line for specie.  Allocate lines if so.
        l = count(lineFlag)
        if ( l == 0 .and. all(myCatalog%continuum == 0) ) then
          call announce_error ( where, noLines, signalText, lit_indices(n) )
          skipIt = .true.
          return
        end if
        call allocate_test ( myCatalog%lines, l, 'myCatalog%lines', moduleName )
        myCatalog%lines = pack ( catalog(n)%lines, lineFlag )

      else

        ! No lines for this specie.  However, its continuum is still valid 
        ! so don't set it to empty.
        ! Don't bother checking that continuum /= 0 as otherwise then
        ! presumably having no continuum and no lines it wouldn't be in the
        ! catalog!
        call allocate_test ( myCatalog%lines, 0, 'myCatalog%lines(0)', moduleName )
      end if
    end subroutine Work_Out_Spectroscopy
  end function Create_PFAData

! =====     Private Procedures     =====================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Create_PFAData_m.f90,v 2.29 2017/12/07 02:42:49 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Create_PFAData_m

! $Log: Create_PFAData_m.f90,v $
! Revision 2.29  2017/12/07 02:42:49  vsnyder
! Don't use host-associated DO indices; make them local
!
! Revision 2.28  2013/08/30 03:56:23  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.27  2013/07/26 22:19:04  vsnyder
! Fiddle with dump switches
!
! Revision 2.26  2011/08/26 00:31:39  pwagner
! CSpline and Hunt now USE MLSNumerics
!
! Revision 2.25  2011/05/09 17:44:26  pwagner
! Converted to using switchDetail
!
! Revision 2.24  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.23  2008/10/03 16:26:32  livesey
! Pushed lo down to support EXTINCTIONV2
!
! Revision 2.22  2008/09/04 19:59:32  vsnyder
! Add PRINT statement in not_used_here
!
! Revision 2.21  2006/07/29 03:01:41  vsnyder
! Send module name to AllocateOneSlabs
!
! Revision 2.20  2006/07/10 22:26:20  vsnyder
! Integrate entire grid when oversampling
!
! Revision 2.19  2006/07/08 01:14:17  vsnyder
! Don't create junk at end of oversampled arrays
!
! Revision 2.18  2006/06/15 20:39:29  vsnyder
! Add oversampling
!
! Revision 2.17  2006/04/26 00:39:26  vsnyder
! Need either ordinary or DACS filters
!
! Revision 2.16  2006/04/25 23:25:36  vsnyder
! Revise DACS filter shape data structure
!
! Revision 2.15  2006/04/21 22:24:19  vsnyder
! Stuff for updating PFA
!
! Revision 2.14  2006/01/26 03:08:05  vsnyder
! Accumulate all errors before crashing, detect duplicate signals early
!
! Revision 2.13  2005/06/09 02:34:15  vsnyder
! Move stuff from l2pc_pfa_structures to slabs_sw_m
!
! Revision 2.12  2005/06/03 01:58:53  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! Revise PFA data structures.
!
! Revision 2.11  2005/05/24 01:54:29  vsnyder
! Delete unused symbols
!
! Revision 2.10  2005/05/12 20:49:28  livesey
! Bug fix (hopefully), fill in channel information in PFADatum on
! creation.
!
! Revision 2.9  2005/05/02 23:02:18  vsnyder
! Use string index of signal's text
!
! Revision 2.8  2005/04/04 19:52:46  vsnyder
! Hoist some loop-invariant stuff
!
! Revision 2.7  2005/03/28 20:22:59  vsnyder
! Add more progress dumps
!
! Revision 2.6  2005/03/17 01:32:26  vsnyder
! Put spectroscopy file's string index in PFAData structure
!
! Revision 2.5  2005/03/16 23:59:56  vsnyder
! Add allLinesForRadiometer and allLinesInCatalog to makePFA
!
! Revision 2.4  2005/01/27 21:20:08  vsnyder
! Remove nonscalar molecule
!
! Revision 2.3  2005/01/12 03:17:26  vsnyder
! Set the channel correctly
!
! Revision 2.2  2004/12/31 02:41:01  vsnyder
! Create PFA data
!
! Revision 2.1  2004/12/13 23:54:46  vsnyder
! Initial commit
!
@


2.29
log
@Don't use host-associated DO indices; make them local
@
text
@a103 1
    type (line_T), pointer :: ThisLine
d386 15
a400 14
            thisLine => lines(catalog(n)%lines(l))
            if ( associated(thisLine%signals) ) then
              do i = 1, size(thisLine%signals)
                if ( whichLines > 0 .and. &
                    & getRadiometerFromSignal(thisLine%signals(i)) == &
                    & signal%radiometer .or. &
                  & thisLine%signals(i) == signal%index .and. &
                  &  ( thisLine%sidebands(i) * signal%sideband == 0 .or. &
                  &    thisline%sidebands(i) == signal%sideband ) ) then
                  lineFlag(l) = .true.
                  exit
                end if
              end do ! i
            end if ! associated(thisLine%signals)
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.28 2013/08/30 03:56:23 vsnyder Exp $"
d440 3
@


2.28
log
@Revise use of trace_begin and trace_end
@
text
@a80 1
    integer :: L        ! Index for lines in catalog
d375 1
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.27 2013/07/26 22:19:04 vsnyder Exp $"
d440 3
@


2.27
log
@Fiddle with dump switches
@
text
@d85 1
d114 3
a116 2
    if ( toggle(emit) ) & ! set by -f command-line switch
      & call trace_begin ( 'Create_PFAData' )
d289 1
a289 2
    if ( toggle(emit) ) & ! set by -f command-line switch
      & call trace_end ( 'Create_PFAData' )
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.26 2011/08/26 00:31:39 pwagner Exp $"
d440 3
@


2.26
log
@CSpline and Hunt now USE MLSNumerics
@
text
@d116 1
a116 3
    dumpIt = 0
    if ( switchDetail(switches,'pfab') > -1 ) dumpIt = 1
    if ( switchDetail(switches,'pfaB') > -1 ) dumpIt = 2
d256 1
a256 1
        if ( progress .or. dumpIt > 0 ) then
d267 1
a267 1
        if ( dumpIt > 0 ) then
d429 1
a429 1
       "$Id: Create_PFAData_m.f90,v 2.25 2011/05/09 17:44:26 pwagner Exp $"
d439 3
@


2.25
log
@Converted to using switchDetail
@
text
@d37 1
a37 1
    use DSIMPSON_MODULE, only: SIMPS
d296 3
a298 3
      use MoreTree, only: StartErrorMessage
      use Output_m, only: Output
      use String_Table, only: Display_String
d376 1
a376 1
      use MLSSignals_m, only: GetRadiometerFromSignal
d431 1
a431 1
       "$Id: Create_PFAData_m.f90,v 2.24 2009/06/23 18:26:10 pwagner Exp $"
d441 3
@


2.24
log
@Prevent Intel from optimizing ident string away
@
text
@d36 1
a36 1
    use Allocate_Deallocate, only: Allocate_Test, DeAllocate_Test
d38 20
a57 19
    use Dump_0, only: Dump
    use FilterShapes_m, only: DACSFilterShapes, FilterShapes, FilterShape_T
    use Intrinsic, only: LIT_INDICES, L_NONE
    use MLSCommon, only: RP, R8
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: GetNameOfSignal, MatchSignal, MaxSigLen, Signal_T
    use MoreTree, only: GetStringIndexFromString
    use Output_m, only: Output
    use PFADataBase_m, only: AddPFADatumToDatabase, HookTableToFindPFA, &
      & PFAData, PFAData_T
    use Physics, only: h_over_K, SpeedOfLight ! m/s
    use Slabs_SW_m, only: AllocateOneSlabs, DeAllocateOneSlabs, &
      & Slabs_Struct, Slabs_Prep_Struct
    use SpectroscopyCatalog_m, only: Catalog, Catalog_t, Line_t, Lines, &
      & MostLines, SpectroscopyFile
    use String_Table, only: Display_String
    use Toggles, only: Emit, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
    use VGridsDatabase, only: VGrid_t
d115 1
a115 1
    progress = index(switches,'pfag') /= 0
d117 2
a118 2
    if ( index(switches,'pfab') /= 0 ) dumpIt = 1
    if ( index(switches,'pfaB') /= 0 ) dumpIt = 2
d431 1
a431 1
       "$Id: read_apriori.f90 is it here $"
d441 3
@


2.23
log
@Pushed lo down to support EXTINCTIONV2
@
text
@d427 1
a428 1
!---------------------------- RCS Ident Info -------------------------------
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.22 2008/09/04 19:59:32 vsnyder Exp $"
a431 1
!---------------------------------------------------------------------------
d433 1
a433 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d435 1
d440 3
@


2.22
log
@Add PRINT statement in not_used_here
@
text
@d354 1
a354 1
        call create_beta ( p, T, frq, slabs, &
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.21 2006/07/29 03:01:41 vsnyder Exp $"
d440 3
@


2.21
log
@Send module name to AllocateOneSlabs
@
text
@d234 1
d430 1
a430 1
       "$Id: Create_PFAData_m.f90,v 2.20 2006/07/10 22:26:20 vsnyder Exp $"
d434 1
d440 3
@


2.20
log
@Integrate entire grid when oversampling
@
text
@d237 1
a237 1
            call allocateOneSlabs ( slabs, myCatalog, .false. )
d429 1
a429 1
       "$Id: Create_PFAData_m.f90,v 2.19 2006/07/08 01:14:17 vsnyder Exp $"
d438 3
@


2.19
log
@Don't create junk at end of oversampled arrays
@
text
@d198 1
d333 2
a334 1
      real(r8) :: Temp(size(myFilter%filterGrid))
d336 1
d339 1
a339 1
      do f = 1+oversample, size(frqs), oversample
d350 1
a350 1
      do f = 1, size(frqs)
d359 1
a359 1
      call simps ( temp, df, nfp, avg )
d362 1
a362 1
      call simps ( temp, df, nfp, dAvg )  ! normalization cancels for derivs
d365 1
a365 1
      call simps ( temp, df, nfp, dAvg )
d368 1
a368 1
      call simps ( temp, df, nfp, dAvg )
d429 1
a429 1
       "$Id: Create_PFAData_m.f90,v 2.18 2006/06/15 20:39:29 vsnyder Exp $"
d438 3
@


2.18
log
@Add oversampling
@
text
@d42 1
a42 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, &
      & MLSMSG_Severity_to_quit
d326 1
a326 1
      real(rp), dimension(nfp*oversample) :: &
d336 1
a336 1
      do f = 1+oversample, nfp*oversample, oversample
d347 1
a347 1
      do f = 1, nfp*oversample
d426 1
a426 1
       "$Id: Create_PFAData_m.f90,v 2.17 2006/04/26 00:39:26 vsnyder Exp $"
d435 3
@


2.17
log
@Need either ordinary or DACS filters
@
text
@d28 1
a28 1
    & Pressures, LosVel, WhichLines, Where )
d69 1
d327 2
a328 2
      real(rp), dimension(size(myFilter%filterGrid)) :: &
        & Beta, dBeta_dw, dBeta_dn, dBeta_dv
d332 1
d334 13
d348 2
a349 2
      do f = 1, nfp
        frq = myFilter%filterGrid(f)
d356 1
a356 1
      temp = beta * myFilter%filterShape
d359 1
a359 1
      temp = dBeta_dw * myFilter%filterShape
d362 1
a362 1
      temp = dBeta_dn * myFilter%filterShape
d365 1
a365 1
      temp = dBeta_dv * myFilter%filterShape
d427 1
a427 1
       "$Id: Create_PFAData_m.f90,v 2.16 2006/04/25 23:25:36 vsnyder Exp $"
d436 3
@


2.16
log
@Revise DACS filter shape data structure
@
text
@d177 8
a184 2
      filters => filterShapes
      if ( signal%dacs ) filters => DACSFilterShapes%filter
d412 1
a412 1
       "$Id: Create_PFAData_m.f90,v 2.15 2006/04/21 22:24:19 vsnyder Exp $"
d421 3
@


2.15
log
@Stuff for updating PFA
@
text
@d31 4
a34 2
    ! and pressures.  Add them to PFADataBase%PFAData.  Sort PFAData.  Return
    ! the index of the last created PFA datum.
d39 1
a39 1
    use FilterShapes_m, only: FilterShapes
d59 1
d61 1
d177 3
a179 1
      shapeInd = matchSignal ( filterShapes%signal, signal, &
d185 4
a188 3
      pfaDatum%filterFile = filterShapes(shapeInd)%file
      nfp = size(filterShapes(shapeInd)%filterGrid)
      df = filterShapes(shapeInd)%filterGrid(2) - filterShapes(shapeInd)%filterGrid(1)
d191 1
a191 1
      call simps ( filterShapes(shapeInd)%filterShape, df, nfp, norm )
d320 1
a320 1
      real(rp), dimension(size(filterShapes(shapeInd)%filterGrid)) :: &
d325 1
a325 1
      real(r8) :: Temp(size(filterShapes(shapeInd)%filterGrid))
d328 1
a328 1
        frq = filterShapes(shapeInd)%filterGrid(f)
d335 1
a335 1
      temp = beta * filterShapes(shapeInd)%filterShape
d338 1
a338 1
      temp = dBeta_dw * filterShapes(shapeInd)%filterShape
d341 1
a341 1
      temp = dBeta_dn * filterShapes(shapeInd)%filterShape
d344 1
a344 1
      temp = dBeta_dv * filterShapes(shapeInd)%filterShape
d406 1
a406 1
       "$Id: Create_PFAData_m.f90,v 2.14 2006/01/26 03:08:05 vsnyder Exp $"
d415 3
@


2.14
log
@Accumulate all errors before crashing, detect duplicate signals early
@
text
@d75 1
d121 1
a121 1
    ! Work out the signal/channel combinations.  Flatten the represenation.
d230 3
d234 7
a240 7
        create_PFAData = AddPFADatumToDatabase ( PFAData, PFADatum )
        call deallocate_test ( myCatalog%lines, 'myCatalog%lines', moduleName )

        ! Report all errors instead of quitting on the first one
        MLSMSG_Severity_to_quit = MLSMSG_Error + 1
        error = error .or. HookTableToFindPFA ( 0, 0, create_PFAData )
        MLSMSG_Severity_to_quit = MLSMSG_Error
d399 1
a399 1
       "$Id: Create_PFAData_m.f90,v 2.13 2005/06/09 02:34:15 vsnyder Exp $"
d408 3
@


2.13
log
@Move stuff from l2pc_pfa_structures to slabs_sw_m
@
text
@d40 2
d73 1
d102 2
a103 1
    integer, parameter :: NoCat = 1
d114 2
d121 1
d125 7
d134 3
d232 5
a236 1
        if ( HookTableToFindPFA ( 0, 0, create_PFAData ) ) continue
d258 2
d285 4
d395 1
a395 1
       "$Id: Create_PFAData_m.f90,v 2.12 2005/06/03 01:58:53 vsnyder Exp $"
d404 3
@


2.12
log
@New copyright notice, move Id to not_used_here to avoid cascades,
Revise PFA data structures.
@
text
@a38 2
    use L2PC_PFA_STRUCTURES, only: AllocateOneSlabs, DeAllocateOneSlabs, &
      & SLABS_STRUCT
d46 2
a47 1
    use Slabs_SW_m, only: Slabs_Prep_Struct
d368 1
a368 1
       "$Id: Create_PFAData_m.f90,v 2.11 2005/05/24 01:54:29 vsnyder Exp $"
d377 4
@


2.11
log
@Delete unused symbols
@
text
@d1 10
a10 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a18 3
  character (len=*), private, parameter :: IdParm = &
       "$Id: Create_PFAData_m.f90,v 2.10 2005/05/12 20:49:28 livesey Exp $"
  character (len=len(idParm)), private :: Id = idParm
d46 1
a46 1
      & PFAData, PFAData_T, Sort_PFADataBase
d216 1
a216 1
        if ( HookTableToFindPFA ( 0, 0, PFAData(create_PFAData) ) ) continue
a241 2
    call sort_PFADataBase

d367 5
d378 3
@


2.10
log
@Bug fix (hopefully), fill in channel information in PFADatum on
creation.
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.9 2005/05/02 23:02:18 vsnyder Exp $"
d40 2
a41 2
    use PFADataBase_m, only: AddPFADatumToDatabase, PFAData, PFAData_T, &
      & Sort_PFADataBase
d46 1
a46 1
    use String_Table, only: Display_String, Get_String
d209 1
a209 1
        create_PFAData = AddPFADatumToDatabase ( pfaData, pfaDatum )
d211 1
d370 4
@


2.9
log
@Use string index of signal's text
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.8 2005/04/04 19:52:46 vsnyder Exp $"
d141 1
d369 3
@


2.8
log
@Hoist some loop-invariant stuff
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.7 2005/03/28 20:22:59 vsnyder Exp $"
d37 2
a38 1
    use MLSSignals_m, only: GetNameOfSignal, MatchSignal, Signal_T
d46 1
a46 1
    use String_Table, only: Display_String
d85 1
d140 2
a141 1
      call getNameOfSignal ( signal, pfaDatum%signal, channel=channel(c) )
d153 1
a153 1
        call announce_error ( where, noFilter, pfaDatum%signal )
d215 1
a215 1
          call output ( trim(pfaDatum%signal) )
d340 1
a340 1
          call announce_error ( where, noLines, pfaDatum%signal, lit_indices(n) )
d368 3
@


2.7
log
@Add more progress dumps
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.6 2005/03/17 01:32:26 vsnyder Exp $"
d37 1
a37 1
    use MLSSignals_m, only: GetNameOfSignal, MatchSignal, MaxSigLen, Signal_T
a83 1
    character(maxSigLen) :: SignalName
d94 2
a95 1
    integer, parameter :: NoLines = noCat + 1
d133 1
d136 10
d149 4
a153 2
      pfaDatum%spectroscopyFile = spectroscopyFile
      pfaDatum%whichLines = whichLines
a162 3

        ! Create an empty PFA Datum
        pfaDatum%name = 0
d164 4
a167 3
        call getNameOfSignal ( signal, pfaDatum%signal, channel=channel(c) )
        pfaDatum%signalIndex = signal%index
        pfaDatum%theSignal = signal
a171 4
        pfaDatum%tGrid = temperatures
        pfaDatum%vGrid = pressures
        pfaDatum%vel_Rel = velRel

d206 1
d236 1
a236 1
      call output ( t2-t0, before='Total CPU time = ', advance='yes' )
d258 3
d337 1
a337 2
          call getNameOfSignal ( signal, signalName )
          call announce_error ( where, noLines, signalName, lit_indices(n) )
d365 3
@


2.6
log
@Put spectroscopy file's string index in PFAData structure
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.5 2005/03/16 23:59:56 vsnyder Exp $"
d31 1
d64 2
d100 3
d140 1
d200 1
a200 1
        if ( progress ) then
d210 8
d355 3
@


2.5
log
@Add allLinesForRadiometer and allLinesInCatalog to makePFA
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.4 2005/01/27 21:20:08 vsnyder Exp $"
d43 1
a43 1
      & MostLines
d133 1
d340 3
@


2.4
log
@Remove nonscalar molecule
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.3 2005/01/12 03:17:26 vsnyder Exp $"
d23 1
a23 1
    & Pressures, LosVel, Where )
d54 3
d279 1
d286 21
a306 14
        do l = 1, size ( catalog(n)%lines )
          lineFlag(l) = .false.
          thisLine => lines(catalog(n)%lines(l))
          if ( associated(thisLine%signals) ) then
            do i = 1, size(thisLine%signals)
              if ( thisLine%signals(i) == signal%index .and. &
                &  ( thisLine%sidebands(i) * signal%sideband == 0 .or. &
                &    thisline%sidebands(i) == signal%sideband ) ) then
                lineFlag(l) = .true.
                exit
              end if
            end do ! i
          end if ! associated(thisLine%signals)
        end do ! l
d339 3
@


2.3
log
@Set the channel correctly
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.2 2004/12/31 02:41:01 vsnyder Exp $"
d142 1
a142 3
        nullify ( pfaDatum%molecules )
        call allocate_test ( pfaDatum%molecules, 1, 'PFADatum%molecules', moduleName )
        pfaDatum%molecules = n
d328 3
@


2.2
log
@Create PFA data
@
text
@d12 1
a12 1
       "$Id: Create_PFAData_m.f90,v 2.1 2004/12/13 23:54:46 vsnyder Exp $"
d22 2
a23 2
  integer function Create_PFAData ( Molecules, Signals, Temperatures, Pressures, &
    & LosVel, Where )
d51 2
a52 2
    type(vGrid_t), intent(in), target :: Temperatures
    type(vGrid_t), intent(in), target :: Pressures
a59 1
    integer :: Error    ! /= 0 => An error occurred
a98 2
    error = 0

d145 1
a145 1
        call getNameOfSignal ( signal, pfaDatum%signal )
d148 6
a153 2
        pfaDatum%tGrid => temperatures
        pfaDatum%vGrid => pressures
a227 1
      error = 1
d330 3
@


2.1
log
@Initial commit
@
text
@d12 1
a12 1
       "$Id: PFADataBase.f90,v 2.9 2004/11/04 03:42:09 vsnyder Exp $"
d15 1
a15 1
       "$RCSfile: PFADataBase.f90,v $"
d36 2
a37 2
    use MLSSignals_m, only: GetNameOfSignal, GetRadiometerFromSignal, &
      & MatchSignal, Signal_T
d44 2
a45 1
    use Toggles, only: Emit, Toggle
d71 1
d73 1
a73 1
    real(rp) :: P       ! Pressure
d79 2
a80 1
    character(127) :: SignalName
d83 1
d94 1
d123 4
d170 4
a173 1

d190 10
d208 5
d234 1
a234 1
        call output ( 'No lines or continuum for molecule ' )
d236 1
a236 1
        call output ( ' and signal ' )
d278 1
d303 2
d306 1
a306 2
        call allocate_test ( myCatalog%lines, l, &
          & 'myCatalog(?,?)%lines(0)', moduleName )
d313 1
a313 1
        ! Won't bother checking that continuum /= 0 as if it were then
d316 1
a316 2
        call allocate_test ( myCatalog%lines, 0, &
          & 'myCatalog(?,?)%lines(0)', moduleName )
d329 4
a332 1
! $Log: $
@

