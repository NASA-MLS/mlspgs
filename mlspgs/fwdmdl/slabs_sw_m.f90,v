head	2.68;
access;
symbols
	v5-02-NRT-19:2.68
	v6-00:2.68
	v5-02-NRT-18:2.68
	v5-02:2.68
	v5-01-NRT-17:2.68
	v5-01-NRT-16:2.68
	v5-01-NRT-15:2.68
	v5-01-NRT-14:2.68
	neuralnetworks-1-0:2.68.0.6
	cfm-single-freq-0-1:2.68.0.4
	v5-01:2.68
	v5-00:2.68
	v4-23-TA133:2.68.0.2
	mus-emls-1-70:2.67.0.2
	rel-1-0-englocks-work:2.66.0.2
	VUMLS1-00:2.66
	VPL1-00:2.65
	V4-22-NRT-08:2.65
	VAM1-00:2.65
	V4-21:2.64.0.2
	V4-13:2.64
	V4-12:2.63
	V4-11:2.63
	V4-10:2.63
	V3-43:2.61
	M4-00:2.62
	V3-41:2.61
	V3-40-PlusGM57:2.61.0.2
	V2-24-NRT-04:2.55
	V3-33:2.61
	V2-24:2.55
	V3-31:2.61
	V3-30-NRT-05:2.61
	cfm-01-00:2.61
	V3-30:2.61
	V3-20:2.61
	V3-10:2.61
	V2-23-NRT-02:2.55
	V2-23:2.55
	V2-22-NRT-01:2.55
	V2-22:2.55
	V2-21:2.53
	V2-20:2.53
	V2-11:2.52
	V2-10:2.52
	V2-00:2.51
	V1-51:2.42
	V1-50:2.42
	V1-45:2.36
	V1-44:2.36
	V1-43:2.35
	V1-32:2.24
	V1-31:2.24
	V1-30:2.24
	V1-13:2.15
	V1-12:2.15
	V1-11:2.15
	V1-10:2.15
	newfwm-feb03:2.15.0.2
	V1-04:2.4
	V1-03:2.4
	V1-02:2.4
	JointForwardModel:2.4.0.2
	V1-00:2.4
	newfwm-sep01:1.4.0.2
	V0-7:1.4
	V0-5-Level2:1.1
	V0-5-SIPS:1.1;
locks; strict;
comment	@# @;


2.68
date	2018.08.09.02.01.13;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2018.04.19.01.59.16;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2016.10.24.22.16.38;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2015.03.28.02.11.31;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2014.09.05.21.27.29;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2013.05.09.01.02.48;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2011.11.11.00.42.06;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2009.05.13.20.03.02;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2008.10.03.16.30.48;	author livesey;	state Exp;
branches;
next	2.58;

2.58
date	2008.05.20.00.23.50;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2008.02.29.01.57.37;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2007.12.04.23.40.12;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2007.05.23.22.41.49;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2006.12.04.21.17.28;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2006.09.01.00.59.45;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2006.07.29.03.02.11;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2006.05.05.22.20.58;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2006.03.25.00.27.46;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2006.01.26.03.05.51;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2005.09.17.00.48.09;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2005.09.03.01.21.33;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2005.08.03.18.02.31;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2005.07.06.02.17.21;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2005.06.09.02.34.16;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2005.03.29.01.58.17;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2004.12.28.00.26.40;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2004.12.13.20.55.36;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2004.09.23.20.08.47;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2004.09.16.22.16.21;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2004.09.16.20.24.23;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2004.09.01.01.14.48;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2004.08.05.20.59.32;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2004.05.11.02.52.43;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2004.04.24.02.26.54;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2004.04.20.00.48.06;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2004.04.19.21.02.19;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2004.04.17.00.37.00;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2004.04.06.23.40.21;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2004.04.02.00.59.24;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2004.03.30.02.25.08;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2004.03.27.03.35.27;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2004.03.20.03.17.44;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2004.03.19.00.47.02;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2003.07.09.22.46.24;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2003.07.08.00.09.18;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2003.07.04.02.49.03;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2003.06.18.14.45.00;	author bill;	state Exp;
branches;
next	2.20;

2.20
date	2003.06.13.21.28.20;	author bill;	state Exp;
branches;
next	2.19;

2.19
date	2003.05.19.19.58.07;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2003.05.16.23.53.05;	author livesey;	state Exp;
branches;
next	2.17;

2.17
date	2003.05.09.19.25.31;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2003.05.05.23.00.26;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2003.01.16.19.41.42;	author jonathan;	state Exp;
branches
	2.15.2.1;
next	2.14;

2.14
date	2003.01.16.19.08.43;	author jonathan;	state Exp;
branches;
next	2.13;

2.13
date	2003.01.16.18.50.20;	author jonathan;	state Exp;
branches;
next	2.12;

2.12
date	2003.01.16.18.04.12;	author jonathan;	state Exp;
branches;
next	2.11;

2.11
date	2003.01.10.21.55.26;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2002.12.20.20.22.59;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.12.03.00.34.23;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2002.10.08.17.08.06;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2002.10.02.21.06.03;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2002.09.12.23.00.04;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2002.08.05.17.51.15;	author jonathan;	state Exp;
branches;
next	2.4;

2.4
date	2001.12.14.23.43.44;	author zvi;	state Exp;
branches;
next	2.3;

2.3
date	2001.11.30.01.18.11;	author zvi;	state Exp;
branches;
next	2.2;

2.2
date	2001.11.30.01.09.25;	author zvi;	state Exp;
branches;
next	2.1;

2.1
date	2001.10.17.22.01.00;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.21.13.07.09;	author zvi;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.06.07.23.39.32;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.15.03.47.26;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.03.02.07.01;	author zvi;	state Exp;
branches;
next	;

2.15.2.1
date	2003.02.13.17.29.26;	author bill;	state Exp;
branches;
next	2.15.2.2;

2.15.2.2
date	2003.02.27.00.57.20;	author vsnyder;	state Exp;
branches;
next	;

1.4.2.1
date	2001.09.07.19.53.13;	author zvi;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.09.10.10.02.32;	author zvi;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.09.12.00.05.44;	author livesey;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.09.12.21.38.54;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.68
log
@Correct calculation of dSlabs1_dv0 in Slabs_prep_dT (s/b 1 / Slabs1 *
d Slabs1 / dv0).  Correct calculation of dSwI_dNu0 in dVoigt_spectral so
it does not try to use dSlabs1_dNu0 when it's not present.  Correct LaTeX
for 1/S dS/dv0 in Slabs_prep_dT.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module SLABS_SW_M

  ! Single-Line Absorption Software

  use MLSKinds, only: R8, RP
  use SpectroscopyCatalog_m, only: Catalog_T
  use Constants, only: SqrtPi

  implicit NONE

  private

!--------------------------------------------------  SLABS_STRUCT  -----
! This structure contains the "slabs preps arrays."  These are the
! frequency-independent terms in the cross section.

  type, public :: SLABS_STATE ! State stuff in Slabs_Struct
    real(r8) :: v0
    real(r8) :: v0s
    real(r8) :: x1
    real(r8) :: y
    real(r8) :: yi
    real(r8) :: slabs1
    real(r8) :: dslabs1_dv0 ! / slabs1
    logical :: polarized
  end type

  type, public :: SLABS_DERIV ! Derivative stuff in Slabs_Struct
    ! Contribution of dx1_dv0 and dy_dv0 in d Beta / d Nu0 cancel.
    ! See Slabs_DSpectral.
!   real(r8) :: dx1_dv0
!   real(r8) :: dy_dv0
    real(r8) :: dv0s_dT    ! not * 1 / v0s
    real(r8) :: dx1_dT     ! / x1
    real(r8) :: dy_dT      ! / y
    real(r8) :: dyi_dT     ! / yi
    real(r8) :: dslabs1_dT ! / slabs1
  end type

  type, public :: SLABS_STRUCT
    type(catalog_t), pointer :: Catalog ! everything else is same size
    !                                     as catalog%lines
    logical :: UseYi ! Are any d(:)%yi > 0?
    type(slabs_state), dimension(:), allocatable :: S ! State stuff
    type(slabs_deriv), dimension(:), allocatable :: D ! Derivative stuff
  end type SLABS_STRUCT

  ! Routines to manipulate slabs structs

  interface DUMP
    module procedure Dump_Slabs_Struct, Dump_Slabs_Struct_2D
  end interface

  public :: AllocateOneSlabs, AllocateSlabs
  public :: DeallocateAllSlabs, DeallocateOneSlabs
  public :: DestroyCompleteSlabs
  public :: Dump, Dump_Slabs_Struct, Dump_Slabs_Struct_2D

  ! Routines to compute Betas and their derivatives, and to get ready to do so:
  public :: Get_GL_Slabs_Arrays
  public :: Slabs, Slabs_dSpectral, Slabs_dAll, Slabs_dT, Slabs_Lines
  public :: Slabs_Lines_dAll, Slabs_lines_dSpectral, Slabs_Lines_dT
  public :: Slabs_Lines_dT_path
  public :: Slabs_Prep, Slabs_Prep_Struct, Slabs_Prep_Struct_Offset, Slabs_Prep_dT
  public :: Slabswint, Slabswint_dAll, Slabswint_dT
  public :: Slabswint_Lines, Slabswint_Lines_dAll, Slabswint_Lines_dSpectral
  public :: Slabswint_Lines_dT
  public :: Voigt_Lorentz, DVoigt_Spectral, DVoigt_Spectral_Lines

  real(rp), parameter :: OneOvSPi = 1.0_rp / sqrtPi  ! 1.0/Sqrt(Pi)

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: slabs_sw_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------

  ! -------------------------------------------  AllocateOneSlabs  -----
  subroutine AllocateOneSlabs ( Slabs, Catalog, InName, TempDer )
    ! Allocates the items in a slabs structure
    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type (slabs_struct), intent(inout), target :: slabs ! Slabs to allocate
    type (catalog_t), target, intent(in) :: Catalog
    character(len=*), intent(in) :: InName      ! Who wants it
    logical, intent(in), optional :: TempDer    ! "Allocate temperature
                                                !  derivative fields"

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    logical :: MyDer
    integer :: NL, Stat

    ! Executable code
    myDer = .false.
    if ( present(tempDer) ) myDer = tempDer
    if ( associated(catalog%lines) ) then
      nl = size(catalog%lines)
    else
      nl = 0
    end if

    slabs%catalog => catalog
    allocate ( slabs%s(nl), stat=stat )
    addr = 0
    if ( stat == 0 .and. nl > 0 ) addr = transfer(c_loc(slabs%s(1)), addr)
    call test_allocate ( stat, inName, "Slabs%S", (/ 1 /), (/ nl /), &
      & storage_size(slabs%s) / 8, address=addr )
    if ( myDer ) then
      allocate ( slabs%d(nl), stat=stat )
      if ( stat == 0 .and. nl > 0 ) addr = transfer(c_loc(slabs%d(1)), addr)
      call test_allocate ( stat, inName, "Slabs%D", (/ 1 /), (/ nl /), &
      & storage_size(slabs%d) / 8, address=addr )
    end if
    if ( nl /= 0 ) then
      slabs%s%v0s = 0.0_r8
      slabs%s%x1 = 0.0_r8
      slabs%s%y = 0.0_r8
      slabs%s%yi = 0.0_r8
      slabs%s%slabs1 = 0.0_r8
      slabs%s%dslabs1_dv0 = 0.0_r8
      slabs%s%polarized = .false.
      if ( myDer ) then
        slabs%d%dv0s_dT = 0.0_r8
        slabs%d%dx1_dT = 0.0_r8
        slabs%d%dy_dT = 0.0_r8
        slabs%d%dyi_dT = 0.0_r8
        slabs%d%dslabs1_dT = 0.0_r8
      end if
    end if
  end subroutine AllocateOneSlabs

  ! --------------------------------------------  AllocateSlabs  ----------
  subroutine AllocateSlabs ( Slabs, No_Ele, Catalog, Caller, TempDer )
  ! Allocate an array of slabs structures, and then the items in each one

    use Allocate_Deallocate, only: Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    type (slabs_struct), dimension(:,:), allocatable, target :: Slabs
    integer, intent(in) :: No_Ele
    type (catalog_t), dimension(:), target, intent(in) :: Catalog
    character(len=*), intent(in) :: Caller
    logical, intent(in), optional :: TempDer    ! "Allocate temperature
                                                !  derivative fields"

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, J

    allocate ( slabs(no_ele, size(catalog)), stat=i )
    addr = 0
    if ( i == 0 ) then
      if ( size(slabs) > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
    end if
    call test_allocate ( i, caller, 'Slabs', (/1,1/), (/no_ele,size(catalog)/), &
      & storage_size(slabs) / 8 )

    do i = 1, size(catalog)
      do j = 1, no_ele
        call AllocateOneSlabs ( slabs(j,i), catalog(i), caller, TempDer )
      end do
    end do

  end subroutine AllocateSlabs

  ! ------------------------------------------ DeallocateAllSlabs ---------
  subroutine DeallocateAllSlabs ( Slabs, inName )
    ! Allocates the items in a slabs
    type (slabs_struct), intent(inout), dimension(:,:) :: Slabs
    character(len=*), intent(in) :: InName

    integer :: I
    integer :: J
    ! Executable code
    do i = 1, size(slabs,2)
      do j = 1, size(slabs,1)
        call DeallocateOneSlabs ( slabs(j,i), inName )
      end do
    end do
  end subroutine DeallocateAllSlabs

  ! ------------------------------------------ DeallocateOneSlabs ---------
  subroutine DeallocateOneSlabs ( slabs, inName )
    ! DeAllocates the items in a slabs structure
    use Allocate_Deallocate, only: Test_DeAllocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type (slabs_struct), intent(inout), target :: slabs ! Slabs to deallocate
    character (len=*), intent(in) :: inName ! ModuleName of caller

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: S, Stat

    ! Executable code
    if ( allocated(slabs%s) ) then
      s = size(slabs%s) * storage_size(slabs%s) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(slabs%s(1)), addr)
      deallocate ( slabs%s, stat=stat )
      call test_deallocate ( stat, inName, "Slabs%S", s, address=addr )
    end if
    if ( allocated(slabs%d) ) then
      s = size(slabs%d) * storage_size(slabs%d) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(slabs%d(1)), addr)
      deallocate ( slabs%d, stat=stat )
      call test_deallocate ( stat, inName, "Slabs%D", s, address=addr )
    end if
  end subroutine DeallocateOneSlabs

  ! ------------------------------------------- DestroyCompleteSlabs -----
  subroutine DestroyCompleteSlabs ( Slabs )
    ! Destroys all the components of a slabs
    use Allocate_Deallocate, only: Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    type (slabs_struct), dimension(:,:), allocatable, target :: Slabs

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: I, S
    ! Executable code
    call deallocateAllSlabs ( slabs, moduleName )
    s = size(slabs) * storage_size(slabs) / 8
    addr = 0
    if ( s > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
    deallocate ( slabs, stat=i )
    call test_deallocate ( i, moduleName, 'slabs', s, address=addr )
  end subroutine DestroyCompleteSlabs

  ! ------------------------------------------  Dump_Slabs_Struct  -----
  subroutine Dump_Slabs_Struct ( The_Slabs_Struct, Name )

    use Dump_0, only: Dump
    use Intrinsic, only: Lit_indices
    use Output_m, only: NewLine, Output
    use String_Table, only: Display_String

    type(slabs_struct), intent(in) :: The_Slabs_Struct
    character(len=*), intent(in), optional :: Name

    integer :: NL

    call output ( 'Slabs_Struct ' )
    if ( present(name) ) call output ( trim(name) )
    nl = size(the_slabs_struct%catalog%lines)
    if ( nl == 0 ) then
      call output ( ' is empty', advance='yes' )
    else
      call output ( '', advance='yes' )
      if ( the_slabs_struct%catalog%species_name /= 0 ) then
        call output ( 'Species ' )
        call display_string ( the_slabs_struct%catalog%species_name )
      end if
      call output ( 'Molecule ' )
      call display_string ( lit_indices(the_slabs_struct%catalog%molecule) )
      if ( the_slabs_struct%useYi ) call output ( ', use Yi' )
      call newLine
      call dump ( the_slabs_struct%s(:nl)%v0s, name='v0s' )
      call dump ( the_slabs_struct%s(:nl)%x1, name='x1' )
      call dump ( the_slabs_struct%s(:nl)%y, name='y' )
      call dump ( the_slabs_struct%s(:nl)%yi, name='yi' )
      call dump ( the_slabs_struct%s(:nl)%slabs1, name='slabs1' )
      call dump ( the_slabs_struct%s(:nl)%dslabs1_dv0, name='dslabs1_dv0' )
      if ( allocated (the_slabs_struct%d) ) then
        call dump ( the_slabs_struct%d(:nl)%dv0s_dT, name='dv0s_dT' )
        call dump ( the_slabs_struct%d(:nl)%dx1_dT, name='dx1_dT' )
        call dump ( the_slabs_struct%d(:nl)%dy_dT, name='dy_dT' )
        call dump ( the_slabs_struct%d(:nl)%dyi_dT, name='dyi_dT' )
        call dump ( the_slabs_struct%d(:nl)%dslabs1_dT, name='dslabs1_dT' )
      end if
    end if

  end subroutine Dump_Slabs_Struct

  ! ---------------------------------------  Dump_Slabs_Struct_2D  -----
  subroutine Dump_Slabs_Struct_2D ( The_Slabs_Struct, Name )

    use Output_m, only: Output

    type(slabs_struct), intent(in) :: The_Slabs_Struct(:,:)
    character(len=*), intent(in), optional :: Name

    integer :: I, J

    call output ( 'Slabs Struct' )
    if ( present(name) ) call output ( ' ' // trim(name) )
    call output ( ', SIZE = ' )
    call output ( size(the_slabs_struct,1) )
    call output ( ' X ' )
    call output ( size(the_slabs_struct,2), advance='yes' )
    do j = 1, size(the_slabs_struct,2)
      do i = 1, size(the_slabs_struct,1)
        call output ( 'Item ' )
        call output ( i )
        call output ( ', ' )
        call output ( j, advance='yes' )
        call dump ( the_slabs_struct(i,j) )
      end do
    end do

  end subroutine Dump_Slabs_Struct_2D

  ! --------------------------------------------  dVoigt_spectral  -----
  elemental subroutine dVoigt_spectral ( dNu, Nu0, x1, yi, y, w, t, tanh1, slabs1, SwI, &
                         &  dslabs1_dNu0, dSwI_dw, dSwI_dn, dSwI_dNu0 )

! Compute the Voigt function and its first derivatives with respect
! to spectral parameters: w, n & Nu0

! NOTE: Before calling this routine, the user needs to call slabs_prep()
!       routine to compute dslabs1_dNu0

! NOTE: In here and in all other routines in this module, 
!       tanh1 = tanh(h * nu / ( 2.0 * k * T ) )

    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: dnu, nu0
    real(rp), intent(in) :: x1, yi, y, w, t, tanh1, slabs1             
    real(rp), intent(in), optional :: dslabs1_dNu0 ! 1 / slabs1 * d(slabs1)/dNu0

    real(rp), intent(out) :: SwI, dSwI_dw,dSwI_dn
    real(rp), intent(out) :: dSwI_dNu0  ! 1 / Slabs1 * d Slabs1 / d Nu0 ???

    real(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, b, g, z, r    

    real(rp) :: dx_dv0, du_dv0, dv_dv0, vvw, slabs2

    x = x1 * dNu                                                          
    call simple_voigt ( x, y, u, v )  

!  Van Vleck - Wieskopf (VVW) line shape with Voigt

    q = 1.0_rp + dNu / Nu0

    b = x1 * (2.0_r8 * Nu0 + dNu)
    g = b * b + y * y
    z = (y - b * yi) / g
    r = z * OneOvSPi + yi * v
    vvw = (u + r) * q
    slabs2 = slabs1 * tanh1
    SwI = slabs2 * vvw

    du_dx = 2.0_rp * (y * v - x * u)
    du_dy = 2.0_rp * (y * u + x * v - OneOvSPi)

    dv_dx = -du_dy         ! Cauchy-Riemann equation
    dv_dy =  du_dx         ! Cauchy-Riemann equation

! Compute the derivative of SwI w.r.t. w

    dSwI_dw = q * slabs2* (y/w) * (du_dy + yi*du_dx + &
                                &   OneOvSPi*((1.0_rp-2.0_rp*z*y)/g))

! Compute the derivative of SwI w.r.t. n

    dSwI_dn = q * slabs2 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)

! Finaly, compute the derivative of SwI w.r.t. Nu0

! ***** Analytically *****

!    dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
    dx_dv0 = -x1
    du_dv0 = du_dx * dx_dv0
    dv_dv0 = dv_dx * dx_dv0
!    db_dv0 = x1
!    dg_dv0 = 2.0_rp * b*db_dv0
!    dz_dv0 = (-yi*db_dv0-z*dg_dv0)/g
!    dr_dv0 = dz_dv0*OneOvSPi+yi*dv_dv0
!    dvvw_dv0 = (du_dv0+dr_dv0)*q + dq_dv0*(u+r)
!    dvvw_dv0 = (du_dv0+dr_dv0)*q
    dSwI_dNu0 = slabs2*q*(du_dv0 + yi * dv_dv0) - swi / Nu0
    if (present(dslabs1_dNu0)) dSwI_dNu0 = dSwI_dNu0 + swi * dslabs1_dNu0

  end subroutine dVoigt_spectral

  ! --------------------------------------  dVoigt_spectral_Lines  -----
  elemental subroutine dVoigt_spectral_Lines ( dNu, Slabs, t, tanh1, &
                                  &  SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 )

! Compute the sums of the Voigt function and its first derivatives with respect
! to spectral parameters: w, n & Nu0 for all lines in Slabs.

! NOTE: Before calling this routine, the user needs to call slabs_prep()
!       routine to compute dslabs1_dNu0

! NOTE: In here and in all other routines in this module, 
!       tanh1 = tanh( h * nu / ( 2.0 * k * T ) )

    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: dnu
    type(slabs_struct), intent(in) :: Slabs
    real(rp), intent(in) :: T
    real(rp), intent(in) :: Tanh1

    real(rp), intent(out) :: SwI, dSwI_dw, dSwI_dn, dSwI_dNu0               

    integer :: L  ! Line index

    real(r8) :: Nu0
    real(rp) :: x1, yi, y, w, slabs1             
    real(rp) :: dslabs1_dNu0                        

    real(rp) :: x, u, v, SwI1, du_dx, du_dy, dv_dx, dv_dy, q, b, g, z, r    

    real(rp) :: dx_dv0, du_dv0, dv_dv0, vvw, slabs2

    SwI = 0.0_rp
    dSwI_dw = 0.0_rp
    dSwI_dn = 0.0_rp
    dSwI_dNu0 = 0.0_rp     
    do l = 1, size(slabs%s)

      nu0 = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      yi = slabs%s(l)%yi
      y = slabs%s(l)%y
      w = lines(slabs%catalog%lines(l))%w
      slabs1 = slabs%s(l)%slabs1
      dslabs1_dNu0 = slabs%s(l)%dslabs1_dv0

      x = x1 * dNu                                                          
      call simple_voigt ( x, y, u, v )  

  !  Van Vleck - Wieskopf (VVW) line shape with Voigt

      q = 1.0_rp + dNu / Nu0

      b = x1 * (2.0_r8 * Nu0 + dNu)
      g = b * b + y * y
      z = (y - b * yi) / g
      r = z * OneOvSPi + yi * v
      vvw = (u + r) * q
      slabs2 = slabs1 * tanh1
      SwI1 = slabs2 * vvw

      du_dx = 2.0_rp * (y * v - x * u)
      du_dy = 2.0_rp * (y * u + x * v - OneOvSPi)

      dv_dx = -du_dy         ! Cauchy-Riemann equation
      dv_dy =  du_dx         ! Cauchy-Riemann equation

  ! Compute the derivative of SwI w.r.t. w

      dSwI_dw = dSwI_dw + q * slabs2* (y/w) * (du_dy + yi*du_dx + &
                                  &   OneOvSPi*((1.0_rp-2.0_rp*z*y)/g))

  ! Compute the derivative of SwI w.r.t. n

      dSwI_dn = dSwI_dn + q * slabs2 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)

  ! Finaly, compute the derivative of SwI w.r.t. Nu0

  ! ***** Analytically *****

  !    dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
      dx_dv0 = -x1
      du_dv0 = du_dx * dx_dv0
      dv_dv0 = dv_dx * dx_dv0
  !    db_dv0 = x1
  !    dg_dv0 = 2.0_rp * b*db_dv0
  !    dz_dv0 = (-yi*db_dv0-z*dg_dv0)/g
  !    dr_dv0 = dz_dv0*OneOvSPi+yi*dv_dv0
  !    dvvw_dv0 = (du_dv0+dr_dv0)*q + dq_dv0*(u+r)
  !    dvvw_dv0 = (du_dv0+dr_dv0)*q
  !    dSwI_dNu0 = dslabs1_dNu0*vvw + slabs2*dvvw_dv0
      dSwI_dNu0 = dSwI_dNu0 + swi1 * (dslabs1_dNu0/slabs1 &
                     - 1.0_r8/Nu0) + slabs2*q*(du_dv0 + yi * dv_dv0)

      SwI = SwI + SwI1

    end do

  end subroutine dVoigt_spectral_Lines

  ! ------------------------------------------------------  Slabs  -----
  real(rp) elemental function Slabs ( Nu, v0, v0s, x1, tanh1, slabs1, y )

    use Voigt_m, only: Real_Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    real(r8), intent(in) :: v0    ! Line center frequency
    real(r8), intent(in) :: v0s   ! Pressure-shifted line center frequency
    real(rp), intent(in) :: x1
    real(rp), intent(in) :: tanh1 ! tanh( h nu / (2 k T) )
    real(rp), intent(in) :: slabs1
    real(rp), intent(in) :: y

! If the molecular transition and temperature have not changed but
! frequency has enter here.

    real(rp) :: u

    call real_simple_voigt ( x1*real(nu-v0s,rp), y, u )

!  Van Vleck - Wieskopf line shape with Voigt, Added Mar/2/91, Bill
!  Modified code to include interference: June/3/1992 (Bill + Zvi)
!  Modified code to correct a sign error (introduced in last change)
!  (Bill + Zvi, July/7/92)

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta, b = x_1 \sigma$, and
!  $D = \frac1{b^2 + y^2}$.
!  Then {\tt Slabs = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + V(b,y) \right)$.  $b$ is always huge, so we approximate
!  $V(b,y)$ with one term of an asymptotic expansion, \emph{viz.}
!  $V(b,y) \sim \frac{y D}{\sqrt{\pi}}$.

    Slabs = slabs1 * real(nu / v0, rp) * tanh1 * &
      & (u + OneOvSPi*y/((x1*(nu+v0s))**2 + y*y))

  end function Slabs

  ! ---------------------------------------------  Slabs_dSpectral  -----
  elemental subroutine Slabs_dSpectral ( Nu, Nu0, Nu0s, x1, yi, y, w, t, tanh1, &
                         & VelCor, slabs1, &
                         & dslabs1_dNu0, SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 )

  ! Compute Single Line Absorption and its first derivatives with respect
  ! to spectral parameters w, n & Nu0

  ! NOTE: slabs_prep() must compute Nu0s, x1, yi, y, w, slabs1 and dslabs1_dNu0
  !       in advance

    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu, Nu0  ! Measurement frequency, line center
    real(r8), intent(in) :: Nu0s     ! Pressure shifted line center
    real(rp), intent(in) :: x1, yi, y, w ! Spectral parameters
    real(rp), intent(in) :: t, tanh1 ! temperature, tanh(h*nu/(2*k*T))
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction
    real(rp), intent(in) :: Slabs1   ! frequency-independent absorption terms
    real(rp), intent(in) :: dSlabs1_dNu0 ! d Slabs1 / d Nu0 * 1 / slabs1

    real(rp), intent(out) :: SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 ! Absorption, derivs

    real(rp) :: x !, y  ! Re(z), Im(z)
    real(rp) :: u, v    ! Re(w), Im(w)
    real(rp) :: du, dv  ! Re(dw/dz), Im(dw/dz)
    real(rp) :: d, denom, dH1_dNu0, dx_dNu0, dy_dNu0, g, h1, h2, numer, r
    real(rp) :: s2, sigmaX1, y_g_dHdy, y2

    !{ The absorption is
    !
    ! \begin{equation}\begin{split}
    !  \beta =\,& G H 
    ! \text{ where }
    !  G = S_1 \tanh \left( \frac{h \nu}{2 k T} \right) \frac{\nu}{\nu_0}\,,
    !  H = (H_1 + H_2)\,,\\
    !  H_1 =\,& V(x_1 \delta, y) + y_i L(x_1 \delta, y)\,,
    !  H_2 = V(x_1 \sigma, y) - y_i L(x_1 \sigma, y)\,,\\
    !  \delta =\,& \nu - {\nu_0}_s\,, \sigma = \nu + {\nu_0}_s\,,
    !  w(z) = V(\Re z, \Im z) + i L(\Re z, \Im z) =
    !  \exp(-z^2) \, \text{erfc}(-iz)\,.\\
    !  H_2 \sim\,& \frac{n}{\sqrt\pi d} \text{ where }
    !  n = y - x_1 \text{ and } d = x_1^2 \sigma^2 + y^2\,.
    ! \end{split}\end{equation}
    ! $S_1$ is given by the {\tt slabs1} variable.  The approximation for
    ! $H_2$ arises from a one-term asymptotic approximation for $w(z)$, which
    ! is acceptable because $\sigma$ is known to be large. See {\tt
    ! slabs\_prep} below for definitions of $x_1$ and $y$.

    x = x1 * ( nu - nu0s )
    call simple_voigt ( x, y, u, v, du, dv ) ! get w(z) and dw/dz

    !{ We could use a one-term asymptotic approximation for $L(x_1 \delta, y)$
    !  and $\frac{\partial L}{\partial y}$ because $y_i$ is known to be small,
    !  and therefore we don't need much precision for $L$, but $L$ is needed
    !  for calculation of $\frac{\partial V}{\partial y}$ so using {\tt
    !  Simple\_Voigt} is in fact a saving.

    r = 1.0 / nu0
    sigmaX1 = x1 * ( nu + nu0s )
    s2 = sigmaX1**2
    y2 = y**2
    d = 1.0 / ( s2 + y2 )
    denom = oneOvSpi * d
    numer = y - sigmaX1 * yi
    h1 = u + yi * v
    h2 = numer * denom

    g = slabs1 * tanh1 * nu * r
    SwI = g * ( h1 + h2 )

    !{ The derivatives w.r.t $w$ and $n$ are very similar:
    ! \begin{equation}
    !  \frac{\partial \beta}{\partial w} =
    !  \frac{\partial \beta}{\partial y} \frac{\partial y}{\partial w} =
    !  \frac{y}{w} \frac{\partial \beta}{\partial y} =
    !  \frac{y}{w}\, G\, \frac{\partial H}{\partial y} \text{ and }
    !  \frac{\partial \beta}{\partial n} =
    !  \frac{\partial \beta}{\partial y} \frac{\partial y}{\partial n} =
    !  y\, \frac{300}T\, G\, \frac{\partial H}{\partial y}
    ! \end{equation}
    !%
    ! where
    !%
    ! \begin{equation}
    !  \frac{\partial H}{\partial y} =
    !    \frac{\partial u}{\partial y} + y_i\frac{\partial v}{\partial y} +
    !    \frac1{\sqrt\pi d} \frac{\partial n}{\partial y} -
    !    \frac{n}{\sqrt\pi d^2} \frac{\partial d}{\partial y}=
    !    \frac{\partial u}{\partial y} + y_i\frac{\partial v}{\partial y}
    !    + \frac1d \left(\frac1{\sqrt\pi} - 2 y H_2 \right)\,,
    ! \end{equation}
    ! 
    ! and, by applying the Cauchy-Riemann equations
    ! 
    ! \begin{equation}
    !  \frac{\partial u}{\partial y} = - \frac{\partial v}{\partial x} =
    !  - \Im\, \frac{\partial z}{\partial x} \frac{\text{d} w}{\text{d} z} =
    !  - \Im\, \frac{\text{d} w}{\text{d} z} \text{ and }
    !  \frac{\partial v}{\partial y} = \frac{\partial u}{\partial x} =
    !    \Re\, \frac{\partial z}{\partial x} \frac{\text{d} w}{\text{d} z} =
    !    \Re\, \frac{\text{d} w}{\text{d} z}\,.
    ! \end{equation}

    y_g_dHdy = y * g * ( - dv + yi * du + denom - 2.0 * d * y * h2 )
    dSwI_dw = y_g_dHdy / w
    dSwI_dn = y_g_dHdy * 300.0 / T

    !{\begin{equation}\begin{split}
    !  \frac{\partial \beta}{\partial \nu_0} =\,&
    !   \beta \left( \frac1{S_1} \frac{\partial S_1}{\partial \nu_0} -
    !                \frac1{\nu_0} \right) + G \frac{\partial H}{\partial \nu_0} =
    !  \frac\beta{S_1}\frac{\partial S_1}{\partial \nu_0} - \frac{G H_1}{\nu_0} -
    !  \frac{G H_2}{\nu_0} + G \frac{\partial H_1}{\partial \nu_0} +
    !                        G \frac{\partial H_2}{\partial \nu_0}\,.\\
    !  \frac{\partial H_1}{\partial \nu_0} =\,& \Re \frac{\partial w}{\partial \nu_0} +
    !  y_i \Im \frac{\partial w}{\partial \nu_0}\,.\,\,
    !  \text{ Using the chain rule and } z = x_1 ( \nu - {\nu_0}_s ) + i y\,,\\
    !  \frac{\partial w}{\partial \nu_0} =\,&
    !   \frac{\text{d} w}{\text{d} z} \frac{\partial z}{\partial \nu_0}
    !  = (a + i b ) \left( \frac{\partial x}{\partial \nu_0} +
    !                       i \frac{\partial y}{\partial \nu_0} \right)
    !  = a \frac{\partial x}{\partial \nu_0} - b \frac{\partial y}{\partial \nu_0}
    !  + i \left[ b \frac{\partial x}{\partial \nu_0} + a \frac{\partial y}{\partial \nu_0}
    !      \right] \text{, and}\\
    ! \frac{\partial H_1}{\partial \nu_0}
    !  =\,& a \frac{\partial x}{\partial \nu_0} - b \frac{\partial y}{\partial \nu_0}
    !  + y_i \left[ b \frac{\partial x}{\partial \nu_0} + a \frac{\partial y}{\partial \nu_0}
    !      \right]\,,
    !  \text{ where}\\
    ! a =\,& \Re \frac{\text{d} w}{\text{d} z}\,,
    ! b =    \Im \frac{\text{d} w}{\text{d} z}\,,
    ! \frac{\partial y}{\partial \nu_0} = -\frac{y}{\nu_0}\,,
    ! \frac{\partial x_1}{\partial \nu_0} = -\frac{x_1}{\nu_0}\,,
    ! \frac{\partial {\nu_0}_s}{\partial \nu_0} = v_c \text{ and } \\
    ! \frac{\partial x}{\partial \nu_0}
    !  =\,& \frac{\partial x_1}{\partial \nu_0} (\nu - {\nu_0}_s)
    !    - x_1 \frac{\partial {\nu_0}_s}{\partial \nu_0} =
    !    -\frac{x}{\nu_0} - x_1 v_c\,.
    ! \end{split}\end{equation}

    !{\begin{equation}\begin{split}
    !  \frac{\partial H_2}{\partial \nu_0} =\,&
    !   \frac1{\sqrt\pi d}\frac{\partial n}{\partial \nu_0} -
    !   \frac{n}{\sqrt\pi d^2}\frac{\partial d}{\partial \nu_0}\,.\\
    !  \frac{\partial n}{\partial \nu_0} =\,& \frac{\partial y}{\partial \nu_0} -
    !   \frac{\partial x_1}{\partial \nu_0} \sigma y_i -
    !   x_1 \frac{\partial \sigma}{\partial \nu_0} y_i -
    !   x_1 \sigma \frac{\partial y_i}{\partial \nu_0} =
    !   -\frac{y}{\nu_0} + \frac{x_1}{\nu_0} \sigma y_i
    !    - x_1 \frac{\partial {\nu_0}_s}{\partial \nu_0} y_i - 0 \\
    !   =\,& -\frac{n}{\nu_0} - x_1 v_c y_i\,.\\
    !  \frac{\partial d}{\partial \nu_0} =\,&
    !   2 x_1 \frac{\partial x_1}{\partial \nu_0} \sigma^2
    !   + 2 x_1^2 \sigma \frac{\partial \sigma}{\partial \nu_0}
    !   + 2 y \frac{\partial y}{\partial \nu_0} =
    !  -2\frac{x_1^2 \sigma^2}{\nu_0} - 2 x_1^2 \sigma v_c
    !   -2 \frac{y^2}{\nu_0}\\
    !  =\,& -2\frac{d}{\nu_0} - 2 x_1^2 \sigma v_c\,. \text{ Thus}\\
    !  \frac{\partial H_2}{\partial \nu_0} =\,&
    !   -\frac{n}{\sqrt\pi d \nu_0} -\frac{x_1 v_c y_i}{\sqrt\pi d}
    !   +\frac{n}{\sqrt\pi d^2}\left(\frac{2 d}{\nu_0} + 2 x_1^2 \sigma v_c \right)\\
    !  =\,& \frac{H_2}{\nu_0} - \frac{x_1 v_c y_i}{\sqrt\pi d}
    !   +2 H_2 \frac{x_1^2 \sigma v_c}d\,.\\
    ! \end{split}\end{equation}
    !
    ! Noticing that the $\frac{G H_2}{\nu_0}$ terms arising from
    ! $\frac{\partial G}{\partial \nu_0} H_2$ and
    ! $G \frac{\partial H_2}{\partial \nu_0}$ cancel, we finally have
    !
    ! \begin{equation}
    ! \frac{\partial \beta}{\partial \nu_0} =
    !  \beta \frac1{S_1} \frac{\partial S_1}{\partial \nu_0}
    !   - G \left[\frac{H_1}{\nu_0} - \frac{\partial H_1}{\partial \nu_0}
    !    + \frac{x_1 v_c}d
    !     \left( \frac{y_i}{\sqrt\pi}- 2 H_2 x_1 \sigma \right) \right]\,.
    ! \end{equation}

    dx_dNu0 = - r * x - x1 * velcor
    dy_dNu0 = - r * y
    dH1_dNu0 = du * dx_dNu0 - dv * dy_dNu0 + yi * ( dv * dx_dNu0 + du * dy_dNu0 )
    dSwI_dNu0 = SwI * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
      & g * ( r * h1 - dH1_dNu0 + &
      &       d * x1 * velCor * ( yi * oneOvSpi - 2.0 * h2 * sigmaX1 ) )

  end subroutine Slabs_dSpectral

  ! ---------------------------------------  Slabs_lines_dSpectral  -----
  elemental subroutine Slabs_lines_dSpectral ( Nu, Slabs, T, tanh1, VelCor, &
                                & NoPolarized, SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 )

  ! Compute Single Line Absorption and its first derivatives with respect
  ! to spectral parameters w, n & Nu0, without interference.

  ! NOTE: slabs_prep() must compute Nu0s, x1, yi, y, w, slabs1 and dslabs1_dNu0
  !       in advance

    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu       ! Measurement frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff, including
      ! Nu0s     ! Pressure shifted line center
      ! x1, yi, y, w ! Spectral parameters
      ! Slabs1   ! frequency-independent absorption terms
      ! dSlabs1_dNu0 ! d Slabs1 / d Nu0 * 1 / slabs1
    real(rp), intent(in) :: T, tanh1 ! temperature, tanh(h*nu/(2*k*T))
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction
    logical, intent(in) :: NoPolarized ! Don't evaluate for polarized lines

    real(rp), intent(out) :: SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 ! Absorption, derivs

    integer :: L         ! Line index
    real(r8) :: Nu0s     ! Pressure shifted line center from Slabs structure
    real(rp) :: x1, y    ! Spectral parameters from Slabs structure
    real(rp) :: x !, y   ! Re(z), Im(z)
    real(rp) :: u, v     ! Re(w), Im(w)
    real(rp) :: du, dv   ! Re(dw/dz), Im(dw/dz)
    real(rp) :: d, denom, dx_dNu0, dy_dNu0, g, h1, h2, r
    real(rp) :: s2, sigmaX1, Swi_up, y_g_dHdy, y2

    ! See Slabs_dSpectral for TeXnicalities

    SwI = 0.0_rp
    dSwI_dw = 0.0_rp
    dSwI_dn = 0.0_rp
    dSwI_dNu0 = 0.0_rp

    do l = 1, size(slabs%s)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      nu0s = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      y = slabs%s(l)%y

      x = x1 * ( nu - nu0s )
      call simple_voigt ( x, y, u, v, du, dv ) ! get w(z) and dw/dz

      r = 1.0 / slabs%s(l)%v0
      sigmaX1 = x1 * ( nu + nu0s )
      s2 = sigmaX1**2
      y2 = y**2
      d = 1.0 / ( s2 + y2 )
      denom = oneOvSpi * d
      g = slabs%s(l)%slabs1 * tanh1 * nu * r

      dx_dNu0 = - r * x - x1 * velcor
      dy_dNu0 = - r * y

      h1 = u
      h2 = y * denom

      SwI_up = g * ( h1 + h2 )

      y_g_dHdy = y * g * ( - dv + denom - 2.0 * d * y * h2 )
      dSwI_dw = dSwI_dw + y_g_dHdy / lines(slabs%catalog%lines(l))%w
      dSwI_dn = dSwI_dn + y_g_dHdy * 300.0 / T

      dSwI_dNu0 = dSwI_dNu0 + &
        & SwI_up * slabs%s(l)%dslabs1_dv0 - & ! remember dslabs1_dv0 is divided by slabs1
        & g * ( r * h1 - ( du * dx_dNu0 - dv * dy_dNu0 ) - &
        &       2.0 * d * x1 * velCor * h2 * sigmaX1 )

      SwI = SwI + SwI_up

    end do

  end subroutine Slabs_Lines_dSpectral

  ! ----------------------------------------------------  Slabs_dT  -----
  elemental subroutine Slabs_dT ( Nu, v0, v0s, x1, tanh1, slabs1, y, &
    &                           dv0s_dT, dx1_dT, dtanh_dT, dslabs1_dT, dy_dT, &
    &                   Slabs, dSlabs_dT )

  ! Compute single-line absorption and its derivative w.r.t. temperature.

!   use Voigt_m, only: D_Real_Simple_Voigt
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu, v0, v0s, dv0s_dT
    real(rp), intent(in) :: x1
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: slabs1, y
    real(rp), intent(in) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: dslabs1_dT ! 1/slabs1 dslabs1 / dT
    real(rp), intent(in) :: dy_dT      ! 1/y dy / dT
    real(rp), intent(out) :: Slabs, dSlabs_dT

    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: Delta   ! Nu-v0s
    real(rp) :: Du      ! du/dT
    real(rp) :: Da      ! d(x1*delta)
    real(rp) :: Sa, Sb  ! parts of Slabs
    real(rp) :: Sigma   ! Nu+v0s
    real(rp) :: SigmaX1 ! sigma * x1
    real(rp) :: U       ! Voigt
    real(rp) :: Y2      ! y**2

    delta = Nu - v0s
    da = x1 * ( delta * dx1_dT - dv0s_dT ) ! remember, dx1_dT = 1/x1 dx1 / dT
    call simple_voigt ( x1*delta, y, u, du=du, dx=da, dy=y*dy_dT )
!   call D_Real_Simple_Voigt ( x1*delta, y, da, y*dy_dT, u, du )

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta, b = x_1 \sigma$, and
!  $D = \frac1{b^2 + y^2}$.
!  Then {\tt Slabs = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + V(b,y) \right)$.
!  This doesn't include the interference terms $y_i ( L(a,y) - L(b,y) )$.
!  $b$ is always huge, so we approximate
!  $V(b,y)$ with one term of an asymptotic expansion, \emph{viz.}
!  $V(b,y) \sim \frac{y D}{\sqrt{\pi}}$.

    sigma = nu + v0s
    sigmaX1 = sigma * x1
    y2 = y*y
    d = 1.0_rp / ( sigmaX1**2 + y2 )
    sa = slabs1 * real(nu / v0,rp) * tanh1
    sb = sa * OneOvSPi * y * d
!   sb = slabs1 * real(nu / v0,rp) * tanh1
!   sa = sb * u
!   sb = sb * OneOvSPi * y * d
    Slabs = sa * u + sb
!   Slabs = sa + sb

!{ The Fadeeva function $w(z)$, where $z = a + i y$, can be written as $V(a,y) +
!  i L(a,y)$.  $V(a,y)$ is frequently called the Voigt function ({\tt u}
!  above).  All we want for $S$ is its real part, so we don't need $L(a,y)$ for
!  $S$.  For $\frac{\partial S}{\partial T}$ we want the real part of the
!  derivative; this requires the real part of the derivative of $w(z)$, not just
!  Voigt.
!
!  Write $S = S_a + S_b$ where
!  $S_a = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) V(a,y)$ and
!  $S_b = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{y D}{\sqrt{\pi}}$.\\
!  Then
!  $\frac{\partial S}{\partial T} = \frac{\partial S_a}{\partial T} +
!   \frac{\partial S_b}{\partial T}$, where\\
!  $\frac1{S_a}\frac{\partial S_a}{\partial T} =
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!   \frac1{V(a,y)} \Re \frac{\partial w(z)}{\partial T}$ and\\
!  $\frac1{S_b}\frac{\partial S_b}{\partial T} = 
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!    \frac1y \frac{\partial y}{\partial T} - 
!    2 D \left( x_1 \sigma \left( x_1 \frac{\partial \nu_{0_s}}{\partial T} +
!     \sigma \frac{\partial x_1}{\partial T} \right) +
!     y \frac{\partial y}{\partial T} \right)$.\\
!    Notice that the first two terms of
!    $\frac1{S_a}\frac{\partial S_a}{\partial T}$ and
!    $\frac1{S_b}\frac{\partial S_b}{\partial T}$ are the same.\\
!  For $\Re \frac{\partial w(z)}{\partial T}$ we need
!  $\frac{\partial a}{\partial T} = -x_1 \frac{\partial \nu_{0_s}}{\partial T} +
!   \delta \frac{\partial x_1}{\partial T}$ and $\frac{\partial y}{\partial T}$.

    c = dSlabs1_dT + dtanh_dT
    dSlabs_dT = sa * ( c * u + du ) + &
!   dSlabs_dT = sa * ( c + du / u ) + &
      &         sb * ( c + dy_dT - 2.0_rp * D * &
      &           ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT ) )

  end subroutine Slabs_dT

  ! --------------------------------------------------  Slabs_dAll  -----
! elemental &
  subroutine Slabs_dAll ( Nu, v0, v0s, x1, y, w, T, tanh1, slabs1, &
    &                     dv0s_dT, dx1_dT, dtanh_dT, dslabs1_dT, dy_dT, &
    &                     dslabs1_dNu0, velCor, &
    &                     Slabs, dSlabs_dT, dSlabs_dw, dSlabs_dn, dSlabs_dNu0 )

  ! Compute single-line absorption and its derivatives w.r.t. temperature
  ! and spectroscopy parameters w, n and nu_0.  No interference.

    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu, v0, v0s, dv0s_dT
    real(rp), intent(in) :: x1, y, w   ! Spectral parameters
    real(rp), intent(in) :: T          ! Temperature, K
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: slabs1     ! Frequency-independent strength
    real(rp), intent(in) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: dslabs1_dT ! 1/slabs1 dslabs1 / dT
    real(rp), intent(in) :: dy_dT      ! 1/y dy / dT
    real(rp), intent(in) :: dslabs1_dNu0 ! 1/slabs1 dslabs1 / dNu0
    real(rp), intent(in) :: velCor     ! Doppler correction = d v0s / d v0
    real(rp), intent(out) :: Slabs, dSlabs_dT, dSlabs_dw, dSlabs_dn, dSlabs_dNu0

    real(rp) :: A, B    ! Re(dw/dz), Im(dw/dz)
    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: Delta   ! Nu - v0s
    real(rp) :: Denom   ! D / Sqrt(pi)
    real(rp) :: Du      ! du/dT 
    real(rp) :: Dx      ! d(x1*delta)
    real(rp) :: Dx_dNu0 ! dx / dNu0
    real(rp) :: Dy_dNu0 ! dy / dNu0
    real(rp) :: G       ! Slabs1 * tanh1 * nu / v0
    real(rp) :: H2      ! y * Denom
    real(rp) :: Q       ! nu/v0
    real(rp) :: R       ! 1/v0
    real(rp) :: Sa, Sb  ! parts of Slabs
    real(rp) :: SigmaX1 ! ( Nu + v0s ) * x1
    real(rp) :: S2      ! ( sigma * x1 ) ** 2
    real(rp) :: U, V    ! Voigt, Lorentz
    real(rp) :: X       ! X1 * Delta
    real(rp) :: Y2      ! y**2
    real(rp) :: Y_G_dHdy ! Y * G * (du/dy + dH2/dy)

! See Slabs_dT and Slabs_dSpectral for TeXnicalities.

    ! Absorption

    delta = Nu - v0s
    x = x1 * delta
    dx = x * dx1_dT - x1 * dv0s_dT ! remember, dx1_dT = 1/x1 dx1 / dT
    call simple_voigt ( x, y, u, v, a, b )
    du = a * dx - b * y * dy_dT

    r = 1 / v0
    q = nu * r
    sigmaX1 = (nu + v0s) * x1
    s2 = sigmaX1**2
    y2 = y*y
    d = 1.0_rp / ( s2 + y2 )
    denom = OneOvSPi * d
    g = slabs1 * q * tanh1
    h2 = y * denom
    sa = g * u
    sb = g * h2
    Slabs = sa + sb

    ! Temperature derivative

    c = dSlabs1_dT + dtanh_dT
    dSlabs_dT = g * ( c * u + du ) + &
!   dSlabs_dT = sa * ( c + du / u ) + &
      &         sb * ( c + dy_dT - 2.0_rp * d * &
      &           ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT ) )

    ! Spectroscopy derivatives

    y_g_dHdy = y * g * ( - b + denom - 2.0 * d * y * h2 )
    dSlabs_dw = y_g_dHdy / w
    dSlabs_dn = y_g_dHdy * 300.0 / T

    dx_dNu0 = - r * x - x1 * velcor
    dy_dNu0 = - r * y
    dSlabs_dNu0 = Slabs * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
      & g * ( r * u - a * dx_dNu0 + b * dy_dNu0 - &
      &       2.0 * d * x1 * velCor * h2 * sigmaX1 )

  end subroutine Slabs_dAll

  ! ------------------------------------------------  Slabs_Lines  -----
  elemental function Slabs_Lines ( Nu, Slabs, tanh1, NoPolarized ) result ( Beta )

    use Voigt_m, only: Real_Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: tanh1 ! tanh( h nu / (2 k T) )
    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized

    real(rp) :: Beta ! Output

! If the molecular transition and temperature have not changed but
! frequency has, enter here to calculate sum of Beta for all lines in SLABS.

    integer :: L      ! Line Index
    real(rp) :: U     ! Voigt = real part of Fadeeva
    real(r8) :: V0S   ! Pressure-shifted line center
    real(r8) :: X1, Y ! Doppler width, ratio Pressure to Doppler widths

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$, and
!  $D = \frac1{\sigma^2 x_1^2 + y^2}$.
!  Then {\tt Slabs = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + \frac{y D}{\sqrt{\pi}} \right)$.

    beta = 0.0_rp
    if ( .not. noPolarized ) then
      do l = 1, size(slabs%s)
        v0s = slabs%s(l)%v0s
        x1 = slabs%s(l)%x1
        y = slabs%s(l)%y
        call real_simple_voigt ( x1*real(nu-v0s,rp), y, u )

        beta = beta + slabs%s(l)%slabs1 * &
          &           real(nu / slabs%s(l)%v0, rp) * tanh1 * &
          & (u + OneOvSPi*y/((x1*(nu+v0s))**2 + y*y))

      end do
    else
      do l = 1, size(slabs%s)
        if ( slabs%s(l)%polarized ) cycle
        v0s = slabs%s(l)%v0s
        x1 = slabs%s(l)%x1
        y = slabs%s(l)%y
        call real_simple_voigt ( x1*real(nu-v0s,rp), y, u )

        beta = beta + slabs%s(l)%slabs1 * &
          &           real(nu / slabs%s(l)%v0, rp) * tanh1 * &
          & (u + OneOvSPi*y/((x1*(nu+v0s))**2 + y*y))

      end do
    end if

  end function Slabs_Lines

  ! ---------------------------------------------  Slabs_Lines_dT  -----
!  elemental &
  pure &
  subroutine Slabs_Lines_dT ( Nu, Slabs, Tanh1, dTanh_dT, &
    &                         Beta, dBeta_dT, NoPolarized )

  ! Compute single-line absorption and its derivative w.r.t. temperature
  ! for all lines in the Slabs structure.

    use Voigt_m, only: D_Real_Simple_Voigt
!   use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: Tanh1 ! tanh( h nu / (2 k T) )
    real(rp), intent(in) :: dTanh_dT ! -h nu / (2 k T^2) 1/tanh(...) dTanh(...)/dT

    real(rp), intent(out) :: Beta, dBeta_dT

    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized

    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: Delta   ! Nu-v0s
    real(rp) :: Du      ! du/dT
    real(rp) :: Da      ! d(x1*delta)
    real(rp) :: Dv0s_dT ! dv0s / dT
    real(rp) :: Dx1_dT  ! 1/x1 dx1/dT
    real(rp) :: Dy_dT   ! 1/y dy/dT
    integer :: L        ! Line index
    real(rp) :: Sa, Sb  ! parts of Slabs
    real(rp) :: SigmaX1 ! (nu + v0s) * x1
    real(rp) :: U       ! Voigt
    real(r8) :: V0S     ! Pressure-shifted line center
    real(rp) :: X1, Y   ! Doppler width, ratio Pressure to Doppler widths
    real(rp) :: Y2      ! y**2

! See Slabs_dT for TeXnicalities

    Beta = 0.0_rp
    dBeta_dT = 0.0_rp

    do l = 1, size(slabs%s) ! == size(slabs%d) == size(slabs%catalog%lines)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      v0s = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      y = slabs%s(l)%y
      sa = slabs%s(l)%slabs1 * (nu / slabs%s(l)%v0) * tanh1
      dv0s_dT = slabs%d(l)%dv0s_dT
      dx1_dT = slabs%d(l)%dx1_dT
      dy_dT = slabs%d(l)%dy_dT
      c = slabs%d(l)%dSlabs1_dT + dtanh_dT
      delta = Nu - v0s
      da = x1 * ( delta * dx1_dT - dv0s_dT )
      call D_Real_Simple_Voigt ( x1*delta, y, da, y*dy_dT, u, du )
      sigmaX1 = (nu + v0s) * x1
      y2 = y * y
      d = 1.0_rp / ( sigmaX1**2 + y2 )
      sb = sa * OneOvSPi * y * d
      beta = beta + sa * u + sb

      dBeta_dT = dBeta_dT + sa * ( u * c + du ) &
        &                 + sb * ( c + dy_dT - 2.0_rp * d * &            
        &                          ( sigmaX1 * ( x1 * dv0s_dT + &        
        &                            sigmaX1 * dx1_dT ) + y2 * dy_dT ) )

    end do

  end subroutine Slabs_Lines_dT

  ! ----------------------------------------  Slabs_Lines_dT_path  -----
!  elemental &
  pure &
  subroutine Slabs_Lines_dT_path ( Nu, Slabs, Path_Inds, Tanh1, dTanh_dT, &
    &                              Ratio, Beta, dBeta_dT, NoPolarized )

  ! Compute single-line absorption and its derivative w.r.t. temperature
  ! for all lines in the Slabs structure.

    use Voigt_m, only: D_Real_Simple_Voigt
!   use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu          ! Frequency
    type(slabs_struct), intent(in) :: Slabs(:) ! Frequency-independent stuff
    integer, intent(in) :: Path_Inds(:) ! Indices for Slabs
    real(rp), intent(in) :: Tanh1(:)    ! tanh( h nu / (2 k T) )
    real(rp), intent(in) :: dTanh_dT(:) ! -h nu / (2 k T^2) 1/tanh(...) dTanh(...)/dT
    real(rp), intent(in) :: Ratio       ! Isotope ratio

    real(rp), intent(inout) :: Beta(:), dBeta_dT(:)

    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized
    real :: B, dB, th, dTh
    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: Delta   ! Nu-v0s
    real(rp) :: Du      ! du/dT
    real(rp) :: Da      ! d(x1*delta)
    real(rp) :: Dv0s_dT ! dv0s / dT
    real(rp) :: Dx1_dT  ! 1/x1 dx1/dT
    real(rp) :: Dy_dT   ! 1/y dy/dT
    integer :: J, K     ! Path indices
    integer :: L        ! Line index
    real(rp) :: Sa, Sb  ! parts of Slabs
    real(rp) :: SigmaX1 ! (nu + v0s) * x1
    real(rp) :: U       ! Voigt
    real(r8) :: V0S     ! Pressure-shifted line center
    real(rp) :: X1, Y   ! Doppler width, ratio Pressure to Doppler widths
    real(rp) :: Y2      ! y**2

! See Slabs_dT for TeXnicalities
    do j = 1, size(path_inds)
      k = path_inds(j)
      b = 0.0  ! Beta for one path slot
      db = 0.0 ! dBeta for one path slot
      th = tanh1(j)
      dTh = dTanh_dT(j)
      do l = 1, size(slabs(k)%s) ! == size(slabs(k)%d) == size(slabs(k)%catalog%lines)

        if ( noPolarized .and. slabs(k)%s(l)%polarized ) cycle

        v0s = slabs(k)%s(l)%v0s
        x1 = slabs(k)%s(l)%x1
        y = slabs(k)%s(l)%y
        sa = slabs(k)%s(l)%slabs1 * (nu / slabs(k)%s(l)%v0) * th
        dv0s_dT = slabs(k)%d(l)%dv0s_dT
        dx1_dT = slabs(k)%d(l)%dx1_dT
        dy_dT = slabs(k)%d(l)%dy_dT
        c = slabs(k)%d(l)%dSlabs1_dT + dTh
        delta = Nu - v0s
        da = x1 * ( delta * dx1_dT - dv0s_dT )
        call D_Real_Simple_Voigt ( x1*delta, y, da, y*dy_dT, u, du )
        sigmaX1 = (nu + v0s) * x1
        y2 = y * y
        d = 1.0_rp / ( sigmaX1**2 + y2 )
        sb = sa * OneOvSPi * y * d
        b = b + sa * u + sb

        db = db + sa * ( u * c + du ) &
          &                 + sb * ( c + dy_dT - 2.0_rp * d * &            
          &                          ( sigmaX1 * ( x1 * dv0s_dT + &        
          &                            sigmaX1 * dx1_dT ) + y2 * dy_dT ) )

      end do
      beta(j) = beta(j) + ratio*b
      dBeta_dT(j) = dBeta_dT(j) + ratio*db
    end do

  end subroutine Slabs_Lines_dT_path

  ! ---------------------------------------------  Slabs_Lines_dAll  -----
  elemental &
  subroutine Slabs_Lines_dAll ( Nu, Slabs, T, tanh1, &
    &                     dtanh_dT, velCor, NoPolarized, &
    &                     Beta, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dNu0 )

  ! Compute single-line absorption and its derivatives w.r.t. temperature
  ! and spectroscopy parameters w, n and nu_0.  No interference.

    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu         ! Measurement frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: T          ! Temperature, K
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: velCor     ! Doppler correction = d v0s / d v0
    logical, intent(in) :: NoPolarized ! Don't evaluate for polarized lines
    real(rp), intent(out) :: Beta, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dNu0

    ! Stuff from Slabs structure
    real(rp) :: dslabs1_dNu0 ! 1/slabs1 dslabs1 / dNu0
    real(rp) :: dv0s_dT    ! dv0s / dT ( not 1/V0s dv0s / dT !)
    real(rp) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp) :: dy_dT      ! 1/y dy / dT
    real(r8) :: v0s        ! Pressure-shifted line center
    real(rp) :: x1, y, w   ! Spectral parameters

    integer :: L        ! Line index
    real(rp) :: A, B    ! Re(dw/dz), Im(dw/dz)
    real(rp) :: Beta_up ! Beta update
    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: Delta   ! Nu - v0s
    real(rp) :: Denom   ! D / Sqrt(pi)
    real(rp) :: Du      ! du/dT 
    real(rp) :: Dx      ! d(x1*delta)
    real(rp) :: Dx_dNu0 ! dx / dNu0
    real(rp) :: Dy_dNu0 ! dy / dNu0
    real(rp) :: G       ! Slabs1 * tanh1 * nu / v0
    real(rp) :: H2      ! y * Denom
    real(rp) :: Q       ! nu/v0
    real(rp) :: R       ! 1/v0
    real(rp) :: Sa, Sd  ! parts of Slabs
    real(rp) :: SigmaX1 ! ( Nu + v0s ) * x1
    real(rp) :: S2      ! ( sigma * x1 ) ** 2
    real(rp) :: U, V    ! Voigt, Lorentz
    real(rp) :: X       ! X1 * Delta
    real(rp) :: Y2      ! y**2
    real(rp) :: Y_dYdT  ! y * dy/dT
    real(rp) :: Y_G_dHdy ! Y * G * (du/dy + dH2/dy)

! See Slabs_dT and Slabs_dSpectral for TeXnicalities.

    Beta = 0.0
    dBeta_dT = 0.0
    dBeta_dw = 0.0
    dBeta_dn = 0.0
    dBeta_dNu0 = 0.0

    do l = 1, size(slabs%s)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      dslabs1_dNu0 = slabs%s(l)%dslabs1_dv0
      dv0s_dT = slabs%d(l)%dv0s_dT
      dx1_dT = slabs%d(l)%dx1_dT
      dy_dT = slabs%d(l)%dy_dT
      v0s = slabs%s(l)%v0s
      w = lines(slabs%catalog%lines(l))%w
      x1 = slabs%s(l)%x1
      y = slabs%s(l)%y

      ! Absorption

      delta = Nu - v0s
      x = x1 * delta
      dx = x * dx1_dT - x1 * dv0s_dT ! remember, dx1_dT = 1/x1 dx1 / dT
      call simple_voigt ( x, y, u, v, a, b )
      y_dydT = y * dy_dT
      du = a * dx - b * y_dydT

      r = 1.0 / slabs%s(l)%v0
      q = nu * r
      sigmaX1 = ( nu + v0s ) * x1
      s2 = sigmaX1**2
      y2 = y*y
      d = 1.0_rp / ( s2 + y2 )
      denom = OneOvSPi * d
      g = slabs%s(l)%slabs1 * q * tanh1
      c = slabs%d(l)%dSlabs1_dT + dtanh_dT
      h2 = y * denom
      sa = g * u
      sd = g * h2

      beta_up = sa + sd

      ! Temperature derivative

      dbeta_dT = dbeta_dT &
!       &      + sa * ( c + du / u ) &
        &      + g * ( u * c + du ) &
        &      + sd * ( c + dy_dT &
        &      - 2.0_rp * d * ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )  )

      ! Spectroscopy derivatives

      y_g_dHdy = y * g * ( - b + denom - 2.0 * d * y * h2 )
      dBeta_dw = dBeta_dw + y_g_dHdy / w
      dBeta_dn = dBeta_dn + y_g_dHdy * 300.0 / T

      dx_dNu0 = - r * x - x1 * velcor
      dy_dNu0 = - r * y
      dBeta_dNu0 = dBeta_dNu0 + &
        & beta_up * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
        &   g * ( r * u - a * dx_dNu0 + b * dy_dNu0 - &
        &         2.0 * d * x1 * velCor * h2 * sigmaX1 )

      beta = beta + beta_up

    end do

  end subroutine Slabs_Lines_dAll

  ! --------------------------------------------------  Slabswint  -----
  real(rp) elemental function Slabswint ( Nu, v0, v0s, x1, tanh1, slabs1, y, yi )

    use Voigt_m, only: Real_Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    real(r8), intent(in) :: v0    ! Line center frequency
    real(r8), intent(in) :: v0s   ! Pressure-shifted line center frequency
    real(rp), intent(in) :: x1
    real(rp), intent(in) :: tanh1 ! tanh( h nu / (2 k T) )
    real(rp), intent(in) :: slabs1
    real(rp), intent(in) :: y
    real(rp), intent(in) :: yi

! If the molecular transition and temperature have not changed but
! frequency has enter here.

    real(rp) :: a, sigmaX1, u, y2

    a = x1 * real(nu-v0s,rp)
    call real_simple_voigt ( a, y, u )

!  Van Vleck - Wieskopf line shape with Voigt, Added Mar/2/91, Bill
!  Modified code to include interference: June/3/1992 (Bill + Zvi)
!  Modified code to correct a sign error (introduced in last change)
!  (Bill + Zvi, July/7/92)

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$, $b = x_1 \sigma$,
!  $D_1 = \frac1{\sqrt\pi} \frac1{a^2 + y^2}$ and
!  $D_2 = \frac1{\sqrt\pi} \frac1{b^2 + y^2}$.
!  Then
!   {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + y_i a D_1
!     + (y - b y_i) D_2 \right)$.
!  The term $y_i a D_1$ is a one-term asymptotic approximation to
!  $L(a, y)$, where $L$ is the imaginary part of Fadeeva.  This is
!  acceptable for all $a$ and $y$ because $y_i$ is known (so far) to
!  be small relative to 1.
!  The term $y D_2$ is a one-term asymptotic approximation to $V(b,
!  y)$, while the term $b D_2$ is a is a one-term asymptotic
!  approximation to $L(b, y)$.  These are both acceptable for all
!  arguments because we know that $b$ is large.

    sigmaX1 = x1 * (nu + v0s)
    y2 = y*y
    Slabswint = slabs1 * real(Nu / v0, rp) * tanh1 * &
      & (u + OneOvSPi*((y - sigmaX1*yi)/(sigmaX1*sigmaX1 + y2) + yi*a/(a*a+y2)))

  end function Slabswint

  ! -----------------------------------------------  Slabswint_dT  -----
  elemental subroutine Slabswint_dT ( Nu, v0, v0s, x1, tanh1, slabs1, y, yi, &
    &                              dv0s_dT, dx1_dT, dtanh_dT, dslabs1_dT, &
    &                              dy_dT, dyi_dT, &
    &                              Slabswint, dSlabs_dT )

    use Voigt_m, only: D_Simple_Voigt

    real(r8), intent(in) :: Nu, v0, v0s, dv0s_dT
    real(rp), intent(in) :: x1
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: slabs1, y, yi
    real(rp), intent(in) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: dslabs1_dT ! 1/slabs1 dslabs1 / dT
    real(rp), intent(in) :: dy_dT      ! 1/y dy / dT
    real(rp), intent(in) :: dyi_dT     ! 1/yi dyi / dT

    real(rp), intent(out) :: Slabswint, dSlabs_dT

! If the molecular transition and temperature have not changed but
! frequency has enter here.

    real(rp) :: A               ! x1 * delta
    real(rp) :: C               ! Terms common to the parts of dSlabs_dT
    real(rp) :: D               ! 1 / (a**2 + y**2)
    real(rp) :: DD              ! 1/D dD/dT, 
    real(rp) :: Da              ! da / dT
    real(rp) :: Delta           ! Nu-v0s
    real(rp) :: DU, DV          ! du/dT, dv/dT
    real(rp) :: Sa, Sb, Sc, Sd  ! parts of SlabsWint
    real(rp) :: Sigma           ! Nu+v0s
    real(rp) :: SigmaX1         ! sigma * x1
    real(rp) :: U, V            ! w(z) = u + i v
    real(rp) :: Y2              ! Y**2

    delta = nu - v0s
    a = x1 * delta
    da = x1 * ( delta * dx1_dT - dv0s_dT ) ! remember, dx1_dT = 1/x1 dx1 / dT
    call D_Simple_Voigt ( a, y, u, v, du, dv, da, y*dy_dT )

!  Van Vleck - Wieskopf line shape with Voigt, Added Mar/2/91, Bill
!  Modified code to include interference: June/3/1992 (Bill + Zvi)
!  Modified code to correct a sign error (introduced in last change)
!  (Bill + Zvi, July/7/92)

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above),
!  $L(a,y)$ be the imaginary part of the Fadeeva function ({\tt v} above),
!  $\delta = \nu-\nu_{0_s}$, $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$,
!  and $D = \frac1{\sigma^2 x_1^2 + y^2}$.
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!  \tanh\left(\frac{h \nu}{2 k T}\right)
!   \left( V(a,y) + y_i L(a,y)
!     + \frac{(y - \sigma x_1 y_i) D}{\sqrt{\pi}} \right)$.
!  The last term arises from a one-term asymptotic expansion of
!  $V(x_1\sigma,y) - y_i L(x_1\sigma,y)$.  This is acceptable because
!  $\sigma$ is known to be large.  We usually use a one-term asymptotic
!  expansion of $L(a,y)$ as well, because $y_i$ is known to be small.  In
!  this case, however, $L(a,y)$ is needed to compute
!  $\frac{\partial V(a,y)}{\partial T}$, so using the general method for
!  $L(a,y)$ actually represents a saving.
!
!  Write $S = S_a + S_b - S_c + S_d$ where
!  $S_a = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) V(a,y)$,
!  $S_b = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) y_i L(a,y)$,
!  $S_c = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{\sigma x_1 y_i D}{\sqrt{\pi}}$, and
!  $S_d = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{y D}{\sqrt{\pi}}$.\\

    sigma = nu + v0s
    sigmaX1 = sigma * x1
    y2 = y * y
    d = 1.0_rp / ( sigmaX1**2 + y2 )
    c = slabs1 * real(nu / v0,rp) * tanh1
    sa = c * u
!   sb = c * yi * v
    sb = c * yi
    c = c * d * OneOvSPi
    sc = c * sigmaX1 * yi
    sd = c * y
    Slabswint = sa + sb * v - sc + sd

!{ Then
!  $\frac{\partial S}{\partial T} = \frac{\partial S_a}{\partial T} +
!   \frac{\partial S_b}{\partial T} - \frac{\partial S_c}{\partial T} +
!   \frac{\partial S_d}{\partial T}$, where\\
!  $\frac1{S_a}\frac{\partial S_a}{\partial T} =
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!   \frac1{V(a,y)} \Re \frac{\partial w(z)}{\partial T}$,\\
!  $\frac1{S_b}\frac{\partial S_b}{\partial T} = 
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!   \frac1{L(a,y)} \Im \frac{\partial w(z)}{\partial T}$,\\
!  $\frac1{S_c}\frac{\partial S_c}{\partial T} = 
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!   \frac1{D}\frac{\partial D}{\partial T} +
!   \frac1{y_i}\frac{\partial y_i}{\partial T} +
!   \frac1{x_1}\frac{\partial x_1}{\partial T} +
!   \frac1{\sigma}\frac{\partial \nu_{0_s}}{\partial T}$, and\\
!  $\frac1{S_d}\frac{\partial S_d}{\partial T} = 
!   \frac1{S_1}\frac{\partial S_1}{\partial T} +
!   \frac1{\tanh\left(\frac{h \nu}{2 k T}\right)}\frac{\partial}{\partial T} \tanh\left(\frac{h \nu}{2 k T}\right) +
!   \frac1{D}\frac{\partial D}{\partial T} +
!   \frac1y \frac{\partial y}{\partial T}$, where\\
!  $\frac1{D}\frac{\partial D}{\partial T} = -2 D \left( x_1 \sigma \left( x_1 \frac{\partial \nu_{0_s}}{\partial T} +
!     \sigma \frac{\partial x_1}{\partial T} \right) +
!     y \frac{\partial y}{\partial T} \right)$.\\

!{ Notice that the first two terms of
!    $\frac1{S_a}\frac{\partial S_a}{\partial T}$,
!    $\frac1{S_b}\frac{\partial S_b}{\partial T}$,
!    $\frac1{S_c}\frac{\partial S_c}{\partial T}$ and
!    $\frac1{S_d}\frac{\partial S_d}{\partial T}$ are the same, and
!  the third terms of
!    $\frac1{S_c}\frac{\partial S_c}{\partial T}$ and
!    $\frac1{S_d}\frac{\partial S_d}{\partial T}$ are the same.\\
!  For $\frac{\partial w(z)}{\partial T}$ we need
!  $\frac{\partial a}{\partial T} = -x_1 \frac{\partial \nu_{0_s}}{\partial T} +
!   \delta \frac{\partial x_1}{\partial T}$ and $\frac{\partial y}{\partial T}$.

!{ We don't actually calculate things this way, because if $\delta \equiv 0$
!  then $L(a,y) \equiv 0$.

    c = dSlabs1_dT + dtanh_dT
    dd = -2.0_rp * d * ( sigmaX1 * ( x1 * dv0S_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
    dSlabS_dT = c  * ( c * u + du ) & ! sa * ( c + du / u )
      &       + sb * ( c * v + dv ) & ! sb * v * ( c + dv / v )
      &       - sc * ( c + dd + dyi_dT + dx1_dT + dv0S_dT / sigma ) &
      &       + sd * ( c + dd + dy_dT )

  end subroutine Slabswint_dT

  ! ----------------------------------------------  Slabswint_dAll  -----
  elemental &
  subroutine Slabswint_dAll ( Nu, v0, v0s, x1, yi, y, w, T, tanh1, slabs1, &
    &                         dv0s_dT, dx1_dT, dtanh_dT, dslabs1_dT, dy_dT, dyi_dT, &
    &                         dslabs1_dNu0, velCor, &
    &              Slabswint, dSlabs_dT, dSlabs_dw, dSlabs_dn, dSlabs_dNu0 )

    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu, v0, v0s, dv0s_dT
    real(rp), intent(in) :: x1, yi, y, w ! Spectral parameters
    real(rp), intent(in) :: T          ! Temperature, K
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: slabs1     ! Frequency-independent strength
    real(rp), intent(in) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: dslabs1_dT ! 1/slabs1 dslabs1 / dT
    real(rp), intent(in) :: dy_dT      ! 1/y dy / dT
    real(rp), intent(in) :: dyi_dT     ! 1/yi dyi / dT
    real(rp), intent(in) :: dslabs1_dNu0 ! 1/slabs1 dslabs1 / dNu0
    real(rp), intent(in) :: velCor     ! Doppler correction = d v0s / d v0
    real(rp), intent(out) :: Slabswint, dSlabs_dT, dSlabs_dw, dSlabs_dn, dSlabs_dNu0

    real(rp) :: A, B    ! Re(dw/dz), Im(dw/dz)
    real(rp) :: C       ! Terms common to the two parts of dSlabs_dT
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: DD      ! 1/D dD/dT, 
    real(rp) :: Delta   ! Nu - v0s
    real(rp) :: Denom   ! D / Sqrt(pi)
    real(rp) :: DH1_dNu0 ! dH1 / dNu0
    real(rp) :: Du, Dv  ! du/dT, du/dT
    real(rp) :: Dx      ! d(x1*delta)
    real(rp) :: Dx_dNu0 ! dx / dNu0
    real(rp) :: Dy_dNu0 ! dy / dNu0
    real(rp) :: G       ! Slabs1 * tanh1 * nu / v0
    real(rp) :: H2      ! y * Denom
    real(rp) :: Q       ! nu/v0
    real(rp) :: R       ! 1/v0
    real(rp) :: Sa, Sb, Sc, Sd  ! parts of Slabswint
    real(rp) :: Sigma   ! Nu + v0s
    real(rp) :: SigmaX1 ! Sigma * x1
    real(rp) :: S2      ! ( sigma * x1 ) ** 2
    real(rp) :: U, V    ! Voigt, Lorentz
    real(rp) :: X       ! X1 * Delta
    real(rp) :: Y2      ! y**2
    real(rp) :: Y_dYdT  ! y * dy/dT
    real(rp) :: Y_G_dHdy ! Y * G * (du/dy + dH2/dy)

! See Slabs_dT and Slabs_dSpectral for TeXnicalities.

    ! Absorption

    delta = Nu - v0s
    x = x1 * delta
    dx = x * dx1_dT - x1 * dv0s_dT ! remember, dx1_dT = 1/x1 dx1 / dT
    call simple_voigt ( x, y, u, v, a, b )
    y_dydT = y * dy_dT
    du = a * dx - b * y_dydT
    dv = a * y_dydT + b * dx

    r = 1 / v0
    q = nu * r
    sigma = nu + v0s
    sigmaX1 = sigma * x1
    s2 = sigmaX1**2
    y2 = y*y
    d = 1.0_rp / ( s2 + y2 )
    denom = OneOvSPi * d
    g = slabs1 * q * tanh1
    c = g * denom
    h2 = y * denom
    sa = g * u
    sb = g * yi
!   sb = g * yi * v
    sc = c * yi * sigmaX1
    sd = g * h2
    Slabswint = sa + sb * v - sc + sd
!   Slabswint = sa + sb - sc + sd

    ! Temperature derivative

    c = dSlabs1_dT + dtanh_dT
    dd = -2.0_rp * d * ( sigmaX1 * ( x1 * dv0S_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
    dSlabS_dT = g * ( u * c + du ) &
!   dSlabS_dT = sa * ( c + du / du ) &
      &       + sb * ( c * v + dv ) &
!     &       + sb * ( c + dv / v ) &
      &       - sc * ( c + dd + dyi_dT + dx1_dT + dv0S_dT / sigma ) &
      &       + sd * ( c + dd + dy_dT )

    ! Spectroscopy derivatives

    y_g_dHdy = y * g * ( - b + yi * dx + denom - 2.0 * d * y * h2 )
    dSlabs_dw = y_g_dHdy / w
    dSlabs_dn = y_g_dHdy * 300.0 / T

    dx_dNu0 = - r * x - x1 * velcor
    dy_dNu0 = - r * y
    dH1_dNu0 = a * dx_dNu0 - b * dy_dNu0 + yi * ( b * dx_dNu0 + a * dy_dNu0 )
    dSlabs_dNu0 = Slabswint * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
      & g * ( r * u - dH1_dNu0 + &
      &       d * x1 * velCor * ( yi * oneOvSpi - 2.0 * h2 * sigmaX1 ) )

  end subroutine Slabswint_dAll

  ! --------------------------------------------  Slabswint_Lines  -----
  elemental function Slabswint_Lines ( Nu, Slabs, tanh1, NoPolarized ) result ( Beta )

    use Voigt_m, only: Real_Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: tanh1 ! tanh( h nu / (2 k T) )
    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized

    real(rp) :: Beta ! Output

! If the molecular transition and temperature have not changed but
! frequency has, enter here to calculate sum of Beta for all lines in SLABS.

    real(rp) :: A        ! First argument for real_simple_voigt
    integer :: L         ! Line Index
    real(rp) :: SigmaX1  ! (nu + nu0s) * x1
    real(rp) :: U        ! Voigt = real part of Fadeeva
    real(r8) :: V0S      ! Pressure-shifted line center
    real(rp) :: X1, Y    ! Doppler width, ratio Pressure to Doppler widths
    real(rp) :: Yi       ! Interference coefficient
    real(rp) :: Y2       ! y**2

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$, $b = x_1 \sigma$,
!  $D_1 = \frac1{\sqrt\pi} \frac1{a^2 + y^2}$ and
!  $D_2 = \frac1{\sqrt\pi} \frac1{b^2 + y^2}$.
!  For $y_i \leq 10^{-6}$,
!   {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + y D_2 \right)$, and for
!  $y_i > 10^{-6}$, 
!   {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!   \tanh\left(\frac{h \nu}{2 k T}\right)
!    \left( V(a,y) + y_i a D_1
!     + (y - b y_i) D_2 \right)$.
!  The term $y_i a D_1$ is a one-term asymptotic approximation to
!  $L(a, y)$, where $L$ is the imaginary part of Fadeeva.  This is
!  acceptable for all $a$ and $y$ because $y_i$ is known (so far) to
!  be small relative to 1.
!  The term $y D_2$ is a one-term asymptotic approximation to $V(b,
!  y)$, while the term $b D_2$ is a is a one-term asymptotic
!  approximation to $L(b, y)$.  These are both acceptable for all
!  arguments because we know that $b$ is large.

    beta = 0.0_rp
    do l = 1, size(slabs%s)
      if ( noPolarized .and. slabs%s(l)%polarized ) cycle
      v0s = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      y = slabs%s(l)%y
      yi = slabs%s(l)%yi
      a = x1 * real(nu-v0s,rp)
      call real_simple_voigt ( a, y, u )

      sigmaX1 = x1 * (nu + v0s)
      y2 = y*y
      if ( abs(yi) > 1.0e-6_rp ) then ! Include interference effect
        beta = beta + slabs%s(l)%slabs1 * &
          &           real(Nu / slabs%s(l)%v0, rp) * tanh1 * &
          & (u + OneOvSPi*((y - sigmaX1*yi)/(sigmaX1*sigmaX1 + y2) + yi*a/(a*a+y2)))
      else
        beta = beta + slabs%s(l)%slabs1 * &
          &           real(Nu / slabs%s(l)%v0, rp) * tanh1 * &
          & (u + OneOvSPi*(y/(sigmaX1*sigmaX1 + y2)))
      end if
    end do

  end function Slabswint_Lines

  ! -----------------------------------------  Slabswint_Lines_dT  -----
  elemental &
  subroutine Slabswint_Lines_dT ( Nu, Slabs, tanh1, dTanh_dT, &
    &                             Beta, dBeta_dT, NoPolarized )

  ! Compute single-line absorption and its derivative w.r.t. temperature,
  ! with interference, for all lines in the Slabs structure.

    use Voigt_m, only: D_Simple_Voigt

    real(r8), intent(in) :: Nu    ! Frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: Tanh1 ! tanh( h nu / (2 k T) )
    real(rp), intent(in) :: dTanh_dT ! -h nu / (2 k T^2) 1/tanh(...) dTanh(...)/dT

    real(rp), intent(out) :: Beta, dBeta_dT

    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized

! If the molecular transition and temperature have not changed but
! frequency has enter here.

    real(rp) :: A               ! x1 * delta
    real(rp) :: C1, C2, C3      ! Common terms
    real(rp) :: D               ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: DD              ! 1/D dD/dT
    real(rp) :: Da              ! da / dT
    real(rp) :: Delta           ! Nu-v0s
    real(rp) :: DU, DV          ! du/dT, dv/dT
    real(rp) :: Dv0s_dT         ! dv0s / dT
    real(rp) :: Dx1_dT          ! 1/x1 dx1/dT
    real(rp) :: Dy_dT           ! 1/y dy/dT
    real(rp) :: Dyi_dT          ! 1/yi dyi/dT
    integer :: L                ! Line index
    real(rp) :: Sa, Sb, Sc, Sd  ! parts of SlabsWint
    real(rp) :: Sigma           ! Nu+v0s
    real(rp) :: SigmaX1         ! sigma * x1
    real(rp) :: U, V            ! w(z) = u + i v
    real(r8) :: V0S             ! Pressure-shifted line center
    real(rp) :: X1, Y           ! Doppler width, ratio Pressure to Doppler widths
    real(rp) :: Yi              ! Interference coefficient
    real(rp) :: Y2              ! Y**2

    ! See Slabswint_dT for TeXnicalities.

    beta = 0.0_rp
    dBeta_dT = 0.0_rp
    do l = 1, size(slabs%s)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      v0s = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      y = slabs%s(l)%y
      yi = slabs%s(l)%yi
      dv0s_dT = slabs%d(l)%dv0s_dT
      dx1_dT = slabs%d(l)%dx1_dT
      dy_dT = slabs%d(l)%dy_dT
      dyi_dT = slabs%d(l)%dyi_dT
      delta = nu - v0s
      a = x1 * delta
      da = x1 * ( delta * dx1_dT - dv0s_dT )
      call D_Simple_Voigt ( a, y, u, v, du, dv, da, y*dy_dT )

      sigma = nu + v0s
      sigmaX1 = sigma * x1
      y2 = y * y
      d = 1.0_rp / ( sigmaX1**2 + y2 )
      c1 = slabs%s(l)%slabs1 * real(nu / slabs%s(l)%v0,rp) * tanh1
      c2 = c1 * d * OneOvSPi
      sa = c1 * u
      sd = c2 * y
      c3 = slabs%d(l)%dSlabs1_dT + dtanh_dT
      dd = -2.0_rp * d * ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
      beta = beta + sa + sd
!     dBeta_dT = dBeta_dT + sa * ( c3 + du / u ) + sd * ( c3 + dd + dy_dT )
      dBeta_dT = dBeta_dT + c1 * ( c3 * u + du ) + sd * ( c3 + dd + dy_dT )
      if ( abs(yi) > 1.0e-6_rp ) then
        sb = c1 * yi
        sc = c2 * sigmaX1 * yi
        beta = beta + sb * v - sc

        dBeta_dT = dBeta_dT &
          &      + sb * ( c3 * v + dv ) & ! sb * v * ( c3 + dv / v )
          &      - sc * ( c3 + dd + dyi_dT + dx1_dT + dv0s_dT / sigma ) ! &
      end if

    end do

  end subroutine Slabswint_Lines_dT

  ! ---------------------------------------  Slabswint_lines_dSpectral  -----
  elemental subroutine Slabswint_lines_dSpectral ( Nu, Slabs, T, tanh1, VelCor, &
                                & NoPolarized, SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 )

  ! Compute Single Line Absorption and its first derivatives with respect
  ! to spectral parameters w, n & Nu0

  ! NOTE: slabs_prep() must compute Nu0s, x1, yi, y, w, slabs1 and dslabs1_dNu0
  !       in advance

    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu       ! Measurement frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff, including
      ! Nu0s     ! Pressure shifted line center
      ! x1, yi, y, w ! Spectral parameters
      ! Slabs1   ! frequency-independent absorption terms
      ! dSlabs1_dNu0 ! d Slabs1 / d Nu0 * 1 / slabs1
    real(rp), intent(in) :: T, tanh1 ! temperature, tanh(h*nu/(2*k*T))
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction
    logical, intent(in) :: NoPolarized ! Don't evaluate for polarized lines

    real(rp), intent(out) :: SwI, dSwI_dw, dSwI_dn, dSwI_dNu0 ! Absorption, derivs

    integer :: L         ! Line index
    real(r8) :: Nu0s     ! Pressure shifted line center from Slabs structure
    real(rp) :: x1, yi, y ! Spectral parameters from Slabs structure
    real(rp) :: x !, y   ! Re(z), Im(z)
    real(rp) :: u, v     ! Re(w), Im(w)
    real(rp) :: du, dv   ! Re(dw/dz), Im(dw/dz)
    real(rp) :: d, denom, dH1_dNu0, dx_dNu0, dy_dNu0, g, h1, h2, r
    real(rp) :: s2, sigmaX1, Swi_up, y_g_dHdy, y2

    ! See Slabs_dSpectral for TeXnicalities

    SwI = 0.0_rp
    dSwI_dw = 0.0_rp
    dSwI_dn = 0.0_rp
    dSwI_dNu0 = 0.0_rp

    do l = 1, size(slabs%s)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      nu0s = slabs%s(l)%v0s
      x1 = slabs%s(l)%x1
      yi = slabs%s(l)%yi
      y = slabs%s(l)%y

      x = x1 * ( nu - nu0s )
      call simple_voigt ( x, y, u, v, du, dv ) ! get w(z) and dw/dz

      r = 1.0 / slabs%s(l)%v0
      sigmaX1 = x1 * ( nu + nu0s )
      s2 = sigmaX1**2
      y2 = y**2
      d = 1.0 / ( s2 + y2 )
      denom = oneOvSpi * d
      g = slabs%s(l)%slabs1 * tanh1 * nu * r

      dx_dNu0 = - r * x - x1 * velcor
      dy_dNu0 = - r * y

      if ( yi > 1.0e-6 ) then

        h1 = u + yi * v
        h2 = ( y - sigmaX1 * yi ) * denom

        SwI_up = g * ( h1 + h2 )

        y_g_dHdy = y * g * ( - dv + yi * du + denom - 2.0 * d * y * h2 )
        dSwI_dw = dSwI_dw + y_g_dHdy / lines(slabs%catalog%lines(l))%w
        dSwI_dn = dSwI_dn + y_g_dHdy * 300.0 / T

        dH1_dNu0 = du * dx_dNu0 - dv * dy_dNu0 + yi * ( dv * dx_dNu0 + du * dy_dNu0 )
        dSwI_dNu0 = dSwI_dNu0 + &
          & SwI_up * slabs%s(l)%dslabs1_dv0 - & ! remember dslabs1_dv0 is divided by slabs1
          & g * ( r * h1 - dH1_dNu0 + &
          &       d * x1 * velCor * ( yi * oneOvSpi - 2.0 * h2 * sigmaX1 ) )

      else

        h1 = u
        h2 = y * denom

        SwI_up = g * ( h1 + h2 )

        y_g_dHdy = y * g * ( - dv + denom - 2.0 * d * y * h2 )
        dSwI_dw = dSwI_dw + y_g_dHdy / lines(slabs%catalog%lines(l))%w
        dSwI_dn = dSwI_dn + y_g_dHdy * 300.0 / T

        dSwI_dNu0 = dSwI_dNu0 + &
          & SwI_up * slabs%s(l)%dslabs1_dv0 - & ! remember dslabs1_dv0 is divided by slabs1
          & g * ( r * h1 - ( du * dx_dNu0 - dv * dy_dNu0 ) - &
          &       2.0 * d * x1 * velCor * h2 * sigmaX1 )

      end if

      SwI = SwI + SwI_up

    end do

  end subroutine Slabswint_Lines_dSpectral

  ! ----------------------------------------  Slabswint_Lines_dAll  -----
  elemental &
  subroutine Slabswint_Lines_dAll ( Nu, Slabs, T, tanh1, &
    &                         dtanh_dT, velCor, NoPolarized, &
    &                   Beta, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dNu0 )

    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: Nu         ! Measurement frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: T          ! Temperature, K
    real(rp), intent(in) :: tanh1      ! tanh(h nu / 2 k T), 
    real(rp), intent(in) :: dtanh_dT   ! 1/tanh(...) d tanh(h nu / 2 k T) / dT
      ! = h nu / ( 2 k t^2 ) (tanh(...) - 1/tanh(...) )
    real(rp), intent(in) :: velCor     ! Doppler correction = d v0s / d v0
    logical, intent(in) :: NoPolarized ! Don't evaluate for polarized lines
    real(rp), intent(out) :: Beta, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dNu0

    ! Stuff from Slabs structure
    real(rp) :: dslabs1_dNu0 ! 1/slabs1 dslabs1 / dNu0
    real(rp) :: dv0s_dT    ! dv0s / dT ( not 1/V0s dv0s / dT !)
    real(rp) :: dx1_dT     ! 1/x1 dx1 / dT
    real(rp) :: dy_dT      ! 1/y dy / dT
    real(rp) :: dyi_dT     ! 1/yi dyi / dT
    real(r8) :: v0s        ! Pressure-shifted line center
    real(rp) :: x1, yi, y, w ! Spectral parameters

    ! Other local variables
    integer :: L        ! Line index
    real(rp) :: A, B    ! Re(dw/dz), Im(dw/dz)
    real(rp) :: Beta_up ! Beta update
    real(rp) :: C2, C3  ! Common terms
    real(rp) :: D       ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: DD      ! 1/D dD/dT, 
    real(rp) :: Delta   ! Nu - v0s
    real(rp) :: Denom   ! D / Sqrt(pi)
    real(rp) :: DH1_dNu0 ! dH1 / dNu0
    real(rp) :: Du, Dv  ! du/dT, du/dT
    real(rp) :: Dx      ! d(x1*delta)
    real(rp) :: Dx_dNu0 ! dx / dNu0
    real(rp) :: Dy_dNu0 ! dy / dNu0
    real(rp) :: G       ! Slabs1 * tanh1 * nu / v0
    real(rp) :: H2      ! y * Denom
    real(rp) :: Q       ! nu/v0
    real(rp) :: R       ! 1/v0
    real(rp) :: Sa, Sb, Sc, Sd  ! parts of Slabswint
    real(rp) :: Sigma   ! Nu + v0s
    real(rp) :: SigmaX1 ! Sigma * x1
    real(rp) :: S2      ! ( sigma * x1 ) ** 2
    real(rp) :: U, V    ! Voigt, Lorentz
    real(rp) :: X       ! X1 * Delta
    real(rp) :: Y2      ! y**2
    real(rp) :: Y_dYdT  ! y * dy/dT
    real(rp) :: Y_G_dHdy ! Y * G * (du/dy + dH2/dy)

! See Slabs_dT and Slabs_dSpectral for TeXnicalities.

    Beta = 0.0
    dBeta_dT = 0.0
    dBeta_dw = 0.0
    dBeta_dn = 0.0
    dBeta_dNu0 = 0.0

    do l = 1, size(slabs%s)

      if ( noPolarized .and. slabs%s(l)%polarized ) cycle

      dslabs1_dNu0 = slabs%s(l)%dslabs1_dv0
      dv0s_dT = slabs%d(l)%dv0s_dT
      dx1_dT = slabs%d(l)%dx1_dT
      dy_dT = slabs%d(l)%dy_dT
      dyi_dT = slabs%d(l)%dyi_dT
      v0s = slabs%s(l)%v0s
      w = lines(slabs%catalog%lines(l))%w
      x1 = slabs%s(l)%x1
      yi = slabs%s(l)%yi
      y = slabs%s(l)%y

      ! Absorption

      delta = Nu - v0s
      x = x1 * delta
      dx = x * dx1_dT - x1 * dv0s_dT ! remember, dx1_dT = 1/x1 dx1 / dT
      call simple_voigt ( x, y, u, v, a, b )
      y_dydT = y * dy_dT
      du = a * dx - b * y_dydT
      dv = a * y_dydT + b * dx

      r = 1.0 / slabs%s(l)%v0
      q = nu * r
      sigma = nu + v0s
      sigmaX1 = sigma * x1
      s2 = sigmaX1**2
      y2 = y*y
      d = 1.0_rp / ( s2 + y2 )
      denom = OneOvSPi * d
      g = slabs%s(l)%slabs1 * q * tanh1
      c2 = g * denom
      c3 = slabs%d(l)%dSlabs1_dT + dtanh_dT
      dd = -2.0_rp * d * ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
      h2 = y * denom
      sa = g * u
      sd = g * h2

      if ( abs(yi) > 1.0e-6_rp ) then

        sb = g * yi
!       sb = g * yi * v
        sc = c2 * yi * sigmaX1
        beta_up = sa + sb * v - sc + sd
!       beta_up = sa + sb - sc + sd

        ! Temperature derivative

        dBeta_dT = dBeta_dT &
          &      + g * ( c3 * u + du ) &
!         &      + sa * ( c3 + du / u ) &
          &      + sb * ( c3 * v + dv ) &
!         &      + sb * ( c3 + dv / v ) &
          &      - sc * ( c3 + dd + dyi_dT + dx1_dT + dv0S_dT / sigma ) &
          &      + sd * ( c3 + dd + dy_dT )

        ! Spectroscopy derivatives

        y_g_dHdy = y * g * ( - b + yi * dx + denom - 2.0 * d * y * h2 )
        dBeta_dw = dBeta_dw + y_g_dHdy / w
        dBeta_dn = dBeta_dn + y_g_dHdy * 300.0 / T

        dx_dNu0 = - r * x - x1 * velcor
        dy_dNu0 = - r * y
        dH1_dNu0 = a * dx_dNu0 - b * dy_dNu0 + yi * ( b * dx_dNu0 + a * dy_dNu0 )
        dBeta_dNu0 = dBeta_dNu0 &
          & + beta_up * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
          &   g * ( r * u - dH1_dNu0 + &
          &         d * x1 * velCor * ( yi * oneOvSpi - 2.0 * h2 * sigmaX1 ) )

      else

        beta_up = sa + sd

        ! Temperature derivative

        dbeta_dT = dbeta_dT &
          &      + g * ( c3 * u + du ) &
!         &      + sa * ( c3 + du / u ) &
          &      + sd * ( c3 + dd + dy_dT )

        ! Spectroscopy derivatives

        y_g_dHdy = y * g * ( - b + denom - 2.0 * d * y * h2 )
        dBeta_dw = dBeta_dw + y_g_dHdy / w
        dBeta_dn = dBeta_dn + y_g_dHdy * 300.0 / T

        dx_dNu0 = - r * x - x1 * velcor
        dy_dNu0 = - r * y
        dBeta_dNu0 = dBeta_dNu0 + &
          & beta_up * dslabs1_dNu0 - & ! remember dslabs1_dNu0 is divided by slabs1
          &   g * ( r * u - a * dx_dNu0 + b * dy_dNu0 - &
          &         2.0 * d * x1 * velCor * h2 * sigmaX1 )

      end if

      beta = beta + beta_up

    end do

  end subroutine Slabswint_Lines_dAll

  ! ----------------------------------------------  Voigt_Lorentz  -----

  elemental subroutine Voigt_Lorentz ( dNu,  Nu0,  x1,  yi,  y,  w,  t,  tanh1, slabs1,  &
                         &   VL, dslabs1_dNu0,  dVL_dw,  dVL_dn,  dVL_dNu0 )

! Compute the Voigt/Lorentz function and its first derivatives with respect
! to spectral parameters: w, n & Nu0

! NOTE: Before calling this routine, the user needs to call slabs_prep()
!       routine to compute dslabs1_dNu0

    use Voigt_m, only: Simple_Voigt

    real(r8), intent(in) :: dNu, nu0
    real(rp), intent(in) :: x1, yi, y, w, t, tanh1, slabs1
    real(rp), intent(in) :: dslabs1_dNu0 ! 1 / Slabs1 * d Slabs1 / d Nu0 

    real(rp), intent(out) :: VL, dVL_dw, dVL_dn, dVL_dNu0

    real(rp) :: xj, zj, q, y2, u, v, up1, up2, dn1, dn2, dup1, &
     &          dup2, ddn1, ddn2, dy_dw, dy_dn, dSum_dw, dSum_dn, &
     &          slabs2

    q = 1.0_rp + dNu / Nu0

    y2 = y * y
    xj = x1 * dNu
    zj = x1 * (2.0_r8 * Nu0 + dNu)
    dn1 = zj * zj + y2
    up1 = y - zj * yi

! Van Vleck - Wieskopf (VVW) line shape with Voigt

    call simple_voigt ( xj, y, u, v )
    dup1 = up1 * OneOvSPi / dn1 + yi * v
    ddn2 = u + dup1
    slabs2 = slabs1 * tanh1
    VL = slabs2 * ddn2 * q            ! This is the Voigt + VVW correction

    dn2 = xj * xj + y2
    up2 = y + yi * xj

    dy_dw = y / w
    dup1 = dy_dw
    ddn1 = 2.0 * y * dy_dw
    dup2 = dy_dw
    ddn2 = 2.0 * y * dy_dw

    dSum_dw = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
   &          (dn2*dup2-up2*ddn2)/(dn2*dn2)

    dVL_dw = OneOvSPi * slabs2 * q * dSum_dw

    dy_dn = y * Log(300.0/t)
    dup1 = dy_dn
    ddn1 = 2.0 * y * dy_dn
    dup2 = dy_dn
    ddn2 = 2.0 * y * dy_dn
    dSum_dn = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
   &          (dn2*dup2-up2*ddn2)/(dn2*dn2)

    dVL_dn = OneOvSPi * slabs2 * q * dSum_dn

!    dup2 =  yi * x1               !  x1 = -dxj_dNu0
!    ddn2 = -2.0 * xj * x1         !  x1 = -dxj_dNu0
!    dSum_dNu0 = (dn2*dup2-up2*ddn2)/(dn2*dn2)
!    dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)

!    dVL_dNu0 = OneOvSPi * (dslabs1_dNu0 * q * Sum          + &
!              &         slabs2 * dq_dNu0 * Sum + &
!              &         slabs2 * q * dSum_dNu0)

!    dVL_dNu0 = OneOvSPi * slabs2 * q * dSum_dNu0
    dVL_dNu0 = VL * (dslabs1_dNu0 - 1.0_rp / Nu0) &
           & + OneOvSPi * slabs2 * q * ( &
           &  (-yi*x1*(xj*xj+y2)+2.0_rp*(y+yi*xj)*xj*x1)/(xj*xj+y2)**2 &
           & + (yi*x1*  dn1     -2.0_rp*   up1   *x1*zj)/dn1**2)

  end subroutine Voigt_Lorentz

  ! -------------------------------------------------  Slabs_prep  -----
  pure subroutine Slabs_prep ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, gamma, &
                      &   n1, n2, velCor, useYi, &
                      &   v0s, x1, y, yi, slabs1, dslabs1 )

! This function computes a single line type absorption coefficient
! WITH INTERFERENCE ! using predominantly data from the Pickett catalogue.

! ** UPDATED: Jul/3/97  To include Hugh Pumphrey's Pressure Shift effects
! >>2004-03-18 WV Snyder Use 1 - exp(-v0/300/Boltzmhz) in denominator instead
!                        of 1 - exp(-v0s/300/Boltzmhz).
! >>2005-06-16 WV Snyder Use nu0s/velCor instead of nu0s in Beta_v.

    use Physics, only: H_OVER_K, k, SpeedOfLight
    use Constants, only: Ln10, Sqrtln2, SqrtPi

! inputs:

    real(rp), intent(in) :: T        ! Temperature K
    real(r8), intent(in) :: M        ! Molecular mass amu
    real(r8), intent(in) :: V0       ! Line center frequency MHz
    real(r8), intent(in) :: El       ! Lower state energy cm-1
    real(r8), intent(in) :: W        ! Collision broadening parameter
                                     ! MHz/mbar at 300 K
    real(r8), intent(in) :: Ps       ! Pressure shift parameter in MHz/mbar
    real(rp), intent(in) :: P        ! Pressure mbar
    real(r8), intent(in) :: N        ! Temperature power dependence of w
    real(r8), intent(in) :: Ns       ! Temperature power dependence of ps
    real(r8), intent(in) :: I        ! Integrated spectral intensity
                                     ! Log(nm**2 MHz) at 300 K
    real(r8), intent(in) :: Q(3)     ! Logarithm of the partition function
                                     ! At 300 , 225 , and 150 K
    real(r8), intent(in) :: Delta    ! Delta interference coefficient at 300K 1/mb
    real(r8), intent(in) :: Gamma    ! Gamma               "
    real(r8), intent(in) :: N1       ! Temperature dependency of delta
    real(r8), intent(in) :: N2       ! Temperature dependency of gamma
    real(r8), intent(in) :: VelCor   ! Doppler velocity correction term
    logical, intent(in) :: UseYi     ! delta + gamma > 0.0

! outputs:

    real(r8), intent(out) :: V0s     ! Pressure shifted line position
    real(r8), intent(out) :: X1      ! Sqrt(Ln(2))/Doppler half width MHz
    real(r8), intent(out) :: Y       ! Sqrt(Ln(2))*collision width /
                                     !             doppler width
    real(r8), intent(out) :: Yi      ! Interference contribution
    real(r8), intent(out) :: Slabs1  ! Frequency independent piece of slabs
    real(r8), intent(out) :: Dslabs1 ! Derivative of slabs1 w.r.t. v0 / slabs1

!  The above outputs along with frequency offset are used with routine
!  SLABSWINT to compute a Single Line ABSorption in 1/Km units. With unit
!  mixing ratio.

! Internal constants:

!  i2abs    - converts intensity into absorption
!  dc       - sqrt(amu/K) used to calculate doppler width
!  boltzcm  - boltzmann constant cm-1/K = k / (hc) 1e6/100
!  boltzmhz - boltzmann constant MHz/K = k / h
!  sqrtln2  - sqrt(ln(2))

    real(rp), parameter :: I2abs = sqrtln2 / ( sqrtPi * 1.0e13 * k )
!   real(rp), parameter :: I2abs = 3.402155052e9_rp ! using above constants
!   real(rp), parameter :: I2abs = 3.402136078e9_rp ! Zvi's original value
    real(rp), parameter :: Dc = 3.58116514e-7_rp ! sqrt(1000 k ln 4 avogadro) / c
!   real(rp), parameter :: Dc = 3.58117369e-7_rp ! Zvi's original value
    real(rp), parameter :: BoltzMHz = 1.0_rp / H_over_k
    real(rp), parameter :: Boltzcm = boltzMHz / SpeedOfLight * 1.0e6 / 100.0
    real(rp), parameter :: Oned300 = 1.0_rp/300.0_rp

    real(rp), parameter :: LT2 = 2.35218251811136_rp      ! Log10(225)
    real(rp), parameter :: LT3 = 2.47712125471966_rp      ! Log10(300)
    real(rp), parameter :: LN300 = lt3 * ln10

    real(rp), parameter :: Tl1 = 0.176091259055681_rp     ! Log10(225/150)
    real(rp), parameter :: Tl2 = 0.124938736608300_rp     ! Log10(300/225)

! Internal data:

    real(rp) :: betae, betav, expd, expn, log_T, onedt
    real(rp) :: Q_Log_a, Q_Log_b, t3t, Wd, z1, z2

! The action begins here

    onedt = 1.0_rp / t
    log_T = log(t)
    t3t = ln300 - log_T ! log(300/T)

!{ $y_i = p \left( \delta \left( \frac{300}T \right)^{n_1} +
!                  \gamma \left( \frac{300}T \right)^{n_2} \right)$.

    yi = 0.0
    if ( useYi ) yi = p * (delta*exp(n1*t3t) + gamma*exp(n2*t3t))

!{ $w_d = \nu_0 d_c \sqrt{\frac{T}M}$.

    Wd = v0 * dc * Sqrt(t/m)

!{ $x_1 = \frac{\sqrt{\ln 2}}{w_d}$.
!  $\frac{\partial x_1}{\partial \nu_0} = -\frac{x_1}{\nu_0}$.

    x1 = real(sqrtln2,rp) / Wd

!{ $y = x_1 w p \left( \frac{300}T \right) ^n$.
!  $\frac{\partial y}{\partial \nu_0} = -\frac{y}{\nu_0}$.

    y = x1 * w * p * exp(n*t3t)

!{ $\nu_{0_s} = \nu_0 + p_s p \left( \frac{300}T \right) ^{n_s}$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = 0$.

    v0s = v0 + ps * p * exp(ns*t3t) ! VelCor is multiplied below

!{ $\beta_e = 10^{-4} \frac{h}k c\, e_l$.
!  $\beta_v = \frac{h}k \frac{\nu_{0_s}}{v_c}$.

    betae = el / boltzcm
    betav = v0s / boltzmhz

!{ Now $\nu_{0_s} = v_c \left[ \nu_0 + p_s p \left( \frac{300}T \right) ^{n_s} \right]$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = v_c$.

    v0s = velcor * v0s

    if ( t < 225.0_rp ) then
      q_log_b = (q(2)-q(3)) / tl1
      q_log_a = q(2) - q(1) - lt2 * q_log_b
    else
      q_log_b = (q(1)-q(2)) / tl2
      q_log_a = -lt3 * q_log_b
    end if
    q_log_b = 1.0 + q_log_b ! This is more useful below

    expd = EXP(-v0*(oned300/boltzmhz)) ! H
    expn = EXP(-betav*onedt) ! G
    z1 = 1.0 + expn          ! 1 + G
    z2 = 1.0 - expd          ! 1 - H

!{ $S = \frac{I_2 \, p \, 10^{i - a - b \log_{10} T
!   + \frac{\beta_e}{\ln 10}\left(\frac1{300}-\frac1T\right)}
!      (1+e^{-\frac{\beta_v}T})}
!   {T w_d \left(1 - e^{-\frac{h \nu_0}{300 k}}\right)} =
!  I_2 \, p \, e^{(i-a) \ln 10 -(b+1) \log T +
!    \beta_e \left( \frac1{300} - \frac1T \right)}
!  \frac{(1+G)} {w_d (1-H)}$, where
!  $G = e^{-\frac{\beta_v}T}$, $H = e^{-\frac{h \nu_0}{300 k}}$ and
!  $S =$ {\tt slabs1}.

    slabs1 = i2abs * p * &
      & exp((i - q_log_a)*ln10 - q_log_b * log_T + betae * (oned300 - onedt)) &
      & * z1 / (Wd * z2)

!{ $\frac1S\,\frac{\partial S}{\partial \nu_0} =
!   - \left[ \left( \frac{G}{(1+G)T}
!   + \frac{H}{300(1-H)} \right) \frac{h}k + \frac1{\nu_0} \right]$.

    dslabs1 = - ( ( expn / (t * z1) + expd / (300.0_rp * z2)) / &
      & boltzmhz + 1.0 / v0 )

  end subroutine Slabs_prep

  ! ------------------------------------------  Slabs_prep_struct  -----
  elemental subroutine Slabs_prep_struct ( T, P, Catalog, VelCor, Derivs, Slabs )
  ! Fill all the fields of the Slabs structure

    use SpectroscopyCatalog_m, only: Lines

    ! inputs:

    real(rp), intent(in) :: T        ! Temperature K
    real(rp), intent(in) :: P        ! Pressure
    type(catalog_t), intent(in) :: Catalog ! The spectroscopy
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction term, 
                                     ! 1 - losVel / C
    logical, intent(in) :: Derivs    ! "Setup for derivative calculations"

    ! output:

    type(slabs_struct), intent(inout) :: Slabs ! inout so as not to clobber
                                     ! pointer associations

    integer :: I ! A loop index
    integer :: L ! Index in the Lines array

    slabs%useYi = .false.
    !ocl independent
    !ocl temp(l)
    do i = 1, size(catalog%lines)
      l = catalog%lines(i)
      slabs%useYi = slabs%useYi .or. lines(l)%useYi
      slabs%s(i)%v0 = lines(l)%v0
      if ( associated(slabs%catalog%polarized) ) &
        & slabs%s(i)%polarized = slabs%catalog%polarized(i)
      if ( derivs ) then
        call slabs_prep_dT ( t, catalog%mass, &
          & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p, &
          & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
          & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
          & velCor, lines(l)%useYi, &
          & slabs%s(i)%v0s, slabs%s(i)%x1, slabs%s(i)%y, &
          & slabs%s(i)%yi, slabs%s(i)%slabs1, &
          & slabs%s(i)%dslabs1_dv0, &
          & slabs%d(i)%dv0s_dT, slabs%d(i)%dx1_dT, &
          & slabs%d(i)%dy_dT, slabs%d(i)%dyi_dT, &
          & slabs%d(i)%dslabs1_dT )
      else
        call slabs_prep ( t, catalog%mass, &
          & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p, &
          & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
          & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
          & velCor, lines(l)%useYi, &
          & slabs%s(i)%v0s, slabs%s(i)%x1, slabs%s(i)%y, &
          & slabs%s(i)%yi, slabs%s(i)%slabs1, &
          & slabs%s(i)%dslabs1_dv0 )
      end if
    end do ! i = 1, size(catalog%lines)

  end subroutine Slabs_prep_struct

  ! -----------------------------------  Slabs_prep_struct_offset  -----
  elemental subroutine Slabs_prep_struct_offset ( T, P, Catalog, VelCor, &
    & Derivs, Slabs, DV0, DW, DN )
  ! Fill all the fields of the Slabs structure

    use SpectroscopyCatalog_m, only: Lines

    ! inputs:

    real(rp), intent(in) :: T        ! Temperature K
    real(rp), intent(in) :: P        ! Pressure
    type(catalog_t), intent(in) :: Catalog ! The spectroscopy
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction term, 
                                     ! 1 - losVel / C
    logical, intent(in) :: Derivs    ! "Setup for derivative calculations"
    real(r8), intent(in) :: DV0, DW, DN  ! Offsets from catalog%v0, %w, %n
    ! output:

    type(slabs_struct), intent(inout) :: Slabs ! inout so as not to clobber
                                     ! pointer associations

    integer :: I ! A loop index
    integer :: L ! Index in the Lines array

    slabs%useYi = .false.
    !ocl independent
    !ocl temp(l)
    do i = 1, size(catalog%lines)
      l = catalog%lines(i)
      slabs%useYi = slabs%useYi .or. lines(l)%useYi
      slabs%s(i)%v0 = lines(l)%v0
      if ( derivs ) then
        call slabs_prep_dT ( t, catalog%mass, &
          & lines(l)%v0+dv0, lines(l)%el, lines(l)%w+dw, lines(l)%ps, p, &
          & lines(l)%n+dn, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
          & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
          & velCor, lines(l)%useYi, &
          & slabs%s(i)%v0s, slabs%s(i)%x1, slabs%s(i)%y, &
          & slabs%s(i)%yi, slabs%s(i)%slabs1, &
          & slabs%s(i)%dslabs1_dv0, &
          & slabs%d(i)%dv0s_dT, slabs%d(i)%dx1_dT, &
          & slabs%d(i)%dy_dT, slabs%d(i)%dyi_dT, &
          & slabs%d(i)%dslabs1_dT )
      else
        call slabs_prep ( t, catalog%mass, &
          & lines(l)%v0+dv0, lines(l)%el, lines(l)%w+dw, lines(l)%ps, p, &
          & lines(l)%n+dn, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
          & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
          & velCor, lines(l)%useYi, &
          & slabs%s(i)%v0s, slabs%s(i)%x1, slabs%s(i)%y, &
          & slabs%s(i)%yi, slabs%s(i)%slabs1, &
          & slabs%s(i)%dslabs1_dv0 )
      end if
    end do ! i = 1, size(catalog%lines)

  end subroutine Slabs_prep_struct_offset

  ! ----------------------------------------------  Slabs_prep_DT  -----
  pure subroutine Slabs_prep_dT ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, gamma, &
                         &   n1, n2, velCor, useYi, &
                         &   v0s, x1, y, yi, slabs1, dslabs1_dv0, &
                         &   dv0s_dT, dx1_dT, dy_dT, dyi_dT, dslabs1_dT )

! This function computes a single line type absorption coefficient
! WITH INTERFERENCE ! using predominantly data from the Pickett catalogue.
! Compute the derivatives with respect to temperature, too.

! ** UPDATED: Jul/3/97  To include Hugh Pumphrey's Pressure Shift effects

    use Physics, only: H_OVER_K, k, SpeedOfLight
    use Constants, only: Ln10, Sqrtln2, SqrtPi

! inputs:

    real(rp), intent(in) :: T        ! Temperature K
    real(r8), intent(in) :: M        ! Molecular mass amu
    real(r8), intent(in) :: V0       ! Line center frequency MHz
    real(r8), intent(in) :: El       ! Lower state energy cm-1
    real(r8), intent(in) :: W        ! Collision broadening parameter
                                     ! MHz/mbar at 300 K
    real(r8), intent(in) :: Ps       ! Pressure shift parameter in MHz/mbar
    real(rp), intent(in) :: P        ! Pressure mbar
    real(r8), intent(in) :: N        ! Temperature power dependence of w
    real(r8), intent(in) :: Ns       ! Temperature power dependence of ps
    real(r8), intent(in) :: I        ! Integrated spectral intensity
                                     ! Log(nm**2 MHz) at 300 K
    real(r8), intent(in) :: Q(3)     ! Logarithm of the partition function
                                     ! At 300 , 225 , and 150 K
    real(r8), intent(in) :: Delta    ! Delta interference coefficient at 300K 1/mb
    real(r8), intent(in) :: Gamma    ! Gamma               "
    real(r8), intent(in) :: N1       ! Temperature dependency of delta
    real(r8), intent(in) :: N2       ! Temperature dependency of gamma
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction term
    logical, intent(in) :: UseYi     ! delta + gamma > 0

! outputs:

    real(r8), intent(out) :: V0s     ! Pressure shifted line position
    real(r8), intent(out) :: X1      ! Sqrt(Ln(2))/Doppler half width MHz
    real(r8), intent(out) :: Y       ! Sqrt(Ln(2))*collision width /
                                     !             doppler width
    real(r8), intent(out) :: Yi      ! Interference contribution
    real(r8), intent(out) :: Slabs1  ! Frequency independent piece of slabs
    real(r8), intent(out) :: Dslabs1_dv0 ! Derivative of slabs1 w.r.t. v0 / slabs1

!  The above outputs along with frequency offset are used with routine
!  SLABSWINT to compute a Single Line ABSorption in 1/Km units. With unit
!  mixing ratio.

! Derivatives with respect to temperature:

    real(r8), intent(out) :: dv0s_dT    ! dv0s/dT
    real(r8), intent(out) :: dx1_dT     ! 1/x1 dx1/dT
    real(r8), intent(out) :: dy_dT      ! 1/y dy/dT
    real(r8), intent(out) :: dyi_dT     ! 1/yi dyi/dT
    real(r8), intent(out) :: dslabs1_dT ! 1/slabs1 dslabs1/dT

! Internal constants:

!  i2abs    - converts intensity into absorption
!  dc       - sqrt(amu/K) used to calculate doppler width
!  boltzcm  - boltzmann constant cm-1/K
!  boltzmhz - boltzmann constant MHz/K = k/h
!  sqrtln2  - sqrt(ln(2))

    real(rp), parameter :: I2abs = sqrtln2 / ( sqrtPi * 1.0e13 * k )
!   real(rp), parameter :: I2abs = 3.402155052e9_rp ! using above constants
!   real(rp), parameter :: I2abs = 3.402136078e9_rp ! Zvi's original value
    real(rp), parameter :: Dc = 3.58116514e-7_rp ! sqrt(1000 k ln 4 avogadro) / c
!   real(rp), parameter :: Dc = 3.58117369e-7_rp ! Zvi's original value
    real(rp), parameter :: BoltzMHz = 1.0_rp / H_over_k
    real(rp), parameter :: Boltzcm = boltzMHz / SpeedOfLight * 1.0e6 / 100.0
    real(rp), parameter :: Oned300 = 1.0_rp/300.0_rp

    real(rp), parameter :: LT2 = 2.35218251811136_rp      ! Log10(225)
    real(rp), parameter :: LT3 = 2.47712125471966_rp      ! Log10(300)
    real(rp), parameter :: LN300 = lt3 * ln10

    real(rp), parameter :: Tl1 = 0.176091259055681_rp     ! Log10(225/150)
    real(rp), parameter :: Tl2 = 0.124938736608300_rp     ! Log10(300/225)

! Internal data:

    real(rp) :: Betae, Betav, dBetav_dT, onedt, expn, expd
    real(rp) :: Q_Log_a, Q_Log_b ! Q_Log = a + b * log10(T)
    real(rp) :: Log_T         ! log(t)
    real(rp) :: t3t           ! log(300/t) = log(300) - log(t)
    real(rp) :: Wd, DWd_dT    ! dWd_dT is actually -dWd_dT/Wd
    real(rp) :: Z1, Z2        ! Temporaries

! The action begins here

    onedt = 1.0_rp / t
    log_t = log(t)
    t3t = ln300 - log_t  ! log(300/T)

!{ $y_i = p \left( \delta \left( \frac{300}T \right)^{n_1} +
!                  \gamma \left( \frac{300}T \right)^{n_2} \right)$.
!  $\frac{\partial y_i}{\partial T} = -\frac{p}T \left(
!                    n_1 \delta \left( \frac{300}T \right)^{n_1} +
!                    n_2 \gamma \left( \frac{300}T \right)^{n_2} \right)$.

    if ( useYi ) then
      z1 = delta*exp(n1*t3t)
      z2 = gamma*exp(n2*t3t)
      yi = ( z1 + z2 )
      dyi_dT = -onedt * ( n1 * z1 + n2 * z2 ) / yi ! 1/yi dyi/dT
      yi = p * yi
    else ! yi == 0.0
      ! If yi == 0.0, dyi_dT will necessarily be zero.  The 1/yi cancels
      ! a yi in a numerator where dyi_dT is used, so 0.0 is the correct
      ! result.  We don't need a fancy l'Hospital argument to justify it.
      yi = 0.0
      dyi_dT = 0.0
    end if

!{ $w_d = \nu_0 d_c \sqrt{\frac{T}M}$.  The $\nu_0$ term should
!  really be $\nu$.  We approximate $\nu$ by $\nu_0$ so that we can use
!  this routine outside the frequency loop.  Thus
!  $-\frac1{w_d}\frac{\partial w_d}{\partial T} = 
!   - \frac1{2 T}$.
!  $-\frac1{w_d}\frac{\partial w_d}{\partial T}$ is what's actually
!  useful later.

    Wd = v0 * dc * sqrt(t/m)
    dWd_dT = - 0.5 * onedt ! Actually -dWd_dT/Wd

!{ $x_1 = \frac{\sqrt{\ln 2}}{w_d}$.
!  $\frac1{x_1}\frac{\partial x_1}{\partial T} =
!   -\frac1{w_d} \frac{\partial w_d}{\partial T}
!   = -\frac1{2T}$.
!  We don't calculate $x$ = $x_1 ( \nu - \nu_{0_s} )$ here because it
!  depends on frequency.  Here's $\frac1x \frac{\partial x}{\partial T} =
!  \frac1{x_1}\frac{\partial x_1}{\partial T} - \frac1{\nu - \nu_{0_s}}
!  \frac{\partial \nu_{0_s}}{\partial T}$ anyway, for reference.
!  $\frac{\partial x_1}{\partial \nu_0} = -\frac{x_1}{\nu_0}$.

    x1 = real(sqrtln2,rp) / Wd
    dx1_dT = dWd_dT ! 1/x1 dx1/dT

!{ $y = x_1 w p \left( \frac{300}T \right)^n$.
!  $\frac1y \frac{\partial y}{\partial T} =
!    \left( \frac1{x_1} \frac{\partial x_1}{\partial T} - \frac{n}T \right)
!    = -\frac1{2T}(1+2n)$.
!  $\frac{\partial y}{\partial \nu_0} = -\frac{y}{\nu_0}$.

    y = x1 * w * p * exp(n*t3t)
    dy_dT = ( dx1_dT - n * onedt ) ! 1/y dy/dT

    if ( t < 225.0_rp ) then
      q_log_b = (q(2)-q(3)) / tl1
      q_log_a = q(2) - q(1) - lt2 * q_log_b
    else
      q_log_b = (q(1)-q(2)) / tl2
      q_log_a = -lt3 * q_log_b
    end if
    q_log_b = -q_log_b - 1.0 ! This is what's interesting later

!{ $\nu_{0_s} = \nu_0 + p_s p \left( \frac{300}T \right)^{n_s}$.
!  $\frac{\partial \nu_{0_s}}{\partial T} = \frac{-n_s}T ( \nu_{0_s} - \nu_0 )$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = 0$.

    if ( ps /= 0.0_r8 ) then
      v0s = ps * p * exp(ns*t3t)
      dv0s_dT = -ns * v0s * onedt
      v0s = v0 + v0s
    else
      v0s = v0
      dv0s_dT = 0.0
    end if

!{ $\beta_e = 10^{-4} \frac{h}k c\, e_l$. $\beta_v = \frac{h}k \nu_{0_s}$.
!  $\frac{\partial \beta_v}{\partial T} =
!    \frac{h}k \frac{\partial \nu_{0_s}}{\partial T}$.

    betae = el / boltzcm
    betav = v0s / boltzmhz ! should not be velocity corrected
    dBetav_dT = dv0s_dT / boltzmhz

!{ Now, $\nu_{0_s} = v_c \left[ \nu_0 + p_s p \left( \frac{300}T \right)^{n_s} \right]$.
!  $\frac{\partial \nu_{0_s}}{\partial T} = \frac{-n_s}T ( \nu_{0_s} - v_c \nu_0 )$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = v_c$.

    v0s = velcor * v0s
    dv0s_dT = velcor * dv0s_dT

!{ Write {\tt slabs1} $= \frac{I_2 \, p \, 10^{i - a - b \log_{10} T
!   + \frac{\beta_e}{\ln 10}\left(\frac1{300}-\frac1T\right)}
!      (1+e^{-\frac{\beta_v}T})}
!   {T w_d \left(1 - e^{\frac{\beta_v}{300}}\right)}$
!  as $S = f \frac{T^{-b-1} e^{-\frac{\beta_e}T} (1+G)}
!                                    {w_d}$, where
!  $f = \frac{I_2 \, p \, e^{(i-a) \ln 10 + \frac{\beta_e}{300}}}{1-H}$
!  is independent of T,
!  $H = e^{-\frac{h \nu_0}{300 k}}$ and $G = e^{-\frac{\beta_v}T}$.  Then
!  $\frac1S \frac{\partial S}{\partial T} =
!    \frac1T \left( -b -1 -G_1 \frac{\partial \beta_v}{\partial T} +
!     \frac1T \left[ \beta_e + G_1 \beta_v \right ] \right )
!    - \frac1{w_d}\frac{\partial w_d}{\partial T}$, where
!  $G_1 = \frac{G}{1+G}$.

    expd = EXP(-v0*(oned300/boltzmhz)) ! H
    expn = EXP(-betav*onedt)   ! G
    z1 = 1.0 + expn            ! 1 + G
    z2 = 1.0 - expd            ! 1 - H

    ! This is rearranged to reduce the number of references to "exp".
    slabs1 = i2abs * p * z1 / ( wd * z2 ) * &
      & exp((i-q_log_a)*ln10 + betae*(oned300 -onedt) + q_log_b * log_t )

    z1 = expn / z1             ! G1
    ! 1/slabs1 dslabs1/dT:
    dslabs1_dT = onedt * ( q_log_b - z1 * dBetav_dT + &
      & onedt * ( betae + z1 * betav ) ) + &
      & dWd_dT ! Remember dWd_dT is really -dWd_dT/Wd

!{ $\frac1S \,\frac{\partial S}{\partial \nu_0} =
!   -\left[ \left( \frac{G_1}T
!    + \frac{H_1}{300} \right) \frac{h}k + \frac1{\nu_0} \right] $
!   where $G_1 = \frac{G}{1+G}$ and $H_1 = \frac{H}{1-H}$.

    dslabs1_dv0 = - ( (z1 * onedt + expd / z2 * oned300) / boltzmhz + &
      & 1.0 / v0 )

  end subroutine Slabs_prep_dT

  ! ----------------------------------------  Get_GL_Slabs_Arrays  -----
  !ocl disjoint
  pure &
  subroutine Get_GL_Slabs_Arrays ( P_path, T_path, Vel_Rel, GL_Slabs, &
    & Do_1D, LineCenter, LineCenter_ix, LineWidth, LineWidth_ix, &
    & LineWidth_TDep, LineWidth_TDep_ix, T_der_flags )

    use Molecules, only: IsExtinction
    use SpectroscopyCatalog_m, only: Lines

    real(rp), intent(in) :: p_path(:) ! Pressure in hPa or mbar
    real(rp), intent(in) :: t_path(:)

    real(rp), intent(in) :: Vel_Rel   ! Vel_Z / speedOfLight

    ! GL_Slabs needs to have been created by AllocateSlabs
    type (slabs_struct), intent(inout) :: GL_Slabs(:,:)

    logical, intent(in) :: Do_1D

    ! Line parameter offsets from catalog (path x molecule) -- intent(in):
    real(rp), optional, intent(in) :: LineCenter(:,:), LineWidth(:,:), &
      & LineWidth_TDep(:,:)
    ! Which molecules are to be offset, and where are they in Line....  Zero
    ! means no offset, otherwise, second subscript for Line... above.
    integer, optional, pointer :: LineCenter_ix(:), LineWidth_ix(:), &
      & LineWidth_TDep_ix(:)
    logical, intent(in), optional :: t_der_flags(:) ! do derivatives if present

!  ----------------
!  Local variables:
!  ----------------

    type(Catalog_T), pointer :: Catalog
    integer :: i, j, k, n, n_sps, nl, no_ele
    logical :: DoCenter, DoWidth, DoWidth_TDep, Offset, Temp_Der
    real(r8) :: DV0, DW, DN  !  Offsets to center, width, width_TDep

    real(rp) :: vel_z_correction

! Begin code:

    doCenter = .false.; doWidth = .false.; doWidth_TDep = .false.
    if ( present(lineCenter) .and. present(lineCenter_ix) ) &
      & doCenter = size(lineCenter) > 0 .and. associated(lineCenter_ix)
    if ( present(lineWidth) .and. present(lineWidth_ix) ) &
      & doWidth = size(lineWidth) > 0 .and. associated(lineWidth_ix)
    if ( present(lineWidth_TDep) .and. present(lineWidth_TDep_ix) ) &
      & doWidth_TDep = size(lineWidth_TDep) > 0 .and. associated(lineWidth_TDep_ix)
    offset = doCenter .or. doWidth .or. doWidth_TDep

    no_ele = size(p_path)
    n_sps = size(gl_slabs,2)
    n = no_ele
    if ( Do_1D ) n = n / 2

    ! opposite sign convention here from ATBD
    Vel_z_correction = 1.0_rp - vel_rel

    do i = 1, n_sps

      catalog => gl_slabs(1,i)%catalog ! gl_slabs(:,i)%catalog are all the same
      gl_slabs(:,i)%useYi = any(lines(catalog%lines)%useYi)

      nl = Size(catalog%Lines)
      if ( nl == 0 ) cycle

      if ( isExtinction(catalog%molecule) ) cycle

      do j = 1, n
        temp_der = present(t_der_flags)
        if ( temp_der ) temp_der = t_der_flags(j)
        if ( offset ) then
          dv0 = 0.0; dw = 0.0; dn = 0.0
          if ( doCenter ) then
            if ( lineCenter_ix(i) /= 0 ) dv0 = lineCenter(j,lineCenter_ix(i))
          end if
          if ( doWidth ) then
            if ( lineWidth_ix(i) /= 0 ) dw = lineWidth(j,lineWidth_ix(i))
          end if
          if ( doWidth_TDep ) then
            if ( lineWidth_TDep_ix(i) /= 0 ) &
              dn = lineWidth_TDep(j,lineWidth_TDep_ix(i))
          end if
          call slabs_prep_struct_offset ( t_path(j), p_path(j), catalog, &
            & Vel_z_correction, temp_der, gl_slabs(j,i), dv0, dw, dn )
        else
          call slabs_prep_struct ( t_path(j), p_path(j), catalog, &
            &                      Vel_z_correction, temp_der, gl_slabs(j,i) )
        end if
      end do ! j = 1, n

      if ( Do_1D ) then
        ! fill in grid points on other side with above value
        !ocl temp(k)
        do j = no_ele, no_ele/2+1, -1
          k = no_ele - j + 1
          gl_slabs(j,i)%s%v0s         = gl_slabs(k,i)%s%v0s
          gl_slabs(j,i)%s%x1          = gl_slabs(k,i)%s%x1
          gl_slabs(j,i)%s%y           = gl_slabs(k,i)%s%y
          gl_slabs(j,i)%s%yi          = gl_slabs(k,i)%s%yi 
          gl_slabs(j,i)%s%slabs1      = gl_slabs(k,i)%s%slabs1 
          gl_slabs(j,i)%s%dslabs1_dv0 = gl_slabs(k,i)%s%dslabs1_dv0
        end do ! j = no_ele, no_ele/2+1, -1

        if ( present(t_der_flags) ) then
          !ocl temp(k)
          do j = no_ele, no_ele/2+1, -1
            if ( t_der_flags(j) ) then ! do derivative stuff
              k = no_ele - j + 1
              gl_slabs(j,i)%d%dv0s_dT    = gl_slabs(k,i)%d%dv0s_dT
              gl_slabs(j,i)%d%dx1_dT     = gl_slabs(k,i)%d%dx1_dT
              gl_slabs(j,i)%d%dy_dT      = gl_slabs(k,i)%d%dy_dT
              gl_slabs(j,i)%d%dyi_dT     = gl_slabs(k,i)%d%dyi_dT
              gl_slabs(j,i)%d%dslabs1_dT = gl_slabs(k,i)%d%dslabs1_dT
            end if
          end do ! j = no_ele, no_ele/2+1, -1
        end if
      end if

    end do              ! On i = 1, n_sps

  end subroutine Get_GL_Slabs_Arrays

!=====================================================================

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: slabs_sw_m.f90,v 2.67 2018/04/19 01:59:16 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module SLABS_SW_M

! $Log: slabs_sw_m.f90,v $
! Revision 2.67  2018/04/19 01:59:16  vsnyder
! Compute address of allocatable/deallocatable for tracking.  Remove USE
! statements for unused names.
!
! Revision 2.66  2016/10/24 22:16:38  vsnyder
! Make Slabs allocatable instead of a pointer
!
! Revision 2.65  2015/03/28 02:11:31  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.64  2014/09/05 21:27:29  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.63  2013/05/09 01:02:48  vsnyder
! Add useYi to dump
!
! Revision 2.62  2011/11/11 00:42:06  vsnyder
! Use IsExtinction array from Molecules module
!
! Revision 2.61  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.60  2009/05/13 20:03:02  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.59  2008/10/03 16:30:48  livesey
! Added EXTINCTIONV2
!
! Revision 2.58  2008/05/20 00:23:50  vsnyder
! Receive Vel/C instead of Vel
!
! Revision 2.57  2008/02/29 01:57:37  vsnyder
! Use MLSKinds instead of MLSCommon
!
! Revision 2.56  2007/12/04 23:40:12  vsnyder
! Don't look for polarized if it's not allocated
!
! Revision 2.55  2007/05/23 22:41:49  vsnyder
! Change line data from struct of arrays to array of structs to improve
! cache locality.
!
! Revision 2.54  2006/12/04 21:17:28  vsnyder
! Reorganize FullForwardModel to use automatic arrays instead of allocating
! pointer arrays.  Requires testing for zero size instead of testing for
! associated in several subsidiary procedures.
!
! Revision 2.53  2006/09/01 00:59:45  vsnyder
! "Catalog" argument of AllocateSlabs needs TARGET attribute so that
! slabs(i)%catalog does not become undefined when AllocateOneSlabs returns
!
! Revision 2.52  2006/07/29 03:02:11  vsnyder
! Send callers module name from AllocateSlabs to AllocateOneSlabs
!
! Revision 2.51  2006/05/05 22:20:58  vsnyder
! Remove duplicate USE statements
!
! Revision 2.50  2006/03/25 00:27:46  vsnyder
! Avoid dividing by zeroes that weren't avoided in the previous revision
!
! Revision 2.49  2006/01/26 03:05:51  vsnyder
! Avoid dividing by zero
!
! Revision 2.48  2005/09/17 00:48:09  vsnyder
! Don't look at an array that might not be there, plus some cannonball polishing
!
! Revision 2.47  2005/09/03 01:21:33  vsnyder
! Spectral parameter offsets stuff
!
! Revision 2.46  2005/08/03 18:02:31  vsnyder
! Some spectroscopy derivative stuff, finish v0s modification
!
! Revision 2.45  2005/07/06 02:17:21  vsnyder
! Revisions for spectral parameter derivatives
!
! Revision 2.44  2005/06/09 02:34:16  vsnyder
! Move stuff from l2pc_pfa_structures to slabs_sw_m
!
! Revision 2.43  2005/03/29 01:58:17  vsnyder
! Make stuff pure
!
! Revision 2.42  2004/12/28 00:26:40  vsnyder
! Remove unreferenced declaration
!
! Revision 2.41  2004/12/13 20:55:36  vsnyder
! Make Slabs_Prep and Slabs_Prep_dT public.  Add Slabs_Prep_Struct.  Polish
! some TeXnicalities.  Revise Slabswint_dT and Slabswint_Lines_dT not to
! compute interference if |yi| < 1.0e-6.  Added UseYi argument to Slabs_Prep
! and Slabs_Prep_dT.  Use Slabs_Prep_Struct from Get_GL_Slabs_Arrays.
!
! Revision 2.40  2004/09/23 20:08:47  vsnyder
! Finish correcting divide by zero
!
! Revision 2.39  2004/09/16 22:16:21  vsnyder
! Avoid dividing by zero in Slabswint_dT also
!
! Revision 2.38  2004/09/16 20:24:23  vsnyder
! Avoid dividing by zero in Slabswing_Lines_dT
!
! Revision 2.37  2004/09/01 01:14:48  vsnyder
! Correct 'not_used_here' routine
!
! Revision 2.36  2004/08/05 20:59:32  vsnyder
! Don't do any calculations for gl_slabs with no lines
!
! Revision 2.35  2004/05/11 02:52:43  vsnyder
! Remove USE for Pi, which isn't referenced
!
! Revision 2.34  2004/04/24 02:26:54  vsnyder
! Move Voigt stuff to its own module
!
! Revision 2.33  2004/04/20 00:48:06  vsnyder
! Only use Taylor really close to the origin
!
! Revision 2.32  2004/04/19 21:02:19  vsnyder
! Use Taylor instead of CDrayson near the origin
!
! Revision 2.31  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.30  2004/04/06 23:40:21  vsnyder
! Do slabs_prep where derivatives not requested in get_gl_slabs_arrays
! instead of doing nothing.
!
! Revision 2.29  2004/04/02 00:59:24  vsnyder
! Get catalog from slabs structure
!
! Revision 2.28  2004/03/30 02:25:08  vsnyder
! Comment out call to slabs_prep_dt until n1==0 etc are worked out
!
! Revision 2.27  2004/03/27 03:35:27  vsnyder
! Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
! line centers and line widths around.  Write slabs_lines and slabswint_lines
! to get sum of beta over all lines; put slabs_struct instead of its components
! in the calling sequence.
!
! Revision 2.26  2004/03/20 03:17:44  vsnyder
! Steps along the way toward analytic temperature derivatives
!
! Revision 2.24  2003/07/09 22:46:24  vsnyder
! Futzing
!
! Revision 2.23  2003/07/08 00:09:18  vsnyder
! Inlined several functions
!
! Revision 2.22  2003/07/04 02:49:03  vsnyder
! Simplify interface to Get_GL_Slabs_Arrays
!
! Revision 2.21  2003/06/18 14:45:00  bill
! added subsetting feature for T-ders
!
! Revision 2.20  2003/06/13 21:28:20  bill
! fixed/improved some bugs with line shape derivative computations
!
! Revision 2.19  2003/05/19 19:58:07  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.18  2003/05/16 23:53:05  livesey
! Now uses molecule indices rather than spectags
!
! Revision 2.17  2003/05/09 19:25:31  vsnyder
! Expect T+DT instead of T and DT separately in Get_GL_Slabs_Arrays
!
! Revision 2.16  2003/05/05 23:00:26  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.15.2.2  2003/02/27 00:57:20  vsnyder
! Cosmetic changes, get rid of declared but unused variables
!
! Revision 2.15.2.1  2003/02/13 17:29:26  bill
! abs coeff obeys detailed balance
!
! Revision 2.15  2003/01/16 19:41:42  jonathan
! tested version: in 1D case, compute only each element along the LOS path before tangent point, and fill otherside accordingly
!
! Revision 2.14  2003/01/16 19:08:43  jonathan
! testing
!
! Revision 2.13  2003/01/16 18:50:20  jonathan
! For 1D FWM compute first element along the LOS path then fill other grid points with value of the first grid point
!
! Revision 2.12  2003/01/16 18:04:12  jonathan
! add Do_1D option to get_gl_slabs_arrays
!
! Revision 2.11  2003/01/10 21:55:26  vsnyder
! Move SpeedOfLight from Geometry to Units
!
! Revision 2.10  2002/12/20 20:22:59  vsnyder
! Cosmetic changes
!
! Revision 2.9  2002/12/03 00:34:23  vsnyder
! Test optional argument presence before using them
!
! Revision 2.8  2002/10/08 17:08:06  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.7  2002/10/02 21:06:03  vsnyder
! Get SpeedOfLight from Geometry module
!
! Revision 2.6  2002/09/12 23:00:04  vsnyder
! Cosmetic changes, move USEs from module scope to procedure scope
!
! Revision 2.5  2002/08/05 17:51:15  jonathan
! debug
!
! Revision 2.4  2001/12/14 23:43:44  zvi
! Modification for Grouping concept
!
! Revision 2.3  2001/11/30 01:18:11  zvi
! Correcting a minor bug
!
! Revision 2.1  2001/10/17 22:01:00  zvi
! Eliminate computation of: ns
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.4.2.4  2001/09/12 21:38:54  zvi
! Added CVS stuff
!
! Revision 1.4.2.3  2001/09/12 00:05:44  livesey
! Corrected sign of velocity correction
!
! Revision 1.4.2.2  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
! Revision 1.1  2001/01/31 18:12:06  Z.Shippony
! Initial conversion to Fortran 90
@


2.67
log
@Compute address of allocatable/deallocatable for tracking.  Remove USE
statements for unused names.
@
text
@d331 1
a331 1
    real(rp), intent(in), optional :: dslabs1_dNu0                        
d334 1
a334 1
    real(rp), intent(out) :: dSwI_dNu0  ! 1 / Slabs1 * d Slabs1 / d Nu0
d384 2
a385 3
!    if (present(dslabs1_dNu0)) dSwI_dNu0 = dslabs1_dNu0*vvw + slabs2*dvvw_dv0
    if (present(dslabs1_dNu0)) dSwI_dNu0 = swi * (dslabs1_dNu0 &
                   - 1.0_r8/Nu0) + slabs2*q*(du_dv0 + yi * dv_dv0)
d2461 1
a2461 1
    real(r8), intent(out) :: Dslabs1_dv0 ! Derivative of slabs1 w.r.t. v0
d2634 2
a2635 2
!{ $\frac{\partial S}{\partial \nu_0} =
!   -S \left[ \left( \frac{G_1}T \frac{\partial \nu_{0_s}}{\partial \nu_0}
d2637 1
a2637 1
!   where $H_1 = \frac{H}{1-H}$.
d2639 1
a2639 1
    dslabs1_dv0 = -slabs1 * ( (z1 * onedt + expd / z2 * oned300) / boltzmhz + &
d2773 1
a2773 1
       "$Id: slabs_sw_m.f90,v 2.66 2016/10/24 22:16:38 vsnyder Exp $"
d2783 4
@


2.66
log
@Make Slabs allocatable instead of a pointer
@
text
@d96 1
a96 1
    type (slabs_struct), intent(inout) :: slabs ! Slabs to allocate
d119 1
a119 1
!     if ( stat == 0 .and. nl > 0 ) addr = transfer(c_loc(slabs%s(1)), addr)
d124 1
a124 1
!       if ( stat == 0 .and. nl > 0 ) addr = transfer(c_loc(slabs%d(1)), addr)
d153 1
a153 1
    type (slabs_struct), dimension(:,:), allocatable :: Slabs
d165 3
a167 3
!     if ( i == 0 ) then
!       if ( size(slabs) > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
!     end if
d200 1
a200 1
    type (slabs_struct), intent(inout) :: slabs ! Slabs to deallocate
d210 1
a210 1
!       if ( s > 0 ) addr = transfer(c_loc(slabs%s(1)), addr)
d217 1
a217 1
!       if ( s > 0 ) addr = transfer(c_loc(slabs%d(1)), addr)
d228 1
a228 1
    type (slabs_struct), dimension(:,:), allocatable :: Slabs
d236 1
a236 1
!     if ( s > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
d2774 1
a2774 1
       "$Id: slabs_sw_m.f90,v 2.65 2015/03/28 02:11:31 vsnyder Exp $"
d2784 3
@


2.65
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d153 1
a153 1
    type (slabs_struct), dimension(:,:), pointer :: Slabs
d165 3
a167 3
    if ( i == 0 ) then
      if ( size(slabs) > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
    end if
d169 1
a169 1
      & storage_size(slabs) / 8, address=addr )
d228 1
a228 1
    type (slabs_struct), dimension(:,:), pointer :: Slabs
d236 1
a236 1
    if ( s > 0 ) addr = transfer(c_loc(slabs(1,1)), addr)
d2774 1
a2774 1
       "$Id: slabs_sw_m.f90,v 2.64 2014/09/05 21:27:29 vsnyder Exp $"
d2784 3
@


2.64
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d95 1
d103 1
d118 2
d121 1
a121 1
      & storage_size(slabs%s) / 8 )
d124 1
d126 1
a126 1
      & storage_size(slabs%d) / 8 )
d151 1
d160 1
d164 4
d169 1
a169 1
      & storage_size(slabs) / 8 )
d199 1
d203 1
d209 2
d212 1
a212 1
      call test_deallocate ( stat, inName, "Slabs%S", s )
d216 2
d219 1
a219 1
      call test_deallocate ( stat, inName, "Slabs%D", s )
d227 1
d230 1
d235 2
d238 1
a238 1
    call test_deallocate ( i, moduleName, 'slabs', s )
d2774 1
a2774 1
       "$Id: slabs_sw_m.f90,v 2.63 2013/05/09 01:02:48 vsnyder Exp $"
d2784 3
@


2.63
log
@Add useYi to dump
@
text
@d116 2
a117 1
    call test_allocate ( stat, inName, "Slabs%S", (/ 1 /), (/ nl /) )
d120 2
a121 1
      call test_allocate ( stat, inName, "Slabs%D", (/ 1 /), (/ nl /) )
d157 2
a158 1
    call test_allocate ( i, caller, 'Slabs', (/1,1/), (/no_ele,size(catalog)/) )
d191 1
a191 1
    integer :: Stat
d195 1
d197 1
a197 1
      call test_deallocate ( stat, inName, "Slabs%S" )
d200 1
d202 1
a202 1
      call test_deallocate ( stat, inName, "Slabs%S" )
d209 1
a209 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Deallocate
d212 1
a212 1
    integer :: I
d215 1
d217 1
a217 2
    if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'slabs' )
d2753 1
a2753 1
       "$Id: slabs_sw_m.f90,v 2.62 2011/11/11 00:42:06 vsnyder Exp $"
d2763 3
@


2.62
log
@Use IsExtinction array from Molecules module
@
text
@d220 1
a220 1
    use Output_m, only: Output
d240 3
a242 1
      call display_string ( lit_indices(the_slabs_struct%catalog%molecule), advance='yes' )
d2748 1
a2748 1
       "$Id: slabs_sw_m.f90,v 2.61 2009/06/23 18:26:11 pwagner Exp $"
d2758 3
@


2.61
log
@Prevent Intel from optimizing ident string away
@
text
@d2624 1
a2624 1
    use Molecules, only: L_Extinction, L_ExtinctionV2
d2684 1
a2684 1
      if ( catalog%molecule == l_extinction .or. catalog%molecule == l_extinctionv2 ) cycle
d2746 1
a2746 1
       "$Id: read_apriori.f90 is it here $"
d2756 3
@


2.60
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d2743 1
d2745 3
a2747 5
  !---------------------------- RCS Ident Info -------------------------------
    character (len=*), parameter :: IdParm = &
      & "$Id: slabs_sw_m.f90,v 2.59 2008/10/03 16:30:48 livesey Exp $"
    character ( len=len(idParm)) :: Id = idParm
  !---------------------------------------------------------------------------
d2749 1
d2751 1
d2756 3
@


2.59
log
@Added EXTINCTIONV2
@
text
@d18 1
a18 1
  use Units, only: SqrtPi
d2126 1
a2126 1
    use Units, only: Ln10, Sqrtln2, SqrtPi
d2401 1
a2401 1
    use Units, only: Ln10, Sqrtln2, SqrtPi
d2746 1
a2746 1
      & "$Id: slabs_sw_m.f90,v 2.58 2008/05/20 00:23:50 vsnyder Exp $"
d2755 3
@


2.58
log
@Receive Vel/C instead of Vel
@
text
@d2624 1
a2624 1
    use Molecules, only: L_Extinction
d2684 1
a2684 1
      if ( catalog%molecule == l_extinction ) cycle
d2746 1
a2746 1
      & "$Id: slabs_sw_m.f90,v 2.57 2008/02/29 01:57:37 vsnyder Exp $"
d2755 3
@


2.57
log
@Use MLSKinds instead of MLSCommon
@
text
@d2620 1
a2620 1
  subroutine Get_GL_Slabs_Arrays ( P_path, T_path, Vel_z, GL_Slabs, &
a2624 1
    use Physics, only: SpeedOfLight
d2630 1
a2630 1
    real(rp), intent(in) :: vel_z     ! Meters per second
d2674 1
a2674 1
    Vel_z_correction = 1.0_rp - vel_z / speedOfLight
d2746 1
a2746 1
      & "$Id: slabs_sw_m.f90,v 2.56 2007/12/04 23:40:12 vsnyder Exp $"
d2755 3
@


2.56
log
@Don't look for polarized if it's not allocated
@
text
@d16 1
a16 1
  use MLSCommon, only: R8, RP
d2747 1
a2747 1
      & "$Id: slabs_sw_m.f90,v 2.55 2007/05/23 22:41:49 vsnyder Exp $"
d2756 3
@


2.55
log
@Change line data from struct of arrays to array of structs to improve
cache locality.
@
text
@d128 1
d732 1
a732 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d1006 1
a1006 1
        if ( slabs%catalog%polarized(l) ) cycle
d1144 1
a1144 1
        if ( noPolarized .and. slabs(k)%catalog%polarized(l) ) cycle
d1239 1
a1239 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d1643 1
a1643 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d1716 1
a1716 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d1801 1
a1801 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d1929 1
a1929 1
      if ( noPolarized .and. slabs%catalog%polarized(l) ) cycle
d2303 2
a2304 1
      slabs%s(i)%polarized = slabs%catalog%polarized(i)
d2747 1
a2747 1
      & "$Id: slabs_sw_m.f90,v 2.54 2006/12/04 21:17:28 vsnyder Exp $"
d2756 4
@


2.54
log
@Reorganize FullForwardModel to use automatic arrays instead of allocating
pointer arrays.  Requires testing for zero size instead of testing for
associated in several subsidiary procedures.
@
text
@d28 23
d54 3
a56 18
    real(r8), dimension(:), pointer :: v0s => NULL()
    real(r8), dimension(:), pointer :: x1 => NULL()
    real(r8), dimension(:), pointer :: y => NULL()
    real(r8), dimension(:), pointer :: yi => NULL()
    real(r8), dimension(:), pointer :: slabs1 => NULL()
    ! Contribution of dx1_dv0 and dy_dv0 in d Beta / d Nu0 cancel.
    ! See Slabs_DSpectral.
!   real(r8), dimension(:), pointer :: dx1_dv0 => NULL()
!   real(r8), dimension(:), pointer :: dy_dv0 => NULL()
    real(r8), dimension(:), pointer :: dslabs1_dv0 => NULL() ! / slabs1
    logical :: UseYi ! Are any yi > 0?
    ! For temperature derivatives.  Most are logarithmic derivatives,
    ! so dz_dT really means 1/z dz_dT.
    real(r8), dimension(:), pointer :: dv0s_dT => NULL()    ! not * 1 / v0s
    real(r8), dimension(:), pointer :: dx1_dT => NULL()     ! / x1
    real(r8), dimension(:), pointer :: dy_dT => NULL()      ! / y
    real(r8), dimension(:), pointer :: dyi_dT => NULL()     ! / yi
    real(r8), dimension(:), pointer :: dslabs1_dT => NULL() ! / slabs1
d74 1
d94 1
a94 1
    use Allocate_Deallocate, only: ALLOCATE_TEST
d97 1
a97 1
    character(len=*), intent(in) :: InName
d103 1
a103 1
    integer :: NL
d115 2
a116 6
    call Allocate_test ( slabs%v0s,         nl, 'v0s',         inName )
    call Allocate_test ( slabs%x1,          nl, 'x1',          inName )
    call Allocate_test ( slabs%y,           nl, 'y',           inName )
    call Allocate_test ( slabs%yi,          nl, 'yi',          inName )
    call Allocate_test ( slabs%slabs1,      nl, 'slabs1',      inName )
    call Allocate_test ( slabs%dslabs1_dv0, nl, 'dslabs1_dv0', inName )
d118 2
a119 5
      call Allocate_test ( slabs%dv0s_dT,    nl, 'dv0s_dT',    inName )
      call Allocate_test ( slabs%dx1_dT,     nl, 'dx1_dT',     inName )
      call Allocate_test ( slabs%dy_dT,      nl, 'dy_dT',      inName )
      call Allocate_test ( slabs%dyi_dT,     nl, 'dyi_dT',     inName )
      call Allocate_test ( slabs%dslabs1_dT, nl, 'dslabs1_dT', inName )
d122 6
a127 6
      slabs%v0s = 0.0_r8
      slabs%x1 = 0.0_r8
      slabs%y = 0.0_r8
      slabs%yi = 0.0_r8
      slabs%slabs1 = 0.0_r8
      slabs%dslabs1_dv0 = 0.0_r8
d129 5
a133 5
        slabs%dv0s_dT = 0.0_r8
        slabs%dx1_dT = 0.0_r8
        slabs%dy_dT = 0.0_r8
        slabs%dyi_dT = 0.0_r8
        slabs%dslabs1_dT = 0.0_r8
d183 1
a183 1
    use Allocate_Deallocate, only: DEALLOCATE_TEST
d187 2
d190 8
a197 11
    call Deallocate_test ( slabs%v0s,         'v0s',         inName )
    call Deallocate_test ( slabs%x1,          'x1',          inName )
    call Deallocate_test ( slabs%y,           'y',           inName )
    call Deallocate_test ( slabs%yi,          'yi',          inName )
    call Deallocate_test ( slabs%slabs1,      'slabs1',      inName )
    call Deallocate_test ( slabs%dslabs1_dv0, 'dslabs1_dv0', inName )
    call Deallocate_test ( slabs%dv0s_dT,     'dv0s_dT',     inName )
    call Deallocate_test ( slabs%dx1_dT,      'dx1_dT',      inName )
    call Deallocate_test ( slabs%dy_dT,       'dy_dT',       inName )
    call Deallocate_test ( slabs%dyi_dT,      'dyi_dT',      inName )
    call Deallocate_test ( slabs%dslabs1_dT,  'dslabs1_dT',  inName )
d240 12
a251 12
      call dump ( the_slabs_struct%v0s(:nl), name='v0s' )
      call dump ( the_slabs_struct%x1(:nl), name='x1' )
      call dump ( the_slabs_struct%y(:nl), name='y' )
      call dump ( the_slabs_struct%yi(:nl), name='yi' )
      call dump ( the_slabs_struct%slabs1(:nl), name='slabs1' )
      call dump ( the_slabs_struct%dslabs1_dv0(:nl), name='dslabs1_dv0' )
      if ( associated (the_slabs_struct%dslabs1_dT) ) then
        call dump ( the_slabs_struct%dv0s_dT(:nl), name='dv0s_dT' )
        call dump ( the_slabs_struct%dx1_dT(:nl), name='dx1_dT' )
        call dump ( the_slabs_struct%dy_dT(:nl), name='dy_dT' )
        call dump ( the_slabs_struct%dyi_dT(:nl), name='dyi_dT' )
        call dump ( the_slabs_struct%dslabs1_dT(:nl), name='dslabs1_dT' )
d398 1
a398 1
    do l = 1, size(slabs%catalog%lines)
d400 4
a403 4
      nu0 = slabs%v0s(l)
      x1 = slabs%x1(l)
      yi = slabs%yi(l)
      y = slabs%y(l)
d405 2
a406 2
      slabs1 = slabs%slabs1(l)
      dslabs1_dNu0 = slabs%dslabs1_dv0(l)
d729 1
a729 1
    do l = 1, size(slabs%catalog%lines)
d733 3
a735 3
      nu0s = slabs%v0s(l)
      x1 = slabs%x1(l)
      y = slabs%y(l)
d740 1
a740 1
      r = 1.0 / lines(slabs%catalog%lines(l))%v0
d746 1
a746 1
      g = slabs%slabs1(l) * tanh1 * nu * r
d761 1
a761 1
        & SwI_up * slabs%dslabs1_dv0(l) - & ! remember dslabs1_dv0 is divided by slabs1
d778 2
a779 1
    use Voigt_m, only: D_Real_Simple_Voigt
d805 2
a806 1
    call D_Real_Simple_Voigt ( x1*delta, y, da, y*dy_dT, u, du )
a964 1
    use SpectroscopyCatalog_m, only: Lines
d992 4
a995 4
      do l = 1, size(slabs%catalog%lines)
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
d998 2
a999 2
        beta = beta + slabs%slabs1(l) * &
          &           real(nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d1004 1
a1004 1
      do l = 1, size(slabs%v0s)
d1006 3
a1008 3
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
d1011 2
a1012 2
        beta = beta + slabs%slabs1(l) * &
          &           real(nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d1021 2
a1022 1
  elemental &
a1028 1
    use SpectroscopyCatalog_m, only: Lines
d1030 1
d1052 1
a1052 2
    real(rp) :: Sigma   ! Nu+v0s
    real(rp) :: SigmaX1 ! sigma * x1
d1063 1
a1063 1
    do l = 1, size(slabs%catalog%lines)
d1065 1
a1065 3
      if ( noPolarized ) then
        if ( slabs%catalog%polarized(l) ) cycle
      end if
d1067 8
a1074 6
      v0s = slabs%v0s(l)
      x1 = slabs%x1(l)
      y = slabs%y(l)
      dv0s_dT = slabs%dv0s_dT(l)
      dx1_dT = slabs%dx1_dT(l)
      dy_dT =slabs%dy_dT(l)
d1078 1
a1078 2
      sigma = nu + v0s
      sigmaX1 = sigma * x1
a1080 4
      sa = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * tanh1
!     sb = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * tanh1
!     sa = sb * u
!     sb = sb * OneOvSPi * y * d
a1082 3
!     beta = beta + sa + sb

      c = slabs%dSlabs1_dT(l) + dtanh_dT
a1084 1
!     dBeta_dT = dBeta_dT + sa * ( c + du / u ) &
d1093 81
d1236 1
a1236 1
    do l = 1, size(slabs%catalog%lines)
d1240 5
a1244 5
      dslabs1_dNu0 = slabs%dslabs1_dv0(l)
      dv0s_dT = slabs%dv0s_dT(l)
      dx1_dT = slabs%dx1_dT(l)
      dy_dT = slabs%dy_dT(l)
      v0s = slabs%v0s(l)
d1246 2
a1247 2
      x1 = slabs%x1(l)
      y = slabs%y(l)
d1258 1
a1258 1
      r = 1.0 / lines(slabs%catalog%lines(l))%v0
d1265 2
a1266 2
      g = slabs%slabs1(l) * q * tanh1
      c = slabs%dSlabs1_dT(l) + dtanh_dT
d1392 1
a1392 1
    call D_Simple_Voigt ( a, y, da, y*dy_dT, u, v, du, dv )
a1594 1
    use SpectroscopyCatalog_m, only: Lines
d1641 1
a1641 1
    do l = 1, size(slabs%v0s)
d1643 4
a1646 4
      v0s = slabs%v0s(l)
      x1 = slabs%x1(l)
      y = slabs%y(l)
      yi = slabs%yi(l)
d1653 2
a1654 2
        beta = beta + slabs%slabs1(l) * &
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d1657 2
a1658 2
        beta = beta + slabs%slabs1(l) * &
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
a1672 1
    use SpectroscopyCatalog_m, only: Lines
d1713 1
a1713 1
    do l = 1, size(slabs%catalog%lines)
d1717 8
a1724 8
      v0s = slabs%v0s(l)
      x1 = slabs%x1(l)
      y = slabs%y(l)
      yi = slabs%yi(l)
      dv0s_dT = slabs%dv0s_dT(l)
      dx1_dT = slabs%dx1_dT(l)
      dy_dT = slabs%dy_dT(l)
      dyi_dT = slabs%dyi_dT(l)
d1728 1
a1728 1
      call D_Simple_Voigt ( a, y, da, y*dy_dT, u, v, du, dv )
d1734 1
a1734 2
      c1 = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * &
        & tanh1
d1738 1
a1738 1
      c3 = slabs%dSlabs1_dT(l) + dtanh_dT
d1798 1
a1798 1
    do l = 1, size(slabs%catalog%lines)
d1802 4
a1805 4
      nu0s = slabs%v0s(l)
      x1 = slabs%x1(l)
      yi = slabs%yi(l)
      y = slabs%y(l)
d1810 1
a1810 1
      r = 1.0 / lines(slabs%catalog%lines(l))%v0
d1816 1
a1816 1
      g = slabs%slabs1(l) * tanh1 * nu * r
d1834 1
a1834 1
          & SwI_up * slabs%dslabs1_dv0(l) - & ! remember dslabs1_dv0 is divided by slabs1
d1850 1
a1850 1
          & SwI_up * slabs%dslabs1_dv0(l) - & ! remember dslabs1_dv0 is divided by slabs1
d1926 1
a1926 1
    do l = 1, size(slabs%catalog%lines)
d1930 6
a1935 6
      dslabs1_dNu0 = slabs%dslabs1_dv0(l)
      dv0s_dT = slabs%dv0s_dT(l)
      dx1_dT = slabs%dx1_dT(l)
      dy_dT = slabs%dy_dT(l)
      dyi_dT = slabs%dyi_dT(l)
      v0s = slabs%v0s(l)
d1937 3
a1939 3
      x1 = slabs%x1(l)
      yi = slabs%yi(l)
      y = slabs%y(l)
d1951 1
a1951 1
      r = 1.0 / lines(slabs%catalog%lines(l))%v0
d1959 1
a1959 1
      g = slabs%slabs1(l) * q * tanh1
d1961 1
a1961 1
      c3 = slabs%dSlabs1_dT(l) + dtanh_dT
d2301 2
d2309 6
a2314 6
          & slabs%v0s(i), slabs%x1(i), slabs%y(i), &
          & slabs%yi(i), slabs%slabs1(i), &
          & slabs%dslabs1_dv0(i), &
          & slabs%dv0s_dT(i), slabs%dx1_dT(i), &
          & slabs%dy_dT(i), slabs%dyi_dT(i), &
          & slabs%dslabs1_dT(i) )
d2321 3
a2323 3
          & slabs%v0s(i), slabs%x1(i), slabs%y(i), &
          & slabs%yi(i), slabs%slabs1(i), &
          & slabs%dslabs1_dv0(i) )
d2359 1
d2366 6
a2371 6
          & slabs%v0s(i), slabs%x1(i), slabs%y(i), &
          & slabs%yi(i), slabs%slabs1(i), &
          & slabs%dslabs1_dv0(i), &
          & slabs%dv0s_dT(i), slabs%dx1_dT(i), &
          & slabs%dy_dT(i), slabs%dyi_dT(i), &
          & slabs%dslabs1_dT(i) )
d2378 3
a2380 3
          & slabs%v0s(i), slabs%x1(i), slabs%y(i), &
          & slabs%yi(i), slabs%slabs1(i), &
          & slabs%dslabs1_dv0(i) )
d2713 6
a2718 6
          gl_slabs(j,i)%v0s         = gl_slabs(k,i)%v0s
          gl_slabs(j,i)%x1          = gl_slabs(k,i)%x1
          gl_slabs(j,i)%y           = gl_slabs(k,i)%y
          gl_slabs(j,i)%yi          = gl_slabs(k,i)%yi 
          gl_slabs(j,i)%slabs1      = gl_slabs(k,i)%slabs1 
          gl_slabs(j,i)%dslabs1_dv0 = gl_slabs(k,i)%dslabs1_dv0
d2726 5
a2730 5
              gl_slabs(j,i)%dv0s_dT    = gl_slabs(k,i)%dv0s_dT
              gl_slabs(j,i)%dx1_dT     = gl_slabs(k,i)%dx1_dT
              gl_slabs(j,i)%dy_dT      = gl_slabs(k,i)%dy_dT
              gl_slabs(j,i)%dyi_dT     = gl_slabs(k,i)%dyi_dT
              gl_slabs(j,i)%dslabs1_dT = gl_slabs(k,i)%dslabs1_dT
d2745 1
a2745 1
      & "$Id: slabs_sw_m.f90,v 2.53 2006/09/01 00:59:45 vsnyder Exp $"
d2754 5
@


2.53
log
@"Catalog" argument of AllocateSlabs needs TARGET attribute so that
slabs(i)%catalog does not become undefined when AllocateOneSlabs returns
@
text
@d2563 1
a2563 1
    real(rp), optional, pointer :: LineCenter(:,:), LineWidth(:,:), &
d2586 1
a2586 1
      & doCenter = associated(lineCenter) .and. associated(lineCenter_ix)
d2588 1
a2588 1
      & doWidth = associated(lineWidth) .and. associated(lineWidth_ix)
d2590 1
a2590 1
      & doWidth_TDep = associated(lineWidth_TDep) .and. associated(lineWidth_TDep_ix)
d2671 1
a2671 1
      & "$Id: slabs_sw_m.f90,v 2.52 2006/07/29 03:02:11 vsnyder Exp $"
d2680 4
@


2.52
log
@Send callers module name from AllocateSlabs to AllocateOneSlabs
@
text
@d144 1
a144 1
    type (catalog_t), dimension(:), intent(in) :: Catalog
d2671 1
a2671 1
      & "$Id: slabs_sw_m.f90,v 2.51 2006/05/05 22:20:58 vsnyder Exp $"
d2680 3
@


2.51
log
@Remove duplicate USE statements
@
text
@d83 1
a83 1
  subroutine AllocateOneSlabs ( Slabs, Catalog, TempDer )
d88 1
d106 6
a111 6
    call Allocate_test ( slabs%v0s,         nl, 'v0s',         ModuleName )
    call Allocate_test ( slabs%x1,          nl, 'x1',          ModuleName )
    call Allocate_test ( slabs%y,           nl, 'y',           ModuleName )
    call Allocate_test ( slabs%yi,          nl, 'yi',          ModuleName )
    call Allocate_test ( slabs%slabs1,      nl, 'slabs1',      ModuleName )
    call Allocate_test ( slabs%dslabs1_dv0, nl, 'dslabs1_dv0', ModuleName )
d113 5
a117 5
      call Allocate_test ( slabs%dv0s_dT,    nl, 'dv0s_dT',    ModuleName )
      call Allocate_test ( slabs%dx1_dT,     nl, 'dx1_dT',     ModuleName )
      call Allocate_test ( slabs%dy_dT,      nl, 'dy_dT',      ModuleName )
      call Allocate_test ( slabs%dyi_dT,     nl, 'dyi_dT',     ModuleName )
      call Allocate_test ( slabs%dslabs1_dT, nl, 'dslabs1_dT', ModuleName )
d156 1
a156 1
        call AllocateOneSlabs ( slabs(j,i), catalog(i), TempDer )
d2671 1
a2671 1
      & "$Id: slabs_sw_m.f90,v 2.50 2006/03/25 00:27:46 vsnyder Exp $"
d2680 3
@


2.50
log
@Avoid dividing by zeroes that weren't avoided in the previous revision
@
text
@a1110 3
    use SpectroscopyCatalog_m, only: Lines
    use Voigt_m, only: Simple_Voigt

d2670 1
a2670 1
      & "$Id: slabs_sw_m.f90,v 2.49 2006/01/26 03:05:51 vsnyder Exp $"
d2679 3
@


2.49
log
@Avoid dividing by zero
@
text
@d819 7
a825 4
    sb = slabs1 * real(nu / v0,rp) * tanh1
    sa = sb * u
    sb = sb * OneOvSPi * y * d
    Slabs = sa + sb
d859 2
a860 1
    dSlabs_dT = sa * ( c + du / u ) + &
d939 2
a940 1
    dSlabs_dT = sa * ( c + du / u ) + &
d1018 2
a1019 1
  elemental subroutine Slabs_Lines_dT ( Nu, Slabs, Tanh1, dTanh_dT, &
d1079 7
a1085 4
      sb = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * tanh1
      sa = sb * u
      sb = sb * OneOvSPi * y * d
      beta = beta + sa + sb
d1089 2
a1090 1
      dBeta_dT = dBeta_dT + sa * ( c + du / u ) &
d1204 2
a1205 1
        &      + sa * ( c + du / u ) &
d1487 2
a1488 1
    sb = g * yi * v
d1491 2
a1492 1
    Slabswint = sa + sb - sc + sd
d1498 4
a1501 2
    dSlabS_dT = sa * ( c + du / u ) &
      &       + sb * ( c + dv / v ) &
d1900 2
a1901 1
        sb = g * yi * v
d1903 2
a1904 1
        beta_up = sa + sb - sc + sd
d1909 4
a1912 2
          &      + sa * ( c3 + du / u ) &
          &      + sb * ( c3 + dv / v ) &
d1937 2
a1938 1
          &      + sa * ( c3 + du / u ) &
d2673 1
a2673 1
      & "$Id: slabs_sw_m.f90,v 2.48 2005/09/17 00:48:09 vsnyder Exp $"
d2682 3
@


2.48
log
@Don't look at an array that might not be there, plus some cannonball polishing
@
text
@d1344 2
a1345 1
    sb = c * yi * v
d1349 1
a1349 1
    Slabswint = sa + sb - sc + sd
d1391 3
d1396 2
a1397 2
    dSlabS_dT = sa * ( c + du / u ) &
      &       + sb * ( c + dv / v ) &
d1404 1
a1404 1
! elemental &
d1580 2
a1581 1
  elemental subroutine Slabswint_Lines_dT ( Nu, Slabs, tanh1, dTanh_dT, &
d1656 3
d1660 1
a1660 1
        sb = c1 * yi * v
d1662 1
a1662 1
        beta = beta + sa + sd - sc + sb
d1665 2
a1666 7
          &      + sa * ( c3 + du / u ) &
          &      + sb * ( c3 + dv / v ) &
          &      - sc * ( c3 + dd + dyi_dT + dx1_dT + dv0s_dT / sigma ) &
          &      + sd * ( c3 + dd + dy_dT )
      else
        beta = beta + sa + sd
        dBeta_dT = dBeta_dT + sa * ( c3 + du / u )  + sd * ( c3 + dd + dy_dT )
d2653 1
a2653 1
      & "$Id: slabs_sw_m.f90,v 2.47 2005/09/03 01:21:33 vsnyder Exp $"
d2662 3
@


2.47
log
@Spectral parameter offsets stuff
@
text
@d36 1
a36 1
    ! Contribution of dx1_dv0 and dy_dv0 in d Beta / d Nu0 cancels out.
a85 1
    use SpectroscopyCatalog_m, only: Catalog_T
a139 1
    use SpectroscopyCatalog_m, only: Catalog_T
d151 1
a151 1
    call test_allocate ( i, moduleName, 'Slabs', (/1,1/), (/no_ele,size(catalog)/) )
d2184 1
a2184 1
    use SpectroscopyCatalog_m, only: Catalog_T, Lines
d2240 1
a2240 1
    use SpectroscopyCatalog_m, only: Catalog_T, Lines
d2529 1
a2529 1
    use SpectroscopyCatalog_m, only: Catalog_T, Lines
d2595 10
a2604 6
          if ( doCenter .and. lineCenter_ix(i) /= 0 ) &
            dv0 = lineCenter(j,lineCenter_ix(i))
          if ( doWidth .and. lineWidth_ix(i) /= 0 ) &
            dw = lineWidth(j,lineWidth_ix(i))
          if ( doWidth_TDep .and. lineWidth_TDep_ix(i) /= 0 ) &
            dn = lineWidth_TDep(j,lineWidth_TDep_ix(i))
d2650 1
a2650 1
      & "$Id: slabs_sw_m.f90,v 2.46 2005/08/03 18:02:31 vsnyder Exp $"
d2659 3
@


2.46
log
@Some spectroscopy derivative stuff, finish v0s modification
@
text
@d140 1
a140 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error
d153 1
a153 2
    if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, Caller, &
      & MLSMSG_Allocate//"slabs" )
d2524 4
a2527 3
  pure subroutine Get_GL_Slabs_Arrays ( P_path, T_path, Vel_z, GL_Slabs, &
    & Do_1D, t_der_flags, LineCenter, LineCenter_ix, LineWidth, LineWidth_ix, &
    & LineWidth_TDep, LineWidth_TDep_ix )
d2538 1
a2538 1
    ! GL_Slabs needs to have been created by L2PC_pfa_structures%AllocateSlabs
a2541 1
    logical, intent(in), optional :: t_der_flags(:) ! do derivatives if present
d2544 1
a2544 1
    real, optional, pointer :: LineCenter(:,:), LineWidth(:,:), &
d2550 1
d2648 1
a2648 1
      & "$Id: slabs_sw_m.f90,v 2.45 2005/07/06 02:17:21 vsnyder Exp $"
d2657 3
@


2.45
log
@Revisions for spectral parameter derivatives
@
text
@d66 1
a66 1
  public :: Slabs_Prep, Slabs_Prep_Struct, Slabs_Prep_dT
d2130 2
a2131 2
!{ $\nu_{0_s} = v_c \left[ \nu_0 + p_s p \left( \frac{300}T \right) ^{n_s} \right]$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = v_c$.
d2140 4
d2238 56
a2412 13
!{ $\nu_{0_s} = v_c \left[ \nu_0 + p_s p \left( \frac{300}T \right)^{n_s} \right]$.
!  $\frac{\partial \nu_{0_s}}{\partial T} = \frac{-n_s}T ( \nu_{0_s} - v_c \nu_0 )$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = v_c$.

    if ( ps /= 0.0_r8 ) then
      v0s = velCor * ps * p * exp(ns*t3t)
      dv0s_dT = -ns * v0s * onedt
      v0s = velCor * v0 + v0s
    else
      v0s = velCor * v0
      dv0s_dT = 0.0
    end if

d2455 13
d2476 7
d2518 1
a2518 1
    dslabs1_dv0 = -slabs1 * ( (z1 * onedt * velCor + expd / z2 * oned300) / boltzmhz + &
d2526 2
a2527 1
                             &     Do_1D, t_der_flags )
d2544 8
d2558 2
a2559 1
    logical :: Temp_Der
d2565 9
d2595 14
a2608 2
        call slabs_prep_struct ( t_path(j), p_path(j), catalog, &
          &                      Vel_z_correction, temp_der, gl_slabs(j,i) )
d2648 1
a2648 1
      & "$Id: slabs_sw_m.f90,v 2.44 2005/06/09 02:34:16 vsnyder Exp $"
d2657 3
@


2.44
log
@Move stuff from l2pc_pfa_structures to slabs_sw_m
@
text
@d36 5
a40 3
    real(r8), dimension(:), pointer :: dx1_dv0 => NULL()
    real(r8), dimension(:), pointer :: dy_dv0 => NULL()
    real(r8), dimension(:), pointer :: dslabs1_dv0 => NULL()
d63 8
a70 5
  public :: Get_GL_Slabs_Arrays,                                          &
         &  Slabs, Slabs_dT, Slabs_Lines, Slabs_Lines_dT, Slabs_Prep,     &
         &  Slabs_Prep_Struct, Slabs_Prep_dT, Slabswint, Slabswint_dT,    &
         &  Slabswint_Lines, Slabswint_Lines_dT, Voigt_Lorentz,           &
         &  DVoigt_Spectral, DVoigt_Spectral_Lines
a92 1
    integer :: myl
a103 1
    myL = nl
d106 6
a111 8
    call Allocate_test ( slabs%v0s,         myl, 'v0s',         ModuleName )
    call Allocate_test ( slabs%x1,          myl, 'x1',          ModuleName )
    call Allocate_test ( slabs%y,           myl, 'y',           ModuleName )
    call Allocate_test ( slabs%yi,          myl, 'yi',          ModuleName )
    call Allocate_test ( slabs%slabs1,      myl, 'slabs1',      ModuleName )
    call Allocate_test ( slabs%dx1_dv0,     myl, 'dx1_dv0',     ModuleName )
    call Allocate_test ( slabs%dy_dv0,      myl, 'dy_dv0',      ModuleName )
    call Allocate_test ( slabs%dslabs1_dv0, myl, 'dslabs1_dv0', ModuleName )
d113 5
a117 5
      call Allocate_test ( slabs%dv0s_dT,    myl, 'dv0s_dT',    ModuleName )
      call Allocate_test ( slabs%dx1_dT,     myl, 'dx1_dT',     ModuleName )
      call Allocate_test ( slabs%dy_dT,      myl, 'dy_dT',      ModuleName )
      call Allocate_test ( slabs%dyi_dT,     myl, 'dyi_dT',     ModuleName )
      call Allocate_test ( slabs%dslabs1_dT, myl, 'dslabs1_dT', ModuleName )
d119 1
a119 1
    if ( nl == 0 ) then
a124 2
      slabs%dx1_dv0 = 0.0_r8
      slabs%dy_dv0 = 0.0_r8
a192 2
    call Deallocate_test ( slabs%dx1_dv0,     'dx1_dv0',     inName )
    call Deallocate_test ( slabs%dy_dv0,      'dy_dv0',      inName )
a245 2
      call dump ( the_slabs_struct%dx1_dv0(:nl), name='dx1_dv0' )
      call dump ( the_slabs_struct%dy_dv0(:nl), name='dy_dv0' )
d305 2
a306 1
    real(rp), intent(out) :: SwI, dSwI_dw,dSwI_dn,dSwI_dNu0               
d313 1
a313 1
    call simple_voigt(x,y,u,v)  
d357 1
a357 1
    if (present(dslabs1_dNu0)) dSwI_dNu0 = swi * (dslabs1_dNu0/slabs1 &
d410 1
a410 1
      call simple_voigt(x,y,u,v)  
d502 270
d812 3
a814 1
!    \left( V(a,y) + V(b,y) \right)$.  $b$ is always huge, so we approximate
d828 5
a832 5
!  i L(a,y)$, where $V(a,y)$ is the Voigt function ({\tt u} above) and $L(a,y)$
!  is the Lorentz function.  All we want for $S$ is its real part, so we don't
!  need $L(a,y)$ for $S$.  For $\frac{\partial S}{\partial T}$ we want the real
!  part of the derivative; this requires the real part of the derivative of
!  $w(z)$, not just Voigt.
d865 91
d1092 128
d1248 16
a1263 6
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$,
!  $D_1 = \frac1{\sigma^2 x_1^2 + y^2}$ and $D_2 = \frac1{a^2 + y^2}$.
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!  \tanh\left(\frac{h \nu}{2 k T}\right)
!   \left( V(a,y) + \frac{(y - \sigma x_1 y_i) D_1}{\sqrt{\pi}}
!     + \frac{y_i a D_2}{\sqrt{\pi}} \right)$.
d1278 1
a1278 1
    use Voigt_m, only: D_Real_Simple_Voigt
d1298 2
a1299 3
    real(rp) :: D1              ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: D2              ! 1 / (a**2 + y**2)
    real(rp) :: DD1, DD2        ! 1/D1 d(D1)/dT, 1/D2 d(D2)/dT, 
d1302 1
a1302 1
    real(rp) :: DU              ! du/dT
d1306 1
a1306 1
    real(rp) :: U               ! Voigt
d1312 1
a1312 1
    call D_Real_Simple_Voigt ( a, y, da, y*dy_dT, u, du )
d1319 4
a1322 3
!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$,
!  $D_1 = \frac1{\sigma^2 x_1^2 + y^2}$ and $D_2 = \frac1{a^2 + y^2}$.
d1325 15
a1339 2
!   \left( V(a,y) + \frac{(y - \sigma x_1 y_i) D_1}{\sqrt{\pi}}
!     + \frac{y_i a D_2}{\sqrt{\pi}} \right)$.
d1344 1
a1344 2
    d1 = 1.0_rp / ( sigmaX1**2 + y2 )
    d2 = 1.0_rp / ( a * a + y2 )
d1347 5
a1351 5
    c = c * OneOvSPi
    sb = c * y * d1
    sc = c * sigmaX1 * yi * d1
    sd = c * yi * d2
    Slabswint = sa + sb - sc + sd * a
d1353 1
a1353 13
!{ The Fadeeva function $w(z)$, where $z = a + i y$, can be written as $V(a,y) +
!  i L(a,y)$, where $V(a,y)$ is the Voigt function ({\tt u} above) and $L(a,y)$
!  is the Lorentz function.  All we want for $S$ is its real part, so we don't
!  need $L(a,y)$ for $S$. For $\frac{\partial S}{\partial T}$ we want the real
!  part of the derivative; this requires the real part of the derivative of
!  $w(z)$, not just Voigt.
!
!  Write $S = S_a + S_b - S_c + S_d$ where
!  $S_a = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) V(a,y)$,
!  $S_b = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{y D_1}{\sqrt{\pi}}$,
!  $S_c = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{\sigma x_1 y_i D_1}{\sqrt{\pi}}$, and
!  $S_d = S_1 \frac{\nu}{\nu_0} \tanh\left(\frac{h \nu}{2 k T}\right) \frac{a y_i D_2}{\sqrt{\pi}}$.\\
!  Then
d1364 1
a1364 2
!   \frac1{D_1}\frac{\partial D_1}{\partial T} +
!   \frac1y \frac{\partial y}{\partial T}$,\\
d1368 1
a1368 1
!   \frac1{D_1}\frac{\partial D_1}{\partial T} +
d1375 3
a1377 5
!   \frac1{D_2}\frac{\partial D_2}{\partial T} +
!   \frac1{y_i}\frac{\partial y_i}{\partial T} +
!   \frac1{a}\frac{\partial a}{\partial T}$
!   , where\\
!  $\frac1{D_1}\frac{\partial D_1}{\partial T} = -2 D_1 \left( x_1 \sigma \left( x_1 \frac{\partial \nu_{0_s}}{\partial T} +
a1378 2
!     y \frac{\partial y}{\partial T} \right)$ and
!  $\frac1{D_2}\frac{\partial D_2}{\partial T} = -2 D_2 \left( a \frac{\partial a}{\partial T} +
d1380 2
a1381 1
!  Notice that the first two terms of
d1385 1
a1385 1
!    $\frac1{S_d}\frac{\partial S_d}{\partial T}$ are the same,
a1386 3
!    $\frac1{S_b}\frac{\partial S_b}{\partial T}$ and
!    $\frac1{S_c}\frac{\partial S_c}{\partial T}$ are the same, and
!  the fourth terms of
d1389 1
a1389 1
!  For $\Re \frac{\partial w(z)}{\partial T}$ we need
d1394 5
a1398 6
    dd1 = -2.0_rp * d1 * ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
    dd2 = -2.0_rp * d2 * ( a * da + y2 * dy_dT )
    dSlabs_dT = sa * ( c + du / u ) &
      &       + sb * ( c + dd1 + dy_dT ) &
      &       - sc * ( c + dd1 + dyi_dT + dx1_dT + dv0s_dT / sigma ) &
      &       + sd * ( a * ( c + dd2 + dyi_dT ) + da )
d1402 102
d1531 21
a1551 6
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$,
!  $D_1 = \frac1{\sigma^2 x_1^2 + y^2}$ and $D_2 = \frac1{a^2 + y^2}$.
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0}
!  \tanh\left(\frac{h \nu}{2 k T}\right)
!   \left( V(a,y) + \frac{(y - \sigma x_1 y_i) D_1}{\sqrt{\pi}}
!     + \frac{y_i a D_2}{\sqrt{\pi}} \right)$.
d1586 1
a1586 1
    use Voigt_m, only: D_Real_Simple_Voigt
d1602 3
a1604 4
    real(rp) :: C1, C2          ! Common terms
    real(rp) :: D1              ! 1 / (SigmaX1**2 + y**2)
    real(rp) :: D2              ! 1 / (a**2 + y**2)
    real(rp) :: DD1, DD2        ! 1/D1 d(D1)/dT, 1/D2 d(D2)/dT, 
d1607 1
a1607 1
    real(rp) :: DU              ! du / dT
d1616 1
a1616 1
    real(rp) :: U               ! Voigt
d1641 1
a1641 1
      call D_Real_Simple_Voigt ( a, y, da, y*dy_dT, u, du )
d1646 1
a1646 2
      d1 = 1.0_rp / ( sigmaX1**2 + y2 )
      d2 = 1.0_rp / ( a * a + y2 )
d1649 1
d1651 3
a1653 4
      c1 = c1 * OneOvSPi
      sb = c1 * y * d1
      c2 = slabs%dSlabs1_dT(l) + dtanh_dT
      dd1 = -2.0_rp * d1 * ( sigmaX1 * ( x1 * dv0s_dT + sigmaX1 * dx1_dT ) + y2 * dy_dT )
d1655 3
a1657 3
        sc = c1 * sigmaX1 * yi * d1
        sd = c1 * yi * d2
        beta = beta + sa + sb - sc + sd * a
d1659 231
a1889 1
        dd2 = -2.0_rp * d2 * ( a * da + y2 * dy_dT )
d1892 19
a1910 4
          &      + sa * ( c2 + du / u ) &
          &      + sb * ( c2 + dd1 + dy_dT ) &
          &      - sc * ( c2 + dd1 + dyi_dT + dx1_dT + dv0s_dT / sigma ) &
          &      + sd * ( a * (c2 + dd2 + dyi_dT) + da )
d1912 22
a1933 2
        beta = beta + sa + sb
        dBeta_dT = dBeta_dT + sa * ( c2 + du / u )
d1936 2
d1940 1
a1940 1
  end subroutine Slabswint_Lines_dT
d1956 2
a1957 1
    real(rp), intent(in) :: x1, yi, y, w, t, tanh1, slabs1, dslabs1_dNu0
d2015 1
a2015 1
    dVL_dNu0 = VL * (dslabs1_dNu0 / slabs1 - 1.0_rp / Nu0) &
d2033 1
d2069 1
a2069 1
    real(r8), intent(out) :: Dslabs1 ! Derivative of slabs1 w.r.t. v0
d2079 2
a2080 2
!  boltzcm  - boltzmann constant cm-1/K
!  boltzmhz - boltzmann constant MHz/K
d2094 1
d2108 1
a2108 1
    t3t = lt3 * ln10 - log_T ! log(300/T)
a2115 5
!{ $\nu_{0_s} = v_c \left[ \nu_0 + p_s p \left( \frac{300}T \right) ^{n_s} \right]$.
!  $\frac{\partial \nu_{0_s}}{\partial \nu_0} = v_c$.

    v0s = velCor * ( v0 + ps * p * exp(ns*t3t) )

d2130 7
a2136 1
!{ $\beta_e = 10^{-4} \frac{h}k c\, e_l$. $\beta_v = \frac{h}k \nu_{0_s}$.
d2140 1
d2149 1
a2149 1
    q_log_b = -1.0 - q_log_b ! This is more useful below
d2167 1
a2167 1
      & exp((i - q_log_a)*ln10 + q_log_b * log_T + betae * (oned300 - onedt)) &
d2170 3
a2172 4
!{ $\frac{\partial S}{\partial \nu_0} =
!   -S \left[ \left( \frac{G_1}T \frac{\partial \nu_{0_s}}{\partial \nu_0}
!   + \frac{H_1}{300} \right) \frac{h}k + \frac1{\nu_0} \right]$ where
!   $G_1 = \frac{G}{1 + G}$ and $H_1 = \frac{H}{1 - H}$.
d2174 1
a2174 1
    dslabs1 = -slabs1 * ( ( expn / (t * z1) * velCor + expd / (300.0_rp * z2)) / &
a2205 2
      slabs%dx1_dv0(i) = 0.0
      slabs%dy_dv0(i) = 0.0
d2313 1
d2325 1
a2325 1
    real(rp) :: Z1, Z2 ! Temps
d2331 1
a2331 1
    t3t = lt3 * ln10 - log_t  ! log(300/T)
a2455 2
!{\newpage

a2523 2
          gl_slabs(j,i)%dx1_dv0     = gl_slabs(k,i)%dx1_dv0
          gl_slabs(j,i)%dy_dv0      = gl_slabs(k,i)%dy_dv0
d2550 1
a2550 1
      & "$Id: slabs_sw_m.f90,v 2.43 2005/03/29 01:58:17 vsnyder Exp $"
d2559 3
@


2.43
log
@Make stuff pure
@
text
@d1 11
d17 1
d24 36
a69 3
  character (len=*), parameter :: IdParm = &
    & "$Id: slabs_sw_m.f90,v 2.42 2004/12/28 00:26:40 vsnyder Exp $"
  character ( len=len(idParm)) :: Id = idParm
d77 214
a378 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a599 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a662 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a915 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a978 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a1307 1
    use L2PC_PFA_STRUCTURES, only: Slabs_Struct
a1588 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d1678 5
d1689 3
@


2.42
log
@Remove unreferenced declaration
@
text
@d23 1
a23 1
    & "$Id: slabs_sw_m.f90,v 2.41 2004/12/13 20:55:36 vsnyder Exp $"
d33 1
a33 1
  subroutine dVoigt_spectral ( dNu, Nu0, x1, yi, y, w, t, tanh1, slabs1, SwI, &
d108 1
a108 1
  subroutine dVoigt_spectral_Lines ( dNu, Slabs, t, tanh1, &
a130 1
    integer, pointer :: CatLines(:)  ! slabs%catalog%lines
a140 1
    catLines => slabs%catalog%lines
d145 1
a145 1
    do l = 1, size(catLines)
d151 1
a151 1
      w = lines(catLines(l))%w
d210 1
a210 1
  real(rp) function Slabs ( Nu, v0, v0s, x1, tanh1, slabs1, y )
d249 1
a249 1
  subroutine Slabs_dT ( Nu, v0, v0s, x1, tanh1, slabs1, y, &
d340 1
a340 1
  function Slabs_Lines ( Nu, Slabs, tanh1, NoPolarized ) result ( Beta )
a356 1
    integer, pointer :: CatLines(:)  ! slabs%catalog%lines
a369 1
    catLines => slabs%catalog%lines
d371 1
a371 1
      do l = 1, size(catLines)
d378 1
a378 1
          &           real(nu / lines(catLines(l))%v0, rp) * tanh1 * &
d391 1
a391 1
          &           real(nu / lines(catLines(l))%v0, rp) * tanh1 * &
d400 1
a400 1
  subroutine Slabs_Lines_dT ( Nu, Slabs, Tanh1, dTanh_dT, &
a419 1
    integer, pointer :: CatLines(:)  ! slabs%catalog%lines
a438 1
    catLines => slabs%catalog%lines
d442 1
a442 1
    do l = 1, size(catLines)
d461 1
a461 1
      sb = slabs%slabs1(l) * real(nu / lines(catLines(l))%v0,rp) * tanh1
d478 1
a478 1
  real(rp) function Slabswint ( Nu, v0, v0s, x1, tanh1, slabs1, y, yi )
d520 1
a520 1
  subroutine Slabswint_dT ( Nu, v0, v0s, x1, tanh1, slabs1, y, yi, &
d658 1
a658 1
  function Slabswint_Lines ( Nu, Slabs, tanh1, NoPolarized ) result ( Beta )
a675 1
    integer, pointer :: CatLines(:)  ! slabs%catalog%lines
a692 1
    catLines => slabs%catalog%lines
d706 1
a706 1
          &           real(Nu / lines(catLines(l))%v0, rp) * tanh1 * &
d710 1
a710 1
          &           real(Nu / lines(catLines(l))%v0, rp) * tanh1 * &
d718 1
a718 1
  subroutine Slabswint_Lines_dT ( Nu, Slabs, tanh1, dTanh_dT, &
a742 1
    integer, pointer :: CatLines(:)  ! slabs%catalog%lines
a764 1
    catLines => slabs%catalog%lines
d767 1
a767 1
    do l = 1, size(catLines)
d789 1
a789 1
      c1 = slabs%slabs1(l) * real(nu / lines(catLines(l))%v0,rp) * &
d819 1
a819 1
  subroutine Voigt_Lorentz ( dNu,  Nu0,  x1,  yi,  y,  w,  t,  tanh1, slabs1,  &
d897 1
a897 1
  subroutine Slabs_prep ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, gamma, &
d1051 1
a1051 1
  subroutine Slabs_prep_struct ( T, P, Catalog, VelCor, Derivs, Slabs )
d1075 2
d1109 1
a1109 1
  subroutine Slabs_prep_dT ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, gamma, &
d1332 2
a1333 1
  subroutine Get_GL_Slabs_Arrays ( P_path, T_path, Vel_z, GL_Slabs, &
d1391 1
d1405 1
d1432 3
@


2.41
log
@Make Slabs_Prep and Slabs_Prep_dT public.  Add Slabs_Prep_Struct.  Polish
some TeXnicalities.  Revise Slabswint_dT and Slabswint_Lines_dT not to
compute interference if |yi| < 1.0e-6.  Added UseYi argument to Slabs_Prep
and Slabs_Prep_dT.  Use Slabs_Prep_Struct from Get_GL_Slabs_Arrays.
@
text
@d23 1
a23 1
    & "$Id: slabs_sw_m.f90,v 2.40 2004/09/23 20:08:47 vsnyder Exp $"
d1364 1
a1364 1
    integer :: i, j, k, l, n, n_sps, nl, no_ele
d1437 6
@


2.40
log
@Finish correcting divide by zero
@
text
@a5 1
  use SpectroscopyCatalog_m, only: CATALOG_T, Lines
d14 3
a16 3
         &  Slabs, Slabs_dT, Slabs_Lines, Slabs_Lines_dT,                 &
         &  Slabswint, Slabswint_dT, Slabswint_Lines, Slabswint_Lines_dT, &
         &  Voigt_Lorentz,                                                &
a18 2
  private :: Slabs_Prep, Slabs_Prep_dT

d23 1
a23 1
    & "$Id: slabs_sw_m.f90,v 2.39 2004/09/16 22:16:21 vsnyder Exp $"
d237 2
a238 2
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$, and
!  $D = \frac1{\sigma^2 x_1^2 + y^2}$.
d240 4
a243 1
!   \tanh(\frac{h \nu}{2 k T}) \left( V(a,y) + \frac{y D}{\sqrt{\pi}} \right)$.
d286 2
a287 2
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$, and
!  $D = \frac1{\sigma^2 x_1^2 + y^2}$.
d289 4
a292 1
!   \tanh(\frac{h \nu}{2 k T}) \left( V(a,y) + \frac{y D}{\sqrt{\pi}} \right)$.
d311 2
a312 2
!  $S_a = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) V(a,y)$ and
!  $S_b = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) \frac{y D}{\sqrt{\pi}}$.\\
d318 1
a318 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d322 1
a322 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d369 2
a370 1
!   \tanh(\frac{h \nu}{2 k T}) \left( V(a,y) + \frac{y D}{\sqrt{\pi}} \right)$.
d513 2
a514 1
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T})
d576 2
a577 1
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T})
d602 4
a605 4
!  $S_a = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) V(a,y)$,
!  $S_b = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) \frac{y D_1}{\sqrt{\pi}}$,
!  $S_c = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) \frac{\sigma x_1 y_i D_1}{\sqrt{\pi}}$, and
!  $S_d = S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T}) \frac{a y_i D_2}{\sqrt{\pi}}$.\\
d612 1
a612 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d616 1
a616 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d621 1
a621 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d628 1
a628 1
!   \frac1{\tanh(\frac{h \nu}{2 k T})}\frac{\partial}{\partial T} \tanh(\frac{h \nu}{2 k T}) +
d694 2
a695 1
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T})
d701 8
a708 8
    if ( .not. noPolarized ) then
      do l = 1, size(catLines)
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
        yi = slabs%yi(l)
        a = x1 * real(nu-v0s,rp)
        call real_simple_voigt ( a, y, u )
d710 3
a712 2
        sigmaX1 = x1 * (nu + v0s)
        y2 = y*y
d716 1
a716 13
      end do
    else
      do l = 1, size(slabs%v0s)
        if ( slabs%catalog%polarized(l) ) cycle
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
        yi = slabs%yi(l)
        a = x1 * real(nu-v0s,rp)
        call real_simple_voigt ( a, y, u )

        sigmaX1 = x1 * (nu + v0s)
        y2 = y*y
d719 3
a721 3
          & (u + OneOvSPi*((y - sigmaX1*yi)/(sigmaX1*sigmaX1 + y2) + yi*a/(a*a+y2)))
      end do
    end if
d750 1
a750 1
    real(rp) :: C               ! Terms common to the parts of dSlabs_dT
d779 1
a779 3
      if ( noPolarized ) then
        if ( slabs%catalog%polarized(l) ) cycle
      end if
d799 1
a799 1
      c = slabs%slabs1(l) * real(nu / lines(catLines(l))%v0,rp) * &
d801 4
a804 8
      sa = c * u
      c = c * OneOvSPi
      sb = c * y * d1
      sc = c * sigmaX1 * yi * d1
      sd = c * yi * d2
      beta = beta + sa + sb - sc + sd * a

      c = slabs%dSlabs1_dT(l) + dtanh_dT
d806 16
a821 7
      dd2 = -2.0_rp * d2 * ( a * da + y2 * dy_dT )

      dBeta_dT = dBeta_dT &
        &      + sa * ( c + du / u ) &
        &      + sb * ( c + dd1 + dy_dT ) &
        &      - sc * ( c + dd1 + dyi_dT + dx1_dT + dv0s_dT / sigma ) &
        &      + sd * ( a * (c + dd2 + dyi_dT) + da )
d908 1
a908 1
                      &   n1, n2, velCor, &
d942 1
d995 2
a996 1
    yi = p * (delta*exp(n1*t3t) + gamma*exp(n2*t3t))
d999 1
d1008 1
d1013 1
d1031 2
a1032 2
    expd = EXP(-v0*(oned300/boltzmhz))
    expn = EXP(-betav*onedt)
d1051 3
a1053 2
!   -S \left( \frac{G_1}T + \frac{H_1}{300} \right) \frac{h}k$ where
!   $G_1 = 1 + G$ and $H_1 = 1 - H$.
d1055 2
a1056 2
    dslabs1 = -slabs1 * (expn / (t * z1) + expd / (300.0_rp * z2)) / &
      & boltzmhz
d1060 56
d1118 1
a1118 1
                         &   n1, n2, velCor, &
d1152 1
d1220 5
a1224 6
    z1 = delta*exp(n1*t3t)
    z2 = gamma*exp(n2*t3t)
    yi = ( z1 + z2 )
    dyi_dT = -onedt * ( n1 * z1 + n2 * z2 )
    if ( yi /= 0.0_r8 ) then
      dyi_dT = dyi_dT / yi ! 1/yi dyi/dT
d1226 1
a1226 1
!   else ! yi == 0.0 -- do nothing
d1230 2
d1236 1
d1238 8
a1245 3
    v0s = velCor * ps * p * exp(ns*t3t)
    dv0s_dT = -ns * v0s * onedt
    v0s = velCor * v0 + v0s
d1266 1
d1275 1
d1328 2
a1329 1
!   -S \left( \frac{G_1}T + \frac{H_1}{300} \right) \frac{h}k$
d1332 2
a1333 1
    dslabs1_dv0 = -slabs1 * (z1 * onedt + z2) / boltzmhz
d1337 1
a1337 1
!{ \newpage
d1346 1
d1382 1
d1392 2
a1393 28
        if ( temp_der ) then ! do temperature derivative stuff
          do k = 1, nl
            l = catalog%lines(k)
            call slabs_prep_dT ( t_path(j), catalog%mass, &
              & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p_path(j), &
              & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
              & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
              & Vel_z_correction, &
              & gl_slabs(j,i)%v0s(k), gl_slabs(j,i)%x1(k), gl_slabs(j,i)%y(k), &
              & gl_slabs(j,i)%yi(k), gl_slabs(j,i)%slabs1(k), &
              & gl_slabs(j,i)%dslabs1_dv0(k), &
              & gl_slabs(j,i)%dv0s_dT(k), gl_slabs(j,i)%dx1_dT(k), &
              & gl_slabs(j,i)%dy_dT(k), gl_slabs(j,i)%dyi_dT(k), &
              & gl_slabs(j,i)%dslabs1_dT(k) )
          end do ! k = 1, nl
        else
          do k = 1, nl
            l = catalog%lines(k)
            call slabs_prep ( t_path(j), catalog%mass, &
              & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p_path(j), &
              & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
              & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
              & Vel_z_correction, &
              & gl_slabs(j,i)%v0s(k), gl_slabs(j,i)%x1(k), gl_slabs(j,i)%y(k), &
              & gl_slabs(j,i)%yi(k), gl_slabs(j,i)%slabs1(k), &
              & gl_slabs(j,i)%dslabs1_dv0(k) )
          end do ! k = 1, nl
        end if ! t_der_flags(j)
d1406 2
d1437 3
@


2.39
log
@Avoid dividing by zero in Slabswint_dT also
@
text
@d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.38 2004/09/16 20:24:23 vsnyder Exp $"
d812 1
a812 1
      beta = beta + sa + sb - sc + sd
d1386 3
@


2.38
log
@Avoid dividing by zero in Slabswing_Lines_dT
@
text
@d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.37 2004/09/01 01:14:48 vsnyder Exp $"
d585 2
a586 2
    sd = c * a * yi * d2
    Slabswint = sa + sb - sc + sd
d653 1
a653 1
      &       + sd * ( c + dd2 + dyi_dT + da / a )
d1386 3
@


2.37
log
@Correct 'not_used_here' routine
@
text
@d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.36 2004/08/05 20:59:32 vsnyder Exp $"
d811 1
a811 1
      sd = c * a * yi * d2
d822 1
a822 1
        &      + sd * ( c + dd2 + dyi_dT + da / a )
d1386 3
@


2.36
log
@Don't do any calculations for gl_slabs with no lines
@
text
@d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.35 2004/05/11 02:52:43 vsnyder Exp $"
a1380 1
    print *, ModuleName(1:1)
d1386 3
@


2.35
log
@Remove USE for Pi, which isn't referenced
@
text
@d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.34 2004/04/24 02:26:54 vsnyder Exp $"
d1309 3
a1313 2
      nl = Size(catalog%Lines)

d1387 3
@


2.34
log
@Move Voigt stuff to its own module
@
text
@d7 1
a7 1
  use Units, only: Pi, SqrtPi
d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.33 2004/04/20 00:48:06 vsnyder Exp $"
d1386 3
@


2.33
log
@Only use Taylor really close to the origin
@
text
@a21 6
  ! Routines to compute Fadeeva/Voigt/Lorentz:
  public :: Real_Simple_Voigt, D_Real_Simple_Voigt,                     &
         &  Simple_Voigt, D_Simple_Voigt,                               &
         &  RLorentz, CLorentz, RVoigth2, CVoigth2, RVoigth6, CVoigth6, &
         &  RHui6, CHui6, RDrayson, CDrayson, Taylor

d26 1
a26 1
    & "$Id: slabs_sw_m.f90,v 2.32 2004/04/19 21:02:19 vsnyder Exp $"
d48 2
d125 1
d217 2
d257 2
d343 1
d408 1
d482 2
d526 2
d662 1
d738 1
d839 2
a906 747
  ! ------------------------------------------  Real_Simple_Voigt  -----
  elemental subroutine Real_Simple_Voigt ( x, y, u )

! simple REAL(Voigt) function

! inputs

    real(rp), intent(in) :: x ! doppler width, del frequency ratio
    real(rp), intent(in) :: y ! doppler width, collision width ratio

! outputs

    real(rp), intent(out) :: u ! real part of Voigt

! internals

    integer :: I, J, MAXJ, N
    real :: DELY, DX, F, FD, IS, IT, Q(5), R(5), RS, RT, W, XA, Y2

    !   Note that the dimensions of R and Q are 2 less than the a and b
    !   coefficients because we start the r and q coeffients at 2.

    ! For Hui
    real(rp), parameter :: a(7) = (/ &
       &     122.607931777104326_rp, 214.382388694706425_rp, &
       &     181.928533092181549_rp,  93.155580458138441_rp, &
       &      30.180142196210589_rp,   5.912626209773153_rp, &
       &       0.564189583562615_rp /)

    real(rp), parameter :: b(7) = (/ &
       &     122.607931773875350_rp, 352.730625110963558_rp, &
       &     457.334478783897737_rp, 348.703917719495792_rp, &
       &     170.354001821091472_rp,  53.992906912940207_rp, &
       &      10.479857114260399_rp /)

    ! For Drayson
    real(rp), parameter :: TwoOvSPi = 2.0_rp * oneOvSPi  ! 2.0/Sqrt(Pi)

    real(rp), parameter :: H = 0.2_rp
    real(rp), parameter :: HN(26) = (/(h*(i-1),i=1,26)/)
    real(rp), parameter :: RI(15) = (/(-i/2.0_rp,i=1,15)/)

    real(rp), parameter :: Dawson(26) = (/  &
       &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
       &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
       &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
       &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
       &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
       &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
       &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
       &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
       &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
       &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
       &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
       &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
       &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)

    real(rp), parameter :: FDer1(26) = 1.0_rp-2.0_rp*hn*dawson
    real(rp), parameter :: FDer2(26) = (hn*FDer1+Dawson)/ri(2)
    real(rp), parameter :: FDer3(26) = (hn*FDer2+FDer1)/ri(3)
    real(rp), parameter :: FDer4(26) = (hn*FDer3+FDer2)/ri(4)
    real(rp), parameter :: FDer5(26) = (hn*FDer4+FDer3)/ri(5)
    real(rp), parameter :: FDer6(26) = (hn*FDer5+FDer4)/ri(6)

    ! For 2-pt Gauss-Hermite
    real(rp), parameter :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
    real(rp), parameter :: gw = 0.88622692545277_rp / Pi

    ! For 6-pt Gauss-Hermite
    real(rp), parameter :: gx6(3) = (/ 4.36077411927616508271e-1_rp, &
                                       1.33584907401369694957_rp,    &
                                       2.35060497367449222280_rp /)
    real(rp), parameter :: gw6(3) = (/ 7.24629595224392524608e-1_rp, &
                                       1.57067320322856644036e-1_rp, &
                                       4.53000990550884564224e-3_rp /) / Pi

    real(rp), parameter :: TwoThirds = 2.0_rp / 3.0_rp
    real(rp), parameter :: XL=5.2_rp, YL=0.05_rp, YH=0.6_rp, DYDX=(yh-yl)/xl

! This is sorted in likely occurance of each case

    xa = ABS(x)

! I am assuming that the OR are evaluated sequentially until the first
! true is found. Also routines are ordered according to speed

    if ( y + TwoThirds*xa > 100.0_rp ) then

      ! Here x is sqrt(ln2)*delnu / wd and y is sqrt(ln2)*wc / wd
      ! u = rlorentz ( x, y )
      u = OneOvSPi * y / (y*y + x*x)

    else if ( y + 0.6875_rp * xa > 11.0_rp ) then

! Drayson's quick 2pt hermite integral (essentially a lorentz)

      ! u = rvoigth2(xa,y)
      y2 = y**2
      u = gw * y * (1.0_rp/(y2 + (xa-gx)**2) + &
        &           1.0_rp/(y2 + (xa+gx)**2))

    else if ( y > 0.6_rp .OR. y > yl + dydx*xa ) then

! Intermediate region

      ! u = rhui6(xa,y)

      !   Fill the r, q coefficients with the recursion
      !   r(0)=1.0, r(1) = y q(0) = 0.0, q(1) = -x

      r(1) = y**2 - xa**2
      q(1) = -2.0_rp*xa*y
      do i = 2, 5
        r(i) = xa * q(i-1) +  y * r(i-1)
        q(i) = y  * q(i-1) - xa * r(i-1)
      end do
      rs = a(1) + a(2)*y  + dot_product(a(3:),r)
      rt = b(1) + b(2)*y  + dot_product(b(3:),r) + xa * q(5) +  y * r(5)
      is =      - a(2)*xa + dot_product(a(3:),q)
      it =      - b(2)*xa + dot_product(b(3:),q) +  y * q(5) - xa * r(5)

      u = (rs*rt + is*it) / (rt*rt + it*it)

    else if ( xa > 5.2_rp ) then

! small y large x limit

      ! u = rvoigth6(xa,y)

      ! Real Voigt region IV 6pt GH integration

      y2 = y**2

      u = y * ( gw6(1) * (1.0_rp/(y2 + (xa-gx6(1))**2) + &
                     &    1.0_rp/(y2 + (xa+gx6(1))**2)) + &
                gw6(2) * (1.0_rp/(y2 + (xa-gx6(2))**2) + &
                     &    1.0_rp/(y2 + (xa+gx6(2))**2)) + &
                gw6(3) * (1.0_rp/(y2 + (xa-gx6(3))**2) + &
                     &    1.0_rp/(y2 + (xa+gx6(3))**2)) )
    else

! Near line center where Doppler dominates Pressure broadening

      ! u = rdrayson(xa,y)

      !******** Region I. Compute Dawson's function at x from Taylor series

      if ( y <= 1.0e-12_rp ) then
        u = exp(-xa*xa)
      else

        !  Taylor series expansion about y = 0.0

        y2 = y*y
        j = xa / h
        n = 1 + min(j, 25)
        dx = xa - hn(n)
        f = 0.0_rp
        if ( xa > 0.05*h) &
           f = (((((fDer6(n)*dx + fDer5(n))*dx + fDer4(n))*dx  + &
                 &  fDer3(n))*dx + fDer2(n))*dx + fDer1(n))*dx + Dawson(n)
        dely = -y
        fd = 1.0_rp - 2.0_rp * xa * f
        w = fd * dely
        j = 5.0_rp + (12.5_rp - xa) * 0.8_rp * y
        maxj = min(j, 14)
        do j = 2, maxj, 2
          f  = (xa*fd + f) / ri(j)
          fd  = (xa*f + fd) / ri(j+1)
          dely = -y2 * dely
          w = w + fd * dely
        end do

        u = exp(y2-xa*xa)*cos(2.0_rp*xa*y) + TwoOvSpi*w
      end if

    end if

  end subroutine Real_Simple_Voigt

  ! -----------------------------------------------  Simple_Voigt  -----
  elemental subroutine Simple_Voigt ( x, y, u, v )

! simple Voigt function

! inputs

    real(rp), intent(in) :: x ! doppler width, del frequency ratio
    real(rp), intent(in) :: y ! doppler width, collision width ratio

! outputs

    real(rp), intent(out) :: u ! real part of Voigt
    real(rp), optional, intent(out) :: v ! imaginary part of Voigt

! internals

    ! For 2-pt Gauss-Hermite
    real(rp), parameter :: GX = 0.70710678118655_rp ! 1.0/sqrt(2.0)
    real(rp), parameter :: GW = 0.88622692545277_rp / Pi

    real(rp), parameter :: XL=5.2_rp, YL=0.05_rp, YH=0.6_rp, DYDX=(yh-yl)/xl
    real(rp) :: DENOM1, DENOM2, XA, XM, XP, Y2
    complex(rp) :: UV

! This is sorted in likely occurance of each case

    xa = ABS(x)

! I am assuming that the OR are evaluated sequentially until the first
! true is found. Also routines are ordered according to speed

!    if ( y + 0.666666*xa > 100.0_rp ) then
! NOTE: clorentz is not accurate enough for spectral derivative
!       computations. This may be something for Van S. to investigate
!       later.

!      uv = clorentz(xa,y)

!    else if ( y + 0.6875_rp * xa > 11.0_rp ) then

    if ( y + 0.6875_rp * xa > 11.0_rp ) then

      ! Drayson's quick 2pt hermite integral (essentially a lorentz)

      ! uv = cvoigth2(xa,y)
      xm = xa - gx
      xp = xa + gx
      y2 = y**2
      denom1 = gw/(y2 + xm**2)
      denom2 = gw/(y2 + xp**2)
      uv = CMPLX(y*(denom1+denom2), xm*denom1 + xp*denom2, KIND=rp)

    else if ( y > 0.6_rp .OR. y > yl + dydx*xa ) then

! Intermediate region

      uv = chui6(xa,y)

    else if ( xa > 5.2_rp ) then

! small y large x limit

      uv = cvoigth6(xa,y)

    else if ( x*x + y*y > 0.0036 ) then

! Near line center where Doppler dominates Pressure broadening

      uv = cdrayson(xa,y)

    else

! Very close to the line center, where cdrayson seems to have a bug

      uv = taylor(xa,y)

    end if

    u = real(uv,kind=rp)
    if ( present(v) ) v = sign(aimag(uv),x)

  end subroutine Simple_Voigt

  ! ---------------------------------------------------  RLorentz  -----
    real(rp) pure function RLorentz ( x, y )

  ! Real Lorentz

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

  ! Internals

    rlorentz = OneOvSPi * y / (y*y + x*x)

  end function RLorentz

  ! ---------------------------------------------------  CLorentz  -----
  complex(rp) elemental function CLorentz(x,y)

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internals

    real(rp) :: denom

    denom = OneOvSPi / (x*x + y*y)
    clorentz = CMPLX(y*denom,x*denom,KIND=rp)

  end function CLorentz

  ! ---------------------------------------------------  RVoigth2  -----
  real(rp) elemental function RVoigth2 ( x, y )

! Real Voigt region IV 2pt GL integration

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internals

    real(rp), parameter :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
    real(rp), parameter :: gw = 0.88622692545277_rp / Pi
    real(rp) :: y2

    y2 = y**2
    rvoigth2 = gw * y * (1.0_rp/(y2 + (x-gx)**2) + &
             &           1.0_rp/(y2 + (x+gx)**2))

  end function RVoigth2

  ! ---------------------------------------------------  CVoigth2  -----
  complex(rp) elemental function CVoigth2 ( x, y )

! Voigt region  2pt GL integration

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu) / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internals

    real(rp), parameter :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
    real(rp), parameter :: gw = 0.88622692545277_rp / Pi
    real(rp) :: denom1,denom2,xm,xp,y2

    xm = x-gx
    xp = x+gx
    y2 = y**2
    denom1 = gw/(y2 + xm**2)
    denom2 = gw/(y2 + xp**2)
    cvoigth2 = CMPLX(y*(denom1+denom2),xm*denom1 + xp*denom2,KIND=rp)

  end function CVoigth2

  ! ---------------------------------------------------  RVoigth6  -----
  real(rp) elemental function RVoigth6 ( x, y )

! Real Voigt region IV 6pt GL integration

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internals

    integer, parameter :: n = 3
    real(rp), parameter :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                      1.33584907401369694957_rp,    &
                                      2.35060497367449222280_rp /)
    real(rp), parameter :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                      1.57067320322856644036e-1_rp, &
                                      4.53000990550884564224e-3_rp /) / Pi
    real(rp) :: y2
    integer :: i

    rvoigth6 = 0.0
    y2 = y**2
    do i = 1 , n
      rvoigth6 = rvoigth6 + gw(i) * y * (1.0_rp/(y2 + (x-gx(i))**2) + &
                                     &   1.0_rp/(y2 + (x+gx(i))**2))
    end do

  end function RVoigth6

  ! ---------------------------------------------------  CVoigth6  -----
  complex(rp) elemental function CVoigth6 ( x, y )

! Voigt region IV 6pt GL integration

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu) / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internals

    integer, parameter :: n = 3
    real(rp), parameter :: Pi = 3.1415926535897932385_rp
    real(rp), parameter :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                      1.33584907401369694957_rp,    &
                                      2.35060497367449222280_rp /)
    real(rp), parameter :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                      1.57067320322856644036e-1_rp, &
                                      4.53000990550884564224e-3_rp /) / Pi
    integer :: i
    real(rp) :: denom1,denom2,xp,xm,y2

    cvoigth6 = cmplx(0.0_rp,0.0_rp)
    y2 = y**2
    do i = 1 , n
      xm = x-gx(i)
      xp = x+gx(i)
      denom1 = gw(i)/(y2 + xm**2)
      denom2 = gw(i)/(y2 + xp**2)
      cvoigth6 = cvoigth6+cmplx(y*(denom1+denom2), xm*denom1+xp*denom2, KIND=rp)
    end do

    end function CVoigth6

  ! ------------------------------------------------------  RHui6  -----
  real(rp) elemental function RHui6 ( x, y )

! Voigt region II Hui polynomial

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

!   Internal stuff

    real(rp), parameter :: a(7) = (/ &
       &     122.607931777104326_rp, 214.382388694706425_rp, &
       &     181.928533092181549_rp,  93.155580458138441_rp, &
       &      30.180142196210589_rp,   5.912626209773153_rp, &
       &       0.564189583562615_rp /)

    real(rp), parameter :: b(7) = (/ &
       &     122.607931773875350_rp, 352.730625110963558_rp, &
       &     457.334478783897737_rp, 348.703917719495792_rp, &
       &     170.354001821091472_rp,  53.992906912940207_rp, &
       &      10.479857114260399_rp /)

    integer :: i
    real :: rs,rt,is,it,r(5),q(5)

!   Note that this dimension is 2 less than the a and b coefficients
!   because we start the r and q coeffients at 2. r(0)=1.0,r(1) = y
!   q(0) = 0.0, q(1) = -x
!   Fill the r, q coefficients with this recursion

    r(1) = y**2 - x**2
    q(1) = -2.0_rp*x*y
    do i = 2 , 5
      r(i) = x * q(i-1) + y * r(i-1)
      q(i) = y * q(i-1) - x * r(i-1)
    end do
    rs = a(1) + a(2)*y + dot_product(a(3:),r)
    rt = b(1) + b(2)*y + dot_product(b(3:),r) + x * q(5) + y * r(5)
    is =      - a(2)*x + dot_product(a(3:),q)
    it =      - b(2)*x + dot_product(b(3:),q) + y * q(5) - x * r(5)

    rhui6 = (rs*rt + is*it) / (rt*rt + it*it)

!   FYI ihui6 = (is*rt - rs*it) / (rt*rt + it*it)

  end function rhui6

  ! ------------------------------------------------------  CHui6  -----
  complex(rp) elemental function CHui6 ( x, y )

! Voigt region II Hui polynomial

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu) / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

! Internal stuff

    real(rp), parameter :: a(7) = (/ &
       &     122.607931777104326_rp, 214.382388694706425_rp, &
       &     181.928533092181549_rp,  93.155580458138441_rp, &
       &      30.180142196210589_rp,   5.912626209773153_rp, &
       &       0.564189583562615_rp /)

    real(rp), parameter :: b(7) = (/ &
       &     122.607931773875350_rp, 352.730625110963558_rp, &
       &     457.334478783897737_rp, 348.703917719495792_rp, &
       &     170.354001821091472_rp,  53.992906912940207_rp, &
       &      10.479857114260399_rp /)

    integer :: i
    real :: rs,rt,is,it,r(5),q(5),denom

! Note that this dimension is 2 less than the a and b coefficients
! because we start the r and q coeffients at 2. r(0)=1.0,r(1) = y
! q(0) = 0.0, q(1) = -x
! Fill the r, q coefficients with this recursion

    r(1) = y**2 - x**2
    q(1) = -2.0_rp*x*y
    do i = 2, 5
      r(i) = x * q(i-1) + y * r(i-1)
      q(i) = y * q(i-1) - x * r(i-1)
    end do

    rs = a(1) + a(2)*y + dot_product(a(3:),r)
    rt = b(1) + b(2)*y + dot_product(b(3:),r) + x * q(5) + y * r(5)
    is =      - a(2)*x + dot_product(a(3:),q)
    it =      - b(2)*x + dot_product(b(3:),q) + y * q(5) - x * r(5)
    denom = 1.0_rp / (rt*rt + it*it)
    chui6 = cmplx((rs*rt+is*it)*denom, (is*rt-rs*it)*denom,kind=rp)

  end function chui6

  ! ---------------------------------------------------  RDrayson  -----
  real(rp) elemental function RDrayson ( x, y )

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu) / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

! Internal stuff

    integer :: I, J, MAXJ, N
    real(rp), parameter :: TwoOvSPi = 2.0_rp * oneOvSPi  ! 2.0/Sqrt(Pi)

    real(rp), parameter :: H = 0.2_rp
    real(rp), parameter :: HN(26) = (/(h*(i-1),i=1,26)/)
    real(rp), parameter :: RI(15) = (/(-i/2.0_rp,i=1,15)/)

    real(rp), parameter :: Dawson(26) = (/  &
       &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
       &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
       &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
       &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
       &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
       &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
       &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
       &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
       &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
       &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
       &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
       &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
       &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)

    real(rp), parameter :: FDer1(26) = 1.0_rp-2.0_rp*hn*dawson
    real(rp), parameter :: FDer2(26) = (hn*FDer1+Dawson)/ri(2)
    real(rp), parameter :: FDer3(26) = (hn*FDer2+FDer1)/ri(3)
    real(rp), parameter :: FDer4(26) = (hn*FDer3+FDer2)/ri(4)
    real(rp), parameter :: FDer5(26) = (hn*FDer4+FDer3)/ri(5)
    real(rp), parameter :: FDer6(26) = (hn*FDer5+FDer4)/ri(6)

! internal stuff

    real(rp) :: Y2, DX, F, FD, W, dely

!******** Region I. Compute Dawson's function at x from Taylor series

    if ( y <= 1.0e-12_rp ) then
      rdrayson = exp(-X*X)
      return
    end if

!  Taylor series expansion about y = 0.0

    y2 = y*y
    j = x / h
    n = 1 + min(j, 25)
    dx = x - hn(n)
    f = 0.0_rp
    if ( x > 0.05*h) &
       f = (((((fDer6(n)*dx + fDer5(n))*dx + fDer4(n))*dx  + &
             &  fDer3(n))*dx + fDer2(n))*dx + fDer1(n))*dx + Dawson(n)
    dely = -y
    fd = 1.0_rp - 2.0_rp * x * f
    w = fd * dely
    j = 5.0_rp + (12.5_rp - x) * 0.8_rp * y
    maxj = min(j, 14)
    do j = 2, maxj,2
      f  = (x*fd + f) / ri(j)
      fd  = (x*f + fd) / ri(j+1)
      dely = -y2 * dely
      w = w + fd * dely
    end do

    rdrayson = exp(y2-x*x)*cos(2.0_rp*x*y) + TwoOvSpi*w

  end function RDrayson

  ! ---------------------------------------------------  CDrayson  -----
  complex(rp) elemental function CDrayson ( x, y )

    real(rp), intent(in) :: x ! sqrt(ln2)*delnu) / wd
    real(rp), intent(in) :: y ! sqrt(ln2)*wc / wd

! Internal stuff

    integer :: I, J, MAXJ, N
    real(rp), parameter :: TwoOvSPi = 2.0_rp * oneOvSPi  ! 2.0/Sqrt(Pi)

! This is a way to set the mesh points without having to use a SAVE statement

    real(rp), parameter :: H = 0.2_rp
    real(rp), parameter :: HN(26) = (/(H*(I-1),I=1,26)/)
    real(rp), parameter :: RI(15) = (/(-I/2.0_rp,I=1,15)/)

    real(rp), parameter :: Dawson(26) = (/  &
       &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
       &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
       &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
       &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
       &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
       &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
       &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
       &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
       &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
       &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
       &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
       &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
       &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)

    real(rp), parameter :: FDer1(26) = 1.0_rp-2.0_rp*hn*Dawson
    real(rp), parameter :: FDer2(26) = (hn*fDer1+Dawson)/ri(2)
    real(rp), parameter :: FDer3(26) = (hn*fDer2+fDer1)/ri(3)
    real(rp), parameter :: FDer4(26) = (hn*fDer3+fDer2)/ri(4)
    real(rp), parameter :: FDer5(26) = (hn*fDer4+fDer3)/ri(5)
    real(rp), parameter :: FDer6(26) = (hn*fDer5+fDer4)/ri(6)

! internal stuff

    real(rp) :: DX, F, FD,wr,wi,dely,twoxy

!******** Region I. Compute Dawson's function at x from Taylor series

    j = x / h
    n = 1 + min(j, 25)
    dx = x - hn(n)
    f = 0.0_rp
    if ( x > 0.05*h) &
       f = (((((fder6(n)*dx + fder5(n))*dx + fder4(n))*dx  + &
             &  fder3(n))*dx + fder2(n))*dx + fder1(n))*dx + dawson(n)
    if ( y <= 1.0e-12_rp ) then
      cdrayson = cmplx(exp(-x*x),twoovspi * f,kind=rp)
      return
    end if

!  Taylor series expansion about y = 0.0

    wr = exp(y*y-x*x)
    twoxy = 2.0_rp*x*y
    cdrayson = cmplx(wr*cos(twoxy),-wr*sin(twoxy),kind=rp)
    dely = -twoovspi*y
    fd = 1.0_rp - 2.0_rp * x * f
    wi = twoovspi*f
    wr = fd*dely
    j = 5.0 + 10.0*y - 0.4*twoxy
    maxj = min(j, 14)
    do j = 2, maxj,2
      f  = (x*fd + f) / ri(j)
      fd = (x*f + fd) / ri(j+1)
      dely = y * dely
      wi = wi + f*dely
      dely = -y*dely
      wr = wr + fd*dely
    end do

    cdrayson = cdrayson + cmplx(wr,wi,kind=rp)

  end function CDrayson

  ! -----------------------------------------------------  Taylor  -----
  complex(rp) elemental function Taylor ( x, y )

  !{ $w(z) = \sum_{n=0}^\infty \frac{(iz)^n}{\Gamma(\frac{n}2+1)}$.
  !  Separating even and odd terms, we have
  !  $w(z) = \sum_{n=0}^\infty \frac{(-z^2)^n}{n!} +
  !          \frac{2 i z}{\sqrt{\pi}}
  !            \sum_{n=0}^\infty \frac{(-z^2)^n}{1\cdot3\cdot\cdot\cdot(2n+1)}$
  !  The even terms are $e^{-z^2}$; the odd ones are erf$(iz)$.  We only use
  !  terms up to second order in each of the even and odd series, so this
  !  approximation gets seven digits only for $x, y \leq 0.06$.

    use MLSCommon, only: RP
    use Units, only: SqrtPi
    real(rp), intent(in) :: X, Y
    real(rp) :: U, V
    real(rp) :: X2, Y2, Y4, TR, TI
    real(rp), parameter :: TwoOvSqpi = 2.0_rp / sqrtPi

    real(rp), parameter :: Q0 = TwoOvSqpi, Q1 = 2.0 * TwoOvSqpi / 3.0
    real(rp), parameter :: Q2 = 4.0 * TwoOvSqpi / 15.0, Q3 = 2.0 * q2

    ! (x2,y2) = -z**2
    x2 = y*y - x*x
    y2 = -2.0_rp * x * y
    y4 = y2 * y2

    tr = q0 - q2 * y4 + ( q1 + q2 * x2 ) * x2
    ti = ( q1 + q3 * x2 ) * y2
    u = ( 1.0_rp + 0.5_rp * x2 ) * x2 + 1.0 - 0.5 * y4 - tr * y - ti * x
    v = ( x2 + 1.0_rp ) * y2 + x * tr - y * ti
    taylor = cmplx(u,v)

  end function Taylor

!{ \newpage

  ! ----------------------------------------  D_Real_Simple_Voigt  -----
  subroutine D_Real_Simple_Voigt ( x, y, dx, dy, u, du )
  ! Compute the real part of Fadeeva = Voigt (without Lorentz) and
  ! the real part of the derivative (which isn't just the derivative
  ! of Voigt).

!{ The Fadeeva function $w(z)$, where $z = x + i y$, can be written as
!  $V(x,y) + i L(x,y)$, where $V(x,y)$ is the Voigt function and
!  $L(x,y)$ is the Lorentz function. 
!
!  From 7.1.20 in {\bf Handbook of Mathematical Functions} by Abramowitz
!  and Stegun (National Bureau of Standards Applied Math Series 55) we have
!  $w^{\prime}(z) = \frac{2i}{\sqrt{\pi}} - 2 z w(z)$.\\
!  $\Re \, \frac{\partial w(z(t))}{\partial T} =
!   2 \left[ \left( -x V(x,y) + y L(x,y) \right) \frac{\partial x}{\partial T} +
!            \left( x L(x,y) + y V(x,y) +\frac1{\sqrt{\pi}} \right)
!             \frac{\partial y}{\partial T} \right]$.

    real(rp), intent(in) :: x, y, dx, dy
    real(rp), intent(out) :: u, du

    real(rp) :: v ! Lorentz function

    call simple_voigt ( x, y, u, v )
    du = 2.0_rp * ( (-x * u + y * v) * dx + (x * v + y * u - oneOvSpi) * dy )

  end subroutine D_Real_Simple_Voigt

  ! ---------------------------------------------  D_Simple_Voigt  -----
  subroutine D_Simple_Voigt ( x, y, dx, dy, u, v, du, dv )
  ! Compute Fadeeva = Voigt and Lorentz its derivative

!{ The Fadeeva function $w(z)$, where $z = x + i y$, can be written as
!  $V(x,y) + i L(x,y)$, where $V(x,y)$ is the Voigt function and
!  $L(x,y)$ is the Lorentz function. 
!
!  From 7.1.20 in {\bf Handbook of Mathematical Functions} by Abramowitz
!  and Stegun (National Bureau of Standards Applied Math Series 55) we have
!  $w^{\prime}(z) = \frac{2i}{\sqrt{\pi}} - 2 z w(z)$.\\
!  \begin{equation*}\begin{split}
!  \frac{\partial w(z(t))}{\partial T}
!   =& 2 \left[ \left( -x V(x,y) + y L(x,y) \right) \frac{\partial x}{\partial T} +
!            \left( x L(x,y) + y V(x,y) +\frac1{\sqrt{\pi}} \right)
!             \frac{\partial y}{\partial T} \right]\\
!   +& 2 i \left [ - \left( x L(x,y) + y V(x,y) +\frac1{\sqrt{\pi}} \right)
!             \frac{\partial x}{\partial T} +
!            \left( - x V(x,y) + y L(x,y) \right) \frac{\partial y}{\partial T} \right]\\
!   =& a \frac{\partial x}{\partial T} + b \frac{\partial y}{\partial T}
!    + i \left( -b \frac{\partial x}{\partial T} + a \frac{\partial y}{\partial T} \right).
!  \end{split}\end{equation*}

    real(rp), intent(in) :: x, y, dx, dy
    real(rp), intent(out) :: u, v, du, dv

    real :: a, b

    call simple_voigt ( x, y, u, v )
    a = -x * u + y * v
    b = x * v + y * u - oneOvSpi
    du = 2.0_rp * ( a * dx + b * dy )
    dv = 2.0_rp * ( -b * dx + a * dy )

  end subroutine D_Simple_Voigt

d1380 1
d1386 3
@


2.32
log
@Use Taylor instead of CDrayson near the origin
@
text
@d32 1
a32 1
    & "$Id: slabs_sw_m.f90,v 2.31 2004/04/17 00:37:00 vsnyder Exp $"
d1141 6
d1149 1
a1149 1
! Near line center where Doppler dominates Pressure broadening
a1151 1
!     uv = cdrayson(xa,y)
d2121 3
@


2.31
log
@Analytic temperature derivatives
@
text
@d26 1
a26 1
         &  RHui6, CHui6, RDrayson, CDrayson
d32 1
a32 1
    & "$Id: slabs_sw_m.f90,v 2.30 2004/04/06 23:40:21 vsnyder Exp $"
d1145 2
a1146 1
      uv = cdrayson(xa,y)
d1537 35
a2000 1
    use Physics, only: SpeedOfLight
d2003 1
d2116 3
@


2.30
log
@Do slabs_prep where derivatives not requested in get_gl_slabs_arrays
instead of doing nothing.
@
text
@d32 1
a32 1
    & "$Id: slabs_sw_m.f90,v 2.29 2004/04/02 00:59:24 vsnyder Exp $"
d282 1
a282 1
    call D_Real_Simple_Voigt ( x1*delta, y, da, dy_dT, u, du )
d452 1
a452 1
      dy_dT = slabs%dy_dT(l)
d455 1
a455 2
      call D_Real_Simple_Voigt ( x1*delta, y, da, dy_dT, u, du )

d466 1
d554 1
a554 1
    call D_Real_Simple_Voigt ( a, y, da, dy_dT, u, du )
d789 1
a789 1
      call D_Real_Simple_Voigt ( a, y, da, dy_dT, u, du )
d808 1
d814 1
d1504 1
a1504 1
    if ( x.gt.0.05*h) &
d1544 3
a1546 3
!{ The Fadeeva function $w(z)$, where $z = a + i y$, can be written as
!  $V(a,y) + i L(a,y)$, where $V(a,y)$ is the Voigt function and
!  $L(a,y)$ is the Lorentz function. 
d1551 4
a1554 4
!  $\Re \, \frac{\partial w(z(t))}{\partial t} =
!   2 \left[ \left( -a V(a,y) + y L(a,y) \right) \frac{\partial a}{\partial t} +
!            \left( a L(a,y) + y V(a,y) -\frac1{\sqrt{\pi}} \right)
!             \frac{\partial y}{\partial t} \right]$.
d1562 1
a1562 1
    du = 2.0_rp * ( (-x * u + y * v) * dx + (x * v + y * u) * dy )
d1570 3
a1572 3
!{ The Fadeeva function $w(z)$, where $z = a + i y$, can be written as
!  $V(a,y) + i L(a,y)$, where $V(a,y)$ is the Voigt function and
!  $L(a,y)$ is the Lorentz function. 
d1578 9
a1586 9
!  \frac{\partial w(z(t))}{\partial t}
!   =& 2 \left[ \left( -a V(a,y) + y L(a,y) \right) \frac{\partial a}{\partial t} +
!            \left( a L(a,y) + y V(a,y) -\frac1{\sqrt{\pi}} \right)
!             \frac{\partial y}{\partial t} \right]\\
!   +& 2 i \left [ - \left( a L(a,y) + y V(a,y) -\frac1{\sqrt{\pi}} \right)
!             \frac{\partial a}{\partial t} +
!            \left( - a V(a,y) + y L(a,y) \right) \frac{\partial y}{\partial t} \right]\\
!   =& u \frac{\partial a}{\partial t} + v \frac{\partial y}{\partial t}
!    + i \left( -v \frac{\partial a}{\partial t} + u \frac{\partial y}{\partial t} \right).
d1596 1
a1596 1
    b = x * v + y * u
d2080 4
@


2.29
log
@Get catalog from slabs structure
@
text
@d32 1
a32 1
    & "$Id: slabs_sw_m.f90,v 2.28 2004/03/30 02:25:08 vsnyder Exp $"
d1984 1
d2006 19
a2024 2
      if ( .not. present(t_der_flags) ) then
        do j = 1, n
d2036 2
a2037 21
        end do ! j = 1, n
      else ! t_der_flags are present -- do temperature derivative stuff
        do j = 1, n
          if ( t_der_flags(j) ) then ! do temperature derivative stuff
            do k = 1, nl
              l = catalog%lines(k)
              call slabs_prep_dT ( t_path(j), catalog%mass, &
                & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p_path(j), &
                & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
                & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
                & Vel_z_correction, &
                & gl_slabs(j,i)%v0s(k), gl_slabs(j,i)%x1(k), gl_slabs(j,i)%y(k), &
                & gl_slabs(j,i)%yi(k), gl_slabs(j,i)%slabs1(k), &
                & gl_slabs(j,i)%dslabs1_dv0(k), &
                & gl_slabs(j,i)%dv0s_dT(k), gl_slabs(j,i)%dx1_dT(k), &
                & gl_slabs(j,i)%dy_dT(k), gl_slabs(j,i)%dyi_dT(k), &
                & gl_slabs(j,i)%dslabs1_dT(k) )
            end do ! k = 1, nl
          end if ! t_der_flags(j)
        end do ! j = 1, n
      end if ! present(t_der_flags)
d2078 3
@


2.28
log
@Comment out call to slabs_prep_dt until n1==0 etc are worked out
@
text
@d3 2
d14 2
a15 2
  public :: Get_GL_Slabs_Arrays, &
         &  Slabs, Slabs_dT, Slabs_Lines, Slabs_Lines_dT, &
d17 1
a17 1
         &  Voigt_Lorentz, &
d20 2
d23 4
a26 5
  public :: Real_Simple_Voigt, Simple_Voigt, RLorentz, CLorentz, RVoigth2, &
         &  CVoigth2, RVoigth6, CVoigth6, RHui6, CHui6, RDrayson, &
         &  CDrayson

  private :: Slabs_Prep, Slabs_Prep_dT
d32 1
a32 1
    & "$Id: slabs_sw_m.f90,v 2.27 2004/03/27 03:35:27 vsnyder Exp $"
d137 1
d148 1
d153 1
a153 1
    do l = 1, size(slabs%catalog%lines)
d159 1
a159 1
      w = lines(slabs%catalog%lines(l))%w
d338 1
a338 1
  function Slabs_Lines ( Nu, Slabs, tanh1, Polarized ) result ( Beta )
d346 2
a347 2
    logical, optional, intent(in) :: Polarized(:) ! "Don't do this line;"
                                  ! do them all if Polarized is not present.
d354 1
d358 1
a358 1
    real(rp) :: X1, Y ! Doppler width, ratio Pressure to Doppler widths
d367 3
a369 2
    if ( .not. present(polarized) ) then
      do l = 1, size(slabs%catalog%lines)
d376 1
a376 1
          &           real(nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d382 1
a382 1
        if ( polarized(l) ) cycle
d389 1
a389 1
          &           real(nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d399 1
a399 1
    &                         Beta, dBeta_dT, Polarized )
d414 2
a415 2
    logical, optional, intent(in) :: Polarized(:) ! "Don't do this line;"
                                  ! do them all if Polarized is not present.
d417 1
d437 1
d441 1
a441 1
    do l = 1, size(slabs%catalog%lines)
d443 2
a444 2
      if ( present(polarized) ) then
        if ( polarized(l) ) cycle
d461 1
a461 2
      sb = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * &
        &  tanh1
d467 2
a468 2
      dBeta_dT = dBeta_dT + sa * ( c + du / u ) + &
        &                   sb * ( c + dy_dT - 2.0_rp * d * &            
d643 4
a646 4
    dSlabs_dT = sa * ( c + du / u ) + &
      &         sb * ( c + dd1 + dy_dT ) - &
      &         sc * ( c + dd1 + dyi_dT + dx1_dT + dv0s_dT / sigma ) + &
      &         sd * ( c + dd2 + dyi_dT + da / a )
d651 1
a651 1
  function Slabswint_Lines ( Nu, Slabs, tanh1, Polarized ) result ( Beta )
d659 2
a660 2
    logical, optional, intent(in) :: Polarized(:) ! "Don't do this line;"
                                  ! do them all if Polarized is not present.
d668 1
d685 3
a687 2
    if ( .not. present(polarized) ) then
      do l = 1, size(slabs%catalog%lines)
d698 1
a698 1
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d703 1
a703 1
        if ( polarized(l) ) cycle
d714 1
a714 1
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
d723 1
a723 1
    &                             Beta, dBeta_dT, Polarized )
d738 2
a739 2
    logical, optional, intent(in) :: Polarized(:) ! "Don't do this line;"
                                  ! do them all if Polarized is not present.
d746 1
d769 4
a772 1
    do l = 1, size(slabs%catalog%lines)
d774 2
a775 2
      if ( present(polarized) ) then
        if ( polarized(l) ) cycle
d796 1
a796 1
      c = slabs%slabs1(l) * real(nu / lines(slabs%catalog%lines(l))%v0,rp) * &
d803 1
a803 1
      Beta = sa + sb - sc + sd
d808 5
a812 4
      dBeta_dT = sa * ( c + du / u ) + &
        &        sb * ( c + dd1 + dy_dT ) - &
        &        sc * ( c + dd1 + dyi_dT + dx1_dT + dv0s_dT / sigma ) + &
        &        sd * ( c + dd2 + dyi_dT + da / a )
d1618 1
a1618 1
    real(rp), intent(in) :: M        ! Molecular mass amu
d1620 2
a1621 2
    real(rp), intent(in) :: El       ! Lower state energy cm-1
    real(rp), intent(in) :: W        ! Collision broadening parameter
d1623 1
a1623 1
    real(rp), intent(in) :: Ps       ! Pressure shift parameter in MHz/mbar
d1625 3
a1627 3
    real(rp), intent(in) :: N        ! Temperature power dependence of w
    real(rp), intent(in) :: Ns       ! Temperature power dependence of ps
    real(rp), intent(in) :: I        ! Integrated spectral intensity
d1629 1
a1629 1
    real(rp), intent(in) :: Q(3)     ! Logarithm of the partition function
d1631 5
a1635 5
    real(rp), intent(in) :: Delta    ! Delta interference coefficient at 300K 1/mb
    real(rp), intent(in) :: Gamma    ! Gamma               "
    real(rp), intent(in) :: N1       ! Temperature dependency of delta
    real(rp), intent(in) :: N2       ! Temperature dependency of gamma
    real(rp), intent(in) :: VelCor   ! Doppler velocity correction term
d1640 2
a1641 2
    real(rp), intent(out) :: X1      ! Sqrt(Ln(2))/Doppler half width MHz
    real(rp), intent(out) :: Y       ! Sqrt(Ln(2))*collision width /
d1643 3
a1645 3
    real(rp), intent(out) :: Yi      ! Interference contribution
    real(rp), intent(out) :: Slabs1  ! Frequency independent piece of slabs
    real(rp), intent(out) :: Dslabs1 ! Derivative of slabs1 w.r.t. v0
d1766 1
a1766 1
    real(rp), intent(in) :: M        ! Molecular mass amu
d1788 2
a1789 2
    real(rp), intent(out) :: X1      ! Sqrt(Ln(2))/Doppler half width MHz
    real(rp), intent(out) :: Y       ! Sqrt(Ln(2))*collision width /
d1791 3
a1793 3
    real(rp), intent(out) :: Yi      ! Interference contribution
    real(rp), intent(out) :: Slabs1  ! Frequency independent piece of slabs
    real(rp), intent(out) :: Dslabs1_dv0 ! Derivative of slabs1 w.r.t. v0
d1802 4
a1805 4
    real(rp), intent(out) :: dx1_dT     ! 1/x1 dx1/dT
    real(rp), intent(out) :: dy_dT      ! 1/y dy/dT
    real(rp), intent(out) :: dyi_dT     ! 1/yi dyi/dT
    real(rp), intent(out) :: dslabs1_dT ! 1/slabs1 dslabs1/dT
d1854 9
a1862 2
    dyi_dT = -onedt * ( n1 * z1 + n2 * z2 ) / yi ! 1/yi dyi/dT
    yi = p * yi
d2005 1
a2005 1
!     if ( .not. present(t_der_flags) ) then
d2019 20
a2038 20
!     else ! t_der_flags are present -- do temperature derivative stuff
!       do j = 1, n
!         if ( t_der_flags(j) ) then ! do temperature derivative stuff
!           do k = 1, nl
!             l = catalog%lines(k)
!             call slabs_prep_dT ( t_path(j), catalog%mass, &
!               & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p_path(j), &
!               & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
!               & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
!               & Vel_z_correction, &
!               & gl_slabs(j,i)%v0s(k), gl_slabs(j,i)%x1(k), gl_slabs(j,i)%y(k), &
!               & gl_slabs(j,i)%yi(k), gl_slabs(j,i)%slabs1(k), &
!               & gl_slabs(j,i)%dslabs1_dv0(k), &
!               & gl_slabs(j,i)%dv0s_dT(k), gl_slabs(j,i)%dx1_dT(k), &
!               & gl_slabs(j,i)%dy_dT(k), gl_slabs(j,i)%dyi_dT(k), &
!               & gl_slabs(j,i)%dslabs1_dT(k) )
!           end do ! k = 1, nl
!         end if ! t_der_flags(j)
!       end do ! j = 1, n
!     end if ! present(t_der_flags)
d2079 3
@


2.27
log
@Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
line centers and line widths around.  Write slabs_lines and slabswint_lines
to get sum of beta over all lines; put slabs_struct instead of its components
in the calling sequence.
@
text
@d3 1
a3 1
  use MLSCommon, only: R8, RP, IP
d13 2
a14 2
         &  Slabs, Slabs_Lines, Slabs_dT, &
         &  Slabswint, Slabswint_dT, Slabswint_Lines, &
d29 1
a29 1
    & "$Id: slabs_sw_m.f90,v 2.26 2004/03/20 03:17:44 vsnyder Exp $"
d390 78
a506 69
  ! --------------------------------------------  Slabswint_Lines  -----
  function Slabswint_Lines ( Nu, Slabs, tanh1, Polarized ) result ( Beta )

    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
    use SpectroscopyCatalog_m, only: Lines

    real(r8), intent(in) :: Nu    ! Frequency
    type(slabs_struct), intent(in) :: Slabs ! Frequency-independent stuff
    real(rp), intent(in) :: tanh1 ! tanh( h nu / (2 k T) )
    logical, optional, intent(in) :: Polarized(:) ! "Don't do this line;"
                                  ! do them all if Polarized is not present.

    real(rp) :: Beta ! Output

! If the molecular transition and temperature have not changed but
! frequency has, enter here to calculate sum of Beta for all lines in SLABS.

    real(rp) :: A        ! First argument for real_simple_voigt
    integer :: L         ! Line Index
    real(rp) :: SigmaX1  ! (nu + nu0s) * x1
    real(rp) :: U        ! Voigt = real part of Fadeeva
    real(r8) :: V0S      ! Pressure-shifted line center
    real(rp) :: X1, Y    ! Doppler width, ratio Pressure to Doppler widths
    real(rp) :: Yi       ! Interference coefficient
    real(rp) :: Y2       ! y**2

!{ Let $V(a,y)$ be the Voigt function ({\tt u} above), $\delta = \nu-\nu_{0_s}$,
!  $\sigma = \nu + \nu_{0_s}$, $a = x_1 \delta$,
!  $D_1 = \frac1{\sigma^2 x_1^2 + y^2}$ and $D_2 = \frac1{a^2 + y^2}$.
!  Then {\tt Slabswint = } $ S_1 \frac{\nu}{\nu_0} \tanh(\frac{h \nu}{2 k T})
!   \left( V(a,y) + \frac{(y - \sigma x_1 y_i) D_1}{\sqrt{\pi}}
!     + \frac{y_i a D_2}{\sqrt{\pi}} \right)$.

    beta = 0.0_rp
    if ( .not. present(polarized) ) then
      do l = 1, size(slabs%catalog%lines)
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
        yi = slabs%yi(l)
        a = x1 * real(nu-v0s,rp)
        call real_simple_voigt ( a, y, u )

        sigmaX1 = x1 * (nu + v0s)
        y2 = y*y
        beta = beta + slabs%slabs1(l) * &
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
          & (u + OneOvSPi*((y - sigmaX1*yi)/(sigmaX1*sigmaX1 + y2) + yi*a/(a*a+y2)))
      end do
    else
      do l = 1, size(slabs%v0s)
        if ( polarized(l) ) cycle
        v0s = slabs%v0s(l)
        x1 = slabs%x1(l)
        y = slabs%y(l)
        yi = slabs%yi(l)
        a = x1 * real(nu-v0s,rp)
        call real_simple_voigt ( a, y, u )

        sigmaX1 = x1 * (nu + v0s)
        y2 = y*y
        beta = beta + slabs%slabs1(l) * &
          &           real(Nu / lines(slabs%catalog%lines(l))%v0, rp) * tanh1 * &
          & (u + OneOvSPi*((y - sigmaX1*yi)/(sigmaX1*sigmaX1 + y2) + yi*a/(a*a+y2)))
      end do
    end if

  end function Slabswint_Lines

d642 160
d1753 2
a1754 2
    real(rp), intent(in) :: El       ! Lower state energy cm-1
    real(rp), intent(in) :: W        ! Collision broadening parameter
d1756 1
a1756 1
    real(rp), intent(in) :: Ps       ! Pressure shift parameter in MHz/mbar
d1758 3
a1760 3
    real(rp), intent(in) :: N        ! Temperature power dependence of w
    real(rp), intent(in) :: Ns       ! Temperature power dependence of ps
    real(rp), intent(in) :: I        ! Integrated spectral intensity
d1762 1
a1762 1
    real(rp), intent(in) :: Q(3)     ! Logarithm of the partition function
d1764 4
a1767 4
    real(rp), intent(in) :: Delta    ! Delta interference coefficient at 300K 1/mb
    real(rp), intent(in) :: Gamma    ! Gamma               "
    real(rp), intent(in) :: N1       ! Temperature dependency of delta
    real(rp), intent(in) :: N2       ! Temperature dependency of gamma
d1983 1
a1983 1
      if ( .not. present(t_der_flags) ) then
d1997 20
a2016 20
      else ! t_der_flags are present -- do temperature derivative stuff
        do j = 1, n
          if ( t_der_flags(j) ) then ! do temperature derivative stuff
            do k = 1, nl
              l = catalog%lines(k)
              call slabs_prep_dT ( t_path(j), catalog%mass, &
                & lines(l)%v0, lines(l)%el, lines(l)%w, lines(l)%ps, p_path(j), &
                & lines(l)%n, lines(l)%ns, lines(l)%str, catalog%QLOG(1:3), &
                & lines(l)%delta, lines(l)%gamma, lines(l)%n1, lines(l)%n2, &
                & Vel_z_correction, &
                & gl_slabs(j,i)%v0s(k), gl_slabs(j,i)%x1(k), gl_slabs(j,i)%y(k), &
                & gl_slabs(j,i)%yi(k), gl_slabs(j,i)%slabs1(k), &
                & gl_slabs(j,i)%dslabs1_dv0(k), &
                & gl_slabs(j,i)%dv0s_dT(k), gl_slabs(j,i)%dx1_dT(k), &
                & gl_slabs(j,i)%dy_dT(k), gl_slabs(j,i)%dyi_dT(k), &
                & gl_slabs(j,i)%dslabs1_dT(k) )
            end do ! k = 1, nl
          end if ! t_der_flags(j)
        end do ! j = 1, n
      end if ! present(t_der_flags)
d2057 6
@


2.26
log
@Steps along the way toward analytic temperature derivatives
@
text
@d10 14
a23 4
  public :: DVoigt_Spectral, Slabs, Slabswint, Voigt_Lorentz, &
        &  Real_Simple_Voigt, Simple_Voigt, RLorentz, CLorentz, RVoigth2, &
        &  CVoigth2, RVoigth6, CVoigth6, RHui6, CHui6, RDrayson, &
        &  CDrayson, Slabs_Prep, Slabs_Prep_Arrays, Get_GL_Slabs_Arrays
d29 1
a29 1
    & "$Id: slabs_sw_m.f90,v 2.24 2003/07/09 22:46:24 vsnyder Exp $"
d49 1
a49 1
!       tanh1 = tanh(nu*expa / 2.0)
d111 101
d228 1
a228 1
    call real_simple_voigt(x1*real(nu-v0s,rp),y,u)
d259 1
a259 1
      ! = h nu / ( 2 k t ) (tanh(...) - 1/tanh(...) )
d332 58
d429 69
d510 1
a510 1
      ! = h nu / ( 2 k t ) (tanh(...) - 1/tanh(...) )
d1366 2
a1367 2
!   2 \left[ \left( -x V(x,y) + y L(x,y) \right) \frac{\partial x}{\partial t} +
!            \left( x L(x,y) + y V(x,y) -\frac1{\sqrt{\pi}} \right)
d1393 2
a1394 2
!   =& 2 \left[ \left( -x V(x,y) + y L(x,y) \right) \frac{\partial x}{\partial t} +
!            \left( x L(x,y) + y V(x,y) -\frac1{\sqrt{\pi}} \right)
d1396 5
a1400 5
!   +& 2 i \left [ - \left( x L(x,y) + y V(x,y) -\frac1{\sqrt{\pi}} \right)
!             \frac{\partial x}{\partial t} +
!            \left( - x V(x,y) + y L(x,y) \right) \frac{\partial y}{\partial t} \right]\\
!   =& a \frac{\partial x}{\partial t} + b \frac{\partial y}{\partial t}
!    + i \left( -b \frac{\partial x}{\partial t} + a \frac{\partial y}{\partial t} \right).
d1418 1
a1418 1
                      &   n1, n2, &
d1428 2
a1429 2
    use Physics, only: H_OVER_K, SpeedOfLight
    use Units, only: Ln10
d1451 1
d1475 5
a1479 2
    real(rp), parameter :: I2abs = 3.402136078e9_rp ! sqrt(ln(2)/pi)*1.0e-13/k
    real(rp), parameter :: Dc = 3.58117369e-7_rp ! sqrt(1000 k ln 4 avogadro) / c
a1481 1
    real(rp), parameter :: Sqrtln2 = 8.32554611157698e-1_rp
d1506 1
a1506 1
!{ $\nu_{0_s} = \nu_0 + p_s p \left( \frac{300}T \right) ^{n_s}$.
d1508 1
a1508 1
    v0s = v0 + ps * p * exp(ns*t3t)
d1510 1
a1510 1
!{ $\omega_d = \nu_0 d_c \sqrt{\frac{T}M}$.
d1512 1
a1512 1
    Wd = v0 * Sqrt(t/m) * dc
d1514 1
a1514 1
!{ $x_1 = \frac{\sqrt{\ln 2}}{\omega_d}$.
d1516 1
a1516 1
    x1 = sqrtln2 / Wd
d1536 1
d1538 2
a1539 3
    z1 = 1.0 + expn
    expd = EXP(-v0*(oned300/boltzmhz))
    z2 = 1.0 - expd
d1544 1
a1544 1
!   {T \omega_d \left(1 - e^{-\frac{h \nu_0}{300 k}}\right)} =
d1547 1
a1547 1
!  \frac{(1+G)} {\omega_d (1-H)}$, where
d1566 1
a1566 1
                         &   n1, n2, &
d1576 2
a1577 2
    use Physics, only: H_OVER_K, SpeedOfLight
    use Units, only: Ln10
d1599 1
d1631 5
a1635 2
    real(rp), parameter :: I2abs = 3.402136078e9_rp ! sqrt(ln(2)/pi)*1.0e-13/k
    real(rp), parameter :: Dc = 3.58117369e-7_rp
a1637 1
    real(rp), parameter :: Sqrtln2 = 8.32554611157698e-1_rp
d1673 2
a1674 2
!{ $\nu_{0_s} = \nu_0 + p_s p \left( \frac{300}T \right)^{n_s}$.
!  $\frac{\partial \nu_{0_s}}{\partial T} = \frac{-n_s}T ( \nu_{0_s} - \nu_0 )$.
d1676 1
a1676 1
    v0s = ps * p * exp(ns*t3t)
d1678 1
a1678 1
    v0s = v0 + v0s
d1680 1
a1680 1
!{ $\omega_d = \nu_0 d_c \sqrt{\frac{T}M}$.  The $\nu_0$ term should
d1683 1
a1683 1
!  $-\frac1{\omega_d}\frac{\partial \omega_d}{\partial T} = 
d1685 1
a1685 1
!  $-\frac1{\omega_d}\frac{\partial \omega_d}{\partial T}$ is what's actually
d1691 1
a1691 1
!{ $x_1 = \frac{\sqrt{\ln 2}}{\omega_d}$.
d1693 1
a1693 1
!   -\frac1{\omega_d} \frac{\partial \omega_d}{\partial T}
d1695 4
d1700 1
a1700 1
    x1 = sqrtln2 / Wd
d1725 1
a1725 1
    betav = v0s / boltzmhz
d1731 1
a1731 1
!   {T \omega_d \left(1 - e^{\frac{\beta_v}{300}}\right)}$
d1733 4
a1736 3
!                                    {\omega_d (1-H)}$, where
!  $f = I_2 \, p \, e^{(i-a) \ln 10 + \frac{\beta_e}{300}}$,
!  $G = e^{-\frac{\beta_v}T}$ and $H = e^{-\frac{\beta_v}{300}}$.  Then
d1740 2
a1741 3
!    - \frac1{\omega_d}\frac{\partial \omega_d}{\partial T}
!    - \frac{H_1}{300} \frac{\partial \beta_v}{\partial T}$, where
!  $G_1 = \frac{G}{1+G}$ and $H_1 = \frac{H}{1-H}$.
d1743 1
a1743 1
    expd = EXP(-betav*oned300) ! H
a1752 1
    z2 = oned300 * expd / z2   ! H1 / 300
d1756 1
a1756 1
      & dWd_dT - z2 * dbetav_dT ! Remember dWd_dT is really -dWd_dT/Wd
d1759 2
a1760 1
!   -S \left( \frac{G_1}T + \frac{H_1}{300} \right) \frac{h}k$.
a1767 35
  ! -----------------------------------------  Slabs_Prep_Arrays   -----
  subroutine Slabs_Prep_Arrays ( molecule, nl, t, p, mass, Qlog, Catalog, &
                               & v0s, x1, y, yi, slabs1, dslabs1_dv0 )

    use Molecules, only: L_Extinction

    type(catalog_T) :: Catalog

    integer(ip), intent(in) :: molecule, nl

    real(rp), intent(in) :: t, p, mass,Qlog(:)

    real(r8), intent(out) :: v0s(:)
    real(rp), intent(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)

    integer :: j, k

    if ( any ( molecule == (/ l_extinction /) ) ) return

! Check for anything but dry air or extinction:

    do j = 1, nl

! Prepare the temperature weighted coefficients:

      k = Catalog%Lines(j)
      call Slabs_prep ( t, mass, Lines(k)%V0, Lines(k)%EL, Lines(k)%W,      &
        &  Lines(k)%PS, p, Lines(k)%N, Lines(k)%NS, Lines(k)%STR,           &
        &  Qlog, Lines(k)%DELTA, Lines(k)%GAMMA, Lines(k)%N1, Lines(k)%N2,  &
        &  v0s(j), x1(j), y(j), yi(j), slabs1(j), dslabs1_dv0(j) )

    end do

  end subroutine Slabs_Prep_Arrays

d1769 1
a1769 1
  subroutine Get_GL_Slabs_Arrays ( Catalog, P_path, T_path, Vel_z, GL_slabs, &
d1774 1
a1774 2

    type(Catalog_T), dimension(:), intent(in) :: Catalog
d1779 5
a1783 1
    real(rp), intent(in) :: vel_z
d1785 1
a1785 3
    logical, intent(in) :: t_der_flags(:)

    type (slabs_struct) :: gl_slabs(:,:)
d1791 2
a1792 1
    real(rp), parameter :: c = speedOfLight/1000.0_rp ! Speed of Light Km./Sec.
d1794 1
a1794 3
    integer :: i, j, k, n_sps, nl, no_ele

    real(rp) :: Qlog(3), vel_z_correction
d1799 3
a1801 1
    n_sps = Size(catalog)
d1803 2
a1804 1
    Vel_z_correction = 1.0_rp - vel_z / c
d1808 1
a1808 20
      nl = Size(Catalog(i)%Lines)

      Qlog(1:3) = Catalog(i)%QLOG(1:3)

      if ( .not. Do_1D ) then

        do j = 1, no_ele
          if (.not. t_der_flags(j)) cycle
          call Slabs_Prep_Arrays ( catalog(i)%molecule, nl, t_path(j),&
            &  p_path(j), catalog(i)%mass, Qlog, &
            &  Catalog(i), gl_slabs(j,i)%v0s, gl_slabs(j,i)%x1, gl_slabs(j,i)%y, &
            &  gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0 )

!  Apply velocity corrections:

          gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction

        end do

      else
d1810 1
a1810 1
        ! compute each element along the LOS path before tangent point
d1812 1
a1812 6
        do j = 1, no_ele/2
          if (.not. t_der_flags(j)) cycle
          call Slabs_Prep_Arrays ( catalog(i)%molecule, nl, t_path(j), p_path(j), &
            & catalog(i)%mass, Qlog, &
            & Catalog(i), gl_slabs(j,i)%v0s, gl_slabs(j,i)%x1, gl_slabs(j,i)%y, &
            & gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0 )
d1814 34
a1847 1
          gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction
d1849 1
a1849 2
        end do
        
a1850 1
        
a1851 1
          if (.not. t_der_flags(j)) cycle          
d1859 14
a1872 3
        
        end do
        
d1875 1
a1875 1
    end do              ! On i
d1888 3
@


2.25
log
@Use line center instead of pressure-shifted line center in a few places
@
text
@d35 1
a35 1
! NOTE: Before calling this routine, the user needs to call slabs_prep_wder()
d41 2
a42 2
    real(r8), intent(in) :: nu0
    real(rp), intent(in) :: dnu, x1, yi, y, w, t, tanh1, slabs1             
d123 6
a128 1
!  >> 2004-03-18 WV Snyder Use Nu/v0 instead of Nu/v0s.
d135 86
d236 1
a236 1
    real(rp) :: x, u, p, y2
d238 2
a239 2
    x = x1 * real(nu-v0s,rp)
    call real_simple_voigt(x,y,u)
a244 1
!  >> 2004-03-18 WV Snyder Use Nu/v0 instead of Nu/v0s.
d246 8
a253 1
    p = x1 * (nu + v0s)
d256 1
a256 1
      & (u + OneOvSPi*((y - p*yi)/(p*p + y2) + yi*x/(x*x+y2)))
d260 135
d406 2
a407 2
    real(r8), intent(in) :: nu0
    real(rp), intent(in) :: dNu, x1, yi, y, w, t, tanh1, slabs1, dslabs1_dNu0
d1112 66
d1190 2
a1191 2
    use Physics, only: H_OVER_K
    use Units, only: Ln10, SpeedOfLight
a1234 1
!  loge     - log10(e)
d1236 2
a1237 2
    real(rp), parameter :: I2abs = 3.402136078e9_rp
    real(rp), parameter :: Dc = 3.58117369e-7_rp
a1240 1
    real(rp), parameter :: Loge = 1.0_rp / ln10
d1251 2
a1252 1
    real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, expn, expd
d1257 28
a1284 2
    t3t = 300.0_rp * onedt
    yi = p * (delta*(t3t**n1) + gamma*(t3t**n2))
d1287 2
a1288 1
      Q_Log = q(2)-q(1)+(q(2)-q(3))/tl1*(Log10(t)-lt2)
d1290 2
a1291 1
      Q_Log =           (q(1)-q(2))/tl2*(Log10(t)-lt3)
d1293 1
a1294 7
    v0s = v0 + ps * p * (t3t**ns)

    betae = el / boltzcm
    betav = v0s / boltzmhz
    Wd = v0 * Sqrt(t/m) * dc
    x1 = sqrtln2 / Wd
    y = x1 * w * p * (t3t**n)
d1296 1
d1298 22
a1319 4
    slabs1 = i2abs * p * 10.0**(i - Q_Log + loge *  betae * (oned300 - onedt)) &
         & * (1.0_rp + expn) / (t * Wd * (1.0_rp - expd))
    dslabs1 = -slabs1 * (expn / (t * (1.0_rp + expn)) + expd / (300.0_rp &
         &  * (1.0_rp - expd))) / boltzmhz
d1323 5
a1327 7
  !  -------------------------------------------  Slabs_prep_wder  -----
  subroutine Slabs_prep_wder ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, &
                            &  gamma, n1, n2,  &
                            &  v0s, x1, y, yi, slabs1, &
                            &  dx1_dv0, dy_dv0, dslabs1_dv0 )

! Slabs_prep_wder: ** ORIGINALLY: Subroutine Slabs_prep()
d1331 1
a1333 2
! ** CHANGED: Jan/5/00  To Include derivatives of x1,y & slabs w.r.t. Nu0
! ** This routine is obselete and probably can be deleted.
d1335 2
a1336 2
    use Physics, only: H_OVER_K
    use Units, only: Ln10, SpeedOfLight
d1340 9
a1348 9
    real(rp), intent(in) :: T       ! Temperature K
    real(rp), intent(in) :: M       ! Molecular mass amu
    real(r8), intent(in) :: V0      ! Line center frequency MHz
    real(rp), intent(in) :: El      ! Lower state energy cm-1
    real(rp), intent(in) :: W       ! Collision broadening parameter
                                    ! MHz/mbar at 300 K
    real(rp), intent(in) :: Ps      ! Pressure shift parameter in MHz/mbar
    real(rp), intent(in) :: P       ! Pressure mbar
    real(rp), intent(in) :: N       ! Temperature power dependence of w
d1350 8
a1357 8
    real(rp), intent(in) :: I       ! Integrated spectral intensity
                                    ! Log(nm**2 MHz) at 300 K
    real(rp), intent(in) :: Q(3)    ! Logarithm of the partition function
                                    ! At 300 , 225 , and 150 K
    real(rp), intent(in) :: Delta   ! Delta interference coefficient at 300K 1/mb
    real(rp), intent(in) :: Gamma   ! Gamma               "
    real(rp), intent(in) :: N1      ! Temperature dependency of delta
    real(rp), intent(in) :: N2      ! Temperature dependency of gamma
d1361 7
a1367 10
    real(r8), intent(out) :: V0s       ! Pressure shifted line position
    real(rp), intent(out) :: X1        ! Sqrt(Ln(2))/Doppler half width MHz
    real(rp), intent(out) :: Y         ! Sqrt(Ln(2))*collision width /
                                       !             doppler width
    real(rp), intent(out) :: Yi        ! Interference contribution
    real(rp), intent(out) :: Slabs1    ! Frequency independent piece of slabs

    real(rp), intent(out) :: Dx1_dv0       ! Derivative of x1 w.r.t. v0
    real(rp), intent(out) :: Dy_dv0        ! Derivative of y w.r.t. v0
    real(rp), intent(out) :: Dslabs1_dv0   ! Derivative of slabs1 w.r.t. v0
d1373 8
d1386 1
a1386 1
!  boltzmhz - boltzmann constant MHz/K
a1387 1
!  loge     - log10(e)
d1389 2
a1390 2
    real(r8), parameter :: I2abs = 3.402136078e9_r8
    real(r8), parameter :: Dc = 3.58117369e-7_r8
d1393 2
a1394 3
    real(r8), parameter :: Sqrtln2 = 8.32554611157698e-1_r8
    real(rp), parameter :: Loge = 1.0_rp / ln10
    real(r8), parameter :: Oned300 = 1.0_r8/300.0_r8
d1396 5
a1400 2
    real(r8), parameter :: Tl1 = 1.76091259055681e-1_r8     ! Log10(225/150)
    real(r8), parameter :: Tl2 = 1.24938736608300e-1_r8     ! Log10(300/225)
d1404 6
a1409 1
    real(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, r, expn, expd
d1413 53
a1465 7
    onedt = 1.0_r8 / t
    t3t = 300.0_r8 * onedt
    yi = p * (delta*(t3t**n1) + gamma*(t3t**n2))

    if ( t < 225.0_r8 ) then
      r = (q(2)-q(3))/tl1
      Q_Log = q(2)-q(1)+r*Log10(t/225.0_r8)
d1467 2
a1468 2
      r = (q(1)-q(2))/tl2
      Q_Log = r*Log10(t/300.0_r8)
d1470 1
d1472 3
a1474 1
    v0s = v0 + ps * p * (t3t**ns)
d1478 39
a1516 11
    Wd = v0s * Dsqrt(t/m) * dc
    x1 = sqrtln2 / Wd
    y = x1 * w * p * (t3t**n)
    expn = EXP(-betav*onedt)
    expd = EXP(-betav*oned300)
    slabs1 = i2abs * p * 10.0**(i - Q_Log + loge *  betae * (oned300-onedt)) &
         & * (1.0_rp + expn) / (t * Wd * (1.0_rp - expd))
    dx1_dv0 = 0.0_rp
    dy_dv0 = 0.0_rp
    dslabs1_dv0 = -slabs1 * (expn / (t * (1.0_rp + expn)) + expd / (300.0_rp &
             &  * (1.0_rp - expd))) / boltzmhz
d1518 1
a1518 1
  end subroutine Slabs_prep_wder
d1559 1
a1559 1
    use Units, only: SpeedOfLight
@


2.24
log
@Futzing
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.23 2003/07/08 00:09:18 vsnyder Exp $"
d102 1
a102 1
  real(rp) function Slabs ( dNu, v0s, x1, tanh1, slabs1, y )
d104 7
a110 4
    real(r8), intent(in) :: v0s
    real(rp), intent(in) :: dNu, x1, tanh1, slabs1, y

!  Note: dNu = v - v0s
a114 3
! inputs: dNu , x1 , tanh1, slabs1 , y, v0s, yi
! output: slabs

d117 1
a117 1
    call real_simple_voigt(x1*dNu,y,u)
d123 1
d125 2
a126 2
    Slabs = slabs1 * (1.0_rp + dNu / v0s) * tanh1 * &
            & (u + OneOvSPi*y/((x1*(2.0_rp*v0s+dNu))**2 + y*y))
d131 1
a131 4
  real(rp) function Slabswint ( dNu, v0s, x1, tanh1, slabs1, y, yi )

    real(r8), intent(in) :: v0s
    real(rp), intent(in) :: dNu, x1, tanh1, slabs1, y, yi
d133 8
a140 1
!  Note: dNu = v - v0s
a144 3
! inputs: dNu , x1 , slabs1 , y, v0s, yi
! output: slabswint (slab with interference)

d147 1
a147 1
    x = x1 * dNu
d154 1
d156 1
a156 1
    p = x1 * (2.0_rp * v0s + dNu)
d158 1
a158 1
    Slabswint = slabs1 *  (1.0_rp + dNu / v0s) * tanh1 * &
d889 2
d973 1
a973 1
    Wd = v0s * Sqrt(t/m) * dc
d977 1
a977 1
    expd = EXP(-betav*oned300)
d1232 3
@


2.23
log
@Inlined several functions
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.22 2003/07/04 02:49:03 vsnyder Exp $"
d124 2
a125 2
    Slabs = slabs1 * (1.0_rp + dNu / v0s) * tanh1 &
              * (u + OneOvSPi*y/((x1*(2.0_rp*v0s+dNu))**2 + y*y))
d143 1
a143 1
    real(rp) :: x, u, q, p, z, y2, w
a152 1
    q = (1.0_rp + dNu / v0s)
d155 2
a156 3
    z = OneOvSPi*((y - p*yi)/(p*p + y2) + yi*x/(x*x+y2))
    w = (u + z) * q
    Slabswint = slabs1 * tanh1 *  w
d1227 3
@


2.22
log
@Simplify interface to Get_GL_Slabs_Arrays
@
text
@d5 1
a5 1
  use Units, only: SqrtPi
d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.21 2003/06/18 14:45:00 bill Exp $"
d255 62
a316 2
    real(rp), parameter :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
    real(rp) :: xa
d325 1
a325 1
    if ( y + 0.666666*xa > 100.0_rp ) then
d327 3
a329 1
      u = rlorentz(xa,y)
d335 4
a338 1
      u = rvoigth2(xa,y)
d344 17
a360 1
      u = rhui6(xa,y)
d366 1
a366 1
      u = rvoigth6(xa,y)
d368 10
d382 32
a413 1
      u = rdrayson(xa,y)
d436 7
a442 3
    real(rp), parameter :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
    real(rp) :: xa
    complex(rp) :: uv
d462 1
a462 1
! Drayson's quick 2pt hermite integral (essentially a lorentz)
d464 7
a470 1
      uv = cvoigth2(xa,y)
d498 1
a498 1
  real(rp) elemental function RLorentz ( x, y )
d500 1
a500 1
! Real Lorentz
d505 1
a505 1
! Internals
d537 1
a537 1
    real(rp), parameter :: gw = 0.28209479177388_rp
d557 1
a557 1
    real(rp), parameter :: gw = 0.28209479177388_rp
a579 1
    real(rp), parameter :: Pi = 3.1415926535897932385_rp
a763 1
    y2 = y*y
d767 8
a781 7
    if ( y <= 1.0e-12_rp ) then
      rdrayson = exp(-X*X)
      return
    end if

!  Taylor series expansion about y = 0.0

d1229 3
@


2.21
log
@added subsetting feature for T-ders
@
text
@a3 1

d5 1
d15 1
a15 1
  real(rp), parameter :: OneOvSPi = 0.56418958354775628695_rp  ! 1.0/Sqrt(Pi)
d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.20 2003/06/13 21:28:20 bill Exp $"
d29 1
a29 1
  SUBROUTINE dVoigt_spectral ( dNu, Nu0, x1, yi, y, w, t, tanh1, slabs1, SwI, &
d41 2
a42 2
    REAL(r8), INTENT(in) :: nu0
    REAL(rp), INTENT(in) :: dnu, x1, yi, y, w, t, tanh1, slabs1             
d49 1
a49 3
!    real(rp) :: dq_dv0
    real(rp) :: dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, & 
                dr_dv0, dvvw_dv0, vvw, slabs2
d102 1
a102 1
  REAL(rp) FUNCTION Slabs ( dNu, v0s, x1, tanh1, slabs1, y )
d104 2
a105 2
    REAL(r8), INTENT(in) :: v0s
    REAL(rp), INTENT(in) :: dNu, x1, tanh1, slabs1, y
d117 1
a117 1
    CALL real_simple_voigt(x1*dNu,y,u)
d130 1
a130 1
  REAL(rp) FUNCTION Slabswint ( dNu, v0s, x1, tanh1, slabs1, y, yi )
d132 2
a133 2
    REAL(r8), INTENT(in) :: v0s
    REAL(rp), INTENT(in) :: dNu, x1, tanh1, slabs1, y, yi
d165 1
a165 1
                         & VL, dslabs1_dNu0,  dVL_dw,  dVL_dn,  dVL_dNu0 )
d180 1
a180 2
     &          dSum_dNu0, slabs2
    real(rp) :: dq_dNu0, Sum
a194 1
    Sum = ddn2 / OneOvSPi
d360 2
a361 2
    u = REAL(uv,KIND=rp)
    if ( present(v) ) v = SIGN(AIMAG(uv),x)
a503 2
! This looks too complicated to split into reals and imaginaries so I
! will do the complex arithmetic here
d525 1
a525 1
!   note that this dimension is 2 less than the a and b coefficients
d528 1
a528 1
!   fill the r, q coefficients with this recursion
a550 2
! This too looks complicated to split into reals and imaginaries so I
! will do the complex arithmetic here
d572 1
a572 1
! note that this dimension is 2 less than the a and b coefficients
d575 1
a575 1
! fill the r, q coefficients with this recursion
d602 1
a602 1
    real(rp), parameter :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
d676 1
a676 1
    real(rp), parameter :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
d749 1
a749 1
  Subroutine Slabs_prep ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, gamma, &
d758 3
d807 2
a808 2
    real(rp), parameter :: Boltzcm = 0.6950387_rp
    real(rp), parameter :: Boltzmhz = 20836.74_rp
d810 1
a810 1
    real(rp), parameter :: Loge = 4.34294481903251828e-1_rp
d821 1
a821 1
    REAL(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, expn, expd
d825 23
a847 23
   onedt = 1.0_rp / t
   t3t = 300.0_rp * onedt
   yi = p * (delta*(t3t**n1) + gamma*(t3t**n2))

   if ( t < 225.0_rp ) then
     Q_Log = q(2)-q(1)+(q(2)-q(3))/tl1*(Log10(t)-lt2)
   else
     Q_Log =           (q(1)-q(2))/tl2*(Log10(t)-lt3)
   end if

   v0s = v0 + ps * p * (t3t**ns)

   betae = el / boltzcm
   betav = v0s / boltzmhz
   Wd = v0s * Sqrt(t/m) * dc
   x1 = sqrtln2 / Wd
   y = x1 * w * p * (t3t**n)
   expn = EXP(-betav*onedt)
   expd = EXP(-betav*oned300)
   slabs1 = i2abs * p * 10.0**(i - Q_Log + loge *  betae * (oned300 - onedt)) &
        & * (1.0_rp + expn) / (t * Wd * (1.0_rp - expd))
   dslabs1 = -slabs1 * (expn / (t * (1.0_rp + expn)) + expd / (300.0_rp &
        &  * (1.0_rp - expd))) / boltzmhz
d849 1
a849 1
 end subroutine Slabs_prep
d852 1
a852 1
  Subroutine Slabs_prep_wder ( t, m, v0, el, w, ps, p, n, ns, i, q, delta, &
d866 3
d918 2
a919 2
    real(r8), parameter :: Boltzcm = 0.6950387_r8
    real(r8), parameter :: Boltzmhz = 20836.74_r8
d921 1
a921 1
    real(r8), parameter :: Loge = 4.34294481903251828e-1_r8
d929 1
a929 1
    REAL(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, r, expn, expd
d961 1
a961 1
 end subroutine Slabs_prep_wder
d964 1
a964 1
  Subroutine Slabs_Prep_Arrays ( molecule, nl, t, p, mass, Qlog, Catalog, &
d976 1
a976 1
    REAL(rp), INTENT(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)
d1000 1
a1000 1
                             &     No_ele, Do_1D, t_der_flags )
a1006 2
    integer(ip), intent(in) :: no_ele

d1011 2
a1012 1
    LOGICAL, intent(in) :: t_der_flags(:)
d1014 1
a1014 1
    type (slabs_struct), pointer :: gl_slabs(:,:)
d1022 1
a1022 3
    integer :: nl,i,j,n_sps, k

    real(rp) :: vel_z_correction, Qlog(3)
d1024 1
a1024 1
    Logical :: Do_1D
d1028 2
a1029 1
    n_sps = Size(Catalog)
a1035 1
      gl_slabs(1:no_ele,i)%no_lines = nl
d1098 3
@


2.20
log
@fixed/improved some bugs with line shape derivative computations
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.19 2003/05/19 19:58:07 vsnyder Exp $"
d1002 1
a1002 1
                             &     No_ele, Do_1D )
d1015 1
d1047 1
a1047 1

d1064 1
a1064 1

d1077 1
a1077 1
          
d1103 3
@


2.19
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.18 2003/05/16 23:53:05 livesey Exp $"
d91 4
a94 4
    db_dv0 = x1
    dg_dv0 = 2.0_rp * b*db_dv0
    dz_dv0 = (-yi*db_dv0-z*dg_dv0)/g
    dr_dv0 = dz_dv0*OneOvSPi+yi*dv_dv0
d96 4
a99 2
    dvvw_dv0 = (du_dv0+dr_dv0)*q
    if ( present(dslabs1_dNu0) ) dSwI_dNu0 = dslabs1_dNu0*vvw + slabs2*dvvw_dv0
d119 1
a119 1
    call real_simple_voigt(x1*dNu,y,u)
d183 1
a183 1
!    real(rp) :: dq_dNu0, Sum
d198 1
a198 1
!    Sum = ddn2 / OneOvSPi
d203 1
a203 1
    up2 = y - yi * xj
d226 3
a228 3
    dup2 =  yi * x1               !  x1 = -dxj_dNu0
    ddn2 = -2.0 * xj * x1         !  x1 = -dxj_dNu0
    dSum_dNu0 = (dn2*dup2-up2*ddn2)/(dn2*dn2)
d235 5
a239 1
    dVL_dNu0 = OneOvSPi * slabs2 * q * dSum_dNu0
d826 1
a826 1
    real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt
d847 2
d850 3
a852 3
        & * (1.0_rp + EXP(-betav*onedt)) &
        & / (t * Wd * (1.0_rp - EXP(-betav*oned300)))
   dslabs1 = 0.0_rp
d931 1
a931 1
    real(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, r
d954 2
d957 1
a957 2
        &  * (1.0_rp + EXP(-betav*onedt)) &
        &  / (t * Wd * (1.0_rp - EXP(-betav*oned300)))
d960 2
a961 1
    dslabs1_dv0 = 0.0_rp
d1102 3
@


2.18
log
@Now uses molecule indices rather than spectags
@
text
@d19 1
a19 1
    & "$Id$"
d22 1
a22 1
    & "$RCSfile$"
d959 1
a959 1
    use Molecules, only: L_N2, L_Extinction
d1091 4
a1094 1
! $Log$
@


2.17
log
@Expect T+DT instead of T and DT separately in Get_GL_Slabs_Arrays
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.16 2003/05/05 23:00:26 livesey Exp $"
d22 1
a22 1
    & "$RCSfile: slabs_sw_m.f90,v $"
d956 1
a956 1
  Subroutine Slabs_Prep_Arrays ( Spectag, nl, t, p, mass, Qlog, Catalog, &
d959 1
a959 1
    use Molecules, only: L_Air_Cont, L_Extinction, L_Liq_H2O, Spec_tags
d963 1
a963 1
    integer(ip), intent(in) :: Spectag, nl
d972 1
a972 2
    if ( spectag==spec_tags(l_liq_h2o) .or. Spectag==spec_tags(l_air_cont) .or. &
      &  spectag==spec_tags(l_extinction) ) return
d974 1
a974 1
! Check for anything but liquid water, dry air or extinction:
d1014 1
a1014 1
    integer :: nl,i,j,n_sps,spectag, k
d1016 1
a1016 1
    real(rp) :: mass, vel_z_correction, Qlog(3)
a1027 3
      Spectag = Catalog(i)%spec_tag
      mass = real(Spectag) / 1000.0_rp

d1037 2
a1038 1
          call Slabs_Prep_Arrays ( Spectag, nl, t_path(j), p_path(j), mass, Qlog, &
d1054 3
a1056 2
          call Slabs_Prep_Arrays ( Spectag, nl, t_path(j), p_path(j), mass, Qlog, &
            &  Catalog(i), gl_slabs(j,i)%v0s, gl_slabs(j,i)%x1, gl_slabs(j,i)%y, &
d1091 4
a1094 1
! $Log: slabs_sw_m.f90,v $
@


2.16
log
@Merged in feb03 newfwm branch
@
text
@d19 1
a19 1
    & "$Id$"
d22 1
a22 1
    & "$RCSfile$"
d992 2
a993 2
  subroutine Get_GL_Slabs_Arrays ( Catalog,p_path,t_path,vel_z,gl_slabs, &
                             &     no_ele, dt, Do_1D )
d1005 1
a1005 1
    real(rp), intent(in) :: vel_z, dt
d1041 1
a1041 1
          call Slabs_Prep_Arrays ( Spectag, nl, t_path(j)+dt, p_path(j), mass, Qlog, &
d1057 1
a1057 1
          call Slabs_Prep_Arrays ( Spectag, nl, t_path(j)+dt, p_path(j), mass, Qlog, &
d1093 4
a1096 1
! $Log$
@


2.15
log
@tested version: in 1D case, compute only each element along the LOS path before tangent point, and fill otherside accordingly
@
text
@d11 1
a11 1
        &  Real_Simple_Voigt, Simple_Voigt, RLorentz, RVoigth2, &
d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.14 2003/01/16 19:08:43 jonathan Exp $"
d22 1
a22 1
    & "$RCSfile: slabs_sw_m.f90,v $"
d29 1
a29 1
  subroutine dVoigt_spectral ( dNu, Nu0, x1, yi, y, w, t, slabs1, SwI,  &
d38 5
a42 1
    real(rp), intent(in) :: dnu, nu0, x1, yi, y, w, t, slabs1             
d47 1
a47 1
    real(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r    
d49 3
a51 2
    real(rp) :: dq_dv0, dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, & 
                dr_dv0, dvvw_dv0, vvw                                     
d54 1
a54 1
    call simple_voigt(x,y,u,v)                                            
a58 1
    q2 = q * q
d64 3
a66 2
    vvw = (u + r) * q2
    SwI = slabs1 * vvw
d76 1
a76 1
    dSwI_dw = q2 * slabs1* (y/w) * (du_dy + yi*du_dx + &
d81 1
a81 1
    dSwI_dn = q2 * slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d87 1
a87 1
    dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
d95 3
a97 2
    dvvw_dv0 = (du_dv0+dr_dv0)*q2 + 2.0_rp*q*dq_dv0*(u+r)
    if ( present(dslabs1_dNu0) ) dSwI_dNu0 = dslabs1_dNu0*vvw + slabs1*dvvw_dv0
d102 1
a102 1
  real(rp) function Slabs ( dNu, v0s, x1, slabs1, y )
d104 2
a105 1
    real(rp), intent(in) :: dNu, v0s, x1, slabs1, y
d112 1
a112 1
! inputs: dNu , x1 , slabs1 , y, v0s, yi
d124 1
a124 1
    Slabs = slabs1 * (1.0_rp + dNu / v0s)**2 &
d130 1
a130 1
  real(rp) function Slabswint ( dNu, v0s, x1, slabs1, y, yi )
d132 2
a133 1
    real(rp), intent(in) :: dNu, v0s, x1, slabs1, y, yi
d153 1
a153 1
    q = (1.0_rp + dNu / v0s)**2
d158 1
a158 1
    Slabswint = slabs1 *  w
d164 2
a165 2
  subroutine Voigt_Lorentz ( dNu,  Nu0,  x1,  yi,  y,  w,  t,  slabs1,  VL,   &
                         &   dslabs1_dNu0,  dVL_dw,  dVL_dn,  dVL_dNu0 )
d173 2
a174 1
    real(rp), intent(in) :: dNu, Nu0, x1, yi, y, w, t, slabs1, dslabs1_dNu0
d178 4
a181 3
    real(rp) :: xj, zj, q, y2, q2, u, v, Sum, up1, up2, dn1, dn2, dup1, &
     &          dup2, ddn1, ddn2, dy_dw, dy_dn, dq_dNu0, dSum_dw, dSum_dn, &
     &          dSum_dNu0
a183 1
    q2 = q * q
d196 3
a198 2
    Sum = ddn2 / OneOvSPi
    VL = slabs1 * ddn2 * q2            ! This is the Voigt + VVW correction
d212 1
a212 1
    dVL_dw = OneOvSPi * slabs1 * q2 * dSum_dw
d222 1
a222 1
    dVL_dn = OneOvSPi * slabs1 * q2 * dSum_dn
d227 1
a227 1
    dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)
d229 5
a233 3
    dVL_dNu0 = OneOvSPi * (dslabs1_dNu0 * q2 * Sum          + &
              &         2.0 * slabs1 * q * dq_dNu0 * Sum + &
              &         slabs1 * q2 * dSum_dNu0)
d323 6
a328 1
    if ( y + 0.666666*xa > 100.0_rp ) then
d330 1
a330 1
      uv = clorentz(xa,y)
d332 1
a332 1
    else if ( y + 0.6875_rp * xa > 11.0_rp ) then
d812 5
a816 2
    real(rp), parameter :: Tl1 = 1.76091259055681e-1_rp     ! Log10(225/150)
    real(rp), parameter :: Tl2 = 1.24938736608300e-1_rp     ! Log10(300/225)
d820 1
a820 2
    real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2, de1
    real(rp) :: de2, g, s, ds
d829 1
a829 2
     r = (q(2)-q(3))/tl1
     Q_Log = q(2)-q(1)+r*Log10(t/225.0_rp)
d831 1
a831 2
     r = (q(1)-q(2))/tl2
     Q_Log = r*Log10(t/300.0_rp)
d841 4
a844 11
   g = i - Q_Log + loge *  betae * (oned300 - onedt)
   r = (i2abs * p * (10.0**g)) / (t * Wd)
   e1 = exp(-betav*onedt)
   e2 = exp(-betav*oned300)
   de1 = -e1*onedt/boltzmhz
   de2 = -e2*oned300/boltzmhz
   g = 1.0_rp - e2
   s = (1.0_rp - e1) / g
   ds = (-de1*g+(1.0_rp-e1)*de2)/(g*g)
   slabs1 = r * s
   dslabs1 = r * ds
d851 2
a852 2
                            &  v0s, x1, y, yi, slabs1, dx1_dv0, dy_dv0, &
                            &  dslabs1_dv0 )
d861 1
d923 1
a923 2
    real(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2
    real(r8) :: de1, de2, g, s, dWd_dv0, dr_dv0, ds_dv0
d946 6
a951 17
    g = i - Q_Log + loge *  betae * (oned300 - onedt)
    r = (i2abs * p * (10.0**g)) / (t * Wd)
    e1 = exp(-betav*onedt)
    e2 = exp(-betav*oned300)
    de1 = -e1*onedt/boltzmhz
    de2 = -e2*oned300/boltzmhz
    g = 1.0_r8 - e2
    s = (1.0_r8 - e1) / g
    ds_dv0 = (-de1*g+(1.0_r8-e1)*de2)/(g*g)
    slabs1 = r * s

    dWd_dv0 = Wd/v0s
    dr_dv0 = -r*dWd_dv0/Wd

    dx1_dv0 = -x1*dWd_dv0/Wd
    dy_dv0 = y*dx1_dv0/x1
    dslabs1_dv0 = r * ds_dv0 + s * dr_dv0
d956 2
a957 2
  Subroutine Slabs_Prep_Arrays ( Spectag, nl, t, p, mass, Qlog, &
                               & Catalog, v0s, x1, y, yi, slabs1, dslabs1_dv0 )
d968 1
a968 1
    real(rp), intent(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)
d1037 1
a1037 1
      IF ( .not. Do_1D ) THEN
d1039 1
a1039 1
      do j = 1, no_ele
d1041 3
a1043 3
        call Slabs_Prep_Arrays ( Spectag, nl, t_path(j)+dt, p_path(j), mass, Qlog, &
          &  Catalog(i), gl_slabs(j,i)%v0s, gl_slabs(j,i)%x1, gl_slabs(j,i)%y, &
          &  gl_slabs(j,i)%yi, gl_slabs(j,i)%slabs1, gl_slabs(j,i)%dslabs1_dv0 )
d1047 1
a1047 1
        gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction
d1049 1
a1049 1
      end do
d1051 1
a1051 1
      ELSE
d1059 1
a1059 1
            &  gl_slabs(j,i)%yi, gl_slabs(j,i)%slabs1, gl_slabs(j,i)%dslabs1_dv0 )
d1063 1
a1063 1
        enddo
d1069 1
a1069 1
          k=no_ele -j + 1
d1077 1
a1077 1
        enddo
d1079 1
a1079 1
      ENDIF
d1093 10
a1102 1
! $Log: slabs_sw_m.f90,v $
d1113 1
a1113 1
! Move SpeedOfLight from Geometry ot Units
@


2.15.2.1
log
@abs coeff obeys detailed balance
@
text
@d11 1
a11 1
        &  Real_Simple_Voigt, Simple_Voigt, RLorentz, CLorentz, RVoigth2, &
d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.15 2003/01/16 19:41:42 jonathan Exp $"
d29 1
a29 1
  SUBROUTINE dVoigt_spectral ( dNu, Nu0, x1, yi, y, w, t, tanh1, slabs1, SwI, &
d38 1
a38 5
! NOTE: In here and in all other routines in this module, 
!       tanh1 = tanh(nu*expa / 2.0)

    REAL(r8), INTENT(in) :: nu0
    REAL(rp), INTENT(in) :: dnu, x1, yi, y, w, t, tanh1, slabs1             
d46 1
a46 1
                dr_dv0, dvvw_dv0, vvw, slabs2
d49 1
a49 1
    call simple_voigt(x,y,u,v)  
d54 1
d60 2
a61 3
    vvw = (u + r) * q
    slabs2 = slabs1 * tanh1
    SwI = slabs2 * vvw
d71 1
a71 1
    dSwI_dw = q * slabs2* (y/w) * (du_dy + yi*du_dx + &
d76 1
a76 1
    dSwI_dn = q * slabs2 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d90 2
a91 3
!    dvvw_dv0 = (du_dv0+dr_dv0)*q + dq_dv0*(u+r)
    dvvw_dv0 = (du_dv0+dr_dv0)*q
    if ( present(dslabs1_dNu0) ) dSwI_dNu0 = dslabs1_dNu0*vvw + slabs2*dvvw_dv0
d96 1
a96 1
  REAL(rp) FUNCTION Slabs ( dNu, v0s, x1, tanh1, slabs1, y )
d98 1
a98 2
    REAL(r8), INTENT(in) :: v0s
    REAL(rp), INTENT(in) :: dNu, x1, tanh1, slabs1, y
d105 1
a105 1
! inputs: dNu , x1 , tanh1, slabs1 , y, v0s, yi
d117 1
a117 1
    Slabs = slabs1 * (1.0_rp + dNu / v0s) * tanh1 &
d123 1
a123 1
  REAL(rp) FUNCTION Slabswint ( dNu, v0s, x1, tanh1, slabs1, y, yi )
d125 1
a125 2
    REAL(r8), INTENT(in) :: v0s
    REAL(rp), INTENT(in) :: dNu, x1, tanh1, slabs1, y, yi
d145 1
a145 1
    q = (1.0_rp + dNu / v0s)
d150 1
a150 1
    Slabswint = slabs1 * tanh1 *  w
d156 2
a157 2
  SUBROUTINE Voigt_Lorentz ( dNu,  Nu0,  x1,  yi,  y,  w,  t,  tanh1, slabs1,  &
                         & VL, dslabs1_dNu0,  dVL_dw,  dVL_dn,  dVL_dNu0 )
d165 1
a165 2
    REAL(r8), INTENT(in) :: nu0
    REAL(rp), INTENT(in) :: dNu, x1, yi, y, w, t, tanh1, slabs1, dslabs1_dNu0
d171 1
a171 1
     &          dSum_dNu0, slabs2
d174 1
d188 1
a188 2
    slabs2 = slabs1 * tanh1
    VL = slabs2 * ddn2 * q            ! This is the Voigt + VVW correction
d202 1
a202 1
    dVL_dw = OneOvSPi * slabs2 * q * dSum_dw
d212 1
a212 1
    dVL_dn = OneOvSPi * slabs2 * q * dSum_dn
d219 3
a221 5
!    dVL_dNu0 = OneOvSPi * (dslabs1_dNu0 * q * Sum          + &
!              &         slabs2 * dq_dNu0 * Sum + &
!              &         slabs2 * q * dSum_dNu0)

    dVL_dNu0 = OneOvSPi * slabs2 * q * dSum_dNu0
d311 1
a311 4
!    if ( y + 0.666666*xa > 100.0_rp ) then
! NOTE: clorentz is not accurate enough for spectral derivative
!       computations. This may be something for Van S. to investigate
!       later.
d313 1
a313 1
!      uv = clorentz(xa,y)
d315 1
a315 3
!    else if ( y + 0.6875_rp * xa > 11.0_rp ) then

    if ( y + 0.6875_rp * xa > 11.0_rp ) then
d824 11
a834 4
   slabs1 = i2abs * p * 10.0**(i - Q_Log + loge *  betae * (oned300 - onedt)) &
        & * (1.0_rp + EXP(-betav*onedt)) &
        & / (t * Wd * (1.0_rp - EXP(-betav*oned300)))
   dslabs1 = 0.0_rp
d841 2
a842 2
                            &  v0s, x1, y, yi, slabs1, &
                            &  dx1_dv0, dy_dv0, dslabs1_dv0 )
a850 1
! ** This routine is obselete and probably can be deleted.
d936 17
a952 6
    slabs1 = i2abs * p * 10.0**(i - Q_Log + loge *  betae * (oned300-onedt)) &
        &  * (1.0_rp + EXP(-betav*onedt)) &
        &  / (t * Wd * (1.0_rp - EXP(-betav*oned300)))
    dx1_dv0 = 0.0_rp
    dy_dv0 = 0.0_rp
    dslabs1_dv0 = 0.0_rp
d957 2
a958 2
  Subroutine Slabs_Prep_Arrays ( Spectag, nl, t, p, mass, Qlog, Catalog, &
                               & v0s, x1, y, yi, slabs1, dslabs1_dv0 )
d969 1
a969 1
    REAL(rp), INTENT(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)
d1044 1
a1044 1
          &  gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0 )
d1060 1
a1060 1
            & gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0 )
a1094 3
! Revision 2.15  2003/01/16 19:41:42  jonathan
! tested version: in 1D case, compute only each element along the LOS path before tangent point, and fill otherside accordingly
!
@


2.15.2.2
log
@Cosmetic changes, get rid of declared but unused variables
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.15.2.1 2003/02/13 17:29:26 bill Exp $"
d47 1
a47 1
    real(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, b, g, z, r    
d49 1
a49 2
!    real(rp) :: dq_dv0
    real(rp) :: dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, & 
d86 1
a86 1
!    dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
d163 1
a163 1
  subroutine Voigt_Lorentz ( dNu,  Nu0,  x1,  yi,  y,  w,  t,  tanh1, slabs1,  &
d172 2
a173 2
    real(r8), intent(in) :: nu0
    real(rp), intent(in) :: dNu, x1, yi, y, w, t, tanh1, slabs1, dslabs1_dNu0
d177 2
a178 2
    real(rp) :: xj, zj, q, y2, u, v, up1, up2, dn1, dn2, dup1, &
     &          dup2, ddn1, ddn2, dy_dw, dy_dn, dSum_dw, dSum_dn, &
a179 1
!    real(rp) :: dq_dNu0, Sum
d194 1
a194 1
!    Sum = ddn2 / OneOvSPi
d225 1
a225 1
!    dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)
d810 2
a811 5
    real(rp), parameter :: LT2 = 2.35218251811136_rp      ! Log10(225)
    real(rp), parameter :: LT3 = 2.47712125471966_rp      ! Log10(300)

    real(rp), parameter :: Tl1 = 0.176091259055681_rp     ! Log10(225/150)
    real(rp), parameter :: Tl2 = 0.124938736608300_rp     ! Log10(300/225)
d815 2
a816 1
    real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt
d825 2
a826 1
     Q_Log = q(2)-q(1)+(q(2)-q(3))/tl1*(Log10(t)-lt2)
d828 2
a829 1
     Q_Log =           (q(1)-q(2))/tl2*(Log10(t)-lt3)
d921 2
a922 1
    real(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, r
d1036 1
a1036 1
      if ( .not. Do_1D ) then
d1038 1
a1038 1
        do j = 1, no_ele
d1040 3
a1042 3
          call Slabs_Prep_Arrays ( Spectag, nl, t_path(j)+dt, p_path(j), mass, Qlog, &
            &  Catalog(i), gl_slabs(j,i)%v0s, gl_slabs(j,i)%x1, gl_slabs(j,i)%y, &
            &  gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0 )
d1046 1
a1046 1
          gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction
d1048 1
a1048 1
        end do
d1050 1
a1050 1
      else
d1062 1
a1062 1
        end do
d1068 1
a1068 1
          k = no_ele - j + 1
d1076 1
a1076 1
        end do
d1078 1
a1078 1
      end if
a1092 3
! Revision 2.15.2.1  2003/02/13 17:29:26  bill
! abs coeff obeys detailed balance
!
d1106 1
a1106 1
! Move SpeedOfLight from Geometry to Units
@


2.14
log
@testing
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.13 2003/01/16 18:50:20 jonathan Exp $"
d1016 1
a1016 1
    integer :: nl,i,j,n_sps,spectag
d1054 1
a1054 6
        ! NEED MORE WORK HERE -JHJ
        PRINT*, NO_ELE 
        ! compute first element along the LOS path
        call Slabs_Prep_Arrays ( Spectag, nl, t_path(1)+dt, p_path(1), mass, Qlog, &
          &  Catalog(i), gl_slabs(1,i)%v0s, gl_slabs(1,i)%x1, gl_slabs(1,i)%y, &
          &  gl_slabs(1,i)%yi, gl_slabs(1,i)%slabs1, gl_slabs(1,i)%dslabs1_dv0 )
d1056 9
a1064 1
        gl_slabs(1,i)%v0s = gl_slabs(1,i)%v0s * Vel_z_correction
d1066 11
a1076 9
        ! fill other grid points with value of the first grid point
        do j = 2, no_ele

          gl_slabs(j,i)%v0s         = gl_slabs(1,i)%v0s
          gl_slabs(j,i)%x1          = gl_slabs(1,i)%x1
          gl_slabs(j,i)%y           = gl_slabs(1,i)%y
          gl_slabs(j,i)%yi          = gl_slabs(1,i)%yi 
          gl_slabs(j,i)%slabs1      = gl_slabs(1,i)%slabs1 
          gl_slabs(j,i)%dslabs1_dv0 = gl_slabs(1,i)%dslabs1_dv0
a1078 1

d1095 3
@


2.13
log
@For 1D FWM compute first element along the LOS path then fill other grid points with value of the first grid point
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.12 2003/01/16 18:04:12 jonathan Exp $"
d1054 2
d1091 3
@


2.12
log
@add Do_1D option to get_gl_slabs_arrays
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.11 2003/01/10 21:55:26 vsnyder Exp $"
d1038 2
d1050 3
d1054 21
a1074 1
      end do
d1089 3
@


2.11
log
@Move SpeedOfLight from Geometry ot Units
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.10 2002/12/20 20:22:59 vsnyder Exp $"
d994 1
a994 1
                             &     no_ele,dt )
d1020 2
d1064 3
@


2.10
log
@Cosmetic changes
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.9 2002/12/03 00:34:23 vsnyder Exp $"
d996 1
a996 1
    use Geometry, only: SpeedOfLight
d1062 3
@


2.9
log
@Test optional argument presence before using them
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.8 2002/10/08 17:08:06 pwagner Exp $"
d32 2
a33 2
! Computes the Voigt function and its first derivative with respect
! to spectaral parameters: w, n & Nu0
a92 1
    return
a119 1
    return
a151 1
    return
d158 3
a160 2
 ! Computes the Voigt/Lorentz function and its first derivative with respect
! to spectaral parameters: w, n & Nu0
a222 1
    return
d389 1
a389 1
    y2 = y*y
d467 1
a467 1
    real(rp) :: denom1,denom2,xp,xm
d470 1
d474 2
a475 2
      denom1 = gw(i)/(y**2 + xm**2)
      denom2 = gw(i)/(y**2 + xp**2)
a835 1
   return
a953 2
    return

d1051 1
a1051 1
    return
a1052 2
  end subroutine Get_GL_Slabs_Arrays
!
d1062 3
@


2.8
log
@Added idents to survive zealous Lahey optimizer
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.7 2002/10/02 21:06:03 vsnyder Exp $"
d91 1
a91 1
    dSwI_dNu0 = dslabs1_dNu0*vvw + slabs1*dvvw_dv0
d345 1
a345 1
    v = SIGN(AIMAG(uv),x)
d1069 3
@


2.7
log
@Get SpeedOfLight from Geometry module
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.6 2002/09/12 23:00:04 vsnyder Exp $"
d23 1
d1062 4
d1069 3
@


2.6
log
@Cosmetic changes, move USEs from module scope to procedure scope
@
text
@d19 1
a19 1
    & "$Id: slabs_sw_m.f90,v 2.5 2002/08/05 17:51:15 jonathan Exp $"
d1000 1
d1018 1
a1018 1
    real(rp), parameter :: c = 299792.4583_rp     ! Speed of Light Km./Sec.
d1057 1
a1057 1
  end subroutine get_gl_slabs_arrays
d1064 3
@


2.5
log
@debug
@
text
@d7 1
a7 1
  Implicit NONE
d9 7
a15 5
  Private
  Public :: dvoigt_spectral, slabs, slabswint, voigt_lorentz, &
        &  real_simple_voigt, simple_voigt, rlorentz, rvoigth2, &
        &  cvoigth2, rvoigth6, cvoigth6, rhui6, chui6, rdrayson, &
        &  cdrayson, slabs_prep, slabs_prep_arrays, get_gl_slabs_arrays
a16 2
  REAL(rp), PARAMETER :: OneOvSPi = 0.56418958354775628695_rp  ! 1.0/Sqrt(Pi)
!
d18 5
a22 4
  CHARACTER (LEN=256) :: Id = &
  "$Id: slabs_sw_m.f90,v 2.4 2001/12/14 23:43:44 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
  "$RCSfile: slabs_sw_m.f90,v $"
d24 1
a24 1
CONTAINS
d26 6
a31 1
! Computes the voigt function and its first derivative with respect
d33 1
a33 1
!
a35 6
!
 Subroutine dvoigt_spectral(dNu,Nu0,x1,yi,y,w,t,slabs1,SwI, &
                         &  dslabs1_dNu0,dSwI_dw,dSwI_dn,dSwI_dNu0)
!
  REAL(rp), INTENT(IN) :: dnu, nu0, x1, yi, y, w, t, slabs1
  Real(rp), INTENT(IN), OPTIONAL :: dslabs1_dNu0
d37 13
a49 10
  Real(rp), INTENT(OUT) :: SwI, dSwI_dw,dSwI_dn,dSwI_dNu0
!
  REAL(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r
!
  Real(rp) :: dq_dv0, dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, &
              dr_dv0, dvvw_dv0, vvw
!
  x = x1 * dNu
  Call simple_voigt(x,y,u,v)
!
d51 17
a67 17
!
  q = 1.0_rp + dNu / Nu0
  q2 = q * q
!
  b = x1 * (2.0_r8 * Nu0 + dNu)
  g = b * b + y * y
  z = (y - b * yi) / g
  r = z * OneOvSPi + yi * v
  vvw = (u + r) * q2
  SwI = slabs1 * vvw
!
  du_dx = 2.0_rp * (y * v - x * u)
  du_dy = 2.0_rp * (y * u + x * v - OneOvSPi)
!
  dv_dx = -du_dy         ! Cauchy-Riemann equation
  dv_dy =  du_dx         ! Cauchy-Riemann equation
!
d69 4
a72 4
!
  dSwI_dw = q2 * slabs1* (y/w) * (du_dy + yi*du_dx + &
                              &   OneOvSPi*((1.0_rp-2.0_rp*z*y)/g))
!
d74 3
a76 3
!
  dSwI_dn = q2 * slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
!
d78 1
a78 1
!
d80 20
a99 21
!
  dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
  dx_dv0 = -x1
  du_dv0 = du_dx * dx_dv0
  dv_dv0 = dv_dx * dx_dv0
  db_dv0 = x1
  dg_dv0 = 2.0_rp * b*db_dv0
  dz_dv0 = (-yi*db_dv0-z*dg_dv0)/g
  dr_dv0 = dz_dv0*OneOvSPi+yi*dv_dv0
  dvvw_dv0 = (du_dv0+dr_dv0)*q2 + 2.0_rp*q*dq_dv0*(u+r)
  dSwI_dNu0 = dslabs1_dNu0*vvw + slabs1*dvvw_dv0
!
  Return
 End Subroutine dvoigt_spectral
!
!---------------------------------------------------------------------
!
 Real(rp) Function Slabs(dNu,v0s,x1,slabs1,y)
!
  REAL(rp), INTENT(IN) :: dNu, v0s, x1, slabs1, y
!
d101 1
a101 1
!
d104 1
a104 1
!
d107 5
a111 5
!
  REAL(rp) :: u
!
  Call real_simple_voigt(x1*dNu,y,u)
!
d116 12
a127 13
!
  Slabs = slabs1 * (1.0_rp + dNu / v0s)**2 &
            * (u + OneOvSPi*y/((x1*(2.0_rp*v0s+dNu))**2 + y*y))
!
  Return
 End Function Slabs
!
!---------------------------------------------------------------------
!
 Real(rp) Function Slabswint(dNu,v0s,x1,slabs1,y,yi)
!
  REAL(rp), INTENT(IN) :: dNu, v0s, x1, slabs1, y, yi
!
d129 1
a129 1
!
d132 1
a132 1
!
d136 5
a140 5
  Real(rp) :: x, u, q, p, z, y2, w
!
  x = x1 * dNu
  Call real_simple_voigt(x,y,u)
!
d145 16
a160 13
!
  q = (1.0_rp + dNu / v0s)**2
  p = x1 * (2.0_rp * v0s + dNu)
  y2 = y*y
  z = OneOvSPi*((y - p*yi)/(p*p + y2) + yi*x/(x*x+y2))
  w = (u + z) * q
  Slabswint = slabs1 *  w
!
  Return
 End Function Slabswint
!
!---------------------------------------------------------------------------
! Computes the Voigt/Lorentz function and its first derivative with respect
d162 1
a162 1
!
a164 5
!
 Subroutine Voigt_Lorentz(dNu, Nu0, x1, yi, y, w, t, slabs1, VL,  &
                      &   dslabs1_dNu0, dVL_dw, dVL_dn, dVL_dNu0)
!
  Real(rp), INTENT(IN) :: dNu, Nu0, x1, yi, y, w, t, slabs1, dslabs1_dNu0
d166 17
a182 15
  Real(rp), INTENT(OUT) :: VL, dVL_dw, dVL_dn, dVL_dNu0
!
  Real(rp) :: xj, zj, q, y2, q2, u, v, Sum, up1, up2, dn1, dn2, dup1, &
   &          dup2, ddn1, ddn2, dy_dw, dy_dn, dq_dNu0, dSum_dw, dSum_dn, &
   &          dSum_dNu0
!
  q = 1.0_rp + dNu / Nu0
  q2 = q * q
!
  y2 = y * y
  xj = x1 * dNu
  zj = x1 * (2.0_r8 * Nu0 + dNu)
  dn1 = zj * zj + y2
  up1 = y - zj * yi
!
a183 28
!
  Call simple_voigt(xj,y,u,v)
  dup1 = up1 * OneOvSPi / dn1 + yi * v
  ddn2 = u + dup1
  Sum = ddn2 / OneOvSPi
  VL = slabs1 * ddn2 * q2            ! This is the Voigt + VVW correction
!
  dn2 = xj * xj + y2
  up2 = y - yi * xj
!
  dy_dw = y / w
  dup1 = dy_dw
  ddn1 = 2.0 * y * dy_dw
  dup2 = dy_dw
  ddn2 = 2.0 * y * dy_dw
!
  dSum_dw = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &          (dn2*dup2-up2*ddn2)/(dn2*dn2)
!
  dVL_dw = OneOvSPi * slabs1 * q2 * dSum_dw
!
  dy_dn = y * Log(300.0/t)
  dup1 = dy_dn
  ddn1 = 2.0 * y * dy_dn
  dup2 = dy_dn
  ddn2 = 2.0 * y * dy_dn
  dSum_dn = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &          (dn2*dup2-up2*ddn2)/(dn2*dn2)
d185 45
a229 15
  dVL_dn = OneOvSPi * slabs1 * q2 * dSum_dn
!
  dup2 =  yi * x1               !  x1 = -dxj_dNu0
  ddn2 = -2.0 * xj * x1         !  x1 = -dxj_dNu0
  dSum_dNu0 = (dn2*dup2-up2*ddn2)/(dn2*dn2)
  dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)
!
  dVL_dNu0 = OneOvSPi * (dslabs1_dNu0 * q2 * Sum          + &
            &         2.0 * slabs1 * q * dq_dNu0 * Sum + &
            &         slabs1 * q2 * dSum_dNu0)
!
  Return
 End Subroutine Voigt_Lorentz
!
!---------------------------------------------------------------------------
d231 1
a231 3
!
  ELEMENTAL SUBROUTINE real_simple_voigt(x,y,u)
!
d233 4
a236 4
!
  REAL(rp), INTENT(in) :: x ! doppler width, del frequency ratio
  REAL(rp), INTENT(in) :: y ! doppler width, collision width ratio
!
d238 3
a240 3
!
  REAL(rp), INTENT(out) :: u ! real part of Voigt
!
d242 4
a245 4
!
  REAL(rp), PARAMETER :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
  REAL(rp) :: xa
!
d247 3
a249 3
!
  xa = ABS(x)
!
d252 7
a258 7
!
  IF(y + 0.666666*xa > 100.0_rp) THEN
!
    u = rlorentz(xa,y)
!
  ELSE IF(y + 0.6875_rp * xa > 11.0_rp) THEN
!
d260 5
a264 5
!
    u = rvoigth2(xa,y)
!
  ELSE IF(y > 0.6_rp .OR. y > yl + dydx*xa) THEN
!
d266 5
a270 5
!
    u = rhui6(xa,y)
!
  ELSE IF(xa > 5.2_rp) THEN
!
d272 5
a276 5
!
    u = rvoigth6(xa,y)
!
  ELSE
!
d278 10
a287 8
!
    u = rdrayson(xa,y)
!
  ENDIF
!
  END SUBROUTINE real_simple_voigt
!
!---------------------------------------------------------------------------
d289 1
a289 3
!
  ELEMENTAL SUBROUTINE simple_voigt(x,y,u,v)
!
d291 4
a294 4
!
  REAL(rp), INTENT(in) :: x ! doppler width, del frequency ratio
  REAL(rp), INTENT(in) :: y ! doppler width, collision width ratio
!
d296 4
a299 4
!
  REAL(rp), INTENT(out) :: u ! real part of Voigt
  REAL(rp), OPTIONAL, INTENT(out) :: v ! imaginary part of Voigt
!
d301 5
a305 5
!
  REAL(rp), PARAMETER :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
  REAL(rp) :: xa
  COMPLEX(rp) :: uv
!
d307 3
a309 3
!
  xa = ABS(x)
!
d312 7
a318 7
!
  IF(y + 0.666666*xa > 100.0_rp) THEN
!
    uv = clorentz(xa,y)
!
  ELSE IF(y + 0.6875_rp * xa > 11.0_rp) THEN
!
d320 5
a324 5
!
    uv = cvoigth2(xa,y)
!
  ELSE IF(y > 0.6_rp .OR. y > yl + dydx*xa) THEN
!
d326 5
a330 5
!
    uv = chui6(xa,y)
!
  ELSE IF(xa > 5.2_rp) THEN
!
d332 5
a336 5
!
    uv = cvoigth6(xa,y)
!
  ELSE
!
d338 13
a350 11
!
    uv = cdrayson(xa,y)
!
  ENDIF
!
  u = REAL(uv,KIND=rp)
  v = SIGN(AIMAG(uv),x)
!
  END SUBROUTINE simple_voigt
!
!---------------------------------------------------------------------------
d352 4
a355 5
!
  REAL(rp) ELEMENTAL FUNCTION rlorentz(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
d357 23
a379 21
!
  rlorentz = OneOvSPi * y / (y*y + x*x)
!
  END FUNCTION rlorentz
!
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION clorentz(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  REAL(rp) :: denom
!
  denom = OneOvSPi / (x*x + y*y)
  clorentz = CMPLX(y*denom,x*denom,KIND=rp)
!
  END FUNCTION clorentz
!
!---------------------------------------------------------------------------
d381 19
a399 18
!
  REAL(rp) ELEMENTAL FUNCTION rvoigth2(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  REAL(rp), PARAMETER :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
  REAL(rp), PARAMETER :: gw = 0.28209479177388_rp
  REAL(rp) :: y2
!
  y2 = y*y
  rvoigth2 = gw * y * (1.0_rp/(y2 + (x-gx)**2) + &
           &           1.0_rp/(y2 + (x+gx)**2))
!
  END FUNCTION rvoigth2
!
!---------------------------------------------------------------------------
d401 22
a422 22
!
  COMPLEX(rp) ELEMENTAL FUNCTION cvoigth2(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  REAL(rp), PARAMETER :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
  REAL(rp), PARAMETER :: gw = 0.28209479177388_rp
  REAL(rp) :: denom1,denom2,xm,xp,y2
!
  xm = x-gx
  xp = x+gx
  y2 = y**2
  denom1 = gw/(y2 + xm**2)
  denom2 = gw/(y2 + xp**2)
  cvoigth2 = CMPLX(y*(denom1+denom2),xm*denom1 + xp*denom2,KIND=rp)
!
  END FUNCTION cvoigth2
!
!---------------------------------------------------------------------------
d424 29
a452 28
!
  REAL(rp) ELEMENTAL FUNCTION rvoigth6(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  INTEGER, PARAMETER :: n = 3
  REAL(rp), PARAMETER :: Pi = 3.1415926535897932385_rp
  REAL(rp), PARAMETER :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                    1.33584907401369694957_rp,    &
                                    2.35060497367449222280_rp /)
  REAL(rp), PARAMETER :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                    1.57067320322856644036e-1_rp, &
                                    4.53000990550884564224e-3_rp /) / Pi
  REAL(rp) :: y2
  INTEGER :: i
!
  rvoigth6 = 0.0
  y2 = y**2
  DO i = 1 , n
    rvoigth6 = rvoigth6 + gw(i) * y * (1.0_rp/(y2 + (x-gx(i))**2) + &
                                   &   1.0_rp/(y2 + (x+gx(i))**2))
  ENDDO
!
  END FUNCTION rvoigth6
!
!---------------------------------------------------------------------------
d454 31
a484 33
!
  COMPLEX(rp) ELEMENTAL FUNCTION cvoigth6(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  INTEGER, PARAMETER :: n = 3
  REAL(rp), PARAMETER :: Pi = 3.1415926535897932385_rp
  REAL(rp), PARAMETER :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                    1.33584907401369694957_rp,    &
                                    2.35060497367449222280_rp /)
  REAL(rp), PARAMETER :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                    1.57067320322856644036e-1_rp, &
                                    4.53000990550884564224e-3_rp /) / Pi
  INTEGER :: i
  REAL(rp) :: denom1,denom2,xp,xm
!
  cvoigth6 = CMPLX(0.0_rp,0.0_rp)
  DO i = 1 , n
    xm = x-gx(i)
    xp = x+gx(i)
    denom1 = gw(i)/(y**2 + xm**2)
    denom2 = gw(i)/(y**2 + xp**2)
    cvoigth6 = cvoigth6+CMPLX(y*(denom1+denom2),xm*denom1+xp*denom2,KIND=rp)
  ENDDO
!
  END FUNCTION cvoigth6
!
!---------------------------------------------------------------------------
  REAL(rp) ELEMENTAL FUNCTION rhui6(x,y)
!
d486 1
a486 1
! This too looks complicated to split into reals and imaginaries so I
d488 46
a533 46
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internal stuff
!
  REAL(rp), PARAMETER :: a(7) = (/ &
     &     122.607931777104326_rp, 214.382388694706425_rp, &
     &     181.928533092181549_rp,  93.155580458138441_rp, &
     &      30.180142196210589_rp,   5.912626209773153_rp, &
     &       0.564189583562615_rp /)
!
  REAL(rp), PARAMETER :: b(7) = (/ &
     &     122.607931773875350_rp, 352.730625110963558_rp, &
     &     457.334478783897737_rp, 348.703917719495792_rp, &
     &     170.354001821091472_rp,  53.992906912940207_rp, &
     &      10.479857114260399_rp /)
!
  INTEGER :: i
  REAL :: rs,rt,is,it,r(5),q(5)
!
! note that this dimension is 2 less than the a and b coefficients
! because we start the r and q coeffients at 2. r(0)=1.0,r(1) = y
! q(0) = 0.0, q(1) = -x
! fill the r, q coefficients with this recursion
!
  r(1) = y**2 - x**2
  q(1) = -2.0_rp*x*y
  DO i = 2 , 5
    r(i) = x * q(i-1) + y * r(i-1)
    q(i) = y * q(i-1) - x * r(i-1)
  ENDDO
  rs = a(1) + a(2)*y + SUM(a(3:)*r)
  rt = b(1) + b(2)*y + SUM(b(3:)*r) + x * q(5) + y * r(5)
  is =      - a(2)*x + SUM(a(3:)*q)
  it =      - b(2)*x + SUM(b(3:)*q) + y * q(5) - x * r(5)
!
  rhui6 = (rs*rt + is*it) / (rt*rt + it*it)
!
! FYI ihui6 = (is*rt - rs*it) / (rt*rt + it*it)
!
  END FUNCTION rhui6
!
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION chui6(x,y)
!
d537 4
a540 4
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
d542 16
a557 16
!
  REAL(rp), PARAMETER :: a(7) = (/ &
     &     122.607931777104326_rp, 214.382388694706425_rp, &
     &     181.928533092181549_rp,  93.155580458138441_rp, &
     &      30.180142196210589_rp,   5.912626209773153_rp, &
     &       0.564189583562615_rp /)
!
  REAL(rp), PARAMETER :: b(7) = (/ &
     &     122.607931773875350_rp, 352.730625110963558_rp, &
     &     457.334478783897737_rp, 348.703917719495792_rp, &
     &     170.354001821091472_rp,  53.992906912940207_rp, &
     &      10.479857114260399_rp /)
!
  INTEGER :: i
  REAL :: rs,rt,is,it,r(5),q(5),denom
!
d562 23
a584 23
!
  r(1) = y**2 - x**2
  q(1) = -2.0_rp*x*y
  DO i = 2, 5
    r(i) = x * q(i-1) + y * r(i-1)
    q(i) = y * q(i-1) - x * r(i-1)
  ENDDO
!
  rs = a(1) + a(2)*y + SUM(a(3:)*r)
  rt = b(1) + b(2)*y + SUM(b(3:)*r) + x * q(5) + y * r(5)
  is =      - a(2)*x + SUM(a(3:)*q)
  it =      - b(2)*x + SUM(b(3:)*q) + y * q(5) - x * r(5)
  denom = 1.0_rp / (rt*rt + it*it)
  chui6 = CMPLX((rs*rt+is*it)*denom, (is*rt-rs*it)*denom,KIND=rp)
!
  END FUNCTION chui6
!
!---------------------------------------------------------------------------
  REAL(rp) ELEMENTAL FUNCTION rdrayson(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
d586 30
a615 38
!
  INTEGER :: I, J, MAXJ, N
  REAL(rp), PARAMETER :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
!
! This is a way to set the mesh points without having to use a SAVE statement
!
  REAL(rp), Parameter :: H = 0.2_rp
  REAL(rp), PARAMETER :: HN(26) = (/(H*(I-1),I=1,26)/)
  REAL(rp), PARAMETER :: RI(15) = (/(-I/2.0_rp,I=1,15)/)
!
  REAL(rp), Parameter :: Dawson(26) = (/  &
     &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
     &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
     &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
     &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
     &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
     &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
     &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
     &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
     &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
     &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
     &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
     &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
     &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)
!
  REAL(rp), PARAMETER :: FDer1(26) = &
           & (/(1.0_rp-2.0_rp*HN(I)*Dawson(I),I=1,26)/)
  REAL(rp), PARAMETER :: FDer2(26) = &
           & (/((HN(I)*FDer1(I)+Dawson(I))/RI(2),I=1,26)/)
  REAL(rp), PARAMETER :: FDer3(26) = &
           & (/((HN(I)*FDer2(I)+FDer1(I))/RI(3),I=1,26)/)
  REAL(rp), PARAMETER :: FDer4(26) = &
           & (/((HN(I)*FDer3(I)+FDer2(I))/RI(4),I=1,26)/)
  REAL(rp), PARAMETER :: FDer5(26) = &
           & (/((HN(I)*FDer4(I)+FDer3(I))/RI(5),I=1,26)/)
  REAL(rp), PARAMETER :: FDer6(26) = &
           & (/((HN(I)*FDer5(I)+FDer4(I))/RI(6),I=1,26)/)
!
d617 4
a620 4
!
  REAL(rp) :: Y2, DX, F, FD, W, dely
  Y2 = y*y
!
d622 13
a634 13
!
  J = X / H
  N = 1 + MIN(J, 25)
  DX = X - HN(N)
  F = 0.0_rp
  IF(X > 0.05*H) &
     F = (((((FDer6(N)*DX + FDer5(N))*DX + FDer4(N))*DX  + &
           &  FDer3(N))*DX + FDer2(N))*DX + FDer1(N))*DX + Dawson(N)
  IF(Y <= 1.0e-12_rp) THEN
    rdrayson = EXP(-X*X)
    RETURN
  ENDIF
!
d636 23
a658 23
!
  dely = -Y
  FD = 1.0_rp - 2.0_rp * X * F
  w = FD * dely
  J = 5.0_rp + (12.5_rp - X) * 0.8_rp * Y
  MAXJ = MIN(J, 14)
  DO J = 2, MAXJ,2
    F  = (X*FD + F) / RI(J)
    FD  = (X*F + FD) / RI(J+1)
    dely = -y2 * dely
    w = w + FD * dely
  END DO
!
  rdrayson = EXP(y2-x*x)*COS(2.0_rp*x*y) + TwoOvSpi*w
!
  END FUNCTION rdrayson
!
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION cdrayson(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
d660 4
a663 4
!
  INTEGER :: I, J, MAXJ, N
  REAL(rp), PARAMETER :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
!
d665 27
a691 33
!
  REAL(rp), Parameter :: H = 0.2_rp
  REAL(rp), PARAMETER :: HN(26) = (/(H*(I-1),I=1,26)/)
  REAL(rp), PARAMETER :: RI(15) = (/(-I/2.0_rp,I=1,15)/)
!
  REAL(rp), Parameter :: Dawson(26) = (/  &
     &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
     &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
     &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
     &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
     &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
     &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
     &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
     &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
     &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
     &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
     &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
     &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
     &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)
!
  REAL(rp), PARAMETER :: FDer1(26) = &
           & (/(1.0_rp-2.0_rp*HN(I)*Dawson(I),I=1,26)/)
  REAL(rp), PARAMETER :: FDer2(26) = &
           & (/((HN(I)*FDer1(I)+Dawson(I))/RI(2),I=1,26)/)
  REAL(rp), PARAMETER :: FDer3(26) = &
           & (/((HN(I)*FDer2(I)+FDer1(I))/RI(3),I=1,26)/)
  REAL(rp), PARAMETER :: FDer4(26) = &
           & (/((HN(I)*FDer3(I)+FDer2(I))/RI(4),I=1,26)/)
  REAL(rp), PARAMETER :: FDer5(26) = &
           & (/((HN(I)*FDer4(I)+FDer3(I))/RI(5),I=1,26)/)
  REAL(rp), PARAMETER :: FDer6(26) = &
           & (/((HN(I)*FDer5(I)+FDer4(I))/RI(6),I=1,26)/)
!
d693 3
a695 3
!
  REAL(rp) :: DX, F, FD,wr,wi,dely,twoxy
!
d697 13
a709 13
!
  J = X / H
  N = 1 + MIN(J, 25)
  DX = X - HN(N)
  F = 0.0_rp
  IF(X.gt.0.05*H) &
     F = (((((FDer6(N)*DX + FDer5(N))*DX + FDer4(N))*DX  + &
           &  FDer3(N))*DX + FDer2(N))*DX + FDer1(N))*DX + Dawson(N)
  IF(Y <= 1.0e-12_rp) THEN
    cdrayson = CMPLX(EXP(-X*X),TwoOvSPi * F,KIND=rp)
    RETURN
  ENDIF
!
d711 29
a739 25
!
  wr = EXP(y*y-x*x)
  twoxy = 2.0_rp*x*y
  cdrayson = CMPLX(wr*COS(twoxy),-wr*SIN(twoxy),KIND=rp)
  dely = -TwoOvSpi*Y
  FD = 1.0_rp - 2.0_rp * X * F
  wi = TwoOvSpi*F
  wr = FD*dely
  j = 5.0 + 10.0*y - 0.4*twoxy
  MAXJ = MIN(J, 14)
  DO J = 2, MAXJ,2
    F  = (X*FD + F) / RI(J)
    FD = (X*F + FD) / RI(J+1)
    dely = y * dely
    wi = wi + f*dely
    dely = -y*dely
    wr = wr + FD*dely
  END DO
!
  cdrayson = cdrayson + CMPLX(wr,wi,KIND=rp)
!
  END FUNCTION cdrayson
!
!---------------------------------------------------------------------
! This function will compute a single line type absorption coefficient
d741 1
a741 1
!
d743 1
a743 6
!
 Subroutine Slabs_prep(t,m,v0,el,w,ps,p,n,ns,i,q,delta,gamma,n1,n2, &
                    &  v0s,x1,y,yi,slabs1,dslabs1)
!
  implicit none
!
d745 20
a764 20
!
  Real(rp), INTENT(IN) :: t        ! Temperature K
  Real(rp), INTENT(IN) :: m        ! Molecular mass amu
  Real(r8), INTENT(IN) :: v0       ! Line center frequency MHz
  Real(rp), INTENT(IN) :: el       ! Lower state energy cm-1
  Real(rp), INTENT(IN) :: w        ! Collision broadening parameter
                                   ! MHz/mbar at 300 K
  Real(rp), INTENT(IN) :: ps       ! Pressure shift parameter in MHz/mbar
  Real(rp), INTENT(IN) :: p        ! Pressure mbar
  Real(rp), INTENT(IN) :: n        ! Temperature power dependence of w
  Real(rp), INTENT(IN) :: ns       ! Temperature power dependence of ps
  Real(rp), INTENT(IN) :: i        ! Integrated spectral intensity
                                   ! Log(nm**2 MHz) at 300 K
  Real(rp), INTENT(IN) :: q(3)     ! Logarithm of the partition function
                                   ! At 300 , 225 , and 150 K
  Real(rp), INTENT(IN) :: delta    ! Delta interference coefficient at 300K 1/mb
  Real(rp), INTENT(IN) :: gamma    ! Gamma               "
  Real(rp), INTENT(IN) :: n1       ! Temperature dependency of delta
  Real(rp), INTENT(IN) :: n2       ! Temperature dependency of gamma
!
d766 9
a774 9
!
  Real(r8), INTENT(OUT) :: v0s     ! Pressure shifted line position
  Real(rp), INTENT(OUT) :: x1      ! Sqrt(Ln(2))/Doppler half width MHz
  Real(rp), INTENT(OUT) :: y       ! Sqrt(Ln(2))*collision width /
                                   !             doppler width
  Real(rp), INTENT(OUT) :: yi      ! Interference contribution
  Real(rp), INTENT(OUT) :: slabs1  ! Frequency independent piece of slabs
  Real(rp), INTENT(OUT) :: dslabs1 ! Derivative of slabs1 w.r.t. v0
!
d778 1
a778 1
!
d780 1
a780 1
!
d787 12
a798 12
!
  Real(rp), Parameter :: i2abs = 3.402136078e9_rp
  Real(rp), Parameter :: dc = 3.58117369e-7_rp
  Real(rp), Parameter :: boltzcm = 0.6950387_rp
  Real(rp), Parameter :: boltzmhz = 20836.74_rp
  Real(rp), Parameter :: sqrtln2 = 8.32554611157698e-1_rp
  Real(rp), Parameter :: loge = 4.34294481903251828e-1_rp
  Real(rp), Parameter :: oned300 = 1.0_rp/300.0_rp
!
  Real(rp), parameter :: tl1 = 1.76091259055681e-1_rp     ! Log10(225/150)
  Real(rp), parameter :: tl2 = 1.24938736608300e-1_rp     ! Log10(300/225)
!
d800 4
a803 4
!
  Real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2, de1, &
              de2, g, s, ds
!
d805 41
a845 36
!
  onedt = 1.0_rp / t
  t3t = 300.0_rp * onedt
  yi = p * (delta*(t3t**n1) + gamma*(t3t**n2))
!
  if (t < 225.0_rp) then
    r = (q(2)-q(3))/tl1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_rp)
  else
    r = (q(1)-q(2))/tl2
    Q_Log = r*Log10(t/300.0_rp)
  endif
!
  v0s = v0 + ps * p * (t3t**ns)
!
  betae = el / boltzcm
  betav = v0s / boltzmhz
  Wd = v0s * Sqrt(t/m) * dc
  x1 = sqrtln2 / Wd
  y = x1 * w * p * (t3t**n)
  g = i - Q_Log + loge *  betae * (oned300 - onedt)
  r = (i2abs * p * (10.0**g)) / (t * Wd)
  e1 = exp(-betav*onedt)
  e2 = exp(-betav*oned300)
  de1 = -e1*onedt/boltzmhz
  de2 = -e2*oned300/boltzmhz
  g = 1.0_rp - e2
  s = (1.0_rp - e1) / g
  ds = (-de1*g+(1.0_rp-e1)*de2)/(g*g)
  slabs1 = r * s
  dslabs1 = r * ds
!
  Return
 End Subroutine Slabs_prep
!
!---------------------------------------------------------------------
d847 2
a848 2
!
! This function will compute a single line type absorption coefficient
d850 1
a850 1
!
d853 1
a853 4
!
 Subroutine Slabs_prep_wder(t,m,v0,el,w,ps,p,n,ns,i,q,delta,gamma,n1,n2, &
     &      v0s,x1,y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0)
!
d855 20
a874 20
!
  Real(rp), INTENT(IN) :: t       ! Temperature K
  Real(rp), INTENT(IN) :: m       ! Molecular mass amu
  Real(r8), INTENT(IN) :: v0      ! Line center frequency MHz
  Real(rp), INTENT(IN) :: el      ! Lower state energy cm-1
  Real(rp), INTENT(IN) :: w       ! Collision broadening parameter
                                  ! MHz/mbar at 300 K
  Real(rp), INTENT(IN) :: ps      ! Pressure shift parameter in MHz/mbar
  Real(rp), INTENT(IN) :: p       ! Pressure mbar
  Real(rp), INTENT(IN) :: n       ! Temperature power dependence of w
  Real(rp), INTENT(IN) :: ns       ! Temperature power dependence of ps
  Real(rp), INTENT(IN) :: i       ! Integrated spectral intensity
                                  ! Log(nm**2 MHz) at 300 K
  Real(rp), INTENT(IN) :: q(3)    ! Logarithm of the partition function
                                  ! At 300 , 225 , and 150 K
  Real(rp), INTENT(IN) :: delta   ! Delta interference coefficient at 300K 1/mb
  Real(rp), INTENT(IN) :: gamma   ! Gamma               "
  Real(rp), INTENT(IN) :: n1      ! Temperature dependency of delta
  Real(rp), INTENT(IN) :: n2      ! Temperature dependency of gamma
!
d876 12
a887 12
!
  Real(r8), INTENT(OUT) :: v0s       ! Pressure shifted line position
  Real(rp), INTENT(OUT) :: x1        ! Sqrt(Ln(2))/Doppler half width MHz
  Real(rp), INTENT(OUT) :: y         ! Sqrt(Ln(2))*collision width /
                                     !             doppler width
  Real(rp), INTENT(OUT) :: yi        ! Interference contribution
  Real(rp), INTENT(OUT) :: slabs1    ! Frequency independent piece of slabs
!
  Real(rp), INTENT(OUT) :: dx1_dv0       ! Derivative of x1 w.r.t. v0
  Real(rp), INTENT(OUT) :: dy_dv0        ! Derivative of y w.r.t. v0
  Real(rp), INTENT(OUT) :: dslabs1_dv0   ! Derivative of slabs1 w.r.t. v0
!
d891 1
a891 1
!
d893 1
a893 1
!
d900 12
a911 12
!
  Real(r8), Parameter :: i2abs = 3.402136078e9_r8
  Real(r8), Parameter :: dc = 3.58117369e-7_r8
  Real(r8), Parameter :: boltzcm = 0.6950387_r8
  Real(r8), Parameter :: boltzmhz = 20836.74_r8
  Real(r8), Parameter :: sqrtln2 = 8.32554611157698e-1_r8
  Real(r8), Parameter :: loge = 4.34294481903251828e-1_r8
  Real(r8), Parameter :: oned300 = 1.0_r8/300.0_r8
!
  Real(r8), parameter :: tl1 = 1.76091259055681e-1_r8     ! Log10(225/150)
  Real(r8), parameter :: tl2 = 1.24938736608300e-1_r8     ! Log10(300/225)
!
d913 4
a916 4
!
  Real(r8) Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2, &
     &     de1, de2, g, s, dWd_dv0, dr_dv0, ds_dv0
!
a917 48
!
  onedt = 1.0_r8 / t
  t3t = 300.0_r8 * onedt
  yi = p * (delta*(t3t**n1) + gamma*(t3t**n2))
!
  if (t < 225.0_r8) then
    r = (q(2)-q(3))/tl1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_r8)
  else
    r = (q(1)-q(2))/tl2
    Q_Log = r*Log10(t/300.0_r8)
  endif
!
  v0s = v0 + ps * p * (t3t**ns)
!
  betae = el / boltzcm
  betav = v0s / boltzmhz
  Wd = v0s * Dsqrt(t/m) * dc
  x1 = sqrtln2 / Wd
  y = x1 * w * p * (t3t**n)
  g = i - Q_Log + loge *  betae * (oned300 - onedt)
  r = (i2abs * p * (10.0**g)) / (t * Wd)
  e1 = exp(-betav*onedt)
  e2 = exp(-betav*oned300)
  de1 = -e1*onedt/boltzmhz
  de2 = -e2*oned300/boltzmhz
  g = 1.0_r8 - e2
  s = (1.0_r8 - e1) / g
  ds_dv0 = (-de1*g+(1.0_r8-e1)*de2)/(g*g)
  slabs1 = r * s
!
  dWd_dv0 = Wd/v0s
  dr_dv0 = -r*dWd_dv0/Wd
!
  dx1_dv0 = -x1*dWd_dv0/Wd
  dy_dv0 = y*dx1_dv0/x1
  dslabs1_dv0 = r * ds_dv0 + s * dr_dv0
!
  Return
!
 End Subroutine Slabs_prep_wder
!
! --------------------------------  slabs_prep_arrays   -----
!
 Subroutine Slabs_Prep_Arrays(Spectag,nl,t,p,mass,Qlog,Catalog,v0s,x1,y, &
                           &  yi,slabs1,dslabs1_dv0)
!
 type(catalog_T) :: Catalog
d919 60
a978 1
 Integer(ip), intent(in) :: Spectag, nl
d980 1
a980 1
 Real(rp), intent(in) :: t, p, mass,Qlog(:)
d982 1
a982 4
 Real(r8), intent(out) :: v0s(:)
 Real(rp), intent(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)
!
  Integer :: j, k
a983 6
  if(Spectag==18999 .or. Spectag==28964 .or. Spectag==28965) Return
!
! Check for anything but liquid water and dry air:
!
  do j = 1, nl
!
a984 18
!
    k = Catalog%Lines(j)
    Call Slabs_prep(t,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,        &
      &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%NS,Lines(k)%STR,         &
      &  Qlog,Lines(k)%DELTA,Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,  &
      &  v0s(j),x1(j),y(j),yi(j),slabs1(j),dslabs1_dv0(j))
!
  end do
!
 End Subroutine Slabs_Prep_Arrays
!
!------------------------------------------------------------
  SUBROUTINE get_gl_slabs_arrays(Catalog,p_path,t_path,vel_z,gl_slabs, &
                             &   no_ele,dt)
!
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
!
  Type(Catalog_T), dimension(:), intent(in) :: Catalog
d986 27
a1012 9
 Integer(ip), INTENT(IN) :: no_ele
!
 REAL(rp), INTENT(IN) :: p_path(:) ! Pressure in hPa or mbar
 REAL(rp), INTENT(IN) :: t_path(:)
!
 Real(rp), INTENT(IN) :: vel_z, dt
!
 Type (slabs_struct), POINTER :: gl_slabs(:,:)
!
d1016 7
a1022 7
!
 Real(rp), PARAMETER :: c = 299792.4583_rp     ! Speed of Light Km./Sec.
!
 Integer :: nl,i,j,n_sps,spectag
!
 Real(rp) :: mass, Vel_z_correction, Qlog(3)
!
a1023 12
!
   n_sps = Size(Catalog)
!
   Vel_z_correction = 1.0_rp - vel_z / c
!
   DO i = 1, n_sps
!
     Spectag = Catalog(i)%spec_tag
     mass = Real(Spectag) / 1000.0_rp
!
     nl = Size(Catalog(i)%Lines)
     gl_slabs(1:no_ele,i)%no_lines = nl
d1025 20
a1044 8
     Qlog(1:3) = Catalog(i)%QLOG(1:3)
!
     do j = 1, no_ele
!
       Call Slabs_Prep_Arrays(Spectag,nl,t_path(j)+dt,p_path(j),mass,Qlog, &
         &  Catalog(i),gl_slabs(j,i)%v0s,gl_slabs(j,i)%x1,gl_slabs(j,i)%y, &
         &  gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0)
!
a1045 2
!
       gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction
d1047 10
a1056 8
!
     end do
!
   END DO              ! On i
!
   Return
!
 END SUBROUTINE get_gl_slabs_arrays
d1060 2
a1061 1
End module SLABS_SW_M
d1063 3
@


2.4
log
@Modification for Grouping concept
@
text
@d19 1
a19 1
  "$Id: slabs_sw_m.f90,v 2.3 2001/11/30 01:18:11 zvi Exp $"
d1055 1
d1069 3
@


2.3
log
@Correcting a minor bug
@
text
@d19 1
a19 1
  "$Id: slabs_sw_m.f90,v 2.1 2001/10/17 22:01:00 zvi Exp $"
d1026 1
a1026 1
 Integer :: nl,i,j,no_sps,spectag
d1032 1
a1032 1
   no_sps = Size(Catalog)
d1036 1
a1036 1
   DO i = 1, no_sps
d1068 3
@


2.2
log
@Protecting against negative arg. in Log by max(t,50)
@
text
@d39 1
a39 1
  REAL(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r, Temp
d72 1
a72 2
  Temp = max(50.0_rp,t)
  dSwI_dn = q2 * slabs1 * y * Log(3.0d2/Temp) * (du_dy + yi * dv_dy)
d171 1
a171 1
   &          dSum_dNu0, Temp
d204 1
a204 2
  Temp = max(50.0_rp,t)
  dy_dn = y * Log(300.0/Temp)
d813 1
a813 1
              de2, g, s, ds, Temp
d817 1
a817 2
  Temp = max(50.0_rp,t)
  onedt = 1.0_rp / Temp
d821 1
a821 1
  if (Temp < 225.0_rp) then
d823 1
a823 1
    Q_Log = q(2)-q(1)+r*Log10(Temp/225.0_rp)
d826 1
a826 1
    Q_Log = r*Log10(Temp/300.0_rp)
d833 1
a833 1
  Wd = v0s * Sqrt(Temp/m) * dc
d837 1
a837 1
  r = (i2abs * p * (10.0**g)) / (Temp * Wd)
d923 1
a923 1
  Real(r8) Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2, Temp, &
d928 1
a928 2
  Temp = max(50.0_rp,t)
  onedt = 1.0_r8 / Temp
d932 1
a932 1
  if (Temp < 225.0_r8) then
d934 1
a934 1
    Q_Log = q(2)-q(1)+r*Log10(Temp/225.0_r8)
d937 1
a937 1
    Q_Log = r*Log10(Temp/300.0_r8)
d944 1
a944 1
  Wd = v0s * Dsqrt(Temp/m) * dc
d948 1
a948 1
  r = (i2abs * p * (10.0**g)) / (Temp * Wd)
@


2.1
log
@Eliminate computation of: ns
@
text
@d19 1
a19 1
  "$Id: slabs_sw_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d39 1
a39 1
  REAL(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r
d72 2
a73 1
  dSwI_dn = q2 * slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d172 1
a172 1
   &          dSum_dNu0
d205 2
a206 1
  dy_dn = y * Log(300.0/t)
d815 1
a815 1
              de2, g, s, ds
d819 2
a820 1
  onedt = 1.0_rp / t
d824 1
a824 1
  if (t < 225.0_rp) then
d826 1
a826 1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_rp)
d829 1
a829 1
    Q_Log = r*Log10(t/300.0_rp)
d836 1
a836 1
  Wd = v0s * Sqrt(t/m) * dc
d840 1
a840 1
  r = (i2abs * p * (10.0**g)) / (t * Wd)
d926 1
a926 1
  Real(r8) Wd, Q_Log, betae, betav, t3t, onedt, r, e1, e2, &
d931 2
a932 1
  onedt = 1.0_r8 / t
d936 1
a936 1
  if (t < 225.0_r8) then
d938 1
a938 1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_r8)
d941 1
a941 1
    Q_Log = r*Log10(t/300.0_r8)
d948 1
a948 1
  Wd = v0s * Dsqrt(t/m) * dc
d952 1
a952 1
  r = (i2abs * p * (10.0**g)) / (t * Wd)
d1072 3
@


2.0
log
@New forward model
@
text
@d19 1
a19 1
  "$Id: slabs_sw_m.f90,v 1.4.2.4 2001/09/12 21:38:54 zvi Exp $"
d750 1
a750 1
 Subroutine Slabs_prep(t,m,v0,el,w,ps,p,n,i,q,delta,gamma,n1,n2, &
d766 1
d812 1
a812 1
  Real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, ns, r, e1, e2, de1, &
a828 1
  ns = 0.25_rp + 1.5_rp * n
d860 1
a860 1
 Subroutine Slabs_prep_wder(t,m,v0,el,w,ps,p,n,i,q,delta,gamma,n1,n2, &
d874 1
d923 1
a923 1
  Real(r8) Wd, Q_Log, betae, betav, t3t, onedt, ns, r, e1, e2, &
a939 1
  ns = 0.25_r8 + 1.5_r8 * n
d995 3
a997 3
      &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
      &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0s(j),x1(j),y(j),    &
      &  yi(j),slabs1(j),dslabs1_dv0(j))
d1068 3
@


1.4
log
@Speed enhancement MAJOR update
@
text
@d1 13
a13 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d15 2
a16 7
module SLABS_SW_M
  use MLSCommon, only: I4, R4, R8
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
      PATH_DERIVATIVE, PATH_VECTOR_2D, PATH_INT_VECTOR_2D
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
  use SpectroscopyCatalog_m, only: Catalog_T, Lines
  implicit NONE
d19 1
a19 1
  "$Id: slabs_sw_m.f90,v 1.3 2001/06/07 23:39:32 pwagner Exp $"
d23 1
a23 1
contains
d29 1
a29 4
!       routine to compute dx1_dv0,dy_dv0 and dslabs1_dNu0
!
 Subroutine dvoigt_spectral(dNu,Nu0,x1,yi,y,w,t,slabs1,dx1_dv0, &
     &      dy_dv0,dslabs1_dNu0,SwI,spect_der,dSwI_dw,dSwI_dn,dSwI_dNu0)
d31 2
a32 2
  Real(r8), Parameter :: twovspi = 1.1283791670955125739_r8   ! 2.0/Sqrt(Pi)
  Real(r8), Parameter :: oneovspi = 0.5_r8 * twovspi
d34 2
a35 3
  Logical,  INTENT(IN) :: spect_der
  Real(r8), INTENT(IN) :: dNu, Nu0, x1, yi, y, w, t, slabs1, &
                          dslabs1_dNu0, dx1_dv0, dy_dv0
d37 1
a37 1
  Real(r8), INTENT(OUT) :: SwI,dSwI_dw,dSwI_dn,dSwI_dNu0
d39 1
a39 1
  Real(r8) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r
d41 1
a41 1
  Real(r8) :: dq_dv0, dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, &
d45 1
a45 7
  Call Z_Slabs(x,y,u,v)
!
  du_dx = -2.0_r8 * (x * u - y * v)
  du_dy =  2.0_r8 * (x * v + y * u) - twovspi
!
  dv_dx = -du_dy         ! Cauchy-Riemann equation
  dv_dy =  du_dx         ! Cauchy-Riemann equation
d49 1
a49 1
  q = 1.0_r8 + dNu / Nu0
d55 1
a55 1
  r = z * oneovspi + yi * v
d59 5
a63 1
  if(.not. spect_der) Return
d67 2
a68 3
  dSwI_dw = slabs1 * (y / w) * (du_dy +          &
     &      q2 * oneovspi * (b*b-y*y) / (g*g) +  &
     &      q2 * yi * du_dx)
d72 1
a72 1
  dSwI_dn = slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d79 8
a86 8
  dx_dv0 = dNu * dx1_dv0 - x1
  du_dv0 = du_dx * dx_dv0 + du_dy * dy_dv0
  dv_dv0 = dv_dx * dx_dv0 + dv_dy * dy_dv0
  db_dv0 = (2.0_r8 * Nu0 + dNu)*dx1_dv0 + x1
  dg_dv0 = 2.0_r8 * (b*db_dv0+y*dy_dv0)
  dz_dv0 = (dy_dv0-yi*db_dv0-z*dg_dv0)/g
  dr_dv0 = dz_dv0*oneovspi+yi*dv_dv0
  dvvw_dv0 = (du_dv0+dr_dv0)*q2 + 2.0_r8*q*dq_dv0*(u+r)
d94 28
a121 1
 Real(r8) Function Slabswint(dNu,v0s,x1,slabs1,y,yi)
d123 1
a123 1
  Real(r8), INTENT(IN) :: dNu, v0s, x1, slabs1, y, yi
d125 1
a125 1
  Real(r8), Parameter :: sqrt_pi_i = 1.0_r8/1.7724538509055160273_r8
d135 1
a135 1
  Real(r8) :: x, u, v, q, p, z, r, w
d138 1
a138 1
  Call Z_Slabs(x,y,u,v)
d145 5
a149 5
  q = 1.0_r8 + dNu / v0s
  p = x1 * (2.0_r8 * v0s + dNu)
  z = (y - p * yi)/(p * p + y * y)
  r = z * sqrt_pi_i + yi * v
  w = (u + r) * q * q
d155 46
a200 1
!---------------------------------------------------------------------
d202 1
a202 1
 Subroutine Z_Slabs(x,y,u,v)
d204 14
a217 40
!***********************************************************************
!                                                                      *
! Computes the Voigt function: Integral from - to + infinity of:       *
!                                                                      *
!     u = (y/Pi)*Exp(-t*t)/(y*y+(x-t)*(x-t)) dt        (Real(W(z)))    *
!                                                                      *
!   and:                                                               *
!                                                                      *
!     v = (1/Pi)*(x-t)*Exp(-t*t)/(y*y+(x-t)*(x-t)) dt  (Image(W(z)))   *
!                                                                      *
!   Here:                                                              *
!               x = sqrt(ln 2) * (v - v0) / aD    (x >= 0.0)           *
!               y = sqrt(ln 2) * aL / aD          (y >= 0.0)           *
!                                                                      *
!   Where v is the wave number, v0 is the line center wave number, aL  *
! is the Lorentzian line half-width and aD is the Doppler line         *
! half-width.                                                          *
!                                                                      *
!***********************************************************************
!
  Real(r8), INTENT(IN)  :: x,y
  Real(r8), INTENT(OUT) :: u,v

  Real(r8) :: xa, yh
!
  xa = abs(x)
  if(xa+y > 6.0_r8) then           ! Region 4, Gauss-Hermite 6 points
    Call VoigtH6(xa,y,u,v)
  else
    yh = 1.0e-4*xa*xa
    if(y <= yh) then
      if(xa > 5.0_r8) then
        Call VoigtH6(xa,y,u,v)    ! Region 4, Gauss-Hermite 6 points
      else
        Call Drayson(xa,y,u,v)    ! Region 1, Dowson+Taylor
      endif
    else                          ! Region 2, Hui (p=6)
      Call Hui6(xa,y,u,v)
    endif
  endif
d219 3
a221 1
  if(x < 0.0_r8) v = -v
d224 57
a280 1
 End Subroutine Z_Slabs
d282 24
a305 1
!---------------------------------------------------------------------
d307 1
a307 1
 Subroutine VoigtH6(x,y,u,v)
d309 2
a310 32
!****************************************************************************
! Computes the complex Voigt function: (i/pi)*integral from - to + infinity *
! of : exp(-t*t)/(z -t) dt, where z=(x+iy), x, y >= 0. Using Gauss-Hermite  *
! Quadrature. The real part is u, the integral of:                          *
!                                                                           *
!                 (y/pi)*Exp(-t*t)/(y*y + (x-t)*(x-t)) dt                   *
!                                                                           *
! The imaginary part is v, the integral of:                                 *
!                                                                           *
!                 (1/pi)*(x-t)*Exp(-t*t)/(y*y + (x-t)*(x-t)) dt             *
!                                                                           *
!****************************************************************************
!
  Real(r8), INTENT(IN)  :: x,y
  Real(r8), INTENT(OUT) :: u,v
!
  Real(r8), Parameter :: Pi_i = 1.0_r8/3.1415926535897932385_r8   ! 1/Pi
!
! These are the 6-point-Gauss-Hermite abscissa (X-axis) values in [-1,1]:
! Note: The roots are both positive and negative !
!
  Integer(i4), Parameter :: N = 3
  Real(r8), Parameter :: Gx(N) = (/ &
     & 4.36077411927616508271e-1_r8, 1.33584907401369694957_r8, &
     & 2.35060497367449222280_r8 /)
!
  Real(r8), Parameter :: Gw(N) = (/ &
     & 7.24629595224392524608e-1_r8, 1.57067320322856644036e-1_r8, &
     & 4.53000990550884564224e-3_r8 /)

  Integer(i4) :: i
  Real(r8) :: y2, Sumv, Sumu, t, xpt, xmt, fm, fp
d312 1
a312 3
  y2 = y * y
  Sumu = 0.0_r8
  Sumv = 0.0_r8
d314 1
a314 9
  do i = 1, N
    t = Gx(i)
    xpt = x + t
    xmt = x - t
    fm = 1.0_r8 / (y2 + xmt * xmt)
    fp = 1.0_r8 / (y2 + xpt * xpt)
    Sumu = Sumu + Gw(i) * (fm + fp)
    Sumv = Sumv + Gw(i) * (xmt * fm + xpt * fp)
  end do
d316 1
a316 2
  u = y * Sumu * Pi_i
  v = Sumv * Pi_i
d318 1
a318 2
  Return
 End Subroutine VoigtH6
d320 1
a320 1
!-----------------------------------------------------------------------
d322 1
a322 1
 Subroutine Drayson(Xin,Yin,Uo,Vo)
d324 1
a324 2
  Real(r8),INTENT(IN)  :: Xin,Yin
  Real(r8),INTENT(OUT) :: Uo,Vo
d326 1
a326 37
  Real(r8), Parameter :: TwoOvSPi = 1.1283791670955125739_r8  ! 2.0/Sqrt(Pi)
!
!***********************************************************************
! Computes the voigt function: y/pi*integral from - to + infinity of   *
! exp(-t*t)/(y*y + (x-t)*(x-t)) dt, for x, y >= 0.  This algorithm was *
! obtained from "Rapid Computation of the Voigt Profile" by S. R.      *
! Drayson in the J. Quant. Spectrosc. Radiat. Transfer, Vol. 16,       *
! pp. 611-614, Pergamon Press 1976.                                    *
!                                                                      *
!               x = sqrt(ln 2) * (v - v0) / aD                         *
!               y = sqrt(ln 2) * aL / aD                               *
!                                                                      *
!  where v is the wave number, v0 is the line center wave number, aL   *
! is the Lorentzian line half-width and aD is the Doppler line         *
! half-width.                                                          *
!                                                                      *
!              voigt(0,0) = 1.                                         *
!              voigt(0,y) = 1 / (sqrt(pi) * y)   for large y           *
!                                                                      *
!***********************************************************************
!
  LOGICAL, SAVE :: FIRST = .True.

  REAL(r4), SAVE :: B(22)
  REAL(r4), SAVE :: RI(15)
  REAL(r4), SAVE :: HN(25), D0(25), D1(25), D2(25), D3(25), D4(25)
!
  REAL(r4), Parameter :: H = 0.201

  REAL(r4), Parameter :: C(21) = &
    & (/ 0.7093602E-7, -0.2518434E-6, 0.8566874E-6, -0.2787638E-5 &
    &  , 0.8660740E-5, -0.2565551E-4, 0.7228775E-4, -0.1933631E-3 &
    &  , 0.4899520E-3, -0.1173267E-2, 0.2648762E-2, -0.5623190E-2 &
    &  , 0.1119601E-1, -0.2084976E-1, 0.3621573E-1, -0.5851412E-1 &
    &  , 0.8770816E-1, -0.121664, 0.15584, -0.184, 0.2 /)

  REAL(r4) :: XL, YL, UU, VV, Y2, DX, CO, F, FD, FR, FI, WI, WR, VOIGT
d328 1
a328 1
  INTEGER :: I, J, MAXJ, N
d330 1
a330 1
  Data B(1), B(2)/0.0, 0.7093602E-7/
d332 1
a332 1
  IF(FIRST) THEN
d334 1
a334 1
    FIRST = .False.
d336 1
a336 1
!******* Initialize Region I. Compute Dawson's function at mesh points
d338 1
a338 16
    DO I = 1, 15
      RI(I) = -Real(I) / 2.0
    END DO
!
    DO I = 1, 25
      HN(I) = H * (I - 0.5)
      CO = 4.0 * HN(I) * HN(I) / 25.0 - 2.0
      DO J = 2, 21
        B(J+1) = CO * B(J) - B(J-1) + C(J)
      END DO
      D0(I) = HN(I) * (B(22) - B(21)) / 5.0
      D1(I) = 1.0 - 2.0 * HN(I) * D0(I)
      D2(I) = (HN(I) * D1(I) + D0(I)) / RI(2)
      D3(I) = (HN(I) * D2(I) + D1(I)) / RI(3)
      D4(I) = (HN(I) * D3(I) + D2(I)) / RI(4)
    END DO
d342 39
a380 2
  XL = Xin
  YL = Yin
d382 93
a474 1
!******** Region I. Compute Dawson's function at x from Taylor series
d476 1
a476 4
  J = XL / H
  N = MIN0(J, 24)
  DX = XL - HN(N+1)
  F = (((D4(N+1)*DX + D3(N+1))*DX + D2(N+1))*DX + D1(N+1))*DX + D0(N+1)
d478 2
a479 1
  FD = 1.0 - 2.0 * XL * F
d481 39
a519 1
!  Taylor series expansion about y = 0.0
d521 1
a521 21
  Y2=  YL*YL
  WI = EXP(Y2 - XL*XL)
  DX = -2.0*XL*YL
  WR = WI*COS(DX)
  WI = WI*SIN(DX)
  FI = F
  UU = -YL
  FR = UU*FD
  J = 5.0 + (12.5-XL)*0.8*YL
  MAXJ = MIN0(J, 14)
  DO J = 2, MAXJ, 2
     F  = (XL*FD + F) / RI(J)
     FD = (XL*F + FD) / RI(J+1)
     UU = UU * YL
     FI = FI + F*UU
     UU = -UU * YL
     FR = FR + FD*UU
  END DO

  VOIGT = WR + TwoOvSpi * FR
  VV    = WI + TwoOvSPi * FI
d523 1
a523 2
  Uo = VOIGT
  Vo = VV
d525 1
a525 3
  RETURN

END Subroutine Drayson
d527 2
a528 1
!---------------------------------------------------------------------
d530 42
a571 1
 Subroutine Hui6(x,y,u,v)
d573 1
a573 40
!***********************************************************************
! Computes the Voigt function: y/pi*integral from - to + infinity of   *
! exp(-t*t)/(y*y + (x-t)*(x-t)) dt, for x, y >= 0.  This algorithm was *
! obtained from "Rapid computation of the Voigt and complex error      *
! function"  by: A.K. Hui, B.H. Aramstrong and A.A. Wray               *
! J. Quant. Spectrosc. Radiat. Transfer, Vol 19, pp. 506-516,          *
! Pergamon Press 1978.                                                 *
!                                                                      *
!               x = sqrt(ln 2) * (v - v0) / aD                         *
!               y = sqrt(ln 2) * aL / aD                               *
!                                                                      *
!  where v is the wave number, v0 is the line center wave number, aL   *
! is the Lorentzian line half-width and aD is the Doppler line         *
! half-width.                                                          *
!                                                                      *
!***********************************************************************
!
  Real(r8), INTENT(IN)  :: x,y
  Real(r8), INTENT(OUT) :: u,v

  Complex(r8) :: z, w, wa, wb
!
  Real(r8), Parameter :: a(7) = (/ &
     &     122.607931777104326_r8, 214.382388694706425_r8, &
     &     181.928533092181549_r8,  93.155580458138441_r8, &
     &      30.180142196210589_r8,   5.912626209773153_r8, &
     &       0.564189583562615_r8 /)
!
  Real(r8), Parameter :: b(7) = (/ &
     &     122.607931773875350_r8, 352.730625110963558_r8, &
     &     457.334478783897737_r8, 348.703917719495792_r8, &
     &     170.354001821091472_r8,  53.992906912940207_r8, &
     &      10.479857114260399_r8 /)
!
  z = Cmplx(y,-x)
  wa = a(1)+z*(a(2)+z*(a(3)+z*(a(4)+z*(a(5)+z*(a(6)+z*a(7))))))
  wb = b(1)+z*(b(2)+z*(b(3)+z*(b(4)+z*(b(5)+z*(b(6)+z*(b(7)+z))))))
  w = wa / wb
  u = Real(w)
  v = AImag(w)
a574 3
  Return
 End Subroutine Hui6

d576 76
a651 2
! Computes the Lorentz function and its first derivative with respect
! to spectaral parameters: w, n & Nu0
d653 1
a653 2
! NOTE: Before calling this routine, the user needs to call slabs_prep_wder()
!       routine to compute x1,yi,y,dx1_dv0,dy_dv0 and dslabs1_dNu0
d655 1
a655 2
 Subroutine Lorentz_spectral(dNu,Nu0,x1,yi,y,w,t,slabs1,dslabs1_dNu0, &
     &      Lorentz,spect_der,dLorentz_dw,dLorentz_dn,dLorentz_dNu0)
d657 2
a658 1
  Real(r8), Parameter :: OvSpi = 0.56418958354776d0 ! 1/Sqrt(Pi)
d660 2
a661 6
  Logical,  INTENT(IN) :: spect_der
  Real(r8), INTENT(IN) :: dNu, Nu0, x1, yi, y, w, t, slabs1, &
                   &      dslabs1_dNu0

  Real(r8), INTENT(OUT) :: Lorentz, dLorentz_dw, dLorentz_dn, &
                    &      dLorentz_dNu0
d663 1
a663 2
  Real(r8) :: xj, zj, q, y2, q2, Sum, up1, up2, dn1, dn2, dup1, dup2, &
   &    ddn1, ddn2, dy_dw, dy_dn, dq_dNu0, dSum_dw, dSum_dn, dSum_dNu0
d665 2
a666 5
  y2 = y * y
  xj = x1 * dNu
  q = 1.0_r8 + dNu/Nu0
  q2 = q * q
  zj = x1 * (2.0_r8 * Nu0 + dNu)
d668 1
a668 5
  up1 = y - yi * zj
  up2 = y - yi * xj
  dn1 = zj * zj + y2
  dn2 = xj * xj + y2
  Sum = up1/dn1 + OvSPi * up2/dn2
d670 31
a700 1
  Lorentz = slabs1 * q2 * Sum
d702 1
a702 1
  if(.not.spect_der) Return
d704 1
a704 5
  dy_dw = y / w
  dup1 = dy_dw
  ddn1 = 2.0 * y * dy_dw
  dup2 = dy_dw
  ddn2 = 2.0 * y * dy_dw
d706 1
a706 2
  dSum_dw = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &  OvSPi * (dn2*dup2-up2*ddn2)/(dn2*dn2)
d708 11
a718 1
  dLorentz_dw = slabs1 * q2 * dSum_dw
d720 1
a720 9
  dy_dn = y * Log(300.0/t)
  dup1 = dy_dn
  ddn1 = 2.0 * y * dy_dn
  dup2 = dy_dn
  ddn2 = 2.0 * y * dy_dn
  dSum_dn = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &  OvSPi * (dn2*dup2-up2*ddn2)/(dn2*dn2)

  dLorentz_dn = slabs1 * q2 * dSum_dn
d722 17
a738 4
  dup2 =  yi * x1               !  x1 = -dxj_dNu0
  ddn2 = -2.0 * xj * x1         !  x1 = -dxj_dNu0
  dSum_dNu0 = OvSPi * (dn2*dup2-up2*ddn2)/(dn2*dn2)
  dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)
d740 1
a740 3
  dLorentz_dNu0 = dslabs1_dNu0 * q2 * Sum          + &
            &     2.0 * slabs1 * q * dq_dNu0 * Sum + &
            &     slabs1 * q2 * dSum_dNu0
d742 1
a742 2
  Return
 End Subroutine Lorentz_spectral
d757 2
a758 2
  Real(r8), INTENT(IN) :: t        ! Temperature K
  Real(r8), INTENT(IN) :: m        ! Molecular mass amu
d760 2
a761 2
  Real(r8), INTENT(IN) :: el       ! Lower state energy cm-1
  Real(r8), INTENT(IN) :: w        ! Collision broadening parameter
d763 4
a766 4
  Real(r8), INTENT(IN) :: ps       ! Pressure shift parameter in MHz/mbar
  Real(r8), INTENT(IN) :: p        ! Pressure mbar
  Real(r8), INTENT(IN) :: n        ! Temperature power dependence of w
  Real(r8), INTENT(IN) :: i        ! Integrated spectral intensity
d768 1
a768 1
  Real(r8), INTENT(IN) :: q(3)     ! Logarithm of the partition function
d770 4
a773 4
  Real(r8), INTENT(IN) :: delta    ! Delta interference coefficient at 300K 1/mb
  Real(r8), INTENT(IN) :: gamma    ! Gamma               "
  Real(r8), INTENT(IN) :: n1       ! Temperature dependency of delta
  Real(r8), INTENT(IN) :: n2       ! Temperature dependency of gamma
d778 2
a779 2
  Real(r8), INTENT(OUT) :: x1      ! Sqrt(Ln(2))/Doppler half width MHz
  Real(r8), INTENT(OUT) :: y       ! Sqrt(Ln(2))*collision width /
d781 3
a783 3
  Real(r8), INTENT(OUT) :: yi      ! Interference contribution
  Real(r8), INTENT(OUT) :: slabs1  ! Frequency independent piece of slabs
  Real(r8), INTENT(OUT) :: dslabs1 ! Derivative of slabs1 w.r.t. v0
d798 7
a804 7
  Real(r8), Parameter :: i2abs = 3.402136078e9_r8
  Real(r8), Parameter :: dc = 3.58117369e-7_r8
  Real(r8), Parameter :: boltzcm = 0.6950387_r8
  Real(r8), Parameter :: boltzmhz = 20836.74_r8
  Real(r8), Parameter :: sqrtln2 = 8.32554611157698e-1_r8
  Real(r8), Parameter :: loge = 4.34294481903251828e-1_r8
  Real(r8), Parameter :: oned300 = 1.0_r8/300.0_r8
d806 2
a807 2
  Real(r8), parameter :: tl1 = 1.76091259055681e-1_r8     ! Log10(225/150)
  Real(r8), parameter :: tl2 = 1.24938736608300e-1_r8     ! Log10(300/225)
d811 1
a811 1
  Real(r8) :: Wd, Q_Log, betae, betav, t3t, onedt, ns, r, e1, e2, de1, &
d816 2
a817 2
  onedt = 1.0_r8 / t
  t3t = 300.0_r8 * onedt
d820 1
a820 1
  if (t < 225.0_r8) then
d822 1
a822 1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_r8)
d825 1
a825 1
    Q_Log = r*Log10(t/300.0_r8)
d828 1
a828 1
  ns = 0.25_r8 + 1.5_r8 * n
d842 3
a844 3
  g = 1.0_r8 - e2
  s = (1.0_r8 - e1) / g
  ds = (-de1*g+(1.0_r8-e1)*de2)/(g*g)
d865 2
a866 2
  Real(r8), INTENT(IN) :: t       ! Temperature K
  Real(r8), INTENT(IN) :: m       ! Molecular mass amu
d868 2
a869 2
  Real(r8), INTENT(IN) :: el      ! Lower state energy cm-1
  Real(r8), INTENT(IN) :: w       ! Collision broadening parameter
d871 4
a874 4
  Real(r8), INTENT(IN) :: ps      ! Pressure shift parameter in MHz/mbar
  Real(r8), INTENT(IN) :: p       ! Pressure mbar
  Real(r8), INTENT(IN) :: n       ! Temperature power dependence of w
  Real(r8), INTENT(IN) :: i       ! Integrated spectral intensity
d876 1
a876 1
  Real(r8), INTENT(IN) :: q(3)    ! Logarithm of the partition function
d878 4
a881 4
  Real(r8), INTENT(IN) :: delta   ! Delta interference coefficient at 300K 1/mb
  Real(r8), INTENT(IN) :: gamma   ! Gamma               "
  Real(r8), INTENT(IN) :: n1      ! Temperature dependency of delta
  Real(r8), INTENT(IN) :: n2      ! Temperature dependency of gamma
d886 2
a887 2
  Real(r8), INTENT(OUT) :: x1        ! Sqrt(Ln(2))/Doppler half width MHz
  Real(r8), INTENT(OUT) :: y         ! Sqrt(Ln(2))*collision width /
d889 2
a890 2
  Real(r8), INTENT(OUT) :: yi        ! Interference contribution
  Real(r8), INTENT(OUT) :: slabs1    ! Frequency independent piece of slabs
d892 3
a894 3
  Real(r8), INTENT(OUT) :: dx1_dv0       ! Derivative of x1 w.r.t. v0
  Real(r8), INTENT(OUT) :: dy_dv0        ! Derivative of y w.r.t. v0
  Real(r8), INTENT(OUT) :: dslabs1_dv0   ! Derivative of slabs1 w.r.t. v0
d970 5
a974 5
 Subroutine Slabs_Prep_Arrays(Spectag,nl,t,p,mass,Catalog,Qlog,v0s, &
        &   x1,y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,x1p,yp,  &
        &   yip,slabs1p,v0sm,x1m,ym,yim,slabs1m)

 Integer(i4), intent(in) :: Spectag, nl
d976 1
a976 1
 Real(r8), intent(in) :: t, p, mass, Qlog(:)
d978 1
a978 1
 Type(Catalog_T), intent(in) :: Catalog
d980 2
a981 5
 Real(r8), intent(out) :: v0s(:), x1(:), y(:), yi(:), slabs1(:), &
                          dx1_dv0(:), dy_dv0(:), dslabs1_dv0(:)

 Real(r8), intent(out) :: v0sp(:), x1p(:), yp(:), yip(:), slabs1p(:), &
                      &   v0sm(:), x1m(:), ym(:), yim(:), slabs1m(:)
d983 1
a983 2
  Integer(i4) :: j, k
  Real(r8) :: dslabs1, tp, tm
d994 1
a994 1
    Call Slabs_prep_wder(t,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,   &
d997 3
a999 1
      &  yi(j),slabs1(j),dx1_dv0(j),dy_dv0(j),dslabs1_dv0(j))
d1001 1
a1001 5
    tp = t + 10.0
    Call Slabs_prep(tp,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,   &
      &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
      &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sp(j),x1p(j),yp(j), &
      &  yip(j),slabs1p(j),dslabs1)
d1003 3
a1005 5
    tm = t - 10.0
    Call Slabs_prep(tm,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,   &
      &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
      &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sm(j),x1m(j),ym(j), &
      &  yim(j),slabs1m(j),dslabs1)
d1007 1
a1007 1
  end do
d1009 1
a1009 23
  End Subroutine Slabs_Prep_Arrays

!-----------------------------------------------------------------
 SUBROUTINE get_gl_slabs_arrays(Catalog,z_path,t_path,vel_z,gl_slabs, &
                             &  ptg_i,no_ele,max_nl,ier)

!  ===============================================================
!  Declaration of variables for sub-program: get_gl_slabs_arrays
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: ptg_i, no_ele, max_nl

Type(path_vector) :: z_path,t_path

Type(Catalog_T), dimension(:), intent(in) :: Catalog

Real(r8), INTENT(IN) :: vel_z

Integer(i4), INTENT(OUT) :: ier

Type (slabs_struct), POINTER :: gl_slabs(:,:)
d1011 9
d1023 7
a1029 17

Real(r8), PARAMETER :: c = 299792.4583d0     ! Speed of Light Km./Sec.

Integer(i4) :: nl,i,j,no_sps,spectag

Real(r8) :: Qlog(3), mass, z, p, t, Vel_z_correction

Real(r8) :: v0s(max_nl), x1(max_nl), y(max_nl), yi(max_nl), &
            slabs1(max_nl), dx1_dv0(max_nl), dy_dv0(max_nl),  &
            dslabs1_dv0(max_nl)

Real(r8) :: v0sp(max_nl), x1p(max_nl), yp(max_nl), yip(max_nl), &
            slabs1p(max_nl)

Real(r8) :: v0sm(max_nl), x1m(max_nl), ym(max_nl), yim(max_nl), &
            slabs1m(max_nl)

a1030 3

  ier = 0
  no_sps = Size(Catalog)
d1032 1
a1032 3
  Vel_z_correction = 1.0_r8 - vel_z / c

  IF(ptg_i == 1) then
d1034 1
a1034 27
    ALLOCATE(gl_slabs(no_ele,no_sps), STAT=ier)
    IF(ier /= 0) THEN
      Print *,'** ALLOCATE Error: gl_slabs, STAT =',ier
      Return
    ENDIF
!
    nl = max_nl
    DO i = 1, no_sps
      DO j = 1, no_ele
        ALLOCATE(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%v0sm(nl),           &
            &    gl_slabs(j,i)%v0sp(nl),gl_slabs(j,i)%x1(nl),            &
            &    gl_slabs(j,i)%y(nl),gl_slabs(j,i)%yi(nl),               &
            &    gl_slabs(j,i)%slabs1(nl),gl_slabs(j,i)%dx1_dv0(nl),     &
            &    gl_slabs(j,i)%dy_dv0(nl),gl_slabs(j,i)%dslabs1_dv0(nl), &
            &    gl_slabs(j,i)%v0sm(nl),gl_slabs(j,i)%x1m(nl),           &
            &    gl_slabs(j,i)%ym(nl),gl_slabs(j,i)%yim(nl),             &
            &    gl_slabs(j,i)%slabs1m(nl),gl_slabs(j,i)%v0sp(nl),       &
            &    gl_slabs(j,i)%x1p(nl),gl_slabs(j,i)%yp(nl),             &
            &    gl_slabs(j,i)%yip(nl),gl_slabs(j,i)%slabs1p(nl),        &
            &    STAT = ier)
        IF(ier /= 0) THEN
          Print *,'** ALLOCATE Error: gl_slabs%component(nl), STAT =',ier
          Print *,'   gl_counter =',j,' specie_counter =',i,' nl =',nl
          Return
        ENDIF
      END DO
    END DO
d1036 1
a1036 1
  ENDIF
d1038 2
a1039 1
  DO i = 1, no_sps
d1041 2
a1042 2
    Spectag = Catalog(i)%spec_tag
    mass = Real(Spectag) / 1000.0
d1044 1
a1044 2
    Qlog(1:3) = Catalog(i)%QLOG(1:3)
    nl = Size(Catalog(i)%Lines)
d1046 1
a1046 1
    gl_slabs(1:no_ele,i)%no_lines = nl
d1048 3
a1050 1
    do j = 1, no_ele
d1052 1
a1052 7
      z = z_path%values(j)
      t = t_path%values(j)
      p = 10.0d0**(-z)
!
      Call Slabs_Prep_Arrays(Spectag,nl,t,p,mass,Catalog(i),Qlog,v0s, &
       &   x1,y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,x1p,yp,yip, &
       &   slabs1p,v0sm,x1m,ym,yim,slabs1m)
d1054 1
a1054 1
!  Apply velocity corrections:
d1056 1
a1056 24
      v0s(1:nl)  = v0s(1:nl)  * Vel_z_correction
      v0sp(1:nl) = v0sp(1:nl) * Vel_z_correction
      v0sm(1:nl) = v0sm(1:nl) * Vel_z_correction
!
      gl_slabs(j,i)%y(1:nl)           = y(1:nl)
      gl_slabs(j,i)%x1(1:nl)          = x1(1:nl)
      gl_slabs(j,i)%yi(1:nl)          = yi(1:nl)
      gl_slabs(j,i)%v0s(1:nl)         = v0s(1:nl)
      gl_slabs(j,i)%dy_dv0(1:nl)      = dy_dv0(1:nl)
      gl_slabs(j,i)%slabs1(1:nl)      = slabs1(1:nl)
      gl_slabs(j,i)%dx1_dv0(1:nl)     = dx1_dv0(1:nl)
      gl_slabs(j,i)%dslabs1_dv0(1:nl) = dslabs1_dv0(1:nl)
!
      gl_slabs(j,i)%ym(1:nl)      = ym(1:nl)
      gl_slabs(j,i)%x1m(1:nl)     = x1m(1:nl)
      gl_slabs(j,i)%yim(1:nl)     = yim(1:nl)
      gl_slabs(j,i)%v0sm(1:nl)    = v0sm(1:nl)
      gl_slabs(j,i)%slabs1m(1:nl) = slabs1m(1:nl)
!
      gl_slabs(j,i)%yp(1:nl)      = yp(1:nl)
      gl_slabs(j,i)%x1p(1:nl)     = x1p(1:nl)
      gl_slabs(j,i)%yip(1:nl)     = yip(1:nl)
      gl_slabs(j,i)%v0sp(1:nl)    = v0sp(1:nl)
      gl_slabs(j,i)%slabs1p(1:nl) = slabs1p(1:nl)
d1058 1
a1058 1
    end do
d1060 1
a1060 3
  END DO              ! On i

  Return
d1064 2
d1068 2
a1069 2
! Revision 1.3  2001/06/07 23:39:32  pwagner
! Added Copyright statement
d1071 2
a1072 2
! Revision 1.2  2001/05/15 03:47:26  zvi
! Adding derivative flag to beta calculations
d1074 2
a1075 2
! Revision 1.1  2001/02/03 02:07:01  zvi
! Changes and additions
@


1.4.2.1
log
@Modified Z_slab regions
@
text
@d13 1
a13 1
  "$Id: slabs_sw_m.f90,v 1.4 2001/06/21 13:07:09 zvi Exp $"
a154 5
!
  Real(r8), Parameter :: xl = 5.2_r8
  Real(r8), Parameter :: yl = 0.05_r8
  Real(r8), Parameter :: yh = 0.6_r8
  Real(r8), Parameter :: dydx = (yh-yl)/xl
d156 1
a156 1
  Real(r8) :: xa, r
d159 1
a159 4
  r = yl+dydx*xa
  IF(xa <= xl  .AND.  y <= r) THEN          ! Region 1, Dowson+Taylor
    Call Drayson(xa,y,u,v)
  ELSE IF(xa > xl  .and.  y <= 0.3d0) THEN  ! Region 4, Gauss-Hermite 6 points
d161 12
a172 3
  ELSE                                      ! Region 2, Hui (p=6)
    Call Hui6(xa,y,u,v)
  ENDIF
d318 1
a318 12
!
  IF(XL.le.0.25*abs(DX)) THEN
    F = 0.0
  ELSE
    F = (((D4(N+1)*DX + D3(N+1))*DX + D2(N+1))*DX + D1(N+1))*DX + D0(N+1)
  ENDIF
!
  IF(YL.le.1.0d-12) THEN
    Vo = TwoOvSPi * F
    Uo = Exp(-Xin*Xin)
    RETURN
  ENDIF
a884 3
! Revision 1.4  2001/06/21 13:07:09  zvi
! Speed enhancement MAJOR update
!
@


1.4.2.2
log
@Cleanup..comp_path_entities_m.f90
@
text
@d1 3
d5 6
a10 9

  use MLSCommon, only: R8, RP, IP

  use SpectroscopyCatalog_m, only: CATALOG_T, Lines

  Implicit NONE

  REAL(rp), PARAMETER :: OneOvSPi = 0.56418958354775628695_rp  ! 1.0/Sqrt(Pi)
!
d13 1
a13 1
  "$Id: slabs_sw_m.f90,v 1.1 2001/01/31 21:56:13 zvi Exp $"
d17 1
a17 1
CONTAINS
d23 1
a23 1
!       routine to compute dslabs1_dNu0
d25 2
a26 2
 Subroutine dvoigt_spectral(dNu,Nu0,x1,yi,y,w,t,slabs1,SwI, &
                         &  dslabs1_dNu0,dSwI_dw,dSwI_dn,dSwI_dNu0)
d28 6
a33 2
  REAL(rp), INTENT(IN) :: dnu, nu0, x1, yi, y, w, t, slabs1
  Real(rp), INTENT(IN), OPTIONAL :: dslabs1_dNu0
d35 1
a35 1
  Real(rp), INTENT(OUT) :: SwI, dSwI_dw,dSwI_dn,dSwI_dNu0
d37 1
a37 1
  REAL(rp) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r
d39 1
a39 1
  Real(rp) :: dq_dv0, dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, &
d43 7
a49 1
  Call simple_voigt(x,y,u,v)
d53 1
a53 1
  q = 1.0_rp + dNu / Nu0
d59 1
a59 1
  r = z * OneOvSPi + yi * v
d63 1
a63 5
  du_dx = 2.0_rp * (y * v - x * u)
  du_dy = 2.0_rp * (y * u + x * v - OneOvSPi)
!
  dv_dx = -du_dy         ! Cauchy-Riemann equation
  dv_dy =  du_dx         ! Cauchy-Riemann equation
d67 3
a69 2
  dSwI_dw = q2 * slabs1* (y/w) * (du_dy + yi*du_dx + &
                              &   OneOvSPi*((1.0_rp-2.0_rp*z*y)/g))
d73 1
a73 1
  dSwI_dn = q2 * slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d80 8
a87 8
  dx_dv0 = -x1
  du_dv0 = du_dx * dx_dv0
  dv_dv0 = dv_dx * dx_dv0
  db_dv0 = x1
  dg_dv0 = 2.0_rp * b*db_dv0
  dz_dv0 = (-yi*db_dv0-z*dg_dv0)/g
  dr_dv0 = dz_dv0*OneOvSPi+yi*dv_dv0
  dvvw_dv0 = (du_dv0+dr_dv0)*q2 + 2.0_rp*q*dq_dv0*(u+r)
d95 1
a95 23
 Real(rp) Function Slabs(dNu,v0s,x1,slabs1,y)
!
  REAL(rp), INTENT(IN) :: dNu, v0s, x1, slabs1, y
!
!  Note: dNu = v - v0s
!
! If the molecular transition and temperature have not changed but
! frequency has enter here.
!
! inputs: dNu , x1 , slabs1 , y, v0s, yi
! output: slabs
!
  REAL(rp) :: u
!
  Call real_simple_voigt(x1*dNu,y,u)
!
!  Van Vleck - Wieskopf line shape with Voigt, Added Mar/2/91, Bill
!  Modified code to include interference: June/3/1992 (Bill + Zvi)
!  Modified code to correct a sign error (introduced in last change)
!  (Bill + Zvi, July/7/92)
!
  Slabs = slabs1 * (1.0_rp + dNu / v0s)**2 &
            * (u + OneOvSPi*y/((x1*(2.0_rp*v0s+dNu))**2 + y*y))
d97 1
a97 2
  Return
 End Function Slabs
d99 1
a99 5
!---------------------------------------------------------------------
!
 Real(rp) Function Slabswint(dNu,v0s,x1,slabs1,y,yi)
!
  REAL(rp), INTENT(IN) :: dNu, v0s, x1, slabs1, y, yi
d109 1
a109 1
  Real(rp) :: x, u, q, p, z, y2, w
d112 1
a112 1
  Call real_simple_voigt(x,y,u)
d119 5
a123 5
  q = (1.0_rp + dNu / v0s)**2
  p = x1 * (2.0_rp * v0s + dNu)
  y2 = y*y
  z = OneOvSPi*((y - p*yi)/(p*p + y2) + yi*x/(x*x+y2))
  w = (u + z) * q
d129 1
a129 3
!---------------------------------------------------------------------------
! Computes the Voigt/Lorentz function and its first derivative with respect
! to spectaral parameters: w, n & Nu0
d131 1
a131 2
! NOTE: Before calling this routine, the user needs to call slabs_prep()
!       routine to compute dslabs1_dNu0
d133 39
a171 2
 Subroutine Voigt_Lorentz(dNu, Nu0, x1, yi, y, w, t, slabs1, VL,  &
                      &   dslabs1_dNu0, dVL_dw, dVL_dn, dVL_dNu0)
d173 1
a173 3
  Real(rp), INTENT(IN) :: dNu, Nu0, x1, yi, y, w, t, slabs1, dslabs1_dNu0

  Real(rp), INTENT(OUT) :: VL, dVL_dw, dVL_dn, dVL_dNu0
d175 2
a176 3
  Real(rp) :: xj, zj, q, y2, q2, u, v, Sum, up1, up2, dn1, dn2, dup1, &
   &          dup2, ddn1, ddn2, dy_dw, dy_dn, dq_dNu0, dSum_dw, dSum_dn, &
   &          dSum_dNu0
d178 1
a178 2
  q = 1.0_rp + dNu / Nu0
  q2 = q * q
d180 1
a180 5
  y2 = y * y
  xj = x1 * dNu
  zj = x1 * (2.0_r8 * Nu0 + dNu)
  dn1 = zj * zj + y2
  up1 = y - zj * yi
d182 32
a213 1
! Van Vleck - Wieskopf (VVW) line shape with Voigt
d215 3
a217 5
  Call simple_voigt(xj,y,u,v)
  dup1 = up1 * OneOvSPi / dn1 + yi * v
  ddn2 = u + dup1
  Sum = ddn2 / OneOvSPi
  VL = slabs1 * ddn2 * q2            ! This is the Voigt + VVW correction
d219 9
a227 2
  dn2 = xj * xj + y2
  up2 = y - yi * xj
d229 2
a230 29
  dy_dw = y / w
  dup1 = dy_dw
  ddn1 = 2.0 * y * dy_dw
  dup2 = dy_dw
  ddn2 = 2.0 * y * dy_dw
!
  dSum_dw = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &          (dn2*dup2-up2*ddn2)/(dn2*dn2)
!
  dVL_dw = OneOvSPi * slabs1 * q2 * dSum_dw
!
  dy_dn = y * Log(300.0/t)
  dup1 = dy_dn
  ddn1 = 2.0 * y * dy_dn
  dup2 = dy_dn
  ddn2 = 2.0 * y * dy_dn
  dSum_dn = (dn1*dup1-up1*ddn1)/(dn1*dn1) + &
 &          (dn2*dup2-up2*ddn2)/(dn2*dn2)

  dVL_dn = OneOvSPi * slabs1 * q2 * dSum_dn
!
  dup2 =  yi * x1               !  x1 = -dxj_dNu0
  ddn2 = -2.0 * xj * x1         !  x1 = -dxj_dNu0
  dSum_dNu0 = (dn2*dup2-up2*ddn2)/(dn2*dn2)
  dq_dNu0 = -(dNu+Nu0)/(Nu0*Nu0)
!
  dVL_dNu0 = OneOvSPi * (dslabs1_dNu0 * q2 * Sum          + &
            &         2.0 * slabs1 * q * dq_dNu0 * Sum + &
            &         slabs1 * q2 * dSum_dNu0)
d233 1
a233 1
 End Subroutine Voigt_Lorentz
d235 1
a235 2
!---------------------------------------------------------------------------
! simple REAL(Voigt) function
d237 1
a237 1
  ELEMENTAL SUBROUTINE real_simple_voigt(x,y,u)
d239 2
a240 1
! inputs
d242 37
a278 2
  REAL(rp), INTENT(in) :: x ! doppler width, del frequency ratio
  REAL(rp), INTENT(in) :: y ! doppler width, collision width ratio
d280 1
a280 1
! outputs
d282 1
a282 1
  REAL(rp), INTENT(out) :: u ! real part of Voigt
d284 1
a284 1
! internals
d286 1
a286 2
  REAL(rp), PARAMETER :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
  REAL(rp) :: xa
d288 1
a288 1
! This is sorted in likely occurance of each case
d290 16
a305 1
  xa = ABS(x)
d307 1
a307 2
! I am assuming that the OR are evaluated sequentially until the first
! true is found. Also routines are ordered according to speed
d309 2
a310 1
  IF(y + 0.666666*xa > 100.0_rp) THEN
d312 1
a312 5
    u = rlorentz(xa,y)
!
  ELSE IF(y + 0.6875_rp * xa > 11.0_rp) THEN
!
! Drayson's quick 2pt hermite integral (essentially a lorentz)
d314 3
a316 13
    u = rvoigth2(xa,y)
!
  ELSE IF(y > 0.6_rp .OR. y > yl + dydx*xa) THEN
!
! Intermediate region
!
    u = rhui6(xa,y)
!
  ELSE IF(xa > 5.2_rp) THEN
!
! small y large x limit
!
    u = rvoigth6(xa,y)
d318 2
d321 1
a321 5
!
! Near line center where Doppler dominates Pressure broadening
!
    u = rdrayson(xa,y)
!
d324 4
a327 58
  END SUBROUTINE real_simple_voigt
!
!---------------------------------------------------------------------------
! simple Voigt function
!
  ELEMENTAL SUBROUTINE simple_voigt(x,y,u,v)
!
! inputs
!
  REAL(rp), INTENT(in) :: x ! doppler width, del frequency ratio
  REAL(rp), INTENT(in) :: y ! doppler width, collision width ratio
!
! outputs
!
  REAL(rp), INTENT(out) :: u ! real part of Voigt
  REAL(rp), OPTIONAL, INTENT(out) :: v ! imaginary part of Voigt
!
! internals
!
  REAL(rp), PARAMETER :: xl=5.2_rp, yl=0.05_rp, yh=0.6_rp, dydx=(yh-yl)/xl
  REAL(rp) :: xa
  COMPLEX(rp) :: uv
!
! This is sorted in likely occurance of each case
!
  xa = ABS(x)
!
! I am assuming that the OR are evaluated sequentially until the first
! true is found. Also routines are ordered according to speed
!
  IF(y + 0.666666*xa > 100.0_rp) THEN
!
    uv = clorentz(xa,y)
!
  ELSE IF(y + 0.6875_rp * xa > 11.0_rp) THEN
!
! Drayson's quick 2pt hermite integral (essentially a lorentz)
!
    uv = cvoigth2(xa,y)
!
  ELSE IF(y > 0.6_rp .OR. y > yl + dydx*xa) THEN
!
! Intermediate region
!
    uv = chui6(xa,y)
!
  ELSE IF(xa > 5.2_rp) THEN
!
! small y large x limit
!
    uv = cvoigth6(xa,y)
!
  ELSE
!
! Near line center where Doppler dominates Pressure broadening
!
    uv = cdrayson(xa,y)
!
d330 1
a330 2
  u = REAL(uv,KIND=rp)
  v = SIGN(AIMAG(uv),x)
d332 1
a332 1
  END SUBROUTINE simple_voigt
d334 21
a354 2
!---------------------------------------------------------------------------
! Real Lorentz
d356 2
a357 3
  REAL(rp) ELEMENTAL FUNCTION rlorentz(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
d359 3
a361 1
! Internals
d363 1
a363 1
  rlorentz = OneOvSPi * y / (y*y + x*x)
d365 1
a365 1
  END FUNCTION rlorentz
d367 40
a406 14
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION clorentz(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  REAL(rp) :: denom
!
  denom = OneOvSPi / (x*x + y*y)
  clorentz = CMPLX(y*denom,x*denom,KIND=rp)
!
  END FUNCTION clorentz
d408 3
d412 2
a413 1
! Real Voigt region IV 2pt GL integration
d415 2
a416 3
  REAL(rp) ELEMENTAL FUNCTION rvoigth2(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
d418 2
a419 1
! Internals
d421 1
a421 3
  REAL(rp), PARAMETER :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
  REAL(rp), PARAMETER :: gw = 0.28209479177388_rp
  REAL(rp) :: y2
d423 6
a428 3
  y2 = y*y
  rvoigth2 = gw * y * (1.0_rp/(y2 + (x-gx)**2) + &
           &           1.0_rp/(y2 + (x+gx)**2))
d430 2
a431 1
  END FUNCTION rvoigth2
d433 5
a437 2
!---------------------------------------------------------------------------
! Voigt region  2pt GL integration
d439 5
a443 1
  COMPLEX(rp) ELEMENTAL FUNCTION cvoigth2(x,y)
d445 1
a445 2
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
d447 1
a447 1
! Internals
d449 5
a453 3
  REAL(rp), PARAMETER :: gx = 0.70710678118655_rp ! 1.0/sqrt(2.0)
  REAL(rp), PARAMETER :: gw = 0.28209479177388_rp
  REAL(rp) :: denom1,denom2,xm,xp,y2
d455 2
a456 6
  xm = x-gx
  xp = x+gx
  y2 = y**2
  denom1 = gw/(y2 + xm**2)
  denom2 = gw/(y2 + xp**2)
  cvoigth2 = CMPLX(y*(denom1+denom2),xm*denom1 + xp*denom2,KIND=rp)
d458 1
a458 1
  END FUNCTION cvoigth2
d460 9
a468 2
!---------------------------------------------------------------------------
! Real Voigt region IV 6pt GL integration
d470 4
a473 23
  REAL(rp) ELEMENTAL FUNCTION rvoigth6(x,y)
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  INTEGER, PARAMETER :: n = 3
  REAL(rp), PARAMETER :: Pi = 3.1415926535897932385_rp
  REAL(rp), PARAMETER :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                    1.33584907401369694957_rp,    &
                                    2.35060497367449222280_rp /)
  REAL(rp), PARAMETER :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                    1.57067320322856644036e-1_rp, &
                                    4.53000990550884564224e-3_rp /) / Pi
  REAL(rp) :: y2
  INTEGER :: i
!
  rvoigth6 = 0.0
  y2 = y**2
  DO i = 1 , n
    rvoigth6 = rvoigth6 + gw(i) * y * (1.0_rp/(y2 + (x-gx(i))**2) + &
                                   &   1.0_rp/(y2 + (x+gx(i))**2))
  ENDDO
d475 3
a477 1
  END FUNCTION rvoigth6
d479 2
a480 297
!---------------------------------------------------------------------------
! Voigt region IV 6pt GL integration
!
  COMPLEX(rp) ELEMENTAL FUNCTION cvoigth6(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internals
!
  INTEGER, PARAMETER :: n = 3
  REAL(rp), PARAMETER :: Pi = 3.1415926535897932385_rp
  REAL(rp), PARAMETER :: gx(n) = (/ 4.36077411927616508271e-1_rp, &
                                    1.33584907401369694957_rp,    &
                                    2.35060497367449222280_rp /)
  REAL(rp), PARAMETER :: gw(n) = (/ 7.24629595224392524608e-1_rp, &
                                    1.57067320322856644036e-1_rp, &
                                    4.53000990550884564224e-3_rp /) / Pi
  INTEGER :: i
  REAL(rp) :: denom1,denom2,xp,xm
!
  cvoigth6 = CMPLX(0.0_rp,0.0_rp)
  DO i = 1 , n
    xm = x-gx(i)
    xp = x+gx(i)
    denom1 = gw(i)/(y**2 + xm**2)
    denom2 = gw(i)/(y**2 + xp**2)
    cvoigth6 = cvoigth6+CMPLX(y*(denom1+denom2),xm*denom1+xp*denom2,KIND=rp)
  ENDDO
!
  END FUNCTION cvoigth6
!
!---------------------------------------------------------------------------
  REAL(rp) ELEMENTAL FUNCTION rhui6(x,y)
!
! Voigt region II Hui polynomial
! This too looks complicated to split into reals and imaginaries so I
! will do the complex arithmetic here
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internal stuff
!
  REAL(rp), PARAMETER :: a(7) = (/ &
     &     122.607931777104326_rp, 214.382388694706425_rp, &
     &     181.928533092181549_rp,  93.155580458138441_rp, &
     &      30.180142196210589_rp,   5.912626209773153_rp, &
     &       0.564189583562615_rp /)
!
  REAL(rp), PARAMETER :: b(7) = (/ &
     &     122.607931773875350_rp, 352.730625110963558_rp, &
     &     457.334478783897737_rp, 348.703917719495792_rp, &
     &     170.354001821091472_rp,  53.992906912940207_rp, &
     &      10.479857114260399_rp /)
!
  INTEGER :: i
  REAL :: rs,rt,is,it,r(5),q(5)
!
! note that this dimension is 2 less than the a and b coefficients
! because we start the r and q coeffients at 2. r(0)=1.0,r(1) = y
! q(0) = 0.0, q(1) = -x
! fill the r, q coefficients with this recursion
!
  r(1) = y**2 - x**2
  q(1) = -2.0_rp*x*y
  DO i = 2 , 5
    r(i) = x * q(i-1) + y * r(i-1)
    q(i) = y * q(i-1) - x * r(i-1)
  ENDDO
  rs = a(1) + a(2)*y + SUM(a(3:)*r)
  rt = b(1) + b(2)*y + SUM(b(3:)*r) + x * q(5) + y * r(5)
  is =      - a(2)*x + SUM(a(3:)*q)
  it =      - b(2)*x + SUM(b(3:)*q) + y * q(5) - x * r(5)
!
  rhui6 = (rs*rt + is*it) / (rt*rt + it*it)
!
! FYI ihui6 = (is*rt - rs*it) / (rt*rt + it*it)
!
  END FUNCTION rhui6
!
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION chui6(x,y)
!
! Voigt region II Hui polynomial
! This too looks complicated to split into reals and imaginaries so I
! will do the complex arithmetic here
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internal stuff
!
  REAL(rp), PARAMETER :: a(7) = (/ &
     &     122.607931777104326_rp, 214.382388694706425_rp, &
     &     181.928533092181549_rp,  93.155580458138441_rp, &
     &      30.180142196210589_rp,   5.912626209773153_rp, &
     &       0.564189583562615_rp /)
!
  REAL(rp), PARAMETER :: b(7) = (/ &
     &     122.607931773875350_rp, 352.730625110963558_rp, &
     &     457.334478783897737_rp, 348.703917719495792_rp, &
     &     170.354001821091472_rp,  53.992906912940207_rp, &
     &      10.479857114260399_rp /)
!
  INTEGER :: i
  REAL :: rs,rt,is,it,r(5),q(5),denom
!
! note that this dimension is 2 less than the a and b coefficients
! because we start the r and q coeffients at 2. r(0)=1.0,r(1) = y
! q(0) = 0.0, q(1) = -x
! fill the r, q coefficients with this recursion
!
  r(1) = y**2 - x**2
  q(1) = -2.0_rp*x*y
  DO i = 2, 5
    r(i) = x * q(i-1) + y * r(i-1)
    q(i) = y * q(i-1) - x * r(i-1)
  ENDDO
!
  rs = a(1) + a(2)*y + SUM(a(3:)*r)
  rt = b(1) + b(2)*y + SUM(b(3:)*r) + x * q(5) + y * r(5)
  is =      - a(2)*x + SUM(a(3:)*q)
  it =      - b(2)*x + SUM(b(3:)*q) + y * q(5) - x * r(5)
  denom = 1.0_rp / (rt*rt + it*it)
  chui6 = CMPLX((rs*rt+is*it)*denom, (is*rt-rs*it)*denom,KIND=rp)
!
  END FUNCTION chui6
!
!---------------------------------------------------------------------------
  REAL(rp) ELEMENTAL FUNCTION rdrayson(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internal stuff
!
  INTEGER :: I, J, MAXJ, N
  REAL(rp), PARAMETER :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
!
! This is a way to set the mesh points without having to use a SAVE statement
!
  REAL(rp), Parameter :: H = 0.2_rp
  REAL(rp), PARAMETER :: HN(26) = (/(H*(I-1),I=1,26)/)
  REAL(rp), PARAMETER :: RI(15) = (/(-I/2.0_rp,I=1,15)/)
!
  REAL(rp), Parameter :: Dawson(26) = (/  &
     &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
     &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
     &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
     &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
     &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
     &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
     &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
     &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
     &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
     &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
     &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
     &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
     &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)
!
  REAL(rp), PARAMETER :: FDer1(26) = &
           & (/(1.0_rp-2.0_rp*HN(I)*Dawson(I),I=1,26)/)
  REAL(rp), PARAMETER :: FDer2(26) = &
           & (/((HN(I)*FDer1(I)+Dawson(I))/RI(2),I=1,26)/)
  REAL(rp), PARAMETER :: FDer3(26) = &
           & (/((HN(I)*FDer2(I)+FDer1(I))/RI(3),I=1,26)/)
  REAL(rp), PARAMETER :: FDer4(26) = &
           & (/((HN(I)*FDer3(I)+FDer2(I))/RI(4),I=1,26)/)
  REAL(rp), PARAMETER :: FDer5(26) = &
           & (/((HN(I)*FDer4(I)+FDer3(I))/RI(5),I=1,26)/)
  REAL(rp), PARAMETER :: FDer6(26) = &
           & (/((HN(I)*FDer5(I)+FDer4(I))/RI(6),I=1,26)/)
!
! internal stuff
!
  REAL(rp) :: Y2, DX, F, FD, W, dely
  Y2 = y*y
!
!******** Region I. Compute Dawson's function at x from Taylor series
!
  J = X / H
  N = 1 + MIN(J, 25)
  DX = X - HN(N)
  F = 0.0_rp
  IF(X > 0.05*H) &
     F = (((((FDer6(N)*DX + FDer5(N))*DX + FDer4(N))*DX  + &
           &  FDer3(N))*DX + FDer2(N))*DX + FDer1(N))*DX + Dawson(N)
  IF(Y <= 1.0e-12_rp) THEN
    rdrayson = EXP(-X*X)
    RETURN
  ENDIF
!
!  Taylor series expansion about y = 0.0
!
  dely = -Y
  FD = 1.0_rp - 2.0_rp * X * F
  w = FD * dely
  J = 5.0_rp + (12.5_rp - X) * 0.8_rp * Y
  MAXJ = MIN(J, 14)
  DO J = 2, MAXJ,2
    F  = (X*FD + F) / RI(J)
    FD  = (X*F + FD) / RI(J+1)
    dely = -y2 * dely
    w = w + FD * dely
  END DO
!
  rdrayson = EXP(y2-x*x)*COS(2.0_rp*x*y) + TwoOvSpi*w
!
  END FUNCTION rdrayson
!
!---------------------------------------------------------------------------
  COMPLEX(rp) ELEMENTAL FUNCTION cdrayson(x,y)
!
  REAL(rp), INTENT(in) :: x ! sqrt(ln2)*delnu) / wd
  REAL(rp), INTENT(in) :: y ! sqrt(ln2)*wc / wd
!
! Internal stuff
!
  INTEGER :: I, J, MAXJ, N
  REAL(rp), PARAMETER :: TwoOvSPi = 1.1283791670955125739_rp  ! 2.0/Sqrt(Pi)
!
! This is a way to set the mesh points without having to use a SAVE statement
!
  REAL(rp), Parameter :: H = 0.2_rp
  REAL(rp), PARAMETER :: HN(26) = (/(H*(I-1),I=1,26)/)
  REAL(rp), PARAMETER :: RI(15) = (/(-I/2.0_rp,I=1,15)/)
!
  REAL(rp), Parameter :: Dawson(26) = (/  &
     &   0.000000000000000000000_rp, 0.194751033368028049654_rp, &
     &   0.359943481934888104273_rp, 0.474763203662977930602_rp, &
     &   0.532101707056365429017_rp, 0.538079506912768419134_rp, &
     &   0.507273496407739614173_rp, 0.456507237526897257242_rp, &
     &   0.399939894323081412623_rp, 0.346772769114872245155_rp, &
     &   0.301340388923791966033_rp, 0.264510759950831957658_rp, &
     &   0.235313055663842576224_rp, 0.212165124242499004111_rp, &
     &   0.193550723859366792343_rp, 0.178271030610558287342_rp, &
     &   0.165461999878675203167_rp, 0.154524057736963452532_rp, &
     &   0.145041773054088859351_rp, 0.136721221674636496320_rp, &
     &   0.129348001236005115591_rp, 0.122760816006522922545_rp, &
     &   0.116835039953297254075_rp, 0.111472268532125307267_rp, &
     &   0.106593431283281074400_rp, 0.102134074424276835438_rp /)
!
  REAL(rp), PARAMETER :: FDer1(26) = &
           & (/(1.0_rp-2.0_rp*HN(I)*Dawson(I),I=1,26)/)
  REAL(rp), PARAMETER :: FDer2(26) = &
           & (/((HN(I)*FDer1(I)+Dawson(I))/RI(2),I=1,26)/)
  REAL(rp), PARAMETER :: FDer3(26) = &
           & (/((HN(I)*FDer2(I)+FDer1(I))/RI(3),I=1,26)/)
  REAL(rp), PARAMETER :: FDer4(26) = &
           & (/((HN(I)*FDer3(I)+FDer2(I))/RI(4),I=1,26)/)
  REAL(rp), PARAMETER :: FDer5(26) = &
           & (/((HN(I)*FDer4(I)+FDer3(I))/RI(5),I=1,26)/)
  REAL(rp), PARAMETER :: FDer6(26) = &
           & (/((HN(I)*FDer5(I)+FDer4(I))/RI(6),I=1,26)/)
!
! internal stuff
!
  REAL(rp) :: DX, F, FD,wr,wi,dely,twoxy
!
!******** Region I. Compute Dawson's function at x from Taylor series
!
  J = X / H
  N = 1 + MIN(J, 25)
  DX = X - HN(N)
  F = 0.0_rp
  IF(X.gt.0.05*H) &
     F = (((((FDer6(N)*DX + FDer5(N))*DX + FDer4(N))*DX  + &
           &  FDer3(N))*DX + FDer2(N))*DX + FDer1(N))*DX + Dawson(N)
  IF(Y <= 1.0e-12_rp) THEN
    cdrayson = CMPLX(EXP(-X*X),TwoOvSPi * F,KIND=rp)
    RETURN
  ENDIF
!
!  Taylor series expansion about y = 0.0
!
  wr = EXP(y*y-x*x)
  twoxy = 2.0_rp*x*y
  cdrayson = CMPLX(wr*COS(twoxy),-wr*SIN(twoxy),KIND=rp)
  dely = -TwoOvSpi*Y
  FD = 1.0_rp - 2.0_rp * X * F
  wi = TwoOvSpi*F
  wr = FD*dely
  j = 5.0 + 10.0*y - 0.4*twoxy
  MAXJ = MIN(J, 14)
  DO J = 2, MAXJ,2
    F  = (X*FD + F) / RI(J)
    FD = (X*F + FD) / RI(J+1)
    dely = y * dely
    wi = wi + f*dely
    dely = -y*dely
    wr = wr + FD*dely
  END DO
!
  cdrayson = cdrayson + CMPLX(wr,wi,KIND=rp)
!
  END FUNCTION cdrayson
d495 2
a496 2
  Real(rp), INTENT(IN) :: t        ! Temperature K
  Real(rp), INTENT(IN) :: m        ! Molecular mass amu
d498 2
a499 2
  Real(rp), INTENT(IN) :: el       ! Lower state energy cm-1
  Real(rp), INTENT(IN) :: w        ! Collision broadening parameter
d501 4
a504 4
  Real(rp), INTENT(IN) :: ps       ! Pressure shift parameter in MHz/mbar
  Real(rp), INTENT(IN) :: p        ! Pressure mbar
  Real(rp), INTENT(IN) :: n        ! Temperature power dependence of w
  Real(rp), INTENT(IN) :: i        ! Integrated spectral intensity
d506 1
a506 1
  Real(rp), INTENT(IN) :: q(3)     ! Logarithm of the partition function
d508 4
a511 4
  Real(rp), INTENT(IN) :: delta    ! Delta interference coefficient at 300K 1/mb
  Real(rp), INTENT(IN) :: gamma    ! Gamma               "
  Real(rp), INTENT(IN) :: n1       ! Temperature dependency of delta
  Real(rp), INTENT(IN) :: n2       ! Temperature dependency of gamma
d516 2
a517 2
  Real(rp), INTENT(OUT) :: x1      ! Sqrt(Ln(2))/Doppler half width MHz
  Real(rp), INTENT(OUT) :: y       ! Sqrt(Ln(2))*collision width /
d519 3
a521 3
  Real(rp), INTENT(OUT) :: yi      ! Interference contribution
  Real(rp), INTENT(OUT) :: slabs1  ! Frequency independent piece of slabs
  Real(rp), INTENT(OUT) :: dslabs1 ! Derivative of slabs1 w.r.t. v0
d536 7
a542 7
  Real(rp), Parameter :: i2abs = 3.402136078e9_rp
  Real(rp), Parameter :: dc = 3.58117369e-7_rp
  Real(rp), Parameter :: boltzcm = 0.6950387_rp
  Real(rp), Parameter :: boltzmhz = 20836.74_rp
  Real(rp), Parameter :: sqrtln2 = 8.32554611157698e-1_rp
  Real(rp), Parameter :: loge = 4.34294481903251828e-1_rp
  Real(rp), Parameter :: oned300 = 1.0_rp/300.0_rp
d544 2
a545 2
  Real(rp), parameter :: tl1 = 1.76091259055681e-1_rp     ! Log10(225/150)
  Real(rp), parameter :: tl2 = 1.24938736608300e-1_rp     ! Log10(300/225)
d549 1
a549 1
  Real(rp) :: Wd, Q_Log, betae, betav, t3t, onedt, ns, r, e1, e2, de1, &
d554 2
a555 2
  onedt = 1.0_rp / t
  t3t = 300.0_rp * onedt
d558 1
a558 1
  if (t < 225.0_rp) then
d560 1
a560 1
    Q_Log = q(2)-q(1)+r*Log10(t/225.0_rp)
d563 1
a563 1
    Q_Log = r*Log10(t/300.0_rp)
d566 1
a566 1
  ns = 0.25_rp + 1.5_rp * n
d580 3
a582 3
  g = 1.0_rp - e2
  s = (1.0_rp - e1) / g
  ds = (-de1*g+(1.0_rp-e1)*de2)/(g*g)
d603 2
a604 2
  Real(rp), INTENT(IN) :: t       ! Temperature K
  Real(rp), INTENT(IN) :: m       ! Molecular mass amu
d606 2
a607 2
  Real(rp), INTENT(IN) :: el      ! Lower state energy cm-1
  Real(rp), INTENT(IN) :: w       ! Collision broadening parameter
d609 4
a612 4
  Real(rp), INTENT(IN) :: ps      ! Pressure shift parameter in MHz/mbar
  Real(rp), INTENT(IN) :: p       ! Pressure mbar
  Real(rp), INTENT(IN) :: n       ! Temperature power dependence of w
  Real(rp), INTENT(IN) :: i       ! Integrated spectral intensity
d614 1
a614 1
  Real(rp), INTENT(IN) :: q(3)    ! Logarithm of the partition function
d616 4
a619 4
  Real(rp), INTENT(IN) :: delta   ! Delta interference coefficient at 300K 1/mb
  Real(rp), INTENT(IN) :: gamma   ! Gamma               "
  Real(rp), INTENT(IN) :: n1      ! Temperature dependency of delta
  Real(rp), INTENT(IN) :: n2      ! Temperature dependency of gamma
d624 2
a625 2
  Real(rp), INTENT(OUT) :: x1        ! Sqrt(Ln(2))/Doppler half width MHz
  Real(rp), INTENT(OUT) :: y         ! Sqrt(Ln(2))*collision width /
d627 2
a628 2
  Real(rp), INTENT(OUT) :: yi        ! Interference contribution
  Real(rp), INTENT(OUT) :: slabs1    ! Frequency independent piece of slabs
d630 3
a632 3
  Real(rp), INTENT(OUT) :: dx1_dv0       ! Derivative of x1 w.r.t. v0
  Real(rp), INTENT(OUT) :: dy_dv0        ! Derivative of y w.r.t. v0
  Real(rp), INTENT(OUT) :: dslabs1_dv0   ! Derivative of slabs1 w.r.t. v0
d708 7
a714 5
!
 Subroutine Slabs_Prep_Arrays(Spectag,nl,t,p,mass,Qlog,Catalog,v0s,x1,y, &
                           &  yi,slabs1,dslabs1_dv0)
!
 type(catalog_T) :: Catalog 
d716 1
a716 1
 Integer(ip), intent(in) :: Spectag, nl
d718 2
a719 1
 Real(rp), intent(in) :: t, p, mass,Qlog(:)
d721 2
a722 2
 Real(r8), intent(out) :: v0s(:)
 Real(rp), intent(out) :: x1(:),y(:),yi(:),slabs1(:),dslabs1_dv0(:)
d724 2
a725 1
  Integer :: j, k
d736 1
a736 1
    Call Slabs_prep(t,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,        &
d739 1
a739 1
      &  yi(j),slabs1(j),dslabs1_dv0(j))
d741 5
a745 1
  end do
d747 5
a751 1
 End Subroutine Slabs_Prep_Arrays
d753 1
a753 3
!------------------------------------------------------------
  SUBROUTINE get_gl_slabs_arrays(Catalog,p_path,t_path,vel_z,gl_slabs, &
                             &   no_ele,dt)
d755 23
a777 3
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
!
  Type(Catalog_T), dimension(:), intent(in) :: Catalog
a778 9
 Integer(ip), INTENT(IN) :: no_ele
!
 REAL(rp), INTENT(IN) :: p_path(:) ! Pressure in hPa or mbar
 REAL(rp), INTENT(IN) :: t_path(:)
!
 Real(rp), INTENT(IN) :: vel_z, dt
!
 Type (slabs_struct), POINTER :: gl_slabs(:,:)
!
d782 21
d804 3
a806 1
 Real(rp), PARAMETER :: c = 299792.4583_rp     ! Speed of Light Km./Sec.
d808 27
a834 1
 Integer :: nl,i,j,no_sps,spectag
d836 1
a836 1
 Real(rp) :: mass, Vel_z_correction, Qlog(3)
d838 1
a838 1
! Begin code:
d840 5
a844 3
   no_sps = Size(Catalog)
!
   Vel_z_correction = 1.0_rp + vel_z / c
d846 1
a846 1
   DO i = 1, no_sps
d848 1
a848 7
     Spectag = Catalog(i)%spec_tag
     mass = Real(Spectag) / 1000.0_rp
!
     nl = Size(Catalog(i)%Lines)
     gl_slabs(1:no_ele,i)%no_lines = nl

     Qlog(1:3) = Catalog(i)%QLOG(1:3)
d850 3
a852 1
     do j = 1, no_ele
d854 3
a856 3
       Call Slabs_Prep_Arrays(Spectag,nl,t_path(j)+dt,p_path(j),mass,Qlog, &
         &  Catalog(i),gl_slabs(j,i)%v0s,gl_slabs(j,i)%x1,gl_slabs(j,i)%y, &
         &  gl_slabs(j,i)%yi,gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dslabs1_dv0)
d860 24
a883 1
       gl_slabs(j,i)%v0s = gl_slabs(j,i)%v0s * Vel_z_correction
d885 1
a885 1
     end do
d887 3
a889 3
   END DO              ! On i
!
   Return
a892 2
!=====================================================================

d895 12
@


1.4.2.3
log
@Corrected sign of velocity correction
@
text
@d13 1
a13 1
  "$Id: slabs_sw_m.f90,v 1.4.2.2 2001/09/10 10:02:32 zvi Exp $"
d1028 1
a1028 1
   Vel_z_correction = 1.0_rp - vel_z / c
a1061 3
! Revision 1.4.2.2  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
@


1.4.2.4
log
@Added CVS stuff
@
text
@a8 6
  Private
  Public :: dvoigt_spectral, slabs, slabswint, voigt_lorentz, &
        &  real_simple_voigt, simple_voigt, rlorentz, rvoigth2, &
        &  cvoigth2, rvoigth6, cvoigth6, rhui6, chui6, rdrayson, &
        &  cdrayson, slabs_prep, slabs_prep_arrays, get_gl_slabs_arrays

d13 1
a13 1
  "$Id: slabs_sw_m.f90,v 1.4.2.3 2001/09/12 00:05:44 livesey Exp $"
d968 1
a968 1
 type(catalog_T) :: Catalog
a1061 3
! Revision 1.4.2.3  2001/09/12 00:05:44  livesey
! Corrected sign of velocity correction
!
@


1.3
log
@Added Copyright statement
@
text
@d6 4
d13 1
a13 1
  "$Id: slabs_sw_m.f90,v 1.2 2001/05/15 03:47:26 zvi Exp $"
d19 161
d400 4
d405 2
a406 1
!---------------------------------------------------------------------
d408 2
a409 1
 Subroutine Z_Slabs(x,y,u,v)
d411 1
a411 19
!***********************************************************************
!                                                                      *
! Computes the Voigt function: Integral from - to + infinity of:       *
!                                                                      *
!     u = (y/Pi)*Exp(-t*t)/(y*y+(x-t)*(x-t)) dt        (Real(W(z)))    *
!                                                                      *
!   and:                                                               *
!                                                                      *
!     v = (1/Pi)*(x-t)*Exp(-t*t)/(y*y+(x-t)*(x-t)) dt  (Image(W(z)))   *
!                                                                      *
!   Here:                                                              *
!               x = sqrt(ln 2) * (v - v0) / aD    (x >= 0.0)           *
!               y = sqrt(ln 2) * aL / aD          (y >= 0.0)           *
!                                                                      *
!   Where v is the wave number, v0 is the line center wave number, aL  *
! is the Lorentzian line half-width and aD is the Doppler line         *
! half-width.                                                          *
!                                                                      *
!***********************************************************************
d413 3
a415 2
  Real(r8), INTENT(IN)  :: x,y
  Real(r8), INTENT(OUT) :: u,v
d417 5
a421 1
  Real(r8) :: xa, yh
d423 5
a427 15
  xa = abs(x)
  if(xa+y > 6.0_r8) then           ! Region 4, Gauss-Hermite 6 points
    Call VoigtH6(xa,y,u,v)
  else
    yh = 1.0e-4*xa*xa
    if(y <= yh) then
      if(xa > 5.0_r8) then
        Call VoigtH6(xa,y,u,v)    ! Region 4, Gauss-Hermite 6 points
      else
        Call Drayson(xa,y,u,v)    ! Region 1, Dowson+Taylor
      endif
    else                          ! Region 2, Hui (p=6)
      Call Hui6(xa,y,u,v)
    endif
  endif
d429 39
a467 1
  if(x < 0.0_r8) v = -v
d470 1
a470 1
 End Subroutine Z_Slabs
d593 17
a609 17
  Real(r8), INTENT(IN) :: t        ! Temperature K
  Real(r8), INTENT(IN) :: m        ! Molecular mass amu
  Real(r8), INTENT(IN) :: v0       ! Line center frequency MHz
  Real(r8), INTENT(IN) :: el       ! Lower state energy cm-1
  Real(r8), INTENT(IN) :: w        ! Collision broadening parameter
                                   ! MHz/mbar at 300 K
  Real(r8), INTENT(IN) :: ps       ! Pressure shift parameter in MHz/mbar
  Real(r8), INTENT(IN) :: p        ! Pressure mbar
  Real(r8), INTENT(IN) :: n        ! Temperature power dependence of w
  Real(r8), INTENT(IN) :: i        ! Integrated spectral intensity
                                   ! Log(nm**2 MHz) at 300 K
  Real(r8), INTENT(IN) :: q(3)     ! Logarithm of the partition function
                                   ! At 300 , 225 , and 150 K
  Real(r8), INTENT(IN) :: delta    ! Delta interference coefficient at 300K 1/mb
  Real(r8), INTENT(IN) :: gamma    ! Gamma               "
  Real(r8), INTENT(IN) :: n1       ! Temperature dependency of delta
  Real(r8), INTENT(IN) :: n2       ! Temperature dependency of gamma
d697 16
a712 3
!---------------------------------------------------------------------
!
 Real(r8) Function Slabswint(dNu,v0s,x1,slabs1,y,yi)
d714 2
a715 11
  Real(r8), INTENT(IN) :: dNu, v0s, x1, slabs1, y, yi
!
  Real(r8), Parameter :: sqrt_pi_i = 1.0_r8/1.7724538509055160273_r8
!
!  Note: dNu = v - v0s
!
! If the molecular transition and temperature have not changed but
! frequency has enter here.
!
! inputs: dNu , x1 , slabs1 , y, v0s, yi
! output: slabswint (slab with interference)
d717 1
a717 1
  Real(r8) :: x, u, v, q, p, z, r, w
d719 1
a719 2
  x = x1 * dNu
  Call Z_Slabs(x,y,u,v)
d721 1
a721 4
!  Van Vleck - Wieskopf line shape with Voigt, Added Mar/2/91, Bill
!  Modified code to include interference: June/3/1992 (Bill + Zvi)
!  Modified code to correct a sign error (introduced in last change)
!  (Bill + Zvi, July/7/92)
d723 1
a723 6
  q = 1.0_r8 + dNu / v0s
  p = x1 * (2.0_r8 * v0s + dNu)
  z = (y - p * yi)/(p * p + y * y)
  r = z * sqrt_pi_i + yi * v
  w = (u + r) * q * q
  Slabswint = slabs1 *  w
d725 5
a729 2
  Return
 End Function Slabswint
d731 5
a735 3
!---------------------------------------------------------------------
! Computes the voigt function and its first derivative with respect
! to spectaral parameters: w, n & Nu0
d737 5
a741 2
! NOTE: Before calling this routine, the user needs to call slabs_prep_wder()
!       routine to compute dx1_dv0,dy_dv0 and dslabs1_dNu0
d743 1
a743 2
 Subroutine dvoigt_spectral(dNu,Nu0,x1,yi,y,w,t,slabs1,dx1_dv0, &
     &      dy_dv0,dslabs1_dNu0,SwI,spect_der,dSwI_dw,dSwI_dn,dSwI_dNu0)
d745 48
a792 2
  Real(r8), Parameter :: twovspi = 1.1283791670955125739_r8   ! 2.0/Sqrt(Pi)
  Real(r8), Parameter :: oneovspi = 0.5_r8 * twovspi
d794 1
a794 3
  Logical, INTENT(IN) :: spect_der
  Real(r8), INTENT(IN) :: dNu, Nu0, x1, yi, y, w, t, slabs1, &
                          dslabs1_dNu0, dx1_dv0, dy_dv0
d796 1
a796 1
  Real(r8), INTENT(OUT) :: SwI,dSwI_dw,dSwI_dn,dSwI_dNu0
d798 5
a802 1
  Real(r8) :: x, u, v, du_dx, du_dy, dv_dx, dv_dy, q, q2, b, g, z, r
d804 21
a824 2
  Real(r8) :: dq_dv0, dx_dv0, du_dv0, dv_dv0, db_dv0, dg_dv0, dz_dv0, &
              dr_dv0, dvvw_dv0, vvw
d826 1
a826 2
  x = x1 * dNu
  Call Z_Slabs(x,y,u,v)
d828 1
a828 2
  du_dx = -2.0_r8 * (x * u - y * v)
  du_dy =  2.0_r8 * (x * v + y * u) - twovspi
d830 5
a834 2
  dv_dx = -du_dy         ! Cauchy-Riemann equation
  dv_dy =  du_dx         ! Cauchy-Riemann equation
d836 1
a836 1
!  Van Vleck - Wieskopf (VVW) line shape with Voigt
d838 1
a838 2
  q = 1.0_r8 + dNu / Nu0
  q2 = q * q
d840 3
a842 8
  b = x1 * (2.0_r8 * Nu0 + dNu)
  g = b * b + y * y
  z = (y - b * yi) / g
  r = z * oneovspi + yi * v
  vvw = (u + r) * q2
  SwI = slabs1 * vvw

  if(.not. spect_der) Return
d844 3
a846 1
! Compute the derivative of SwI w.r.t. w
d848 1
a848 3
  dSwI_dw = slabs1 * (y / w) * (du_dy +          &
     &      q2 * oneovspi * (b*b-y*y) / (g*g) +  &
     &      q2 * yi * du_dx)
d850 3
a852 1
! Compute the derivative of SwI w.r.t. n
d854 8
a861 1
  dSwI_dn = slabs1 * y * Log(3.0d2/t) * (du_dy + yi * dv_dy)
d863 5
a867 1
! Finaly, compute the derivative of SwI w.r.t. Nu0
d869 5
a873 1
! ***** Analytically *****
d875 1
a875 10
  dq_dv0 = -(Nu0+dNu)/(Nu0*Nu0)
  dx_dv0 = dNu * dx1_dv0 - x1
  du_dv0 = du_dx * dx_dv0 + du_dy * dy_dv0
  dv_dv0 = dv_dx * dx_dv0 + dv_dy * dy_dv0
  db_dv0 = (2.0_r8 * Nu0 + dNu)*dx1_dv0 + x1
  dg_dv0 = 2.0_r8 * (b*db_dv0+y*dy_dv0)
  dz_dv0 = (dy_dv0-yi*db_dv0-z*dg_dv0)/g
  dr_dv0 = dz_dv0*oneovspi+yi*dv_dv0
  dvvw_dv0 = (du_dv0+dr_dv0)*q2 + 2.0_r8*q*dq_dv0*(u+r)
  dSwI_dNu0 = dslabs1_dNu0*vvw + slabs1*dvvw_dv0
d877 2
d880 2
a881 1
 End Subroutine dvoigt_spectral
d885 3
@


1.2
log
@Adding derivative flag to beta calculations
@
text
@d1 3
d9 1
a9 1
  "$Id: slabs_sw_m.f90,v 1.1 2001/02/03 02:07:01 zvi Exp $"
d624 3
@


1.1
log
@Changes and additions
@
text
@d6 1
a6 1
  "$Id: slabs_sw_m.f90,v 1.1 2001/01/31 21:56:13 zvi Exp $"
d552 1
a552 1
     &      dy_dv0,dslabs1_dNu0,SwI,dSwI_dw,dSwI_dn,dSwI_dNu0)
d557 1
d588 2
d620 4
a623 1
! $Log: slabs_dw_m.f90,v $
@

