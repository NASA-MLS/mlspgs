head	2.145;
access;
symbols
	v5-02-NRT-19:2.145
	v6-00:2.145
	v5-02-NRT-18:2.145
	v5-02:2.144
	v5-01-NRT-17:2.145
	v5-01-NRT-16:2.145
	v5-01-NRT-15:2.145
	v5-01-NRT-14:2.145
	neuralnetworks-1-0:2.145.0.4
	cfm-single-freq-0-1:2.145.0.2
	v5-01:2.144
	v5-00:2.144
	v4-23-TA133:2.143.0.2
	mus-emls-1-70:2.142.0.2
	rel-1-0-englocks-work:2.140.0.2
	VUMLS1-00:2.137
	VPL1-00:2.136
	V4-22-NRT-08:2.136
	VAM1-00:2.135
	V4-21:2.133.0.2
	V4-13:2.133
	V4-12:2.130
	V4-11:2.130
	V4-10:2.130
	V3-43:2.104
	M4-00:2.120
	V3-41:2.104
	V3-40-PlusGM57:2.104.0.2
	V2-24-NRT-04:2.98
	V3-33:2.111
	V2-24:2.98
	V3-31:2.111
	V3-30-NRT-05:2.109
	cfm-01-00:2.108
	V3-30:2.104
	V3-20:2.104
	V3-10:2.103
	V2-23-NRT-02:2.98
	V2-23:2.98
	V2-22-NRT-01:2.98
	V2-22:2.98
	V2-21:2.95
	V2-20:2.95
	V2-11:2.95
	V2-10:2.95
	V2-00:2.94
	V1-51:2.65
	V1-50:2.65
	V1-45:2.57
	V1-44:2.57
	V1-43:2.48
	V1-32:2.45
	V1-31:2.45
	V1-30:2.41
	V1-13:2.31
	V1-12:2.31
	V1-11:2.31
	V1-10:2.30
	newfwm-feb03:2.30.0.2
	V1-04:2.6
	V1-03:2.6
	V1-02:2.6
	JointForwardModel:2.7.0.2
	V1-00:2.6
	newfwm-sep01:1.15.0.2
	V0-7:1.14
	V0-5-Level2:1.7
	V0-5-SIPS:1.3;
locks; strict;
comment	@# @;


2.145
date	2019.10.07.20.04.12;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2019.04.24.19.17.24;	author vsnyder;	state Exp;
branches;
next	2.143;

2.143
date	2018.08.06.19.58.24;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2018.05.15.03.26.25;	author vsnyder;	state Exp;
branches;
next	2.141;

2.141
date	2018.04.11.22.25.23;	author vsnyder;	state Exp;
branches;
next	2.140;

2.140
date	2017.09.20.01.07.57;	author vsnyder;	state Exp;
branches;
next	2.139;

2.139
date	2017.09.15.15.45.18;	author livesey;	state Exp;
branches;
next	2.138;

2.138
date	2017.08.17.16.29.54;	author livesey;	state Exp;
branches;
next	2.137;

2.137
date	2017.02.04.02.17.40;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2016.05.02.23.31.50;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2015.08.25.17.21.47;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2015.03.28.01.59.22;	author vsnyder;	state Exp;
branches;
next	2.133;

2.133
date	2014.09.29.20.25.58;	author vsnyder;	state Exp;
branches;
next	2.132;

2.132
date	2014.09.05.20.48.44;	author vsnyder;	state Exp;
branches;
next	2.131;

2.131
date	2014.08.01.01.01.55;	author vsnyder;	state Exp;
branches;
next	2.130;

2.130
date	2014.01.09.00.26.39;	author pwagner;	state Exp;
branches;
next	2.129;

2.129
date	2013.09.24.23.28.17;	author vsnyder;	state Exp;
branches;
next	2.128;

2.128
date	2013.08.16.02.32.14;	author vsnyder;	state Exp;
branches;
next	2.127;

2.127
date	2013.08.12.23.48.08;	author pwagner;	state Exp;
branches;
next	2.126;

2.126
date	2013.08.09.01.02.58;	author vsnyder;	state Exp;
branches;
next	2.125;

2.125
date	2013.08.08.02.34.54;	author vsnyder;	state Exp;
branches;
next	2.124;

2.124
date	2013.07.25.00.22.09;	author vsnyder;	state Exp;
branches;
next	2.123;

2.123
date	2013.07.19.01.18.45;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2013.07.13.00.07.28;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2013.05.15.03.08.55;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2013.03.30.00.11.39;	author vsnyder;	state Exp;
branches;
next	2.119;

2.119
date	2013.03.20.22.46.42;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2013.03.01.01.08.11;	author pwagner;	state Exp;
branches;
next	2.117;

2.117
date	2012.05.01.22.18.50;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2012.03.07.00.45.28;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2012.01.25.00.07.07;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2011.07.29.01.51.38;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2011.05.09.17.45.38;	author pwagner;	state Exp;
branches;
next	2.112;

2.112
date	2011.03.31.19.50.29;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2010.12.06.19.15.42;	author pwagner;	state Exp;
branches;
next	2.110;

2.110
date	2010.09.25.01.08.39;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2010.08.27.06.13.37;	author yanovsky;	state Exp;
branches;
next	2.108;

2.108
date	2010.06.09.16.33.59;	author pwagner;	state Exp;
branches;
next	2.107;

2.107
date	2010.06.07.23.20.51;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2010.05.14.02.18.16;	author vsnyder;	state Exp;
branches;
next	2.105;

2.105
date	2010.03.26.23.12.51;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2010.01.23.01.04.26;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.102;

2.102
date	2008.08.27.19.56.51;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2008.07.31.17.39.34;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2008.05.20.00.27.32;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2007.11.07.03.07.42;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2007.10.02.22.34.49;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2007.06.25.20.34.46;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2006.11.30.23.32.17;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2006.07.21.00.17.39;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2006.06.03.01.46.10;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2006.06.01.02.55.21;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2006.05.31.22.02.13;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2006.05.11.19.36.14;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2006.04.25.23.25.36;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2006.04.11.18.37.21;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2006.02.23.00.58.58;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2006.02.08.21.37.36;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2006.02.08.01.02.01;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2005.12.29.01.12.04;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2005.11.15.00.23.21;	author pwagner;	state Exp;
branches;
next	2.83;

2.83
date	2005.11.02.21.38.24;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2005.11.01.23.01.36;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2005.09.17.00.48.42;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2005.09.03.01.21.33;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2005.08.19.23.32.06;	author pwagner;	state Exp;
branches;
next	2.78;

2.78
date	2005.08.03.18.04.09;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2005.06.03.01.58.53;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2005.05.28.03.27.21;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2005.05.26.20.12.16;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2005.05.26.20.11.31;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2005.05.26.02.15.14;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2005.05.24.01.54.35;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2005.05.05.20.48.02;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2005.05.05.01.14.22;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2005.05.02.23.04.03;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2005.03.28.20.27.51;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2005.02.17.02.35.13;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2005.02.16.23.16.49;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2004.12.28.00.27.29;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2004.12.13.20.35.22;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2004.11.05.19.38.11;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2004.11.04.03.42.08;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2004.11.03.01.25.30;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2004.11.01.20.18.23;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2004.10.06.21.23.50;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2004.09.01.00.32.40;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2004.08.07.01.17.26;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2004.08.05.20.57.52;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2004.08.03.21.40.06;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2004.07.16.19.13.18;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2004.07.08.02.35.29;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2004.06.23.02.14.06;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2004.06.11.01.33.29;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2004.06.10.00.59.55;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2004.05.26.23.54.14;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2004.05.01.04.00.59;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2004.03.24.13.50.56;	author hcp;	state Exp;
branches;
next	2.46;

2.46
date	2004.03.22.18.23.20;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2003.10.28.23.43.47;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2003.10.18.01.15.58;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2003.09.15.23.45.00;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2003.09.11.23.10.04;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2003.07.22.22.43.39;	author michael;	state Exp;
branches;
next	2.40;

2.40
date	2003.07.15.22.09.59;	author livesey;	state Exp;
branches;
next	2.39;

2.39
date	2003.07.15.18.16.26;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2003.06.30.22.55.01;	author cvuu;	state Exp;
branches;
next	2.37;

2.37
date	2003.06.18.01.58.01;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2003.05.29.16.37.02;	author livesey;	state Exp;
branches;
next	2.35;

2.35
date	2003.05.19.19.58.07;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2003.05.05.23.00.24;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2003.04.04.00.26.44;	author jonathan;	state Exp;
branches;
next	2.32;

2.32
date	2003.04.02.21.46.51;	author jonathan;	state Exp;
branches;
next	2.31;

2.31
date	2003.03.07.03.16.00;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2003.02.06.22.04.25;	author vsnyder;	state Exp;
branches
	2.30.2.1;
next	2.29;

2.29
date	2003.02.06.20.16.23;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2003.02.05.21.57.27;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2003.01.30.22.01.30;	author livesey;	state Exp;
branches;
next	2.26;

2.26
date	2003.01.30.18.29.40;	author jonathan;	state Exp;
branches;
next	2.25;

2.25
date	2003.01.30.17.28.01;	author jonathan;	state Exp;
branches;
next	2.24;

2.24
date	2003.01.29.01.48.52;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2003.01.26.04.42.42;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2003.01.17.00.01.44;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2003.01.16.05.53.19;	author livesey;	state Exp;
branches;
next	2.20;

2.20
date	2003.01.16.05.50.59;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2003.01.16.00.55.27;	author jonathan;	state Exp;
branches;
next	2.18;

2.18
date	2003.01.13.17.16.23;	author jonathan;	state Exp;
branches;
next	2.17;

2.17
date	2002.12.04.21.55.22;	author livesey;	state Exp;
branches;
next	2.16;

2.16
date	2002.11.22.12.14.31;	author mjf;	state Exp;
branches;
next	2.15;

2.15
date	2002.11.15.01.32.53;	author livesey;	state Exp;
branches;
next	2.14;

2.14
date	2002.10.08.17.40.01;	author livesey;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.08.17.08.03;	author pwagner;	state Exp;
branches;
next	2.12;

2.12
date	2002.10.06.01.09.22;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2002.10.05.00.41.01;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2002.09.25.20.06.42;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2002.08.21.23.53.57;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2002.07.17.06.02.13;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2002.06.12.17.00.49;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2002.03.07.17.17.49;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2002.02.14.23.01.35;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2002.02.13.00.09.24;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.11.15.23.50.11;	author jonathan;	state Exp;
branches;
next	2.2;

2.2
date	2001.11.15.20.56.38;	author jonathan;	state Exp;
branches;
next	2.1;

2.1
date	2001.10.02.20.37.09;	author livesey;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.25;	author livesey;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.04.15.59.01;	author jonathan;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.17.22.38.05;	author jonathan;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.16.22.07.57;	author jonathan;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.06.18.55.13;	author jonathan;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.21.15.05.53;	author livesey;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.31.23.07.45;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.25.20.26.09;	author livesey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.14.23.17.35;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.03.23.07.02;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.02.20.30.36;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.26.02.36.52;	author vsnyder;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.21.01.08.57;	author vsnyder;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.12.17.00.08;	author vsnyder;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.22.17.05;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.07.01.56.25;	author vsnyder;	state Exp;
branches;
next	;

2.30.2.1
date	2003.02.22.00.48.08;	author vsnyder;	state Exp;
branches;
next	2.30.2.2;

2.30.2.2
date	2003.04.08.23.40.11;	author jonathan;	state Exp;
branches;
next	;


desc
@@


2.145
log
@Add trapezoid field for quadrature in FullForwardModel
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject bto U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module ForwardModelConfig
!=============================================================================

! Set up the forward model configuration, except for actually processing
! the command.

  use MLSKinds, only: R8, RP
  use MLSSignals_M, only: Signal_T
  use SpectroscopyCatalog_M, only: Catalog_T
  use VectorsModule, only: RV, VectorValue_T
  use VGridsDatabase, only: VGrid_T, DestroyVGridContents, Dump

  implicit NONE
  private

  ! Public procedures:
  interface Dump
    module procedure Dump_Beta_Group, Dump_ForwardModelConfig
    module procedure Dump_ForwardModelConfigDatabase, Dump_Qty_Stuff
  end interface Dump

  public :: AddForwardModelConfigToDatabase, DeriveFromForwardModelConfig
  public :: DestroyFWMConfigDatabase, DestroyForwardModelDerived
  public :: Dump, NullifyForwardModelConfig
  public :: PVMPackFWMConfig, PVMUnpackFWMConfig
  public :: StripForwardModelConfigDatabase
 
  ! Public Types:

  ! Quantities derived from forward models, but not carted around by
  ! PVMPackFWMConfig and PVMUnpackFWMConfig.  Rather, they are computed by
  ! DeriveFromForwardModelConfig, either when a ForwardModelConfig_T is
  ! created or when one arrives by way of PVMUnpackFWMConfig.

  type, public :: QtyStuff_T ! So we can have an array of pointers to QTY's
    type (VectorValue_T), pointer :: Qty => NULL()
    real(rv), pointer :: Value1(:) => NULL()      ! For logBasis quantities
                                                  ! Freq * Vert * Horiz
    real(rv), pointer :: Values(:,:) => NULL()    ! Associated with Value1
                                                  ! Freq * Vert x Horiz
    real(rv), pointer :: Values3(:,:,:) => NULL() ! Associated with Value1
                                                  ! Freq x Vert x Horiz
    logical :: FoundInFirst = .false.
    logical :: WasSpecific = .false.
    logical :: DerivOK = .false. ! There is a place for the forward model to
                                 ! put the derivatives.  If .not. FoundInFirst,
                                 ! then the forward model must have gotten
                                 ! ExtraJacobian.
  end type QtyStuff_T

  ! Data structures to indicate which spectral parameters are being solved.
  type, public :: SpectroParam_T
    integer :: Beta(2)       ! Beta group LBL indices
    integer :: Molecule
    type (QtyStuff_T) :: Qty ! The Qty's vector
  end type SpectroParam_T

  ! Subscripts for spectral parameter stuff
  integer, parameter, public :: LineCenter = 1, LineWidth = 2, LineWidth_TDep = 3

  ! Beta group type declaration.  Each entry in the Molecules list of the form
  ! "m" has one of these with n_elements == 1, referring to "m".  Each entry
  ! of the form "[m,m1,...,mn]" has one of these with n_elements == n, referring
  ! to m1,...mn (but not m).  The Ratio components are filled in
  ! Get_Species_Data.
  type, public :: LBL_T ! For LBL molecules in the group.  All the same
    ! size, if associated at all.
    integer, pointer  :: Cat_Index(:) => NULL() ! Indices for config%catalog
                                      ! and gl_slabs. Allocated in
                                      ! ConstructForwardModelConfig. Filled in
                                      ! DeriveFromForwardModelConfig.
    integer, pointer :: Molecules(:) => NULL() ! LBL molecules in the group
                                      ! if a group, i.e., "m1...mn", else "m" if
                                      ! "m" is LBL, else zero size.
    real(rp), pointer :: Ratio(:) => NULL() ! Isotope ratio.  Allocated in
                                      ! ForwardModelSupport with value 1.0, but
                                      ! could be filled in Get_Species_Data.
    integer :: Spect_der_ix(lineCenter:lineWidth_tDep) = 0 ! Do deriv w.r.t.
      ! spectral param if nonzero. If Spect_der_ix(lineCenter) is nonzero,
      ! fwdModelConf%%LineCenter(Spect_der_ix_ix(lineCenter)) is added onto the
      ! line center in the gl_slabs array for the i'th line-by-line molecule in
      ! sideband s.  Similarly for %LineWidth and %LineWidth_Tdep.
  end type LBL_T

  type, public :: PFA_T ! For PFA molecules in the group:
    integer, pointer :: Molecules(:) => NULL() ! PFA molecules in the group if a
                                      ! group, i.e., "m1...mn", else "m" if "m"
                                      ! is PFA, else zero size.
    integer, pointer :: Data(:,:) => NULL() ! Channels x 1:size(Molecules).
                                      ! Indices in PFAData.  Allocated and
                                      ! filled in DeriveFromForwardModelConfig.
    real(rp), pointer :: Ratio(:) => NULL() ! 1:size(Molecules).  Isotope
                                      ! ratio.  Allocated in ForwardModelSupport
                                      ! with value 1.0, but could be filled in
                                      ! Get_Species_Data.
  end type PFA_T

  type, public :: Beta_Group_T
    ! For the group as a whole:
    logical :: Derivatives = .false.        ! "Compute derivatives w.r.t. mixing ratio"
    logical :: SecondDerivatives = .false.  ! "Compute second derivatives w.r.t. mixing ratio"
    logical :: Group = .false.        ! "Molecule group", i.e., [m,m1,...,mn]
    integer :: Molecule               ! Group name, i.e., "m".
    type(qtyStuff_t) :: Qty           ! The Qty's vector and foundInFirst, filled
                                      ! in Get_Species_Data.
    type(lbl_t) :: LBL(2)             ! LSB, USB for Line-By-Line stuff
    type(pfa_t) :: PFA(2)             ! LSB, USB for Pre-Frequency-Averaged stuff
  end type Beta_Group_T

  ! Channel information from the signals database.
  type, public :: Channels_T
    integer :: Used       ! Which channel is this?
    integer :: Origin     ! Index of first channel (zero or one)
    integer :: Signal     ! Signal index for the channel
    integer :: DACS       ! DACS index if any, else zero
    integer :: ShapeInds(2) ! Filter shape indices, by sideband, 1 => LSB, 2 => USB
  end type Channels_T

  ! The scalar components are sorted in the order they are to make the packing
  ! and unpacking for PVM as easy as possible to maintain
  type, public :: ForwardModelConfig_T
    ! First the lit_indices
    integer :: Name                   ! String index of config name
    integer :: Where                  ! Tree node index of config (for messages)
    integer :: Cloud_der              ! Compute cloud sensitivity in cloud models.
                                      ! l_iwc_low_height, l_iwc_high_height, l_iwp
                                      ! l_none
    integer :: FwmType                ! l_linear, l_full, l_scan, ....
    integer :: I_saturation           ! Flag to determine saturation status
                                      ! l_clear, l_clear_110rh_below_top
                                      ! l_clear_0rh, l_clear_lowest_0_110rh
                                      ! l_clear_110rh_below_tropopause,
                                      ! l_cloudy_110rh_below_top
                                      ! l_cloudy_110rh_in_cloud,
                                      ! l_cloudy_nearside_only
    integer :: InstrumentModule       ! Module for scan model (actually a spec index)
    integer :: Trapezoid              ! "Wrong" or "Correct"
    integer :: WindowUnits            ! Either degrees or profiles
    ! Now the other integers
    integer :: Cat_Size(2)            ! Catalog size, by sideband, 1 = LSB, 2 = USB
    integer :: LinearSideband         ! For hybrid model, which SB is linear?
    integer :: MIFTangent             ! L_ECRtoFOV or L_PTAN
    integer :: No_cloud_species       ! No of Cloud Species '2'
    integer :: No_model_surfs         ! No of Model surfaces '640'
    integer :: NoUsedChannels         ! Total in all signals
    integer :: Ntimes = 0             ! Number of times calling FullForwardModel
    integer :: Num_ab_terms           ! No of AB terms '50'
    integer :: Num_azimuth_angles     ! No of azmuth angles '8'
    integer :: Num_scattering_angles  ! No of scattering angles '16'
    integer :: Num_size_bins          ! No of size bins '40'
    integer :: ReferenceMIF = 1       ! MIF number to use for MAF geolocation
    integer :: SidebandStart, SidebandStop ! Folded or SSB config?
    integer :: SurfaceTangentIndex    ! Index in Tangentgrid of Earth's surface
    integer :: TScatMIF               ! Which MIF to use for TScat LOS VEL and PHITAN
    integer :: xStar                  ! Index of specific vector to use for linearized model
    integer :: yStar                  ! Index of specific vector to use for linearized model
    ! Now the logicals
    logical :: AllLinesForRadiometer  ! As opposed to just using lines designated for band.
    logical :: AllLinesInCatalog      ! Use all the lines
    logical :: AnyLBL(2)              ! "there are LBL molecules in the sideband"
    logical :: AnyPFA(2)              ! "there are PFA molecules in the sideband"
    logical :: Atmos_der              ! Do atmospheric derivatives
    logical :: Atmos_second_der       ! Do atmospheric second derivatives
    logical :: Default_spectroscopy   ! Using Bill's spectroscopy data
    logical :: DifferentialScan       ! Differential scan model
    logical :: Do_1d                  ! Do 1D forward model calculation
    logical :: Do_baseline            ! Do a baseline computation
    logical :: Do_conv                ! Do convolution
    logical :: Do_freq_avg            ! Do Frequency averaging
    logical :: Do_Path_Norm           ! Do path normalization
    logical :: ForceFoldedOutput      ! Output to folded sideband even if signal is other (linear only)
    logical :: ForceSidebandFraction  ! If set mult. by SBfrac even if single sideband
    logical :: GenerateTScat          ! Generate TScat tables
    logical :: GlobalConfig           ! If set is shared between all chunks
    logical :: IgnoreHessian          ! Don't do 2nd-order Taylor series
                                      ! in quasi-linear model even if L2PC has
                                      ! a Hessian
    logical :: Incl_cld ! Include cloud extinction calculation in Bill's forward model
    logical :: IsRadianceModel        ! The forward model is a radiance model
    logical :: LockBins               ! Use same l2pc bin for whole chunk
    logical :: No_Magnetic_Field      ! Set magnetic field to zero for testing
    logical :: Polarized              ! Use polarized model for Zeeman-split lines
    logical :: Refract                ! Compute refractive correction for PhiTan
    logical :: ScanAverage            ! Average scan over MIF
    logical :: SkipOverlaps           ! Don't calculate for MAFs in overlap regions
    logical :: Spect_Der              ! Do spectroscopy derivatives
    logical :: SwitchingMirror        ! Model radiance at the switching mirror
    logical :: Temp_Der               ! Do temperature derivatives
    logical :: TransformMIFExtinction ! Transform MIF extinction, see wvs-107
    logical :: TransformMIFRHI        ! Transform MIF RHI
    logical :: UseTScat               ! Use TScat tables + linear model in full model
    ! Now the reals
    real (r8) :: FrqTol               ! MHz, how close to desired frequency must
                                      ! Mie table be?
    real (r8) :: PhiWindow(2)         ! Window for examining stuff; (1) before
                                      ! tangent point, (2) after tangent point
    real (r8) :: Tolerance            ! Accuracy desired when choosing approximations
    real :: sum_DeltaTime = 0.0       ! sum of delta time calling FullForwardModel 
    real :: sum_squareDeltaTime = 0.0 ! sum of the square of delta times calling FullForwardModel 
    ! Now the arrays
    integer, dimension(:), pointer :: BinSelectors=>NULL() ! List of relevant bin selectors
    integer, dimension(:), pointer :: Molecules=>NULL() ! Which molecules to consider
    logical, dimension(:), pointer :: MoleculeDerivatives=>NULL() ! Want Jacobians
    logical, dimension(:), pointer :: MoleculeSecondDerivatives=>NULL() ! Want Hessians
    integer, dimension(:), pointer :: SpecificQuantities=>NULL() ! Specific quantities to use
    ! Now the derived types
    type (beta_group_t), dimension(:), pointer :: Beta_Group => NULL() ! q.v. above
    type (spectroParam_t), dimension(:), pointer :: LineCenter => NULL()
    type (spectroParam_t), dimension(:), pointer :: LineWidth => NULL()
    type (spectroParam_t), dimension(:), pointer :: LineWidth_TDep => NULL()
      ! Some of this is filled in each time the forward model is invoked.  Those
      ! parts aren't dragged around by PVM.
    type (Signal_T), dimension(:), pointer :: Signals=>NULL()
    integer, dimension(:), pointer :: SignalIndices=>NULL() ! in signals database
    type (vGrid_T), pointer :: IntegrationGrid=>NULL() ! Zeta grid for integration
    type (vGrid_T), pointer :: TangentGrid=>NULL()     ! Zeta grid for integration
    ! Finally stuff that PVMPackFWMConfig and PVMUnpackFWMConfig don't cart around
    ! This stuff is filled in each time the forward model is invoked, partly by
    ! DeriveFromForwardModel and partly by Get_Species_Data.
    type (catalog_t), pointer :: Catalog(:,:) => NULL()     ! sidebands,1:noNonPFA
      ! Catalog's second subscript comes from Beta_Group%Cat_Index for each
      ! element of the beta group.  We do this indirectly so that the whole
      ! catalog can be turned into gl_slabs data at once, and then the gl_slabs
      ! can be indexed by Beta_Group%Cat_Index as well.
    real(rp), dimension(:,:), pointer :: DACsStaging => NULL() ! Temporary
      ! space for DACS radiances
    integer, dimension(:), pointer :: USEDDACSSIGNALS => NULL() ! Indices in
      ! FwdModelConf_T%Signals of signals for our dacs
    type(channels_T), pointer, dimension(:) :: Channels => NULL()
    type(qtyStuff_T) :: Temp ! Temperature stuff
  end type ForwardModelConfig_T

  !------------- RCS Ident Info (more below in not_used_here) ----------------
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: ForwardModelConfig.f90,v $"
  private :: not_used_here 
  !---------------------------------------------------------------------------

contains

  ! ----------------------------  AddForwardModelConfigToDatabase  -----
  integer function AddForwardModelConfigToDatabase ( Database, Item )

    ! Add a quantity template to a database, or create the database if it
    ! doesn't yet exist

    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate

    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: Database
    type (ForwardModelConfig_T), intent(in) :: Item

    ! Local variables
    type (ForwardModelConfig_T), dimension(:), pointer :: tempDatabase

    include "addItemToDatabase.f9h"

    AddForwardModelConfigToDatabase = newSize
  end function AddForwardModelConfigToDatabase

  ! -------------------------------  DeriveFromForwardModelConfig  -----
  subroutine DeriveFromForwardModelConfig ( FwdModelConf )

    use Allocate_Deallocate, only: Allocate_Test
    use MLSMessageModule, only: MLSMessage,  MLSMsg_Error, MLSMsg_Warning
    use MLSStringLists, only: SwitchDetail
    use PFADatabase_M, only: Dump
    use Read_Mie_M, only: F_S
    use Output_M, only: Output
    use SpectroscopyCatalog_M, only: Dump
    use Toggles, only: Switches

    type (ForwardModelConfig_T), intent(inout) :: FwdModelConf
    integer :: DumpFwm = -2                ! -2 = not called yet, -1 = no dumps,
                                           ! low-order digit: catalog dump level
                                           ! high-order digit: 1 => stop
    logical :: Error
    integer :: S1, S2                      ! SidebandStart, SidebandStop

    if ( dumpFwm < -1 ) dumpFwm = switchDetail(switches,'fwmd')

    error = .false.

    s1 = fwdModelConf%sidebandStart
    s2 = fwdModelConf%sidebandStop

    ! Identify which of our signals are DACS and how many unique DACS are involved
    ! Allocate and compute UsedDACSSignals and allocate DACsStaging.
    call DACS_Stuff ( fwdModelConf%DACsStaging, &
                    & fwdModelConf%usedDACSSignals ) ! Below

    ! Work out which channels are used.
    call channel_stuff ( fwdModelConf%channels, fwdModelConf%usedDACSSignals ) ! Below

    ! Work out the spectroscopy we're going to need.
    call SpectroscopyCatalogExtract ! Below

    ! Work out the PFA stuff.  The PFA stuff is done here instead of in
    ! ForwardModelSupport because the PFA stuff might be large (at least
    ! compared to the LBL stuff), so it is useful to allocate and destroy
    ! it separately for each forward model run.
    call PFA_Stuff ! Below

    if ( fwdModelConf%useTScat .and. .not. allocated(f_s) ) then
      call output ( 'UseTScat requested but no Mie tables loaded', advance='yes' )
      error = .true.
    end if

    if ( dumpFwm > -1 .or. error ) then
      call dump ( fwdModelConf, 'DeriveFromForwardModelConfig' )
      call dump ( fwdModelConf%catalog, details=mod(dumpFwm,10) )
      if ( dumpFwm > 9 .and. .not. error ) stop ! error message will stop later
    end if

    if ( error ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Unrecoverable errors in forward model configuration' )

  contains

    ! ............................................  Channel_Stuff  .....
    subroutine Channel_Stuff ( Channels, UsedDACSSignals )

      ! Work out which channels are used.

      use Allocate_Deallocate, only: Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      use FilterShapes_M, only: DACSFilterShapes, FilterShapes
      use MLSFinds, only: FindFirst
      use MLSSignals_M, only: MatchSignal

      type(channels_T), pointer :: Channels(:)
      integer :: UsedDACSSignals(:)          ! Indices in FwdModelConf_T%Signals
                                             ! of signals for our dacs

      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: Channel
      integer :: I, Ier
      integer :: SigInd
      integer :: SX, ThisSideband ! Sideband indices

      allocate ( channels(fwdModelConf%noUsedChannels), stat=ier )
      if ( ier == 0 .and. fwdModelConf%noUsedChannels > 0 ) &
        & addr = transfer(c_loc(channels(1)), addr)
      call test_allocate ( ier, ModuleName, 'info%channels', &
        & ubounds=(/ fwdModelConf%noUsedChannels /), &
        & elementSize = storage_size(channels) / 8, address=addr )

      ! Collect channel information from signals database.
      channel = 0
      do sigInd = 1, size(fwdModelConf%signals)
        do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
          if ( fwdModelConf%signals(sigInd)%channels(i) ) then
            channel = channel + 1
            channels(channel)%origin = &
              & lbound ( fwdModelConf%signals(sigInd)%frequencies, 1 )
            channels(channel)%used = i + channels(channel)%origin - 1
            channels(channel)%signal = sigInd
            channels(channel)%dacs = FindFirst ( usedDACSSignals, sigind )
            ! Look for channel shape information, but we only need to
            ! do this if we've been asked to perform frequeny averaging
            if ( fwdModelConf%do_freq_avg ) then
              if ( channels(channel)%dacs == 0 ) then
                do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
                  sx = (thisSideband +3) / 2
                  channels(channel)%shapeInds(sx) = MatchSignal ( &
                    & filterShapes%signal, fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channels(channel)%used )
                  if ( channels(channel)%shapeInds(sx) == 0) &
                    & call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &    "No matching channel shape information" )
                end do
              else
                do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
                  sx = (thisSideband +3) / 2
                  channels(channel)%shapeInds(sx) = MatchSignal ( &
                    & DACSFilterShapes%filter%signal, fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channels(channel)%used )
                  if ( channels(channel)%shapeInds(sx) == 0 ) &
                    & call MLSMessage ( MLSMSG_Error, ModuleName, &
                    &    "No matching DACS channel shape information" )
                end do
              end if ! filter bank or DACS
            end if ! Need filter shape information
          end if
        end do
      end do

      if ( fwdModelConf%do_freq_avg ) then
        ! Check again whether we have channel shapes.  We can't just check in
        ! ConstructForwardModelConfig whether frequency averaging was requested
        ! and both FilterShapes and DACSFilterShapes are associated, because if
        ! there are no DACS (or only DACS) then one of them might be harmlessly
        ! disassociated.  To check in ConstructForwardModelConfig, it would be
        ! necessary to determine whether any channels are DACS channels, which
        ! is only done here.
        ier = 0
        do i = 1, channel
          do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
            sx = (thisSideband + 3) / 2
            if ( channels(channel)%shapeInds(sx) == 0 ) ier = 1
          end do
        end do
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
           & "Frequency averaging requested but there is no channel " // &
           & "shape information for some channel" )
      end if

    end subroutine Channel_Stuff

    ! ...............................................  DACS_Stuff  .....
    subroutine DACS_Stuff ( DACsStaging, UsedDACSSignals )

      use FilterShapes_M, only: DACSFilterShapes

      ! Identify which of our signals are DACS and how many unique DACS are involved
      ! Allocate and compute UsedDACSSignals and allocate DACsStaging.

      real(rp), pointer :: DACsStaging(:,:)  ! DACS radiances
      integer, pointer :: UsedDACSSignals(:) ! Indices in FwdModelConf_T%Signals
                                             ! of signals for our dacs

      integer :: I
      integer :: LBoundDACs, UBoundDACs      ! How many channels in a DAC
      integer :: NoUsedDACS
      integer :: SigInd
      logical :: SignalFlag(size(fwdModelConf%signals))

      nullify ( DACsStaging, usedDACSSignals )
      signalFlag = .false.
      lBoundDACs = 0; uBoundDACs = 0
      noUsedDACs = 0
      do sigInd = 1, size(fwdModelConf%signals)
        if ( fwdModelConf%signals(sigInd)%dacs .and. &
          & .not. signalFlag(sigind) ) then
          signalFlag(sigind) = .true.
          noUsedDACs = noUsedDACs + 1
          if ( noUsedDACs == 1 ) then
            lBoundDACs = lbound(fwdModelConf%signals(sigInd)%frequencies,1 )
            uBoundDACs = ubound(fwdModelConf%signals(sigInd)%frequencies,1 )
          else
            if ( lBoundDACs /= lbound ( fwdModelConf%signals(sigInd)%frequencies,1 ) .or. &
              &  uBoundDACs /= ubound ( fwdModelConf%signals(sigInd)%frequencies,1 ) ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Two DACS have different number of channels' )
          end if
        end if
      end do
      if ( noUsedDACs > 0 .and. .not. associated(DACsFilterShapes) ) &
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'DACS in use but no filter shapes provided.' )
      call allocate_test ( usedDACSSignals, noUsedDACs, 'usedDACSSignals', ModuleName )
      usedDACSSignals = pack ( (/ (i, i=1, size(signalFlag)) /), signalFlag )
      call allocate_test ( DACsStaging, uBoundDACs, noUsedDACs, &
        & 'DACsStaging', moduleName, low1 = lBoundDACs )
    end subroutine DACS_Stuff

    ! ................................................  PFA_Stuff  .....
    subroutine PFA_Stuff

      use Allocate_Deallocate, only: Allocate_Test
      use Intrinsic, only: Lit_Indices
      use MLSMessageModule, only: MLSMessage, MLSMsg_Error
      use MLSSignals_M, only: DisplaySignalName
      use Molecules, only: L_CloudIce
      use MoreTree, only: StartErrorMessage
      use PFADatabase_M, only: Test_And_Fetch_PFA
      use Read_Mie_M, only: Beta_C_A, Beta_C_S
      use String_Table, only: Display_String

      integer :: B                    ! Index for beta groups
      integer :: Channel              ! Index in fwdModelConf%channels
      integer :: P                    ! Index for PFA molecules in a beta group
      integer :: SB                   ! Sideband index, -1 .. +1
      integer :: SX                   ! Sideband index, 1 .. 2

      ! Fill fwdModelConf%beta_group%pfa%data

      do sb = s1, s2, 2
        sx = ( sb + 3 ) / 2
        do b = 1, size(fwdModelConf%beta_group)
          call allocate_test ( fwdModelConf%beta_group(b)%pfa(sx)%data, &
            & size(fwdModelConf%channels), &
            & size(fwdModelConf%beta_group(b)%pfa(sx)%molecules), &
            & 'Beta_group(b)%PFA(sx)%data', moduleName, fill=0 )
          do p = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%molecules)
            if ( fwdModelConf%beta_group(b)%pfa(sx)%molecules(p) == l_cloudIce ) then
              if ( .not. allocated(beta_c_a) ) &
                call MLSMessage ( MLSMSG_Error, moduleName, &
                  'No Mie tables for Cloud_A beta' )
              cycle
              if ( .not. allocated(beta_c_s) )  &
                call MLSMessage ( MLSMSG_Error, moduleName, &
                  'No Mie tables for Cloud_S beta' )
              cycle
            end if
            do channel = 1, size(fwdModelConf%channels)
              ! Look up PFA data and read it if necessary
              fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p) = &
                test_and_fetch_PFA(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p), &
                  & fwdModelConf%signalIndices(fwdModelConf%channels(channel)%signal), &
                  & sb, fwdModelConf%channels(channel)%used, fwdModelConf%spect_der)
              if ( fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p) == 0 ) then
                call startErrorMessage ( fwdModelConf%where )
                call display_string ( &
                  & lit_indices(fwdModelConf%beta_group(b)%molecule), &
                  & before=' PFA table not found for ' )
                call displaySignalName ( &
                  & fwdModelConf%signals(fwdModelConf%channels(channel)%signal), &
                  & advance='yes', before=' and ', sideband=sb, &
                  & channel=fwdModelConf%channels(channel)%used )
                error = .true.
              end if
            end do ! channel
          end do ! p
        end do ! b
      end do ! sb

    end subroutine PFA_Stuff

    ! ...............................  SpectroscopyCatalogExtract  .....
    subroutine SpectroscopyCatalogExtract
      use Allocate_Deallocate, only: Allocate_Test, Test_Allocate
      use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
      use Intrinsic, only: Lit_Indices, L_None
      use MLSSignals_M, only: GetRadiometerFromSignal
      use MLSStringLists, only: SwitchDetail
      use MoreTRee, only: StartErrorMessage
      use SpectroscopyCatalog_M, only: Catalog, Empty_Cat, Lines, MostLines
      use String_Table, only: Display_String ! , Get_String
      use Toggles, only: Switches

      integer(c_intptr_t) :: Addr         ! For tracing
      integer :: B         ! Beta_group index
      integer :: C         ! Spectroscopy catalog extract size/index
      logical :: DoThis    ! Flag for lines in catalog item
      integer :: I
      integer :: L         ! Index for lines, or number of lines
      integer, pointer :: LineFlag(:) ! /= 0 => Use this line
      integer :: M         ! Index for beta_group's molecule-size stuff
      integer :: N         ! Molecule index, L_... from Intrinsic
      integer :: NoLinesMsg = -1 ! From switches
      integer, target :: MaxLineFlag(mostLines)
!     character(len=32) :: MoleculeName ! for error message
      integer :: Polarized ! -1 => One of the selected lines is Zeeman split
                           ! +1 => None of the selected lines is Zeeman split
      integer :: S, SX     ! Indices for sidebands
      logical :: SawNoLines ! Saw a species without lines or continuum
      integer :: STAT      ! Status from allocate or deallocate
      integer :: Z         ! Index for fwdModelConf%Signals

      if ( noLinesMsg < 0 ) noLinesMsg = switchDetail(switches, '0sl') ! Done once
      sawNoLines = .false.

      ! Allocate the spectroscopy catalog extract
      c = maxval(fwdModelConf%cat_size)
      allocate ( fwdModelConf%catalog(s1:s2,c), stat=stat )
      addr = 0
      if ( stat == 0 ) then
        if ( size(fwdModelConf%catalog) > 0 ) &
          & addr = transfer(c_loc(fwdModelConf%catalog(s1,1)), addr)
      end if
      call test_allocate ( stat, moduleName, 'fwdModelConf%catalog', &
        & (/s1,1/), (/s2,c/), storage_size(fwdModelConf%catalog) / 8, address=addr )

      ! Work out the spectroscopy we're going to need.
      fwdModelConf%catalog = empty_cat

      do s = s1, s2, 2
        sx = (s + 3) / 2 ! 1 or 2, instead of -1 or 1.
        c = 0
        do b = 1, size(fwdModelConf%beta_group)
          do m = 1, size(fwdModelConf%beta_group(b)%lbl(sx)%molecules)
            c = c + 1
            fwdModelConf%beta_group(b)%lbl(sx)%cat_index(m) = c
            n = fwdModelConf%beta_group(b)%lbl(sx)%molecules(m)
            if ( n > ubound(catalog,1) .or. n < lbound(catalog,1) ) then ! Probably RHi
              call startErrorMessage ( fwdModelConf%where )
              call display_string ( lit_indices(n), &
                & before=' No spectroscopy catalog for ', advance='yes' )
              error = .true.
              cycle
            else if ( catalog(n)%molecule == l_none ) then
              call startErrorMessage ( fwdModelConf%where )
              call display_string ( lit_indices(n), &
                & before=' No spectroscopy catalog for ', advance='yes' )
              error = .true.
              cycle
            end if
            fwdModelConf%catalog(s,c) = catalog(n)
            ! Don't deallocate them by mistake -- fwdModelConf%catalog is a shallow copy
            nullify ( fwdModelConf%catalog(s,c)%lines, fwdModelConf%catalog(s,c)%polarized )
            if ( associated ( catalog(n)%lines ) ) then
              ! Now subset the lines according to the signal we're using
              lineFlag => MaxLineFlag(:size(catalog(n)%lines))
              lineFlag = 0
              if ( fwdModelConf%allLinesInCatalog ) then
                ! NOTE: If allLinesInCatalog is set, then no lines can be polarized;
                ! this is checked for in ForwardModelSupport.
                lineFlag = 1
              else
                do l = 1, size ( catalog(n)%lines )
                  associate ( thisLine => lines(catalog(n)%lines(l)) )
                    if ( associated(thisLine%signals) ) then
                      polarized = 1 ! not polarized
                      ! Work out whether to do this line
                      do z = 1, size(fwdModelConf%signals)
                        if ( fwdModelConf%allLinesForRadiometer ) then
                          doThis = .false.
                          do i = 1, size(thisLine%signals)
                            ! Tried to make GetRadiometerFromSignal elemental, but compile time
                            ! in LF95 (optimized) for Construct.f90 went nuts! :-(
                            if ( GetRadiometerFromSignal ( thisLine%signals(i) ) == &
                              & fwdModelConf%signals(z)%radiometer ) then
                              doThis = .true.
                              if ( .not. fwdModelConf%polarized ) &
                                exit   ! loop over signals for line -- no need to check for
                              ! polarized lines
                              if ( associated(thisLine%polarized) ) then
                                if ( thisLine%polarized(i) ) then
                                  polarized = -1 ! polarized
                                  exit   ! loop over signals for line -- one signal
                                  ! that sees a polarized line is enough to turn on
                                  ! the polarized method
                                end if
                              end if
                            end if
                          end do ! End loop over signals for line
                        else
                          ! Not doing all lines for radiometer, be more selective
                          doThis = any ( &
                            & ( thisLine%signals == fwdModelConf%signals(z)%index ) .and. &
                            & ( ( thisLine%sidebands == 0 ) .or. ( thisLine%sidebands == s ) ) )
                          if ( fwdModelConf%polarized .and. doThis .and. &
                            & associated(thisLine%polarized) ) then
                            if ( any(thisLine%polarized) ) polarized = -1 ! polarized
                          end if
                        end if

                        if ( fwdModelConf%sidebandStart == fwdModelConf%sidebandStop ) &
                          & doThis = doThis .and. &
                          & any( ( thisLine%sidebands == fwdModelConf%sidebandStart ) &
                          & .or. ( thisLine%sidebands == 0 ) )
                        if ( doThis ) then
                          lineFlag(l) = polarized
                          if ( polarized < 0 .or. .not. fwdModelConf%polarized ) &
                            exit   ! loop over signals requested in fwm
                        end if
                      end do ! z End loop over signals requested in fwm
                    end if
                  end associate
                end do     ! l End loop over lines
              end if       ! End case where allLinesInCatalog not set

              ! Check we have at least one line for this specie

              l = count(lineFlag /= 0)
              if ( l == 0 .and. all ( fwdModelConf%catalog(s,c)%continuum == 0.0 ) &
                & .and. noLinesMsg > 0 ) then
                sawNoLines = .true.
                call startErrorMessage ( fwdModelConf%where )
                call display_string ( lit_indices(n), &
                  & before='No relevant lines or continuum for ', advance='yes' )
              end if
              call allocate_test ( fwdModelConf%catalog(s,c)%lines, l, &
                & 'fwdModelConf%catalog(?,?)%lines', moduleName )
              call allocate_test ( fwdModelConf%catalog(s,c)%polarized, l, &
                & 'fwdModelConf%catalog(?,?)%polarized', moduleName )
              fwdModelConf%catalog(s,c)%lines = pack ( catalog(n)%lines, lineFlag /= 0 )
              fwdModelConf%catalog(s,c)%polarized = pack ( lineFlag < 0, lineFlag /= 0 )

            else

              ! No lines for this specie.  However, its continuum may still
              ! be valid so don't set it to empty.
              call allocate_test ( fwdModelConf%catalog(s,c)%lines, 0, &
                & 'fwdModelConf%catalog(?,?)%lines(0)', moduleName )
              call allocate_test ( fwdModelConf%catalog(s,c)%polarized, 0, &
                & 'fwdModelConf%catalog(?,?)%polarized(0)', moduleName )
              if ( all(catalog(n)%continuum == 0.0) .and. noLinesMsg >= 0 ) then
                sawNoLines = .true.
                call startErrorMessage ( fwdModelConf%where )
                call display_string ( lit_indices(n), &
                  & before='No lines or continuum for ', advance='yes' )
!               ! DON'T DO THIS! it catches radiometer-dependent species
!               ! such as O3_R1A that intentionally have no lines or continuum
!                 call get_string ( lit_indices(n), moleculeName )
!                 call MLSMessage ( MLSMSG_Error, moduleName, &
!                   & 'No lines or continuum for ' // trim(moleculeName) )
              end if
            end if
          end do ! m Molecules in fwdModelConf
        end do ! b Beta groups
      end do ! s Sidebands

      if ( sawNoLines .and. noLinesMsg >= 0 ) &
        & call MLSMessage ( MLSMSG_Warning, moduleName, &
        & 'At least one species has no lines or continuum' )

    end subroutine SpectroscopyCatalogExtract

  end subroutine DeriveFromForwardModelConfig

  ! --------------------------  DestroyForwardModelConfigDatabase  -----
  subroutine DestroyFWMConfigDatabase ( Database, Deep )

    use ALLOCATE_DEALLOCATE, only: TEST_DEALLOCATE
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: Database
    logical, optional, intent(in) :: DEEP

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Config                   ! Loop counter
    integer :: S                        ! Size in bytes of object to deallocate
    integer :: Status                   ! Flag

    if ( associated(database) ) then
      do config = 1, size(database)
        call DestroyOneForwardModelConfig ( database(config), deep=deep )
      end do

      s = size(database) * storage_size(database) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(database(1)), addr)
      deallocate ( database, stat=status )
      call test_deallocate ( status, ModuleName, 'Database', s, address=addr )
    end if
  end subroutine DestroyFWMConfigDatabase

  ! ---------------------------------  DestroyForwardModelDerived  -----
  subroutine DestroyForwardModelDerived ( FwdModelConf )
    ! Destroy stuff in FwdModelConf derived for one forward model run

    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    type ( ForwardModelConfig_T ), intent(inout) :: FwdModelConf

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: C, B, Ier, S

    if ( associated(fwdModelConf%channels) ) then
      s = size(fwdModelConf%channels) * storage_size(fwdModelConf%channels) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(fwdModelConf%channels(1)), addr)
      deallocate ( fwdModelConf%channels, stat = ier )
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%channels', s, address=addr )
  ! else
  !   It was already deallocated at the end of FullForwardModel
    end if

    do b = 1, size(fwdModelConf%beta_group)
      do s = 1, 2
        call deallocate_test ( fwdModelConf%beta_group(b)%PFA(s)%data, &
          & 'Beta_group(b)%PFA(s)%data', moduleName )
      end do ! s
    end do ! b

    call deallocate_test ( fwdModelConf%DACSStaging, &
      & 'fwdModelConf%DACSStaging', moduleName )

    call deallocate_test ( fwdModelConf%usedDACSSignals, &
      & 'fwdModelConf%usedDACSSignals', moduleName )

    if ( associated(fwdModelConf%catalog) ) then
      do s = lbound(fwdModelConf%catalog,1), ubound(fwdModelConf%catalog,1), 2
        do c = 1, size(fwdModelConf%catalog,2)
          ! We don't deallocate the signals/sidebands stuff for each line because
          ! they're shallow copies of the main spectroscopy catalog stuff
          call deallocate_test ( fwdModelConf%catalog(s,c)%lines, &
            & 'fwdModelConf%catalog(?,?)%lines', moduleName )
          call deallocate_test ( fwdModelConf%catalog(s,c)%polarized, &
            & 'fwdModelConf%catalog(?,?)%polarized', moduleName )
        end do
      end do

      s = size(fwdModelConf%catalog) * storage_size(fwdModelConf%catalog) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc( &
        & fwdModelConf%catalog(lbound(fwdModelConf%catalog,1),1)), addr)
      deallocate ( fwdModelConf%catalog, stat=ier )
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%catalog', s, address=addr )
  ! else
  !   It was already deallocated at the end of FullForwardModel
    end if

  end subroutine DestroyForwardModelDerived

  ! ------------------------------------ NullifyForwardModelConfig -----
  subroutine NullifyForwardModelConfig ( IntentionallyNotUsed )
    ! Given a forward model config, nullify all the pointers associated with it
    type ( ForwardModelConfig_T ), intent(out) :: IntentionallyNotUsed

    ! Executable code not needed since => NULL() initializes pointer
    ! components of intent(out) dummy arguments.
  end subroutine NullifyForwardModelConfig

  ! --------------------------------------------- PVMPackFwmConfig -----
  subroutine PVMPackFWMConfig ( Config )
    use PVMIDL, only: PVMIDLPack
    use MorePVM, only: PVMPackLitIndex, PVMpackStringIndex
    use MLSSignals_M, only: PVMPackSignal
    use VGridsDatabase, only: PVMPackVGrid
    ! Dummy arguments
    type ( ForwardModelConfig_T ), intent(in) :: Config
    ! Local variables
    integer :: I                        ! Loop counter

    ! Executable code
    ! First pack the lit indices
    call PVMPackStringIndex ( config%name, msg = "Packing fwmConfig name" )
    call PVMPackLitIndex ( config%cloud_der, msg = "Packing fwmConfig cloud_der" )
    call PVMPackLitIndex ( config%fwmType, msg = "Packing fwmConfig fwmType" )
    call PVMPackLitIndex ( config%i_saturation, msg = "Packing fwmConfig i_saturation" )
    call PVMPackLitIndex ( config%instrumentModule, msg = "Packing fwmConfig instrumentModule" )
    call PVMPackLitIndex ( config%windowUnits, msg = "Packing fwmConfig windowUnits" )

    ! Now pack the integer scalars
    call PVMIDLPack ( (/ &
      & config%linearSideband, &
      & config%no_cloud_species, config%no_model_surfs, &
      & config%num_ab_terms, config%num_azimuth_angles, &
      & config%num_scattering_angles, config%num_size_bins, &
      & config%referenceMIF, config%sidebandStart, config%sidebandStop, &
      & config%surfaceTangentIndex /), msg = "Packing fwmConfig integers" )

    ! Now the logical scalars
    call PVMIDLPack ( (/ &
      & config%allLinesForRadiometer, config%allLinesInCatalog, config%anyLBL, &
      & config%anyPFA, config%atmos_der, config%atmos_second_der, config%default_spectroscopy, &
      & config%differentialScan, config%do_1d, config%do_baseline, &
      & config%do_conv, config%do_freq_avg, config%forceFoldedOutput, &
      & config%forceSidebandFraction, config%generateTScat, config%globalConfig, &
      & config%ignoreHessian, config%incl_cld, config%isRadianceModel, &
      & config%lockBins, config%no_magnetic_field, config%polarized, &
      & config%refract, config%scanAverage, config%skipOverlaps, config%spect_Der, &
      & config%switchingMirror, config%temp_Der, config%transformMIFextinction, &
      & config%useTScat /), &
      & msg ="Packing fwmConfig logicals" )

    ! Now pack the reals
    call PVMIDLPack ( (/ config%phiWindow, config%tolerance /), &
      & msg = "Packing fwmConfig reals" )

    ! ------------- The rest are arrays and/or types
    ! Bin selectors
    if ( associated ( config%binSelectors ) ) then
      call PVMIDLPack ( size ( config%binSelectors ), msg = "Packing number of binSelectors" )
      call PVMIDLPack ( config%binSelectors, msg = "Packing binSelectors" )
    else
      call PVMIDLPack ( 0, msg = "Packing 0 binSelectors" )
    end if

    ! Molecules / derivatives
    if ( associated ( config%molecules ) ) then
      call PVMIDLPack ( size ( config%molecules ), msg = "Packing number of molecules" )
      if ( size ( config%molecules ) > 0 ) then
        do i = 1, size(config%molecules) - 1
          call PVMPackLitIndex ( abs ( config%molecules(i) ), &
            & msg = "Packing a molecule" )
          call PVMIDLPack ( (config%molecules(i) > 0.0), msg = "Packing molecule sign" )
        end do
        call PVMIDLPack ( config%moleculeDerivatives, msg = "Packing molecule derivatives" )
        call PVMIDLPack ( config%moleculeSecondDerivatives, msg = "Packing molecule second derivatives" )
      end if
    else
      call PVMIDLPack ( 0, msg = "Packing 0 molecules" )
    end if

    ! Specific quantities
    if ( associated ( config%specificQuantities ) ) then
      call PVMIDLPack ( size ( config%specificQuantities ), &
        & msg = "Packing number of specificQuantities" )
      call PVMIDLPack ( config%specificQuantities, msg = "Packing specificQuantities" )
    else
      call PVMIDLPack ( 0, msg = "Packing 0 specificQuantities" )
    end if

    ! Pack the other structures - signals
    if ( associated ( config%signals ) ) then
      call PVMIDLPack ( size ( config%signals ), msg = "Packing number of signals" )
      do i = 1, size ( config%signals )
        call PVMPackSignal ( config%signals(i) )
      end do
    else
      call PVMIDLPack ( 0, msg = "Packing 0 signals" )
    end if

    ! Vgrids
    call PVMIDLPack ( (/ associated ( config%integrationGrid ), &
      & associated ( config%tangentGrid ) /), msg = "Packing vGrid flags" )
    if ( associated ( config%integrationGrid ) ) &
      & call PVMPackVGrid ( config%integrationGrid )
    if ( associated ( config%tangentGrid ) ) &
      & call PVMPackVGrid ( config%tangentGrid )

  end subroutine PVMPackFWMConfig

  ! ----------------------------------------- PVMUnpackFWMConfig ---------
  subroutine PVMUnpackFWMConfig ( Config )
    use Allocate_Deallocate, only: Allocate_Test, Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use MLSMessageModule, only: MLSMessage, MLSMsg_Error
    use MLSSignals_M, only: PVMUnpackSignal
    use MorePVM, only: PVMUnpackLitIndex, PVMUnpackStringIndex
    use PVMIDL, only: PVMIDLUnpack
    use VGridsDatabase, only: PVMUnpackVGrid
    ! Dummy arguments
    type ( ForwardModelConfig_T ), intent(out) :: Config
    ! Local variables
    integer, parameter     :: ISMax = 11 ! Number of integers to unpack
    integer, parameter     :: LSMax = 32 ! Number of logicals to unpack
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: INFO                     ! Flag from PVM
    logical :: FLAG                     ! A flag from the sender
    integer, dimension(ISMax) :: IS     ! Temporary array, for integer scalars
    logical, dimension(LSMax) :: LS     ! Temporary array, for logical scalars
    real(r8), dimension(3) :: RS        ! Temporary array, for reals
    integer :: I                        ! Loop counter
    integer :: N                        ! Array size

    ! Executable code
    ! First unpack the lit indices
    call PVMUnpackStringIndex ( config%name, msg = "Unpacking fwmConfig name" )
    call PVMUnpackLitIndex ( config%cloud_der, msg = "Unpacking fwmConfig cloud_der" )
    call PVMUnpackLitIndex ( config%fwmType, msg = "Unpacking fwmConfig fwmType" )
    call PVMUnpackLitIndex ( config%i_saturation, msg = "Unpacking fwmConfig i_saturation" )
    call PVMUnpackLitIndex ( config%instrumentModule, &
      msg = "Unpacking fwmConfig instrumentModule" )
    call PVMUnpackLitIndex ( config%windowUnits, msg = "Unpacking fwmConfig windowUnits" )

    ! Now the integer scalars. Array IS has to be long enough for this.
    ! If you add any items here, don't forget to make IS longer at the top
    ! of the program unit.
    call PVMIDLUnpack ( is, msg = "Unpacking fwmConfig integers" )
    i = 1
    config%linearsideband         = is(i) ; i = i + 1
    config%no_cloud_species       = is(i) ; i = i + 1
    config%no_model_surfs         = is(i) ; i = i + 1
    config%num_ab_terms           = is(i) ; i = i + 1
    config%num_azimuth_angles     = is(i) ; i = i + 1
    config%num_scattering_angles  = is(i) ; i = i + 1
    config%num_size_bins          = is(i) ; i = i + 1
    config%referenceMIF           = is(i) ; i = i + 1
    config%sideBandStart          = is(i) ; i = i + 1
    config%sideBandStop           = is(i) ; i = i + 1
    config%surfaceTangentIndex    = is(i) !  ; i = i + 1
    if ( i > LSMAX ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName // 'PVMUnpackFWMConfig', &
      & 'programming error--ISMAX too small' )

    ! Now the logical scalars. Array LS has to be long enough for this.
    ! If you add any items here, don't forget to make LS longer at the top
    ! of the program unit.
    call PVMIDLUnpack ( ls, msg = "Unpacking fwmConfig logicals" )
    i = 1
    config%allLinesForRadiometer  = ls(i) ; i = i + 1
    config%allLinesInCatalog      = ls(i) ; i = i + 1
    config%anyLBL                 = ls(i:i+1) ; i = i + 2
    config%anyPFA                 = ls(i:i+1) ; i = i + 2
    config%atmos_der              = ls(i) ; i = i + 1
    config%atmos_second_der       = ls(i) ; i = i + 1
    config%default_spectroscopy   = ls(i) ; i = i + 1
    config%differentialScan       = ls(i) ; i = i + 1
    config%do_1d                  = ls(i) ; i = i + 1
    config%do_baseline            = ls(i) ; i = i + 1
    config%do_conv                = ls(i) ; i = i + 1
    config%do_freq_avg            = ls(i) ; i = i + 1
    config%forceFoldedOutput      = ls(i) ; i = i + 1
    config%forceSidebandFraction  = ls(i) ; i = i + 1
    config%globalConfig           = ls(i) ; i = i + 1
    config%generateTScat          = ls(i) ; i = i + 1
    config%ignoreHessian          = ls(i) ; i = i + 1
    config%incl_cld               = ls(i) ; i = i + 1
    config%isRadianceModel        = ls(i) ; i = i + 1
    config%lockBins               = ls(i) ; i = i + 1
    config%no_magnetic_field      = ls(i) ; i = i + 1
    config%polarized              = ls(i) ; i = i + 1
    config%refract                = ls(i) ; i = i + 1
    config%scanAverage            = ls(i) ; i = i + 1
    config%skipOverlaps           = ls(i) ; i = i + 1
    config%spect_der              = ls(i) ; i = i + 1
    config%switchingMirror        = ls(i) ; i = i + 1
    config%temp_der               = ls(i) ; i = i + 1
    config%transformMIFextinction = ls(i) ; i = i + 1
    config%useTScat               = ls(i) !  ; i = i + 1
    if ( i > LSMAX ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName // 'PVMUnpackFWMConfig', &
      & 'programming error--LSMAX too small' )

    ! Now the real scalars
    call PVMIDLUnpack ( rs, msg = "Unpacking fwmConfig reals" )
    i = 1
    config%phiWindow(1) = rs(i) ; i = i + 1
    config%phiWindow(2) = rs(i) ; i = i + 1
    config%tolerance = rs(i) ; i = i + 1

    ! ------- The rest are arrays and/or types
    ! Bin selectors
    call PVMIDLUnpack ( n, msg = "Unpacking number of specific quantities" )
    if ( n > 0 ) then
      call Allocate_test ( config%binSelectors, n, &
        & 'config%binSelectors', ModuleName )
      call PVMIDLUnpack ( config%binSelectors, msg = "Unpacking binSelectors" )
    end if

    ! Molecules / derivatives
    call PVMIDLUnpack ( n, msg = "Unpacking number of molecules" )
    if ( n > 0 ) then
      call Allocate_test ( config%molecules, n, 'config%molecules', ModuleName )
      call Allocate_test ( config%moleculeDerivatives, &
        & n, 'config%moleculeDerivatives', ModuleName )
      call Allocate_test ( config%moleculeSecondDerivatives, &
        & n, 'config%moleculeSecondDerivatives', ModuleName )
      do i = 1, n - 1
        call PVMUnpackLitIndex ( config%molecules(i), msg = "Unpacking a molecule" )
        call PVMIDLUnpack ( flag, msg = "Unpacking a molecule sign flag" )
        if ( .not. flag ) config%molecules(i) = - config%molecules(i)
      end do
      config%molecules(n) = huge(config%molecules(n)) ! Sentinel
      call PVMIDLUnpack ( config%moleculeDerivatives, msg = "Unpacking moleculeDerivatives" )
      call PVMIDLUnpack ( config%moleculeSecondDerivatives, msg = "Unpacking moleculeSecondDerivatives" )
    end if

    ! Specific quantities
    call PVMIDLUnpack ( n, msg = "Unpacking number of specific quantities" )
    if ( n > 0 ) then
      call Allocate_test ( config%specificQuantities, n, &
        & 'config%specificQuantities', ModuleName )
      call PVMIDLUnpack ( config%specificQuantities, msg = "Unpacking specific quantities" )
    end if

    ! Unpack other structures - signals
    call PVMIDLUnpack ( n, msg = "Unpacking number of signals" )
    if ( n > 0 ) then
      allocate ( config%signals(n), STAT=info )
      addr = 0
      if ( info == 0 ) addr = transfer(c_loc(config%signals(1)), addr)
      call test_allocate ( info, ModuleName, 'config%signals', ubounds = [n], &
        & elementSize = storage_size(config%signals) / 8, address=addr )
      do i = 1, n
        call PVMUnpackSignal ( config%signals(i) )
      end do
    end if

    ! Vgrids
    call PVMIDLUnpack ( ls(1:2), msg = "Unpacking vGrid flags" )
    if ( ls(1) ) then
      allocate ( config%integrationGrid, STAT=info )
      addr = 0
      if ( info == 0 ) addr = transfer(c_loc(config%integrationGrid), addr)
      call test_allocate ( info, ModuleName, 'config%integrationGrid', &
        & uBounds = [1], elementSize = storage_size(config%integrationGrid) / 8, &
        & address=addr )
      call PVMUnpackVGrid ( config%integrationGrid )
    end if
    if ( ls(2) ) then
      allocate ( config%tangentGrid, STAT=info )
      addr = 0
      if ( info == 0 ) addr = transfer(c_loc(config%tangentGrid), addr)
      call test_allocate ( info, ModuleName, 'config%tangentGrid', &
        & uBounds = [1], elementSize = storage_size(config%tangentGrid) / 8, &
        & address=addr )
      call PVMUnpackVGrid ( config%tangentGrid )
    end if

  end subroutine PVMUnpackFWMConfig

  ! --------------------------  StripForwardModelConfigDatabase --------
  subroutine StripForwardModelConfigDatabase ( Database )
    ! This routine removes the non-global forward model configs from the database
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: Database

    ! Local variables
    type (ForwardModelConfig_T), dimension(:), pointer :: TmpDatabase
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Config                   ! Loop counter
    integer :: N
    integer :: Status

    ! Executable code
    ! Clear out dying configs
    if ( .not. associated ( database ) ) return
    do config = 1, size ( database )
      if ( .not. database(config)%globalConfig ) &
        & call DestroyOneForwardModelConfig ( database(config) )
    end do

    ! Create new database in tmp space, pack old one into
    n = count ( database%globalConfig )
    allocate ( tmpDatabase ( n ), STAT=status )
    addr = 0
    if ( status == 0 .and. n > 0 ) addr = transfer(c_loc(tmpDatabase(1)), addr)
    call test_allocate ( status, ModuleName, 'tmpDatabase', &
      & uBounds = [n], elementSize = storage_size(tmpDatabase) / 8, address=addr )
    tmpDatabase = pack ( database, database%globalConfig )

    ! Destroy old database, then point to new one
    n = size(database) * storage_size(database) / 8
    addr = 0
    if ( n > 0 ) addr = transfer(c_loc(database(1)), addr)
    deallocate ( database, STAT=status )
    call test_deallocate ( status, ModuleName, 'database', n, address=addr )

    database => tmpDatabase
  end subroutine StripForwardModelConfigDatabase

  ! =====     Private Procedures     =====================================

  ! ------------------------------------ DestroyOneForwardModelConfig --
  subroutine DestroyOneForwardModelConfig ( Config, Deep )
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use MLSSignals_M, only: DestroySignalDatabase

    ! Dummy arguments
    type ( ForwardModelConfig_T), intent(inout) :: config
    logical, optional, intent(in) :: Deep ! Do a really deep destroy

    ! Local variables
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: B                        ! Subscript for Beta_Group
    integer :: S                        ! 1 = LSB, 2 = USB, or
                                        ! size in bytes of an object to deallocate
    integer :: Status                   ! Flag from allocate etc.
    logical :: MyDeep                   ! Copy of deep

    ! Executable code
    myDeep = .false.
    if ( present ( deep ) ) myDeep = deep
    call destroyForwardModelDerived ( config )
    ! Destroy the beta groups
    do b = 1, size(config%beta_group)
      do s = 1, 2
        call deallocate_test ( config%beta_group(b)%LBL(s)%cat_index, 'Cat_Index', moduleName )
        call deallocate_test ( config%beta_group(b)%LBL(s)%molecules, 'LBL Molecules', moduleName )
        call deallocate_test ( config%beta_group(b)%LBL(s)%ratio, 'LBL Ratio', moduleName )
        call deallocate_test ( config%beta_group(b)%PFA(s)%molecules, 'PFA molecules', moduleName )
        call deallocate_test ( config%beta_group(b)%PFA(s)%ratio, 'PFA ratio', moduleName )
      end do ! s
    end do ! b = 1, size(config%beta_group)

    if ( associated(config%lineCenter) ) then
      s = size(config%lineCenter) * storage_size(config%lineCenter) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(config%lineCenter(1)), addr)
      deallocate ( config%lineCenter, stat=status )
      call test_deallocate ( status, moduleName, 'LineCenter', s, address=addr )
    end if
    if ( associated(config%lineWidth) ) then
      s = size(config%lineWidth) * storage_size(config%lineWidth) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(config%lineWidth(1)), addr)
      deallocate ( config%lineWidth, stat=status )
      call test_deallocate ( status, moduleName, 'LineWidth', s, address=addr )
    end if
    if ( associated(config%lineWidth_TDep) ) then
      s = size(config%lineWidth_TDep) * storage_size(config%lineWidth_TDep) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(config%lineWidth_TDep(1)), addr)
      deallocate ( config%lineWidth_TDep, stat=status )
      call test_deallocate ( status, moduleName, 'LineWidth_TDep', s, address=addr )
    end if

    if ( associated(config%beta_group) ) then
      s = size(config%beta_group) * storage_size(config%beta_group) / 8
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(config%beta_group(1)), addr)
      deallocate ( config%beta_group, stat=status )
      call test_deallocate ( status, moduleName, 'config%Beta_group', s, address=addr )
    end if

    if ( associated(config%signals) ) &
      & call DestroySignalDatabase ( config%signals, justChannels=.not. myDeep )
    call deallocate_test ( config%signalIndices, 'SignalIndices', moduleName )
    if ( myDeep ) then
      if ( associated ( config%integrationGrid ) ) then
        call DestroyVGridContents ( config%integrationGrid )
        s = storage_size(config%integrationGrid) / 8
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(config%integrationGrid), addr)
        deallocate ( config%integrationGrid, stat=status )
        call test_deallocate ( status, moduleName, 'Config%integrationGrid', s, &
          & address=addr )
      end if
      if ( associated ( config%tangentGrid ) ) then
        call DestroyVGridContents ( config%tangentGrid )
        s = storage_size(config%tangentGrid) / 8
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(config%tangentGrid), addr)
        deallocate ( config%tangentGrid, stat=status )
        call test_deallocate ( status, moduleName, 'Config%tangentGrid', s, &
          & address=addr )
      end if
    end if
    ! Otherwise don't destroy integrationGrid and tangentGrid.  Assume they
    ! will be (or already are) destroyed by destroyVGridDatabase.
    ! Don't deallocate config%molecules because it's a pointer into beta_group
    call deallocate_test ( config%specificQuantities, &
      & "config%specificQuantities", ModuleName )
    call deallocate_test ( config%binSelectors, &
      & "config%binSelectors", ModuleName )
  end subroutine DestroyOneForwardModelConfig

  ! --------------------------------------------  Dump_Beta_Group  -----
  subroutine Dump_Beta_Group ( Beta_Group, Name, Sidebands, Details )

    use Dump_0, only: Dump
    use Intrinsic, only: Lit_Indices
    use Output_M, only: Blanks, NewLine, Output
    use PFADatabase_M, only: Dump, PFAData
    use String_Table, only: Display_String

    type(beta_group_t), intent(in) :: Beta_Group(:)
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Sidebands(2)
    integer, intent(in), optional :: Details ! for Dump_PFADatum (default 0)

    integer :: B, C, M, S, S1, S2
    logical :: Missing ! PFA data
    integer :: MyDetails
    character(3), parameter :: SB(2) = (/ 'Low', 'Upp' /)
    character(*), parameter :: ParamNames(lineCenter:lineWidth_tDep) = &
      & (/ ' LineCenter=    ', &
      &    ' LineWidth=     ', &
      &    ' LineWidth_tDep=' /)

    s1 = 1; s2 = 2
    if ( present(sidebands) ) then
      s1 = (sidebands(1)+3)/2
      s2 = (sidebands(2)+3)/2
    end if
    myDetails = 0
    if ( present(details) ) myDetails = details
    call output ( '  Beta groups' )
    if ( present(name) ) call output ( ' ' // trim(name) )
    call output ( size(beta_group), before=', SIZE = ', advance='yes' )
    do b = 1, size(beta_group)
      call output ( b, before='  Beta group ', after=': ' )
      call display_string ( lit_indices(beta_group(b)%molecule) )
      if ( beta_group(b)%derivatives ) call output ( ' with derivative' )
      if ( beta_group(b)%secondDerivatives ) call output ( ' with second derivative' )
      call newLine
      do s = s1, s2
        call output ( '  ' // sb(s) // 'er sideband:', advance='yes' )
        if ( size(beta_group(b)%lbl(s)%molecules) > 0 ) then
          call display_string ( &
            & lit_indices(beta_group(b)%lbl(s)%molecules), before='   LBL:', &
            & advance='yes' )
          call dump ( beta_group(b)%lbl(s)%ratio, name='    Isotope ratio' )
          call dump ( beta_group(b)%lbl(s)%cat_index, &
            & name='    Spectroscopy catalog extract index' )
          if ( any(beta_group(b)%lbl(s)%spect_der_ix /= 0) ) then
            call output ( '    Spectrosopy parameter derivatives:' )
            do m = lineCenter, lineWidth_tDep
              if ( beta_group(b)%lbl(s)%spect_der_ix(m) /= 0 ) &
                & call output ( beta_group(b)%lbl(s)%spect_der_ix(m), &
                  & before=trim(paramNames(m)) )
            end do
            call newLine
          end if
        end if
        if ( size(beta_group(b)%pfa(s)%molecules) > 0 ) then
          call display_string ( &
            & lit_indices(beta_group(b)%pfa(s)%molecules), before='   PFA:', &
            & advance='yes' )
          call dump ( beta_group(b)%pfa(s)%ratio, name='    Isotope ratio' )
          if ( associated(beta_group(b)%pfa(s)%data) ) then
            do m = 1, size(beta_group(b)%pfa(s)%data,2)
              missing = .false.
              do c = 1, size(beta_group(b)%pfa(s)%data,1)
                if ( beta_group(b)%pfa(s)%data(c,m) /= 0 ) then
                  call blanks ( 4 )
                  call dump ( PFAData(beta_group(b)%pfa(s)%data(c,m)), details=myDetails )
                else
                  missing = .true.
                end if
              end do ! c
              if ( missing ) call display_string ( &
                & lit_indices(beta_group(b)%pfa(s)%molecules(m)), &
                & before='    Some PFA data missing for ', advance='yes' )
            end do ! m
          end if
        end if
      end do ! s
      call Dump_Qty_Stuff ( beta_group(b)%qty )
    end do
  end subroutine Dump_Beta_Group

  ! ----------------------------  Dump_ForwardModelConfigDatabase  -----
  subroutine Dump_ForwardModelConfigDatabase ( Database, &
    & Where, Details, SkipPFA, QuantityTemplatesDB )

    use MoreTree, only: StartErrorMessage
    use Output_M, only: Output
    use QuantityTemplates, only: QuantityTemplate_T

    type (forwardModelConfig_T), pointer, dimension(:) :: Database
    integer, optional, intent(in) :: Where ! Tree node index
    integer, intent(in), optional :: Details ! for Dump_Beta_Group
    logical, optional, intent(in) :: SkipPFA
    type (quantityTemplate_t), pointer, optional, dimension(:) :: QuantityTemplatesDB

    ! Local variables
    integer :: I                         ! Loop counters

    ! executable code
    if ( associated(database) ) then
      do i = 1, size(database)
        call Dump_ForwardModelConfig( database(i), details=details, &
          & skipPFA=skipPFA, quantityTemplatesDB=quantityTemplatesDB )
      end do
    else
      if ( present(where) ) call startErrorMessage ( where )
      call output ( 'No forward model database to dump.', advance='yes' )
    end if
  end subroutine Dump_ForwardModelConfigDatabase

  ! -----------------------------------  Dump_ForwardModelConfig  -----
  subroutine Dump_ForwardModelConfig ( Config, Where, &
    & Details, SkipPFA, QuantityTemplatesDB )

    use Dump_0, only: Dump
    use Intrinsic, only: Lit_Indices, PHYQ_Indices
    use Lexer_Core, only: Print_Source
    use MLSSignals_M, only: GetNameOfSignal, MaxSigLen, Modules
    use Output_M, only: NewLine, Output
    use QuantityTemplates, only: QuantityTemplate_T
    use String_Table, only: Display_String
    use Tree, only: Null_Tree, Where_At => Where

    type (forwardModelConfig_T), intent(in) :: Config
    character(len=*), intent(in), optional :: Where
    integer, intent(in), optional :: Details ! for Dump_Beta_Group
    logical, optional, intent(in) :: SkipPFA
    type (quantityTemplate_t), pointer, optional, dimension(:) :: QuantityTemplatesDB

    ! Local variables
    logical :: dumpPFA
    integer :: J, S                          ! Loop counters
    integer :: MyDetails
    integer :: S1, S2                        ! Sideband limits
    character (len=MaxSigLen) :: SignalName  ! A line of text

    ! executable code
    dumpPFA = .true.
    if ( present(skipPFA) ) dumpPFA = .not. skipPFA
    myDetails = 0
    if ( present(details) ) myDetails = details

    s1 = (config%sidebandStart+3)/2; s2 = (config%sidebandStop+3)/2
    call display_string ( config%name, before='  Forward Model Config Name: ' )
    if ( config%where /= null_tree ) then
      call output ( ' defined at ' )
      call print_source ( where_at(config%where) )
    end if
    if ( present(where) ) then
      call output ( ' from ' )
      call output ( where )
    end if
    call newLine
    if ( myDetails < 0 ) return
    ! Logical scalars
    call output ( config%allLinesForRadiometer, before='  AllLinesForRadiometer: ', advance='yes' )
    call output ( config%allLinesInCatalog, before='  AllLinesInCatalog: ', advance='yes' )
    call output ( config%anyLBL(1), before='  AnyLBL: ' )
    call output ( config%anyLBL(2) )
    call output ( config%anyPFA(1), before='  AnyPFA: ' )
    call output ( config%anyPFA(2), advance='yes' )
    call output ( config%atmos_der, before='  Atmos_der: ', advance='yes' )
    call output ( config%atmos_second_der, before='  Atmos_second_der: ', advance='yes' )
    call output ( config%default_spectroscopy, before='  Default_spectroscopy: ', advance='yes' )
    call output ( config%DifferentialScan, before='  DifferentialScan: ', advance='yes' )
    call output ( config%do_1d, before='  Do_1D: ', advance='yes' )
    call output ( config%do_Baseline, before='  Do_Baseline: ', advance='yes' )
    call output ( config%do_conv, before='  Do_conv: ', advance='yes' )
    call output ( config%do_freq_avg, before='  Do_freq_avg: ', advance='yes' )
    call output ( config%do_path_norm, before='  Do_path_norm: ', advance='yes' )
    call output ( config%forceFoldedOutput, before='  ForceFoldedOutput: ', advance='yes' )
    call output ( config%forceSidebandFraction, before='  ForceSidebandFraction: ', advance='yes' )
    call output ( config%globalConfig, before='  GlobalConfig: ', advance='yes' )
    call output ( config%incl_cld, before='  Incl_Cld: ', advance='yes' )
    call output ( config%lockBins, before='  LockBins: ', advance='yes' )
    call output ( config%no_magnetic_field, before='  No_Magnetic_Field: ', advance='yes' )
    call output ( config%polarized, before='  Polarized: ', advance='yes' )
    call output ( config%refract, before='  Refract: ', advance='yes' )
    call output ( config%scanAverage, before='  ScanAverage: ', advance='yes' )
    call output ( config%skipOverlaps, before='  SkipOverlaps: ',advance='yes' )
    call output ( config%spect_der, before='  Spect_der: ', advance='yes' )
    call output ( config%switchingMirror, before='  SwitchingMirror: ', advance='yes' )
    call output ( config%temp_der, before='  Temp_der: ', advance='yes' )
    call output ( config%transformMIFextinction, before='  TransformMIFextinction: ', advance='yes' )
    ! Strings
    call display_string ( lit_indices(config%cloud_der), before='  Cloud_der: ', advance='yes' )
    call display_string ( lit_indices(config%fwmType), before='  FwmType: ', advance='yes' )
    call display_string ( lit_indices(config%i_saturation), before='  I_saturation: ', advance='yes' )
    call output ( config%instrumentModule, before='  InstrumentModule: ' )
    if ( config%instrumentModule /= 0 ) &
      & call display_string ( modules(config%instrumentModule)%name, &
        & before=' - ' )
    call newline
    call display_string ( lit_indices(config%MIFTangent), before=' MIFTangent: ', advance='yes' )
    ! Integer scalars
    call output ( config%LinearSideband, before='  LinearSideband: ', advance='yes' )
    call output ( config%No_cloud_species, before='  No_cloud_species: ', advance='yes' )
    call output ( config%No_model_surfs, before='  No_model_surfs: ', advance='yes' )
    call output ( config%NoUsedChannels, before='  NoUsedChannels: ', advance='yes' )
    call output ( config%Num_ab_terms, before='  Num_ab_terms: ', advance='yes' )
    call output ( config%Num_azimuth_angles, before='  Num_azimuth_angles: ', advance='yes' )
    call output ( config%Num_scattering_angles, before='  Num_scattering_angles: ', advance='yes' )
    call output ( config%Num_size_bins, before='  Num_size_bins: ', advance='yes' )
    call output ( config%ReferenceMIF, before='  ReferenceMIF: ', advance='yes' )
    call output ( config%sidebandStart, before='  Sidebands: ' )
    call output ( config%sidebandStop, before=' ', advance='yes' )
    call output ( config%SurfaceTangentIndex, before='  SurfaceTangentIndex: ', advance='yes' )
    call output ( config%TScatMIF, before='  TScatMIF: ', advance='yes' )
    call output ( config%xStar, before='  xStar: ', advance='yes' )
    call output ( config%yStar, before='  yStar: ', advance='yes' )
    ! Integer arrays
    if ( associated(config%specificQuantities) ) then
      if ( present(quantityTemplatesDB) ) then
        call output ( '  Specific quantities:', advance='yes' )
        do j = 1, size(config%specificQuantities)
          call display_string ( quantityTemplatesDB(config%specificQuantities(j))%name, &
            before='    ', advance='yes' )
        end do
      else
        call dump ( config%specificQuantities, name='  SpecificQuantities' )
      end if
    end if
    ! Real scalars
    call output ( config%PhiWindow(1), before='  PhiWindow: ' )
    call output ( config%PhiWindow(2), before=' ' )
    call display_string ( phyq_indices(config%windowUnits), before=' ', advance='yes' )
    call output ( config%Tolerance, before='  Tolerance: ', advance='yes' )
    ! Bin selectors
    if ( associated ( config%binSelectors ) ) &
      & call dump ( config%binSelectors, name=  '  BinSelectors: ' )

    if ( associated(config%Beta_group) .and. dumpPFA ) &
      & call dump ( config%Beta_group, &
        & sidebands=(/config%sidebandStart,config%sidebandStop/), details=details )
    call output ( '  Molecules: ', advance='yes' )
    if ( associated(config%molecules) ) then
      do j = 1, size(config%molecules)
        call display_string ( lit_indices(config%molecules(j)), before='    ' )
        call output ( j, before=':' )

        if (config%moleculeDerivatives(j)) then
          call output (' compute derivatives' )
        else
          call output (' no derivatives' )
        end if

        if (config%moleculeSecondDerivatives(j)) then
          call output (' compute second derivatives' )
        else
          call output (' no second derivatives' )
        end if  

        call newline

      end do
    end if
    if ( size(config%lineCenter) > 0 .or. size(config%lineWidth) > 0 .or. &
      &  size(config%lineWidth_Tdep) > 0 ) then
      call output ( '  Spectroscopy parameters:', advance='yes')
      if ( size(config%lineCenter) > 0 ) &
        & call display_string ( lit_indices(config%lineCenter%molecule), &
          & advance='yes', before='    Line centers:' )
      if ( size(config%lineWidth) > 0 ) &
        & call display_string ( lit_indices(config%lineWidth%molecule), &
          & advance='yes', before='    Line widths:' )
      if ( size(config%lineWidth_Tdep) > 0 ) &
        & call display_string ( lit_indices(config%lineWidth%molecule), &
          & advance='yes', before='    Line width temperature dependencies:' )
    end if
    call output ( '  Signals:', advance='yes')
    if ( associated(config%signals) ) then
      do j = 1, size(config%signals)
        if ( config%signals(j)%index < 0 ) then
          call output ( j, before='unable to parse signal ', advance='yes' )
        else
          call getNameOfSignal ( config%signals(j), signalName)
          call output ( '  '//trim(signalName)//' channels Included:' )
          if ( associated(config%signals(j)%channels) ) then
            call newLine
            call dump ( config%signals(j)%channels )
          else
            call output ( ' None', advance='yes' )
          end if
        end if
      end do
    else
      call output ( '  (none associated yet)', advance='yes')
    endif
    ! Dump ForwardModelDerived
    call output ( '  ForwardModelDerived:', advance='yes' )
    if ( associated(config%usedDACSSignals) ) &
      call dump  ( config%usedDACSSignals, name='   Used DACS Signals' )
    if ( associated(config%channels) ) then
      call output ( '   Channel info:', advance='yes' )
      do j = 1, size(config%channels)
        call output ( config%channels(j)%used, before='    Used: ' )
        call output ( config%channels(j)%origin, before='    Origin: ' )
        call output ( config%channels(j)%signal, before='    Signal: ' )
        call output ( config%channels(j)%DACS, before='    DACS: ' )
        call output ( '    Shape Inds:' )
        do s = s1, s2
          call output ( config%channels(j)%shapeInds(s), before=' ' )
        end do
        call newLine
      end do ! j = 1, size(config%channels)
    end if
    if ( associated(config%IntegrationGrid) ) then
      call dump ( config%IntegrationGrid, details=details, what='Integration grid' )
    else
      call output ( '  no IntegrationGrid', advance='yes' )
    end if
    if ( associated(config%tangentGrid) ) then
      call dump ( config%tangentGrid, details=details, what='Tangent grid' )
    else
      call output ( '  no tangentGrid', advance='yes' )
    end if
    if ( associated(config%beta_Group) .and. .not. dumpPFA ) &
      & call dump ( config%beta_Group, &
        & sidebands=(/config%sidebandStart,config%sidebandStop/), &
        & details=details, name='Beta group' )
    if ( .not. associated(config%beta_Group) ) &
      & call output ( ' no Beta group (surprised?)', advance='yes' )
  end subroutine Dump_ForwardModelConfig

  ! ---------------------------------------------  Dump_Qty_Stuff  -----
  subroutine Dump_Qty_Stuff ( Qty, Details )
    use HighOutput, only: OutputNamedValue
    use Output_M, only: NewLine, Output
    use VectorsModule, only: Dump
    type(QtyStuff_t), intent(in) :: Qty
    integer, optional, intent(in) :: Details
    if ( associated(qty%qty) ) then
      call dump ( qty%qty, details=details )
    else
      call output( '  Quantity not assocated for this qtyStuff type', advance='yes' )
    endif
    call outputNamedValue ( '  Found in first', qty%foundInFirst )
    call outputNamedValue ( '  Was Specific', qty%wasSpecific )
    call newLine
  end subroutine Dump_Qty_Stuff

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: ForwardModelConfig.f90,v 2.144 2019/04/24 19:17:24 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module ForwardModelConfig

! $Log: ForwardModelConfig.f90,v $
! Revision 2.144  2019/04/24 19:17:24  vsnyder
! Add MIFTangent field to forwardModel
!
! Revision 2.143  2018/08/06 19:58:24  vsnyder
! Use ASSOCIATE construct to avoid necessity for Lines database to have the
! TARGET attribute.  Some cannonball polishing.
!
! Revision 2.142  2018/05/15 03:26:25  vsnyder
! Change Mie tables from pointer to allocatable
!
! Revision 2.141  2018/04/11 22:25:23  vsnyder
! Remove USE for unused names
!
! Revision 2.140  2017/09/20 01:07:57  vsnyder
! Add check that filter shapes are provided if frequency averaging is
! selected.
!
! Revision 2.139  2017/09/15 15:45:18  livesey
! Modified to allow omission of filter shapes file under appropriate circumstances
!
! Revision 2.138  2017/08/17 16:29:54  livesey
! Allowed there to be a missing filter shapes file if frequency
! averaging is not being called for
!
! Revision 2.137  2017/02/04 02:17:40  vsnyder
! Undo all-caps switch in USE statements and some declarations.  Add Values1,
! Values (rank 2) and Values3 pointers to QtyStuff_t, but they're not used
! yet, and might never be used.
!
! Revision 2.136  2016/05/02 23:31:50  vsnyder
! Add QtyStuff component for temperature
!
! Revision 2.135  2015/08/25 17:21:47  vsnyder
! PhiWindow is a tuple, with the first element specifying the angles or
! number of profiles/MAFs before the tangent point, and the second
! specifying the angles or number after.
!
! Revision 2.134  2015/03/28 01:59:22  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.133  2014/09/29 20:25:58  vsnyder
! Add No_Magnetic_Field to config
!
! Revision 2.132  2014/09/05 20:48:44  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.131  2014/08/01 01:01:55  vsnyder
! Change noLinesMsg level from 1 to zero
!
! Revision 2.130  2014/01/09 00:26:39  pwagner
! Some procedures formerly in output_m now got from highOutput
!
! Revision 2.129  2013/09/24 23:28:17  vsnyder
! Use Where instead of Source_Ref for messages
!
! Revision 2.128  2013/08/16 02:32:14  vsnyder
! Remove ModelPlaneMIF
!
! Revision 2.127  2013/08/12 23:48:08  pwagner
! FindSomethings moved to MLSFinds module
!
! Revision 2.126  2013/08/09 01:02:58  vsnyder
! Add ReferenceMIF component
!
! Revision 2.125  2013/08/08 02:34:54  vsnyder
! Add derivOK component to Qty_Stuff
!
! Revision 2.124  2013/07/25 00:22:09  vsnyder
! Replace TransformRHI with TransformMIFRHI
!
! Revision 2.123  2013/07/19 01:18:45  vsnyder
! Add TransformRHI component
!
! Revision 2.122  2013/07/13 00:07:28  vsnyder
! Add Model_Plane_MIF component
!
! Revision 2.121  2013/05/15 03:08:55  vsnyder
! Revise processing of dump switch
!
! Revision 2.120  2013/03/30 00:11:39  vsnyder
! Add Quantity database to dump, dump more stuff in config, add wasSpecific
! to QtyStuff_t.
!
! Revision 2.119  2013/03/20 22:46:42  vsnyder
! Give default value to QtyStuff_t%foundInFirst
!
! Revision 2.118  2013/03/01 01:08:11  pwagner
! Snip all but name of dumped config if details < 0
!
! Revision 2.117  2012/05/01 22:18:50  vsnyder
! Add IsRadianceModel component
!
! Revision 2.116  2012/03/07 00:45:28  vsnyder
! Add TransformMIFExtinction component
!
! Revision 2.115  2012/01/25 00:07:07  vsnyder
! Use Test_Allocate, Test_Deallocate
!
! Revision 2.114  2011/07/29 01:51:38  vsnyder
! Remove TScatMolecules and TScatMoleculeDerivatives fields.  Make CloudIce
! a molecule.  Look for CloudIce instead of Cloud_A and Cloud_S
!
! Revision 2.113  2011/05/09 17:45:38  pwagner
! Converted to using switchDetail
!
! Revision 2.112  2011/03/31 19:50:29  vsnyder
! Don't dump beta group twice
!
! Revision 2.111  2010/12/06 19:15:42  pwagner
! More detailed dump of config to aid debugging
!
! Revision 2.110  2010/09/25 01:08:39  vsnyder
! Cannonball polishing
!
! Revision 2.109  2010/08/27 06:13:37  yanovsky
! Add atmos_second_der, MoleculeSecondDerivatives.
! Add SecondDerivatives component to Beta_Group_T.
!
! Revision 2.108  2010/06/09 16:33:59  pwagner
! Complain if IS, LS array bounds exceeded
!
! Revision 2.107  2010/06/07 23:20:51  vsnyder
! Add UseTScat, TScatMolecules, TScatMoleculeDerivatives, change name
! of PhaseFrqTol to FrqTol, check that Mie tables are loaded of UseTScat
! is selected.
!
! Revision 2.106  2010/05/14 02:18:16  vsnyder
! Dump BinSelectors
!
! Revision 2.105  2010/03/26 23:12:51  vsnyder
! Add ignoreHessian field for quasi-linear model
!
! Revision 2.104  2010/01/23 01:04:26  vsnyder
! Make sure Mie tables have been read if needed
!
! Revision 2.103  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.102  2008/08/27 19:56:51  vsnyder
! Add PRINT to not_used_here
!
! Revision 2.101  2008/07/31 17:39:34  vsnyder
! Add PhaseFrqTol to the config
!
! Revision 2.100  2008/05/20 00:27:32  vsnyder
! Add GenerateTScat field
!
! Revision 2.99  2007/11/07 03:07:42  vsnyder
! Add Do_Path_Norm switch
!
! Revision 2.98  2007/10/02 22:34:49  vsnyder
! Cannonball polishing
!
! Revision 2.97  2007/06/25 20:34:46  vsnyder
! Replace tabs by spaces, since tabs are nonstandard
!
! Revision 2.96  2006/11/30 23:32:17  vsnyder
! Use SIZE() instead of ASSOCIATED for spectroscopy derivative stuff
!
! Revision 2.95  2006/07/21 00:17:39  vsnyder
! Remove unused declarations and USEs
!
! Revision 2.94  2006/06/03 01:46:10  vsnyder
! Remove no_dup_mol flag from config structure
!
! Revision 2.93  2006/06/01 02:55:21  vsnyder
! Make sure config%lines is associated
!
! Revision 2.92  2006/05/31 22:02:13  vsnyder
! Display 'no lines or continuum' msg if none in the catalog
!
! Revision 2.91  2006/05/11 19:36:14  pwagner
! Added option to disallow duplicate molecules
!
! Revision 2.90  2006/04/25 23:25:36  vsnyder
! Revise DACS filter shape data structure
!
! Revision 2.89  2006/04/11 18:37:21  vsnyder
! Check for DACS channel information
!
! Revision 2.88  2006/02/23 00:58:58  vsnyder
! Don't crash while dumping config if the signal can't be parsed
!
! Revision 2.87  2006/02/08 21:37:36  vsnyder
! Delay halting on error until all possible error messages are emitted.
! Add descriptive titles to integration grid and tangent grid dumps.
!
! Revision 2.86  2006/02/08 01:02:01  vsnyder
! More stuff for spectroscopy derivatives
!
! Revision 2.85  2005/12/29 01:12:04  vsnyder
! Add 'refract' field, polished up dump
!
! Revision 2.84  2005/11/15 00:23:21  pwagner
! Must not attempt to dump config%signals if not associated
!
! Revision 2.83  2005/11/02 21:38:24  vsnyder
! Hoist some stuff out of MAF loop, delete debugging code
!
! Revision 2.82  2005/11/01 23:01:36  vsnyder
! Precompute ShapeInds and stash in config
!
! Revision 2.81  2005/09/17 00:48:42  vsnyder
! Cannonball polishing
!
! Revision 2.80  2005/09/03 01:21:33  vsnyder
! Spectral parameter offsets stuff
!
! Revision 2.79  2005/08/19 23:32:06  pwagner
! option to allow skipping voluminous PFA DB dump when dumping FwdMdl
!
! Revision 2.78  2005/08/03 18:04:09  vsnyder
! Some spectroscopy derivative stuff
!
! Revision 2.77  2005/06/03 01:58:53  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! Revise PFA data structures.
!
! Revision 2.76  2005/05/28 03:27:21  vsnyder
! Simplify PFAStuff
!
! Revision 2.75  2005/05/26 20:12:16  vsnyder
! Delete some debugging code
!
! Revision 2.74  2005/05/26 20:11:31  vsnyder
! Don't delete PFA molecules and ratio in DestroyForwardModelDerived
!
! Revision 2.73  2005/05/26 02:15:14  vsnyder
! Use molecule.signal.sideband.channel structure for PFA
!
! Revision 2.72  2005/05/24 01:54:35  vsnyder
! Delete unused symbols
!
! Revision 2.71  2005/05/05 20:48:02  vsnyder
! Don't check IER if deallocate isn't done
!
! Revision 2.70  2005/05/05 01:14:22  vsnyder
! Make sure fields of PFA_t are nullified.
! Don't try to deallocate channels once for each sideband -- there's only one
! Don't try to deallocate fwdModelConf%beta_group(b)%PFA(s)%data if it's not
! associated.
!
! Revision 2.69  2005/05/02 23:04:03  vsnyder
! Stuff for PFA Cacheing
!
! Revision 2.68  2005/03/28 20:27:51  vsnyder
! Lots of PFA stuff
!
! Revision 2.67  2005/02/17 02:35:13  vsnyder
! Remove PFA stuff from Channels part of config
!
! Revision 2.66  2005/02/16 23:16:49  vsnyder
! Revise data structures for split-sideband PFA
!
! Revision 2.65  2004/12/28 00:27:29  vsnyder
! Remove unreferenced use names
!
! Revision 2.64  2004/12/13 20:35:22  vsnyder
! Moved a bunch of stuff that doesn't depend on the state vector here from
! get_species data.  Some support for PFA, too.
!
! Revision 2.63  2004/11/05 19:38:11  vsnyder
! Moved some stuff here from Get_Species_Data, more work on PFA, some rearranging
!
! Revision 2.62  2004/11/04 03:42:08  vsnyder
! Provide for both LBL_Ratio and PFA_Ratio in beta_group
!
! Revision 2.61  2004/11/03 01:25:30  vsnyder
! Don't deallocate config%molecules -- it's a pointer into beta_group
!
! Revision 2.60  2004/11/01 20:18:23  vsnyder
! Reorganization of representation for molecules and beta groups
!
! Revision 2.59  2004/10/06 21:23:50  vsnyder
! More work on PFA data structures
!
! Revision 2.58  2004/09/01 00:32:40  vsnyder
! Add PFAIndex field, polish up the dump routines
!
! Revision 2.57  2004/08/07 01:17:26  vsnyder
! Forgot an advance='yes' in a dump routine
!
! Revision 2.56  2004/08/05 20:57:52  vsnyder
! Put a sentinel at the end of %molecules
!
! Revision 2.55  2004/08/03 21:40:06  vsnyder
! Inching further toward PFA
!
! Revision 2.54  2004/07/16 19:13:18  vsnyder
! Correct problem in dump routine
!
! Revision 2.53  2004/07/08 02:35:29  vsnyder
! Put all line-by-line molecules before PFA ones
!
! Revision 2.52  2004/06/23 02:14:06  vsnyder
! Added PFA stuff, some cannonball polishing
!
! Revision 2.51  2004/06/11 01:33:29  vsnyder
! Declare all pointer components to be initially NULL
!
! Revision 2.50  2004/06/10 00:59:55  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.49  2004/05/26 23:54:14  vsnyder
! Don't dump the database if it's not allocated
!
! Revision 2.48  2004/05/01 04:00:59  vsnyder
! Added pfaMolecules field
!
! Revision 2.47  2004/03/24 13:50:56  hcp
! Made array LS 17 elements instead of 16. 17 things are taken out of it,
! so presumably it should be that long. NAG f95 flagged this as an error.
!
! Revision 2.46  2004/03/22 18:23:20  livesey
! Added AllLinesInCatalog flag
!
! Revision 2.45  2003/10/28 23:43:47  livesey
! Added forceFoldedOutput
!
! Revision 2.44  2003/10/18 01:15:58  livesey
! Various changes to the pack/unpack stuff.  This currently needs more
! attention.
!
! Revision 2.43  2003/09/15 23:45:00  vsnyder
! Remove unused local variables and USEs
!
! Revision 2.42  2003/09/11 23:10:04  livesey
! Added xStar and yStar
!
! Revision 2.41  2003/07/22 22:43:39  michael
! Added a Dump_ForwardModelConfig subroutine for a single configuration and made
! Dump_ForwardModelConfigDatabase call Dump_ForwardModelConfig to dump an array
! of configurations.  Either is called with the generic interface "dump".
! Formerly, only pointers to arrays of forwardmodelconsigurations could be dumped.
!
! Revision 2.40  2003/07/15 22:09:59  livesey
! Added forceSidebandFraction and linearSideband
!
! Revision 2.39  2003/07/15 18:16:26  livesey
! Added name to configuration
!
! Revision 2.38  2003/06/30 22:55:01  cvuu
! Find mean, std dev timing of fullForwardModel calls
!
! Revision 2.37  2003/06/18 01:58:01  vsnyder
! Add SidebandStart and SidebandStop fields
!
! Revision 2.36  2003/05/29 16:37:02  livesey
! Added switchingMirror
!
! Revision 2.35  2003/05/19 19:58:07  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.34  2003/05/05 23:00:24  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.33  2003/04/04 00:26:44  jonathan
! change dimension(12) :: i11 TO dimension(11) :: i11
!
! Revision 2.32  2003/04/02 21:46:51  jonathan
! remove cloud_fov, changed i12 to i11
!
! Revision 2.31  2003/03/07 03:16:00  livesey
! Changed use of DestroySignal
!
! Revision 2.30.2.2  2003/04/08 23:40:11  jonathan
! remove cloud_fov
!
! Revision 2.30.2.1  2003/02/22 00:48:08  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
! Revision 2.30  2003/02/06 22:04:25  vsnyder
! Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
!
! Revision 2.29  2003/02/06 20:16:23  livesey
! Minor bug fix in the database deallocation
!
! Revision 2.28  2003/02/05 21:57:27  livesey
! Tidy up and added binSelectors, removed nameFragment
!
! Revision 2.27  2003/01/30 22:01:30  livesey
! Tidy up of the logical array packing.
!
! Revision 2.26  2003/01/30 18:29:40  jonathan
! change dimension l13 to 14
!
! Revision 2.25  2003/01/30 17:28:01  jonathan
! add logical incl_cld
!
! Revision 2.24  2003/01/29 01:48:52  vsnyder
! Add 'polarized' field to forwardModel
!
! Revision 2.23  2003/01/26 04:42:42  livesey
! Added profiles/angle options for phiWindow
!
! Revision 2.22  2003/01/17 00:01:44  livesey
! Another bug fix in the packing/unpacking
!
! Revision 2.21  2003/01/16 05:53:19  livesey
! Bug fix to Jonathans new configs
!
! Revision 2.20  2003/01/16 05:50:59  livesey
! Bug fix in do_1d handling
!
! Revision 2.19  2003/01/16 00:55:27  jonathan
! add do_1d, also fix bug of reversed  do_freq_avg do_baseline order
!
! Revision 2.18  2003/01/13 17:16:23  jonathan
! chane cloud_width to i_saturation
!
! Revision 2.17  2002/12/04 21:55:22  livesey
! Added the name fragment packing
!
! Revision 2.16  2002/11/22 12:14:31  mjf
! Added nullify routine(s) to get round Sun's WS6 compiler not
! initialising derived type function results.
!
! Revision 2.15  2002/11/15 01:32:53  livesey
! Added allLinesForRadiometer
!
! Revision 2.14  2002/10/08 17:40:01  livesey
! Various bug fixes in the pack/unpack routines
!
! Revision 2.13  2002/10/08 17:08:03  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.12  2002/10/06 01:09:22  livesey
! Made the pvm routines public
!
! Revision 2.11  2002/10/05 00:41:01  livesey
! Added pvm pack and unpack config and deep option on destroy
!
! Revision 2.10  2002/09/25 20:06:42  livesey
! Added specificQuantities, which necessitated globalConfig to allow for
! some configs inside construct.  This in turn required
! StripForwardModelConfigDatabase
!
! Revision 2.9  2002/08/21 23:53:57  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 2.8  2002/07/17 06:02:13  livesey
! New config elements for hdf5 l2pcs
!
! Revision 2.7  2002/06/12 17:00:49  livesey
! Changed phiWindow to float
!
! Revision 2.6  2002/03/07 17:17:49  livesey
! Removed frqGap
!
! Revision 2.5  2002/02/14 23:01:35  livesey
! Added justChannels in call to destroySignal
!
! Revision 2.4  2002/02/13 00:09:24  livesey
! Added differential Scan model
!
! Revision 2.3  2001/11/15 23:50:11  jonathan
! rename DF_spectroscopy to default_spectroscopy
!
! Revision 2.2  2001/11/15 20:56:38  jonathan
! add df_spectroscopy
!
! Revision 2.1  2001/10/02 20:37:09  livesey
! Added do_baseline
!
! Revision 2.0  2001/09/17 20:26:25  livesey
! New forward model
!
! Revision 1.15  2001/09/04 15:59:01  jonathan
! add cloud_fov, jonathan
!
! Revision 1.14  2001/07/17 22:38:05  jonathan
! add cloud_width, jonathan/paul
!
! Revision 1.13  2001/07/16 22:07:57  jonathan
! change cloud_der to integer-type, jonathan
!
! Revision 1.12  2001/07/06 18:55:13  jonathan
! Modified for cloud model, Paul/Jonathan
!
! Revision 1.11  2001/06/21 15:05:53  livesey
! Added tolerance
!
! Revision 1.10  2001/05/31 23:07:45  livesey
! Added cloud_der
!
! Revision 1.9  2001/05/25 20:26:09  livesey
! Added skipOverlaps option
!
! Revision 1.8  2001/05/14 23:17:35  livesey
! Added frqGap parameter
!
! Revision 1.7  2001/05/03 23:07:02  livesey
! Added scan model stuff
!
! Revision 1.6  2001/05/02 20:30:36  livesey
! Removed frequency from config
!
! Revision 1.5  2001/04/26 02:36:52  vsnyder
! Moved *_indices declarations from init_tables_module to intrinsic
!
! Revision 1.4  2001/04/21 01:08:57  vsnyder
! Deallocate Molecules and MoleculeDerivatives in DestroyFWMConfigDatabase
!
! Revision 1.3  2001/04/12 17:00:08  vsnyder
! Comment out a line with an undefined variable on it
!
! Revision 1.2  2001/04/10 22:17:05  livesey
! Renamed module
!
! Revision 1.1  2001/04/07 01:56:25  vsnyder
! Initial commit
!
@


2.144
log
@Add MIFTangent field to forwardModel
@
text
@d149 1
d1572 1
a1572 1
       "$Id: ForwardModelConfig.f90,v 2.143 2018/08/06 19:58:24 vsnyder Exp $"
d1582 3
@


2.143
log
@Use ASSOCIATE construct to avoid necessity for Lines database to have the
TARGET attribute.  Some cannonball polishing.
@
text
@d153 1
d1420 1
d1571 1
a1571 1
       "$Id: ForwardModelConfig.f90,v 2.142 2018/05/15 03:26:25 vsnyder Exp $"
d1581 4
@


2.142
log
@Change Mie tables from pointer to allocatable
@
text
@d539 1
a539 2
      use SpectroscopyCatalog_M, only: Catalog, Empty_Cat, Line_T, &
        & Lines, MostLines
a559 1
      type (line_T), pointer :: ThisLine
d613 23
a635 22
                  thisLine => lines(catalog(n)%lines(l))
                  if ( associated(thisLine%signals) ) then
                    polarized = 1 ! not polarized
                    ! Work out whether to do this line
                    do z = 1, size(fwdModelConf%signals)
                      if ( fwdModelConf%allLinesForRadiometer ) then
                        doThis = .false.
                        do i = 1, size(thisLine%signals)
                          ! Tried to make GetRadiometerFromSignal elemental, but compile time
                          ! in LF95 (optimized) for Construct.f90 went nuts! :-(
                          if ( GetRadiometerFromSignal ( thisLine%signals(i) ) == &
                            & fwdModelConf%signals(z)%radiometer ) then
                            doThis = .true.
                            if ( .not. fwdModelConf%polarized ) &
                              exit   ! loop over signals for line -- no need to check for
                            ! polarized lines
                            if ( associated(thisLine%polarized) ) then
                              if ( thisLine%polarized(i) ) then
                                polarized = -1 ! polarized
                                exit   ! loop over signals for line -- one signal
                                ! that sees a polarized line is enough to turn on
                                ! the polarized method
d638 9
a647 9
                        end do ! End loop over signals for line
                      else
                        ! Not doing all lines for radiometer, be more selective
                        doThis = any ( &
                          & ( thisLine%signals == fwdModelConf%signals(z)%index ) .and. &
                          & ( ( thisLine%sidebands == 0 ) .or. ( thisLine%sidebands == s ) ) )
                        if ( fwdModelConf%polarized .and. doThis .and. &
                          & associated(thisLine%polarized) ) then
                          if ( any(thisLine%polarized) ) polarized = -1 ! polarized
a648 1
                      end if
d650 12
a661 11
                      if ( fwdModelConf%sidebandStart == fwdModelConf%sidebandStop ) &
                        & doThis = doThis .and. &
                        & any( ( thisLine%sidebands == fwdModelConf%sidebandStart ) &
                        & .or. ( thisLine%sidebands == 0 ) )
                      if ( doThis ) then
                        lineFlag(l) = polarized
                        if ( polarized < 0 .or. .not. fwdModelConf%polarized ) &
                          exit   ! loop over signals requested in fwm
                      end if
                    end do ! z End loop over signals requested in fwm
                  end if
d1569 1
a1569 1
       "$Id: ForwardModelConfig.f90,v 2.141 2018/04/11 22:25:23 vsnyder Exp $"
d1579 3
@


2.141
log
@Remove USE for unused names
@
text
@d314 1
a314 1
    if ( fwdModelConf%useTScat .and. .not. associated(f_s) ) then
d498 1
a498 1
              if ( .not. associated(beta_c_a) ) &
d502 1
a502 1
              if ( .not. associated(beta_c_s) )  &
d1570 1
a1570 1
       "$Id: ForwardModelConfig.f90,v 2.140 2017/09/20 01:07:57 vsnyder Exp $"
d1580 3
@


2.140
log
@Add check that filter shapes are provided if frequency averaging is
selected.
@
text
@a257 1
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
d1570 1
a1570 1
       "$Id: ForwardModelConfig.f90,v 2.139 2017/09/15 15:45:18 livesey Exp $"
d1580 4
@


2.139
log
@Modified to allow omission of filter shapes file under appropriate circumstances
@
text
@d400 20
d1571 1
a1571 1
       "$Id: ForwardModelConfig.f90,v 2.138 2017/08/17 16:29:54 livesey Exp $"
d1581 3
@


2.138
log
@Allowed there to be a missing filter shapes file if frequency
averaging is not being called for
@
text
@d371 25
a395 21
            if ( channels(channel)%dacs == 0 ) then
              do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
                sx = (thisSideband +3) / 2
                channels(channel)%shapeInds(sx) = MatchSignal ( &
                  & filterShapes%signal, fwdModelConf%signals(sigInd), &
                  & sideband = thisSideband, channel=channels(channel)%used )
                if ( channels(channel)%shapeInds(sx) == 0 .and. fwdModelConf%do_freq_avg) &
                  & call MLSMessage ( MLSMSG_Error, ModuleName, &
                  &    "No matching channel shape information" )
              end do
            else
              do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
                sx = (thisSideband +3) / 2
                channels(channel)%shapeInds(sx) = MatchSignal ( &
                  & DACSFilterShapes%filter%signal, fwdModelConf%signals(sigInd), &
                  & sideband = thisSideband, channel=channels(channel)%used )
                if ( channels(channel)%shapeInds(sx) == 0 ) &
                  & call MLSMessage ( MLSMSG_Error, ModuleName, &
                  &    "No matching DACS channel shape information" )
              end do
            end if ! filter bank or DACS
d1551 1
a1551 1
       "$Id: ForwardModelConfig.f90,v 2.137 2017/02/04 02:17:40 vsnyder Exp $"
d1561 4
@


2.137
log
@Undo all-caps switch in USE statements and some declarations.  Add Values1,
Values (rank 2) and Values3 pointers to QtyStuff_t, but they're not used
yet, and might never be used.
@
text
@d377 1
a377 1
                if ( channels(channel)%shapeInds(sx) == 0 ) &
d1547 1
a1547 1
       "$Id: ForwardModelConfig.f90,v 2.136 2016/05/02 23:31:50 vsnyder Exp $"
d1557 5
@


2.136
log
@Add QtyStuff component for temperature
@
text
@d19 5
a23 5
  use MLSKINDS, only: R8, RP
  use MLSSIGNALS_M, only: SIGNAL_T
  use SPECTROSCOPYCATALOG_M, only: CATALOG_T
  use VECTORSMODULE, only: VECTORVALUE_T
  use VGRIDSDATABASE, only: VGRID_T, DESTROYVGRIDCONTENTS, DUMP
d34 5
a38 5
  public :: ADDFORWARDMODELCONFIGTODATABASE, DERIVEFROMFORWARDMODELCONFIG
  public :: DESTROYFWMCONFIGDATABASE, DESTROYFORWARDMODELDERIVED
  public :: DUMP, NULLIFYFORWARDMODELCONFIG
  public :: PVMPACKFWMCONFIG, PVMUNPACKFWMCONFIG
  public :: STRIPFORWARDMODELCONFIGDATABASE
d48 7
a54 1
    type (VectorValue_T), pointer :: QTY => NULL()
d275 8
a282 8
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST
    use MLSMESSAGEMODULE, only: MLSMESSAGE,  MLSMSG_ERROR, MLSMSG_WARNING
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use PFADATABASE_M, only: DUMP
    use READ_MIE_M, only: F_S
    use OUTPUT_M, only: OUTPUT
    use SPECTROSCOPYCATALOG_M, only: DUMP
    use TOGGLES, only: SWITCHES
d337 1
a337 1
      use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE
d339 3
a341 3
      use FILTERSHAPES_M, only: DACSFILTERSHAPES, FILTERSHAPES
      use MLSFINDS, only: FINDFIRST
      use MLSSIGNALS_M, only: MATCHSIGNAL
d401 1
a401 1
      use FILTERSHAPES_M, only: DACSFILTERSHAPES
d448 9
a456 9
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST
      use INTRINSIC, only: LIT_INDICES
      use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
      use MLSSIGNALS_M, only: DISPLAYSIGNALNAME
      use MOLECULES, only: L_CLOUDICE
      use MORETREE, only: STARTERRORMESSAGE
      use PFADATABASE_M, only: TEST_AND_FETCH_PFA
      use READ_MIE_M, only: BETA_C_A, BETA_C_S
      use STRING_TABLE, only: DISPLAY_STRING
d510 1
a510 1
      use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, TEST_ALLOCATE
d512 8
a519 8
      use INTRINSIC, only: LIT_INDICES, L_NONE
      use MLSSIGNALS_M, only: GETRADIOMETERFROMSIGNAL
      use MLSSTRINGLISTS, only: SWITCHDETAIL
      use MORETREE, only: STARTERRORMESSAGE
      use SPECTROSCOPYCATALOG_M, only: CATALOG, EMPTY_CAT, LINE_T, &
        & LINES, MOSTLINES
      use STRING_TABLE, only: DISPLAY_STRING ! , GET_STRING
      use TOGGLES, only: SWITCHES
d527 1
a527 1
      integer, pointer :: LINEFLAG(:) ! /= 0 => Use this line
d725 1
a725 1
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, TEST_DEALLOCATE
d790 5
a794 5
  subroutine PVMPackFWMConfig ( config )
    use PVMIDL, only: PVMIDLPACK
    use MOREPVM, only: PVMPACKLITINDEX, PVMPACKSTRINGINDEX
    use MLSSIGNALS_M, only: PVMPACKSIGNAL
    use VGRIDSDATABASE, only: PVMPACKVGRID
d796 1
a796 1
    type ( ForwardModelConfig_T ), intent(in) :: CONFIG
d891 2
a892 2
  subroutine PVMUnpackFWMConfig ( CONFIG )
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, TEST_ALLOCATE
d894 5
a898 5
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
    use MLSSIGNALS_M, only: PVMUNPACKSIGNAL
    use MOREPVM, only: PVMUNPACKLITINDEX, PVMUNPACKSTRINGINDEX
    use PVMIDL, only: PVMIDLUNPACK
    use VGRIDSDATABASE, only: PVMUNPACKVGRID
d900 1
a900 1
    type ( ForwardModelConfig_T ), intent(out) :: CONFIG
d902 2
a903 2
    integer, parameter     :: ISMAX = 11 ! Number of integers to unpack
    integer, parameter     :: LSMAX = 32 ! Number of logicals to unpack
d907 2
a908 2
    integer, dimension(ISMAX) :: IS     ! Temporary array, for integer scalars
    logical, dimension(LSMAX) :: LS     ! Temporary array, for logical scalars
d1061 1
a1061 1
  subroutine StripForwardModelConfigDatabase ( database )
d1063 1
a1063 1
    use ALLOCATE_DEALLOCATE, only: TEST_ALLOCATE, TEST_DEALLOCATE
d1067 1
a1067 1
    type (ForwardModelConfig_T), dimension(:), pointer :: DATABASE
d1070 1
a1070 1
    type (ForwardModelConfig_T), dimension(:), pointer :: TMPDATABASE
d1072 1
a1072 1
    integer :: CONFIG                   ! Loop counter
d1074 1
a1074 1
    integer :: STATUS
d1107 1
a1107 1
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST, TEST_DEALLOCATE
d1109 1
a1109 1
    use MLSSIGNALS_M, only: DESTROYSIGNALDATABASE
d1113 1
a1113 1
    logical, optional, intent(in) :: DEEP ! Do a really deep destroy
d1120 2
a1121 2
    integer :: STATUS                   ! Flag from allocate etc.
    logical :: MYDEEP                   ! Copy of deep
d1203 5
a1207 5
    use DUMP_0, only: DUMP
    use INTRINSIC, only: LIT_INDICES
    use OUTPUT_M, only: BLANKS, NEWLINE, OUTPUT
    use PFADATABASE_M, only: DUMP, PFADATA
    use STRING_TABLE, only: DISPLAY_STRING
d1289 3
a1291 3
    use MORETREE, only: STARTERRORMESSAGE
    use OUTPUT_M, only: OUTPUT
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
d1296 1
a1296 1
    logical, optional, intent(in) :: skipPFA
d1318 8
a1325 8
    use DUMP_0, only: DUMP
    use INTRINSIC, only: LIT_INDICES, PHYQ_INDICES
    use LEXER_CORE, only: PRINT_SOURCE
    use MLSSIGNALS_M, only: GETNAMEOFSIGNAL, MAXSIGLEN, MODULES
    use OUTPUT_M, only: NEWLINE, OUTPUT
    use QUANTITYTEMPLATES, only: QUANTITYTEMPLATE_T
    use STRING_TABLE, only: DISPLAY_STRING
    use TREE, only: NULL_TREE, Where_At => Where
d1330 1
a1330 1
    logical, optional, intent(in) :: skipPFA
d1336 1
a1336 1
    integer :: MYDETAILS
d1528 6
a1533 6
  subroutine Dump_Qty_Stuff ( Qty, details )
    use HIGHOUTPUT, only: OUTPUTNAMEDVALUE
    use OUTPUT_M, only: NEWLINE, OUTPUT
    use VECTORSMODULE, only: DUMP
    type(qtyStuff_t), intent(in) :: Qty
    integer, optional, intent(in) :: details
d1547 1
a1547 1
       "$Id: ForwardModelConfig.f90,v 2.135 2015/08/25 17:21:47 vsnyder Exp $"
d1557 3
@


2.135
log
@PhiWindow is a tuple, with the first element specifying the angles or
number of profiles/MAFs before the tangent point, and the second
specifying the angles or number after.
@
text
@d234 1
d1541 1
a1541 1
       "$Id: ForwardModelConfig.f90,v 2.134 2015/03/28 01:59:22 vsnyder Exp $"
d1551 5
@


2.134
log
@Added stuff to trace allocate/deallocate addresses
@
text
@d199 2
a200 1
    real (r8) :: PhiWindow            ! Window size for examining stuff
d902 1
a902 1
    real(r8), dimension(2) :: RS        ! Temporary array, for real scalars
d978 2
a979 1
    config%phiWindow = rs(i) ; i = i + 1
d1419 2
a1420 1
    call output ( config%PhiWindow, before='  PhiWindow: ' )
d1540 1
a1540 1
       "$Id: ForwardModelConfig.f90,v 2.133 2014/09/29 20:25:58 vsnyder Exp $"
d1550 3
@


2.133
log
@Add No_Magnetic_Field to config
@
text
@d250 1
d330 1
d339 1
d346 2
d350 1
a350 1
        & elementSize = storage_size(channels) / 8 )
d503 1
d513 1
d539 5
d545 1
a545 1
        & (/s1,1/), (/s2,c/), storage_size(fwdModelConf%catalog) / 8 )
d688 1
d695 1
d706 2
d709 1
a709 1
      call test_deallocate ( status, ModuleName, 'Database', s )
d718 1
d722 1
d727 2
d730 1
a730 1
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%channels', s )
d761 3
d765 1
a765 1
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%catalog', s )
d885 1
d896 1
d1019 2
d1022 1
a1022 1
        & elementSize = storage_size(config%signals) / 8 )
d1032 2
d1035 2
a1036 1
        & uBounds = [1], elementSize = storage_size(config%integrationGrid) / 8 )
d1041 2
d1044 2
a1045 1
        & uBounds = [1], elementSize = storage_size(config%tangentGrid) / 8)
d1055 1
d1062 1
d1078 2
d1081 1
a1081 1
      & uBounds = [n], elementSize = storage_size(tmpDatabase) / 8 )
d1086 2
d1089 1
a1089 1
    call test_deallocate ( status, ModuleName, 'database', n )
d1099 1
d1107 1
d1131 2
d1134 1
a1134 1
      call test_deallocate ( status, moduleName, 'LineCenter', s )
d1138 2
d1141 1
a1141 1
      call test_deallocate ( status, moduleName, 'LineWidth', s )
d1145 2
d1148 1
a1148 1
      call test_deallocate ( status, moduleName, 'LineWidth_TDep', s )
d1153 2
d1156 1
a1156 1
      call test_deallocate ( status, moduleName, 'config%Beta_group', s )
d1166 2
d1169 2
a1170 1
        call test_deallocate ( status, moduleName, 'Config%integrationGrid', s )
d1175 2
d1178 2
a1179 1
        call test_deallocate ( status, moduleName, 'Config%tangentGrid', s )
d1537 1
a1537 1
       "$Id: ForwardModelConfig.f90,v 2.132 2014/09/05 20:48:44 vsnyder Exp $"
d1547 3
@


2.132
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d185 1
d795 4
a798 3
      & config%lockBins, config%polarized, config%refract, config%scanAverage, &
      & config%skipOverlaps, config%spect_Der, config%switchingMirror, &
      & config%temp_Der, config%transformMIFextinction, config%useTScat /), &
d870 2
a871 2
    integer, parameter     :: ISMAX = 11
    integer, parameter     :: LSMAX = 31
d874 1
a875 1
    integer, dimension(ISMAX) :: IS     ! Temporary array, for integer scalars
d935 1
d1315 1
d1482 1
a1482 1
       "$Id: ForwardModelConfig.f90,v 2.131 2014/08/01 01:01:55 vsnyder Exp $"
d1492 3
@


2.131
log
@Change noLinesMsg level from 1 to zero
@
text
@d248 1
a248 2
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ALLOCATE, &
      & MLSMSG_DEALLOCATE, MLSMSG_ERROR
d343 2
a344 1
        & ubounds=(/ fwdModelConf%noUsedChannels /) )
d531 2
a532 1
      call test_allocate ( stat, moduleName, 'fwdModelConf%catalog', (/s1,1/), (/s2,c/) )
d682 1
d690 1
d692 1
a692 1
      call test_deallocate ( status, ModuleName, 'Database' )
d707 1
d709 1
a709 1
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%channels' )
d739 1
d741 1
a741 1
      call test_deallocate ( ier, ModuleName, 'fwdModelConf%catalog' )
d991 2
a992 1
      call test_allocate ( info, ModuleName, 'config%signals' )
d1002 2
a1003 1
      call test_allocate ( info, ModuleName, 'config%integrationGrid' )
d1008 2
a1009 1
      call test_allocate ( info, ModuleName, 'config%tangentGrid' )
d1026 1
d1038 4
a1041 2
    allocate ( tmpDatabase ( count ( database%globalConfig ) ), STAT=status )
    call test_allocate ( status, ModuleName, 'tmpDatabase' )
d1045 1
d1047 1
a1047 1
    call test_deallocate ( status, ModuleName, 'database' )
d1065 2
a1066 1
    integer :: S                        ! 1 = LSB, 2 = USB
d1086 1
d1088 1
a1088 1
      call test_deallocate ( status, moduleName, 'LineCenter' )
d1091 1
d1093 1
a1093 1
      call test_deallocate ( status, moduleName, 'LineWidth' )
d1096 1
d1098 1
a1098 1
      call test_deallocate ( status, moduleName, 'LineWidth_TDep' )
d1101 5
a1105 2
    deallocate ( config%beta_group, stat=status )
    call test_deallocate ( status, moduleName, 'config%Beta_group' )
d1113 1
d1115 1
a1115 1
        call test_deallocate ( status, moduleName, 'Config%integrationGrid' )
d1119 1
d1121 1
a1121 1
        call test_deallocate ( status, moduleName, 'Config%tangentGrid' )
d1124 2
a1125 2
    ! Otherwise don't destroy integrationGrid and tangentGrid.  Assume they will
    ! be (or already are) destroyed by destroyVGridDatabase.
d1478 1
a1478 1
       "$Id: ForwardModelConfig.f90,v 2.130 2014/01/09 00:26:39 pwagner Exp $"
d1488 3
@


2.130
log
@Some procedures formerly in output_m now got from highOutput
@
text
@d646 1
a646 1
              if ( all(catalog(n)%continuum == 0.0) .and. noLinesMsg > 0 ) then
d662 1
a662 1
      if ( sawNoLines .and. noLinesMsg > 0 ) &
d1457 1
a1457 1
       "$Id: ForwardModelConfig.f90,v 2.129 2013/09/24 23:28:17 vsnyder Exp $"
d1467 3
@


2.129
log
@Use Where instead of Source_Ref for messages
@
text
@d1439 2
a1440 1
    use OUTPUT_M, only: NEWLINE, OUTPUT, OUTPUTNAMEDVALUE
d1457 1
a1457 1
       "$Id: ForwardModelConfig.f90,v 2.128 2013/08/16 02:32:14 vsnyder Exp $"
d1467 3
@


2.128
log
@Remove ModelPlaneMIF
@
text
@a442 1
      use TREE, only: SOURCE_REF
a476 1
                if ( source_ref(fwdModelConf%where) /= 0 ) &
a504 1
      use TREE, only: SOURCE_REF
a544 1
              if ( source_ref(fwdModelConf%where) /= 0 ) &
a550 1
              if ( source_ref(fwdModelConf%where) /= 0 ) &
a626 1
                if ( source_ref(fwdModelConf%where) /= 0 ) &
a647 1
                if ( source_ref(fwdModelConf%where) /= 0 ) &
d1237 1
a1237 1
    use TREE, only: NULL_TREE, SOURCE_REF
d1262 1
a1262 1
      call print_source ( source_ref(config%where) )
d1456 1
a1456 1
       "$Id: ForwardModelConfig.f90,v 2.127 2013/08/12 23:48:08 pwagner Exp $"
d1466 3
@


2.127
log
@FindSomethings moved to MLSFinds module
@
text
@a146 2
    integer :: Model_Plane_MIF = 1    ! MIF about which model plane is rotated
                                      ! if L_Azimuth quantity is in fwdModelExtra
d155 1
a155 1
    integer :: ReferenceMIF           ! MIF number to use for MAF geolocation
d1324 1
d1463 1
a1463 1
       "$Id: ForwardModelConfig.f90,v 2.126 2013/08/09 01:02:58 vsnyder Exp $"
d1473 3
@


2.126
log
@Add ReferenceMIF component
@
text
@d332 1
a332 1
      use MLSSETS, only: FINDFIRST
d1464 1
a1464 1
       "$Id: ForwardModelConfig.f90,v 2.125 2013/08/08 02:34:54 vsnyder Exp $"
d1474 3
@


2.125
log
@Add derivOK component to Qty_Stuff
@
text
@d157 1
d787 1
a787 1
      & config%sidebandStart, config%sidebandStop, &
d872 1
a872 1
    integer, parameter     :: ISMAX = 10
d904 1
d1464 1
a1464 1
       "$Id: ForwardModelConfig.f90,v 2.124 2013/07/25 00:22:09 vsnyder Exp $"
d1474 3
@


2.124
log
@Replace TransformRHI with TransformMIFRHI
@
text
@d51 4
d1462 1
a1462 1
       "$Id: ForwardModelConfig.f90,v 2.123 2013/07/19 01:18:45 vsnyder Exp $"
d1472 3
@


2.123
log
@Add TransformRHI component
@
text
@d190 1
a190 1
    logical :: TransformRHI           ! Transform RHI
d1458 1
a1458 1
       "$Id: ForwardModelConfig.f90,v 2.122 2013/07/13 00:07:28 vsnyder Exp $"
d1468 3
@


2.122
log
@Add Model_Plane_MIF component
@
text
@d190 1
d748 1
a748 1
  subroutine NullifyForwardModelConfig ( F )
d750 1
a750 1
    type ( ForwardModelConfig_T ), intent(out) :: F
d1458 1
a1458 1
       "$Id: ForwardModelConfig.f90,v 2.121 2013/05/15 03:08:55 vsnyder Exp $"
d1468 3
@


2.121
log
@Revise processing of dump switch
@
text
@d143 2
d1457 1
a1457 1
       "$Id: ForwardModelConfig.f90,v 2.120 2013/03/30 00:11:39 vsnyder Exp $"
d1467 3
@


2.120
log
@Add Quantity database to dump, dump more stuff in config, add wasSpecific
to QtyStuff_t.
@
text
@d270 3
a272 2
    integer :: DumpFwm = -1                ! -1 = not called yet, 0 = no dumps,
                                           ! 1 = dump, 2 = dump and stop
d276 2
a277 5
    if ( dumpFwm < 0 ) then ! done only once
      dumpFwm = 0
      if ( switchDetail(switches,'fwmd') > -1 )  dumpFwm = 1
      if ( switchDetail(switches,'fwmD') > -1 )  dumpFwm = 2
    end if
d305 1
a305 1
    if ( dumpFwm > 0 .or. error ) then
d307 2
a308 2
      call dump ( fwdModelConf%catalog )
      if ( dumpFwm > 1 .and. .not. error ) stop ! error message will stop later
d665 1
a665 1
        & 'At least one specie has no lines or continuum' )
d1455 1
a1455 1
       "$Id: ForwardModelConfig.f90,v 2.119 2013/03/20 22:46:42 vsnyder Exp $"
d1465 4
@


2.119
log
@Give default value to QtyStuff_t%foundInFirst
@
text
@d50 1
d794 1
a794 1
      & config%temp_Der, config%transformMIFExtinction, config%useTScat /), &
d891 10
a900 10
    config%linearsideband        = is(i) ; i = i + 1
    config%no_cloud_species      = is(i) ; i = i + 1
    config%no_model_surfs        = is(i) ; i = i + 1
    config%num_ab_terms          = is(i) ; i = i + 1
    config%num_azimuth_angles    = is(i) ; i = i + 1
    config%num_scattering_angles = is(i) ; i = i + 1
    config%num_size_bins         = is(i) ; i = i + 1
    config%sideBandStart         = is(i) ; i = i + 1
    config%sideBandStop          = is(i) ; i = i + 1
    config%surfaceTangentIndex   = is(i) ! ; i = i + 1
d937 1
a937 1
    config%transformMIFExtinction = ls(i) !  ; i = i + 1
d1201 1
a1201 1
    & Where, Details, SkipPFA )
d1205 1
d1207 1
a1207 1
    type (ForwardModelConfig_T), pointer, dimension(:) :: Database
d1211 1
d1219 2
a1220 2
        call Dump_ForwardModelConfig( database(i), &
          & details=details, skipPFA=skipPFA )
d1229 2
a1230 1
  subroutine Dump_ForwardModelConfig ( Config, Where, Details, SkipPFA )
d1237 1
d1241 1
a1241 1
    type (ForwardModelConfig_T), intent(in) :: Config
d1245 1
d1300 1
d1322 15
d1423 1
a1423 1
      call output ( ' no IntegrationGrid', advance='yes' )
d1428 1
a1428 1
      call output ( ' no tangentGrid', advance='yes' )
d1447 1
a1447 1
      call output( 'Quantity not assocated for this qtyStuff type', advance='yes' )
d1449 2
a1450 1
    call outputNamedValue ( 'Found in first', qty%foundInFirst )
d1457 1
a1457 1
       "$Id: ForwardModelConfig.f90,v 2.118 2013/03/01 01:08:11 pwagner Exp $"
d1467 3
@


2.118
log
@Snip all but name of dumped config if details < 0
@
text
@d49 1
a49 1
    logical :: FoundInFirst
d1434 1
a1434 1
       "$Id: ForwardModelConfig.f90,v 2.117 2012/05/01 22:18:50 vsnyder Exp $"
d1444 3
@


2.117
log
@Add IsRadianceModel component
@
text
@d34 5
a38 4
  public :: AddForwardModelConfigToDatabase, DeriveFromForwardModelConfig
  public :: DestroyFWMConfigDatabase, DestroyForwardModelDerived
  public :: Dump, NullifyForwardModelConfig
  public :: StripForwardModelConfigDatabase, PVMPackFWMConfig, PVMUnpackFWMConfig
d241 2
a242 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
      & MLSMSG_Deallocate, MLSMSG_Error
d323 2
a324 2
      use Allocate_Deallocate, only: Test_Allocate
      use FilterShapes_m, only: DACSFilterShapes, FilterShapes
d326 1
a326 1
      use MLSSignals_m, only: MatchSignal
d382 1
a382 1
      use FilterShapes_m, only: DACSFilterShapes
d675 1
a675 1
    use Allocate_Deallocate, only: Test_Deallocate
d699 1
a699 1
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
d756 4
a759 4
    use PVMIDL, only: PVMIDLPack
    use MorePVM, only: PVMPackLitIndex, PVMPackStringIndex
    use MLSSignals_m, only: PVMPackSignal
    use VGridsDatabase, only: PVMPackVGrid
d856 6
a861 6
    use Allocate_Deallocate, only: Allocate_test, Test_Allocate
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSSignals_m, only: PVMUnpackSignal
    use MorePVM, only: PVMUnpackLitIndex, PVMUnpackStringIndex
    use PVMIDL, only: PVMIDLUnpack
    use VGridsDatabase, only: PVMUnpackVGrid
d1011 1
a1011 1
    use Allocate_Deallocate, only: Test_Allocate, Test_Deallocate
d1045 2
a1046 2
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate
    use MLSSignals_M, only: DestroySignalDatabase
d1116 5
a1120 5
    use Dump_0, only: Dump
    use Intrinsic, only: Lit_indices
    use Output_m, only: Blanks, NewLine, Output
    use PFADataBase_m, only: Dump, PFAData
    use String_Table, only: Display_String
d1202 2
a1203 2
    use MoreTree, only: StartErrorMessage
    use Output_M, only: Output
d1228 7
a1234 7
    use Dump_0, only: DUMP
    use Intrinsic, only: Lit_indices, PHYQ_Indices
    use Lexer_Core, only: Print_Source
    use MLSSignals_M, only: GetNameOfSignal, MaxSigLen, Modules
    use Output_M, only: NewLine, Output
    use String_Table, only: Display_String
    use Tree, only: Null_Tree, Source_Ref
d1244 1
d1251 2
d1265 1
d1418 2
a1419 2
    use Output_m, only: NewLine, Output, OutputNamedValue
    use VectorsModule, only: Dump
d1425 1
a1425 1
      call output( 'Quantity not assocated for this qtyStuff type (surprised?)', advance='yes' )
d1434 1
a1434 1
       "$Id: ForwardModelConfig.f90,v 2.116 2012/03/07 00:45:28 vsnyder Exp $"
d1444 3
@


2.116
log
@Add TransformMIFExtinction component
@
text
@d128 1
a128 1
    integer :: FwmType                ! l_linear, l_full or l_scan
d176 1
d785 1
a785 1
      & config%anyPFA,  config%atmos_der, config%atmos_second_der, config%default_spectroscopy, &
d787 6
a792 6
      & config%do_conv, config%do_freq_avg,  config%forceFoldedOutput, &
      & config%forceSidebandFraction,  config%globalConfig, &
      & config%ignoreHessian, config%incl_cld, config%lockBins, &
      & config%polarized, config%refract, config%skipOverlaps, &
      & config%spect_Der, config%switchingMirror, config%temp_Der, &
      & config%useTScat /), &
d865 1
a865 1
    integer, parameter     :: LSMAX = 27
d908 29
a936 25
    config%allLinesForRadiometer = ls(i) ; i = i + 1
    config%allLinesInCatalog     = ls(i) ; i = i + 1
    config%anyLBL                = ls(i:i+1) ; i = i + 2
    config%anyPFA                = ls(i:i+1) ; i = i + 2
    config%atmos_der             = ls(i) ; i = i + 1
    config%atmos_second_der      = ls(i) ; i = i + 1
    config%default_spectroscopy  = ls(i) ; i = i + 1
    config%differentialScan      = ls(i) ; i = i + 1
    config%do_1d                 = ls(i) ; i = i + 1
    config%do_baseline           = ls(i) ; i = i + 1
    config%do_conv               = ls(i) ; i = i + 1
    config%do_freq_avg           = ls(i) ; i = i + 1
    config%forceFoldedOutput     = ls(i) ; i = i + 1
    config%forceSidebandFraction = ls(i) ; i = i + 1
    config%globalConfig          = ls(i) ; i = i + 1
    config%ignoreHessian         = ls(i) ; i = i + 1
    config%incl_cld              = ls(i) ; i = i + 1
    config%lockBins              = ls(i) ; i = i + 1
    config%polarized             = ls(i) ; i = i + 1
    config%refract               = ls(i) ; i = i + 1
    config%skipOverlaps          = ls(i) ; i = i + 1
    config%spect_der             = ls(i) ; i = i + 1
    config%switchingMirror       = ls(i) ; i = i + 1
    config%temp_der              = ls(i) ; i = i + 1
    config%useTScat              = ls(i) !  ; i = i + 1
d1429 1
a1429 1
       "$Id: ForwardModelConfig.f90,v 2.115 2012/01/25 00:07:07 vsnyder Exp $"
d1439 3
@


2.115
log
@Use Test_Allocate, Test_Deallocate
@
text
@d184 1
d1424 1
a1424 1
       "$Id: ForwardModelConfig.f90,v 2.114 2011/07/29 01:51:38 vsnyder Exp $"
d1434 3
@


2.114
log
@Remove TScatMolecules and TScatMoleculeDerivatives fields.  Make CloudIce
a molecule.  Look for CloudIce instead of Cloud_A and Cloud_S
@
text
@d257 1
a257 3
    use MLSMESSAGEMODULE, only: MLSMESSAGE,  MLSMSG_ALLOCATE, MLSMSG_ERROR, &
      & MLSMSG_WARNING
    use MLSSETS, only: FINDFIRST
d320 1
d322 1
d335 2
a336 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'fwdModelConf%channels' )
d672 1
a672 1
    use MLSMessageModule, only: MLSMessage,  MLSMSG_Deallocate, MLSMSG_Error
d688 1
a688 2
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate // "Database" )
d696 1
a696 2
    use Allocate_Deallocate, only: Deallocate_Test
    use MLSMessageModule, only: MLSMessage, MLSMSG_Deallocate, MLSMSG_Error
d704 1
a704 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'fwdModelConf%channels' )
d735 1
a735 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Deallocate // 'fwdModelConf%catalog' )
d853 4
a857 4
    use MorePVM, only: PVMUnpackLitIndex, PVMUnpackStringIndex
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Allocate
    use Allocate_Deallocate, only: Allocate_test
    use MLSSignals_m, only: PVMUnpackSignal
d980 1
a980 2
      if ( info /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'config%signals' )
d990 1
a990 2
      if ( info /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'config%integrationGrid' )
d995 1
a995 2
      if ( info /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'config%tangentGrid' )
d1004 1
a1004 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
      & MLSMSG_Deallocate, MLSMSG_Error
d1024 1
a1024 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // 'tmpDatabase' )
d1029 2
a1030 2
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate // 'database' )
d1423 1
a1423 1
       "$Id: ForwardModelConfig.f90,v 2.113 2011/05/09 17:45:38 pwagner Exp $"
d1433 4
@


2.113
log
@Converted to using switchDetail
@
text
@a197 2
    integer, dimension(:), pointer :: TScatMolecules=>NULL() ! Which molecules to consider
    logical, dimension(:), pointer :: TScatMoleculeDerivatives=>NULL() ! Want Jacobians
d430 1
a430 1
      use MOLECULES, only: L_CLOUD_A, L_CLOUD_S
d453 1
a453 1
            if ( fwdModelConf%beta_group(b)%pfa(sx)%molecules(p) == l_cloud_a ) then
a457 2
            end if
            if ( fwdModelConf%beta_group(b)%pfa(sx)%molecules(p) == l_cloud_s ) then
d1432 1
a1432 1
       "$Id: ForwardModelConfig.f90,v 2.112 2011/03/31 19:50:29 vsnyder Exp $"
d1442 3
@


2.112
log
@Don't dump beta group twice
@
text
@d19 5
a23 5
  use MLSCommon, only: R8, RP
  use MLSSignals_M, only: Signal_t
  use SpectroscopyCatalog_m, only: Catalog_t
  use VectorsModule, only: VectorValue_T
  use VGridsDatabase, only: VGrid_T, DestroyVGridContents, dump
d258 10
a267 10
    use Allocate_Deallocate, only: Allocate_Test
    use MLSMessageModule, only: MLSMessage,  MLSMSG_Allocate, MLSMSG_Error, &
      & MLSMSG_Warning
    use MLSSets, only: FindFirst
!   use Output_m, only: Output
    use PFADataBase_m, only: Dump
    use Read_Mie_m, only: F_s
    use Output_m, only: Output
    use SpectroscopyCatalog_m, only: Dump
    use Toggles, only: Switches
d277 2
a278 2
      if ( index(switches,'fwmd') /= 0 )  dumpFwm = 1
      if ( index(switches,'fwmD') /= 0 )  dumpFwm = 2
d428 10
a437 10
      use Allocate_deallocate, only: Allocate_Test
      use Intrinsic, only: Lit_Indices
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error
      use MLSSignals_m, only: DisplaySignalName
      use Molecules, only: L_Cloud_A, L_Cloud_S
      use MoreTree, only: StartErrorMessage
      use PFADatabase_m, only: Test_And_Fetch_PFA
      use Read_Mie_m, only: Beta_c_a, Beta_c_s
      use String_Table, only: Display_String
      use Tree, only: Source_Ref
d494 10
a503 9
      use Allocate_Deallocate, only: Allocate_Test, Test_Allocate
      use Intrinsic, only: LIT_INDICES, L_NONE
      use MLSSignals_m, only: GetRadiometerFromSignal
      use MoreTree, only: StartErrorMessage
      use SpectroscopyCatalog_m, only: Catalog, Empty_Cat, Line_t, &
        & Lines, MostLines
      use String_table, only: Display_String ! , Get_String
      use Toggles, only: Switches
      use Tree, only: Source_Ref
d524 1
a524 1
      if ( noLinesMsg < 0 ) noLinesMsg = index(switches, '0sl') ! Done once
d1436 1
a1436 1
       "$Id: ForwardModelConfig.f90,v 2.111 2010/12/06 19:15:42 pwagner Exp $"
d1446 3
@


2.111
log
@More detailed dump of config to aid debugging
@
text
@d1409 6
a1414 5
    if ( associated(config%beta_Group) ) then
      call dump ( config%beta_Group, details=details, name='Beta group' )
    else
      call output ( ' no Beta group (surprised?)', advance='yes' )
    end if
d1435 1
a1435 1
       "$Id: ForwardModelConfig.f90,v 2.110 2010/09/25 01:08:39 vsnyder Exp $"
d1445 3
@


2.110
log
@Cannonball polishing
@
text
@d1199 1
a1199 1
      if ( associated ( beta_group(b)%qty%qty ) ) call dump ( beta_group(b)%qty )
d1409 5
d1417 2
a1418 2
  subroutine Dump_Qty_Stuff ( Qty )
    use Output_m, only: NewLine, Output
d1421 7
a1427 2
    call dump ( qty%qty, details=-2 )
    if ( qty%foundInFirst ) call output ( ', Found in first' )
d1434 1
a1434 1
       "$Id: ForwardModelConfig.f90,v 2.109 2010/08/27 06:13:37 yanovsky Exp $"
d1444 3
@


2.109
log
@Add atmos_second_der, MoleculeSecondDerivatives.
Add SecondDerivatives component to Beta_Group_T.
@
text
@d151 1
a151 1
    integer :: TScatMIF               ! Which MIF to use for TEcat LOS VEL and PHITAN
d1424 1
a1424 1
       "$Id: ForwardModelConfig.f90,v 2.108 2010/06/09 16:33:59 pwagner Exp $"
d1434 4
@


2.108
log
@Complain if IS, LS array bounds exceeded
@
text
@d100 2
a101 1
    logical :: Derivatives = .false.  ! "Compute derivatives w.r.t. mixing ratio"
d160 1
d196 1
d790 1
a790 1
      & config%anyPFA,  config%atmos_der, config%default_spectroscopy, &
d823 1
d870 1
a870 1
    integer, parameter     :: LSMAX = 26
d918 1
d963 2
d972 1
d1155 1
d1275 1
d1332 1
d1334 1
a1334 1
          call output (' compute derivatives', advance='yes')
d1336 1
a1336 1
          call output (' no derivatives', advance='yes')
d1338 9
d1424 1
a1424 1
       "$Id: ForwardModelConfig.f90,v 2.107 2010/06/07 23:20:51 vsnyder Exp $"
d1434 3
@


2.107
log
@Add UseTScat, TScatMolecules, TScatMoleculeDerivatives, change name
of PhaseFrqTol to FrqTol, check that Mie tables are loaded of UseTScat
is selected.
@
text
@d865 2
d869 2
a870 2
    logical, dimension(25) :: LS        ! Temporary array, for logical scalars
    integer, dimension(10) :: IS        ! Temporary array, for integer scalars
d885 3
a887 1
    ! Now the integer scalars
d899 4
a902 1
    config%surfaceTangentIndex   = is(i) ; i = i + 1
d932 4
a935 1
    config%useTScat              = ls(i) ; i = i + 1
d1404 1
a1404 1
       "$Id: ForwardModelConfig.f90,v 2.106 2010/05/14 02:18:16 vsnyder Exp $"
d1414 5
@


2.106
log
@Dump BinSelectors
@
text
@d182 1
d184 2
a185 2
    real (r8) :: PhaseFrqTol          ! MHz, how close to channel must scattering
                                      ! phase function be?
d195 2
d261 2
d299 5
d793 2
a794 1
      & config%spect_Der, config%switchingMirror,  config%temp_Der /), &
d925 1
d1394 1
a1394 1
       "$Id: ForwardModelConfig.f90,v 2.105 2010/03/26 23:12:51 vsnyder Exp $"
d1404 3
@


2.105
log
@Add ignoreHessian field for quasi-linear model
@
text
@d1288 3
d1382 1
a1382 1
       "$Id: ForwardModelConfig.f90,v 2.104 2010/01/23 01:04:26 vsnyder Exp $"
d1392 3
@


2.104
log
@Make sure Mie tables have been read if needed
@
text
@d170 3
d780 2
a781 2
      & config%forceSidebandFraction,  config%globalConfig, config%incl_cld, &
      & config%lockBins, &
d856 1
a856 1
    logical, dimension(24) :: LS        ! Temporary array, for logical scalars
d905 1
d1379 1
a1379 1
       "$Id: ForwardModelConfig.f90,v 2.103 2009/06/23 18:26:10 pwagner Exp $"
d1389 3
@


2.103
log
@Prevent Intel from optimizing ident string away
@
text
@d414 1
d416 1
d419 1
d439 12
d1375 1
a1375 1
       "$Id: read_apriori.f90 is it here $"
d1385 3
@


2.102
log
@Add PRINT to not_used_here
@
text
@d1357 1
d1359 3
a1361 6

    !---------------------------- RCS Ident Info -------------------------------
    character (len=*), parameter :: IdParm = &
      & "$Id: ForwardModelConfig.f90,v 2.101 2008/07/31 17:39:34 vsnyder Exp $"
    character (len=len(idParm)) :: Id = IdParm
    !---------------------------------------------------------------------------
d1363 1
a1363 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1365 1
d1370 3
@


2.101
log
@Add PhaseFrqTol to the config
@
text
@d1361 1
a1361 1
      & "$Id: ForwardModelConfig.f90,v 2.100 2008/05/20 00:27:32 vsnyder Exp $"
d1365 1
d1371 3
@


2.100
log
@Add GenerateTScat field
@
text
@d150 1
d180 2
d1361 1
a1361 1
      & "$Id: ForwardModelConfig.f90,v 2.99 2007/11/07 03:07:42 vsnyder Exp $"
d1370 3
@


2.99
log
@Add Do_Path_Norm switch
@
text
@d167 1
d1358 1
a1358 1
      & "$Id: ForwardModelConfig.f90,v 2.98 2007/10/02 22:34:49 vsnyder Exp $"
d1367 3
@


2.98
log
@Cannonball polishing
@
text
@d164 1
d1227 1
d1357 1
a1357 1
      & "$Id: ForwardModelConfig.f90,v 2.97 2007/06/25 20:34:46 vsnyder Exp $"
d1366 3
@


2.97
log
@Replace tabs by spaces, since tabs are nonstandard
@
text
@d1202 1
a1202 2
    call output ( '  Forward Model Config Name: ' )
    call display_string ( config%name )
d1355 1
a1355 1
      & "$Id: ForwardModelConfig.f90,v 2.96 2006/11/30 23:32:17 vsnyder Exp $"
d1364 3
@


2.96
log
@Use SIZE() instead of ASSOCIATED for spectroscopy derivative stuff
@
text
@d143 1
a143 1
    integer :: Ntimes = 0	      ! Number of times calling FullForwardModel
d179 1
a179 1
    real :: sum_DeltaTime = 0.0	      ! sum of delta time calling FullForwardModel 
d1356 1
a1356 1
      & "$Id: ForwardModelConfig.f90,v 2.95 2006/07/21 00:17:39 vsnyder Exp $"
d1365 3
@


2.95
log
@Remove unused declarations and USEs
@
text
@d1280 2
a1281 2
    if ( associated(config%lineCenter) .or. associated(config%lineWidth) .or. &
      &  associated(config%lineWidth_Tdep) ) then
d1283 1
a1283 1
      if ( associated(config%lineCenter) ) &
d1286 1
a1286 1
      if ( associated(config%lineWidth) ) &
d1289 1
a1289 1
      if ( associated(config%lineWidth_Tdep) ) &
d1356 1
a1356 1
      & "$Id: ForwardModelConfig.f90,v 2.94 2006/06/03 01:46:10 vsnyder Exp $"
d1365 3
@


2.94
log
@Remove no_dup_mol flag from config structure
@
text
@d464 1
a464 1
      use String_table, only: Display_String, Get_String
a474 1
      character(len=32) :: MolName ! For messages
d478 1
a478 1
      character(len=32) :: MoleculeName ! for error message
a997 1
    use MLSMessageModule, only: MLSMSG_Deallocate, MLSMSG_Error, MLSMessage
d1179 1
a1179 1
    use Intrinsic, only: Lit_indices, PHYQ_Indices, Spec_Indices
d1356 1
a1356 1
      & "$Id: ForwardModelConfig.f90,v 2.93 2006/06/01 02:55:21 vsnyder Exp $"
d1365 3
@


2.93
log
@Make sure config%lines is associated
@
text
@d6 1
a6 1
! This software may be subject to U.S. export control laws. By accepting this
a168 1
    logical :: No_dup_mol             ! Quit if duplicate molecules found
d759 1
a759 1
      & config%lockBins, config%no_dup_mol, &
d834 1
a834 1
    logical, dimension(25) :: LS        ! Temporary array, for logical scalars
a884 1
    config%no_dup_mol            = ls(i) ; i = i + 1
a1233 1
    call output ( config%no_dup_mol, before='  No_dup_mol: ', advance='yes' )
d1358 1
a1358 1
      & "$Id: ForwardModelConfig.f90,v 2.92 2006/05/31 22:02:13 vsnyder Exp $"
d1367 3
@


2.92
log
@Display 'no lines or continuum' msg if none in the catalog
@
text
@d605 1
a605 1
            else if ( any(catalog(n)%continuum /= 0.0) ) then
d607 2
a608 2
              ! No lines for this specie.  However, its continuum is still
              ! valid so don't set it to empty.
d613 1
a613 1
            else if ( noLinesMsg > 0 ) then ! just warn
d615 10
a624 10
              if ( source_ref(fwdModelConf%where) /= 0 ) &
              call startErrorMessage ( fwdModelConf%where )
              call display_string ( lit_indices(n), &
                & before='No lines or continuum for ', advance='yes' )
!             else ! it's an error to have no lines or continuum
!             ! DON'T DO THIS! it catches radiometer-dependent species
!             ! such as O3_R1A that intentionally have no lines or continuum
!               call get_string ( lit_indices(n), moleculeName )
!               call MLSMessage ( MLSMSG_Error, moduleName, &
!                 & 'No lines or continuum for ' // trim(moleculeName) )
d1361 1
a1361 1
      & "$Id: ForwardModelConfig.f90,v 2.91 2006/05/11 19:36:14 pwagner Exp $"
d1370 3
@


2.91
log
@Added option to disallow duplicate molecules
@
text
@d246 2
a247 1
    use MLSMessageModule, only: MLSMessage,  MLSMSG_Allocate, MLSMSG_Error
d465 1
a465 1
      use String_table, only: Display_String
d480 1
d484 1
d490 1
d592 1
d596 1
a596 1
                  & before='No relevant lines or continuum for ' )
d605 1
a605 1
            else
a608 3
              ! Don't bother checking that continuum /= 0 as if it were then
              ! presumably having no continuum and no lines it wouldn't be in
              ! the catalog!
d613 12
d630 4
d1361 1
a1361 1
      & "$Id: ForwardModelConfig.f90,v 2.90 2006/04/25 23:25:36 vsnyder Exp $"
d1370 3
@


2.90
log
@Revise DACS filter shape data structure
@
text
@d169 1
d742 2
a743 1
      & config%lockBins, config%polarized, config%refract, config%skipOverlaps, &
d817 1
a817 1
    logical, dimension(24) :: LS        ! Temporary array, for logical scalars
d868 1
d1218 1
d1343 1
a1343 1
      & "$Id: ForwardModelConfig.f90,v 2.89 2006/04/11 18:37:21 vsnyder Exp $"
d1352 3
@


2.89
log
@Check for DACS channel information
@
text
@d343 1
a343 1
                  & DACSFilterShapes%signal, fwdModelConf%signals(sigInd), &
d1339 1
a1339 1
      & "$Id: ForwardModelConfig.f90,v 2.88 2006/02/23 00:58:58 vsnyder Exp $"
d1348 3
@


2.88
log
@Don't crash while dumping config if the signal can't be parsed
@
text
@d339 11
a349 1
            end if ! not DACS
d1176 1
a1176 1
    integer :: J                             ! Loop counter
d1305 6
a1310 2
        call output ( config%channels(j)%DACS, before='    DACS: ', &
          & advance='yes' )
d1339 1
a1339 1
      & "$Id: ForwardModelConfig.f90,v 2.87 2006/02/08 21:37:36 vsnyder Exp $"
d1348 3
@


2.87
log
@Delay halting on error until all possible error messages are emitted.
Add descriptive titles to integration grid and tangent grid dumps.
@
text
@d1269 2
a1270 5
        call getNameOfSignal ( config%signals(j), signalName)
        call output ( '  '//trim(signalName)//' channels Included:' )
        if ( associated(config%signals(j)%channels) ) then
          call newLine
          call dump ( config%signals(j)%channels )
d1272 8
a1279 1
          call output ( ' None', advance='yes' )
d1325 1
a1325 1
      & "$Id: ForwardModelConfig.f90,v 2.86 2006/02/08 01:02:01 vsnyder Exp $"
d1334 4
@


2.86
log
@More stuff for spectroscopy derivatives
@
text
@a448 1
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d450 1
d453 1
a453 1
      use String_table, only: GET_STRING
d455 1
d493 14
a506 4
            if ( catalog(n)%molecule == l_none ) then
              call get_string ( lit_indices(n), molName )
              call MLSMessage ( MLSMSG_Error, moduleName, &
                & 'No spectroscopy catalog for ' // molName )
d577 4
a580 3
                call get_string ( lit_indices(n), molName )
                call MLSMessage ( MLSMSG_Warning, ModuleName, &
                  & 'No relevant lines or continuum for '//trim(molName) )
d1296 1
a1296 1
      call dump(config%IntegrationGrid, details=details)
d1298 2
a1299 2
      call output (' no IntegrationGrid', advance='yes')
    endif
d1301 1
a1301 1
      call dump(config%tangentGrid, details=details)
d1303 2
a1304 2
      call output (' no tangentGrid', advance='yes')
    endif
d1321 1
a1321 1
      & "$Id: ForwardModelConfig.f90,v 2.85 2005/12/29 01:12:04 vsnyder Exp $"
d1330 3
@


2.85
log
@Add 'refract' field, polished up dump
@
text
@d53 1
d58 3
d78 5
a182 7
    ! Indices for spectral parameters.   If LineCenter+ix(s,i) is nonzero,
    ! LineCenter(LineCenter_ix(s,i)) is added onto the line center in the gl_slabs
    ! array for the i'th line-by-line molecule in sideband s.  Similarly for
    ! LineWidth_ix and LineWidth_Tdep_ix.
    integer, dimension(:,:), pointer :: LineCenter_ix=>NULL() ! sidebands,1:noNonPFA
    integer, dimension(:,:), pointer :: LineWidth_ix=>NULL() ! sidebands,1:noNonPFA
    integer, dimension(:,:), pointer :: LineWidth_Tdep_ix=>NULL() ! sidebands,1:noNonPFA
a1022 6
    call deallocate_test ( config%lineCenter_ix, &
      & "config%lineCenter_ix", moduleName )
    call deallocate_test ( config%lineWidth_ix, &
      & "config%lineWidth_ix", moduleName )
    call deallocate_test ( config%lineWidth_Tdep_ix, &
      & "config%lineWidth_Tdep_ix", moduleName )
d1043 4
d1072 9
a1246 2
      if ( associated(config%lineCenter_ix) ) &
        & call dump ( config%lineCenter_ix(s1:s2,:), name='    Line Center Indices' )
a1249 2
      if ( associated(config%lineWidth_ix) ) &
        & call dump ( config%lineWidth_ix(s1:s2,:), name='    Line Width Indices' )
a1252 3
      if ( associated(config%lineWidth_Tdep_ix) ) &
        & call dump ( config%lineWidth_Tdep_ix(s1:s2,:), &
          & name='    Line Width Temperature Dependence Indices' )
d1309 1
a1309 1
      & "$Id: ForwardModelConfig.f90,v 2.84 2005/11/15 00:23:21 pwagner Exp $"
d1318 3
@


2.84
log
@Must not attempt to dump config%signals if not associated
@
text
@a114 1
    integer :: Cat_Size(2)            ! Catalog size, by sideband, 1 = LSB, 2 = USB
d127 3
a130 1
    ! Now the other integers
a140 1
    integer :: WindowUnits            ! Either degrees or profiles
d161 1
d717 1
a717 1
      & config%lockBins, config%polarized,  config%skipOverlaps, &
d791 1
a791 1
    logical, dimension(23) :: LS        ! Temporary array, for logical scalars
d843 1
d1131 3
a1133 2
    use Intrinsic, only: Lit_indices
    use MLSSignals_M, only: GetNameOfSignal, MaxSigLen
d1136 1
d1156 4
d1165 44
a1208 7
    call output ( config%atmos_der, before='  Atmos_der:', advance='yes' )
    call output ( config%do_conv, before='  Do_conv:', advance='yes' )
    call output ( config%do_Baseline, before='  Do_Baseline:', advance='yes' )
    call output ( config%Default_spectroscopy, before='  Default_spectroscopy:', advance='yes' )
    call output ( config%do_freq_avg, before='  Do_freq_avg:', advance='yes' )
    call output ( config%do_1d, before='  Do_1D:', advance='yes' )
    call output ( config%incl_cld, before='  Incl_Cld:', advance='yes' )
d1211 6
a1216 7
    call output ( config%skipOverlaps, before='  SkipOverlaps:',advance='yes' )
    call output ( config%spect_der, before='  Spect_der:', advance='yes' )
    call output ( config%temp_der, before='  Temp_der:', advance='yes' )
    call output ( config%anyLBL(1), before='  AnyLBL:' )
    call output ( config%anyLBL(2) )
    call output ( config%anyPFA(1), before='  AnyPFA:' )
    call output ( config%anyPFA(2), advance='yes' )
d1223 1
a1223 2
        call output ( '    ' )
        call display_string(lit_indices(config%molecules(j)))
d1307 1
a1307 1
      & "$Id: ForwardModelConfig.f90,v 2.83 2005/11/02 21:38:24 vsnyder Exp $"
d1316 3
@


2.83
log
@Hoist some stuff out of MAF loop, delete debugging code
@
text
@d1210 14
a1223 10
    do j = 1, size(config%signals)
      call getNameOfSignal ( config%signals(j), signalName)
      call output ( '  '//trim(signalName)//' channels Included:' )
      if ( associated(config%signals(j)%channels) ) then
        call newLine
        call dump ( config%signals(j)%channels )
      else
        call output ( ' None', advance='yes' )
      end if
    end do
d1264 1
a1264 1
      & "$Id: ForwardModelConfig.f90,v 2.82 2005/11/01 23:01:36 vsnyder Exp $"
d1273 3
@


2.82
log
@Precompute ShapeInds and stash in config
@
text
@d132 1
a249 1
    logical, parameter :: debug = .false.
a259 4
    if ( debug ) then
      print *, 'Entering DeriveFromForwardModelConfig'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a268 4
    if ( debug .and. .false. ) then
      print *, 'Exiting DACS_Stuff'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a271 4
    if ( debug .and. .false. ) then
      print *, 'Exiting channel_stuff'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a274 4
    if ( debug .and. .false. ) then
      print *, 'Exiting SpectroscopyCatalogExtract'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a280 4
    if ( debug ) then
      print *, 'Exiting PFA_Stuff'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a287 4
    if ( debug ) then
      print *, 'Exiting DeriveFromForwardModelConfig'
      call dump(fwdModelConf, details=9, skipPFA=.true.)
    endif
a307 1
      integer :: NoUsedChannels
d311 1
a311 6
      noUsedChannels = 0
      do sigInd = 1, size(fwdModelConf%signals)
        noUsedChannels = noUsedChannels + &
          & count( fwdModelConf%signals(sigInd)%channels )
      end do
      allocate ( channels(noUsedChannels), stat=ier )
a415 6
          if ( debug .and. .false. ) then
            print *, 'sb, b, n_beta, n_channels, n_molecules ', &
              & sb, b, size(fwdModelConf%beta_group), size(fwdModelConf%channels), &
              & size(fwdModelConf%beta_group(b)%pfa(sx)%molecules)
            call dump(fwdModelConf, details=9, skipPFA=.true.)
          endif
a418 6
              if ( debug .and. .false. ) then
                print *, 'b, size(beta) ', b, size(fwdModelConf%beta_group)
                print *, 'signal, size(signals) ', fwdModelConf%channels(channel)%signal, size(fwdModelConf%signalIndices)
                print *, 'sx, size(pfa) ', sx, size(fwdModelConf%beta_group(b)%pfa)
                print *, 'channel, p, shape(data) ', channel, p, shape(fwdModelConf%beta_group(b)%pfa(sx)%data)
              endif
a422 4
              if ( debug ) then
                print *, 'after test_and_fetch_PFA ', fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)
                call dump(fwdModelConf, details=9, skipPFA=.true.)
              endif
d1260 1
a1260 1
      & "$Id: ForwardModelConfig.f90,v 2.81 2005/09/17 00:48:42 vsnyder Exp $"
d1269 3
@


2.81
log
@Cannonball polishing
@
text
@d106 1
d323 3
d334 1
d356 11
d1306 1
a1306 1
      & "$Id: ForwardModelConfig.f90,v 2.80 2005/09/03 01:21:33 vsnyder Exp $"
d1315 3
@


2.80
log
@Spectral parameter offsets stuff
@
text
@d506 1
a506 1
      call test_allocate ( stat, moduleName, 'fwdModelConf%catalog', (/s1,1/), (/1,c/) )
d1290 1
a1290 1
      & "$Id: ForwardModelConfig.f90,v 2.79 2005/08/19 23:32:06 pwagner Exp $"
d1299 3
@


2.79
log
@option to allow skipping voluminous PFA DB dump when dumping FwdMdl
@
text
@a73 5
    ! Indices in info%line....  Nonzero means use the solved-for parameter;
    ! zero (or not associated) means use the one in the catalog.
    integer, pointer :: LineCenter(:) => NULL()
    integer, pointer :: LineWidth(:) => NULL()
    integer, pointer :: LineWidth_TDep(:) => NULL()
d171 7
d474 1
a474 1
      use Allocate_Deallocate, only: Allocate_Test
d476 1
a476 2
      use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error, &
        & MLSMSG_Warning
d504 1
a504 10
      c = 0
      do sx = (s1+3)/2,(s2+3)/2
        m = 0
        do b = 1, size(fwdModelConf%beta_group) ! Get total catalog size
          m = m + size(fwdModelConf%beta_group(b)%lbl(sx)%molecules)
        end do ! b
        fwdModelConf%cat_size(sx) = m
        c = max(c,m)
      end do ! sx

d506 1
a506 2
      if ( stat /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'fwdModelConf%catalog' )
a1005 3
        call deallocate_test ( config%beta_group(b)%LBL(s)%lineCenter, 'LineCenter', moduleName )
        call deallocate_test ( config%beta_group(b)%LBL(s)%lineWidth, 'LineWidth', moduleName )
        call deallocate_test ( config%beta_group(b)%LBL(s)%lineWidth_TDep, 'LineWidth_TDep', moduleName )
d1049 6
a1099 16
          if ( associated(beta_group(b)%lbl(s)%lineCenter) ) &
            call display_string ( &
              & lit_indices(pack(beta_group(b)%lbl(s)%molecules, &
                &                beta_group(b)%lbl(s)%lineCenter/=0)), &
              & before='   Line centers for:', advance='yes' )
          if ( associated(beta_group(b)%lbl(s)%lineWidth) ) &
            call display_string ( &
              & lit_indices(pack(beta_group(b)%lbl(s)%molecules, &
                &                beta_group(b)%lbl(s)%lineWidth/=0)), &
              & before='   Line widths for:', advance='yes' )
          if ( associated(beta_group(b)%lbl(s)%lineWidth_TDep) ) &
            call display_string ( &
              & lit_indices(pack(beta_group(b)%lbl(s)%molecules, &
                &                beta_group(b)%lbl(s)%lineWidth_TDep/=0)), &
              & before='   Line width temperature depencence for:', &
              & advance='yes' )
d1170 3
a1172 1
    integer ::  J                            ! Loop counter
a1173 1
    logical :: dumpPFA
d1179 1
d1219 20
d1290 1
a1290 1
      & "$Id: ForwardModelConfig.f90,v 2.78 2005/08/03 18:04:09 vsnyder Exp $"
d1299 3
@


2.78
log
@Some spectroscopy derivative stuff
@
text
@d23 1
a23 1
  use VGridsDatabase, only: VGrid_T, DestroyVGridContents
d246 1
a246 1

d257 4
a260 1

d270 4
d277 4
d284 4
d294 4
d305 4
d428 6
d437 6
d447 4
d1151 2
a1152 1
  subroutine Dump_ForwardModelConfigDatabase ( Database, Where )
d1159 2
d1168 2
a1169 1
        call Dump_ForwardModelConfig( database(i) )
d1178 1
a1178 1
  subroutine Dump_ForwardModelConfig ( Config, Where, Details )
d1189 1
d1194 1
d1197 2
d1223 1
a1223 1
    if ( associated(config%Beta_group) ) &
d1264 10
d1290 1
a1290 1
      & "$Id: ForwardModelConfig.f90,v 2.77 2005/06/03 01:58:53 vsnyder Exp $"
d1299 3
@


2.77
log
@New copyright notice, move Id to not_used_here to avoid cascades,
Revise PFA data structures.
@
text
@d51 6
d62 6
a67 5
  type, public :: LBL_T ! For LBL molecules in the group:
    integer, pointer  :: Cat_Index(:) => NULL() ! 1:size(LBL_Molecules).  Indices
                                      ! for config%catalog and gl_slabs.
                                      ! Allocated in ConstructForwardModelConfig.
                                      ! Filled in DeriveFromForwardModelConfig.
d71 8
a78 4
    real(rp), pointer :: Ratio(:) => NULL() ! 1:size(LBL_Molecules).  Isotope
                                      ! ratio.  Allocated in ForwardModelSupport
                                      ! with value 1.0, but could be filled in
                                      ! Get_Species_Data.
d164 1
a176 2
      ! >0 = beginning of a group or a lonesome molecule, <0 = member of a group.
      ! Size is one more than number in config; last one is a huge positive sentinel.
d181 3
d952 1
a952 1
    use Allocate_Deallocate, only: Deallocate_Test
d973 6
a978 3
        call deallocate_test ( config%beta_group(b)%lbl(s)%cat_index, 'Cat_Index', moduleName )
        call deallocate_test ( config%beta_group(b)%lbl(s)%molecules, 'LBL Molecules', moduleName )
        call deallocate_test ( config%beta_group(b)%lbl(s)%ratio, 'LBL Ratio', moduleName )
d982 17
a998 1
    end do
a999 3
    deallocate ( config%beta_group, stat=b )
    if ( b /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Deallocate // 'config%Beta_group' )
d1007 1
a1007 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate // "config%integrationGrid" )
d1012 1
a1012 2
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate // "config%tangentGrid" )
d1018 1
a1018 1
    call Deallocate_test ( config%specificQuantities, &
d1020 1
a1020 1
    call Deallocate_test ( config%binSelectors, &
d1067 16
d1233 1
a1233 1
      & "$Id: ForwardModelConfig.f90,v 2.76 2005/05/28 03:27:21 vsnyder Exp $"
d1242 4
@


2.76
log
@Simplify PFAStuff
@
text
@a20 1
  use PFADatabase_m, only: PFAPointer_t
d74 2
a75 2
    type(PFAPointer_t), pointer :: Data(:,:) => NULL() ! Channels x 1:size(Molecules).
                                      ! Pointers to PFA Data.  Allocated and
d174 1
a226 1
    use MLSSignals_m, only: MatchSignal
d228 1
a228 2
    use PFADataBase_m, only: Dump, PFA_By_Molecule, SortPFAData, &
      & Sort_PFADataBase
d369 1
a370 1
      use MLSMessageModule, only: MLSMessage,  MLSMSG_Allocate, MLSMSG_Error
d373 1
a373 1
      use PFADatabase_m, only: FindPFA, PFAData
a378 1
      integer :: I                    ! Index for sorted PFA data
a384 1
      ! Look first in the molecule.signal.sideband.channel structure
d388 1
a388 1
          allocate ( fwdModelConf%beta_group(b)%pfa(sx)%data( &
d390 2
a391 3
            & size(fwdModelConf%beta_group(b)%pfa(sx)%molecules)), stat=i )
          if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_Allocate // 'Beta_group(b)%PFA(sx)%data' )
d394 6
a399 49
              if ( associated(findPFA(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p))%s) ) then
                if ( associated(findPFA(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p))% &
                  & s(fwdModelConf%channels(channel)%signal)%sb(sx)%c) ) then
                  fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum => &
                    & findPFA(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p))% &
                      & s(fwdModelConf%channels(channel)%signal)%sb(sx)% &
                      & c(fwdModelConf%channels(channel)%used)%datum
                end if ! signal stru associated
              end if ! channel stru associated
            end do ! channel
          end do ! p
        end do ! b
      end do ! sb

      ! Now look in the PFA_By_Molecule structure.
      ! This is only for data created online instead of read from a file.
      if ( associated(pfaData) ) then
        call sort_PFADatabase ! Only does anything once
        do sb = s1, s2, 2
          sx = ( sb + 3 ) / 2
          do b = 1, size(fwdModelConf%beta_group)
            do p = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%molecules)
              do channel = 1, size(fwdModelConf%channels)
                if ( .not. &
                  & associated(fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum) ) then
                  ! Search the other structure for PFA data created online
                  do i = PFA_by_molecule(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p)-1)+1, &
                    &    PFA_by_molecule(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p))
                    if ( matchSignal ( PFAData(sortPFAdata(i))%theSignal, &
                      &  fwdModelConf%signals(fwdModelConf%channels(channel)%signal), sideband=sb, &
                      &  channel=fwdModelConf%channels(channel)%used ) > 0 ) then
                      fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum => &
                        PFAData(sortPFAdata(i))
                    end if
                  end do ! i (molecules)
                end if ! .not. associated....
              end do ! channel
            end do ! p
          end do ! b
        end do ! sb
      end if ! associated(pfaData)

      ! Now check that we have PFA data
      do sb = s1, s2, 2
        sx = ( sb + 3 ) / 2
        do b = 1, size(fwdModelConf%beta_group)
          do p = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%data,2)
            do channel = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%data,1)
              if ( .not. associated(fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum) ) then
d412 1
a412 1
          end do ! p (molecules)
d626 2
a627 5
        if ( associated(fwdModelConf%beta_group(b)%PFA(s)%data) ) then
          deallocate ( fwdModelConf%beta_group(b)%PFA(s)%data, stat=ier )
          if ( ier/= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & MLSMSG_Deallocate // 'Beta_group(b)%PFA(s)%data' )
        end if
d964 1
a964 1
        call deallocate_test ( config%beta_group(b)%PFA(s)%ratio, 'PFA %ratio', moduleName )
d973 1
d1003 1
a1003 1
    use PFADataBase_m, only: Dump
d1050 1
a1050 1
                if ( associated(beta_group(b)%pfa(s)%data(c,m)%datum) ) then
d1052 1
a1052 1
                  call dump ( beta_group(b)%pfa(s)%data(c,m)%datum, details=myDetails )
d1190 1
a1190 1
      & "$Id: ForwardModelConfig.f90,v 2.75 2005/05/26 20:12:16 vsnyder Exp $"
d1199 3
@


2.75
log
@Delete some debugging code
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d414 1
a414 1
      ! Maybe this one isn't necessary any more.
a419 5
            allocate ( fwdModelConf%beta_group(b)%pfa(sx)%data( &
              & size(fwdModelConf%channels), &
              & size(fwdModelConf%beta_group(b)%pfa(sx)%molecules)), stat=i )
            if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & MLSMSG_Allocate // 'Beta_group(b)%PFA(sx)%data' )
d424 1
a424 1
                  ! Search the other structure.  Maybe this one isn't necessary any more
a436 16
            do p = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%data,2)
              do channel = 1, size(fwdModelConf%beta_group(b)%pfa(sx)%data,1)
                if ( .not. associated(fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum) ) then
                  if ( source_ref(fwdModelConf%where) /= 0 ) &
                  call startErrorMessage ( fwdModelConf%where )
                  call display_string ( &
                    & lit_indices(fwdModelConf%beta_group(b)%molecule), &
                    & before=' PFA table not found for ' )
                  call displaySignalName ( &
                    & fwdModelConf%signals(fwdModelConf%channels(channel)%signal), &
                    & advance='yes', before=' and ', sideband=sb, &
                    & channel=fwdModelConf%channels(channel)%used )
                  error = .true.
                end if
              end do ! channel
            end do ! p (molecules)
d1240 1
a1240 1
      & "$Id: ForwardModelConfig.f90,v 2.74 2005/05/26 20:11:31 vsnyder Exp $"
d1249 3
@


2.74
log
@Don't delete PFA molecules and ratio in DestroyForwardModelDerived
@
text
@a366 1
use output_m, only: output
a383 3
if ( .not. associated(fwdModelConf%beta_group) ) call output ( 'Beta_Group', advance='yes' )
if ( .not. associated(fwdModelConf%channels) ) call output ( 'Channels', advance='yes' )
if ( .not. associated(fwdModelConf%beta_group(b)%pfa(sx)%molecules) ) call output ( 'Molecules', advance='yes' )
d1253 1
a1253 1
      & "$Id: ForwardModelConfig.f90,v 2.73 2005/05/26 02:15:14 vsnyder Exp $"
d1262 3
@


2.73
log
@Use molecule.signal.sideband.channel structure for PFA
@
text
@d367 1
d385 3
a695 4
        call deallocate_test ( fwdModelConf%beta_group(b)%PFA(s)%molecules, &
          & 'fwdModelConf%beta_group(b)%PFA(s)%molecules', moduleName )
        call deallocate_test ( fwdModelConf%beta_group(b)%PFA(s)%ratio, &
          & 'fwdModelConf%beta_group(b)%PFA(s)%ratio', moduleName )
d1031 2
d1035 1
d1257 1
a1257 1
      & "$Id: ForwardModelConfig.f90,v 2.72 2005/05/24 01:54:35 vsnyder Exp $"
d1266 3
@


2.72
log
@Delete unused symbols
@
text
@d255 4
a258 1
    ! Work out the PFA stuff
d367 1
a367 1
      use PFADatabase_m, only: PFAData
d380 27
d418 15
a432 11
              do i = PFA_by_molecule(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p)-1)+1, &
                &    PFA_by_molecule(fwdModelConf%beta_group(b)%pfa(sx)%molecules(p))
                do channel = 1, size(fwdModelConf%channels)
                  if ( matchSignal ( PFAData(sortPFAdata(i))%theSignal, &
                    &  fwdModelConf%signals(fwdModelConf%channels(channel)%signal), sideband=sb, &
                    &  channel=fwdModelConf%channels(channel)%used ) > 0 ) then
                    fwdModelConf%beta_group(b)%pfa(sx)%data(channel,p)%datum => &
                      PFAData(sortPFAdata(i))
                  end if
                end do ! channel
              end do ! i (molecules)
a451 8
      else ! Make sure pointer fields of PFA are nullified
        do sx = 1, 2
          do b = 1, size(fwdModelConf%beta_group)
            nullify ( fwdModelConf%beta_group(b)%pfa(sx)%data, &
                      fwdModelConf%beta_group(b)%pfa(sx)%molecules, &
                      fwdModelConf%beta_group(b)%pfa(sx)%ratio )
          end do
        end do
d454 23
a691 1
        ! These are probably deallocated somewhere else, but this can't hurt
a1030 4
      ! PFA_Indices are created and destroyed on each call to FullForwardModel.
      ! call deallocate_test ( config%beta_group(b)%pfa(s)%indices, 'PFA Indices', moduleName )
        call deallocate_test ( config%beta_group(b)%pfa(s)%molecules, 'PFA Molecules', moduleName )
        call deallocate_test ( config%beta_group(b)%pfa(s)%ratio, 'PFA Ratio', moduleName )
d1254 1
a1254 1
      & "$Id: ForwardModelConfig.f90,v 2.71 2005/05/05 20:48:02 vsnyder Exp $"
d1263 3
@


2.71
log
@Don't check IER if deallocate isn't done
@
text
@d13 1
a13 1
  use PFADatabase_m, only: PFAData_t, PFAPointer_t
d221 1
a221 1
    use PFADataBase_m, only: Dump, PFAData, PFA_By_Molecule, SortPFAData, &
a363 1
      use Output_M, only: Output
d1210 1
a1210 1
      & "$Id: ForwardModelConfig.f90,v 2.70 2005/05/05 01:14:22 vsnyder Exp $"
d1219 3
@


2.70
log
@Make sure fields of PFA_t are nullified.
Don't try to deallocate channels once for each sideband -- there's only one
Don't try to deallocate fwdModelConf%beta_group(b)%PFA(s)%data if it's not
associated.
@
text
@d639 5
a643 4
        if ( associated(fwdModelConf%beta_group(b)%PFA(s)%data) ) &
          & deallocate ( fwdModelConf%beta_group(b)%PFA(s)%data, stat=ier )
        if ( ier/= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Deallocate // 'Beta_group(b)%PFA(s)%data' )
d1211 1
a1211 1
      & "$Id: ForwardModelConfig.f90,v 2.69 2005/05/02 23:04:03 vsnyder Exp $"
d1220 6
@


2.69
log
@Stuff for PFA Cacheing
@
text
@d419 8
d629 7
a635 8
    do s = 1, 2
      if ( associated(fwdModelConf%channels) ) then
        deallocate ( fwdModelConf%channels, stat = ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'fwdModelConf%channels' )
    ! else
    !   It was already deallocated at the end of FullForwardModel
      end if
d637 4
a640 2
      do b = 1, size(fwdModelConf%beta_group)
        deallocate ( fwdModelConf%beta_group(b)%PFA(s)%data, stat=ier )
d642 8
a649 3
          & MLSMSG_Deallocate // 'Beta_group(b)%PFA(s)%indices' )
      end do ! b
    end do ! s
d1210 1
a1210 1
      & "$Id: ForwardModelConfig.f90,v 2.68 2005/03/28 20:27:51 vsnyder Exp $"
d1219 3
@


2.68
log
@Lots of PFA stuff
@
text
@d12 2
a13 1
  use MLSSignals_M, only: Signal_T
d47 2
a48 2
  ! to m1,...mn (but not m).  The Cat_Index, Qty and *_Ratio components are
  ! filled in Get_Species_Data.
a63 3
    integer, pointer :: Indices(:,:) => NULL() ! Channels x 1:size(Molecules). 
                                      ! Indices in PFADataBase%PFAData.  Allocated
                                      ! and filled in DeriveFromForwardModelConfig.
d67 3
d81 2
a82 1
    type(qtyStuff_t) :: Qty           ! The Qty's vector and foundInFirst
d361 2
d365 1
d376 1
a376 3
      character(len=3), parameter :: SBN(2) = (/ 'Low', 'Upp' /)

      ! Fill fwdModelConf%beta_group%pfa%indices
d383 1
a383 1
            call allocate_test ( fwdModelConf%beta_group(b)%pfa(sx)%indices, &
d385 3
a387 3
              & size(fwdModelConf%beta_group(b)%pfa(sx)%molecules), &
              & 'Beta_group(b)%PFA(sx)%indices', moduleName )
            fwdModelConf%beta_group(b)%pfa(sx)%indices = 0 ! not junk, to detect missing ones
d394 4
a397 3
                    &  channel=fwdModelConf%channels(channel)%used ) > 0 ) &
                      & fwdModelConf%beta_group(b)%pfa(sx)%indices(channel,p) = &
                        & sortPFAdata(i)
d401 16
a416 8
            if ( any(fwdModelConf%beta_group(b)%pfa(sx)%indices == 0) ) then
              call startErrorMessage ( source_ref ( fwdModelConf%where ) )
              call output ( ' PFA tables not found for ' )
              call display_string ( &
                & lit_indices(fwdModelConf%beta_group(b)%molecule) )
              call output ( ' in ' // sbn(sx) // 'er sideband.', advance='yes' )
              error = .true.
            end if
d631 3
a633 2
        call deallocate_test ( fwdModelConf%beta_group(b)%PFA(s)%indices, &
          'Beta_group(b)%PFA(s)%indices', moduleName )
d655 2
a656 2
      deallocate ( fwdModelConf%catalog, stat=s )
      if ( s /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
d1004 1
a1004 1
  subroutine Dump_Beta_Group ( Beta_Group, Name, Sidebands )
d1008 2
a1009 1
    use Output_m, only: NewLine, Output
d1015 1
d1017 3
a1019 1
    integer :: I, S, S1, S2
d1027 2
d1032 4
a1035 4
    do i = 1, size(beta_group)
      call output ( i, before='  Beta group ', after=': ' )
      call display_string ( lit_indices(beta_group(i)%molecule) )
      if ( beta_group(i)%derivatives ) call output ( ' with derivative' )
d1039 1
a1039 1
        if ( size(beta_group(i)%lbl(s)%molecules) > 0 ) then
d1041 1
a1041 1
            & lit_indices(beta_group(i)%lbl(s)%molecules), before='   LBL:', &
d1043 2
a1044 2
          call dump ( beta_group(i)%lbl(s)%ratio, name='    Isotope ratio' )
          call dump ( beta_group(i)%lbl(s)%cat_index, &
d1047 1
a1047 1
        if ( size(beta_group(i)%pfa(s)%molecules) > 0 ) then
d1049 1
a1049 1
            & lit_indices(beta_group(i)%pfa(s)%molecules), before='   PFA:', &
d1051 17
a1067 4
          call dump ( beta_group(i)%pfa(s)%ratio, name='    Isotope ratio' )
          if ( associated(beta_group(i)%pfa(s)%indices) ) &
            & call dump ( beta_group(i)%pfa(s)%indices(:,:), &
            & name='    PFA Database indices ' )
d1070 1
a1070 1
      if ( associated ( beta_group(i)%qty%qty ) ) call dump ( beta_group(i)%qty )
d1098 1
a1098 1
  subroutine Dump_ForwardModelConfig ( Config, Where )
d1107 2
a1108 1
    character(len=*), optional, intent(in) :: Where
a1111 1
    character(3), parameter :: SB(2) = (/ 'Low', 'Upp' /)    
d1141 1
a1141 1
        & sidebands=(/config%sidebandStart,config%sidebandStop/) )
d1196 1
a1196 1
      & "$Id: ForwardModelConfig.f90,v 2.67 2005/02/17 02:35:13 vsnyder Exp $"
d1205 3
@


2.67
log
@Remove PFA stuff from Channels part of config
@
text
@d98 2
d129 2
a130 1
    logical :: AnyPFA                 ! Set if there are any PFA molecules
d214 2
a215 3
    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use MLSMessageModule, only: MLSMessage,  MLSMSG_Allocate, MLSMSG_Error, &
      & MLSMSG_Warning
d221 1
d258 1
d358 6
d371 2
d377 1
a377 1
        do sb = s1, s2
d384 1
a384 1
            fwdModelConf%beta_group(b)%pfa(sx)%indices = 0 ! OK if some missing, but no junk
d397 8
d445 1
a445 1
      do sx = 1, 2
d450 1
d607 1
a607 1
    integer :: C, B, I, Ier, S
d691 8
a698 7
      & config%allLinesForRadiometer, config%allLinesInCatalog, config%anyPFA, &
      & config%atmos_der, config%default_spectroscopy, config%differentialScan,&
      & config%do_1d, config%do_baseline, config%do_conv, config%do_freq_avg, &
      & config%forceFoldedOutput, config%forceSidebandFraction, &
      & config%globalConfig, config%incl_cld, config%lockBins, config%polarized, &
      & config%skipOverlaps, config%spect_Der, config%switchingMirror, &
      & config%temp_Der /), msg = "Packing fwmConfig logicals" )
d770 1
a770 1
    logical, dimension(20) :: LS        ! Temporary array, for logical scalars
d807 2
a808 1
    config%anyPFA                = ls(i) ; i = i + 1
d964 1
a964 1
      & MLSMSG_Deallocate // 'Config%Beta_group' )
d991 1
a991 1
  subroutine Dump_Beta_Group ( Beta_Group, Name )
d1000 1
d1002 1
a1002 1
    integer :: I, S
d1005 5
d1017 3
a1019 7
      do s = 1, 2
        call output ( sb(s) // 'er sideband:', advance='yes' )
        if ( size(beta_group(i)%lbl(s)%molecules) > 0 ) call display_string ( &
            & lit_indices(beta_group(i)%lbl(s)%molecules), before=', LBL:' )
        if ( size(beta_group(i)%pfa(s)%molecules) > 0 ) call display_string ( &
            & lit_indices(beta_group(i)%pfa(s)%molecules), before=', PFA:' )
        call newLine
d1021 6
a1026 2
          call dump ( beta_group(i)%lbl(s)%ratio, name='   LBL Ratio' )
          call dump ( beta_group(i)%lbl(s)%cat_index, name='   Cat_Index' )
d1029 4
a1032 1
          call dump ( beta_group(i)%pfa(s)%ratio, name='   PFA Ratio' )
d1034 2
a1035 1
            & call dump ( beta_group(i)%pfa(s)%indices(:,:), name='   PFA Indices ' )
d1078 1
a1078 1
    integer ::  I, J, S                      ! Loop counters
d1085 1
a1085 1
    call display_string ( Config%name )
d1091 19
a1109 21
    call output ( '  Atmos_der:' )
    call output ( Config%atmos_der, advance='yes' )
    call output ( '  Do_conv:' )
    call output ( Config%do_conv, advance='yes' )
    call output ( '  Do_Baseline:' )
    call output ( Config%do_Baseline, advance='yes' )
    call output ( '  Default_spectroscopy:' )
    call output ( Config%Default_spectroscopy, advance='yes' )
    call output ( '  Do_freq_avg:' )
    call output ( Config%do_freq_avg, advance='yes' )
    call output ( '  Do_1D:' )
    call output ( Config%do_1d, advance='yes' )
    call output ( '  Incl_Cld:' )
    call output ( Config%incl_cld, advance='yes' )
    call output ( '  SkipOverlaps:' )
    call output ( Config%skipOverlaps, advance='yes' )
    call output ( '  Spect_der:' )
    call output ( Config%spect_der, advance='yes' )
    call output ( '  Temp_der:' )
    call output ( Config%temp_der, advance='yes' )
    if ( associated(Config%Beta_group) ) call dump ( Config%Beta_group )
d1111 2
a1112 3
    if ( associated(Config%molecules) ) then
      i = 0
      do j = 1, size(Config%molecules) - 1
d1114 3
a1116 7
        if ( Config%molecules(j) < 0 ) call output ( '-' )
        call display_string(lit_indices(abs(Config%molecules(j))))
        if ( Config%molecules(j) > 0 ) then
          i = i + 1
          call output ( i, before=':' )
        end if
        if (Config%moleculeDerivatives(j)) then
d1124 9
a1132 5
    do j = 1, size(Config%signals)
      call getNameOfSignal ( Config%signals(j), signalName)
      call output ( '  ' )
      call output ( trim(signalName)//' channelIncluded:', advance='yes')
      call dump ( Config%signals(j)%channels )
d1136 3
a1138 3
    if ( associated(Config%usedDACSSignals) ) &
      call dump  ( Config%usedDACSSignals, name='   Used DACS Signals' )
    if ( associated(Config%channels) ) then
d1140 5
a1144 5
      do j = 1, size(Config%channels)
        call output ( Config%channels(j)%used, before='    Used: ' )
        call output ( Config%channels(j)%origin, before='    Origin: ' )
        call output ( Config%channels(j)%signal, before='    Signal: ' )
        call output ( Config%channels(j)%DACS, before='    DACS: ', &
d1146 1
a1146 1
      end do ! j = 1, size(Config%channels)
d1164 1
a1164 1
      & "$Id: ForwardModelConfig.f90,v 2.66 2005/02/16 23:16:49 vsnyder Exp $"
d1173 3
@


2.66
log
@Revise data structures for split-sideband PFA
@
text
@d63 1
a63 1
    integer, pointer :: Indices(:,:) => NULL() ! Channels x 1:size(PFA_Molecules). 
d69 1
a69 1
    real(rp), pointer :: Ratio(:) => NULL() ! 1:size(PFA_Molecules).  Isotope
d85 1
a85 1
  ! Channel information from the signals database
a90 7
    integer, pointer :: PFAIndex(:,:) => NULL()   ! Sidebands X numPFA
                          ! Indices in PFADataBase%PFAData
    integer, pointer :: PFAMolecules(:) => NULL() ! L_... from Molecules(firstPFA:)
                          ! for this channel
    integer, pointer :: BetaIndex(:) => NULL()    ! Allocated here but filled
                          ! later in Get_Species_Data; BetaIndex(i) is second
                          ! subscript for beta_path for PFAMolecules(i).
d179 1
a179 4
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
    & "$Id: ForwardModelConfig.f90,v 2.65 2004/12/28 00:27:29 vsnyder Exp $"
  character (len=len(idParm)) :: Id = IdParm
a233 2
    call sort_PFADatabase ! Only does anything once

d354 35
a388 171
      integer :: B                           ! Index for beta groups
      integer :: Channel
!     logical :: Hit                         ! Hit a molecule to be used
!     integer :: HowManyPFA                  ! How many PFA data records are for the
                                             ! molecules in fwdModelConf%Molecules?
      integer :: I
!     integer :: J, K
!     integer :: NumPFA                      ! Like HowManyPFA, but for one channel
      integer :: P                           ! Index for PFA molecules in a beta group
!     integer, pointer :: PFAWork(:,:)       ! PFA Indices for a channel.
!                                            ! Sideband X Molecules.
      integer :: SB                          ! Sideband index
!     integer, pointer :: T1(:), T2(:)       ! Temps for set operations
!     integer, pointer :: WhichMolecule(:)   ! To which element of config%molecules
!                                            ! does WhichPfa(i) correspond?
!     integer, pointer :: WhichPFA(:)        ! Which PFA data records are for the
!                                            ! molecules in fwdModelConf%Molecules?

!       if ( associated(pfaData) ) then
!         do b = 1, size(fwdModelConf%beta_group)
!           call allocate_test ( fwdModelConf%beta_group(b)%pfa_indices, &
!             & fwdModelConf%sidebandStop, &
!             & size(fwdModelConf%channels), &
!             & size(fwdModelConf%beta_group(b)%pfa_molecules), &
!             & 'Beta_group(b)%PFA_indices', moduleName, &
!             & lowBound_1=fwdModelConf%sidebandStart )
!           fwdModelConf%beta_group(b)%pfa_indices = 0 ! OK if some missing, but no junk
!           do p = 1, size(fwdModelConf%beta_group(b)%PFA_Molecules)
!             do i = PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p)-1)+1, &
!               &    PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p))
!               do sb = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
!                 do channel = 1, size(fwdModelConf%channels)
!                   if ( matchSignal ( PFAData(sortPFAdata(i))%theSignal, &
!                     &  fwdModelConf%signals(fwdModelConf%channels(channel)%signal), sideband=sb, &
!                     &  channel=fwdModelConf%channels(channel)%used ) > 0 ) &
!                       & fwdModelConf%beta_group(b)%pfa_indices(sb,channel,p) = &
!                         & sortPFAdata(i)
!                 end do ! channel
!               end do ! sb
!             end do ! i (molecules)
!           end do ! p
!         end do ! b
!       else
!         do b = 1, size(fwdModelConf%beta_group)
!           nullify ( fwdModelConf%beta_group(b)%pfa_indices ) ! Why is this needed?
!         end do
!       end if ! associated(pfaData)
! 
!      if ( associated(pfaData) ) then
!
!        call allocate_test ( PFAWork, s2, size(fwdModelConf%molecules), &
!          & 'PFAWork', moduleName, lowBound_1=s1, lowBound_2=fwdModelConf%firstPFA )
!
!        ! Work out which PFA data are germane to fwdModelConf%Molecules
!        ! We do this because there are thousands of PFA data, but maybe only
!        ! a few that are germane to this fwdModelConf
!        howManyPFA = 0
!        do i = 1, size(pfaData)
!          hit = .false.
!          do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
!            if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
!              if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
!                & DSBSSB=.true.) /= 0 ) then
!                if ( hit ) then
!                  error = .true.
!                  call MLSMessage ( MLSMSG_Warning, moduleName, &
!                    & 'Two molecules in same PFA Datum selected' )
!                  call dump ( PFAData(whichPFA(j)), details=0 )
!                end if
!                hit = .true.
!              end if
!            end if
!          end do
!          if ( hit ) howManyPFA = howManyPFA + 1
!        end do
!        call allocate_test ( whichPFA, howManyPFA, 'whichPFA', moduleName )
!        call allocate_test ( whichMolecule, howManyPFA, 'whichMolecule', moduleName )
!        howManyPFA = 0
!        do i = 1, size(pfaData)
!          do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
!            if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
!              if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
!                & DSBSSB=.true.) /= 0 ) then
!                howManyPFA = howManyPFA + 1
!                whichPFA(howManyPFA) = i
!                whichMolecule(howManyPFA) = j
!              end if
!            end if
!          end do
!        end do
!        ! Work out PFA abstracts for each channel
!        if ( .not. error ) then
!          do i = 1, size(channels)
!            PFAWork = 0
!            nullify ( t1, channels(i)%PFAMolecules, channels(i)%betaIndex )
!            call allocate_test ( channels(i)%PFAMolecules, 0, &
!              & 'channels(i)%PFAMolecules', moduleName ) ! so we can do unions
!            ! Where there is a signal and a molecule, make whichPFA negative.
!            ! Make sure that only one molecule is selected from each PFA Datum
!            do j = 1, howManyPFA
!              if ( channels(i)%used < lbound(PFAData(whichPFA(j))%theSignal%channels,1) .or. &
!                   channels(i)%used > ubound(PFAData(whichPFA(j))%theSignal%channels,1) ) cycle
!              if ( .not. PFAData(whichPFA(j))%theSignal%channels(channels(i)%used) ) cycle
!              if ( matchSignal ( fwdModelConf%signals(channels(i)%signal), &
!                &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true. ) == 0 ) cycle
!              t2 => intersection(fwdModelConf%molecules(fwdModelConf%firstPFA:), &
!                &                PFAData(whichPFA(j))%molecules)
!              if ( size(t2) == 0 ) cycle
!              whichPFA(j) = -whichPFA(j) ! Indicate above tests succeeded
!              t1 => union(channels(i)%PFAMolecules,t2)
!              call deallocate_test ( t2, 't2', moduleName )
!              call deallocate_test ( channels(i)%PFAMolecules, &
!                & 'channels(i)%PFAMolecules', moduleName )
!              channels(i)%PFAMolecules => t1
!            end do ! j = 1, howManyPFA
!            numPFA = size(channels(i)%PFAMolecules)
!            call allocate_test ( channels(i)%PFAIndex, s2, numPFA, &
!              & 'channels(i)%PFAIndex', moduleName, lowBound_1=s1 )
!            call allocate_test ( channels(i)%betaIndex, numPFA, &
!              & 'channels(i)%BetaIndex', moduleName )
!            channels(i)%betaIndex = 0 ! in case a dump is requested
!            ! Arrange the PFAData indices by sideband and molecule in PFAWork
!            do sb = s1, s2, 2
!              do j = 1, howManyPFA
!                if ( whichPFA(j) > 0 ) cycle ! some test in previous loop failed
!                if ( matchSignal ( PFAData(-whichPFA(j))%theSignal, &
!                  &  fwdModelConf%signals(channels(i)%signal), sideband=sb, &
!                  &  channel=channels(i)%used ) > 0 ) &
!                    & PFAWork(sb,whichMolecule(j)) = -whichPFA(j)
!              end do ! j = 1, howManyPFA
!            end do ! sb = s1, s2
!            ! Copy nonzero columns of PFAWork to channels(i)%PFAIndex, which
!            ! has exactly the same number of columns as the number of PFAWork's
!            ! nonzero columns
!            k = 0
!            do j = lbound(pfawork,2), ubound(pfawork,2)
!              if ( pfawork(-1,j)+pfawork(+1,j) /= 0 ) then
!                k = k + 1
!                channels(i)%PFAIndex(s1:s2:2,k) = pfawork(s1:s2:2,j)
!              end if
!            end do
!            ! Check whether we have PFA data for both sidebands if LBL is DSB
!            if ( s1 /= s2 ) then
!              do j = 1, numPFA
!                if ( channels(i)%PFAIndex(s1,j) * channels(i)%PFAIndex(s2,j) == 0 ) then
!    !             error = .true.
!                  call MLSMessage ( MLSMSG_warning, moduleName, &
!                    & 'LBL signal is DSB but both PFAs are not available' )
!                  call output ( channels(i)%used, before=' Channel ' )
!                  call output ( ', LBL signal: ' )
!                  call displaySignalName ( fwdModelConf%signals(channels(i)%signal), &
!                    & advance='yes' )
!                  call output ( ' Available ' )
!                  if ( channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j) == 0 ) then
!                    call output ( 'PFA Datum: None', advance='yes' )
!                  else
!                    call dump ( PFAData( &
!                      & channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j)), &
!                      & index=channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j), &
!                      & details=0 )
!                  end if
!                end if
!              end do ! j = 1, numPFA
!            end if
!            whichPFA = abs(whichPFA)
!          end do ! i = 1, size(channels)
!        end if
!        call deallocate_test ( PFAWork, 'PFAWork', moduleName )
!        call deallocate_test ( whichPFA, 'whichPFA', moduleName )
!        call deallocate_test ( whichMolecule, 'whichMolecule', moduleName )
!     end if ! associated(pfaData)
d588 8
a595 18
    if ( associated(fwdModelConf%channels) ) then
      do i = 1, size(fwdModelConf%channels)
        call deallocate_test ( &
          & fwdModelConf%channels(i)%PFAIndex, &
          & 'fwdModelConf%channels(i)%PFAIndex', moduleName )
        call deallocate_test ( &
          & fwdModelConf%channels(i)%PFAMolecules, &
          & 'fwdModelConf%channels(i)%PFAMolecules', moduleName )
        call deallocate_test ( &
          & fwdModelConf%channels(i)%betaIndex, &
          & 'fwdModelConf%channels(i)%BetaIndex', moduleName )
      end do
      deallocate ( fwdModelConf%channels, stat = ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'fwdModelConf%channels' )
  ! else
  !   It was already deallocated at the end of FullForwardModel
    end if
a596 1
    do s = 1, 2
d1045 2
a1046 1
    integer ::  I, J                         ! Loop counters
d1116 1
a1116 19
        if ( associated(Config%channels(j)%PFAIndex) ) &
          & call dump ( Config%channels(j)%PFAIndex(-1:1:2,:), &
            & name='    PFAData' )
        if ( associated(Config%channels(j)%PFAMolecules) ) then
          call output ( '    PFA Molecules:', advance='no' )
          if ( size(Config%channels(j)%PFAMolecules) == 0 ) &
            call output ( ' Empty' )
          do i = 1, size(Config%channels(j)%PFAMolecules)
            call output ( ' ', advance='no' )
            call display_string ( &
              & lit_indices(Config%channels(j)%PFAMolecules(i)), &
              & advance='no' )
            if ( Config%channels(j)%betaIndex(i) /= 0 ) &
              & call output ( Config%channels(j)%betaIndex(i), &
                & before=':' )
          end do
          call newLine
        end if
      end do
d1131 6
d1143 3
@


2.65
log
@Remove unreferenced use names
@
text
@d46 1
a46 1
  ! to m1,...mn (but not m).  The Cat_Index, Qty and Ratio components are
d48 1
a48 7
  type, public :: Beta_Group_T
    ! For the group as a whole:
    logical :: Derivatives = .false.  ! "Compute derivatives w.r.t. mixing ratio"
    logical :: Group = .false.        ! "Molecule group", i.e., [m,m1,...,mn]
    integer :: Molecule               ! Group name, i.e., "m".
    type(qtyStuff_t) :: Qty           ! The Qty's vector and foundInFirst
    ! For LBL molecules in the group:
d51 3
a53 2
                                      ! Allocated and filled in Get_Species_Data.
    integer, pointer :: LBL_Molecules(:) => NULL() ! LBL molecules in the group
d56 1
a56 1
    real(rp), pointer :: LBL_Ratio(:) => NULL() ! 1:size(LBL_Molecules).  Isotope
d60 10
a69 9
    ! For PFA molecules in the group:
    integer, pointer :: PFA_Indices(:,:,:) => NULL() ! Sidebands x Channels
                                      ! x 1:size(PFA_Molecules).  Indices in
                                      ! PFADataBase%PFAData.  Allocated and
                                      ! filled in Get_Species_Data.
    integer, pointer :: PFA_Molecules(:) => NULL() ! PFA molecules in the group
                                      ! if a group, i.e., "m1...mn", else "m" if
                                      ! "m" is PFA, else zero size.
    real(rp), pointer :: PFA_Ratio(:) => NULL() ! 1:size(PFA_Molecules).  Isotope
d73 10
d188 1
a188 1
    & "$Id: ForwardModelConfig.f90,v 2.64 2004/12/13 20:35:22 vsnyder Exp $"
d384 30
a413 30
      if ( associated(pfaData) ) then
        do b = 1, size(fwdModelConf%beta_group)
          call allocate_test ( fwdModelConf%beta_group(b)%pfa_indices, &
            & fwdModelConf%sidebandStop, &
            & size(fwdModelConf%channels), &
            & size(fwdModelConf%beta_group(b)%pfa_molecules), &
            & 'Beta_group(b)%PFA_indices', moduleName, &
            & lowBound_1=fwdModelConf%sidebandStart )
          fwdModelConf%beta_group(b)%pfa_indices = 0 ! OK if some missing, but no junk
          do p = 1, size(fwdModelConf%beta_group(b)%PFA_Molecules)
            do i = PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p)-1)+1, &
              &    PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p))
              do sb = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
                do channel = 1, size(fwdModelConf%channels)
                  if ( matchSignal ( PFAData(sortPFAdata(i))%theSignal, &
                    &  fwdModelConf%signals(fwdModelConf%channels(channel)%signal), sideband=sb, &
                    &  channel=fwdModelConf%channels(channel)%used ) > 0 ) &
                      & fwdModelConf%beta_group(b)%pfa_indices(sb,channel,p) = &
                        & sortPFAdata(i)
                end do ! channel
              end do ! sb
            end do ! i (molecules)
          end do ! p
        end do ! b
      else
        do b = 1, size(fwdModelConf%beta_group)
          nullify ( fwdModelConf%beta_group(b)%pfa_indices ) ! Why is this needed?
        end do
      end if ! associated(pfaData)

d564 2
a565 2
      integer :: S         ! Index for sidebands                
      integer :: STAT      ! Status from allocate or deallocate 
d573 7
a579 3
      do b = 1, size(fwdModelConf%beta_group) ! Get total catalog size
        c = c + size(fwdModelConf%beta_group(b)%lbl_molecules)
      end do
d581 1
a581 2
      allocate ( fwdModelConf%catalog(fwdModelConf%sidebandStart:fwdModelConf%sidebandStop,c), &
        & stat=stat )
d589 1
d592 1
a592 1
          do m = 1, size(fwdModelConf%beta_group(b)%lbl_molecules)
d594 2
a595 2
            fwdModelConf%beta_group(b)%cat_index(m) = c
            n = fwdModelConf%beta_group(b)%lbl_molecules(m)
d755 6
a760 4
    do b = 1, size(fwdModelConf%beta_group)
      call deallocate_test ( fwdModelConf%beta_group(b)%PFA_indices, &
        'Beta_group(b)%PFA_indices', moduleName )
    end do ! b
d1078 1
d1088 4
a1091 5
      call deallocate_test ( config%beta_group(b)%cat_index, 'Cat_Index', moduleName )
      call deallocate_test ( config%beta_group(b)%lbl_molecules, 'LBL_Molecules', moduleName )
      call deallocate_test ( config%beta_group(b)%lbl_ratio, 'LBL_Ratio', moduleName )
      call deallocate_test ( config%beta_group(b)%pfa_molecules, 'PFA_Molecules', moduleName )
      call deallocate_test ( config%beta_group(b)%pfa_ratio, 'PFA_Ratio', moduleName )
d1093 4
d1137 2
a1138 1
    integer :: I, J
d1147 15
a1161 17
      if ( size(beta_group(i)%lbl_molecules) > 0 ) call display_string ( &
          & lit_indices(beta_group(i)%lbl_molecules), before=', LBL:' )
      if ( size(beta_group(i)%pfa_molecules) > 0 ) call display_string ( &
          & lit_indices(beta_group(i)%pfa_molecules), before=', PFA:' )
      call newLine
      if ( size(beta_group(i)%lbl_molecules) > 0 ) then
        call dump ( beta_group(i)%lbl_ratio, name='   LBL Ratio' )
        call dump ( beta_group(i)%cat_index, name='   Cat_Index' )
      end if
      if ( size(beta_group(i)%pfa_molecules) > 0 ) then
        call dump ( beta_group(i)%pfa_ratio, name='   PFA Ratio' )
        if ( associated(beta_group(i)%PFA_indices) ) then
          do j = lbound(beta_group(i)%PFA_indices,1), &
                 ubound(beta_group(i)%PFA_indices,1), 2
            call output ( j, before='   PFA Indices for sideband ', advance='yes' )
            call dump ( beta_group(i)%PFA_indices(j,:,:) )
          end do
d1163 1
a1163 1
      end if
d1313 3
@


2.64
log
@Moved a bunch of stuff that doesn't depend on the state vector here from
get_species data.  Some support for PFA, too.
@
text
@d182 1
a182 1
    & "$Id: ForwardModelConfig.f90,v 2.63 2004/11/05 19:38:11 vsnyder Exp $"
d1115 1
a1115 1
    use Output_m, only: Blanks, NewLine, Output
a1283 1
    use String_Table, only: Display_String
d1298 4
@


2.63
log
@Moved some stuff here from Get_Species_Data, more work on PFA, some rearranging
@
text
@d182 1
a182 1
    & "$Id: ForwardModelConfig.f90,v 2.62 2004/11/04 03:42:08 vsnyder Exp $"
a215 1
    use FilterShapes_m, only: DACSFilterShapes
d218 3
a220 3
    use MLSSets, only: FindFirst, Intersection, Union
    use MLSSignals_m, only: DisplaySignalName, MatchSignal
    use Output_m, only: Output
a226 2
    integer :: B                           ! Index for beta groups
    integer :: Channel
a229 14
    logical :: Hit                         ! Hit a molecule to be used
    integer :: HowManyPFA                  ! How many PFA data records are for the
                                           ! molecules in fwdModelConf%Molecules?
    integer :: I, Ier, J, K
    integer :: LBoundDACs, UBoundDACs      ! How many channels in a DAC
    integer :: M1, M2                      ! Matched signal indices
    integer :: NoUsedChannels, NoUsedDACS
    integer :: NumPFA                      ! Like HowManyPFA, but for one channel
    integer :: P                           ! Index for PFA molecules in a beta group
!   integer, pointer :: PFAWork(:,:)       ! PFA Indices for a channel.
!                                          ! Sideband X Molecules.
    integer :: SB                          ! Sideband index
    integer :: SigInd
    logical :: SignalFlag(size(fwdModelConf%signals))
a230 11
    integer, pointer :: T1(:), T2(:)       ! Temps for set operations
!   integer, pointer :: WhichMolecule(:)   ! To which element of config%molecules
!                                          ! does WhichPfa(i) correspond?
!   integer, pointer :: WhichPFA(:)        ! Which PFA data records are for the
!                                          ! molecules in fwdModelConf%Molecules?

    ! Shorthand pointers into fwdModelConf
    real(rp), dimension(:,:), pointer :: DACsStaging  ! Temporary space for DACS radiances
    integer, pointer :: USEDDACSSIGNALS(:) ! Indices in FwdModelConf_T%Signals
                                           ! of signals for our dacs
    type(channels_T), pointer :: Channels(:)
a245 1
    ! Compute NoUsedDACs
d247 2
d250 42
a291 27
    nullify ( DACsStaging, usedDACSSignals )!, whichPFA )
    signalFlag = .false.
    lBoundDACs = 0; uBoundDACs = 0
    noUsedDACs = 0
    do sigInd = 1, size(fwdModelConf%signals)
      if ( fwdModelConf%signals(sigInd)%dacs .and. &
        & .not. signalFlag(sigind) ) then
        signalFlag(sigind) = .true.
        noUsedDACs = noUsedDACs + 1
        if ( noUsedDACs == 1 ) then
          lBoundDACs = lbound(fwdModelConf%signals(sigInd)%frequencies,1 )
          uBoundDACs = ubound(fwdModelConf%signals(sigInd)%frequencies,1 )
        else
          if ( lBoundDACs /= lbound ( fwdModelConf%signals(sigInd)%frequencies,1 ) .or. &
            &  uBoundDACs /= ubound ( fwdModelConf%signals(sigInd)%frequencies,1 ) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Two DACS have different number of channels' )
        end if
      end if
    end do
    if ( noUsedDACs > 0 .and. .not. associated(DACsFilterShapes) ) &
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'DACS in use but no filter shapes provided.' )
    call allocate_test ( usedDACSSignals, noUsedDACs, 'usedDACSSignals', ModuleName )
    usedDACSSignals = pack ( (/ (i, i=1, size(signalFlag)) /), signalFlag )
    call allocate_test ( DACsStaging, uBoundDACs, noUsedDACs, &
      & 'DACsStaging', moduleName, low1 = lBoundDACs )
d293 13
a305 22
    ! Work out which channels are used.
    noUsedChannels = 0
    do sigInd = 1, size(fwdModelConf%signals)
      noUsedChannels = noUsedChannels + &
        & count( fwdModelConf%signals(sigInd)%channels )
    end do
    allocate ( channels(noUsedChannels), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'fwdModelConf%channels' )

    ! Collect channel information from signals database.
    channel = 0
    do sigInd = 1, size(fwdModelConf%signals)
      do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
        if ( fwdModelConf%signals(sigInd)%channels(i) ) then
          channel = channel + 1
          channels(channel)%origin = &
            & lbound ( fwdModelConf%signals(sigInd)%frequencies, 1 )
          channels(channel)%used = i + channels(channel)%origin - 1
          channels(channel)%signal = sigInd
          channels(channel)%dacs = FindFirst ( usedDACSSignals, sigind )
        end if
a306 1
    end do
d308 39
a346 32
    ! Hook the shortcuts into the structure
    fwdModelConf%channels => channels
    fwdModelConf%DACsStaging => DACsStaging
    fwdModelConf%usedDACSSignals => usedDACSSignals

    if ( associated(pfaData) ) then
      do b = 1, size(fwdModelConf%beta_group)
        call allocate_test ( fwdModelConf%beta_group(b)%pfa_indices, &
          & fwdModelConf%sidebandStop, &
          & size(fwdModelConf%channels), &
          & size(fwdModelConf%beta_group(b)%pfa_molecules), &
          & 'Beta_group(b)%PFA_indices', moduleName, &
          & lowBound_1=fwdModelConf%sidebandStart )
        fwdModelConf%beta_group(b)%pfa_indices = 0 ! OK if some missing, but no junk
        do p = 1, size(fwdModelConf%beta_group(b)%PFA_Molecules)
          do i = PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p)-1)+1, &
            &    PFA_by_molecule(fwdModelConf%beta_group(b)%PFA_Molecules(p))
            do sb = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2
              do channel = 1, size(channels)
                if ( matchSignal ( PFAData(sortPFAdata(i))%theSignal, &
                  &  fwdModelConf%signals(channels(channel)%signal), sideband=sb, &
                  &  channel=channels(channel)%used ) > 0 ) &
                    & fwdModelConf%beta_group(b)%pfa_indices(sb,channel,p) = &
                      & sortPFAdata(i)
              end do ! channel
            end do ! sb
          end do ! i (molecules)
        end do ! p
      end do ! b
    else
      do b = 1, size(fwdModelConf%beta_group)
        nullify ( fwdModelConf%beta_group(b)%pfa_indices ) ! Why is this needed?
d348 59
a406 1
    end if ! associated(pfaData)
d408 1
a408 1
!    if ( associated(pfaData) ) then
d410 2
a411 2
!      call allocate_test ( PFAWork, s2, size(fwdModelConf%molecules), &
!        & 'PFAWork', moduleName, lowBound_1=s1, lowBound_2=fwdModelConf%firstPFA )
d413 17
a429 15
!      ! Work out which PFA data are germane to fwdModelConf%Molecules
!      ! We do this because there are thousands of PFA data, but maybe only
!      ! a few that are germane to this fwdModelConf
!      howManyPFA = 0
!      do i = 1, size(pfaData)
!        hit = .false.
!        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
!          if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
!            if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
!              & DSBSSB=.true.) /= 0 ) then
!              if ( hit ) then
!                error = .true.
!                call MLSMessage ( MLSMSG_Warning, moduleName, &
!                  & 'Two molecules in same PFA Datum selected' )
!                call dump ( PFAData(whichPFA(j)), details=0 )
a430 1
!              hit = .true.
d432 2
a433 1
!          end if
d435 12
a446 13
!        if ( hit ) howManyPFA = howManyPFA + 1
!      end do
!      call allocate_test ( whichPFA, howManyPFA, 'whichPFA', moduleName )
!      call allocate_test ( whichMolecule, howManyPFA, 'whichMolecule', moduleName )
!      howManyPFA = 0
!      do i = 1, size(pfaData)
!        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
!          if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
!            if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
!              & DSBSSB=.true.) /= 0 ) then
!              howManyPFA = howManyPFA + 1
!              whichPFA(howManyPFA) = i
!              whichMolecule(howManyPFA) = j
d448 1
a448 1
!          end if
d450 9
a458 34
!      end do
!      ! Work out PFA abstracts for each channel
!      if ( .not. error ) then
!        do i = 1, size(channels)
!          PFAWork = 0
!          nullify ( t1, channels(i)%PFAMolecules, channels(i)%betaIndex )
!          call allocate_test ( channels(i)%PFAMolecules, 0, &
!            & 'channels(i)%PFAMolecules', moduleName ) ! so we can do unions
!          ! Where there is a signal and a molecule, make whichPFA negative.
!          ! Make sure that only one molecule is selected from each PFA Datum
!          do j = 1, howManyPFA
!            if ( channels(i)%used < lbound(PFAData(whichPFA(j))%theSignal%channels,1) .or. &
!                 channels(i)%used > ubound(PFAData(whichPFA(j))%theSignal%channels,1) ) cycle
!            if ( .not. PFAData(whichPFA(j))%theSignal%channels(channels(i)%used) ) cycle
!            if ( matchSignal ( fwdModelConf%signals(channels(i)%signal), &
!              &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true. ) == 0 ) cycle
!            t2 => intersection(fwdModelConf%molecules(fwdModelConf%firstPFA:), &
!              &                PFAData(whichPFA(j))%molecules)
!            if ( size(t2) == 0 ) cycle
!            whichPFA(j) = -whichPFA(j) ! Indicate above tests succeeded
!            t1 => union(channels(i)%PFAMolecules,t2)
!            call deallocate_test ( t2, 't2', moduleName )
!            call deallocate_test ( channels(i)%PFAMolecules, &
!              & 'channels(i)%PFAMolecules', moduleName )
!            channels(i)%PFAMolecules => t1
!          end do ! j = 1, howManyPFA
!          numPFA = size(channels(i)%PFAMolecules)
!          call allocate_test ( channels(i)%PFAIndex, s2, numPFA, &
!            & 'channels(i)%PFAIndex', moduleName, lowBound_1=s1 )
!          call allocate_test ( channels(i)%betaIndex, numPFA, &
!            & 'channels(i)%BetaIndex', moduleName )
!          channels(i)%betaIndex = 0 ! in case a dump is requested
!          ! Arrange the PFAData indices by sideband and molecule in PFAWork
!          do sb = s1, s2, 2
d460 14
a473 5
!              if ( whichPFA(j) > 0 ) cycle ! some test in previous loop failed
!              if ( matchSignal ( PFAData(-whichPFA(j))%theSignal, &
!                &  fwdModelConf%signals(channels(i)%signal), sideband=sb, &
!                &  channel=channels(i)%used ) > 0 ) &
!                  & PFAWork(sb,whichMolecule(j)) = -whichPFA(j)
d475 48
a522 9
!          end do ! sb = s1, s2
!          ! Copy nonzero columns of PFAWork to channels(i)%PFAIndex, which
!          ! has exactly the same number of columns as the number of PFAWork's
!          ! nonzero columns
!          k = 0
!          do j = lbound(pfawork,2), ubound(pfawork,2)
!            if ( pfawork(-1,j)+pfawork(+1,j) /= 0 ) then
!              k = k + 1
!              channels(i)%PFAIndex(s1:s2:2,k) = pfawork(s1:s2:2,j)
d524 46
a569 31
!          end do
!          ! Check whether we have PFA data for both sidebands if LBL is DSB
!          if ( s1 /= s2 ) then
!            do j = 1, numPFA
!              if ( channels(i)%PFAIndex(s1,j) * channels(i)%PFAIndex(s2,j) == 0 ) then
!  !             error = .true.
!                call MLSMessage ( MLSMSG_warning, moduleName, &
!                  & 'LBL signal is DSB but both PFAs are not available' )
!                call output ( channels(i)%used, before=' Channel ' )
!                call output ( ', LBL signal: ' )
!                call displaySignalName ( fwdModelConf%signals(channels(i)%signal), &
!                  & advance='yes' )
!                call output ( ' Available ' )
!                if ( channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j) == 0 ) then
!                  call output ( 'PFA Datum: None', advance='yes' )
!                else
!                  call dump ( PFAData( &
!                    & channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j)), &
!                    & index=channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j), &
!                    & details=0 )
!                end if
!              end if
!            end do ! j = 1, numPFA
!          end if
!          whichPFA = abs(whichPFA)
!        end do ! i = 1, size(channels)
!      end if
!      call deallocate_test ( PFAWork, 'PFAWork', moduleName )
!      call deallocate_test ( whichPFA, 'whichPFA', moduleName )
!      call deallocate_test ( whichMolecule, 'whichMolecule', moduleName )
!   end if ! associated(pfaData)
d571 115
a685 4
    if ( dumpFwm > 0 .or. error ) then
      call dump ( fwdModelConf, 'DeriveFromForwardModelConfig' )
      if ( dumpFwm > 1 .and. .not. error ) stop ! error message will stop later
    end if
d687 1
a687 3
    if ( error ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Unrecoverable errors in forward model configuration' )
d724 1
a724 1
    integer :: B, I, Ier
d741 2
d756 19
d1139 9
a1147 8
      if ( size(beta_group(i)%pfa_molecules) > 0 ) &
        & call dump ( beta_group(i)%pfa_ratio, name='   PFA Ratio' )
      if ( associated(beta_group(i)%PFA_indices) ) then
        do j = lbound(beta_group(i)%PFA_indices,1), &
               ubound(beta_group(i)%PFA_indices,1), 2
          call output ( j, before='   PFA Indices for sideband ', advance='yes' )
          call dump ( beta_group(i)%PFA_indices(j,:,:) )
        end do
d1299 3
@


2.62
log
@Provide for both LBL_Ratio and PFA_Ratio in beta_group
@
text
@d27 1
a27 1
  public :: Destroy_Beta_Group, DestroyFWMConfigDatabase, DestroyForwardModelDerived
d49 6
a57 2
    logical :: Derivatives = .false.  ! "Compute derivatives w.r.t. mixing ratio"
    logical :: Group = .false.        ! "Molecule group", i.e., [m,m1,...,mn]
d65 2
a66 2
    integer :: Molecule               ! Group name, i.e., "m".
    integer, pointer :: PFA_Indices(:,:,:) => NULL() ! Sidebands x size(Channels)
d68 2
a69 2
                                      ! PFADataBase%PFAData.  Allocated and filled
                                      ! in Get_Species_Data.
a76 1
    type(qtyStuff_t) :: Qty           ! The Qty's vector and foundInFirst
a93 10
  ! Now all of the derived stuff
  type, public :: ForwardModelDerived_T
    real(rp), dimension(:,:), pointer :: DACsStaging => NULL() ! Temporary
                                         ! space for DACS radiances
    integer, dimension(:), pointer :: USEDDACSSIGNALS => NULL() ! Indices in
                                         ! FwdModelConf_T%Signals
                                         ! of signals for our dacs
    type(channels_T), pointer, dimension(:) :: Channels => NULL()
  end type ForwardModelDerived_T

d173 5
a177 1
    type (forwardModelDerived_T) :: ForwardModelDerived
d182 1
a182 1
    & "$Id: ForwardModelConfig.f90,v 2.61 2004/11/03 01:25:30 vsnyder Exp $"
d222 2
a223 1
    use PFADataBase_m, only: Dump, PFAData, SortPFAData, Sort_PFADataBase
d242 2
a243 2
    integer, pointer :: PFAWork(:,:)       ! PFA Indices for a channel.
                                           ! Sideband X Molecules.
d249 4
a252 4
    integer, pointer :: WhichMolecule(:)   ! To which element of config%molecules
                                           ! does WhichPfa(i) correspond?
    integer, pointer :: WhichPFA(:)        ! Which PFA data records are for the
                                           ! molecules in fwdModelConf%Molecules?
d254 1
a254 1
    ! Shorthand pointers into fwdModelConf%forwardModelDerived
d277 1
a277 1
    nullify ( DACsStaging, usedDACSSignals, whichPFA )
d313 1
a313 1
      & MLSMSG_Allocate//'fwdModelConf%forwardModelDerived%channels' )
d316 1
a316 1
    channel = 1
d320 1
a325 1
          channel = channel + 1
d330 5
d337 7
d345 12
d359 7
d487 1
a487 6
    end if ! associated(pfaData)

    ! Hook the shortcuts into the structure
    fwdModelConf%forwardModelDerived%channels => channels
    fwdModelConf%forwardModelDerived%DACsStaging => DACsStaging
    fwdModelConf%forwardModelDerived%usedDACSSignals => usedDACSSignals
a499 35
  ! -----------------------------------------  Destroy_Beta_Group  -----
  subroutine Destroy_Beta_Group ( Beta_Group )

  ! Destroy the catalog extract prepared by Get_Species_Data

    use Allocate_Deallocate, only: DEALLOCATE_TEST
    use MLSMessageModule, only: MLSMessage, MLSMSG_Deallocate, MLSMSG_Error

    type(beta_group_t), pointer :: Beta_Group(:)

    integer :: I

    if ( .not. associated(beta_group) ) return

    do i = 1, size(beta_group)
      call deallocate_test ( beta_group(i)%cat_index, 'beta_group(i)%cat_index', &
        & moduleName )
      call deallocate_test ( beta_group(i)%lbl_molecules, 'beta_group(i)%LBL_molecules', &
        & moduleName )
      call deallocate_test ( beta_group(i)%lbl_ratio, 'beta_group(i)%LBL_ratio', &
        & moduleName )
      call deallocate_test ( beta_group(i)%PFA_indices, 'beta_group(i)%PFA_indices', &
        & moduleName )
      call deallocate_test ( beta_group(i)%pfa_molecules, 'beta_group(i)%PFA_molecules', &
        & moduleName )
      call deallocate_test ( beta_group(i)%pfa_ratio, 'beta_group(i)%PFA_ratio', &
        & moduleName )
    end do

    deallocate ( beta_group, stat=i )
    if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Deallocate // 'beta_group' )

  end subroutine Destroy_Beta_Group

d526 1
a526 1
    ! Destroy FwdModelConf%ForwardModelDerived
d533 1
a533 1
    integer :: I, Ier
d535 2
a536 2
    if ( associated(fwdModelConf%forwardModelDerived%channels) ) then
      do i = 1, size(fwdModelConf%forwardModelDerived%channels)
d538 2
a539 2
          & fwdModelConf%forwardModelDerived%channels(i)%PFAIndex, &
          & 'fwdModelConf%forwardModelDerived%channels(i)%PFAIndex', moduleName )
d541 2
a542 2
          & fwdModelConf%forwardModelDerived%channels(i)%PFAMolecules, &
          & 'fwdModelConf%forwardModelDerived%channels(i)%PFAMolecules', moduleName )
d544 2
a545 2
          & fwdModelConf%forwardModelDerived%channels(i)%betaIndex, &
          & 'fwdModelConf%forwardModelDerived%channels(i)%BetaIndex', moduleName )
d547 1
a547 1
      deallocate ( fwdModelConf%forwardModelDerived%channels, stat = ier )
d549 1
a549 1
        & MLSMSG_DeAllocate//'fwdModelConf%forwardModelDerived%channels' )
d552 4
a555 2
    call deallocate_test ( fwdModelConf%forwardModelDerived%DACSStaging, &
      & 'fwdModelConf%forwardModelDerived%DACSStaging', moduleName )
d557 5
a561 2
    call deallocate_test ( fwdModelConf%forwardModelDerived%usedDACSSignals, &
      & 'fwdModelConf%forwardModelDerived%usedDACSSignals', moduleName )
d853 1
d860 13
a895 1
    call destroyForwardModelDerived ( config )
a923 1
        if ( associated ( beta_group(i)%qty%qty ) ) call dump ( beta_group(i)%qty )
d925 1
a925 2
        if ( associated ( beta_group(i)%cat_index ) ) &
          & call dump ( beta_group(i)%cat_index, name='   Cat_Index' )
d927 2
a929 1
        call dump ( beta_group(i)%pfa_ratio, name='   PFA Ratio' )
d936 1
d1036 3
a1038 4
    if ( associated(Config%forwardModelDerived%usedDACSSignals) ) &
      call dump  ( Config%forwardModelDerived%usedDACSSignals, &
        & name='   Used DACS Signals' )
    if ( associated(Config%forwardModelDerived%channels) ) then
d1040 5
a1044 5
      do j = 1, size(Config%forwardModelDerived%channels)
        call output ( Config%forwardModelDerived%channels(j)%used, before='    Used: ' )
        call output ( Config%forwardModelDerived%channels(j)%origin, before='    Origin: ' )
        call output ( Config%forwardModelDerived%channels(j)%signal, before='    Signal: ' )
        call output ( Config%forwardModelDerived%channels(j)%DACS, before='    DACS: ', &
d1046 2
a1047 2
        if ( associated(Config%forwardModelDerived%channels(j)%PFAIndex) ) &
          & call dump ( Config%forwardModelDerived%channels(j)%PFAIndex(-1:1:2,:), &
d1049 1
a1049 1
        if ( associated(Config%forwardModelDerived%channels(j)%PFAMolecules) ) then
d1051 1
a1051 1
          if ( size(Config%forwardModelDerived%channels(j)%PFAMolecules) == 0 ) &
d1053 1
a1053 1
          do i = 1, size(Config%forwardModelDerived%channels(j)%PFAMolecules)
d1056 1
a1056 1
              & lit_indices(Config%forwardModelDerived%channels(j)%PFAMolecules(i)), &
d1058 2
a1059 2
            if ( Config%forwardModelDerived%channels(j)%betaIndex(i) /= 0 ) &
              & call output ( Config%forwardModelDerived%channels(j)%betaIndex(i), &
d1086 3
@


2.61
log
@Don't deallocate config%molecules -- it's a pointer into beta_group
@
text
@d57 4
d69 4
a73 4
    real(rp), pointer :: Ratio(:) => NULL() ! 1:size(LBL_Molecules).  Isotope
                                      ! ratio. Allocated with size == 1 and
                                      ! value == 1.0 if not a group.  Allocated
                                      ! and filled in Get_Species_Data.
d185 1
a185 1
    & "$Id: ForwardModelConfig.f90,v 2.60 2004/11/01 20:18:23 vsnyder Exp $"
d230 1
d243 1
d268 2
d332 5
a336 1
!    if ( associated(pfaData) ) then
d458 1
a458 1
!    end if ! associated(pfaData)
d495 2
d501 1
a501 1
      call deallocate_test ( beta_group(i)%ratio, 'beta_group(i)%ratio', &
d918 1
a918 1
        call dump ( beta_group(i)%ratio, name='   Ratio' )
d923 1
d1080 3
@


2.60
log
@Reorganization of representation for molecules and beta groups
@
text
@d181 1
a181 1
    & "$Id: ForwardModelConfig.f90,v 2.59 2004/10/06 21:23:50 vsnyder Exp $"
d869 1
a869 2
    call deallocate_test ( config%molecules, &
      & "config%molecules", moduleName )
d1065 3
@


2.59
log
@More work on PFA data structures
@
text
@a10 1

d13 2
d22 2
a23 1
    module procedure Dump_ForwardModelConfig, Dump_ForwardModelConfigDatabase
d27 2
a28 2
  public :: DestroyFWMConfigDatabase, DestroyForwardModelDerived, Dump
  public :: NullifyForwardModelConfig
d34 37
a70 3
  ! PVMPackFWMConfig and PVMUnpackFWMConfig.  Rather, they are computed
  ! by ForwardModelDerive when a ForwardModelConfig_T is created, or
  ! when arrives by way of PVMUnpackFWMConfig
d96 2
a97 2
  
  ! These components are sorted in the order they are to make the packing
a115 1
    integer :: FirstPFA               ! Index of first PFA in Molecules
d131 1
d162 3
d169 7
d181 1
a181 1
    & "$Id: ForwardModelConfig.f90,v 2.58 2004/09/01 00:32:40 vsnyder Exp $"
d324 123
a446 123
    if ( associated(pfaData) ) then

      call allocate_test ( PFAWork, s2, size(fwdModelConf%molecules), &
        & 'PFAWork', moduleName, lowBound_1=s1, lowBound_2=fwdModelConf%firstPFA )

      ! Work out which PFA data are germane to fwdModelConf%Molecules
      ! We do this because there are thousands of PFA data, but maybe only
      ! a few that are germane to this fwdModelConf
      howManyPFA = 0
      do i = 1, size(pfaData)
        hit = .false.
        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
          if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
            if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
              & DSBSSB=.true.) /= 0 ) then
              if ( hit ) then
                error = .true.
                call MLSMessage ( MLSMSG_Warning, moduleName, &
                  & 'Two molecules in same PFA Datum selected' )
                call dump ( PFAData(whichPFA(j)), details=0 )
              end if
              hit = .true.
            end if
          end if
        end do
        if ( hit ) howManyPFA = howManyPFA + 1
      end do
      call allocate_test ( whichPFA, howManyPFA, 'whichPFA', moduleName )
      call allocate_test ( whichMolecule, howManyPFA, 'whichMolecule', moduleName )
      howManyPFA = 0
      do i = 1, size(pfaData)
        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules) - 1
          if ( any(fwdModelConf%molecules(j) == PFAData(i)%molecules) ) then
            if ( matchSignal(fwdModelConf%signals, PFAData(i)%theSignal, &
              & DSBSSB=.true.) /= 0 ) then
              howManyPFA = howManyPFA + 1
              whichPFA(howManyPFA) = i
              whichMolecule(howManyPFA) = j
            end if
          end if
        end do
      end do
      ! Work out PFA abstracts for each channel
      if ( .not. error ) then
        do i = 1, size(channels)
          PFAWork = 0
          nullify ( t1, channels(i)%PFAMolecules, channels(i)%betaIndex )
          call allocate_test ( channels(i)%PFAMolecules, 0, &
            & 'channels(i)%PFAMolecules', moduleName ) ! so we can do unions
          ! Where there is a signal and a molecule, make whichPFA negative.
          ! Make sure that only one molecule is selected from each PFA Datum
          do j = 1, howManyPFA
            if ( channels(i)%used < lbound(PFAData(whichPFA(j))%theSignal%channels,1) .or. &
                 channels(i)%used > ubound(PFAData(whichPFA(j))%theSignal%channels,1) ) cycle
            if ( .not. PFAData(whichPFA(j))%theSignal%channels(channels(i)%used) ) cycle
            if ( matchSignal ( fwdModelConf%signals(channels(i)%signal), &
              &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true. ) == 0 ) cycle
            t2 => intersection(fwdModelConf%molecules(fwdModelConf%firstPFA:), &
              &                PFAData(whichPFA(j))%molecules)
            if ( size(t2) == 0 ) cycle
            whichPFA(j) = -whichPFA(j) ! Indicate above tests succeeded
            t1 => union(channels(i)%PFAMolecules,t2)
            call deallocate_test ( t2, 't2', moduleName )
            call deallocate_test ( channels(i)%PFAMolecules, &
              & 'channels(i)%PFAMolecules', moduleName )
            channels(i)%PFAMolecules => t1
          end do ! j = 1, howManyPFA
          numPFA = size(channels(i)%PFAMolecules)
          call allocate_test ( channels(i)%PFAIndex, s2, numPFA, &
            & 'channels(i)%PFAIndex', moduleName, lowBound_1=s1 )
          call allocate_test ( channels(i)%betaIndex, numPFA, &
            & 'channels(i)%BetaIndex', moduleName )
          channels(i)%betaIndex = 0 ! in case a dump is requested
          ! Arrange the PFAData indices by sideband and molecule in PFAWork
          do sb = s1, s2, 2
            do j = 1, howManyPFA
              if ( whichPFA(j) > 0 ) cycle ! some test in previous loop failed
              if ( matchSignal ( PFAData(-whichPFA(j))%theSignal, &
                &  fwdModelConf%signals(channels(i)%signal), sideband=sb, &
                &  channel=channels(i)%used ) > 0 ) &
                  & PFAWork(sb,whichMolecule(j)) = -whichPFA(j)
            end do ! j = 1, howManyPFA
          end do ! sb = s1, s2
          ! Copy nonzero columns of PFAWork to channels(i)%PFAIndex, which
          ! has exactly the same number of columns as the number of PFAWork's
          ! nonzero columns
          k = 0
          do j = lbound(pfawork,2), ubound(pfawork,2)
            if ( pfawork(-1,j)+pfawork(+1,j) /= 0 ) then
              k = k + 1
              channels(i)%PFAIndex(s1:s2:2,k) = pfawork(s1:s2:2,j)
            end if
          end do
          ! Check whether we have PFA data for both sidebands if LBL is DSB
          if ( s1 /= s2 ) then
            do j = 1, numPFA
              if ( channels(i)%PFAIndex(s1,j) * channels(i)%PFAIndex(s2,j) == 0 ) then
  !             error = .true.
                call MLSMessage ( MLSMSG_warning, moduleName, &
                  & 'LBL signal is DSB but both PFAs are not available' )
                call output ( channels(i)%used, before=' Channel ' )
                call output ( ', LBL signal: ' )
                call displaySignalName ( fwdModelConf%signals(channels(i)%signal), &
                  & advance='yes' )
                call output ( ' Available ' )
                if ( channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j) == 0 ) then
                  call output ( 'PFA Datum: None', advance='yes' )
                else
                  call dump ( PFAData( &
                    & channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j)), &
                    & index=channels(i)%PFAIndex(s1,j) + channels(i)%PFAIndex(s2,j), &
                    & details=0 )
                end if
              end if
            end do ! j = 1, numPFA
          end if
          whichPFA = abs(whichPFA)
        end do ! i = 1, size(channels)
      end if
      call deallocate_test ( PFAWork, 'PFAWork', moduleName )
      call deallocate_test ( whichPFA, 'whichPFA', moduleName )
      call deallocate_test ( whichMolecule, 'whichMolecule', moduleName )
    end if ! associated(pfaData)
d464 33
a568 1
    use PVM, only: PVMErrorMessage
a574 1
    integer :: INFO                     ! Flag from PVM
d579 6
a584 12
    call PVMPackStringIndex ( config%name, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig name" )
    call PVMPackLitIndex ( config%cloud_der, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig cloud_der" )
    call PVMPackLitIndex ( config%fwmType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig fwmType" )
    call PVMPackLitIndex ( config%i_saturation, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig i_saturation" )
    call PVMPackLitIndex ( config%instrumentModule, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig instrumentModule" )
    call PVMPackLitIndex ( config%windowUnits, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig windowUnits" )
d593 1
a593 2
      & config%surfaceTangentIndex /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig integers" )
d597 7
a603 8
      & config%allLinesForRadiometer, config%atmos_der, &
      & config%default_spectroscopy, config%differentialScan,&
      & config%do_1d, config%do_baseline, config%do_conv, &
      & config%do_freq_avg, config%forceFoldedOutput, config%forceSidebandFraction, &
      & config%globalConfig, config%incl_cld, &
      & config%lockBins, config%polarized, config%skipOverlaps, &
      & config%spect_Der, config%temp_Der /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig logicals" )
d606 2
a607 2
    call PVMIDLPack ( (/ config%phiWindow, config%tolerance /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig reals" )
d612 2
a613 4
      call PVMIDLPack ( size ( config%binSelectors ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of binSelectors" )
      call PVMIDLPack ( config%binSelectors, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing binSelectors" )
d615 1
a615 2
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 binSelectors" )
d620 1
a620 4
      call PVMIDLPack ( size ( config%molecules ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of molecules" )
      call PVMIDLPack ( config%firstPFA, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing index of first PFA molecule" )
d623 3
a625 4
          call PVMPackLitIndex ( abs ( config%molecules(i) ), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "Packing a molecule" )
          call PVMIDLPack ( (config%molecules(i) .gt. 0.0), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "Packing molecule sign" )
d627 1
a627 2
        call PVMIDLPack ( config%moleculeDerivatives, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Packing molecule derivatives" )
d630 1
a630 2
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 molecules" )
d635 3
a637 4
      call PVMIDLPack ( size ( config%specificQuantities ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of specificQuantities" )
      call PVMIDLPack ( config%specificQuantities, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing specificQuantities" )
d639 1
a639 2
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 specificQuantities" )
d644 1
a644 2
      call PVMIDLPack ( size ( config%signals ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of signals" )
d649 1
a649 2
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 signals" )
d654 1
a654 2
      & associated ( config%tangentGrid ) /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing vGrid flags" )
a664 1
    use PVM, only: PVMErrorMessage
d675 3
a677 3
    logical, dimension(17) :: LS        ! Temporary array
    integer, dimension(10) :: IS         ! Temporary array
    real(r8), dimension(2) :: RS        ! Temporary array
d683 7
a689 12
    call PVMUnpackStringIndex ( config%name, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig name" )
    call PVMUnpackLitIndex ( config%cloud_der, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig cloud_der" )
    call PVMUnpackLitIndex ( config%fwmType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig fwmType" )
    call PVMUnpackLitIndex ( config%i_saturation, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig i_saturation" )
    call PVMUnpackLitIndex ( config%instrumentModule, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig instrumentModule" )
    call PVMUnpackLitIndex ( config%windowUnits, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig windowUnits" )
d692 1
a692 2
    call PVMIDLUnpack ( is, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig integers" )
d708 1
a708 2
    call PVMIDLUnpack ( ls, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig logicals" )
d711 2
d728 1
d732 1
a732 2
    call PVMIDLUnpack ( rs, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig reals" )
d739 1
a739 2
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of specific quantities" )
d743 1
a743 2
      call PVMIDLUnpack ( config%binSelectors, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking binSelectors" )
d747 1
a747 4
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of molecules" )
    call PVMIDLUnpack ( config%firstPFA, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking index of PFA molecule" )
d753 2
a754 4
        call PVMUnpackLitIndex ( config%molecules(i), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a molecule" )
        call PVMIDLUnpack ( flag, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a molecule sign flag" )
d758 1
a758 2
      call PVMIDLUnpack ( config%moleculeDerivatives, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking moleculeDerivatives" )
d762 1
a762 2
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of specific quantities" )
d766 1
a766 2
      call PVMIDLUnpack ( config%specificQuantities, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking specific quantities" )
d770 1
a770 2
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of signals" )
d781 1
a781 2
    call PVMIDLUnpack ( ls(1:2), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking vGrid flags" )
a870 2
    call deallocate_test ( config%moleculeDerivatives, &
      & "config%moleculeDerivatives", moduleName )
d878 41
d987 1
a992 1
        if ( j == config%firstPFA ) call output ( 'PFA: ' )
d1048 11
d1066 3
@


2.58
log
@Add PFAIndex field, polish up the dump routines
@
text
@d42 1
a42 1
    integer, pointer :: PFAData(:,:) => NULL()    ! Sidebands X numPFA
d44 5
a48 4
    integer, pointer :: PFAMolecules(:) => NULL() ! L_... from PFAData for this channel
    integer, pointer :: PFAIndex(:) => NULL()     ! Allocated here but filled
                          ! later; PFAIndex(i) is second subscript for
                          ! beta_path for PFAMolecules(i).
d135 1
a135 1
    & "$Id: ForwardModelConfig.f90,v 2.57 2004/08/07 01:17:26 vsnyder Exp $"
d170 2
a171 1
    use MLSMessageModule, only: MLSMessage,  MLSMSG_Allocate, MLSMSG_Error
d173 3
a175 2
    use MLSSignals_M, only: MatchSignal
    use PFADataBase_m, only: PFAData
d181 4
d187 1
a187 1
    integer :: I, Ier, J
d192 3
d199 2
a203 1

d210 8
d279 4
d288 1
d290 12
a301 2
          howManyPFA = howManyPFA + &
            & count(fwdModelConf%molecules(j) == PFAData(i)%molecules)
d303 1
d306 1
d311 6
a316 2
            howManyPFA = howManyPFA + 1
            whichPFA(howManyPFA) = i
a319 1

d321 72
a392 43
      do i = 1, size(channels)
        numPFA = 0
        nullify ( t1, channels(i)%PFAMolecules, channels(i)%PFAIndex )
        call allocate_test ( channels(i)%PFAMolecules, 0, &
          & 'channels(i)%PFAMolecules', moduleName ) ! so we can do unions
        do j = 1, howManyPFA
          if ( channels(i)%used < lbound(PFAData(whichPFA(j))%theSignal%channels,1) .or. &
               channels(i)%used > lbound(PFAData(whichPFA(j))%theSignal%channels,1) ) cycle
          if ( .not. PFAData(whichPFA(j))%theSignal%channels(channels(i)%used) ) cycle
          if ( matchSignal ( &
            &  fwdModelConf%signals(channels(i)%signal:channels(i)%signal), &
            &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true. ) == 0 ) cycle
          numPFA = numPFA + 1
          t2 => intersection(fwdModelConf%molecules(fwdModelConf%firstPFA:), &
            &                PFAData(whichPFA(j))%molecules)
          t1 => union(channels(i)%PFAMolecules,t2)
          call deallocate_test ( t2, 't2', moduleName )
          call deallocate_test ( channels(i)%PFAMolecules, &
            & 'channels(i)%PFAMolecules', moduleName )
          channels(i)%PFAMolecules => t1
        end do
        allocate ( channels(i)%PFAData(s1:s2,numPFA), stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Allocate//'channels(i)%PFAData' )
        channels(i)%PFAData = 0
        call allocate_test ( channels(i)%PFAIndex, size(channels(i)%PFAMolecules), &
          & 'channels(i)%PFAIndex', moduleName )
        channels(i)%PFAIndex = 0
        numPFA = 0
        do j = 1, howManyPFA
          if ( channels(i)%used < lbound(PFAData(whichPFA(j))%theSignal%channels,1) .or. &
               channels(i)%used > lbound(PFAData(whichPFA(j))%theSignal%channels,1) ) cycle
          if ( .not. PFAData(whichPFA(j))%theSignal%channels(channels(i)%used) ) cycle
          m1 = matchSignal ( &
            &  fwdModelConf%signals(channels(i)%signal:channels(i)%signal), &
            &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true., sideband=s1 )
          m2 = matchSignal ( &
            &  fwdModelConf%signals(channels(i)%signal:channels(i)%signal), &
            &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true., sideband=s2 )
          if ( m1 + m2 /= 0 ) then
            numPFA = numPFA + 1
            if ( m1 /= 0 ) channels(i)%PFAData(s1,numPFA) = whichPFA(j)
            if ( m2 /= 0 ) channels(i)%PFAData(s2,numPFA) = whichPFA(j)
d394 6
a399 3
        end do
      end do
      call deallocate_test ( whichPFA, 'HowManyPfa', moduleName )
d407 8
a414 1
    if ( index(switches,'fwmd') /= 0 ) call dump ( fwdModelConf, 'DeriveFromForwardModelConfig' )
d456 2
a457 2
          & fwdModelConf%forwardModelDerived%channels(i)%PFAData, &
          & 'fwdModelConf%forwardModelDerived%channels(i)%PFAData', moduleName )
d462 2
a463 2
          & fwdModelConf%forwardModelDerived%channels(i)%PFAIndex, &
          & 'fwdModelConf%forwardModelDerived%channels(i)%PFAIndex', moduleName )
d477 1
d487 1
a487 1
  ! ------------------------------------------- PVMPackFwmConfig --------
d950 2
a951 2
        if ( associated(Config%forwardModelDerived%channels(j)%PFAData) ) &
          & call dump ( Config%forwardModelDerived%channels(j)%PFAData(-1:1:2,:), &
d962 2
a963 2
            if ( Config%forwardModelDerived%channels(j)%PFAIndex(i) /= 0 ) &
              & call output ( Config%forwardModelDerived%channels(j)%PFAIndex(i), &
d979 3
@


2.57
log
@Forgot an advance='yes' in a dump routine
@
text
@d43 1
a43 1
                                                  ! Indices in PFADataBase%PFAData
d45 3
d134 1
a134 1
    & "$Id: ForwardModelConfig.f90,v 2.56 2004/08/05 20:57:52 vsnyder Exp $"
d284 1
a284 1
        nullify ( t1, channels(i)%PFAMolecules )
d291 1
a291 1
          if ( .not. matchSignal ( &
d293 1
a293 1
            &  PFAData(whichPFA(j))%theSignal, DSBSSB=.true. ) /= 0) cycle
d307 3
d336 1
a336 1
    if ( index(switches,'fwmd') /= 0 ) call dump ( fwdModelConf )
d383 3
d788 1
a788 1
  subroutine Dump_ForwardModelConfig ( Config )
d796 2
a797 1
    type (ForwardModelConfig_T):: Config
d806 6
a811 1
    call display_string ( Config%name, advance='yes' )
d834 1
d840 4
d872 1
a872 1
          & call dump ( Config%forwardModelDerived%channels(j)%PFAData, &
d883 3
d900 3
@


2.56
log
@Put a sentinel at the end of %molecules
@
text
@d131 1
a131 1
    & "$Id: ForwardModelConfig.f90,v 2.55 2004/08/03 21:40:06 vsnyder Exp $"
d849 2
a850 1
        call output ( Config%forwardModelDerived%channels(j)%DACS, before='    DACS: ' )
d877 3
@


2.55
log
@Inching further toward PFA
@
text
@d117 2
a118 1
      ! >0 = beginning of a group or a lonesome molecule, <0 = member of a group
d131 1
a131 1
    & "$Id: ForwardModelConfig.f90,v 2.54 2004/07/16 19:13:18 vsnyder Exp $"
d262 1
a262 1
        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules)
d270 1
a270 1
        do j = fwdModelConf%firstPFA, size(fwdModelConf%molecules)
d471 1
a471 1
        do i = 1, size(config%molecules)
d620 1
a620 1
      do i = 1, n
d627 1
d819 1
a819 1
      do j = 1, size(Config%molecules)
d876 3
@


2.54
log
@Correct problem in dump routine
@
text
@d42 2
a43 1
    integer, pointer :: PFAData(:) => NULL()      ! Indices in PFADataBase%PFAData
d130 1
a130 1
    & "$Id: ForwardModelConfig.f90,v 2.53 2004/07/08 02:35:29 vsnyder Exp $"
d169 1
d174 2
d178 1
a178 2
    integer :: HowManyPFA                  ! How many PFA data records are for the
                                           ! molecules in fwdModelConf%Molecules?
d182 2
a183 1
    logical :: signalFlag(size(fwdModelConf%signals))
d195 3
d259 8
a266 1
      call allocate_test ( whichPFA, size(fwdModelConf%molecules) - fwdModelConf%firstPFA + 1, 'whichPFA', moduleName )
d284 14
a297 12
          if ( matchSignal ( &
            & fwdModelConf%signals(channels(i)%signal:channels(i)%signal), &
            & PFAData(whichPFA(j))%theSignal ) /= 0 ) then
            numPFA = numPFA + 1
            t2 = intersection(fwdModelConf%molecules(fwdModelConf%firstPFA:),&
              &               PFAData(whichPFA(j))%molecules)
            t1 = union(channels(i)%PFAMolecules,t2)
            call deallocate_test ( t2, 't2', moduleName )
            call deallocate_test ( channels(i)%PFAMolecules, &
              & 'channels(i)%PFAMolecules', moduleName )
            channels(i)%PFAMolecules => t1
          end if
d299 4
a302 2
        call allocate_test ( channels(i)%PFAData, numPFA, 'channels(i)%PFAData', &
          & moduleName )
d305 10
a314 3
          if ( matchSignal ( &
            & fwdModelConf%signals(channels(i)%signal:channels(i)%signal), &
            & PFAData(whichPFA(j))%theSignal ) /= 0 ) then
d316 2
a317 1
            channels(i)%PFAData(numPFA) = whichPFA(j)
d329 2
d781 1
a781 1
!   use MLSSignals_M, only: GetSignalName, MaxSigLen
d789 1
a789 1
!   character (len=MaxSigLen) :: SignalName  ! A line of text
d831 3
a833 3
      !call GetSignalName( signal=Config%signals(j), signalName)
      !??? Sort this out later!
      ! call output ( signalName//' channelIncluded:', advance='yes')
d837 1
a837 1
    call output ( '  ForwardModelDerived:', advance='yes')
d842 1
a842 1
      call output ( '   Channel info:' )
d853 2
d874 3
@


2.53
log
@Put all line-by-line molecules before PFA ones
@
text
@d129 1
a129 1
    & "$Id: ForwardModelConfig.f90,v 2.52 2004/06/23 02:14:06 vsnyder Exp $"
d792 2
a793 1
        call display_string(lit_indices(Config%molecules(j)))
d844 3
@


2.52
log
@Added PFA stuff, some cannonball polishing
@
text
@d75 1
d78 1
a85 1
    integer :: Ntimes = 0	      ! Number of times calling FullForwardModel
a97 1
    logical :: GlobalConfig           ! If set is shared between all chunks
d100 1
d116 2
a117 1
    integer, dimension(:), pointer :: PFAMolecules=>NULL() ! Which molecules to PFA
d119 1
a119 2
    logical, dimension(:), pointer :: MoleculeDerivatives=>NULL() ! Want jacobians
    ! Now the types
d129 1
a129 1
    & "$Id: ForwardModelConfig.f90,v 2.51 2004/06/11 01:33:29 vsnyder Exp $"
d165 1
a165 1
    use MLSSets, only: FindFirst, Intersect, Intersection, Union
d175 1
a175 1
                                           ! molecules in fwdModelConf%pfaMolecules?
d182 1
a182 1
                                           ! molecules in fwdModelConf%pfaMolecules?
d249 1
a249 1
      ! Work out which PFA data are germane to fwdModelConf%PFAMolecules
d252 1
d255 6
a260 10
        if ( intersect(fwdModelConf%PFAMolecules, PFAData(i)%molecules) ) &
          & howManyPFA = howManyPFA + 1
      end do
      call allocate_test ( whichPFA, howManyPfa, 'HowManyPfa', moduleName )
      howManyPFA = 0
      do i = 1, size(pfaData)
        if ( intersect(fwdModelConf%PFAMolecules, PFAData(i)%molecules) ) then
          howManyPFA = howManyPFA + 1
          whichPFA(howManyPFA) = i
        end if
d274 2
a275 1
            t2 = intersection(fwdModelConf%pfaMolecules,PFAData(whichPFA(j))%molecules)
d366 2
a367 9
    ! Executable code
    nullify ( f%molecules )
    nullify ( f%moleculeDerivatives )
    nullify ( f%pfaMolecules )
    nullify ( f%signals )
    nullify ( f%integrationGrid )
    nullify ( f%tangentGrid )
    nullify ( f%specificQuantities )
    nullify ( f%binSelectors )
d439 2
a455 10
    ! PFA Molecules -- field is always associated, even if with zero size.
    call PVMIDLPack ( size ( config%pfaMolecules ), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of PFA molecules" )
    if ( size ( config%pfaMolecules ) > 0 ) then
      do i = 1, size(config%pfaMolecules)
        call PVMPackLitIndex ( config%molecules(i), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Packing a PFA molecule" )
      end do
    end if

d585 2
a601 9
    ! PFA Molecules
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of PFA molecules" )
    call Allocate_test ( config%pfaMolecules, n, 'config%pfaMolecules', ModuleName )
    do i = 1, n
      call PVMUnpackLitIndex ( config%pfaMolecules(i), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a PFA molecule" )
    end do

a717 2
    call deallocate_test ( config%pfaMolecules, &
      & "config%pfaMolecules", moduleName )
d791 1
a799 7
    if ( associated(Config%pfaMolecules) ) then
      call output ( '  PFA Molecules: ', advance='yes' )
      do j = 1, size(Config%pfaMolecules)
        call output ( '    ' )
        call display_string ( lit_indices(Config%pfaMolecules(j)), advance='yes')
      end do
    end if
d843 3
@


2.51
log
@Declare all pointer components to be initially NULL
@
text
@d128 1
a128 1
    & "$Id: ForwardModelConfig.f90,v 2.50 2004/06/10 00:59:55 vsnyder Exp $"
d161 1
a161 1
    use Allocate_Deallocate, only: Allocate_Test
d164 1
a164 1
    use MLSSets, only: FindFirst
d171 1
a171 1
    integer :: I, Ier
d173 2
d176 1
d179 3
d194 1
a194 1
    nullify ( DACsStaging, usedDACSSignals )
d247 51
a297 3
    ! Work out PFA abstracts for each channel
    do i = 1, size(channels)
    end do
d339 1
a339 1
    integer :: Ier
d342 8
d462 8
a469 13
    ! PFA Molecules
    if ( associated ( config%pfaMolecules ) ) then
      call PVMIDLPack ( size ( config%pfaMolecules ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of PFA molecules" )
      if ( size ( config%pfaMolecules ) > 0 ) then
        do i = 1, size(config%pfaMolecules)
          call PVMPackLitIndex ( config%molecules(i), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "Packing a PFA molecule" )
        end do
      end if
    else
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 PFA molecules" )
d619 5
a623 7
    if ( n > 0 ) then
      call Allocate_test ( config%pfaMolecules, n, 'config%pfaMolecules', ModuleName )
      do i = 1, n
        call PVMUnpackLitIndex ( config%pfaMolecules(i), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a PFA molecule" )
      end do
    end if
d779 1
a779 1
    use Output_M, only: Output
d785 1
a785 1
    integer ::  J                          ! Loop counters
d828 1
a828 1
        call display_string(lit_indices(Config%pfaMolecules(j)),advance='yes')
d838 27
d874 3
@


2.50
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d42 2
a43 2
    integer, pointer :: PFAData(:)       ! Indices in PFADataBase%PFAData
    integer, pointer :: PFAMolecules(:)  ! L_... from PFAData for this channel
d48 3
a50 2
    real(rp), dimension(:,:), pointer :: DACsStaging  ! Temporary space for DACS radiances
    integer, dimension(:), pointer :: USEDDACSSIGNALS ! Indices in
d128 1
a128 1
    & "$Id: ForwardModelConfig.f90,v 2.49 2004/05/26 23:54:14 vsnyder Exp $"
d792 3
@


2.49
log
@Don't dump the database if it's not allocated
@
text
@d12 1
a12 1
  use MLSCommon, only: R8
d24 2
a25 1
  public :: AddForwardModelConfigToDatabase, DestroyFWMConfigDatabase, Dump
d31 25
a55 1
  ! These arguments are sorted in the order they are to make the packing
d117 1
a117 1
    ! Finally the types
d121 2
d127 1
a127 1
    & "$Id: ForwardModelConfig.f90,v 2.48 2004/05/01 04:00:59 vsnyder Exp $"
d157 2
a158 5
  ! --------------------------  StripForwardModelConfigDatabase --------
  subroutine StripForwardModelConfigDatabase ( database )
    ! This routine removes the non-global forward model configs from the database
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, &
      & MLSMSG_Deallocate, MLSMSG_Error
d160 79
a238 2
    ! Dummy arguments
    type (ForwardModelConfig_T), dimension(:), pointer :: DATABASE
d240 2
a241 11
    ! Local variables
    type (ForwardModelConfig_T), dimension(:), pointer :: TMPDATABASE
    integer :: CONFIG                   ! Loop counter
    integer :: STATUS

    ! Executable code
    ! Clear out dying configs
    if ( .not. associated ( database ) ) return
    do config = 1, size ( database )
      if ( .not. database(config)%globalConfig ) &
        & call DestroyOneForwardModelConfig ( database(config) )
d244 4
a247 5
    ! Create new database in tmp space, pack old one into
    allocate ( tmpDatabase ( count ( database%globalConfig ) ), STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate // 'tmpDatabase' )
    tmpDatabase = pack ( database, database%globalConfig )
d249 1
a249 6
    ! Destroy old database, then point to new one
    deallocate ( database, STAT=status )
    if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate // 'database' )
    database => tmpDatabase
  end subroutine StripForwardModelConfigDatabase
d252 1
a252 1
  subroutine DestroyFWMConfigDatabase ( Database, deep )
d275 40
d609 13
a621 4
  ! ------------------------------------ NullifyForwardModelConfig -----
  subroutine NullifyForwardModelConfig ( F )
    ! Given a forward model config, nullify all the pointers associated with it
    type ( ForwardModelConfig_T ), intent(out) :: F
d624 19
a642 9
    nullify ( f%molecules )
    nullify ( f%moleculeDerivatives )
    nullify ( f%pfaMolecules )
    nullify ( f%signals )
    nullify ( f%integrationGrid )
    nullify ( f%tangentGrid )
    nullify ( f%specificQuantities )
    nullify ( f%binSelectors )
  end subroutine NullifyForwardModelConfig
d647 1
a647 1
  subroutine DestroyOneForwardModelConfig ( config, deep )
d691 1
d791 3
@


2.48
log
@Added pfaMolecules field
@
text
@d100 1
a100 1
    & "$Id: ForwardModelConfig.f90,v 2.47 2004/03/24 13:50:56 hcp Exp $"
d549 4
a552 1
  subroutine Dump_ForwardModelConfigDatabase ( Database )
d555 1
d565 3
d645 3
@


2.47
log
@Made array LS 17 elements instead of 16. 17 things are taken out of it,
so presumably it should be that long. NAG f95 flagged this as an error.
@
text
@d34 1
a34 1
    integer :: Name                     ! String index of config name
d89 1
d100 1
a100 1
    & "$Id: ForwardModelConfig.f90,v 2.46 2004/03/22 18:23:20 livesey Exp $"
d273 15
d432 12
a443 1
    ! Specific quantiites
d491 1
d540 2
d548 1
a548 1
  ! ------------------------------------  Dump_FowardModelConfigs  -----
d564 1
a564 1
  ! ------------------------------------  Dump_FowardModelConfig  -----
d580 49
a628 39
   
        call output ( '  Atmos_der:' )
        call output ( Config%atmos_der, advance='yes' )
        call output ( '  Do_conv:' )
        call output ( Config%do_conv, advance='yes' )
        call output ( '  Do_Baseline:' )
        call output ( Config%do_Baseline, advance='yes' )
        call output ( '  Default_spectroscopy:' )
        call output ( Config%Default_spectroscopy, advance='yes' )
        call output ( '  Do_freq_avg:' )
        call output ( Config%do_freq_avg, advance='yes' )
        call output ( '  Do_1D:' )
        call output ( Config%do_1d, advance='yes' )
        call output ( '  Incl_Cld:' )
        call output ( Config%incl_cld, advance='yes' )
        call output ( '  SkipOverlaps:' )
        call output ( Config%skipOverlaps, advance='yes' )
        call output ( '  Spect_der:' )
        call output ( Config%spect_der, advance='yes' )
        call output ( '  Temp_der:' )
        call output ( Config%temp_der, advance='yes' )
        call output ( '  Molecules: ', advance='yes' )
        do j = 1, size(Config%molecules)
          call output ( '    ' )
          call display_string(lit_indices(Config%molecules(j)))
          if (Config%moleculeDerivatives(j)) then
            call output (' compute derivatives', advance='yes')
          else
            call output (' no derivatives', advance='yes')
          end if
        end do
        call output ( '  Signals:', advance='yes')
        do j = 1, size(Config%signals)
          call output ( '    ' )
          !call GetSignalName( signal=Config%signals(j), signalName)
          !??? Sort this out later!
          ! call output ( signalName//' channelIncluded:', advance='yes')
          call dump ( Config%signals(j)%channels )
        end do
d638 4
@


2.46
log
@Added AllLinesInCatalog flag
@
text
@d99 1
a99 1
    & "$Id: ForwardModelConfig.f90,v 2.45 2003/10/28 23:43:47 livesey Exp $"
d320 1
a320 1
    logical, dimension(16) :: LS        ! Temporary array
d356 3
a358 1
    ! Now the logical scalars
d598 3
@


2.45
log
@Added forceFoldedOutput
@
text
@d63 1
d99 1
a99 1
    & "$Id: ForwardModelConfig.f90,v 2.44 2003/10/18 01:15:58 livesey Exp $"
d596 3
@


2.44
log
@Various changes to the pack/unpack stuff.  This currently needs more
attention.
@
text
@d71 1
d98 1
a98 1
    & "$Id: ForwardModelConfig.f90,v 2.43 2003/09/15 23:45:00 vsnyder Exp $"
d230 2
a231 1
      & config%do_freq_avg, config%forceSidebandFraction, config%globalConfig, config%incl_cld, &
d367 1
d595 4
@


2.43
log
@Remove unused local variables and USEs
@
text
@d97 1
a97 1
    & "$Id: ForwardModelConfig.f90,v 2.42 2003/09/11 23:10:04 livesey Exp $"
d190 1
a190 1
    use MorePVM, only: PVMPackLitIndex
d201 2
d216 1
d229 1
a229 1
      & config%do_freq_avg, config%globalConfig, config%incl_cld, &
d307 1
a307 1
    use MorePVM, only: PVMUnpackLitIndex
d317 2
a318 2
    logical, dimension(15) :: LS        ! Temporary array
    integer, dimension(9) :: IS         ! Temporary array
d325 2
d341 11
a351 9
    config%no_cloud_species = is(1)
    config%no_model_surfs = is(2)
    config%num_ab_terms = is(3)
    config%num_azimuth_angles = is(4)
    config%num_scattering_angles = is(5)
    config%num_size_bins = is(6)
    config%sideBandStart = is(7)
    config%sideBandStop = is(8)
    config%surfaceTangentIndex = is(9)
d356 17
a372 15
    config%allLinesForRadiometer = ls(1)
    config%atmos_der = ls(2)
    config%default_spectroscopy = ls(3)
    config%differentialScan = ls(4)
    config%do_1d = ls(5)
    config%do_baseline = ls(6)
    config%do_conv = ls(7)
    config%do_freq_avg = ls(8)
    config%globalConfig = ls(9)
    config%incl_cld = ls(10)
    config%lockBins = ls(11)
    config%polarized = ls(12)
    config%skipOverlaps = ls(13)
    config%spect_der = ls(14)
    config%temp_der = ls(15)
d377 3
a379 2
    config%phiWindow = rs(1)
    config%tolerance = rs(2)
d592 3
@


2.42
log
@Added xStar and yStar
@
text
@a14 1
  use VectorsModule, only: VECTOR_T
d97 1
a97 1
    & "$Id: ForwardModelConfig.f90,v 2.41 2003/07/22 22:43:39 michael Exp $"
a504 6
    use Dump_0, only: DUMP
    use Intrinsic, only: Lit_indices
    use MLSSignals_M, only: GetSignalName, MaxSigLen
    use Output_M, only: Output
    use String_Table, only: Display_String

a508 1
!   character (len=MaxSigLen) :: SignalName  ! A line of text
d523 1
a523 1
    use MLSSignals_M, only: GetSignalName, MaxSigLen
d573 1
a573 1
   end subroutine Dump_ForwardModelConfig
d582 3
@


2.41
log
@Added a Dump_ForwardModelConfig subroutine for a single configuration and made
Dump_ForwardModelConfigDatabase call Dump_ForwardModelConfig to dump an array
of configurations.  Either is called with the generic interface "dump".
Formerly, only pointers to arrays of forwardmodelconsigurations could be dumped.
@
text
@d15 1
d60 2
d98 1
a98 1
    & "$Id: ForwardModelConfig.f90,v 2.40 2003/07/15 22:09:59 livesey Exp $"
d590 6
@


2.40
log
@Added forceSidebandFraction and linearSideband
@
text
@d21 1
a21 1
    module procedure Dump_ForwardModelConfigs
d27 1
a27 1

d95 1
a95 1
    & "$Id: ForwardModelConfig.f90,v 2.39 2003/07/15 18:16:26 livesey Exp $"
d501 1
a501 1
  subroutine Dump_ForwardModelConfigs ( Database )
d512 1
a512 1
    integer :: I, J                          ! Loop counters
d518 22
a539 2
        call output ( 'FowardModelConfig: ' )
        call output ( i, advance = 'yes' )
d541 1
a541 1
        call output ( database(i)%atmos_der, advance='yes' )
d543 1
a543 1
        call output ( database(i)%do_conv, advance='yes' )
d545 1
a545 1
        call output ( database(i)%do_Baseline, advance='yes' )
d547 1
a547 1
        call output ( database(i)%Default_spectroscopy, advance='yes' )
d549 1
a549 1
        call output ( database(i)%do_freq_avg, advance='yes' )
d551 1
a551 1
        call output ( database(i)%do_1d, advance='yes' )
d553 1
a553 1
        call output ( database(i)%incl_cld, advance='yes' )
d555 1
a555 1
        call output ( database(i)%skipOverlaps, advance='yes' )
d557 1
a557 1
        call output ( database(i)%spect_der, advance='yes' )
d559 1
a559 1
        call output ( database(i)%temp_der, advance='yes' )
d561 1
a561 1
        do j = 1, size(database(i)%molecules)
d563 2
a564 2
          call display_string(lit_indices(database(i)%molecules(j)))
          if (database(i)%moleculeDerivatives(j)) then
d571 1
a571 1
        do j = 1, size(database(i)%signals)
d573 1
a573 1
          !call GetSignalName( signal=database(i)%signals(j), signalName)
d576 1
a576 1
          call dump ( database(i)%signals(j)%channels )
d578 1
a578 3
      end do
    end if
  end subroutine Dump_ForwardModelConfigs
d587 3
@


2.39
log
@Added name to configuration
@
text
@d47 1
d69 1
d95 1
a95 1
    & "$Id: ForwardModelConfig.f90,v 2.38 2003/06/30 22:55:01 cvuu Exp $"
d569 3
@


2.38
log
@Find mean, std dev timing of fullForwardModel calls
@
text
@d34 1
d93 1
a93 1
    & "$Id: ForwardModelConfig.f90,v 2.37 2003/06/18 01:58:01 vsnyder Exp $"
d567 3
@


2.37
log
@Add SidebandStart and SidebandStop fields
@
text
@d56 1
d77 2
d92 1
a92 1
    & "$Id: ForwardModelConfig.f90,v 2.36 2003/05/29 16:37:02 livesey Exp $"
d566 3
@


2.36
log
@Added switchingMirror
@
text
@d34 12
a45 5
    integer :: cloud_der    ! Compute cloud sensitivity in cloud models.
    integer :: fwmType        ! l_linear, l_full or l_scan
    integer :: i_saturation        ! Flag to determine saturation status
    integer :: instrumentModule         ! Module for scan model
    integer :: windowUnits              ! Either degrees or profiles
d47 9
a55 7
    integer :: no_cloud_species         ! No of Cloud Species '2'
    integer :: no_model_surfs           ! No of Model surfaces '640'
    integer :: num_ab_terms             ! No of AB terms '50'
    integer :: num_azimuth_angles       ! No of azmuth angles '8'
    integer :: num_scattering_angles    ! No of scattering angles '16'
    integer :: num_size_bins            ! No of size bins '40'
    integer :: surfaceTangentIndex ! Index in Tangentgrid of Earth's surface
d57 16
a72 16
    logical :: allLinesForRadiometer ! As opposed to just using lines designated for band.
    logical :: atmos_der      ! Do atmospheric derivatives
    logical :: default_spectroscopy     ! Using Bill's spectroscopy data
    logical :: differentialScan         ! Differential scan model
    logical :: do_1d          ! Do 1D forward model calculation
    logical :: do_baseline    ! Do a baseline computation
    logical :: do_conv        ! Do convolution
    logical :: do_freq_avg    ! Do Frequency averaging
    logical :: globalConfig   ! If set is shared between all chunks
    logical :: incl_cld ! Include cloud extinction calculation in Bill's forward model
    logical :: lockBins              ! Use same l2pc bin for whole chunk
    logical :: polarized      ! Use polarized model for Zeeman-split lines
    logical :: switchingMirror          ! Model radiance at the switching mirror
    logical :: skipOverlaps   ! Don't calculate for MAFs in overlap regions
    logical :: spect_Der      ! Do spectroscopy derivatives
    logical :: temp_Der       ! Do temperature derivatives
d74 2
a75 2
    real (r8) :: phiWindow             ! Window size for examining stuff
    real (r8) :: tolerance ! Accuracy desired when choosing approximations
d77 4
a80 4
    integer, dimension(:), pointer :: binSelectors=>NULL() ! List of relevant bin selectors
    integer, dimension(:), pointer :: molecules=>NULL() ! Which molecules to consider
    integer, dimension(:), pointer :: specificQuantities=>NULL() ! Specific quantities to use
    logical, dimension(:), pointer :: moleculeDerivatives=>NULL() ! Want jacobians
d82 3
a84 3
    type (Signal_T), dimension(:), pointer :: signals=>NULL()
    type (vGrid_T), pointer :: integrationGrid=>NULL() ! Zeta grid for integration
    type (vGrid_T), pointer :: tangentGrid=>NULL()     ! Zeta grid for integration
d89 1
a89 1
    & "$Id: ForwardModelConfig.f90,v 2.35 2003/05/19 19:58:07 vsnyder Exp $"
d209 1
d307 1
a307 1
    integer, dimension(7) :: IS         ! Temporary array
d334 3
a336 1
    config%surfaceTangentIndex = is(7)
d507 1
a507 1
    character (len=MaxSigLen) :: SignalName  ! A line of text
d563 3
@


2.35
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d60 1
d80 1
a80 1
    & "$Id: ForwardModelConfig.f90,v 2.34 2003/05/05 23:00:24 livesey Exp $"
d551 3
@


2.34
log
@Merged in feb03 newfwm branch
@
text
@d79 1
a79 1
    & "$Id$"
d82 1
a82 1
    & "$RCSfile$"
a146 1
    use Allocate_Deallocate, only: Deallocate_Test
d172 1
a172 1
    use MorePVM, only: PVMPackLitIndex, PVMPackStringIndex
d285 1
a285 1
    use MorePVM, only: PVMUnpackLitIndex, PVMUnpackStringIndex
a289 1
    use Output_M, only: OUTPUT
a446 1
    integer :: SIGNAL                   ! Loop counter
d549 4
a552 1
! $Log$
@


2.33
log
@change dimension(12) :: i11 TO dimension(11) :: i11
@
text
@d30 2
d33 2
a34 1
    logical :: globalConfig   ! If set is shared between all chunks
d36 13
d50 3
d56 12
a67 1
    logical :: do_1d          ! Do 1D forward model calculation
d69 1
d71 1
a71 4
    integer, dimension(:), pointer :: moleculesPol=>NULL() ! Which molecules
      !                       ! to consider that have Zeeman-split lines
    logical, dimension(:), pointer :: moleculeDerivativesPol=>NULL() ! Want
      !                       ! jacobians w.r.t. molecules_pol
d73 2
a74 28
    logical :: Spect_Der      ! Do spectroscopy derivatives
    logical :: Temp_Der       ! Do temperature derivatives
    logical :: SkipOverlaps   ! Don't calculate for MAFs in overlap regions
    logical :: AllLinesForRadiometer ! As opposed to just using lines designated for band.
    type(vGrid_T), pointer :: integrationGrid=>NULL() ! Zeta grid for integration
    type(vGrid_T), pointer :: tangentGrid=>NULL()     ! Zeta grid for integration
    integer, dimension(:), pointer :: specificQuantities=>NULL() ! Specific quantities to use
    integer :: surfaceTangentIndex ! Index in Tangentgrid of Earth's surface
    real (r8) :: phiWindow             ! Window size for examining stuff
    integer :: windowUnits              ! Either degrees or profiles
    real (r8) :: tolerance ! Accuracy desired when choosing approximations
    ! Specifics for CloudForwardModel
    logical :: Default_spectroscopy     ! Using Bill's spectroscopy data
    logical :: incl_cld ! Include cloud extinction calculation in Bill's forward model
    integer :: no_cloud_species         ! No of Cloud Species '2'
    integer :: no_model_surfs           ! No of Model surfaces '640'
    integer :: num_scattering_angles    ! No of scattering angles '16'
    integer :: num_azimuth_angles       ! No of azmuth angles '8'
    integer :: num_ab_terms             ! No of AB terms '50'
    integer :: num_size_bins            ! No of size bins '40'
    integer :: cloud_der    ! Compute cloud sensitivity in cloud models.
    integer :: i_saturation        ! Flag to determine saturation status
    ! Specifics for linearised forward model
    logical :: LockBins              ! Use same l2pc bin for whole chunk
    integer, dimension(:), pointer :: binSelectors=>NULL() ! List of relevant bin selectors
    ! Specifics for scan forward model
    integer :: instrumentModule         ! Module for scan model
    logical :: differentialScan         ! Differential scan model
d79 1
a79 1
    & "$Id: ForwardModelConfig.f90,v 2.32 2003/04/02 21:46:51 jonathan Exp $"
d82 1
a82 1
    & "$RCSfile: ForwardModelConfig.f90,v $"
d183 14
a196 9
    ! First pack the logical scalars
    call PVMIDLPack ( (/ config%globalConfig, config%atmos_der, &
      & config%do_baseline, config%do_conv, config%do_freq_avg, &
      & config%do_1d, config%incl_cld, config%differentialScan, &
      & config%lockBins, config%spect_der, &
      & config%temp_der, config%skipOverlaps, config%default_spectroscopy /), info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig logicals" )
    ! Pack the integer scalars
    call PVMIDLPack ( (/ config%instrumentModule, config%surfaceTangentIndex, &
d198 3
a200 3
      & config%num_scattering_angles, config%num_azimuth_angles, &
      & config%num_ab_terms, config%num_size_bins, config%cloud_der, &
      & config%i_saturation, config%windowUnits /), info )
d202 12
a215 2
    call PVMPackLitIndex ( config%fwmType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing fwmConfig%fwmType" )
d217 13
a229 1
    ! Now pack the arrays - molecules
d247 1
a247 18
    ! Molecules with Zeeman splitting
    if ( associated ( config%moleculesPol ) ) then
      call PVMIDLPack ( size ( config%moleculesPol ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of moleculesPol" )
      if ( size ( config%moleculesPol ) > 0 ) then
        do i = 1, size(config%moleculesPol)
          call PVMPackLitIndex ( abs ( config%moleculesPol(i) ), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "Packing a moleculePol" )
          call PVMIDLPack ( (config%moleculesPol(i) .gt. 0.0), info )
          if ( info /= 0 ) call PVMErrorMessage ( info, "Packing moleculePol sign" )
        end do
        call PVMIDLPack ( config%moleculeDerivativesPol, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Packing molecule derivativesPol" )
      end if
    else
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 moleculesPol" )
    end if
a257 10
    ! Bin selectors
    if ( associated ( config%binSelectors ) ) then
      call PVMIDLPack ( size ( config%binSelectors ), info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing number of binSelectors" )
      call PVMIDLPack ( config%binSelectors, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing binSelectors" )
    else
      call PVMIDLPack ( 0, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Packing 0 binSelectors" )
    end if
d297 3
a299 4
    logical, dimension(13) :: l13       ! Temporary array
    logical, dimension(2) :: l2         ! Temporary array
    integer, dimension(11) :: i11       ! Temporary array
    real(r8), dimension(2) :: r2        ! Temporary array
d304 25
a328 2
    ! First the scalars
    call PVMIDLUnpack ( l13, info )
d330 18
a347 27
    config%globalConfig = l13(1)
    config%atmos_der = l13(2)
    config%do_baseline = l13(3)
    config%do_conv = l13(4)
    config%do_freq_avg = l13(5)
    config%do_1d = l13(6)
    config%incl_cld = l13(7)
    config%differentialScan = l13(8)
    config%lockBins = l13(9)
    config%spect_der = l13(10)
    config%temp_der = l13(11)
    config%skipOverlaps = l13(12)
    config%default_spectroscopy = l13(13)
    call PVMIDLUnpack ( i11, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmConfig integers" )
    config%instrumentModule = i11(1)
    config%surfaceTangentIndex = i11(2)
    config%no_cloud_species = i11(3)
    config%no_model_surfs = i11(4)
    config%num_scattering_angles = i11(5)
    config%num_azimuth_angles = i11(6)
    config%num_ab_terms = i11(7)
    config%num_size_bins = i11(8)
    config%cloud_der = i11(9)
    config%i_saturation = i11(10)
    config%windowUnits = i11(11)
    call PVMIDLUnpack ( r2, info )
d349 13
a361 4
    config%phiWindow = r2(1)
    config%tolerance = r2(2)
    call PVMUnpackLitIndex ( config%fwmType, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking fwmType" )
d363 1
a363 1
    ! Now the arrays - molecules
a379 17
    ! Molecules with Zeeman-split lines
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of moleculesPol" )
    if ( n > 0 ) then
      call Allocate_test ( config%moleculesPol, n, 'config%moleculesPol', ModuleName )
      call Allocate_test ( config%moleculeDerivativesPol, &
        & n, 'config%moleculeDerivativesPol', ModuleName )
      do i = 1, n
        call PVMUnpackLitIndex ( config%moleculesPol(i), info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a moleculePol" )
        call PVMIDLUnpack ( flag, info )
        if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking a moleculePol sign flag" )
        if ( .not. flag ) config%moleculesPol(i) = - config%moleculesPol(i)
      end do
      call PVMIDLUnpack ( config%moleculeDerivatives, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking moleculeDerivativesPol" )
    end if
a390 10
    ! Specific quantiites
    call PVMIDLUnpack ( n, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking number of specific quantities" )
    if ( n > 0 ) then
      call Allocate_test ( config%binSelectors, n, &
        & 'config%binSelectors', ModuleName )
      call PVMIDLUnpack ( config%binSelectors, info )
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking binSelectors" )
    end if

d402 1
d404 1
a404 1
    call PVMIDLUnpack ( l2, info )
d406 1
a406 1
    if ( l2(1) ) then
d412 1
a412 1
    if ( l2(2) ) then
d552 4
a555 1
! $Log: ForwardModelConfig.f90,v $
d561 6
@


2.32
log
@remove cloud_fov, changed i12 to i11
@
text
@d77 1
a77 1
    & "$Id: ForwardModelConfig.f90,v 2.31 2003/03/07 03:16:00 livesey Exp $"
d297 1
a297 1
    integer, dimension(12) :: i11       ! Temporary array
d555 3
@


2.31
log
@Changed use of DestroySignal
@
text
@a66 1
    integer :: cloud_fov ! Flag for cloud model field-of-view averaging.
d77 1
a77 1
    & "$Id: ForwardModelConfig.f90,v 2.30 2003/02/06 22:04:25 vsnyder Exp $"
d193 1
a193 1
      & config%i_saturation, config%cloud_fov, config%windowUnits /), info )
d297 1
a297 1
    integer, dimension(12) :: i12       ! Temporary array
d319 1
a319 1
    call PVMIDLUnpack ( i12, info )
d321 11
a331 12
    config%instrumentModule = i12(1)
    config%surfaceTangentIndex = i12(2)
    config%no_cloud_species = i12(3)
    config%no_model_surfs = i12(4)
    config%num_scattering_angles = i12(5)
    config%num_azimuth_angles = i12(6)
    config%num_ab_terms = i12(7)
    config%num_size_bins = i12(8)
    config%cloud_der = i12(9)
    config%i_saturation = i12(10)
    config%cloud_fov = i12(11)
    config%windowUnits = i12(12)
d555 3
@


2.30
log
@Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
@
text
@d78 1
a78 1
    & "$Id: ForwardModelConfig.f90,v 2.29 2003/02/06 20:16:23 livesey Exp $"
a147 1
    use MLSSignals_M, only: DestroySignal
d445 1
a445 1
    use MLSSignals_M, only: DestroySignal
d460 2
a461 9
    if ( associated(config%signals) ) then
      do signal = 1, size(config%signals)
        call destroySignal ( config%signals(signal), &
          & justChannels=.not. myDeep )
      end do
      deallocate ( config%signals, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate // "config%signals" )
    end if
d557 3
@


2.30.2.1
log
@Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
@
text
@d40 4
a43 1
    logical :: Polarized      ! Use polarized model for Zeeman-split lines
d78 1
a78 1
    & "$Id: ForwardModelConfig.f90,v 2.30 2003/02/06 22:04:25 vsnyder Exp $"
d183 6
a188 6
    ! First pack the logical scalars, in alphabetical order
    call PVMIDLPack ( (/ config%atmos_der, config%default_spectroscopy, &
      & config%differentialScan, config%do_1d, config%do_baseline, &
      & config%do_conv, config%do_freq_avg, config%globalConfig, &
      & config%incl_cld, config%lockBins, config%polarized, &
      & config%skipOverlaps, config%spect_der, config%temp_der /), info )
d190 6
a195 6
    ! Pack the integer scalars, in alphabetical order
    call PVMIDLPack ( (/ config%cloud_der, config%cloud_fov, &
      & config%instrumentModule, config%i_saturation, config%no_cloud_species, &
      & config%no_model_surfs, config%num_ab_terms, config%num_azimuth_angles, &
      & config%num_scattering_angles, config%num_size_bins, &
      & config%surfaceTangentIndex, config%windowUnits /), info )
d220 18
d297 1
a297 1
    logical, dimension(14) :: l14       ! Temporary array
d306 1
a306 1
    call PVMIDLUnpack ( l14, info )
d308 13
a320 14
    config%atmos_der = l14(1)
    config%default_spectroscopy = l14(2)
    config%differentialScan = l14(3)
    config%do_1d = l14(4)
    config%do_baseline = l14(5)
    config%do_conv = l14(6)
    config%do_freq_avg = l14(7)
    config%globalConfig = l14(8)
    config%incl_cld = l14(9)
    config%lockBins = l14(10)
    config%polarized = l14(11)
    config%skipOverlaps = l14(12)
    config%spect_der = l14(13)
    config%temp_der = l14(14)
d323 6
a328 6
    config%cloud_der = i12(1)
    config%cloud_fov = i12(2)
    config%instrumentModule = i12(3)
    config%i_saturation = i12(4)
    config%no_cloud_species = i12(5)
    config%no_model_surfs = i12(5)
d330 4
a333 4
    config%num_azimuth_angles = i12(8)
    config%num_scattering_angles = i12(9)
    config%num_size_bins = i12(10)
    config%surfaceTangentIndex = i12(11)
d359 17
a564 3
! Revision 2.30  2003/02/06 22:04:25  vsnyder
! Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
!
@


2.30.2.2
log
@remove cloud_fov
@
text
@d64 1
d75 1
a75 1
    & "$Id: ForwardModelConfig.f90,v 2.30.2.1 2003/02/22 00:48:08 vsnyder Exp $"
d188 1
a188 1
    call PVMIDLPack ( (/ config%cloud_der, &
d278 1
a278 1
    integer, dimension(11) :: i11       ! Temporary array
d301 1
a301 1
    call PVMIDLUnpack ( i11, info )
d303 12
a314 11
    config%cloud_der = i11(1)
    config%instrumentModule = i11(2)
    config%i_saturation = i11(3)
    config%no_cloud_species = i11(4)
    config%no_model_surfs = i11(5)
    config%num_ab_terms = i11(6)
    config%num_azimuth_angles = i11(7)
    config%num_scattering_angles = i11(8)
    config%num_size_bins = i11(9)
    config%surfaceTangentIndex = i11(10)
    config%windowUnits = i11(11)
a527 3
! Revision 2.30.2.1  2003/02/22 00:48:08  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
@


2.29
log
@Minor bug fix in the database deallocation
@
text
@d40 4
a44 1
    logical :: Polarized      ! Do polarized radiative transfer
d78 1
a78 1
    & "$Id: ForwardModelConfig.f90,v 2.28 2003/02/05 21:57:27 livesey Exp $"
d183 1
a183 1
    ! First pack the scalars
d187 1
a187 1
      & config%lockBins, config%polarized, config%spect_der, &
d190 1
d220 18
d297 1
a297 1
    logical, dimension(14) :: l14       ! Temporary array
d306 1
a306 1
    call PVMIDLUnpack ( l14, info )
d308 13
a320 14
    config%globalConfig = l14(1)
    config%atmos_der = l14(2)
    config%do_baseline = l14(3)
    config%do_conv = l14(4)
    config%do_freq_avg = l14(5)
    config%do_1d = l14(6)
    config%incl_cld = l14(7)
    config%differentialScan = l14(8)
    config%lockBins = l14(9)
    config%polarized = l14(10)
    config%spect_der = l14(11)
    config%temp_der = l14(12)
    config%skipOverlaps = l14(13)
    config%default_spectroscopy = l14(14)
d359 17
a529 2
        call output ( '  Polarized:' )
        call output ( database(i)%polarized, advance='yes' )
d565 3
@


2.28
log
@Tidy up and added binSelectors, removed nameFragment
@
text
@d75 1
a75 1
    & "$Id: ForwardModelConfig.f90,v 2.27 2003/01/30 22:01:30 livesey Exp $"
d121 1
d529 3
@


2.27
log
@Tidy up of the logical array packing.
@
text
@d33 5
a37 5
    logical :: Atmos_Der      ! Do atmospheric derivatives
    logical :: do_Baseline    ! Do a baseline computation
    logical :: Do_Conv        ! Do convolution
    logical :: Do_Freq_Avg    ! Do Frequency averaging
    logical :: Do_1D          ! Do 1D forward model calculation
a40 3
    integer :: instrumentModule         ! Module for scan model
    logical :: differentialScan         ! Differential scan model
    logical :: LockBins                 ! Use same l2pc bin for whole chunk
d49 22
a70 18
    integer :: surfaceTangentIndex  ! Index in Tangentgrid of Earth's surface
    real (r8) :: phiWindow            ! Window size for examining stuff
    integer :: windowUnits          ! Either degrees or profiles
    real (r8) :: tolerance          ! Accuracy desired when choosing approximations
    ! CloudForwardModel
    logical :: Default_spectroscopy ! Using Bill's spectroscopy data
    logical :: Incl_Cld             ! Include cloud extinction calculation in Bill's forward model
    integer :: no_cloud_species     ! No of Cloud Species '2'
    integer :: no_model_surfs       ! No of Model surfaces '640'
    integer :: NUM_SCATTERING_ANGLES! No of scattering angles '16'
    integer :: NUM_AZIMUTH_ANGLES   ! No of azmuth angles '8'
    integer :: NUM_AB_TERMS         ! No of AB terms '50'
    integer :: NUM_SIZE_BINS        ! No of size bins '40'
    integer :: cloud_der            ! Compute cloud sensitivity in cloud models.
!    integer :: cloud_width          ! Flag for cloud horizontal extend.
    integer :: i_saturation         ! Flag to determine saturation status
    integer :: cloud_fov            ! Flag for cloud model field-of-view averaging.
    integer :: NameFragment         ! For e.g. restricting bins in l2pc
d75 1
a75 1
    & "$Id: ForwardModelConfig.f90,v 2.26 2003/01/30 18:29:40 jonathan Exp $"
d225 10
a256 4
    ! Name fragment
    call PVMPackStringIndex ( config%nameFragment, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Packing nameFragment" )

d337 1
d345 11
a355 1
      if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking specificQuantities" )
a384 4
    ! Name fragment
    call PVMUnpackStringIndex ( config%nameFragment, info )
    if ( info /= 0 ) call PVMErrorMessage ( info, "Unpacking name fragment" )

d399 1
d453 2
d528 3
@


2.26
log
@change dimension l13 to 14
@
text
@d74 1
a74 1
    & "$Id: ForwardModelConfig.f90,v 2.25 2003/01/30 17:28:01 jonathan Exp $"
d179 5
a183 4
    call PVMIDLPack ( (/ config%globalConfig, config%atmos_der, config%do_baseline, &
      & config%do_conv, config%do_freq_avg, config%do_1d, config%incl_cld, config%differentialScan, &
      & config%lockBins, config%polarized, config%spect_der, config%temp_der, config%skipOverlaps, &
      & config%default_spectroscopy /), info )
d267 1
a267 1
    logical, dimension(14) :: l13       ! Temporary array
d276 1
a276 1
    call PVMIDLUnpack ( l13, info )
d278 14
a291 14
    config%globalConfig = l13(1)
    config%atmos_der = l13(2)
    config%do_baseline = l13(3)
    config%do_conv = l13(4)
    config%do_freq_avg = l13(5)
    config%do_1d = l13(6)
    config%differentialScan = l13(7)
    config%lockBins = l13(8)
    config%polarized = l13(9)
    config%spect_der = l13(10)
    config%temp_der = l13(11)
    config%skipOverlaps = l13(12)
    config%default_spectroscopy = l13(13)
    config%incl_cld = l13(14)
d511 3
@


2.25
log
@add logical incl_cld
@
text
@d74 1
a74 1
    & "$Id: ForwardModelConfig.f90,v 2.24 2003/01/29 01:48:52 vsnyder Exp $"
d266 1
a266 1
    logical, dimension(13) :: l13       ! Temporary array
d510 3
@


2.24
log
@Add 'polarized' field to forwardModel
@
text
@d57 2
a58 1
    logical :: Default_spectroscopy      !
d74 1
a74 1
    & "$Id: ForwardModelConfig.f90,v 2.23 2003/01/26 04:42:42 livesey Exp $"
d180 1
a180 1
      & config%do_conv, config%do_freq_avg, config%do_1d, config%differentialScan, &
d290 1
d471 2
d510 3
@


2.23
log
@Added profiles/angle options for phiWindow
@
text
@d44 1
d47 1
a47 1
    logical :: skipOverlaps   ! Don't calculate for MAFs in overlap regions
d73 1
a73 1
    & "$Id: ForwardModelConfig.f90,v 2.22 2003/01/17 00:01:44 livesey Exp $"
a149 1
    integer :: Signal                   ! Loop counter
d180 1
a180 1
      & config%lockBins, config%spect_der, config%temp_der, config%skipOverlaps, &
d265 1
a265 1
    logical, dimension(12) :: l12       ! Temporary array
d274 1
a274 1
    call PVMIDLUnpack ( l12, info )
d276 13
a288 12
    config%globalConfig = l12(1)
    config%atmos_der = l12(2)
    config%do_baseline = l12(3)
    config%do_conv = l12(4)
    config%do_freq_avg = l12(5)
    config%do_1d = l12(6)
    config%differentialScan = l12(7)
    config%lockBins = l12(8)
    config%spect_der = l12(9)
    config%temp_der = l12(10)
    config%skipOverlaps = l12(11)
    config%default_spectroscopy = l12(12)
d469 4
a476 2
        call output ( '  SkipOverlaps:' )
        call output ( database(i)%skipOverlaps, advance='yes' )
d506 3
@


2.22
log
@Another bug fix in the packing/unpacking
@
text
@d53 1
d72 1
a72 1
    & "$Id: ForwardModelConfig.f90,v 2.21 2003/01/16 05:53:19 livesey Exp $"
d187 1
a187 2
      & config%i_saturation, config%cloud_fov /), info )
!      & config%cloud_width, config%cloud_fov /), info )
d267 1
a267 1
    integer, dimension(11) :: i11       ! Temporary array
d288 1
a288 1
    call PVMIDLUnpack ( i11, info )
d290 12
a301 12
    config%instrumentModule = i11(1)
    config%surfaceTangentIndex = i11(2)
    config%no_cloud_species = i11(3)
    config%no_model_surfs = i11(4)
    config%num_scattering_angles = i11(5)
    config%num_azimuth_angles = i11(6)
    config%num_ab_terms = i11(7)
    config%num_size_bins = i11(8)
    config%cloud_der = i11(9)
!    config%cloud_width = i11(10)
    config%i_saturation = i11(10)
    config%cloud_fov = i11(11)
d503 3
@


2.21
log
@Bug fix to Jonathans new configs
@
text
@d71 1
a71 1
    & "$Id: ForwardModelConfig.f90,v 2.20 2003/01/16 05:50:59 livesey Exp $"
d180 1
a180 1
      & config%default_spectroscopy, config%do_1d /), info )
d503 3
@


2.20
log
@Bug fix in do_1d handling
@
text
@d71 1
a71 1
    & "$Id: ForwardModelConfig.f90,v 2.19 2003/01/16 00:55:27 jonathan Exp $"
d281 7
a287 7
    config%differentialScan = l12(6)
    config%lockBins = l12(7)
    config%spect_der = l12(8)
    config%temp_der = l12(9)
    config%skipOverlaps = l12(10)
    config%default_spectroscopy = l12(11)
    config%do_1d = l12(12)
d503 3
@


2.19
log
@add do_1d, also fix bug of reversed  do_freq_avg do_baseline order
@
text
@d71 1
a71 1
    & "$Id: ForwardModelConfig.f90,v 2.18 2003/01/13 17:16:23 jonathan Exp $"
d180 1
a180 1
      & config%default_spectroscopy /), info )
d265 1
a265 1
    logical, dimension(11) :: l11       ! Temporary array
d274 1
a274 1
    call PVMIDLUnpack ( l11, info )
d276 12
a287 12
    config%globalConfig = l11(1)
    config%atmos_der = l11(2)
    config%do_baseline = l11(3)
    config%do_conv = l11(4)
    config%do_freq_avg = l11(5)
    config%differentialScan = l11(6)
    config%lockBins = l11(7)
    config%spect_der = l11(8)
    config%temp_der = l11(9)
    config%skipOverlaps = l11(10)
    config%default_spectroscopy = l11(11)
    config%do_1d = l11(12)
d503 3
@


2.18
log
@chane cloud_width to i_saturation
@
text
@d37 1
d71 1
a71 1
    & "$Id: ForwardModelConfig.f90,v 2.17 2002/12/04 21:55:22 livesey Exp $"
d178 1
a178 1
      & config%do_conv, config%do_freq_avg, config%differentialScan, &
d287 1
d462 2
a464 2
        call output ( database(i)%Default_spectroscopy, advance='yes' )
        call output ( '  Default_spectroscopy:' )
d466 2
d503 3
@


2.17
log
@Added the name fragment packing
@
text
@d62 2
a63 1
    integer :: cloud_width          ! Flag for cloud horizontal extend.
d70 1
a70 1
    & "$Id: ForwardModelConfig.f90,v 2.16 2002/11/22 12:14:31 mjf Exp $"
d185 2
a186 1
      & config%cloud_width, config%cloud_fov /), info )
d297 2
a298 1
    config%cloud_width = i11(10)
d499 3
@


2.16
log
@Added nullify routine(s) to get round Sun's WS6 compiler not
initialising derived type function results.
@
text
@d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.15 2002/11/15 01:32:53 livesey Exp $"
d164 1
a164 1
    use MorePVM, only: PVMPackLitIndex
d241 4
d251 1
a251 1
    use MorePVM, only: PVMUnpackLitIndex
d358 4
d496 4
@


2.15
log
@Added allLinesForRadiometer
@
text
@d25 1
d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.14 2002/10/08 17:40:01 livesey Exp $"
d356 14
d488 3
@


2.14
log
@Various bug fixes in the pack/unpack routines
@
text
@d45 1
d68 1
a68 1
    & "$Id: ForwardModelConfig.f90,v 2.13 2002/10/08 17:08:03 pwagner Exp $"
d473 3
@


2.13
log
@Added idents to survive zealous Lahey optimizer
@
text
@d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 2.12 2002/10/06 01:09:22 livesey Exp $"
d184 2
d195 1
a195 1
          call PVMPackLitIndex ( config%molecules(i), info )
d197 2
d250 1
d255 1
d257 1
a257 1
    logical, dimension(11) :: l2        ! Temporary array
d259 1
d291 4
d303 2
d308 3
d312 2
d319 2
a320 1
      call Allocate_test ( config%molecules, n, 'config%specificQuantities', ModuleName )
d472 3
@


2.12
log
@Made the pvm routines public
@
text
@d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 2.11 2002/10/05 00:41:01 livesey Exp $"
d71 1
d446 4
d453 3
@


2.11
log
@Added pvm pack and unpack config and deep option on destroy
@
text
@d24 2
a25 2
  public :: AddForwardModelConfigToDatabase, DestroyFWMConfigDatabase, Dump, &
    & StripForwardModelConfigDatabase
d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 2.10 2002/09/25 20:06:42 livesey Exp $"
d448 3
@


2.10
log
@Added specificQuantities, which necessitated globalConfig to allow for
some configs inside construct.  This in turn required
StripForwardModelConfigDatabase
@
text
@d14 1
a14 1
  use VGridsDatabase, only: VGrid_T
d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 2.9 2002/08/21 23:53:57 vsnyder Exp $"
d131 1
a131 1
  subroutine DestroyFWMConfigDatabase ( Database )
d139 1
d148 1
a148 1
        call DestroyOneForwardModelConfig ( database(config) )
d157 177
d337 1
a337 1
  subroutine DestroyOneForwardModelConfig ( config )
d344 1
d349 1
d352 2
d357 1
a357 1
          & justChannels=.true. )
d361 15
a375 1
        & MLSMSG_Deallocate // "database%signals" )
d377 1
a377 1
    ! Don't destroy integrationGrid and tangentGrid.  Assume they will
d448 5
@


2.9
log
@Move USE statements from module scope to procedure scope
@
text
@d24 2
a25 1
  public :: AddForwardModelConfigToDatabase, DestroyFWMConfigDatabase, Dump
d30 1
d47 1
d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 2.8 2002/07/17 06:02:13 livesey Exp $"
d96 34
d147 1
a147 15
        if ( associated(database(config)%signals) ) then
          do signal = 1, size(database(config)%signals)
            call destroySignal ( database(config)%signals(signal), &
              & justChannels=.true. )
          end do
          deallocate ( database(config)%signals, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Deallocate // "database%signals" )
        end if
        ! Don't destroy integrationGrid and tangentGrid.  Assume they will
        ! be (or already are) destroyed by destroyVGridDatabase.
        call deallocate_test ( database(config)%molecules, &
          & "database(config)%molecules", moduleName )
        call deallocate_test ( database(config)%moleculeDerivatives, &
          & "database(config)%moleculeDerivatives", moduleName )
d157 35
a191 1
  ! ------------------------------------  DUMP_FOWARDMODELCONFIGS  -----
d252 3
@


2.8
log
@New config elements for hdf5 l2pcs
@
text
@a11 3
  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
  use Dump_0, only: DUMP
  use Intrinsic, only: Lit_indices
d13 2
a14 6
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate,&
    & MLSMSG_Error
  use MLSSignals_M, only: DestroySignal, GetSignalName, MaxSigLen, Signal_T
  use Output_M, only: Output
  use String_Table, only: Display_String
  use VGridsDatabase, only: DestroyVGridContents, VGrid_T
d64 1
a64 1
    & "$Id: ForwardModelConfig.f90,v 2.7 2002/06/12 17:00:49 livesey Exp $"
d78 3
d95 5
d136 7
d195 3
@


2.7
log
@Changed phiWindow to float
@
text
@d46 1
d66 1
d71 1
a71 1
    & "$Id: ForwardModelConfig.f90,v 2.6 2002/03/07 17:17:49 livesey Exp $"
d187 3
@


2.6
log
@Removed frqGap
@
text
@d52 1
a52 1
    integer :: phiWindow            ! Window size for examining stuff
d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.5 2002/02/14 23:01:35 livesey Exp $"
d185 3
@


2.5
log
@Added justChannels in call to destroySignal
@
text
@a52 1
    real (r8) :: frqGap             ! Lines further than this are ignored (MHz)
d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.4 2002/02/13 00:09:24 livesey Exp $"
a153 2
        call output ( '  frqGap:' )
        call output ( database(i)%frqGap, advance='yes' )
d185 3
@


2.4
log
@Added differential Scan model
@
text
@d70 1
a70 1
    & "$Id: ForwardModelConfig.f90,v 2.3 2001/11/15 23:50:11 jonathan Exp $"
d110 2
a111 1
            call destroySignal ( database(config)%signals(signal) )
d188 3
@


2.3
log
@rename DF_spectroscopy to default_spectroscopy
@
text
@d45 1
d70 1
a70 1
    & "$Id: ForwardModelConfig.f90,v 2.2 2001/11/15 20:56:38 jonathan Exp $"
d187 3
@


2.2
log
@add df_spectroscopy
@
text
@d55 1
a55 1
    logical :: DF_spectroscopy      !
d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.1 2001/10/02 20:37:09 livesey Exp $"
d150 2
d186 3
@


2.1
log
@Added do_baseline
@
text
@d55 1
d69 1
a69 1
    & "$Id: ForwardModelConfig.f90,v 2.0 2001/09/17 20:26:25 livesey Exp $"
d184 3
@


2.0
log
@New forward model
@
text
@d38 1
d68 1
a68 1
    & "$Id: ForwardModelConfig.f90,v 1.15 2001/09/04 15:59:01 jonathan Exp $"
d146 2
d183 3
@


1.15
log
@add cloud_fov, jonathan
@
text
@d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 1.14 2001/07/17 22:38:05 jonathan Exp $"
d180 3
@


1.14
log
@add cloud_width, jonathan/paul
@
text
@d62 1
d67 1
a67 1
    & "$Id: ForwardModelConfig.f90,v 1.13 2001/07/16 22:07:57 jonathan Exp $"
d180 3
@


1.13
log
@change cloud_der to integer-type, jonathan
@
text
@a46 1
    integer :: cloud_der      ! Compute cloud sensitivity in cloud models.
d60 2
d66 1
a66 1
    & "$Id: ForwardModelConfig.f90,v 1.12 2001/07/06 18:55:13 jonathan Exp $"
d179 3
@


1.12
log
@Modified for cloud model, Paul/Jonathan
@
text
@d47 1
a47 1
    logical :: cloud_der      ! Compute cloud sensitivity in cloud models.
d65 1
a65 1
    & "$Id: ForwardModelConfig.f90,v 1.10 2001/05/31 23:07:45 livesey Exp $"
d178 3
@


1.11
log
@Added tolerance
@
text
@d54 7
d178 3
@


1.10
log
@Added cloud_der
@
text
@d53 1
d58 1
a58 1
    & "$Id: ForwardModelConfig.f90,v 1.9 2001/05/25 20:26:09 livesey Exp $"
d171 3
@


1.9
log
@Added skipOverlaps option
@
text
@d47 1
d57 1
a57 1
    & "$Id: ForwardModelConfig.f90,v 1.8 2001/05/14 23:17:35 livesey Exp $"
d170 3
@


1.8
log
@Added frqGap parameter
@
text
@d46 1
d56 1
a56 1
    & "$Id: ForwardModelConfig.f90,v 1.7 2001/05/03 23:07:02 livesey Exp $"
d142 2
d169 3
@


1.7
log
@Added scan model stuff
@
text
@d50 1
d55 1
a55 1
    & "$Id: ForwardModelConfig.f90,v 1.6 2001/05/02 20:30:36 livesey Exp $"
d135 2
d166 3
@


1.6
log
@Removed frequency from config
@
text
@d43 1
d54 1
a54 1
    & "$Id: ForwardModelConfig.f90,v 1.5 2001/04/26 02:36:52 vsnyder Exp $"
d163 3
@


1.5
log
@Moved *_indices declarations from init_tables_module to intrinsic
@
text
@a41 1
    real(r8) :: The_Freq      ! Frequency to use if .not. do_freq_avg
d53 1
a53 1
    & "$Id: ForwardModelConfig.f90,v 1.4 2001/04/21 01:08:57 vsnyder Exp $"
a136 2
        call output ( '  The_freq:' )
        call output ( database(i)%the_freq, advance='yes' )
d162 3
@


1.4
log
@Deallocate Molecules and MoleculeDerivatives in DestroyFWMConfigDatabase
@
text
@d14 1
d54 1
a54 1
    & "$Id: ForwardModelConfig.f90,v 1.3 2001/04/12 17:00:08 vsnyder Exp $"
d116 1
a116 1
  subroutine Dump_ForwardModelConfigs ( Database, Lit_Indices )
a117 1
    integer, intent(in), dimension(:) :: Lit_Indices
d165 3
@


1.3
log
@Comment out a line with an undefined variable on it
@
text
@d17 1
a17 1
  use MLSSignals_M, only: GetSignalName, MaxSigLen, Signal_T
d20 1
a20 1
  use VGridsDatabase, only: VGrid_T
d45 2
a46 2
    type(vGrid_T), pointer :: integrationGrid ! Zeta grid for integration
    type(vGrid_T), pointer :: tangentGrid     ! Zeta grid for integration
d53 1
a53 1
    & "$Id: ForwardModelConfig.f90,v 1.2 2001/04/10 22:17:05 livesey Exp $"
d91 5
a95 3
        do signal = 1, size(database(config)%signals)
          deallocate ( database(config)%signals(signal)%channels, &
            & stat=status )
d97 8
a104 8
            & MLSMSG_Deallocate // "database%signals%channelIncluded" )
        end do
        deallocate ( database(config)%signals, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate // "database%signals" )
        deallocate ( database(config)%molecules, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate // "database%molecules" )
d165 3
@


1.2
log
@Renamed module
@
text
@d53 1
a53 1
    & "$Id: ForwardModelConfig.f90,v 1.1 2001/04/07 01:56:25 vsnyder Exp $"
d152 2
a153 2
          ! Sort this out later!
          call output ( signalName//' channelIncluded:', advance='yes')
d163 3
@


1.1
log
@Initial commit
@
text
@d17 1
a17 1
  use MLSSignals_M, only: GetSignalName, MaxSigLen
a33 5
  type, public :: ForwardModelSignalInfo_T
    integer :: signal                   ! The signal we're considering
    logical, dimension(:), pointer :: channelIncluded=>null() ! Which channels to use
  end type ForwardModelSignalInfo_T

d42 1
a42 1
    type (ForwardModelSignalInfo_T), dimension(:), pointer :: siginfo=>NULL()
d53 1
a53 1
    & "$Id: ForwardModelInterface.f90,v 2.66 2001/04/06 21:53:40 vsnyder Exp $"
d56 1
a56 1
    & "$RCSfile: ForwardModelInterface.f90,v $"
d91 2
a92 2
        do signal = 1, size(database(config)%sigInfo)
          deallocate ( database(config)%sigInfo(signal)%channelIncluded, &
d97 1
a97 1
        deallocate ( database(config)%sigInfo, stat=status )
d149 1
a149 1
        do j = 1, size(database(i)%sigInfo)
d151 2
a152 1
          call GetSignalName( database(i)%sigInfo(j)%signal, signalName)
d154 1
a154 1
          call dump ( database(i)%sigInfo(j)%channelIncluded )
d162 4
a165 1
! $Log: $
@

