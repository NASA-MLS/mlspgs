head	2.17;
access;
symbols
	v5-02-NRT-19:2.17
	v6-00:2.17
	v5-02-NRT-18:2.17
	v5-02:2.17
	v5-01-NRT-17:2.17
	v5-01-NRT-16:2.17
	v5-01-NRT-15:2.17
	v5-01-NRT-14:2.17
	neuralnetworks-1-0:2.17.0.6
	cfm-single-freq-0-1:2.17.0.4
	v5-01:2.17
	v5-00:2.17
	v4-23-TA133:2.17.0.2
	mus-emls-1-70:2.16.0.2
	rel-1-0-englocks-work:2.15.0.4
	VUMLS1-00:2.15
	VPL1-00:2.15
	V4-22-NRT-08:2.15
	VAM1-00:2.15
	V4-21:2.15.0.2
	V4-13:2.15
	V4-12:2.15
	V4-11:2.14
	V4-10:2.14
	V3-43:2.12
	M4-00:2.14
	V3-41:2.12
	V3-40-PlusGM57:2.12.0.2
	V2-24-NRT-04:2.7
	V3-33:2.13
	V2-24:2.7
	V3-31:2.13
	V3-30-NRT-05:2.12
	cfm-01-00:2.12
	V3-30:2.12
	V3-20:2.12
	V3-10:2.11
	V2-23-NRT-02:2.7
	V2-23:2.7
	V2-22-NRT-01:2.7
	V2-22:2.7
	V2-21:2.6
	V2-20:2.6
	V2-11:2.6
	V2-10:2.6
	V2-00:2.6
	V1-51:2.1
	V1-50:2.1;
locks; strict;
comment	@# @;


2.17
date	2018.11.01.00.47.59;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2018.05.14.23.29.41;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2014.07.18.23.16.08;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2011.09.30.01.53.43;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2010.12.22.21.46.25;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2010.02.02.01.36.03;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2009.06.13.01.13.02;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2007.12.04.23.39.19;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2007.11.07.02.34.32;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2006.12.13.02.32.03;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2005.11.01.23.02.21;	author vsnyder;	state Exp;
branches;
next	2.5;

2.5
date	2005.10.24.20.14.41;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2005.06.22.18.08.20;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2005.03.28.20.23.41;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2005.03.03.02.08.32;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2004.10.07.17.34.15;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.17
log
@Add Underflow_Black_Out parameter.  Define Black_Out parameter using
Merge to select log(Underflow) or -15 as black-out value.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Tau_M

  use MLSCommon, only: RP

  implicit NONE
  private

  public :: Destroy_Tau, Dump, Dump_Tau, Get_Tau, Black_Out

  type, public :: Tau_T
    real(rp), pointer :: Tau(:,:) => NULL() ! Path X Frequencies
    integer, pointer :: I_Stop(:) => NULL() ! Amount of path to use, size = #Frequencies
  contains
    procedure :: Destroy_Tau
    generic :: Destroy => Destroy_Tau
    procedure :: Dump_Tau
    generic :: Dump => Dump_Tau
  end type Tau_T

  interface Dump; module procedure Dump_Tau; end interface Dump

  ! Use log(underflow) for real(rp), else use log(default real round-off),
  ! to compute black-out point
  logical, private, parameter :: Underflow_Black_Out = .false.

  real(rp), parameter :: black_out = & ! round-off or underflow for exp
!     merge ( -log(huge(1.0_rp)), log(epsilon(1.0)*1.0_rp), Underflow_Black_Out )
    merge ( -log(huge(1.0_rp)), -15.0_rp, Underflow_Black_Out )

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: Tau_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------

  ! ----------------------------------------------------  Get_Tau  -----
  subroutine Get_Tau ( Frq_i, gl_inds, more_inds, i_start, e_rflty,  &
                     & del_zeta, alpha_path, ref_cor, incoptdepth, &
                     & tan_pt, ds_dz_gw, tau )

  !{ Evaluate {\tt Tau(j)} = $\tau(s_j,s_m) = \int_{s_j}^{s_m}
  !  \alpha(s) \, \text{d} s$, where $s_m$ is the location of the instrument.
  !  Here, {\tt j = 1} is the instrument location.

  ! Update IncOptDepth with its GL corrections.  Multiply it by the
  ! refractive correction Ref_Cor.  Compute Tau = exp(indefinite sum of
  ! IncOptDepth).  The tangent point is a zero-thickness layer that
  ! doesn't have any IncOptDepth.  Instead, multiply tau(tan_pt) by
  ! e_rflty to get tau(tan_pt+1).

  ! This is just Rad_Tran without Inc_Rad_Path and Radiance calculations

    use GL_Update_Incoptdepth_m
    use MLSCommon, only: RP, IP

  ! inputs

    integer(ip), intent(in) :: Frq_I         ! Which frequency slice in Tau_T?
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
                                             ! where GL is needed
    integer, intent(in) :: I_Start           ! Where in path to start integrating
    real(rp), intent(in) :: e_rflty          ! Earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! Path -log(P) differences on the
                                             ! main grid.  This is for the whole
                                             ! coarse path, not just the part up
                                             ! to the black-out
    real(rp), intent(in) :: alpha_path(:)    ! Absorption coefficient on
                                             ! composite coarse & fine grid.
    real(rp), intent(in) :: ref_cor(:)       ! Refracted to unrefracted path
                                             ! length ratios.
    real(rp), intent(inout) :: incoptdepth(:) ! Incremental path opacities
                                             ! from one-sided layer calculation
                                             ! on output. It is the full
                                             ! integrated layer opacity.
    integer, intent(in) :: tan_pt            ! Tangent point index in IncOptDepth
    real(rp), intent(in) :: ds_dz_gw(:)      ! Path length wrt zeta derivative * gw.

  ! outputs

    type(tau_t), intent(inout) :: tau        ! Transmission function.  inout so
                                             ! as not to clobber the association
                                             ! status of its components. 
                                             ! Initial values not used.

  ! Internals

    integer :: I_Stop, N_Path
    real(rp) :: Total_Opacity

  ! Begin code

  ! see if anything needs to be gl-d

    call GL_update_incoptdepth ( gl_inds, more_inds, i_start, del_zeta, &
                               & alpha_path, ds_dz_gw, ref_cor, &
                               & incoptdepth )

  ! Compute Tau = exp(-indefinite sum of IncOptDepth)

    n_path = size(incoptdepth)
    total_opacity = 0.0_rp

    tau%tau(1:i_start,frq_i) = 1.0_rp

    !{ Compute $\tau_i$ for {\tt i_start} $ < i \leq t$, where $t$ is given by
    !  tan\_pt.
    !  $\tau_i = \exp \left \{ - \sum_{j=2}^i \Delta \delta_{j \rightarrow j-1}
    !  \right \}$.
    !  $\Delta \delta_{j \rightarrow j-1}$ is given by incoptdepth and
    !  $- \sum_{j=2}^i \Delta \delta_{j \rightarrow j-1}$ is given by
    !  total\_opacity.

    do i_stop = i_start+1, min(tan_pt,n_path)
      total_opacity = total_opacity - incoptdepth(i_stop)
      tau%tau(i_stop,frq_i) = exp(total_opacity)
      if ( total_opacity < black_out ) go to 19 ! Won't add anything
    end do
    if ( tan_pt >= n_path ) then
      i_stop = i_stop - 1
      go to 19
    end if

    !{ Account for earth reflectivity at the tangent to the surface:
    !  $\tau_{t + 1} = \Upsilon \tau_t$.

    if ( i_start < tan_pt ) then
      tau%tau(tan_pt+1,frq_i) = e_rflty * tau%tau(tan_pt,frq_i)
      total_opacity = total_opacity + log(e_rflty)
    else
      i_stop = i_start
    end if

    !{ Compute $\tau_i$ for $i > 2 N - t + 1$, where $t$ is given by tan\_pt.\\
    !  $\tau_i = \tau_{2N - t + 1} \exp \left \{ - \sum_{j=2N - t + 1}^i
    !    \Delta \delta_{j-1 \rightarrow j} \right \}$.

    ! i_stop is tan_pt + 1 here.

    if ( total_opacity >= black_out ) then
      do while ( i_stop < n_path )
        total_opacity = total_opacity - incoptdepth(i_stop)
        if ( total_opacity < black_out ) exit ! Won't add anything
        i_stop = i_stop + 1
        tau%tau(i_stop,frq_i) = exp(total_opacity)
      end do
    end if

19  continue
    tau%tau(i_stop+1:n_path,frq_i) = 0.0_rp

    tau%i_stop(frq_i) = i_stop

  end subroutine Get_Tau

! --------------------------------------------------  Destroy_Tau  -----
  subroutine Destroy_Tau ( Tau, What, Where )
    use Allocate_Deallocate, only: Deallocate_test
    class(tau_t), intent(inout) :: Tau
    character(len=*), intent(in) :: What, Where
    call deallocate_test ( tau%tau, what//"%Tau", where )
    call deallocate_test ( tau%i_stop, what//"%I_Stop", where )
  end subroutine Destroy_Tau

! -----------------------------------------------------  Dump_Tau  -----
  subroutine Dump_Tau ( Tau, NoFreqs, What, I_Start )
    use Dump_0, only: Dump
    use Output_m, only: Output

    class(tau_t), intent(in) :: Tau
    integer, intent(in) :: NoFreqs ! Number of frequences
    character(len=*), intent(in), optional :: What
    integer, intent(in), optional :: I_Start

    integer :: I, My_Start

    if ( present(what) ) call output ( what, advance='yes' )
    my_Start = 1
    if ( present(i_start) ) my_Start = i_start

    do i = 1, noFreqs
      call dump ( tau%tau(my_start:tau%i_stop(i),i) )
    end do

  end subroutine Dump_Tau

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Tau_m.f90,v 2.16 2018/05/14 23:29:41 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Tau_M

! $Log: Tau_m.f90,v $
! Revision 2.16  2018/05/14 23:29:41  vsnyder
! Make some procedures type bound, use GL_Update_Incoptdepth_m
!
! Revision 2.15  2014/07/18 23:16:08  pwagner
! Aimed for consistency in names passed to allocate_test
!
! Revision 2.14  2011/09/30 01:53:43  vsnyder
! Correct a comment
!
! Revision 2.13  2010/12/22 21:46:25  vsnyder
! TeXnicalities
!
! Revision 2.12  2010/02/02 01:36:03  vsnyder
! Don't reference incoptdepth and ref_cor before i_start
!
! Revision 2.11  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.10  2009/06/13 01:13:02  vsnyder
! Specify start and end of path
!
! Revision 2.9  2007/12/04 23:39:19  vsnyder
! Make black_out public
!
! Revision 2.8  2007/11/07 02:34:32  vsnyder
! Correct a comment
!
! Revision 2.7  2006/12/13 02:32:03  vsnyder
! Drag the tangent point around instead of assuming it's the middle one
!
! Revision 2.6  2005/11/01 23:02:21  vsnyder
! PFA Derivatives
!
! Revision 2.5  2005/10/24 20:14:41  vsnyder
! Tau after black out is zero, not one
!
! Revision 2.4  2005/06/22 18:08:20  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.3  2005/03/28 20:23:41  vsnyder
! Add nFreqs argument to dump routine
!
! Revision 2.2  2005/03/03 02:08:32  vsnyder
! Add Destroy, Dump routines
!
! Revision 2.1  2004/10/07 17:34:15  vsnyder
! Initial commit
!
@


2.16
log
@Make some procedures type bound, use GL_Update_Incoptdepth_m
@
text
@d33 7
a39 1
  real(rp), parameter :: black_out = -15.0_rp ! underflow for exp, roughly
d203 1
a203 1
       "$Id: Tau_m.f90,v 2.15 2014/07/18 23:16:08 pwagner Exp $"
d213 3
@


2.15
log
@Aimed for consistency in names passed to allocate_test
@
text
@d24 5
d45 2
a46 2
                     & del_zeta, alpha_path_c, ref_cor, incoptdepth, &
                     & tan_pt, alpha_path_gl, ds_dz_gw, tau )
d60 1
a60 1
    use GLNP, only: NG
d68 1
a68 1
  !                                            where GL is needed
d70 13
a82 11
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient on coarse
  !                                            grid.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
  !                                            length ratios.
    real(rp), intent(inout) :: incoptdepth(:) ! incremental path opacities
  !                            from one-sided layer calculation on output.
  !                            it is the full integrated layer opacity.
d84 1
a84 3
    real(rp), intent(in) :: alpha_path_gl(:) ! absorption coefficient on gl
  !                                            grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
d88 4
a91 3
    type(tau_t), intent(inout) :: tau        ! transmission function.  inout so
  !                            as not to clobber the association status of its
  !                            components.  Initial values not used.
d95 1
a95 1
    integer :: A, AA, I, II, I_Stop, N_Path
d102 3
a104 31
    if ( size(gl_inds) > 0 ) then

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt incoptdepth}.
      !  In the second integral, $G(\zeta)$ is {\tt alpha\_path\_gl} --
      !  which has already been evaluated at the appropriate abscissae -- and
      !  $G(\zeta_i)$ is {\tt alpha\_path\_c}.  The weights are {\tt gw}.

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        ii = more_inds(i)
        incoptdepth(ii) = incoptdepth(ii) + &
          & del_zeta(ii) * &
          & dot_product( (alpha_path_gl(a:a+ng-1) - alpha_path_c(ii)), &
               & ds_dz_gw(aa:aa+ng-1) )
        a = a + ng
      end do ! i

    end if

    incoptdepth(i_start:) = ref_cor(i_start:) * incoptdepth(i_start:)
d166 1
a166 1
    type(tau_t), intent(inout) :: Tau
d177 1
a177 1
    type(tau_t), intent(in) :: Tau
d197 1
a197 1
       "$Id: Tau_m.f90,v 2.14 2011/09/30 01:53:43 vsnyder Exp $"
d207 3
@


2.14
log
@Correct a comment
@
text
@d191 1
a191 1
    call deallocate_test ( tau%i_stop, what//"%I_stop", where )
d219 1
a219 1
       "$Id: Tau_m.f90,v 2.13 2010/12/22 21:46:25 vsnyder Exp $"
d229 3
@


2.13
log
@TeXnicalities
@
text
@d128 1
a128 1
  ! Compute Tau = exp(indefinite sum of IncOptDepth)
d219 1
a219 1
       "$Id: Tau_m.f90,v 2.12 2010/02/02 01:36:03 vsnyder Exp $"
d229 3
@


2.12
log
@Don't reference incoptdepth and ref_cor before i_start
@
text
@d43 4
d135 1
a135 1
    !{ Compute $\tau_i$ for $i_start < i \leq t$, where $t$ is given by
d219 1
a219 1
       "$Id: Tau_m.f90,v 2.11 2009/06/23 18:26:10 pwagner Exp $"
d229 3
@


2.11
log
@Prevent Intel from optimizing ident string away
@
text
@d32 1
a32 1
       "$RCSfile: $"
d122 1
a122 1
    incoptdepth = ref_cor * incoptdepth
d215 1
a215 1
       "$Id: read_apriori.f90 is it here $"
d225 3
@


2.10
log
@Specify start and end of path
@
text
@d32 2
a33 2
       "$RCSfile: Tau_m.f90,v $"
  private :: not_used_here
d212 1
a213 1
!---------------------------- RCS Ident Info -------------------------------
d215 2
a216 3
       "$Id: Tau_m.f90,v 2.9 2007/12/04 23:39:19 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d218 1
a218 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d220 1
d225 3
@


2.9
log
@Make black_out public
@
text
@d39 3
a41 3
  subroutine Get_Tau ( Frq_i, gl_inds, more_inds, e_rflty, del_zeta, &
                     &  alpha_path_c, ref_cor, incoptdepth, tan_pt, &
                     &  alpha_path_gl, ds_dz_gw, tau )
d45 1
a45 1
  ! IncOptDepth).  The half-path point is a zero-thickness layer that
d60 1
d85 2
a86 2
    integer :: A, AA, I, I_Stop, N_Path
    real(rp) :: total_opacity
d112 4
a115 3
        incoptdepth(more_inds(i)) = incoptdepth(more_inds(i)) + &
          & del_zeta(more_inds(i)) * &
          & dot_product( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))), &
a126 1
    tau%tau(1,frq_i) = 1.0_rp
d129 1
a129 4
!{ Compute $\tau_i$ for $2 \leq i \leq t$, where $t$ is given by half\_path.
!  $\tau_i = \exp \left \{ - \sum_{j=2}^i \Delta \delta_{j \rightarrow j-1} \right \}$.
!  $\Delta \delta_{j \rightarrow j-1}$ is given by incoptdepth and
!  $- \sum_{j=2}^i \Delta \delta_{j \rightarrow j-1}$ is given by total\_opacity.
d131 9
a139 1
    do i_stop = 2, tan_pt
d142 1
a142 1
      if ( total_opacity < black_out ) go to 99
d144 4
d149 2
a150 2
!{ Account for earth reflectivity at the tangent to the surface:
!  $\tau_{2N - t + 1} = \Upsilon \tau_t$.
d152 6
a157 1
    tau%tau(tan_pt+1,frq_i) = e_rflty * tau%tau(tan_pt,frq_i)
d159 14
a172 3
!{ Compute $\tau_i$ for $i > 2 N - t + 1$, where $t$ is given by half\_path.\\
!  $\tau_i = \tau_{2N - t + 1} \exp \left \{ - \sum_{j=2N - t + 1}^i
!    \Delta \delta_{j-1 \rightarrow j} \right \}$.
d174 2
a175 2
! We don't reset total_opacity, so we compute e_rflty * exp(total_opacity)
! instead of tau(tan_pt) * exp(total_opacity).  i_stop is tan_pt + 1 here.
a176 8
    do while ( total_opacity >= black_out .and. i_stop < n_path )
      total_opacity = total_opacity - incoptdepth(i_stop)
      i_stop = i_stop + 1
      tau%tau(i_stop,frq_i) = e_rflty * exp(total_opacity)
    end do

99  continue
    tau%tau(i_stop+1:n_path,frq_i) = 0.0_rp
d191 1
a191 1
  subroutine Dump_Tau ( Tau, NoFreqs, What )
d198 1
d200 1
a200 1
    integer :: I
d203 2
d207 1
a207 1
      call dump ( tau%tau(:tau%i_stop(i),i) )
d215 1
a215 1
       "$Id: Tau_m.f90,v 2.8 2007/11/07 02:34:32 vsnyder Exp $"
d219 1
d225 3
@


2.8
log
@Correct a comment
@
text
@d19 1
a19 1
  public :: Destroy_Tau, Dump, Dump_Tau, Get_Tau
d28 2
a85 1
    real(rp), parameter :: black_out = -15.0_rp
d194 1
a194 1
       "$Id: Tau_m.f90,v 2.7 2006/12/13 02:32:03 vsnyder Exp $"
d203 3
@


2.7
log
@Drag the tangent point around instead of assuming it's the middle one
@
text
@d42 1
a42 1
  ! refraction correction Ref_Cor.  Compute Tau = exp(indefinite sum of
d193 1
a193 1
       "$Id: Tau_m.f90,v 2.6 2005/11/01 23:02:21 vsnyder Exp $"
d202 3
@


2.6
log
@PFA Derivatives
@
text
@d38 1
a38 1
                     &  alpha_path_c, ref_cor, incoptdepth, &
d44 2
a45 2
  ! doesn't have any IncOptDepth.  Instead, multiply tau(half_path) by
  ! e_rflty to get tau(half_path+1).
d69 1
d82 1
a82 1
    integer :: A, AA, Half_Path, I, I_Stop, N_Path
a123 1
    half_path = n_path / 2
d132 1
a132 1
    do i_stop = 2, half_path
d141 1
a141 1
    tau%tau(half_path+1,frq_i) = e_rflty * tau%tau(half_path,frq_i)
d148 1
a148 1
! instead of tau(half_path) * exp(total_opacity).  i_stop is half_path + 1 here.
d193 1
a193 1
       "$Id: Tau_m.f90,v 2.5 2005/10/24 20:14:41 vsnyder Exp $"
d202 3
@


2.5
log
@Tau after black out is zero, not one
@
text
@d31 1
a31 1
  private :: not_used_here 
d47 2
d111 2
a112 2
          & sum( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))) * &            
               & ds_dz_gw(aa:aa+ng-1) ) 
d193 1
a193 1
       "$Id: Tau_m.f90,v 2.4 2005/06/22 18:08:20 pwagner Exp $"
d202 3
@


2.4
log
@Reworded Copyright statement, moved rcs id
@
text
@d30 1
a30 1
       "$RCSfile: $"
d44 1
a44 1
  ! doesn't have any IncOptDepth.  Instead, multiply tau(hal_path) by
d155 1
a155 1
    tau%tau(i_stop+1:n_path,frq_i) = 1.0_rp
d191 1
a191 1
       "$Id: $"
d200 3
@


2.3
log
@Add nFreqs argument to dump routine
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d28 3
a30 5
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: Tau_m.f90,v 2.2 2005/03/03 02:08:32 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = "$RCSfile: Tau_m.f90,v $"
d188 6
a193 1
  logical function NOT_USED_HERE()
d195 1
a195 1
  end function NOT_USED_HERE
d200 3
@


2.2
log
@Add Destroy, Dump routines
@
text
@d22 1
a22 1
    & "$Id: Tau_m.f90,v 2.1 2004/10/07 17:34:15 vsnyder Exp $"
d164 1
a164 1
  subroutine Dump_Tau ( Tau, What )
d169 1
d176 1
a176 1
    do i = 1, size(tau%i_stop)
d189 3
@


2.1
log
@Initial commit
@
text
@d11 1
a11 1
  public :: Get_Tau
d18 2
d22 1
a22 1
    & "$Id: rad_tran_m.f90,v 2.39 2004/08/03 22:06:46 vsnyder Exp $"
d24 1
a24 1
  character (len=*), parameter :: ModuleName = "$RCSfile: rad_tran_m.f90,v $"
d154 27
d187 4
a190 1
! $Log: $
@

