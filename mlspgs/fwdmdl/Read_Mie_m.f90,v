head	2.14;
access;
symbols
	v5-02-NRT-19:2.14
	v6-00:2.14
	v5-02-NRT-18:2.14
	v5-02:2.14
	v5-01-NRT-17:2.14
	v5-01-NRT-16:2.14
	v5-01-NRT-15:2.14
	v5-01-NRT-14:2.14
	neuralnetworks-1-0:2.14.0.8
	cfm-single-freq-0-1:2.14.0.6
	v5-01:2.14
	v5-00:2.14
	v4-23-TA133:2.14.0.4
	mus-emls-1-70:2.14.0.2
	rel-1-0-englocks-work:2.13.0.2
	VUMLS1-00:2.13
	VPL1-00:2.13
	V4-22-NRT-08:2.13
	VAM1-00:2.13
	V4-21:2.12.0.2
	V4-13:2.12
	V4-12:2.11
	V4-11:2.11
	V4-10:2.11
	V3-43:2.8
	M4-00:2.10
	V3-41:2.8
	V3-40-PlusGM57:2.8.0.2
	V3-33:2.10
	V3-31:2.10
	V3-30-NRT-05:2.9
	cfm-01-00:2.9
	V3-30:2.8
	V3-20:2.8
	V3-10:2.6;
locks; strict;
comment	@# @;


2.14
date	2018.05.15.03.26.25;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2015.03.28.02.03.48;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2014.09.05.20.52.32;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2013.06.12.02.21.57;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2011.01.26.02.50.43;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2010.06.07.23.13.02;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2010.01.14.02.24.06;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2009.08.20.19.47.26;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2009.05.13.20.03.01;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2008.10.20.23.23.20;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2008.07.31.18.00.13;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2008.06.05.02.15.26;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2008.05.20.00.26.40;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.14
log
@Change Mie tables from pointer to allocatable
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Read_Mie_m

  ! Read the Mie tables produced by the Mie_Tables program.

  use MLSKinds, only: R8, RP

  implicit NONE
  private
  public :: Destroy_Log_Mie, Destroy_Mie, Dump_Mie, Log_Mie, Read_Mie

  ! Coordinates
  real(rp), public, target, allocatable :: F_s(:)     ! MHz
  real(rp), public, target, allocatable :: IWC_s(:)   ! log10(IWC)
  real(rp), public, target, allocatable :: T_s(:)     ! K
  real(rp), public, target, allocatable :: Theta_s(:) ! Radians above horizon
  ! Betas
  real(r8), public, target, allocatable :: Beta_c_a(:,:,:)      ! T X IWC X F
  real(r8), public, target, allocatable :: Beta_c_e(:,:,:)      ! T X IWC X F
  real(r8), public, target, allocatable :: Beta_c_s(:,:,:)      ! T X IWC X F
  real(r8), public, target, allocatable :: Log_Beta_c_a(:,:,:)  ! T X IWC X F
  real(r8), public, target, allocatable :: Log_Beta_c_e(:,:,:)  ! T X IWC X F
  real(r8), public, target, allocatable :: Log_Beta_c_s(:,:,:)  ! T X IWC X F
  ! Beta derivatives
  real(r8), public, target, allocatable :: dBeta_dIWC_c_a(:,:,:)     ! T X IWC X F
  real(r8), public, target, allocatable :: dBeta_dT_c_a(:,:,:)       ! T X IWC X F
  real(r8), public, target, allocatable :: dBeta_dIWC_c_e(:,:,:)     ! T X IWC X F
  real(r8), public, target, allocatable :: dBeta_dT_c_e(:,:,:)       ! T X IWC X F
  real(r8), public, target, allocatable :: dBeta_dIWC_c_s(:,:,:)     ! T X IWC X F
  real(r8), public, target, allocatable :: dBeta_dT_c_s(:,:,:)       ! T X IWC X F
  ! Phase
  real(r8), public, target, allocatable :: P(:,:,:,:)       ! T X IWC X Theta X F
  ! Phase Derivatives
  real(r8), public, target, allocatable :: dP_dIWC(:,:,:,:) ! T X IWC X Theta X F
  real(r8), public, target, allocatable :: dP_dT(:,:,:,:)   ! T X IWC X Theta X F

!---------------------------- RCS Ident Info -------------------------------
  character(len=*), private, parameter :: ModuleName= &
       "$RCSfile: Read_Mie_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

contains

  ! --------------------------------------------- Destroy_Log_Mie  -----
  subroutine Destroy_Log_Mie
  ! Deallocate the Log Mie tables

    use Allocate_Deallocate, only: Byte_Size, Test_DeAllocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Status
    integer :: S

    if ( allocated(log_beta_c_a) ) then
      s = byte_size(log_beta_c_a)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(log_beta_c_a(1,1,1)), addr)
      deallocate ( log_beta_c_a, stat=status )
      call test_deallocate ( status, moduleName, 'log_beta_c_a', s, address=addr )
    end if
    if ( allocated(log_beta_c_e) ) then
      s = byte_size(log_beta_c_e)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(log_beta_c_e(1,1,1)), addr)
      deallocate ( log_beta_c_e, stat=status )
      call test_deallocate ( status, moduleName, 'log_beta_c_e', s, address=addr )
    end if
    if ( allocated(log_beta_c_s) ) then
      s = byte_size(log_beta_c_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(log_beta_c_s(1,1,1)), addr)
      deallocate ( log_beta_c_s, stat=status )
      call test_deallocate ( status, moduleName, 'log_beta_c_s', s, address=addr )
    end if
  end subroutine Destroy_Log_Mie
  
  ! ------------------------------------------------  Destroy_Mie  -----
  subroutine Destroy_Mie
  ! Deallocate the Mie tables

    use Allocate_Deallocate, only: Byte_Size, Test_DeAllocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Status
    integer :: S

    if ( allocated(f_s) ) then
      s = byte_size(f_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(f_s(1)), addr)
      deallocate ( f_s, stat=status )
      call test_deallocate ( status, moduleName, 'F_s', s, address=addr )
      s = byte_size(iwc_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(iwc_s(1)), addr)
      deallocate ( iwc_s, stat=status )
      call test_deallocate ( status, moduleName, 'iwc_s', s, address=addr )
      s = byte_size(t_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(t_s(1)), addr)
      deallocate ( t_s, stat=status )
      call test_deallocate ( status, moduleName, 't_s', s, address=addr )
      s = byte_size(theta_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(theta_s(1)), addr)
      deallocate ( theta_s, stat=status )
      call test_deallocate ( status, moduleName, 'theta_s', s, address=addr )
      s = byte_size(beta_c_a)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(beta_c_a(1,1,1)), addr)
      deallocate ( beta_c_a, stat=status )
      call test_deallocate ( status, moduleName, 'beta_c_a', s, address=addr )
      s = byte_size(beta_c_e)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(beta_c_e(1,1,1)), addr)
      deallocate ( beta_c_e, stat=status )
      call test_deallocate ( status, moduleName, 'beta_c_e', s, address=addr )
      s = byte_size(beta_c_s)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(beta_c_s(1,1,1)), addr)
      deallocate ( beta_c_s, stat=status )
      call test_deallocate ( status, moduleName, 'beta_c_s', s, address=addr )
      s = byte_size(P)
      addr = 0
      if ( s > 0 ) addr = transfer(c_loc(P(1,1,1,1)), addr)
      deallocate ( P, stat=status )
      call test_deallocate ( status, moduleName, 'P', s, address=addr )
      if ( allocated(dP_dIWC) ) then
        s = byte_size(dBeta_dIWC_c_a)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dIWC_c_a(1,1,1)), addr)
        deallocate ( dBeta_dIWC_c_a, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_a', s, address=addr )
        s = byte_size(dBeta_dT_c_a)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dT_c_a(1,1,1)), addr)
        deallocate ( dBeta_dT_c_a, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_a', s, address=addr )
        s = byte_size(dBeta_dIWC_c_e)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dIWC_c_e(1,1,1)), addr)
        deallocate ( dBeta_dIWC_c_e, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_e', s, address=addr )
        s = byte_size(dBeta_dT_c_e)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dT_c_e(1,1,1)), addr)
        deallocate ( dBeta_dT_c_e, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_e', s, address=addr )
        s = byte_size(dBeta_dIWC_c_s)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dIWC_c_s(1,1,1)), addr)
        deallocate ( dBeta_dIWC_c_s, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_s', s, address=addr )
        s = byte_size(dBeta_dT_c_s)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dBeta_dT_c_s(1,1,1)), addr)
        deallocate ( dBeta_dT_c_s, stat=status )
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_s', s, address=addr )
        s = byte_size(dP_dIWC)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dP_dIWC(1,1,1,1)), addr)
        deallocate ( dP_dIWC, stat=status )
        call test_deallocate ( status, moduleName, 'dP_dIWC', s, address=addr )
        s = byte_size(dP_dT)
        addr = 0
        if ( s > 0 ) addr = transfer(c_loc(dP_dT(1,1,1,1)), addr)
        deallocate ( dP_dT, stat=status )
        call test_deallocate ( status, moduleName, 'dP_dT', s, address=addr )
      end if
    end if

    call destroy_log_mie

  end subroutine Destroy_Mie

  ! ---------------------------------------------------  Dump_Mie  -----
  subroutine Dump_Mie ( Details )
  ! Dump the Mie tables
  ! Details <= 0 => F_s, T_s, IWC_s, Theta_s
  !          = 1 => 0 + P
  !         >= 2 => 1 + dP_dIWC + dP_dT
    use Dump_0, only: Dump
    use Output_m, only: Output
    use Constants, only: Rad2Deg
    integer, intent(in) :: Details
    integer :: I_f, I_theta
    if ( .not. allocated(f_s) ) return
    call dump ( f_s, name='F_s (MHz)' )
    call dump ( T_s, name='T_s (K)' )
    call dump ( IWC_s, name='IWC_s (actually log10 IWC)' )
    call dump ( Rad2Deg*theta_s, name='Theta_s (Degrees)' )
    if ( details <= 0 ) return
    do i_f = 1, size(f_s)
      call output ( f_s(i_f), before='Beta_c_a(T X IWC), F = ', advance='yes' )
      call dump ( beta_c_a(:,:,i_f) )
      call output ( f_s(i_f), before='Beta_c_e(T X IWC), F = ', advance='yes' )
      call dump ( beta_c_e(:,:,i_f) )
      if ( allocated(log_beta_c_a) ) then
        call output ( f_s(i_f), before='log_beta_c_a(T X IWC), F = ', advance='yes' )
        call dump ( log_beta_c_a(:,:,i_f) )
      end if
      if ( allocated(log_beta_c_e) ) then
        call output ( f_s(i_f), before='Log_Beta_c_e(T X IWC), F = ', advance='yes' )
        call dump ( log_beta_c_e(:,:,i_f) )
      end if
      call output ( f_s(i_f), before='Beta_c_s(T X IWC), F = ', advance='yes' )
      call dump ( beta_c_s(:,:,i_f) )
      if ( allocated(log_beta_c_s) ) then
        call output ( f_s(i_f), before='Log_Beta_c_s(T X IWC), F = ', advance='yes' )
        call dump ( log_beta_c_s(:,:,i_f) )
      end if
      if ( allocated(dBeta_dIWC_c_a) .and. details >= 2 ) then
        call output ( f_s(i_f), before='dBeta_dIWC_c_a(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dIWC_c_a(:,:,i_f) )
        call output ( f_s(i_f), before='dBeta_dT_c_a(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dT_c_a(:,:,i_f) )
        call output ( f_s(i_f), before='dBeta_dIWC_c_e(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dIWC_c_e(:,:,i_f) )
        call output ( f_s(i_f), before='dBeta_dT_c_e(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dT_c_e(:,:,i_f) )
        call output ( f_s(i_f), before='dBeta_dIWC_c_s(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dIWC_c_s(:,:,i_f) )
        call output ( f_s(i_f), before='dBeta_dT_c_s(T X IWC), F = ', advance='yes' )
        call dump ( dBeta_dT_c_s(:,:,i_f) )
      end if
      do i_theta = 1, size(theta_s)
        call output ( Rad2Deg*theta_s(i_theta), before='P(T X IWC,' )
        call output ( f_s(i_f), before=') F = ', advance='yes' )
        call dump ( p(:,:,i_theta,i_f) )
        if ( allocated(dP_dIWC) .and. details >= 2 ) then
          call output ( Rad2Deg*theta_s(i_theta), before='dP_dIWC(T X IWC,' )
          call output ( f_s(i_f), before=') F = ', advance='yes' )
          call dump ( dP_dIWC(:,:,i_theta,i_f) )
          call output ( Rad2Deg*theta_s(i_theta), before='dP_dT(T X IWC,' )
          call output ( f_s(i_f), before=') F = ', advance='yes' )
          call dump ( dP_dT(:,:,i_theta,i_f) )
        end if
      end do
    end do
  end subroutine Dump_Mie

  ! ----------------------------------------------------  Log_Mie  -----
  subroutine Log_Mie
  ! If any of Log_Beta_c_a, Log_Beta_c_e, Log_Beta_c_s are not associated,
  ! allocate them and compute them.  Read_Mie has to be called first.

    use Allocate_Deallocate, only: Bytes, Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: Status

    if ( .not. allocated(beta_c_e) ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & 'Cannot compute log(beta...) before allocating beta.')

    if ( .not. allocated(log_beta_c_a) ) then
      allocate ( &
        & log_beta_c_a(ubound(beta_c_e,1),ubound(beta_c_e,2),ubound(beta_c_e,3)), &
        & stat=status )
      addr = 0
      if ( status == 0 ) then
        if ( size(log_beta_c_a) > 0 ) addr = transfer(c_loc(log_beta_c_a(1,1,1)), addr)
      end if
      call test_allocate ( status, moduleName, 'log_beta_c_a', (/ 1,1,1 /), &
          & ubound(beta_c_e), bytes(beta_c_e), address=addr )
      log_beta_c_a = log(beta_c_e)
    end if
    if ( .not. allocated(log_beta_c_e) ) then
      allocate ( &
        & log_beta_c_e(ubound(beta_c_e,1),ubound(beta_c_e,2),ubound(beta_c_e,3)), &
        & stat=status )
      addr = 0
      if ( status == 0 ) then
        if ( size(log_beta_c_e) > 0 ) addr = transfer(c_loc(log_beta_c_e(1,1,1)), addr)
      end if
      call test_allocate ( status, moduleName, 'Log_Beta_c_e', (/ 1,1,1 /), &
          & ubound(beta_c_e), bytes(log_beta_c_e), address=addr )
      log_beta_c_e = log(beta_c_e)
    end if
    if ( .not. allocated(log_beta_c_s) ) then
      allocate ( &
        & log_beta_c_s(ubound(beta_c_s,1),ubound(beta_c_s,2),ubound(beta_c_s,3)), &
        & stat=status )
      addr = 0
      if ( status == 0 ) then
        if ( size(log_beta_c_s) > 0 ) addr = transfer(c_loc(log_beta_c_s(1,1,1)), addr)
      end if
      call test_allocate ( status, moduleName, 'Log_Beta_c_s', (/ 1,1,1 /), &
          & ubound(beta_c_s), bytes(beta_c_s), address=addr )
      log_beta_c_s = log(beta_c_s)
    end if
  end subroutine Log_Mie

  ! ---------------------------------------------------  Read_Mie  -----
  subroutine Read_Mie ( FileName )

    use Allocate_Deallocate, only: Bytes, Test_Allocate
    use, intrinsic :: ISO_C_Binding, only: C_Intptr_t, C_Loc
    use Machine, only: IO_Error
    use MLSHDF5, only: IsHDF5DSPresent, loadAllocFromHDF5DS
    use HDF5, only: H5FClose_f, H5FOpen_f, H5F_ACC_RDONLY_F
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSStrings, only: Capitalize

    character(len=*), intent(in) :: FileName

    integer(c_intptr_t) :: Addr         ! For tracing
    integer :: FileID, Lun, Status

    integer :: N_f, N_IWC, N_T, N_theta, N_cut
    real(r8) :: R_min, R_max
    logical :: Derivs

    ! Destroy the old database
    call destroy_Mie

    if ( index(capitalize(fileName),'.HDF') /= 0 ) then
      ! Read tables from HDF5 file
      call H5FOpen_f ( trim(fileName), H5F_ACC_RDONLY_F, fileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open Mie tables file " // trim(fileName) )
      ! Get the index arrays
      call loadAllocFromHDF5DS ( fileID, 'IWC_s', iwc_s )
      call loadAllocFromHDF5DS ( fileID, 'T_s', T_s )
      call loadAllocFromHDF5DS ( fileID, 'Theta_s', theta_s )
      call loadAllocFromHDF5DS ( fileID, 'F_s', f_s )
      f_s = 1000.0 * f_s ! F_s are GHz, standard unit is MHz
      ! Get the betas
      call loadAllocFromHDF5DS ( fileID, 'Beta_c_a', Beta_c_a )
      call loadAllocFromHDF5DS ( fileID, 'Beta_c_e', Beta_c_e )
      call loadAllocFromHDF5DS ( fileID, 'Beta_c_s', Beta_c_s )
      ! Get the beta derivatives
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dIWC_c_a', dBeta_dIWC_c_a )
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dT_c_a', dBeta_dT_c_a )
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dIWC_c_e', dBeta_dIWC_c_e )
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dT_c_e', dBeta_dT_c_e )
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dIWC_c_s', dBeta_dIWC_c_s )
      call loadAllocFromHDF5DS ( fileID, 'dBeta_dT_c_s', dBeta_dT_c_s )
      ! Get the phase function
      call loadAllocFromHDF5DS ( fileID, 'P', P )
      ! Get the phase function derivatives
      if ( IsHDF5DSPresent ( fileID, 'dP_dIWC' ) ) then
        call loadAllocFromHDF5DS ( fileID, 'dP_dIWC', dP_dIWC )
        call loadAllocFromHDF5DS ( fileID, 'dP_dT', dP_dT )
      end if
      call H5FClose_f ( fileID, status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to close Mie tables file " // trim(fileName) )
    else
      ! Read tables from Fortran unformatted file
      ! Open the file
      open ( newunit=lun, file=filename, status='old', form='unformatted', &
        & access='sequential', iostat=status )
      if ( status /= 0 ) then
        call io_error ( "Unable to open Mie tables file ", status, filename )
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & "Unable to open Mie tables file " // trim(fileName) )
      end if

      ! Read some sizes and scalars
      read ( lun ) n_f, n_IWC, n_T, n_theta, r_min, r_max, n_cut, derivs

      ! Allocate and read the coordinate arrays
      allocate ( f_s(n_f), stat=status )
      addr = 0
      if ( status == 0 .and. n_f > 0 ) addr = transfer(c_loc(f_s(1)), addr)
      call test_allocate ( status, moduleName, 'F_s', (/ 1 /), (/ n_f /), &
        & bytes(f_s), address=addr )
      allocate ( iwc_s(n_iwc), stat=status )
      addr = 0
      if ( status == 0 .and. n_iwc > 0 ) addr = transfer(c_loc(iwc_s(1)), addr)
      call test_allocate ( status, moduleName, 'IWC_s', (/ 1 /), (/ n_iwc /), &
        & bytes(iwc_s), address=addr )
      allocate ( T_s(n_T), stat=status )
      addr = 0
      if ( status == 0 .and. n_T > 0 ) addr = transfer(c_loc(T_s(1)), addr)
      call test_allocate ( status, moduleName, 'T_s', (/ 1 /), (/ n_T /), &
        & bytes(T_s), address=addr )
      allocate ( theta_s(n_theta), stat=status )
      addr = 0
      if ( status == 0 .and. n_theta > 0 ) addr = transfer(c_loc(theta_s(1)), addr)
      call test_allocate ( status, moduleName, 'theta_s', (/ 1 /), (/ n_theta /), &
        & bytes(theta_s), address=addr )
      read ( lun ) iwc_s, t_s, theta_s, f_s

      ! Allocate the phase array and its derivatives
      allocate ( p(n_t, n_iwc, n_theta, n_f), stat=status )
      addr = 0
      if ( status == 0 ) then
        if ( size(p) > 0 ) addr = transfer(c_loc(p(1,1,1,1)), addr)
      end if
      call test_allocate ( status, moduleName, 'P', (/ 1,1,1,1 /), &
        & (/ n_t,n_iwc,n_theta,n_f /), bytes(p), address=addr )
      if ( derivs ) then
        allocate ( dP_dIWC(n_t, n_iwc, n_theta, n_f), stat=status )
        addr = 0
        if ( status == 0 ) then
          if ( size(dP_dIWC) > 0 ) addr = transfer(c_loc(dP_dIWC(1,1,1,1)), addr)
        end if
        call test_allocate ( status, moduleName, 'dP_dIWC', (/ 1,1,1,1 /), &
          & (/ n_t,n_iwc,n_theta,n_f /), bytes(dP_dIWC), address=addr )
        allocate ( dP_dT(n_t, n_iwc, n_theta, n_f), stat=status )
        addr = 0
        if ( status == 0 ) then
          if ( size(dP_dT) > 0 ) addr = transfer(c_loc(dP_dT(1,1,1,1)), addr)
        end if
        call test_allocate ( status, moduleName, 'dP_dT', (/ 1,1,1,1 /), &
          & (/ n_t,n_iwc,n_theta,n_f /), bytes(dP_dT), address=addr )
      end if

      ! Read everything
      call Read_Mie_Auto
      if ( derivs ) call Read_Mie_Derivs_Auto

      close ( lun )
    end if

  contains

    ! These are internal subroutines to avoid a bunch of explicit allocations
    subroutine Read_Mie_Auto

      integer, parameter :: I_c_e = 1, I_c_s = 2

!     real(r8) :: Beta(n_t,n_iwc,n_f,2) ! Final dimension: 1 = Beta(c_e), 2 = Beta(c_s)
!     real(r8) :: Eest(n_t,n_iwc,n_f,2) ! Error estimate
!     integer :: NFunc(2,n_t,n_iwc,n_f,2)
!     integer :: MaxOrd(n_t,n_iwc,n_f,2)
      real(r8) :: E_P(n_t,n_iwc,n_theta,n_f) ! Error estimate
      integer :: NFuncP(2, n_t, n_iwc, n_theta, n_f, 3)
      integer :: MaxOrdP(n_t, n_iwc, n_theta, n_f, 3)

!     read ( lun ) beta(:,:,:,i_c_e), eest(:,:,:,i_c_e), nFunc(:,:,:,:,i_c_e), maxOrd(:,:,:,i_c_e)
!     read ( lun ) beta(:,:,:,i_c_s), eest(:,:,:,i_c_s), nFunc(:,:,:,:,i_c_s), maxOrd(:,:,:,i_c_s)
      read ( lun ) ! Skip beta(:,:,:,i_c_e) etc
      read ( lun ) ! Skip beta(:,:,:,i_c_s) etc
      read ( lun ) p, e_p, nFuncP(:,:,:,:,:,1), maxOrdP(:,:,:,:,1)
    end subroutine Read_Mie_Auto

    subroutine Read_Mie_Derivs_Auto

      integer, parameter :: I_c_e = 1, I_c_s = 2

!     real(r8) :: dBeta_dIWC(n_t, n_iwc, n_f, 2)
!     real(r8) :: E_dBeta_dIWC(n_t, n_iwc, n_f, 2) ! Error estimate
!     real(r8) :: dBeta_dT(n_t, n_iwc, n_f, 2)
!     real(r8) :: E_dBeta_dT(n_t, n_iwc, n_f, 2) ! Error estimate
!     integer :: NFunc(2,n_t,n_iwc,n_f,3:6)
!     integer :: MaxOrd(n_t,n_iwc,n_f,3:6)
      real(r8) :: e_dP_dIWC(n_t,n_iwc,n_theta,n_f) ! Error estimate
      integer :: NFuncP(2,n_t,n_iwc,n_theta,n_f,3)
      integer :: MaxOrdP(n_t,n_iwc,n_theta,n_f,3)
      real(r8) :: e_dP_dT(n_t,n_iwc,n_theta,n_f) ! Error estimate

!     read ( lun ) dBeta_dIWC(:,:,:,i_c_e),  e_dBeta_dIWC(:,:,:,i_c_e), nFunc(:,:,:,:,3), maxOrd(:,:,:,3)
!     read ( lun ) dBeta_dIWC(:,:,:,i_c_s),  e_dBeta_dIWC(:,:,:,i_c_s), nFunc(:,:,:,:,4), maxOrd(:,:,:,4)
!     read ( lun ) dBeta_dT(:,:,:,i_c_e),  e_dBeta_dT(:,:,:,i_c_e), nFunc(:,:,:,:,5), maxOrd(:,:,:,5)
!     read ( lun ) dBeta_dT(:,:,:,i_c_s),  e_dBeta_dT(:,:,:,i_c_s), nFunc(:,:,:,:,6), maxOrd(:,:,:,6)
      read ( lun ) ! skip dBeta_dIWC(:,:,:,i_c_e) etc
      read ( lun ) ! skip dBeta_dIWC(:,:,:,i_c_s) etc
      read ( lun ) ! skip dBeta_dT(:,:,:,i_c_e) etc
      read ( lun ) ! skip dBeta_dT(:,:,:,i_c_s) etc
      read ( lun ) dP_dIWC, e_dP_dIWC, nFuncP(:,:,:,:,:,2), maxOrdP(:,:,:,:,2)
      read ( lun ) dP_dT, e_dP_dT, nFuncP(:,:,:,:,:,3), maxOrdP(:,:,:,:,3)
    end subroutine Read_Mie_Derivs_Auto

  end subroutine Read_Mie

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: Read_Mie_m.f90,v 2.13 2015/03/28 02:03:48 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Read_Mie_m

! $Log: Read_Mie_m.f90,v $
! Revision 2.13  2015/03/28 02:03:48  vsnyder
! Added stuff to trace allocate/deallocate addresses.  Use NewUnit=
! specifier in OPEN statement instead of Get_Lun.
!
! Revision 2.12  2014/09/05 20:52:32  vsnyder
! More complete and accurate allocate/deallocate size tracking
!
! Revision 2.11  2013/06/12 02:21:57  vsnyder
! Use BYTE_SIZE from Allocate_Deallocate
!
! Revision 2.10  2011/01/26 02:50:43  vsnyder
! Add more support for beta_c_a separately from beta_c_e
!
! Revision 2.9  2010/06/07 23:13:02  vsnyder
! Added ability to compute and store Log_Beta_c_e and Log_Beta_c_s
!
! Revision 2.8  2010/01/14 02:24:06  vsnyder
! Add some comments
!
! Revision 2.7  2009/08/20 19:47:26  vsnyder
! Replace THETA_s by Theta_s to conform to Mie_Tables
!
! Revision 2.6  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.5  2009/05/13 20:03:01  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.4  2008/10/20 23:23:20  vsnyder
! Convert F_s from GHz to MHz, since MHz is the standard unit
!
! Revision 2.3  2008/07/31 18:00:13  vsnyder
! Change coordinates from R8 to RP
!
! Revision 2.2  2008/06/05 02:15:26  vsnyder
! Added HDF, spiffed up dump
!
! Revision 2.1  2008/05/20 00:26:40  vsnyder
! Initial commit
!
@


2.13
log
@Added stuff to trace allocate/deallocate addresses.  Use NewUnit=
specifier in OPEN statement instead of Get_Lun.
@
text
@d23 4
a26 4
  real(rp), public, pointer :: F_s(:) => NULL()     ! MHz
  real(rp), public, pointer :: IWC_s(:) => NULL()   ! log10(IWC)
  real(rp), public, pointer :: T_s(:) => NULL()     ! K
  real(rp), public, pointer :: Theta_s(:) => NULL() ! Radians above horizon
d28 6
a33 6
  real(r8), public, pointer :: Beta_c_a(:,:,:) => NULL()      ! T X IWC X F
  real(r8), public, pointer :: Beta_c_e(:,:,:) => NULL()      ! T X IWC X F
  real(r8), public, pointer :: Beta_c_s(:,:,:) => NULL()      ! T X IWC X F
  real(r8), public, pointer :: Log_Beta_c_a(:,:,:) => NULL()  ! T X IWC X F
  real(r8), public, pointer :: Log_Beta_c_e(:,:,:) => NULL()  ! T X IWC X F
  real(r8), public, pointer :: Log_Beta_c_s(:,:,:) => NULL()  ! T X IWC X F
d35 6
a40 6
  real(r8), public, pointer :: dBeta_dIWC_c_a(:,:,:) => NULL()     ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_a(:,:,:) => NULL()       ! T X IWC X F
  real(r8), public, pointer :: dBeta_dIWC_c_e(:,:,:) => NULL()     ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_e(:,:,:) => NULL()       ! T X IWC X F
  real(r8), public, pointer :: dBeta_dIWC_c_s(:,:,:) => NULL()     ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_s(:,:,:) => NULL()       ! T X IWC X F
d42 1
a42 1
  real(r8), public, pointer :: P(:,:,:,:) => NULL()       ! T X IWC X Theta X F
d44 2
a45 2
  real(r8), public, pointer :: dP_dIWC(:,:,:,:) => NULL() ! T X IWC X Theta X F
  real(r8), public, pointer :: dP_dT(:,:,:,:) => NULL()   ! T X IWC X Theta X F
d66 1
a66 1
    if ( associated(log_beta_c_a) ) then
d73 1
a73 1
    if ( associated(log_beta_c_e) ) then
d80 1
a80 1
    if ( associated(log_beta_c_s) ) then
d100 1
a100 1
    if ( associated(f_s) ) then
d141 1
a141 1
      if ( associated(dP_dIWC) ) then
d200 1
a200 1
    if ( .not. associated(f_s) ) return
d211 1
a211 1
      if ( associated(log_beta_c_a) ) then
d215 1
a215 1
      if ( associated(log_beta_c_e) ) then
d221 1
a221 1
      if ( associated(log_beta_c_s) ) then
d225 1
a225 1
      if ( associated(dBeta_dIWC_c_a) .and. details >= 2 ) then
d243 1
a243 1
        if ( associated(dP_dIWC) .and. details >= 2 ) then
d266 1
a266 1
    if ( .not. associated(beta_c_e) ) call MLSMessage ( MLSMSG_Error, moduleName, &
d269 1
a269 1
    if ( .not. associated(log_beta_c_a) ) then
d281 1
a281 1
    if ( .not. associated(log_beta_c_e) ) then
d293 1
a293 1
    if ( .not. associated(log_beta_c_s) ) then
d313 1
a313 1
    use MLSHDF5, only: IsHDF5DSPresent, LoadPtrFromHDF5DS
d336 4
a339 4
      call loadPtrFromHDF5DS ( fileID, 'IWC_s', iwc_s )
      call loadPtrFromHDF5DS ( fileID, 'T_s', T_s )
      call loadPtrFromHDF5DS ( fileID, 'Theta_s', theta_s )
      call loadPtrFromHDF5DS ( fileID, 'F_s', f_s )
d342 3
a344 3
      call loadPtrFromHDF5DS ( fileID, 'Beta_c_a', Beta_c_a )
      call loadPtrFromHDF5DS ( fileID, 'Beta_c_e', Beta_c_e )
      call loadPtrFromHDF5DS ( fileID, 'Beta_c_s', Beta_c_s )
d346 6
a351 6
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dIWC_c_a', dBeta_dIWC_c_a )
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dT_c_a', dBeta_dT_c_a )
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dIWC_c_e', dBeta_dIWC_c_e )
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dT_c_e', dBeta_dT_c_e )
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dIWC_c_s', dBeta_dIWC_c_s )
      call loadPtrFromHDF5DS ( fileID, 'dBeta_dT_c_s', dBeta_dT_c_s )
d353 1
a353 1
      call loadPtrFromHDF5DS ( fileID, 'P', P )
d356 2
a357 2
        call loadPtrFromHDF5DS ( fileID, 'dP_dIWC', dP_dIWC )
        call loadPtrFromHDF5DS ( fileID, 'dP_dT', dP_dT )
d485 1
a485 1
       "$Id: Read_Mie_m.f90,v 2.12 2014/09/05 20:52:32 vsnyder Exp $"
d495 4
@


2.12
log
@More complete and accurate allocate/deallocate size tracking
@
text
@d60 1
d62 1
d68 2
d71 1
a71 1
      call test_deallocate ( status, moduleName, 'log_beta_c_a', s )
d75 2
d78 1
a78 1
      call test_deallocate ( status, moduleName, 'log_beta_c_e', s )
d82 2
d85 1
a85 1
      call test_deallocate ( status, moduleName, 'log_beta_c_s', s )
d94 1
d96 1
d102 2
d105 1
a105 1
      call test_deallocate ( status, moduleName, 'F_s', s )
d107 2
d110 1
a110 1
      call test_deallocate ( status, moduleName, 'iwc_s', s )
d112 2
d115 1
a115 1
      call test_deallocate ( status, moduleName, 't_s', s )
d117 2
d120 1
a120 1
      call test_deallocate ( status, moduleName, 'theta_s', s )
d122 2
d125 1
a125 1
      call test_deallocate ( status, moduleName, 'beta_c_a', s )
d127 2
d130 1
a130 1
      call test_deallocate ( status, moduleName, 'beta_c_e', s )
d132 2
d135 1
a135 1
      call test_deallocate ( status, moduleName, 'beta_c_s', s )
d137 2
d140 1
a140 1
      call test_deallocate ( status, moduleName, 'P', s )
d143 2
d146 1
a146 1
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_a', s )
d148 2
d151 1
a151 1
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_a', s )
d153 2
d156 1
a156 1
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_e', s )
d158 2
d161 1
a161 1
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_e', s )
d163 2
d166 1
a166 1
        call test_deallocate ( status, moduleName, 'dBeta_dIWC_c_s', s )
d168 2
d171 1
a171 1
        call test_deallocate ( status, moduleName, 'dBeta_dT_c_s', s )
d173 2
d176 1
a176 1
        call test_deallocate ( status, moduleName, 'dP_dIWC', s )
d178 2
d181 1
a181 1
        call test_deallocate ( status, moduleName, 'dP_dT', s )
d261 1
d263 1
d273 4
d278 1
a278 1
          & ubound(beta_c_e), bytes(beta_c_e) )
d285 4
d290 1
a290 1
          & ubound(beta_c_e), bytes(log_beta_c_e) )
d297 4
d302 1
a302 1
          & ubound(beta_c_s), bytes(beta_c_s) )
d311 1
a311 1
    use IO_stuff, only: Get_Lun
d320 1
d365 1
a365 4
      call get_lun ( lun, msg=.false. )
      if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & "No logical unit numbers available to read " // trim(fileName) )
      open ( unit=lun, file=filename, status='old', form='unformatted', &
d378 2
d381 1
a381 1
        & bytes(f_s) )
d383 2
d386 1
a386 1
        & bytes(iwc_s) )
d388 2
d391 1
a391 1
        & bytes(T_s) )
d393 2
d396 1
a396 1
        & bytes(theta_s) )
d401 4
d406 1
a406 1
        & (/ n_t,n_iwc,n_theta,n_f /), bytes(p) )
d409 4
d414 1
a414 1
          & (/ n_t,n_iwc,n_theta,n_f /), bytes(dP_dIWC) )
d416 4
d421 1
a421 1
          & (/ n_t,n_iwc,n_theta,n_f /), bytes(dP_dT) )
d485 1
a485 1
       "$Id: Read_Mie_m.f90,v 2.11 2013/06/12 02:21:57 vsnyder Exp $"
d495 3
@


2.11
log
@Use BYTE_SIZE from Allocate_Deallocate
@
text
@d59 1
a59 1
    use Allocate_Deallocate, only: Byte_Size, MEMORY_UNITS, Test_DeAllocate
d62 1
a62 1
    real :: S
d65 1
a65 1
      s = byte_size(log_beta_c_a) / MEMORY_UNITS
d70 1
a70 1
      s = byte_size(log_beta_c_e) / MEMORY_UNITS
d75 1
a75 1
      s = byte_size(log_beta_c_s) / MEMORY_UNITS
d85 1
a85 1
    use Allocate_Deallocate, only: Byte_Size, MEMORY_UNITS, Test_DeAllocate
d88 1
a88 1
    real :: S
d91 1
a91 1
      s = byte_size(f_s) / MEMORY_UNITS
d94 1
a94 1
      s = byte_size(iwc_s) / MEMORY_UNITS
d97 1
a97 1
      s = byte_size(t_s) / MEMORY_UNITS
d100 1
a100 1
      s = byte_size(theta_s) / MEMORY_UNITS
d103 1
a103 1
      s = byte_size(beta_c_a) / MEMORY_UNITS
d106 1
a106 1
      s = byte_size(beta_c_e) / MEMORY_UNITS
d109 1
a109 1
      s = byte_size(beta_c_s) / MEMORY_UNITS
d112 1
a112 1
      s = byte_size(P) / MEMORY_UNITS
d116 1
a116 1
        s = byte_size(dBeta_dIWC_c_a) / MEMORY_UNITS
d119 1
a119 1
        s = byte_size(dBeta_dT_c_a) / MEMORY_UNITS
d122 1
a122 1
        s = byte_size(dBeta_dIWC_c_e) / MEMORY_UNITS
d125 1
a125 1
        s = byte_size(dBeta_dT_c_e) / MEMORY_UNITS
d128 1
a128 1
        s = byte_size(dBeta_dIWC_c_s) / MEMORY_UNITS
d131 1
a131 1
        s = byte_size(dBeta_dT_c_s) / MEMORY_UNITS
d134 1
a134 1
        s = byte_size(dP_dIWC) / MEMORY_UNITS
d137 1
a137 1
        s = byte_size(dP_dT) / MEMORY_UNITS
d218 1
a218 1
    use Allocate_Deallocate, only: Test_Allocate
d230 1
a230 1
          & ubound(beta_c_e) )
d238 1
a238 1
          & ubound(beta_c_e) )
d246 1
a246 1
          & ubound(beta_c_s) )
d254 1
a254 1
    use Allocate_Deallocate, only: Test_Allocate
d324 2
a325 1
      call test_allocate ( status, moduleName, 'F_s', (/ 1 /), (/ n_f /) )
d327 2
a328 1
      call test_allocate ( status, moduleName, 'IWC_s', (/ 1 /), (/ n_iwc /) )
d330 2
a331 1
      call test_allocate ( status, moduleName, 'T_s', (/ 1 /), (/ n_T /) )
d333 2
a334 1
      call test_allocate ( status, moduleName, 'theta_s', (/ 1 /), (/ n_theta /) )
d340 1
a340 1
        & (/ n_t,n_iwc,n_theta,n_f /) )
d344 1
a344 1
          & (/ n_t,n_iwc,n_theta,n_f /) )
d347 1
a347 1
          & (/ n_t,n_iwc,n_theta,n_f /) )
d411 1
a411 1
       "$Id: Read_Mie_m.f90,v 2.10 2011/01/26 02:50:43 vsnyder Exp $"
d421 3
@


2.10
log
@Add more support for beta_c_a separately from beta_c_e
@
text
@d59 1
a59 1
    use Allocate_Deallocate, only: E_dp, MEMORY_UNITS, Test_DeAllocate
d65 1
a65 1
      s = (e_dp * size(log_beta_c_a) ) / MEMORY_UNITS
d70 1
a70 1
      s = (e_dp * size(log_beta_c_e) ) / MEMORY_UNITS
d75 1
a75 1
      s = (e_dp * size(log_beta_c_s) ) / MEMORY_UNITS
d85 1
a85 1
    use Allocate_Deallocate, only: E_dp, MEMORY_UNITS, Test_DeAllocate
d91 1
a91 1
      s = (e_dp * size(f_s) ) / MEMORY_UNITS
d94 1
a94 1
      s = (e_dp * size(iwc_s) ) / MEMORY_UNITS
d97 1
a97 1
      s = (e_dp * size(t_s) ) / MEMORY_UNITS
d100 1
a100 1
      s = (e_dp * size(theta_s) ) / MEMORY_UNITS
d103 1
a103 1
      s = (e_dp * size(beta_c_a) ) / MEMORY_UNITS
d106 1
a106 1
      s = (e_dp * size(beta_c_e) ) / MEMORY_UNITS
d109 1
a109 1
      s = (e_dp * size(beta_c_s) ) / MEMORY_UNITS
d112 1
a112 1
      s = (e_dp * size(P) ) / MEMORY_UNITS
d116 1
a116 1
        s = (e_dp * size(dBeta_dIWC_c_a) ) / MEMORY_UNITS
d119 1
a119 1
        s = (e_dp * size(dBeta_dT_c_a) ) / MEMORY_UNITS
d122 1
a122 1
        s = (e_dp * size(dBeta_dIWC_c_e) ) / MEMORY_UNITS
d125 1
a125 1
        s = (e_dp * size(dBeta_dT_c_e) ) / MEMORY_UNITS
d128 1
a128 1
        s = (e_dp * size(dBeta_dIWC_c_s) ) / MEMORY_UNITS
d131 1
a131 1
        s = (e_dp * size(dBeta_dT_c_s) ) / MEMORY_UNITS
d134 1
a134 1
        s = (e_dp * size(dP_dIWC) ) / MEMORY_UNITS
d137 1
a137 1
        s = (e_dp * size(dP_dT) ) / MEMORY_UNITS
d407 1
a407 1
       "$Id: Read_Mie_m.f90,v 2.9 2010/06/07 23:13:02 vsnyder Exp $"
d417 3
@


2.9
log
@Added ability to compute and store Log_Beta_c_e and Log_Beta_c_s
@
text
@d31 1
d64 5
d169 4
d215 2
a216 3
  ! If any of Log_Beta_c_a, Log_Beta_c_e, Log_dBeta_dIWC_c_a, Log_dBeta_dT_c_a
  ! are not associated, allocate them and compute them.  Read_Mie has to
  ! be called first.
d225 8
d407 1
a407 1
       "$Id: Read_Mie_m.f90,v 2.8 2010/01/14 02:24:06 vsnyder Exp $"
d417 3
@


2.8
log
@Add some comments
@
text
@d20 1
a20 1
  public :: Destroy_Mie, Dump_Mie, Read_Mie
d28 5
a32 3
  real(r8), public, pointer :: Beta_c_a(:,:,:) => NULL()  ! T X IWC X F
  real(r8), public, pointer :: Beta_c_e(:,:,:) => NULL()  ! T X IWC X F
  real(r8), public, pointer :: Beta_c_s(:,:,:) => NULL()  ! T X IWC X F
d34 6
a39 6
  real(r8), public, pointer :: dBeta_dIWC_c_a(:,:,:) => NULL() ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_a(:,:,:) => NULL()   ! T X IWC X F
  real(r8), public, pointer :: dBeta_dIWC_c_e(:,:,:) => NULL() ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_e(:,:,:) => NULL()   ! T X IWC X F
  real(r8), public, pointer :: dBeta_dIWC_c_s(:,:,:) => NULL() ! T X IWC X F
  real(r8), public, pointer :: dBeta_dT_c_s(:,:,:) => NULL()   ! T X IWC X F
d54 21
d137 2
d163 4
d169 4
d203 31
d390 1
a390 1
       "$Id: Read_Mie_m.f90,v 2.7 2009/08/20 19:47:26 vsnyder Exp $"
d400 3
@


2.7
log
@Replace THETA_s by Theta_s to conform to Mie_Tables
@
text
@d23 4
a26 2
  real(rp), public, pointer :: F_s(:) => NULL(), IWC_s(:) => NULL()
  real(rp), public, pointer :: T_s(:) => NULL(), Theta_s(:) => NULL()
d326 1
a326 1
       "$Id: Read_Mie_m.f90,v 2.6 2009/06/23 18:26:10 pwagner Exp $"
d336 3
@


2.6
log
@Prevent Intel from optimizing ident string away
@
text
@d198 1
a198 1
      call loadPtrFromHDF5DS ( fileID, 'THETA_s', theta_s )
d324 1
a324 1
       "$Id: read_apriori.f90 is it here $"
d334 3
@


2.5
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d321 1
a322 1
!---------------------------- RCS Ident Info -------------------------------
d324 1
a324 1
       "$Id: Read_Mie_m.f90,v 2.4 2008/10/20 23:23:20 vsnyder Exp $"
a325 1
!---------------------------------------------------------------------------
d327 1
d329 1
d334 3
@


2.4
log
@Convert F_s from GHz to MHz, since MHz is the standard unit
@
text
@d122 1
a122 1
    use Units, only: Rad2Deg
d324 1
a324 1
       "$Id: Read_Mie_m.f90,v 2.3 2008/07/31 18:00:13 vsnyder Exp $"
d333 3
@


2.3
log
@Change coordinates from R8 to RP
@
text
@d126 1
a126 1
    call dump ( f_s, name='F_s (GHz)' )
d200 1
d324 1
a324 1
       "$Id: Read_Mie_m.f90,v 2.2 2008/06/05 02:15:26 vsnyder Exp $"
d333 3
@


2.2
log
@Added HDF, spiffed up dump
@
text
@d16 1
a16 1
  use MLSKinds, only: R8
d23 2
a24 2
  real(r8), public, pointer :: F_s(:) => NULL(), IWC_s(:) => NULL()
  real(r8), public, pointer :: T_s(:) => NULL(), Theta_s(:) => NULL()
d323 1
a323 1
       "$Id: Read_Mie_m.f90,v 2.1 2008/05/20 00:26:40 vsnyder Exp $"
d332 3
@


2.1
log
@Initial commit
@
text
@d20 1
a20 1
  public :: Destroy_Mie, Read_Mie
d23 13
a35 1
  real(r8), public, allocatable :: F_s(:), IWC_s(:), T_s(:), Theta_s(:)
d37 4
a40 4
  real(r8), public, allocatable :: P(:,:,:,:)       ! T X IWC X Theta X F
  ! Derivatives
  real(r8), public, allocatable :: dP_dIWC(:,:,:,:) ! T X IWC X Theta X F
  real(r8), public, allocatable :: dP_dT(:,:,:,:)   ! T X IWC X Theta X F
d44 1
a44 1
       "$RCSfile: tree_walker.f90,v $"
d50 1
d59 1
a59 1
    if ( allocated(f_s) ) then
d72 9
d84 19
a102 1
      if ( allocated(dP_dIWC) ) then
d114 55
d174 2
d177 1
d181 1
a181 1
    integer :: Lun, Status
d190 44
a233 11
    ! Open the file
    call get_lun ( lun, msg=.false. )
    if ( lun < 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & "No logical unit numbers available" )
    open ( unit=lun, file=filename, status='old', form='unformatted', &
      & access='sequential', iostat=status )
    if ( status /= 0 ) then
      call io_error ( "Unable to open Mie tables file ", status, filename )
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Unable to open Mie tables file " // Filename )
    end if
d235 2
a236 2
    ! Read some sizes and scalars
    read ( lun ) n_f, n_IWC, n_T, n_theta, r_min, r_max, n_cut, derivs
d238 14
a251 18
    ! Allocate and read the coordinate arrays
    allocate ( f_s(n_f), stat=status )
    call test_allocate ( status, moduleName, 'F_s', (/ 1 /), (/ n_f /) )
    allocate ( iwc_s(n_iwc), stat=status )
    call test_allocate ( status, moduleName, 'IWC_s', (/ 1 /), (/ n_iwc /) )
    allocate ( T_s(n_T), stat=status )
    call test_allocate ( status, moduleName, 'T_s', (/ 1 /), (/ n_T /) )
    allocate ( theta_s(n_theta), stat=status )
    call test_allocate ( status, moduleName, 'theta_s', (/ 1 /), (/ n_theta /) )
    read ( lun ) iwc_s, t_s, theta_s, f_s

    ! Allocate the phase array and its derivatives
    allocate ( p(n_t, n_iwc, n_theta, n_f), stat=status )
    call test_allocate ( status, moduleName, 'P', (/ 1,1,1,1 /), &
      & (/ n_t,n_iwc,n_theta,n_f /) )
    if ( derivs ) then
      allocate ( dP_dIWC(n_t, n_iwc, n_theta, n_f), stat=status )
      call test_allocate ( status, moduleName, 'dP_dIWC', (/ 1,1,1,1 /), &
d253 8
a260 4
      allocate ( dP_dT(n_t, n_iwc, n_theta, n_f), stat=status )
      call test_allocate ( status, moduleName, 'dP_dT', (/ 1,1,1,1 /), &
        & (/ n_t,n_iwc,n_theta,n_f /) )
    end if
d262 3
a264 3
    ! Read everything
    call Read_Mie_Auto
    if ( derivs ) call Read_Mie_Derivs_Auto
d266 2
a267 1
    close ( lun )
d323 1
a323 1
       "$Id: tree_walker.f90,v 2.163 2008/04/01 17:00:15 pwagner Exp $"
d331 4
a334 1
! $Log: $
@

