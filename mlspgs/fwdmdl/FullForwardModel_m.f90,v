head	2.411;
access;
symbols
	v5-02-NRT-19:2.411
	v6-00:2.411
	v5-02-NRT-18:2.411
	v5-02:2.404
	v5-01-NRT-17:2.409
	v5-01-NRT-16:2.409
	v5-01-NRT-15:2.409
	v5-01-NRT-14:2.409
	neuralnetworks-1-0:2.409.0.2
	cfm-single-freq-0-1:2.408.0.2
	v5-01:2.404
	v5-00:2.404
	v4-23-TA133:2.402.0.2
	mus-emls-1-70:2.395.0.2
	rel-1-0-englocks-work:2.390.0.2
	VUMLS1-00:2.380
	VPL1-00:2.367
	V4-22-NRT-08:2.366
	VAM1-00:2.358
	V4-21:2.352.0.2
	V4-13:2.352
	V4-12:2.350
	V4-11:2.349
	V4-10:2.349
	V3-43:2.301
	M4-00:2.339
	V3-41:2.301
	V3-40-PlusGM57:2.301.0.2
	V2-24-NRT-04:2.285
	V3-33:2.314
	V2-24:2.285
	V3-31:2.314
	V3-30-NRT-05:2.308
	cfm-01-00:2.305
	V3-30:2.301
	V3-20:2.301
	V3-10:2.295
	V2-23-NRT-02:2.285
	V2-23:2.285
	V2-22-NRT-01:2.285
	V2-22:2.285
	V2-21:2.267
	V2-20:2.267
	V2-11:2.265
	V2-10:2.265
	V2-00:2.260
	V1-51:2.230
	V1-50:2.230
	V1-45:2.220
	V1-44:2.220
	V1-43:2.210
	V1-32:2.191
	V1-31:2.191
	V1-30:2.170
	V1-13:2.130
	V1-12:2.130
	V1-11:2.130
	V1-10:2.124
	newfwm-feb03:2.126.0.2
	V1-04:2.38
	V1-03:2.38
	V1-02:2.38
	JointForwardModel:2.66.0.2
	V1-00:2.38
	newfwm-sep01:1.5.0.2
	V0-7:1.5;
locks; strict;
comment	@# @;


2.411
date	2023.07.06.18.34.10;	author pwagner;	state Exp;
branches;
next	2.410;

2.410
date	2023.06.23.20.45.07;	author pwagner;	state Exp;
branches;
next	2.409;

2.409
date	2020.08.28.21.41.58;	author vsnyder;	state Exp;
branches;
next	2.408;

2.408
date	2020.05.05.23.57.56;	author vsnyder;	state Exp;
branches;
next	2.407;

2.407
date	2020.04.22.01.59.27;	author vsnyder;	state Exp;
branches;
next	2.406;

2.406
date	2020.02.07.01.11.08;	author pwagner;	state Exp;
branches;
next	2.405;

2.405
date	2019.10.07.20.05.53;	author vsnyder;	state Exp;
branches;
next	2.404;

2.404
date	2019.09.05.17.10.33;	author pwagner;	state Exp;
branches;
next	2.403;

2.403
date	2019.06.24.23.28.16;	author pwagner;	state Exp;
branches;
next	2.402;

2.402
date	2018.10.30.23.14.36;	author vsnyder;	state Exp;
branches;
next	2.401;

2.401
date	2018.10.26.22.05.47;	author vsnyder;	state Exp;
branches;
next	2.400;

2.400
date	2018.09.12.22.51.16;	author vsnyder;	state Exp;
branches;
next	2.399;

2.399
date	2018.09.12.22.07.42;	author vsnyder;	state Exp;
branches;
next	2.398;

2.398
date	2018.09.05.20.56.10;	author vsnyder;	state Exp;
branches;
next	2.397;

2.397
date	2018.08.28.22.17.53;	author vsnyder;	state Exp;
branches;
next	2.396;

2.396
date	2018.08.15.01.18.50;	author vsnyder;	state Exp;
branches;
next	2.395;

2.395
date	2018.05.24.03.24.36;	author vsnyder;	state Exp;
branches;
next	2.394;

2.394
date	2018.05.17.02.15.45;	author vsnyder;	state Exp;
branches;
next	2.393;

2.393
date	2018.05.15.03.26.25;	author vsnyder;	state Exp;
branches;
next	2.392;

2.392
date	2018.05.14.23.40.58;	author vsnyder;	state Exp;
branches;
next	2.391;

2.391
date	2018.04.23.20.40.45;	author livesey;	state Exp;
branches;
next	2.390;

2.390
date	2017.11.01.00.11.32;	author vsnyder;	state Exp;
branches;
next	2.389;

2.389
date	2017.11.01.00.09.32;	author vsnyder;	state Exp;
branches;
next	2.388;

2.388
date	2017.10.31.23.49.35;	author vsnyder;	state Exp;
branches;
next	2.387;

2.387
date	2017.10.31.17.36.46;	author vsnyder;	state Exp;
branches;
next	2.386;

2.386
date	2017.09.20.01.18.49;	author vsnyder;	state Exp;
branches;
next	2.385;

2.385
date	2017.08.10.00.15.53;	author vsnyder;	state Exp;
branches;
next	2.384;

2.384
date	2017.03.31.00.49.43;	author vsnyder;	state Exp;
branches;
next	2.383;

2.383
date	2017.03.24.00.10.43;	author vsnyder;	state Exp;
branches;
next	2.382;

2.382
date	2017.03.20.23.25.40;	author vsnyder;	state Exp;
branches;
next	2.381;

2.381
date	2017.03.11.00.58.13;	author vsnyder;	state Exp;
branches;
next	2.380;

2.380
date	2017.01.14.02.58.48;	author vsnyder;	state Exp;
branches;
next	2.379;

2.379
date	2016.12.02.02.04.50;	author vsnyder;	state Exp;
branches;
next	2.378;

2.378
date	2016.11.23.21.35.13;	author vsnyder;	state Exp;
branches;
next	2.377;

2.377
date	2016.11.23.00.14.36;	author vsnyder;	state Exp;
branches;
next	2.376;

2.376
date	2016.11.17.01.45.26;	author vsnyder;	state Exp;
branches;
next	2.375;

2.375
date	2016.11.14.21.10.47;	author vsnyder;	state Exp;
branches;
next	2.374;

2.374
date	2016.11.14.19.17.12;	author vsnyder;	state Exp;
branches;
next	2.373;

2.373
date	2016.11.12.01.42.32;	author vsnyder;	state Exp;
branches;
next	2.372;

2.372
date	2016.11.11.02.06.27;	author vsnyder;	state Exp;
branches;
next	2.371;

2.371
date	2016.11.09.00.38.10;	author vsnyder;	state Exp;
branches;
next	2.370;

2.370
date	2016.11.03.19.11.47;	author vsnyder;	state Exp;
branches;
next	2.369;

2.369
date	2016.10.25.22.27.39;	author vsnyder;	state Exp;
branches;
next	2.368;

2.368
date	2016.10.24.22.20.32;	author vsnyder;	state Exp;
branches;
next	2.367;

2.367
date	2016.06.03.23.47.23;	author vsnyder;	state Exp;
branches;
next	2.366;

2.366
date	2016.05.02.23.32.52;	author vsnyder;	state Exp;
branches;
next	2.365;

2.365
date	2016.04.21.02.00.12;	author vsnyder;	state Exp;
branches;
next	2.364;

2.364
date	2016.03.25.02.02.37;	author vsnyder;	state Exp;
branches;
next	2.363;

2.363
date	2016.02.25.00.57.58;	author vsnyder;	state Exp;
branches;
next	2.362;

2.362
date	2016.01.23.02.55.24;	author vsnyder;	state Exp;
branches;
next	2.361;

2.361
date	2015.12.08.23.23.42;	author vsnyder;	state Exp;
branches;
next	2.360;

2.360
date	2015.12.08.19.13.08;	author vsnyder;	state Exp;
branches;
next	2.359;

2.359
date	2015.10.28.00.34.13;	author vsnyder;	state Exp;
branches;
next	2.358;

2.358
date	2015.09.22.23.37.26;	author vsnyder;	state Exp;
branches;
next	2.357;

2.357
date	2015.08.25.17.23.05;	author vsnyder;	state Exp;
branches;
next	2.356;

2.356
date	2015.05.28.23.22.44;	author vsnyder;	state Exp;
branches;
next	2.355;

2.355
date	2015.05.01.02.08.36;	author vsnyder;	state Exp;
branches;
next	2.354;

2.354
date	2015.04.11.01.26.03;	author vsnyder;	state Exp;
branches;
next	2.353;

2.353
date	2015.03.28.02.16.24;	author vsnyder;	state Exp;
branches;
next	2.352;

2.352
date	2014.09.05.20.49.32;	author vsnyder;	state Exp;
branches;
next	2.351;

2.351
date	2014.08.01.01.06.05;	author vsnyder;	state Exp;
branches;
next	2.350;

2.350
date	2014.07.18.23.15.44;	author pwagner;	state Exp;
branches;
next	2.349;

2.349
date	2014.01.11.01.28.53;	author vsnyder;	state Exp;
branches;
next	2.348;

2.348
date	2013.08.31.02.30.03;	author vsnyder;	state Exp;
branches;
next	2.347;

2.347
date	2013.08.30.03.56.23;	author vsnyder;	state Exp;
branches;
next	2.346;

2.346
date	2013.08.17.02.56.19;	author vsnyder;	state Exp;
branches;
next	2.345;

2.345
date	2013.08.08.02.35.25;	author vsnyder;	state Exp;
branches;
next	2.344;

2.344
date	2013.08.02.01.24.06;	author vsnyder;	state Exp;
branches;
next	2.343;

2.343
date	2013.07.13.00.06.20;	author vsnyder;	state Exp;
branches;
next	2.342;

2.342
date	2013.06.12.02.35.22;	author vsnyder;	state Exp;
branches;
next	2.341;

2.341
date	2013.05.22.00.19.10;	author vsnyder;	state Exp;
branches;
next	2.340;

2.340
date	2013.05.18.00.34.43;	author vsnyder;	state Exp;
branches;
next	2.339;

2.339
date	2013.04.09.18.23.56;	author pwagner;	state Exp;
branches;
next	2.338;

2.338
date	2013.02.04.22.06.27;	author pwagner;	state Exp;
branches;
next	2.337;

2.337
date	2013.01.23.21.24.26;	author vsnyder;	state Exp;
branches;
next	2.336;

2.336
date	2012.08.08.20.06.37;	author vsnyder;	state Exp;
branches;
next	2.335;

2.335
date	2012.07.07.00.14.33;	author vsnyder;	state Exp;
branches;
next	2.334;

2.334
date	2012.07.06.21.30.41;	author yanovsky;	state Exp;
branches;
next	2.333;

2.333
date	2012.06.15.23.33.13;	author vsnyder;	state Exp;
branches;
next	2.332;

2.332
date	2012.02.13.23.20.12;	author pwagner;	state Exp;
branches;
next	2.331;

2.331
date	2012.02.10.23.51.33;	author vsnyder;	state Exp;
branches;
next	2.330;

2.330
date	2011.11.10.23.23.32;	author vsnyder;	state Exp;
branches;
next	2.329;

2.329
date	2011.11.09.00.29.48;	author vsnyder;	state Exp;
branches;
next	2.328;

2.328
date	2011.08.26.17.53.33;	author pwagner;	state Exp;
branches;
next	2.327;

2.327
date	2011.08.12.18.59.57;	author vsnyder;	state Exp;
branches;
next	2.326;

2.326
date	2011.07.29.01.55.18;	author vsnyder;	state Exp;
branches;
next	2.325;

2.325
date	2011.07.21.20.48.38;	author honghanh;	state Exp;
branches;
next	2.324;

2.324
date	2011.07.08.18.19.35;	author yanovsky;	state Exp;
branches;
next	2.323;

2.323
date	2011.06.24.23.15.53;	author pwagner;	state Exp;
branches;
next	2.322;

2.322
date	2011.06.02.22.31.48;	author yanovsky;	state Exp;
branches;
next	2.321;

2.321
date	2011.05.09.17.46.38;	author pwagner;	state Exp;
branches;
next	2.320;

2.320
date	2011.03.31.19.51.03;	author vsnyder;	state Exp;
branches;
next	2.319;

2.319
date	2011.03.25.20.46.59;	author vsnyder;	state Exp;
branches;
next	2.318;

2.318
date	2011.03.23.23.50.42;	author vsnyder;	state Exp;
branches;
next	2.317;

2.317
date	2011.03.23.23.45.32;	author vsnyder;	state Exp;
branches;
next	2.316;

2.316
date	2011.03.11.03.09.08;	author vsnyder;	state Exp;
branches;
next	2.315;

2.315
date	2011.03.04.03.44.40;	author vsnyder;	state Exp;
branches;
next	2.314;

2.314
date	2011.02.12.03.57.40;	author vsnyder;	state Exp;
branches;
next	2.313;

2.313
date	2011.01.29.00.52.32;	author vsnyder;	state Exp;
branches;
next	2.312;

2.312
date	2011.01.28.19.18.44;	author vsnyder;	state Exp;
branches;
next	2.311;

2.311
date	2010.11.05.23.03.18;	author pwagner;	state Exp;
branches;
next	2.310;

2.310
date	2010.11.03.18.43.51;	author vsnyder;	state Exp;
branches;
next	2.309;

2.309
date	2010.09.25.01.08.39;	author vsnyder;	state Exp;
branches;
next	2.308;

2.308
date	2010.08.28.00.03.12;	author vsnyder;	state Exp;
branches;
next	2.307;

2.307
date	2010.08.27.06.02.39;	author yanovsky;	state Exp;
branches;
next	2.306;

2.306
date	2010.08.19.02.14.03;	author vsnyder;	state Exp;
branches;
next	2.305;

2.305
date	2010.06.12.01.30.54;	author vsnyder;	state Exp;
branches;
next	2.304;

2.304
date	2010.06.07.23.23.53;	author vsnyder;	state Exp;
branches;
next	2.303;

2.303
date	2010.05.18.18.13.35;	author honghanh;	state Exp;
branches;
next	2.302;

2.302
date	2010.03.24.20.50.02;	author vsnyder;	state Exp;
branches;
next	2.301;

2.301
date	2010.02.05.03.29.19;	author vsnyder;	state Exp;
branches;
next	2.300;

2.300
date	2010.02.02.01.39.06;	author vsnyder;	state Exp;
branches;
next	2.299;

2.299
date	2010.01.23.01.30.49;	author vsnyder;	state Exp;
branches;
next	2.298;

2.298
date	2009.12.15.03.30.04;	author vsnyder;	state Exp;
branches;
next	2.297;

2.297
date	2009.11.17.23.45.32;	author vsnyder;	state Exp;
branches;
next	2.296;

2.296
date	2009.09.25.02.45.06;	author vsnyder;	state Exp;
branches;
next	2.295;

2.295
date	2009.06.23.18.26.10;	author pwagner;	state Exp;
branches;
next	2.294;

2.294
date	2009.06.16.17.38.17;	author pwagner;	state Exp;
branches;
next	2.293;

2.293
date	2009.06.13.01.15.03;	author vsnyder;	state Exp;
branches;
next	2.292;

2.292
date	2009.05.14.00.46.02;	author pwagner;	state Exp;
branches;
next	2.291;

2.291
date	2009.01.21.01.00.39;	author pwagner;	state Exp;
branches;
next	2.290;

2.290
date	2008.10.03.16.27.14;	author livesey;	state Exp;
branches;
next	2.289;

2.289
date	2008.06.26.00.28.03;	author vsnyder;	state Exp;
branches;
next	2.288;

2.288
date	2008.05.20.00.23.21;	author vsnyder;	state Exp;
branches;
next	2.287;

2.287
date	2008.02.29.01.59.39;	author vsnyder;	state Exp;
branches;
next	2.286;

2.286
date	2007.11.08.02.02.19;	author vsnyder;	state Exp;
branches;
next	2.285;

2.285
date	2007.07.31.23.49.21;	author vsnyder;	state Exp;
branches;
next	2.284;

2.284
date	2007.07.11.22.26.32;	author vsnyder;	state Exp;
branches;
next	2.283;

2.283
date	2007.06.29.19.33.59;	author vsnyder;	state Exp;
branches;
next	2.282;

2.282
date	2007.06.26.01.05.02;	author vsnyder;	state Exp;
branches;
next	2.281;

2.281
date	2007.06.08.22.05.33;	author vsnyder;	state Exp;
branches;
next	2.280;

2.280
date	2007.02.01.02.53.47;	author vsnyder;	state Exp;
branches;
next	2.279;

2.279
date	2007.01.20.01.08.08;	author vsnyder;	state Exp;
branches;
next	2.278;

2.278
date	2007.01.19.02.38.53;	author vsnyder;	state Exp;
branches;
next	2.277;

2.277
date	2007.01.18.00.27.10;	author vsnyder;	state Exp;
branches;
next	2.276;

2.276
date	2006.12.21.22.59.00;	author vsnyder;	state Exp;
branches;
next	2.275;

2.275
date	2006.12.21.01.34.53;	author vsnyder;	state Exp;
branches;
next	2.274;

2.274
date	2006.12.20.21.22.16;	author vsnyder;	state Exp;
branches;
next	2.273;

2.273
date	2006.12.19.02.53.15;	author vsnyder;	state Exp;
branches;
next	2.272;

2.272
date	2006.12.13.02.32.02;	author vsnyder;	state Exp;
branches;
next	2.271;

2.271
date	2006.12.08.23.57.08;	author vsnyder;	state Exp;
branches;
next	2.270;

2.270
date	2006.12.04.21.17.28;	author vsnyder;	state Exp;
branches;
next	2.269;

2.269
date	2006.11.30.01.29.28;	author vsnyder;	state Exp;
branches;
next	2.268;

2.268
date	2006.11.29.01.09.40;	author vsnyder;	state Exp;
branches;
next	2.267;

2.267
date	2006.08.25.19.42.31;	author vsnyder;	state Exp;
branches;
next	2.266;

2.266
date	2006.08.25.19.37.07;	author vsnyder;	state Exp;
branches;
next	2.265;

2.265
date	2006.07.06.23.16.19;	author vsnyder;	state Exp;
branches;
next	2.264;

2.264
date	2006.06.29.19.34.43;	author vsnyder;	state Exp;
branches;
next	2.263;

2.263
date	2006.06.19.19.26.56;	author vsnyder;	state Exp;
branches;
next	2.262;

2.262
date	2006.06.16.20.32.30;	author vsnyder;	state Exp;
branches;
next	2.261;

2.261
date	2006.06.16.00.49.10;	author vsnyder;	state Exp;
branches;
next	2.260;

2.260
date	2006.04.25.23.25.36;	author vsnyder;	state Exp;
branches;
next	2.259;

2.259
date	2006.04.21.22.25.20;	author vsnyder;	state Exp;
branches;
next	2.258;

2.258
date	2006.04.11.18.34.37;	author vsnyder;	state Exp;
branches;
next	2.257;

2.257
date	2006.03.06.20.44.06;	author vsnyder;	state Exp;
branches;
next	2.256;

2.256
date	2006.02.08.21.38.18;	author vsnyder;	state Exp;
branches;
next	2.255;

2.255
date	2006.02.08.01.02.01;	author vsnyder;	state Exp;
branches;
next	2.254;

2.254
date	2006.01.05.00.03.52;	author vsnyder;	state Exp;
branches;
next	2.253;

2.253
date	2005.12.10.01.51.54;	author vsnyder;	state Exp;
branches;
next	2.252;

2.252
date	2005.12.07.19.43.32;	author vsnyder;	state Exp;
branches;
next	2.251;

2.251
date	2005.12.07.01.30.04;	author vsnyder;	state Exp;
branches;
next	2.250;

2.250
date	2005.12.07.00.35.04;	author vsnyder;	state Exp;
branches;
next	2.249;

2.249
date	2005.11.21.22.57.41;	author vsnyder;	state Exp;
branches;
next	2.248;

2.248
date	2005.11.05.03.38.13;	author vsnyder;	state Exp;
branches;
next	2.247;

2.247
date	2005.11.03.03.57.45;	author vsnyder;	state Exp;
branches;
next	2.246;

2.246
date	2005.11.02.21.38.48;	author vsnyder;	state Exp;
branches;
next	2.245;

2.245
date	2005.11.01.23.02.08;	author vsnyder;	state Exp;
branches;
next	2.244;

2.244
date	2005.09.17.01.02.38;	author vsnyder;	state Exp;
branches;
next	2.243;

2.243
date	2005.09.17.00.49.53;	author vsnyder;	state Exp;
branches;
next	2.242;

2.242
date	2005.09.03.01.21.33;	author vsnyder;	state Exp;
branches;
next	2.241;

2.241
date	2005.08.03.18.03.42;	author vsnyder;	state Exp;
branches;
next	2.240;

2.240
date	2005.07.08.19.40.51;	author vsnyder;	state Exp;
branches;
next	2.239;

2.239
date	2005.07.08.00.12.11;	author vsnyder;	state Exp;
branches;
next	2.238;

2.238
date	2005.07.06.02.17.20;	author vsnyder;	state Exp;
branches;
next	2.237;

2.237
date	2005.06.09.02.34.16;	author vsnyder;	state Exp;
branches;
next	2.236;

2.236
date	2005.06.03.01.59.25;	author vsnyder;	state Exp;
branches;
next	2.235;

2.235
date	2005.04.19.20.16.45;	author livesey;	state Exp;
branches;
next	2.234;

2.234
date	2005.03.28.20.26.25;	author vsnyder;	state Exp;
branches;
next	2.233;

2.233
date	2005.03.10.00.28.09;	author pwagner;	state Exp;
branches;
next	2.232;

2.232
date	2005.02.17.02.35.29;	author vsnyder;	state Exp;
branches;
next	2.231;

2.231
date	2005.02.16.23.16.49;	author vsnyder;	state Exp;
branches;
next	2.230;

2.230
date	2004.12.28.00.28.02;	author vsnyder;	state Exp;
branches;
next	2.229;

2.229
date	2004.12.13.20.37.23;	author vsnyder;	state Exp;
branches;
next	2.228;

2.228
date	2004.11.05.19.38.39;	author vsnyder;	state Exp;
branches;
next	2.227;

2.227
date	2004.11.01.20.26.35;	author vsnyder;	state Exp;
branches;
next	2.226;

2.226
date	2004.10.13.01.08.27;	author vsnyder;	state Exp;
branches;
next	2.225;

2.225
date	2004.10.07.23.26.09;	author vsnyder;	state Exp;
branches;
next	2.224;

2.224
date	2004.10.06.21.27.41;	author vsnyder;	state Exp;
branches;
next	2.223;

2.223
date	2004.09.14.17.20.45;	author bill;	state Exp;
branches;
next	2.222;

2.222
date	2004.09.04.01.50.30;	author vsnyder;	state Exp;
branches;
next	2.221;

2.221
date	2004.09.01.01.48.27;	author vsnyder;	state Exp;
branches;
next	2.220;

2.220
date	2004.08.06.22.40.17;	author livesey;	state Exp;
branches;
next	2.219;

2.219
date	2004.08.06.01.40.39;	author livesey;	state Exp;
branches;
next	2.218;

2.218
date	2004.08.06.01.24.55;	author livesey;	state Exp;
branches;
next	2.217;

2.217
date	2004.08.06.01.24.22;	author livesey;	state Exp;
branches;
next	2.216;

2.216
date	2004.08.05.20.53.50;	author vsnyder;	state Exp;
branches;
next	2.215;

2.215
date	2004.08.05.20.24.00;	author livesey;	state Exp;
branches;
next	2.214;

2.214
date	2004.08.03.22.07.10;	author vsnyder;	state Exp;
branches;
next	2.213;

2.213
date	2004.07.30.19.53.18;	author livesey;	state Exp;
branches;
next	2.212;

2.212
date	2004.07.08.21.00.23;	author vsnyder;	state Exp;
branches;
next	2.211;

2.211
date	2004.06.10.00.59.56;	author vsnyder;	state Exp;
branches;
next	2.210;

2.210
date	2004.05.27.23.23.50;	author pwagner;	state Exp;
branches;
next	2.209;

2.209
date	2004.05.17.22.05.11;	author livesey;	state Exp;
branches;
next	2.208;

2.208
date	2004.04.24.02.27.05;	author vsnyder;	state Exp;
branches;
next	2.207;

2.207
date	2004.04.19.21.01.37;	author vsnyder;	state Exp;
branches;
next	2.206;

2.206
date	2004.04.17.00.37.00;	author vsnyder;	state Exp;
branches;
next	2.205;

2.205
date	2004.04.05.21.08.42;	author jonathan;	state Exp;
branches;
next	2.204;

2.204
date	2004.04.02.00.59.24;	author vsnyder;	state Exp;
branches;
next	2.203;

2.203
date	2004.03.31.20.35.26;	author jonathan;	state Exp;
branches;
next	2.202;

2.202
date	2004.03.30.02.26.17;	author livesey;	state Exp;
branches;
next	2.201;

2.201
date	2004.03.30.02.00.36;	author vsnyder;	state Exp;
branches;
next	2.200;

2.200
date	2004.03.27.03.35.27;	author vsnyder;	state Exp;
branches;
next	2.199;

2.199
date	2004.03.20.04.05.50;	author vsnyder;	state Exp;
branches;
next	2.198;

2.198
date	2004.03.20.01.15.16;	author jonathan;	state Exp;
branches;
next	2.197;

2.197
date	2004.03.08.22.58.03;	author vsnyder;	state Exp;
branches;
next	2.196;

2.196
date	2004.03.01.19.22.14;	author jonathan;	state Exp;
branches;
next	2.195;

2.195
date	2004.02.14.00.23.48;	author vsnyder;	state Exp;
branches;
next	2.194;

2.194
date	2004.02.05.23.30.01;	author livesey;	state Exp;
branches;
next	2.193;

2.193
date	2004.02.03.02.48.35;	author vsnyder;	state Exp;
branches;
next	2.192;

2.192
date	2004.01.23.19.13.42;	author jonathan;	state Exp;
branches;
next	2.191;

2.191
date	2003.12.08.21.38.33;	author jonathan;	state Exp;
branches;
next	2.190;

2.190
date	2003.12.08.17.52.02;	author jonathan;	state Exp;
branches;
next	2.189;

2.189
date	2003.12.07.19.45.46;	author jonathan;	state Exp;
branches;
next	2.188;

2.188
date	2003.12.01.17.24.05;	author jonathan;	state Exp;
branches;
next	2.187;

2.187
date	2003.11.24.22.10.14;	author vsnyder;	state Exp;
branches;
next	2.186;

2.186
date	2003.11.20.17.33.50;	author pwagner;	state Exp;
branches;
next	2.185;

2.185
date	2003.11.19.22.21.34;	author jonathan;	state Exp;
branches;
next	2.184;

2.184
date	2003.11.17.18.04.15;	author jonathan;	state Exp;
branches;
next	2.183;

2.183
date	2003.11.12.00.10.55;	author jonathan;	state Exp;
branches;
next	2.182;

2.182
date	2003.11.07.03.18.49;	author vsnyder;	state Exp;
branches;
next	2.181;

2.181
date	2003.11.06.01.13.14;	author bill;	state Exp;
branches;
next	2.180;

2.180
date	2003.11.05.19.26.01;	author jonathan;	state Exp;
branches;
next	2.179;

2.179
date	2003.11.04.02.49.13;	author vsnyder;	state Exp;
branches;
next	2.178;

2.178
date	2003.11.04.01.57.15;	author vsnyder;	state Exp;
branches;
next	2.177;

2.177
date	2003.11.03.23.15.16;	author vsnyder;	state Exp;
branches;
next	2.176;

2.176
date	2003.11.01.03.02.57;	author vsnyder;	state Exp;
branches;
next	2.175;

2.175
date	2003.10.30.20.37.00;	author vsnyder;	state Exp;
branches;
next	2.174;

2.174
date	2003.10.29.00.43.51;	author livesey;	state Exp;
branches;
next	2.173;

2.173
date	2003.10.28.22.05.53;	author jonathan;	state Exp;
branches;
next	2.172;

2.172
date	2003.10.09.19.30.18;	author vsnyder;	state Exp;
branches;
next	2.171;

2.171
date	2003.09.24.02.53.48;	author vsnyder;	state Exp;
branches;
next	2.170;

2.170
date	2003.09.09.00.04.27;	author vsnyder;	state Exp;
branches;
next	2.169;

2.169
date	2003.08.16.01.14.58;	author vsnyder;	state Exp;
branches;
next	2.168;

2.168
date	2003.08.15.20.29.26;	author vsnyder;	state Exp;
branches;
next	2.167;

2.167
date	2003.08.15.18.50.21;	author vsnyder;	state Exp;
branches;
next	2.166;

2.166
date	2003.08.12.23.07.32;	author vsnyder;	state Exp;
branches;
next	2.165;

2.165
date	2003.08.12.21.58.37;	author vsnyder;	state Exp;
branches;
next	2.164;

2.164
date	2003.08.12.18.22.10;	author michael;	state Exp;
branches;
next	2.163;

2.163
date	2003.07.15.23.07.21;	author vsnyder;	state Exp;
branches;
next	2.162;

2.162
date	2003.07.15.22.10.09;	author livesey;	state Exp;
branches;
next	2.161;

2.161
date	2003.07.15.18.16.48;	author livesey;	state Exp;
branches;
next	2.160;

2.160
date	2003.07.09.23.40.13;	author vsnyder;	state Exp;
branches;
next	2.159;

2.159
date	2003.07.09.22.27.42;	author vsnyder;	state Exp;
branches;
next	2.158;

2.158
date	2003.07.09.20.23.50;	author vsnyder;	state Exp;
branches;
next	2.157;

2.157
date	2003.07.09.20.14.19;	author livesey;	state Exp;
branches;
next	2.156;

2.156
date	2003.07.04.03.40.13;	author vsnyder;	state Exp;
branches;
next	2.155;

2.155
date	2003.07.04.02.50.15;	author vsnyder;	state Exp;
branches;
next	2.154;

2.154
date	2003.06.27.23.43.34;	author vsnyder;	state Exp;
branches;
next	2.153;

2.153
date	2003.06.27.22.09.48;	author vsnyder;	state Exp;
branches;
next	2.152;

2.152
date	2003.06.27.00.59.53;	author vsnyder;	state Exp;
branches;
next	2.151;

2.151
date	2003.06.25.02.41.37;	author vsnyder;	state Exp;
branches;
next	2.150;

2.150
date	2003.06.18.22.26.41;	author vsnyder;	state Exp;
branches;
next	2.149;

2.149
date	2003.06.18.19.29.30;	author vsnyder;	state Exp;
branches;
next	2.148;

2.148
date	2003.06.18.17.23.16;	author bill;	state Exp;
branches;
next	2.147;

2.147
date	2003.06.18.14.54.04;	author bill;	state Exp;
branches;
next	2.146;

2.146
date	2003.06.18.01.59.20;	author vsnyder;	state Exp;
branches;
next	2.145;

2.145
date	2003.06.13.00.00.27;	author vsnyder;	state Exp;
branches;
next	2.144;

2.144
date	2003.06.10.15.06.54;	author bill;	state Exp;
branches;
next	2.143;

2.143
date	2003.06.09.20.52.37;	author vsnyder;	state Exp;
branches;
next	2.142;

2.142
date	2003.06.09.17.38.47;	author livesey;	state Exp;
branches;
next	2.141;

2.141
date	2003.05.29.16.37.38;	author livesey;	state Exp;
branches;
next	2.140;

2.140
date	2003.05.26.01.42.50;	author michael;	state Exp;
branches;
next	2.139;

2.139
date	2003.05.22.20.01.17;	author vsnyder;	state Exp;
branches;
next	2.138;

2.138
date	2003.05.22.04.03.41;	author livesey;	state Exp;
branches;
next	2.137;

2.137
date	2003.05.20.00.05.39;	author vsnyder;	state Exp;
branches;
next	2.136;

2.136
date	2003.05.15.03.29.44;	author vsnyder;	state Exp;
branches;
next	2.135;

2.135
date	2003.05.09.19.26.36;	author vsnyder;	state Exp;
branches;
next	2.134;

2.134
date	2003.05.05.23.00.24;	author livesey;	state Exp;
branches;
next	2.133;

2.133
date	2003.04.24.16.53.51;	author dwu;	state Exp;
branches;
next	2.132;

2.132
date	2003.04.22.00.14.45;	author dwu;	state Exp;
branches;
next	2.131;

2.131
date	2003.04.11.00.49.02;	author dwu;	state Exp;
branches;
next	2.130;

2.130
date	2003.03.04.20.22.40;	author dwu;	state Exp;
branches;
next	2.129;

2.129
date	2003.02.20.23.29.54;	author livesey;	state Exp;
branches;
next	2.128;

2.128
date	2003.02.13.23.05.50;	author jonathan;	state Exp;
branches;
next	2.127;

2.127
date	2003.02.13.17.25.07;	author bill;	state Exp;
branches;
next	2.126;

2.126
date	2003.02.11.00.48.18;	author jonathan;	state Exp;
branches
	2.126.2.1;
next	2.125;

2.125
date	2003.02.08.01.03.00;	author livesey;	state Exp;
branches;
next	2.124;

2.124
date	2003.02.07.01.07.41;	author jonathan;	state Exp;
branches;
next	2.123;

2.123
date	2003.02.06.22.04.25;	author vsnyder;	state Exp;
branches;
next	2.122;

2.122
date	2003.02.06.19.15.47;	author jonathan;	state Exp;
branches;
next	2.121;

2.121
date	2003.02.06.19.06.49;	author jonathan;	state Exp;
branches;
next	2.120;

2.120
date	2003.02.06.05.55.47;	author livesey;	state Exp;
branches;
next	2.119;

2.119
date	2003.02.06.00.20.08;	author jonathan;	state Exp;
branches;
next	2.118;

2.118
date	2003.02.03.23.18.43;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2003.02.03.22.58.17;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2003.02.03.19.00.36;	author bill;	state Exp;
branches;
next	2.115;

2.115
date	2003.02.01.02.33.22;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2003.01.31.17.53.39;	author jonathan;	state Exp;
branches;
next	2.113;

2.113
date	2003.01.31.17.15.49;	author jonathan;	state Exp;
branches;
next	2.112;

2.112
date	2003.01.31.01.53.01;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2003.01.30.00.16.35;	author jonathan;	state Exp;
branches;
next	2.110;

2.110
date	2003.01.26.04.42.42;	author livesey;	state Exp;
branches;
next	2.109;

2.109
date	2003.01.21.18.20.32;	author vsnyder;	state Exp;
branches;
next	2.108;

2.108
date	2003.01.18.03.36.09;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2003.01.18.01.43.19;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2003.01.16.23.13.03;	author livesey;	state Exp;
branches;
next	2.105;

2.105
date	2003.01.16.18.04.01;	author jonathan;	state Exp;
branches;
next	2.104;

2.104
date	2003.01.14.21.48.58;	author jonathan;	state Exp;
branches;
next	2.103;

2.103
date	2003.01.10.21.55.26;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2003.01.08.00.16.39;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2002.12.12.01.12.47;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2002.11.15.01.33.08;	author livesey;	state Exp;
branches;
next	2.99;

2.99
date	2002.11.13.17.07.44;	author livesey;	state Exp;
branches;
next	2.98;

2.98
date	2002.10.26.00.13.35;	author livesey;	state Exp;
branches;
next	2.97;

2.97
date	2002.10.25.01.12.43;	author livesey;	state Exp;
branches;
next	2.96;

2.96
date	2002.10.10.19.38.22;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2002.10.10.01.46.50;	author livesey;	state Exp;
branches;
next	2.94;

2.94
date	2002.10.10.01.28.06;	author livesey;	state Exp;
branches;
next	2.93;

2.93
date	2002.10.08.17.08.03;	author pwagner;	state Exp;
branches;
next	2.92;

2.92
date	2002.10.04.23.49.50;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2002.10.02.23.06.42;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2002.09.26.18.02.49;	author livesey;	state Exp;
branches;
next	2.89;

2.89
date	2002.09.10.17.05.38;	author livesey;	state Exp;
branches;
next	2.88;

2.88
date	2002.09.07.02.18.50;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2002.09.06.20.23.22;	author livesey;	state Exp;
branches;
next	2.86;

2.86
date	2002.09.06.18.19.04;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2002.09.05.21.00.38;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2002.08.26.20.02.22;	author livesey;	state Exp;
branches;
next	2.83;

2.83
date	2002.08.22.23.13.03;	author livesey;	state Exp;
branches;
next	2.82;

2.82
date	2002.08.20.23.33.23;	author livesey;	state Exp;
branches;
next	2.81;

2.81
date	2002.08.20.22.37.04;	author livesey;	state Exp;
branches;
next	2.80;

2.80
date	2002.08.02.00.12.07;	author bill;	state Exp;
branches;
next	2.79;

2.79
date	2002.07.31.23.27.54;	author bill;	state Exp;
branches;
next	2.78;

2.78
date	2002.07.31.00.03.45;	author livesey;	state Exp;
branches;
next	2.77;

2.77
date	2002.07.30.20.03.59;	author livesey;	state Exp;
branches;
next	2.76;

2.76
date	2002.07.30.20.03.19;	author livesey;	state Exp;
branches;
next	2.75;

2.75
date	2002.07.29.21.41.30;	author bill;	state Exp;
branches;
next	2.74;

2.74
date	2002.07.23.22.26.31;	author livesey;	state Exp;
branches;
next	2.73;

2.73
date	2002.07.19.23.35.49;	author bill;	state Exp;
branches;
next	2.72;

2.72
date	2002.07.11.20.51.20;	author bill;	state Exp;
branches;
next	2.71;

2.71
date	2002.07.09.17.37.10;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2002.07.08.17.45.37;	author zvi;	state Exp;
branches;
next	2.69;

2.69
date	2002.07.05.07.52.45;	author zvi;	state Exp;
branches;
next	2.68;

2.68
date	2002.06.28.21.41.36;	author livesey;	state Exp;
branches;
next	2.67;

2.67
date	2002.06.28.11.06.46;	author zvi;	state Exp;
branches;
next	2.66;

2.66
date	2002.06.26.19.58.48;	author livesey;	state Exp;
branches;
next	2.65;

2.65
date	2002.06.24.21.11.24;	author zvi;	state Exp;
branches;
next	2.64;

2.64
date	2002.06.24.21.07.13;	author zvi;	state Exp;
branches;
next	2.63;

2.63
date	2002.06.24.21.01.28;	author zvi;	state Exp;
branches;
next	2.62;

2.62
date	2002.06.20.14.34.01;	author bill;	state Exp;
branches;
next	2.61;

2.61
date	2002.06.17.17.12.15;	author bill;	state Exp;
branches;
next	2.60;

2.60
date	2002.06.17.16.30.52;	author bill;	state Exp;
branches;
next	2.59;

2.59
date	2002.06.14.22.51.14;	author bill;	state Exp;
branches;
next	2.58;

2.58
date	2002.06.13.22.40.38;	author bill;	state Exp;
branches;
next	2.57;

2.57
date	2002.06.11.22.20.10;	author bill;	state Exp;
branches;
next	2.56;

2.56
date	2002.06.07.23.22.58;	author bill;	state Exp;
branches;
next	2.55;

2.55
date	2002.06.07.23.01.25;	author bill;	state Exp;
branches;
next	2.54;

2.54
date	2002.06.07.04.50.03;	author bill;	state Exp;
branches;
next	2.53;

2.53
date	2002.06.05.17.20.28;	author livesey;	state Exp;
branches;
next	2.52;

2.52
date	2002.06.04.23.06.47;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2002.06.04.10.27.59;	author zvi;	state Exp;
branches;
next	2.50;

2.50
date	2002.05.28.17.09.14;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2002.05.24.17.10.57;	author livesey;	state Exp;
branches;
next	2.48;

2.48
date	2002.05.23.21.01.11;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2002.05.23.20.55.20;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2002.05.22.19.44.51;	author zvi;	state Exp;
branches;
next	2.45;

2.45
date	2002.05.17.22.13.20;	author livesey;	state Exp;
branches;
next	2.44;

2.44
date	2002.05.14.22.40.45;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2002.05.14.22.32.45;	author livesey;	state Exp;
branches;
next	2.42;

2.42
date	2002.05.14.00.19.10;	author livesey;	state Exp;
branches;
next	2.41;

2.41
date	2002.05.10.16.18.45;	author livesey;	state Exp;
branches;
next	2.40;

2.40
date	2002.05.08.08.53.42;	author zvi;	state Exp;
branches;
next	2.39;

2.39
date	2002.05.03.23.29.18;	author livesey;	state Exp;
branches;
next	2.38;

2.38
date	2002.02.22.00.52.06;	author bill;	state Exp;
branches;
next	2.37;

2.37
date	2002.02.20.22.19.45;	author zvi;	state Exp;
branches;
next	2.36;

2.36
date	2002.02.16.10.32.16;	author zvi;	state Exp;
branches;
next	2.35;

2.35
date	2002.02.16.06.49.59;	author zvi;	state Exp;
branches;
next	2.34;

2.34
date	2002.02.16.00.16.02;	author bill;	state Exp;
branches;
next	2.33;

2.33
date	2002.02.15.22.52.29;	author livesey;	state Exp;
branches;
next	2.32;

2.32
date	2002.02.14.19.05.01;	author bill;	state Exp;
branches;
next	2.31;

2.31
date	2002.02.13.20.35.47;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.02.08.00.46.05;	author zvi;	state Exp;
branches;
next	2.29;

2.29
date	2002.02.07.00.36.31;	author zvi;	state Exp;
branches;
next	2.28;

2.28
date	2002.02.05.21.54.29;	author zvi;	state Exp;
branches;
next	2.27;

2.27
date	2002.02.04.22.44.40;	author zvi;	state Exp;
branches;
next	2.26;

2.26
date	2002.02.02.11.20.17;	author zvi;	state Exp;
branches;
next	2.25;

2.25
date	2002.01.30.01.11.18;	author zvi;	state Exp;
branches;
next	2.24;

2.24
date	2002.01.27.08.37.45;	author zvi;	state Exp;
branches;
next	2.23;

2.23
date	2002.01.09.00.30.48;	author zvi;	state Exp;
branches;
next	2.22;

2.22
date	2002.01.08.01.01.19;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2001.12.26.04.05.04;	author zvi;	state Exp;
branches;
next	2.20;

2.20
date	2001.12.14.23.43.05;	author zvi;	state Exp;
branches;
next	2.19;

2.19
date	2001.11.25.07.57.12;	author zvi;	state Exp;
branches;
next	2.18;

2.18
date	2001.11.20.10.23.27;	author zvi;	state Exp;
branches;
next	2.17;

2.17
date	2001.11.20.01.18.59;	author zvi;	state Exp;
branches;
next	2.16;

2.16
date	2001.11.15.01.21.57;	author zvi;	state Exp;
branches;
next	2.15;

2.15
date	2001.11.10.00.46.40;	author zvi;	state Exp;
branches;
next	2.14;

2.14
date	2001.11.08.21.52.23;	author jonathan;	state Exp;
branches;
next	2.13;

2.13
date	2001.11.08.09.56.59;	author zvi;	state Exp;
branches;
next	2.12;

2.12
date	2001.11.08.00.11.29;	author livesey;	state Exp;
branches;
next	2.11;

2.11
date	2001.11.07.21.19.01;	author livesey;	state Exp;
branches;
next	2.10;

2.10
date	2001.11.07.21.16.56;	author livesey;	state Exp;
branches;
next	2.9;

2.9
date	2001.11.07.09.58.41;	author zvi;	state Exp;
branches;
next	2.8;

2.8
date	2001.11.03.01.33.35;	author livesey;	state Exp;
branches;
next	2.7;

2.7
date	2001.11.02.10.47.57;	author zvi;	state Exp;
branches;
next	2.6;

2.6
date	2001.10.12.20.40.25;	author livesey;	state Exp;
branches;
next	2.5;

2.5
date	2001.10.09.22.39.08;	author livesey;	state Exp;
branches;
next	2.4;

2.4
date	2001.10.02.16.51.41;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2001.09.19.04.38.48;	author livesey;	state Exp;
branches;
next	2.2;

2.2
date	2001.09.18.02.04.38;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.09.18.01.23.19;	author livesey;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.25;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.04.00.34.24;	author zvi;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.22.02.35.08;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.21.15.05.42;	author livesey;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.21.13.07.08;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.29.22.53.51;	author livesey;	state Exp;
branches;
next	;

2.126.2.1
date	2003.02.13.17.35.01;	author bill;	state Exp;
branches;
next	2.126.2.2;

2.126.2.2
date	2003.02.13.22.26.18;	author jonathan;	state Exp;
branches;
next	2.126.2.3;

2.126.2.3
date	2003.02.14.00.21.42;	author jonathan;	state Exp;
branches;
next	2.126.2.4;

2.126.2.4
date	2003.02.14.03.53.41;	author vsnyder;	state Exp;
branches;
next	2.126.2.5;

2.126.2.5
date	2003.02.14.23.27.31;	author vsnyder;	state Exp;
branches;
next	2.126.2.6;

2.126.2.6
date	2003.02.14.23.31.14;	author vsnyder;	state Exp;
branches;
next	2.126.2.7;

2.126.2.7
date	2003.02.15.00.29.11;	author vsnyder;	state Exp;
branches;
next	2.126.2.8;

2.126.2.8
date	2003.02.21.21.34.32;	author michael;	state Exp;
branches;
next	2.126.2.9;

2.126.2.9
date	2003.02.22.00.49.26;	author vsnyder;	state Exp;
branches;
next	2.126.2.10;

2.126.2.10
date	2003.02.24.23.26.43;	author jonathan;	state Exp;
branches;
next	2.126.2.11;

2.126.2.11
date	2003.02.24.23.40.31;	author jonathan;	state Exp;
branches;
next	2.126.2.12;

2.126.2.12
date	2003.02.25.00.53.09;	author jonathan;	state Exp;
branches;
next	2.126.2.13;

2.126.2.13
date	2003.02.27.23.35.01;	author vsnyder;	state Exp;
branches;
next	2.126.2.14;

2.126.2.14
date	2003.02.28.00.15.59;	author vsnyder;	state Exp;
branches;
next	2.126.2.15;

2.126.2.15
date	2003.03.01.03.19.28;	author vsnyder;	state Exp;
branches;
next	2.126.2.16;

2.126.2.16
date	2003.03.04.20.24.44;	author dwu;	state Exp;
branches;
next	2.126.2.17;

2.126.2.17
date	2003.03.05.03.40.07;	author vsnyder;	state Exp;
branches;
next	2.126.2.18;

2.126.2.18
date	2003.03.06.22.47.29;	author vsnyder;	state Exp;
branches;
next	2.126.2.19;

2.126.2.19
date	2003.03.07.23.17.05;	author vsnyder;	state Exp;
branches;
next	2.126.2.20;

2.126.2.20
date	2003.03.19.00.11.14;	author michael;	state Exp;
branches;
next	2.126.2.21;

2.126.2.21
date	2003.03.20.01.42.25;	author vsnyder;	state Exp;
branches;
next	2.126.2.22;

2.126.2.22
date	2003.03.20.19.21.05;	author vsnyder;	state Exp;
branches;
next	2.126.2.23;

2.126.2.23
date	2003.03.21.02.49.55;	author vsnyder;	state Exp;
branches;
next	2.126.2.24;

2.126.2.24
date	2003.03.22.02.48.53;	author vsnyder;	state Exp;
branches;
next	2.126.2.25;

2.126.2.25
date	2003.03.22.04.03.04;	author vsnyder;	state Exp;
branches;
next	2.126.2.26;

2.126.2.26
date	2003.03.22.04.19.13;	author vsnyder;	state Exp;
branches;
next	2.126.2.27;

2.126.2.27
date	2003.03.27.00.50.35;	author vsnyder;	state Exp;
branches;
next	2.126.2.28;

2.126.2.28
date	2003.03.27.23.32.19;	author vsnyder;	state Exp;
branches;
next	2.126.2.29;

2.126.2.29
date	2003.03.28.18.14.19;	author jonathan;	state Exp;
branches;
next	2.126.2.30;

2.126.2.30
date	2003.04.04.20.43.53;	author jonathan;	state Exp;
branches;
next	2.126.2.31;

2.126.2.31
date	2003.04.07.17.13.52;	author jonathan;	state Exp;
branches;
next	2.126.2.32;

2.126.2.32
date	2003.04.08.21.44.23;	author jonathan;	state Exp;
branches;
next	2.126.2.33;

2.126.2.33
date	2003.04.10.16.16.06;	author jonathan;	state Exp;
branches;
next	2.126.2.34;

2.126.2.34
date	2003.04.15.14.18.22;	author jonathan;	state Exp;
branches;
next	2.126.2.35;

2.126.2.35
date	2003.04.15.17.55.19;	author jonathan;	state Exp;
branches;
next	2.126.2.36;

2.126.2.36
date	2003.04.15.23.45.45;	author vsnyder;	state Exp;
branches;
next	2.126.2.37;

2.126.2.37
date	2003.04.16.19.32.02;	author vsnyder;	state Exp;
branches;
next	2.126.2.38;

2.126.2.38
date	2003.04.16.20.44.20;	author vsnyder;	state Exp;
branches;
next	2.126.2.39;

2.126.2.39
date	2003.04.24.19.01.19;	author vsnyder;	state Exp;
branches;
next	2.126.2.40;

2.126.2.40
date	2003.04.24.21.57.05;	author vsnyder;	state Exp;
branches;
next	;

1.5.2.1
date	2001.09.07.18.08.52;	author livesey;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.09.07.19.58.49;	author zvi;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.09.07.20.05.26;	author livesey;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.09.07.20.16.37;	author livesey;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2001.09.07.22.18.04;	author livesey;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2001.09.07.22.34.21;	author zvi;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2001.09.07.22.49.10;	author livesey;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2001.09.08.21.41.14;	author zvi;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2001.09.08.23.11.23;	author livesey;	state Exp;
branches;
next	1.5.2.10;

1.5.2.10
date	2001.09.08.23.47.52;	author livesey;	state Exp;
branches;
next	1.5.2.11;

1.5.2.11
date	2001.09.09.00.09.15;	author livesey;	state Exp;
branches;
next	1.5.2.12;

1.5.2.12
date	2001.09.09.00.43.34;	author zvi;	state Exp;
branches;
next	1.5.2.13;

1.5.2.13
date	2001.09.09.01.41.58;	author zvi;	state Exp;
branches;
next	1.5.2.14;

1.5.2.14
date	2001.09.09.01.40.18;	author livesey;	state Exp;
branches;
next	1.5.2.15;

1.5.2.15
date	2001.09.09.01.57.41;	author zvi;	state Exp;
branches;
next	1.5.2.16;

1.5.2.16
date	2001.09.09.01.57.31;	author livesey;	state Exp;
branches;
next	1.5.2.17;

1.5.2.17
date	2001.09.09.02.18.03;	author zvi;	state Exp;
branches;
next	1.5.2.18;

1.5.2.18
date	2001.09.09.02.16.56;	author livesey;	state Exp;
branches;
next	1.5.2.19;

1.5.2.19
date	2001.09.09.02.42.52;	author zvi;	state Exp;
branches;
next	1.5.2.20;

1.5.2.20
date	2001.09.09.03.02.53;	author zvi;	state Exp;
branches;
next	1.5.2.21;

1.5.2.21
date	2001.09.09.03.03.25;	author livesey;	state Exp;
branches;
next	1.5.2.22;

1.5.2.22
date	2001.09.09.03.16.48;	author livesey;	state Exp;
branches;
next	1.5.2.23;

1.5.2.23
date	2001.09.09.11.17.43;	author zvi;	state Exp;
branches;
next	1.5.2.24;

1.5.2.24
date	2001.09.10.10.02.32;	author zvi;	state Exp;
branches;
next	1.5.2.25;

1.5.2.25
date	2001.09.10.19.38.19;	author livesey;	state Exp;
branches;
next	1.5.2.26;

1.5.2.26
date	2001.09.10.19.56.36;	author livesey;	state Exp;
branches;
next	1.5.2.27;

1.5.2.27
date	2001.09.10.20.24.06;	author livesey;	state Exp;
branches;
next	1.5.2.28;

1.5.2.28
date	2001.09.10.20.46.42;	author livesey;	state Exp;
branches;
next	1.5.2.29;

1.5.2.29
date	2001.09.10.21.06.42;	author livesey;	state Exp;
branches;
next	1.5.2.30;

1.5.2.30
date	2001.09.10.21.07.58;	author livesey;	state Exp;
branches;
next	1.5.2.31;

1.5.2.31
date	2001.09.10.23.34.51;	author zvi;	state Exp;
branches;
next	1.5.2.32;

1.5.2.32
date	2001.09.10.23.50.47;	author livesey;	state Exp;
branches;
next	1.5.2.33;

1.5.2.33
date	2001.09.11.00.01.06;	author zvi;	state Exp;
branches;
next	1.5.2.34;

1.5.2.34
date	2001.09.11.00.50.32;	author zvi;	state Exp;
branches;
next	1.5.2.35;

1.5.2.35
date	2001.09.11.01.27.14;	author livesey;	state Exp;
branches;
next	1.5.2.36;

1.5.2.36
date	2001.09.11.01.36.54;	author livesey;	state Exp;
branches;
next	1.5.2.37;

1.5.2.37
date	2001.09.11.08.13.33;	author zvi;	state Exp;
branches;
next	1.5.2.38;

1.5.2.38
date	2001.09.11.20.48.22;	author zvi;	state Exp;
branches;
next	1.5.2.39;

1.5.2.39
date	2001.09.11.20.48.04;	author livesey;	state Exp;
branches;
next	1.5.2.40;

1.5.2.40
date	2001.09.11.21.24.27;	author livesey;	state Exp;
branches;
next	1.5.2.41;

1.5.2.41
date	2001.09.12.00.12.03;	author livesey;	state Exp;
branches;
next	1.5.2.42;

1.5.2.42
date	2001.09.12.00.30.00;	author zvi;	state Exp;
branches;
next	1.5.2.43;

1.5.2.43
date	2001.09.12.00.32.36;	author livesey;	state Exp;
branches;
next	1.5.2.44;

1.5.2.44
date	2001.09.12.01.00.34;	author livesey;	state Exp;
branches;
next	1.5.2.45;

1.5.2.45
date	2001.09.12.04.42.32;	author zvi;	state Exp;
branches;
next	1.5.2.46;

1.5.2.46
date	2001.09.12.22.38.25;	author livesey;	state Exp;
branches;
next	1.5.2.47;

1.5.2.47
date	2001.09.12.22.46.26;	author livesey;	state Exp;
branches;
next	1.5.2.48;

1.5.2.48
date	2001.09.12.22.56.05;	author livesey;	state Exp;
branches;
next	1.5.2.49;

1.5.2.49
date	2001.09.12.23.44.18;	author livesey;	state Exp;
branches;
next	1.5.2.50;

1.5.2.50
date	2001.09.13.00.42.18;	author livesey;	state Exp;
branches;
next	1.5.2.51;

1.5.2.51
date	2001.09.13.01.48.39;	author livesey;	state Exp;
branches;
next	1.5.2.52;

1.5.2.52
date	2001.09.13.02.03.08;	author livesey;	state Exp;
branches;
next	1.5.2.53;

1.5.2.53
date	2001.09.13.11.18.15;	author zvi;	state Exp;
branches;
next	1.5.2.54;

1.5.2.54
date	2001.09.13.19.36.27;	author livesey;	state Exp;
branches;
next	1.5.2.55;

1.5.2.55
date	2001.09.13.19.57.43;	author livesey;	state Exp;
branches;
next	1.5.2.56;

1.5.2.56
date	2001.09.14.22.19.39;	author livesey;	state Exp;
branches;
next	;


desc
@@


2.411
log
@Commented-out most uncondtional printing
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module FullForwardModel_m

  ! This module contains the `full' forward model.

  use GLNP, only: NG, NGP1
  implicit NONE
  private
  public :: FullForwardModel

!------------------------------ RCS Ident Info -------------------------------
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: FullForwardModel_m.f90,v $"
!------------------------------------------------------------------------------

  ! Private parameters:

  integer, parameter :: Max_New = NGP1 ! Maximum new points in coarse path in
    ! addition to ones derived from the preselected zeta grid: the minimum
    ! zeta point plus NG H_Glgrid intersections below the tangent zeta.

  logical, parameter :: NaN_Fill = .false. ! Fill automatic arrays with NaN

  logical, parameter :: Zeta_Only = .true. ! Don't determine intersections of
    ! the LOS with vertical boundaries of a QTM-based grid.  Calculations
    ! along the line of sight are mostly from one intersection with a constant
    ! zeta surface to the next one.  If vertical boundary intersections are
    ! included, the maximum diameter of the QTM would need to be included in
    ! those numbers of elements along the path.

  logical :: Same_Facets ! The size of the union of the parts of the QTM
    ! traversed by the paths of all MIFs in the MAF is less than twice the
    ! length of the longest one.  Thereby, we can copy the subset of the
    ! state vector of the MAF into Grids_Tmp and Grids_F once, instead of
    ! allocating Grids_Tmp and Grids_F at first for the maximum number of
    ! vertices needed for any MIF, and copying the appropriate subset of the
    ! state vector in each pointing.  Sizes of automatic arrays in
    ! FullForwardModelAuto depend upon them.

  ! This is set from the configuration:

  logical, private :: WrongTrapezoidal = .true.
    ! If GL is not used on a panel, the rectangular estimate used to cancel
    ! the singularity at the tangent point is replaced by a trapezoidal
    ! estimate.  Originally, this was done incorrectly, using delta
    ! s ~ ds/dh dh/dz delta z, which is a rectangular quadrature approximation
    ! of delta s.  We have delta s, so we ought to use it.  This flag
    ! indicates whether the incorrect computation ought to be preserved.

  logical, private, parameter :: Dump_ds = .false.
    ! The difference between the trapezoidal methods is that one uses del_s
    ! and the other uses dsdz_c * del_zeta.  If this parameter is true,
    ! these values are written to units 42 and 43.

contains

  ! -------------------------------------------- FullForwardModel -----

  subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
                             &  FwdModelOut, FmStat, Jacobian, ExtraJacobian, &
                             &  Hessian )

  ! This gets a little bit of data and then computes the sizes for quantities
  ! in the full forward model proper, FullForwardModelAuto.

    use Allocate_Deallocate, only: Deallocate_Test, Test_Allocate, Test_Deallocate
    use Check_QTM_m, only: Check_QTM
    use Compute_Z_PSIG_M, only: Compute_Z_PSIG
    use ForwardModelConfig, only: Dump, ForwardModelConfig_T
    use ForwardModelIntermediate, only: ForwardModelStatus_T
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Get_Magnetic_Field_m, only: Get_Magnetic_Field
    use Get_Species_Data_M, only:  Get_Species_Data
    use HessianModule_1, only: Hessian_T
    use HGridsDatabase, only: HGrid_T
    use Interpolate_MIF_to_Tan_Press_m, only: Get_Lines_of_Sight
    use Intrinsic, only: Lit_Indices, L_ECRtoFOV, L_PhiTan, L_PTan, L_ScECR, &
      & L_TScat, L_VMR, L_Wrong
    use Load_SPS_Data_M, only: DestroyGrids_T, Dump, EmptyGrids_T, Grids_T, &
      & Load_One_Item_Grid, Load_SPS_Data
    use MatrixModule_1, only: Matrix_T
    use MLSKinds, only: RP
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSStringLists, only: SwitchDetail
    use Molecules, only: L_CloudIce
    use MoreMessage, only: MLSMessage
    use Path_Representation_m, only: Facets_and_Vertices_t, Path_t, Union_Paths
    use QTM_Facets_Under_Path_m, only: QTM_Facets_Under_Path
    use Tangent_Pressures_m, only: Tangent_Pressures
    use Toggles, only: Emit, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use VectorsModule, only: Vector_T, VectorValue_T

    type(forwardModelConfig_T), intent(inout) :: FwdModelConf
    type(vector_T), intent(in) :: FwdModelIn, FwdModelExtra
    type(vector_T), intent(inout) :: FwdModelOut  ! Radiances, etc.
    type(forwardModelStatus_t), intent(inout) :: FmStat ! Reverse comm. stuff
    type(matrix_T), intent(inout), optional :: Jacobian
    type(matrix_T), intent(inout), optional :: ExtraJacobian
    type(hessian_T), intent(inout), optional :: Hessian

    real(rp), allocatable :: Z_PSIG(:)    ! Surfs from Temperature, tangent grid
                                ! and species grids, sans duplicates.
    real(rp), allocatable :: Tan_Press(:) ! Pressures corresponding to Z_PSIG

    type (Facets_and_Vertices_t), allocatable :: F_and_V(:) ! Facets and
                                ! vertices under each path through
                                ! the QTM that is used to integrate the
                                ! radiative-transfer equation.
    type (Facets_and_Vertices_t), allocatable :: F_and_V_MIF(:) ! Facets and
                                ! vertices under each path through
                                ! the QTM that is a MIF line of sight.
    type (Grids_T) :: Grids_tmp ! All the coordinates for TEMP
    type (Grids_T) :: Grids_f   ! All the coordinates for VMR
    type (Grids_T) :: Grids_IWC ! All the coordinates for IWC
    type (Grids_T) :: Grids_mag ! All the coordinates for Magnetic field
    type (Grids_T) :: Grids_n   ! All the spectroscopy(N) coordinates
    type (Grids_T) :: Grids_v   ! All the spectroscopy(V) coordinates
    type (Grids_T) :: Grids_w   ! All the spectroscopy(W) coordinates
    type (HGrid_T), pointer :: QTM_HGrid  ! HGrid that has finest QTM resolution.
    type (Path_t), allocatable :: QTM_Paths(:)! LOS through QTM at tangent
                                ! pressures given by Tan_Press
    type (VectorValue_T), pointer :: CloudIce ! Ice water content
    type (Facets_and_Vertices_t), allocatable :: Path_Union(:) ! Facets and
                                ! vertices under all paths through the QTM.
    type (VectorValue_T), pointer :: ECRtoFOV ! Rotation matrix from ECR to
                                ! field-of-view (minor frame quantity)
    type (VectorValue_T), pointer :: PhiTan   ! Tangent geodAngle component of
                                ! state vector (minor frame quantity)
    type (VectorValue_T), pointer :: PTan     ! Tangent pressure component of
                                ! state vector (minor frame quantity)
    type (Path_T), allocatable :: Q_LOS(:)    ! Line-of-sight, for QTM,
                                ! minor frame quantity
    type (VectorValue_T), pointer :: ScECR_MIF ! Instrument position in ECR
                                ! (minor frame quantity)
    type (VectorValue_T), pointer :: Temp     ! Temperature component of
                                ! state vector

    character(127) :: ERMSG     ! From allocate

    integer :: Dump_Conf        ! for debugging, from -Sfmconf
    integer :: K                ! Loop inductor and subscript
    integer :: Longest_QTM_path ! Path with greatest number of QTM vertices
                                ! adjacent to the line of sight
    integer :: Max_C            ! Length of longest possible coarse path,
                                ! Z_PSIG & Min Zeta & surface Zeta
    integer :: Max_F            ! Length of longest possible combined coarse &
                                ! fine path (all npf<max_f)
    integer :: MaxVert          ! Number of points in gl-refined vertical grid:
                                ! (NLVL-1) * (NG+1) + 1, i.e., 1 + NG
                                ! per level, except the last,
                                ! where there's no GL space.
    integer :: Me = -1          ! String index for trace
    integer :: Nlvl             ! Number of levels in coarse zeta grid
    integer :: No_Mol           ! Number of molecules
    integer :: No_sv_p_T        ! number of phi basis for temperature
    integer :: No_Tan_Hts       ! Number of tangent heights
    integer :: NoUsedChannels   ! Number of channels used
    integer :: N_T_zeta         ! Number of zetas for temperature
    integer :: Stat             ! From allocate
    integer :: SurfaceTangentIndex  ! Index in tangent grid of earth's
                                    ! surface
    integer :: Sv_T_len         ! Number of t_phi*t_zeta in the window
    integer :: S_A   ! Multiplier for atmos derivative sizes, 0 or 1
    integer :: S_H   ! Multiplier for atmos second derivative sizes, 0 or 1
    integer :: S_I   ! Multiplier for ice/cloud sizes, 0 or 1
    integer :: S_LC  ! Multiplier for line center deriv sizes, 0 or 1
    integer :: S_LW  ! Multiplier for line width deriv sizes, 0 or 1
    integer :: S_PFA ! Multiplier for PFA sizes, 0 or 1
    integer :: S_P   ! Multiplier for polarized sizes, 0 or 1
    integer :: S_QTM ! Multiplier for sizes of QTM-related stuff, 0 or 1
    integer :: S_T   ! Multiplier for temp derivative sizes, 0 or 1
    integer :: S_TD  ! Multiplier for temp dependence deriv sizes, 0 or 1
    integer :: S_TG  ! Multiplier for TScat generation sizes, 0 or 1
    integer :: S_TS  ! Multiplier for using TScat tables, 0 or 1
    logical :: UsingQTM         ! Temperature and all species have QTM hGrids

    ! Flags for various derivatives
    logical :: Atmos_Der, Atmos_Second_Der, PTan_Der, Spect_Der
    logical :: Spect_Der_Center, Spect_Der_Width, Spect_Der_Width_TDep
    ! What severity is not having derivative in "first" state vector?
    integer, parameter :: DerivativeMissingFromState = MLSMSG_Error

    call trace_begin ( me, 'FullForwardModel, MAF=', index=fmstat%maf, &
      & cond=toggle(emit) ) ! set by -f command-line switch

    ! Create the data structures for the species.  Get the
    ! spectroscopy parameters from the state vector.  Get a pointer to the
    ! temperature quantity from the state vector into the configuration.
    ! This has to be done AFTER DeriveFromForwardModelConfig, which is
    ! invoked from ForwardModelWrappers.

    call get_species_data ( fwdModelConf, fwdModelIn, fwdModelExtra )

    ! Get a shorter handle for the temperature quantity
    temp => fwdModelConf%temp%qty

    no_mol = size(fwdModelConf%beta_group)
    noUsedChannels = size(fwdModelConf%channels)

    ! Check whether temperature and all the mixing ratios either all have QTM
    ! HGrid, or none do.  If so, find the QTM HGrid with the finest resolution.
    ! (We currently require that if they're QTM they all have the same grid.)

    call check_QTM ( fwdModelConf, QTM_HGrid, usingQTM )

    ! Compute the preselected integration grid (all surfs from temperature,
    ! tangent grid and species).  Tan_Press is thrown in for free.
    if ( fwdModelConf%generateTScat ) then
      ! Make sure the TScat zeta is in the preselected grid.
      call compute_Z_PSIG ( fwdModelConf, z_psig,                  &
                          & GetQuantityForForwardModel (            &
                          &  fwdModelOut, quantityType=l_TScat,     &
                          &  signal=fwdModelConf%signals(1)%index,  &
                          &  config=fwdModelConf ) )

    else
      call compute_Z_PSIG ( fwdModelConf, z_psig )
    end if
    nlvl = size(z_psig)
    call tangent_pressures ( fwdModelConf, z_psig, no_tan_hts,   &
                           & surfaceTangentIndex, tan_press )

    ! Find the phiTan quantity in the state vector.  The phiTan quantity is
    ! only used to compute the instance window for the temperature quantity.
    ! If the temperature grid is QTM, phiTan isn't actually used because the
    ! entire QTM is used, instead of having an instance window.
    phitan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, config=fwdModelConf, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule )

    ! Compute some derivative flags.  %derivOK needs to be computed BEFORE
    ! loading Grids_f.
    fwdModelConf%beta_group%qty%derivOK = fwdModelConf%moleculeDerivatives .and. &
      & ( fwdModelConf%beta_group%qty%foundInFirst .or. present(extraJacobian) )
    fwdModelConf%temp%derivOK = present ( jacobian ) .and. FwdModelConf%temp_der
    if ( fwdModelConf%temp%derivOK .and. .not. fwdModelConf%temp%foundInFirst ) &
      & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
        & 'With config(%S): Temperature derivative requested but temperature is not in "first" state vector', &
        & datum=fwdModelConf%name )

    pTan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, foundInFirst=pTan_der, config=fwdModelConf, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule )
    pTan_der = pTan_der .and. present ( jacobian )

    wrongTrapezoidal = fwdModelConf%trapezoid == l_wrong

    ! Compute some sizes
    n_t_zeta = temp%template%noSurfs ! Number of zeta levels for temperature

    if ( usingQTM ) then

      ! These computations are here instead of in Both_Sidebands_Setup
      ! because they calculate No_Sv_P_T, which is bound for many arrays
      ! in FullForwardModelAuto.

      ! Find the facets and vertices under all the paths through the QTM.
      ! The largest number of vertices in any of them is the horizontal
      ! extent of grids related to temperature.

      allocate ( QTM_Paths(no_tan_hts), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "QTM_paths", 1, no_tan_hts, &
        & ermsg=ermsg )
      allocate ( F_and_V(no_tan_hts), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "F_and_V", 1, no_tan_hts, &
        & ermsg=ermsg )
      allocate ( F_and_V_MIF(ptan%template%noSurfs), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "F_and_V_MIF", 1, no_tan_hts, &
        & ermsg=ermsg )
      ! Path_Union is allocatable instead of explicit shape so that it can be
      ! moved to F_And_V or F_And_V_MIF if all paths have (approximately) the
      ! same sets of facets and vertices.
      allocate ( path_union(1), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "Path_Union", 1, 1, &
        & ermsg=ermsg )

      ! Get Q_LOS ( C, U ) vectors for all MIFs for the MAF
      ! The third column of ECRtoFOV is an unit vector in the direction of
      ! the line of sight from the instrument.
      ECRtoFOV => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_ECRtoFOV, config=fwdModelConf )
      allocate ( Q_LOS(ECRtoFOV%template%noSurfs), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "Q_LOS", 1, 1, &
        & ermsg=ermsg )
      scECR_MIF => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_scECR, config=fwdModelConf )
      do k = 1, size(Q_LOS)
        Q_LOS(k)%lines(1,1)%xyz = ScECR_MIF%value3(1:3,k,fmstat%maf) ! C vec
        Q_LOS(k)%lines(2,1)%xyz = ECRtoFOV%value3(7:9,k,fmstat%maf)  ! U vec
      end do

      call get_lines_of_sight ( fmStat%maf, pTan, tan_press, Q_LOS, &
                              & QTM_paths )

      ! Compute the maximum horizontal extent of arrays related to temperature.
      ! Temperature is extracted from the state vector and put onto a grid that
      ! has a horizontal extent equal to the maximum number of vertices adjacent
      ! to any path through the QTM.  All the other temperature-related
      ! quantities have the same horizontal grid.

      ! If MIFs in a MAF might cover very different sets of facets of the QTM,
      ! we need to know the longest one because components of Grids_Tmp
      ! and Grids_F provide sizes of automatic arrays in FullForwardModelAuto,
      ! and then re-create Grids_Tmp and Grids_F for each pointing.
      ! Otherwise, assume that each MIF of a MAF covers approximately the same
      ! set of facets.
      no_sv_p_T = 0
      longest_QTM_path = 1
      do k = 1, no_tan_hts ! size(QTM_paths), size(F_and_V)
        call QTM_Facets_Under_Path ( QTM_paths(k), QTM_HGrid%QTM_tree, &
          & F_and_V(k) )
        if ( size(f_and_v(k)%vertices) > no_sv_p_T ) then
          no_sv_p_T = size(f_and_v(k)%vertices)
          longest_QTM_path = k
        end if
        call union_paths ( path_union(1), f_and_v(k) )
      end do
      same_facets = size(path_union(1)%vertices) <= 2 * no_sv_p_T
      if ( same_facets ) then
        call move_alloc ( path_union, f_and_v )
        longest_QTM_path = 1
        no_sv_p_T = size(F_and_V(1)%vertices)
      end if

      ! Copy the temperature from the state vector via the configuration into
      ! Grids_tmp.  Automatic extents of arrays in FullForwardModelAuto
      ! depend upon components of Grids_Tmp.  If Same_Facets, these values will
      ! be used for all paths, else new ones will be loaded for each path.

      call load_one_item_grid ( grids_tmp, temp, fmStat%maf, phitan, fwdModelConf, &
        & setDerivFlags=.true., subset=f_and_v(longest_QTM_path)%vertices, &
        & short=.not. same_facets )

      ! Copy the mixing ratios from the state vector via the configuration
      ! into Grids_f.  Automatic extents of arrays in FullForwardModelAuto
      ! depend upon components of Grids_F.  If Same_Facets, these values will
      ! be used for all paths, else new ones will be loaded for each path.

      call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f, &
        & subset=f_and_v(longest_QTM_path)%vertices, short=.not. same_facets )

      ! Calculate facets and vertices under MIF paths.  These are used for
      ! the hydrostatic equilibrium calculation that is necessary to compute
      ! MIF-based Chi angles, and their derivatives.

      do k = 1, ptan%template%noSurfs
        call QTM_Facets_Under_Path ( Q_LOS(k), QTM_HGrid%QTM_tree, &
          & F_and_V_MIF(k) )
        call union_paths ( path_union(1), F_and_V_MIF(k) )
      end do
      if ( size(path_union(1)%vertices) <= 2 * size(F_and_V_MIF(k)%vertices) ) &
        & call move_alloc ( path_union, F_and_V_MIF )

    else ! not QTM

      same_facets = .true. ! Used to decide whether to re-load Grids_Tmp and
                           ! Grids_F for each path, even in the non-QTM case.

      ! Copy the temperature quantity from the state vector via the
      ! configuration into Grids_tmp.  Automatic extents of arrays in
      ! FullForwardModelAuto depend upon components of Grids_Tmp.

      call load_one_item_grid ( grids_tmp, temp, fmStat%maf, phitan, fwdModelConf, &
        & setDerivFlags=.true. )

      ! Copy the mixing ratios from the state vector via the configuration into
      ! Grids_f.  Automatic extents of arrays in FullForwardModelAuto depend
      ! upon components of Grids_F.

      call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f )

      allocate ( QTM_Paths(0), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "QTM_paths", 1, no_tan_hts, &
        & ermsg=ermsg )
      ! One element of F_and_V is needed because routines in Convolve_All_m
      ! test whether F_and_V%Vertices is allocated.
      allocate ( F_and_V(1), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "F_and_V", 1, 1, &
        & ermsg=ermsg )
      no_sv_p_T = grids_tmp%l_p(1)  ! size of temperature's horizontal grid ==
                                    ! windowFinish - windowStart + 1.
    end if ! not QTM

    sv_t_len = no_sv_p_T * n_t_zeta ! Number of temperature values

    spect_der = present ( jacobian ) .and. FwdModelConf%spect_der
    spect_der_center = spect_der .and. size(fwdModelConf%lineCenter) > 0
    spect_der_width = spect_der .and. size(fwdModelConf%lineWidth) > 0
    spect_der_width_TDep = spect_der .and. size(fwdModelConf%lineWidth_TDep) > 0

    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der
    atmos_second_der = present (hessian ) .and. FwdModelConf%atmos_second_der

    ! Determine where we can compute derivatives.  We know for sure we have
    ! a place to put them if fwdModelConf%Beta_group%qty%foundInFirst, but
    ! we also have a place to put them otherwise if ExtraJacobian is present
    ! and there's a column there for it.

    if ( atmos_der ) then
      do k = 1, no_mol
        if ( fwdModelConf%moleculeDerivatives(k) ) then
          if ( .not. fwdModelConf%beta_group(k)%qty%derivOK ) then
            call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
              & 'With config(%S): ' // &
              & '%S derivative requested but %S is not in "first" state vector, ' // &
              & 'or ExtraJacobian is not present', &
              & datum=(/ fwdModelConf%name, lit_indices(k), lit_indices(k) /) )
          end if
        else if ( .not. usingQTM ) then
          ! Turn off deriv_flags where we don't want molecule derivatives,
          ! so we don't have to look at fwdModelConf%moleculeDerivatives
          grids_f%deriv_flags(grids_f%l_v(k-1)+1:grids_f%l_v(k)) = .false.
        end if
      end do                        ! Loop over major molecules
    end if                          ! Want derivatives for atmos

    if ( spect_der_center .and. &
       & any(.not. fwdModelConf%lineCenter%qty%foundInFirst) ) then
       ! If the vector quantity for the desired molecule is not in the
       ! "first" state vector, check whether there's an ExtraJacobian.
       if ( .not. present(extraJacobian) ) &
         & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
           & 'With config(%S): ' // &
           & 'derivative requested but line center is not in "first" state ' // &
           & 'vector, or ExtraJacobian is not present', &
           & datum=(/ fwdModelConf%name /) )
    end if
    if ( spect_der_width .and. &
       & any(.not. fwdModelConf%lineWidth%qty%foundInFirst) ) then
       ! If the vector quantity for the desired molecule is not in the
       ! "first" state vector, check whether there's an ExtraJacobian.
       if ( .not. present(extraJacobian) ) &
         & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
           & 'With config(%S): ' // &
           & 'derivative requested but line width is not in "first" state ' // &
           & 'vector, or ExtraJacobian is not present', &
           & datum=(/ fwdModelConf%name /) )
    end if
    if ( spect_der_width_TDep .and. &
       & any(.not. fwdModelConf%lineWidth_TDep%qty%foundInFirst) ) then
       ! If the vector quantity for the desired molecule is not in the
       ! "first" state vector, check whether there's an ExtraJacobian.
       if ( .not. present(extraJacobian) ) &
         & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
           & 'With config(%S): ' // &
           & 'derivative requested but line width temperature dependence is ' // &
           & 'not in "first" state vector, or ExtraJacobian is not present', &
           & datum=(/ fwdModelConf%name /) )
    end if

    call Get_Magnetic_Field ( fwdModelConf, fwdModelIn, fwdModelExtra, &
                            & fmStat, phiTan, grids_mag )

    nullify ( cloudIce )
    if ( FwdModelConf%incl_cld .or. FwdModelConf%useTScat ) then
      cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_vmr, molecule=l_cloudIce, config=fwdModelConf,    &
        & noError=.true. )
    end if
    if ( associated(cloudIce) ) then
      call load_one_item_grid ( grids_IWC, cloudIce, fmStat%maf, phitan, &
        & fwdModelConf, .false., .false. )
    else
      call emptyGrids_t ( grids_IWC ) ! Allocate components with zero size
    end if

    ! Compute some sizes
    maxVert = (nlvl-1) * ngp1 + 1
    if ( usingQTM .and. .not. zeta_only ) then
      ! We don't know the maximum diameter of the QTM HGrid, so assume a ray
      ! could cut through all facets at all altitudes.
      max_c = 2*max(nlvl,QTM_hGrid%QTM_tree%n_facets) + max_new + 1
      max_f = ( max_c - 1 ) * ngp1 + 1
    else ! not QTM, or QTM but only with constant-zeta surface intersections
      max_c = 2*nlvl + max_new + 1 ! Maximum coarse path length
      max_f = 2 * maxVert + ngp1   ! Maximum fine path, including minimum Zeta panel
    end if

    ! Allocate and fill spectroscopy derivative grids.  They'll be empty
    ! if fwdModelConf%line* has size zero.
    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_v, &
      & qtyStuffIn=fwdModelConf%lineCenter%qty )
    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_w, &
      & qtyStuffIn=fwdModelConf%lineWidth%qty )
    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_n, &
      & qtyStuffIn=fwdModelConf%lineWidth_TDep%qty )

    if ( switchDetail(switches,'Grids') > -1 .and. .not. usingQTM ) then
      ! dump the grids
      call dump ( grids_f, "Grids_f", details=9 )
      call dump ( grids_tmp, "Grids_tmp", details=9 )
      if ( size(fwdModelConf%lineCenter) > 0 ) call dump ( grids_v )
      if ( size(fwdModelConf%lineWidth) > 0 ) call dump ( grids_w )
      if ( size(fwdModelConf%lineWidth_TDep) > 0 ) call dump ( grids_n )
    end if

    s_a = merge(1,0,atmos_der)
    s_h = merge(1,0,atmos_second_der)
    s_i = merge(1,0,FwdModelConf%incl_cld)
    s_lc = merge(1,0,spect_der_center)
    s_lw = merge(1,0,spect_der_width)
    s_pfa = merge(1,0,FwdModelConf%anyPFA(1) .or. FwdModelConf%anyPFA(2))
    s_p = merge(1,0,FwdModelConf%polarized)
    s_QTM = merge(1,0,usingQTM)
    s_t = merge(1,0,fwdModelConf%temp%derivOK)
    s_td = merge(1,0,spect_der_width_TDep)
    s_tg = merge(1,0,FwdModelConf%GenerateTScat)
    s_ts = merge(1,0,FwdModelConf%useTScat)

    dump_conf = switchDetail(switches,'fmconf')
    if ( dump_conf > -1 ) call dump( FwdModelConf, details=dump_conf  )

    call FullForwardModelAuto ( FwdModelConf, FwdModelIn, FwdModelExtra,       &
                              & FwdModelOut, FmStat, z_psig, tan_press,        &
                              & grids_tmp, grids_f, grids_mag, grids_iwc,      &
                              & grids_n, grids_v, grids_w,                     &
                              & ptan, phitan, temp,                            &
!Q                              & QTM_HGrid, &
                              & Q_LOS, QTM_Paths, ScECR_MIF,                   &
                              & F_and_V, F_and_V_MIF, no_mol, noUsedChannels,  &
                              & no_sv_p_T, n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
                              & surfaceTangentIndex,                           &
                              & max_c, maxVert, max_f, ptan_der,               &
                              & s_t, s_a, s_h, s_lc, s_lw, s_td, s_p, s_pfa,   &
                              & s_i, s_tg, s_ts, s_QTM,                        &
                              ! Optional:
                              & Jacobian, ExtraJacobian, Hessian )

    call destroygrids_t ( grids_f )
    call destroygrids_t ( grids_iwc )
    call destroygrids_t ( grids_mag )
    call destroygrids_t ( grids_tmp )
    call destroygrids_t ( grids_n )
    call destroygrids_t ( grids_w )
    call destroygrids_t ( grids_v )

    ! Allocated in tangent_pressures:
    call deallocate_test ( tan_press,    'tan_press',    moduleName )

    deallocate ( QTM_Paths, stat=stat, errmsg=ermsg )
    call test_deallocate ( stat, moduleName, "QTM_Paths", ermsg=ermsg )
    deallocate ( F_and_V, stat=stat, errmsg=ermsg )
    call test_deallocate ( stat, moduleName, "F_and_V", ermsg=ermsg )
    if ( allocated(F_and_V_MIF) ) then
      deallocate ( F_and_V_MIF, stat=stat, errmsg=ermsg )
      call test_deallocate ( stat, moduleName, "F_and_V_MIF", ermsg=ermsg )
    end if

    call trace_end ( 'FullForwardModel, MAF=', fmStat%maf, cond=toggle(emit) )

  contains

    integer function DerivativeMissingFromStateFun() result( SEVERITY )
      ! Default severity (probably ERROR) can be reduced to a warning 
      ! by adding -Sdmiss to command line
      ! Args
      severity = merge( min( MLSMSG_Warning, DerivativeMissingFromState ), &
                      & DerivativeMissingFromState, &
                      & switchDetail(switches,'dmiss') > -1 )
    end function DerivativeMissingFromStateFun

  end subroutine FullForwardModel

  ! ---------------------------------------- FullForwardModelAuto  -----

  subroutine FullForwardModelAuto ( FwdModelConf, FwdModelIn, FwdModelExtra,   &
                             & FwdModelOut, FmStat, z_psig, tan_press,         &
                             & grids_tmp,  grids_f, grids_mag, grids_iwc,      &
                             & grids_n, grids_v, grids_w, ptan,                &
                             & phitan, temp, &
!Q                             & QTM_HGrid, &
                             & Q_LOS, QTM_Paths, ScECR_MIF,                    &
                             & F_and_V, F_and_V_MIF, no_mol, noUsedChannels,   &
                             & No_sv_p_T, n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
                             & surfaceTangentIndex,                            &
                             & max_c, maxVert, max_f, ptan_der,                &
                             & s_t, s_a, s_h, s_lc, s_lw, s_td, s_p, s_pfa,    &
                             & s_i, s_tg, s_ts, s_QTM,                         &
                             ! Optional:
                             & Jacobian, ExtraJacobian, Hessian )

  ! This is the full radiative transfer forward model, the workhorse code.
  ! It's called FullForwardModelAuto because most of the variable-size
  ! work arrays are automatic arrays, instead of being explicitly allocated
  ! and deallocated.  Their extents are sufficient for the longest path
  ! through the atmosphere on which the radiative-transfer equation is
  ! integrated.  If they were allocated in One_Pointing with an extent
  ! appropriate to each path, much more time would be spent in the storage
  ! manager.

    use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test
    use Comp_Sps_Path_Sparse_m, only: Comp_Sps_Path_Sparse
    use Compute_GL_Grid_M, only: Compute_GL_Grid
    use Constants, only: Deg2Rad, Rad2Deg
    use Convolution_m, only: Convolution, Convolution_Setup
    use Dump_0, only: Dump
    use FilterShapes_M, only: DACSFilterShapes, FilterShapes
    use ForwardModelConfig, only: Beta_Group_T, Channels_T, &
      & ForwardModelConfig_T, LineCenter, LineWidth, LineWidth_TDep
    use ForwardModelIntermediate, only: ForwardModelStatus_T, B_Refraction
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Generate_QTM_m, only: QTM_Tree_t
    use Geolocation_0, only: H_V_Geod
    use Geometry, only: Get_R_EQ
    use Get_IEEE_NaN_m, only: Fill_IEEE_NaN
    use HessianModule_1, only: Hessian_T
    use HighOutput, only: HeadLine, OutputNamedValue
    use Intrinsic, only: L_A, L_Radiance, L_TScat, L_VMR
    use Load_SPS_Data_M, only: DestroyGrids_T, Dump, Grids_T
    use MatrixModule_1, only: Matrix_T
    use Metrics_3D_m, only: S_QTM_t
    use MLSKinds, only: R4, R8, RP, RV
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: Hunt, InterpolateValues, PureHunt
    use MLSSignals_M, only: AreSignalsSuperset, Dump, &
      & GetNameOfSignal, MatchSignal, &
      & Radiometers, Signal_T
    use MLSStringLists, only: SwitchDetail
    use Molecules, only: L_H2O, L_N2O, L_O3
    use MoreMessage, only: MLSMessage
    use Output_M, only: NewLine, Output
    use Path_Contrib_M, only: Get_GL_Inds
    use Path_Representation_m, only: Facets_and_Vertices_t, Path_t
    use Physics, only: SpeedOfLight
    use PointingGrid_M, only: PointingGrids, PointingGrid_T, &
      & Dump_Pointing_Grid
    use Radius_of_Curvature_m, only: Radius_of_Curvature_Normal
    use Read_Mie_m, only: IWC_S, T_S
    use Slabs_sw_m, only: AllocateSLABS, DestroyCompleteSLABS, SLABS_Struct
    use Sparse_Eta_m, only: Sparse_Eta_t
    use Sparse_m, only: Sparse_t
    use Tau_m, only: Destroy_Tau, Dump, Tau_t
    use Toggles, only: Emit, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End
    use TScat_Support_M, only: Print_TScat_Deriv, Print_TScat_Detail, &
      & TScat_Detail_Heading, TScat_Gen_Setup
    use Two_D_Hydrostatic_M, only: Two_D_Hydrostatic
    use VectorsModule, only: CloneVectorQuantity, DestroyVectorQuantityValue, &
      & GetVectorQuantityByType, Vector_T, VectorValue_T

    type(forwardModelConfig_T), intent(inout) :: FwdModelConf
    type(vector_T), intent(in) :: FwdModelIn, FwdModelExtra
    type(vector_T), intent(inout) :: FwdModelOut  ! Radiances, etc.
    type(forwardModelStatus_t), intent(inout) :: FmStat ! Reverse comm. stuff
    real(rp), intent(in) :: Z_PSIG(:)       ! Surfs from Temperature, tangent
                                            ! grid and species grids, sans
                                            ! duplicates.
    real(rp), intent(in) :: Tan_Press(:)    ! Pressures corresponding to Z_PSIG
    type (Grids_T), intent(inout) :: Grids_tmp ! All the coordinates for TEMP,
                                            ! inout for cloud model to change
                                            ! supersat
    type (Grids_T), intent(inout) :: Grids_f   ! All the coordinates for VMR,
                                            ! inout for cloud model to change
                                            ! supersat
    type (Grids_T), intent(in) :: Grids_IWC ! All the coordinates for IWC
    type (Grids_T), intent(in) :: Grids_Mag ! All the coordinates for Magnetic field
    type (Grids_T), intent(in) :: Grids_n   ! All the spectroscopy(N) coordinates
    type (Grids_T), intent(in) :: Grids_v   ! All the spectroscopy(V) coordinates
    type (Grids_T), intent(in) :: Grids_w   ! All the spectroscopy(W) coordinates
    type (VectorValue_T), pointer :: PhiTan ! Tangent geodAngle component of
                                            ! state vector (minor frame quantity)
    type (VectorValue_T), intent(in) :: PTan ! Tangent pressure component of
                                            ! state vector (minor frame quantity)
    type (VectorValue_T), intent(in) :: Temp ! Temperature component of state vector
    type (Path_t), allocatable :: Q_LOS(:)  ! Minor-frame lines of sight for QTM
    type (Path_t), intent(inout) :: QTM_Paths(:) ! LOS through QTM
    type (VectorValue_T), intent(in), pointer :: ScECR_MIF ! Instrument
                                            ! position in ECR (MIF quantity)
    type (Facets_and_Vertices_t), intent(in) :: F_and_V(:) ! of QTM under paths
                                            ! used to integrate the radiative-transfer
                                            ! equation
    type (Facets_and_Vertices_t), intent(in), allocatable :: F_and_V_MIF(:) ! of
                                            ! QTM under MIF paths.  Used for
                                            ! hydrostatic equilibrium
                                            ! calculation that is used to
                                            ! calculate MIF-based Chi angles.
    type(QTM_tree_t) :: QTM ! for QTM case; only
    integer, intent(in) :: No_Mol           ! Number of molecules
    integer, intent(in) :: NoUsedChannels   ! Number of channels used
    integer, intent(in) :: No_sv_p_T        ! number of phi basis for temperature
    integer, intent(in) :: N_T_zeta         ! Number of zetas for temperature
    integer, intent(in) :: Sv_T_len         ! Number of t_phi*t_zeta in the window
    integer, intent(in) :: Nlvl             ! Number of levels in coarse zeta grid
    integer, intent(in) :: No_Tan_Hts       ! Number of tangent heights
    integer, intent(in) :: SurfaceTangentIndex ! Index in tangent grid of
                                            ! earth's surface
    integer, intent(in) :: Max_C            ! Length of longest possible coarse path
    integer, intent(in) :: MaxVert          ! Number of points in gl-refined vertical grid:
                                            ! (NLVL-1) * (NG+1) + 1, i.e., 1 + NG
                                            ! per level, except the last,
                                            ! where there's no GL space.
    integer, intent(in) :: Max_F            ! Length of longest possible path (all npf<max_f)
    logical, intent(in) :: PTan_Der
    integer, intent(in) :: S_A  ! Multiplier for atmos derivative sizes, 0 or 1
    integer, intent(in) :: S_H  ! Multiplier for atmos second derivative sizes, 0 or 1
    integer, intent(in) :: S_I  ! Multiplier for ice/cloud sizes, 0 or 1
    integer, intent(in) :: S_LC ! Multiplier for line center deriv sizes, 0 or 1
    integer, intent(in) :: S_LW ! Multiplier for line width deriv sizes, 0 or 1
    integer, intent(in) :: S_P  ! Multiplier for polarized sizes, 0 or 1
    integer, intent(in) :: S_PFA ! Multiplier for PFA sizes, 0 or 1
    integer, intent(in) :: S_QTM ! Multiplier for sizes of QTM-related stuff, 0 or 1
    integer, intent(in) :: S_T  ! Multiplier for temp derivative sizes, 0 or 1
    integer, intent(in) :: S_TD ! Multiplier for temp dependence deriv sizes, 0 or 1
    integer, intent(in) :: S_TG ! Multiplier for TScat generation sizes, 0 or 1
    integer, intent(in) :: S_TS ! Multiplier for using TScat tables, 0 or 1

    type(matrix_T),  intent(inout), optional :: Jacobian
    type(matrix_T),  intent(inout), optional :: ExtraJacobian ! This is used
                                ! if a quantity with respect to which we are
                                ! computing derivatives is found in the extra
                                ! vector.  Usually, this means we are retrieving
                                ! a MIF quantity, with profile derivatives
                                ! computed here.
    type(hessian_T), intent(inout), optional :: Hessian

    ! Now define local variables, group by type and then
    ! Alphabetically

    integer :: Channel            ! A Loop counter
    integer :: Dump_Rad_Pol       ! Dump intermediate values in Rad_Tran_Pol
    integer :: Frq_Avg_Sel        ! Summarizes combinations of PFA, LBL,
                                  ! Frequency averaging and derivatives.
                                  ! See Frequency_Average below.
    integer :: H2O_Ind            ! Grids_f%S_Ind(L_H2O) = index of H2O in Grids_f
    integer :: IER                ! Status flag from allocates
    integer :: I                  ! Loop index and other uses.
    integer :: Inst               ! Instance of temperature nearest to MAF
    integer :: J                  ! Loop index and other uses.
    integer :: K                  ! Loop index and other uses.
    integer :: MAF                ! MAF under consideration
    integer :: Me = -1            ! String index for trace
    integer :: Me_Hydro = -1      ! String index for trace
    integer :: Me_PointingLoop = -1 ! String index for trace
    integer :: Me_Sideband = -1   ! String index for trace
    integer :: Me_SidebandLoop = -1 ! String index for trace
    integer :: MIF                ! MIF number for tan_press(ptg_i) and rotation
                                  ! matrix from ECR to IFOVPP (R1A) for magnetic
                                  ! field
    integer :: N_More             ! Effective size of More_*_Path
    integer :: N_Phi              ! Number of phi values for one species
    integer :: NGLMax             ! NGL if all panels need GL
    integer :: NoFreqs            ! Number of frequencies for a pointing
    integer :: NoUsedDACS         ! Number of different DACS in this run.
    integer :: NPC                ! Length of coarse path
    integer :: NPF                ! Length of a combined coarse & fine path
    integer :: NZ_IF              ! Effective size of Z_GLgrid and cohorts
    integer :: NZ_IG              ! Effective size of Zetas, size(z_psig) <=
                                  ! nz_ig <= size(z_psig)+2
    integer :: Prev_Mie_Frq_Ind   ! From a previous execution of One_Frequency
    integer :: PTG_I              ! Loop counter for the pointings
    integer :: Sideband           ! Either zero or from firstSignal
    integer :: SX                 ! 1 = LSB, 2 = USB
    integer :: Tan_Ind_C          ! Index of tangent point in coarse zeta ref grid
    integer :: Tan_Ind_F          ! Index of tangent point in fine zeta ref grid
    integer :: Tan_Pt_C           ! Index of tangent point in coarse path
    integer :: Tan_Pt_F           ! Index of tangent point in fine path
    integer :: ThisSideband       ! Loop counter for sidebands, -1 = LSB, +1 = USB
    integer :: WindowFinish       ! End of temperature `window'
    integer :: WindowStart        ! Start of temperature `window'

    integer :: Nspec              ! No of species for cloud model

    logical :: Any_Der            ! temp_der .or. atmos_der .or. spect_der
    ! logical :: Clean              ! Used for dumping
    character(len=4) :: Clean     ! Used for dumping
    logical :: Do_More_Points     ! Do intersections of path at zetas < zeta(tan)
    logical :: Do_Zmin            ! "Do minimum Zeta calculation"
    logical :: Dump_Tscat         ! For debugging, from -Sdsct
    logical, parameter :: PFAFalse = .false.
    logical, parameter :: PFATrue = .true.
    logical :: Print_Frq          ! For debugging, from -Sffrq
    integer :: Print_Deltau_Pol   ! For debugging, from -Sdeltaupol
    logical :: Print_Incopt       ! For debugging, from -Sincp
    logical :: Print_IncRad       ! For debugging, from -Sincr
    integer :: Print_Mag          ! For debugging, from -Smag#
    logical :: Print_More_Points  ! Print if Do_More_Points finds more, from -SZMOR
    integer :: Print_Path         ! Nicer format than Print_Incopt, for few molecules
    integer :: Print_Pol_Rad      ! For debugging, from -Spolr[n]
                                  ! n>0 => print pointing number
                                  ! n>1 => print frequency
    integer :: Print_Rad          ! For debugging, from -Srad
    logical :: Print_Seez         ! For debugging, from -Sseez
    logical :: Print_TauL         ! For debugging, from -Staul
    logical :: Print_TauP         ! For debugging, from -Staup
    logical :: Print_TScat        ! For debugging, from -STScat

    logical :: UsingQTM

    logical :: temp_der, atmos_der, spect_der ! Flags for various derivatives
    logical :: atmos_second_der   ! Flag for atmos second derivatives
    logical :: Spect_Der_Center, Spect_Der_Width, Spect_Der_Width_TDep

    character (len=127) :: SigName      ! Name of a Signal

    integer, target :: C_Inds_B(max_c)  ! Base array for C_INDS
    integer, target :: CG_Inds_B(max_c) ! Base array for CG_INDS
    integer :: F_Inds(max_c*ng)         ! Indices of fine grid within combined
                                        ! coarse & fine path.
    integer, target :: GL_Inds_B(max_c*ng) ! Base array for GL_INDS
    integer :: Grids(no_tan_hts)        ! Indices in ptgGrid for each tangent
    integer :: IPSD(s_i*max_f)
    integer :: Vert_Inds(max_f)         ! Height indices of fine path in
                                        ! H_Glgrid etc.
    integer :: Where_GL(max_c)          ! If K = Where_GL(i) /= 0 it indicates
                                        ! GL_Inds(k:k+ng-1) are GL_Inds
                                        ! for panel(i:i+1) in the coarse
                                        ! path.

    real(r8) :: WC(s_i*fwdModelConf%no_cloud_species, max_f)
    real(r8) :: Scat_ang(s_i*fwdModelConf%num_scattering_angles)

    real(rp), target :: Alpha_Path(max_f) ! Absorption coefficients on composite
                                      ! coarse & fine path
    real(rp), pointer :: Alpha_Path_C(:)  ! coarse grid part of Alpha_Path
    real(rp) :: Alpha_Path_F(max_c*ng)    ! absorption coefficients for GL
    real(rp) :: B(max_c)              ! Planck radiation function
    real(rp) :: Beta_Path_Cloud_c(s_i*max_c) ! Beta on path coarse
    real(rp) :: Beta_c_e_Path_c(s_ts*max_c)  ! Beta_c_e on coarse path
    real(rp) :: Beta_c_s_Path_c(s_ts*max_c)  ! Beta_c_s on coarse path
    real(r8), target :: ChannelCenters(noUsedChannels) ! for PFA or non-frequency-averaging
    real(rp) :: DAlpha_DT_Path(max_f)   ! dAlpha/dT on coarse & fine grid
    real(rp) :: DAlpha_DT_Path_F(max_f) ! dAlpha/dT on fine grid
    real(rp) :: Del_S(max_c)          ! Integration lengths along coarse path,
                                      !  (2:npc-1).  Before the tangent point,
                                      !  Del_s(i) is the path length [i-1:i].
                                      !  After the tangent point, Del_s(i) is
                                      !  the path length [i:i+1].  Thereby,
                                      !  IncOptDepth(i) is \int_{i-1}^i Alpha
                                      !  before the tangent point, and
                                      !  \int_i^{i+1} Alpha after the tangent
                                      !  point.
    real(rp) :: Del_Zeta(max_c)       ! Integration lengths in Zeta coords
                                      !  along coarse path, (2:npc-1).  Same
                                      !  indexing as for Del_S.
    real(rp) :: dBeta_c_a_dIWC_Path_C(s_ts*max_c)  ! on coarse path
    real(rp) :: dBeta_c_s_dIWC_Path_C(s_ts*max_c)  ! on coarse path
    real(rp) :: dBeta_c_a_dT_Path_C(s_ts*max_c)    ! on coarse path
    real(rp) :: dBeta_c_s_dT_Path_C(s_ts*max_c)    ! on coarse path
    real(rp) :: DHDZ_Path(max_f)      ! dH/dZ on fine path (1:npf)
    real(rp) :: DHDZ_GW_Path(max_f)   ! dH/dZ * GW on fine path (1:npf)
    real(rp) :: DSDH_Path(max_f)      ! dS/dH on fine path (1:tan_pt_f-1,tan_pt_f+ngp1+1:npf)
    real(rp) :: DSDZ_C(merge(max_c,0,WrongTrapezoidal)) ! ds/dH * dH/dZ on coarse path (1:tan_pt_c-1,tan_pt_c+2:npc)
    real(rp) :: DSDZ_GW_Path(max_f)   ! ds/dH * dH/dZ * GW on path
    real(rp) :: DTanh_DT_C(max_c)     ! 1/tanh1_c d/dT tanh1_c
    real(rp) :: DTanh_DT_F(max_f)     ! 1/tanh1_f d/dT tanh1_f
    real(rp) :: dTScat_df(s_ts*max_c,size(grids_f%values))   ! on coarse path w.r.t. SVE
    real(rp) :: dTScat_dT(s_ts*max_c,sv_t_len) ! on coarse path w.r.t. SVE
    real(rp) :: H_Path(max_f)         ! Heights on path (km)
    real(rp) :: H_Path_C(max_c)       ! H_Path on coarse grid (km)
    real(rp) :: IncOptDepth(max_c)    ! Incremental Optical depth on coarse grid
    real(rp) :: More_H_Path(max_new), More_Phi_Path(max_new), More_Z_Path(max_new)
    real(rp) :: N_Path_C(max_c)       ! Refractive index - 1 on coarse path
    real(rp) :: N_Path_F(max_f)       ! Refractive index - 1 on fine path
    real(rp) :: N_Path_Inst           ! Refractive index - 1 at the instrument,
                                      ! 0.0 for satellite, n_path_c(1) for QTM
    real(rp), target :: Phi_Path(max_f) ! Phi's on fine path, Radians
    real(rp), pointer :: Phi_Path_c(:)  ! Phi on the coarse path
    real(rp) :: P_Path(max_f)         ! Pressure on path
    real(rp) :: Ptg_Angles(no_tan_hts)
    real(rp) :: Ref_Corr(max_c)       ! Refraction correction
    real(rp) :: Tan_dH_dT(s_t*sv_t_len) ! dH/dT at Tangent, used for convolution
    real(rp) :: Tanh1_C(max_c)        ! tanh(0.5 h nu / k T)
    real(rp) :: Tanh1_F(max_f)        ! tanh1 on fine grid
    real(rp) :: T_Path(max_f)         ! Temperatures on entire path
    real(rp) :: T_Path_c(max_c)       ! T_Path on coarse grid
    real(rp) :: T_Path_f(max_f)       ! T_Path on GL points
    real(rp) :: TT_Path_c(max(s_i,s_ts)*max_c)  ! TScat on path coarse
    real(rp) :: W0_Path_c(max(s_i,s_ts)*max_c)  ! w0 on path coarse
    real(rp) :: Z_Coarse(max_c)       ! Z_PSIG & Z_min & surface zeta on path
    real(rp) :: Z_GLGrid(maxvert)     ! Zeta on initial glGrid surfs
    real(rp) :: Z_Path(max_f)         ! Zeta on fine grid path tangent grid and
                                      ! species grids, sans duplicates.
    real(rp) :: Beta_Path_C(max_c,no_mol)    ! on coarse path
    real(rp) :: Beta_Path_F(max_c*ng,no_mol) ! for GL points of path only
    real(rp) :: d2_Delta_dF2(max_c,size(grids_f%values),s_h*size(grids_f%values))
                                      ! Incremental opacity second derivative.
                                      ! Path x SVE x SVE.
    real(rp) :: d_T_SCR_dT(max_c,s_t*sv_t_len)     ! D Delta_B in some notes
                                      ! coarse path x state-vector-components
    real(rp) :: d2X_dXdT(no_tan_hts,s_t*sv_t_len)    ! (No_tan_hts, nz*np)
    real(rp), target :: dAlpha_dF_Path(max_f,s_a*no_mol) ! on composite coarse &
                                                     ! fine path
    real(rp), pointer :: dAlpha_DF_Path_C(:,:)       ! on coarse path
    real(rp) :: dAlpha_dF_Path_F(max_f,s_a*no_mol)   ! GL points only
    real(rp) :: d2Alpha_dF2_Path_C(max_c,s_h*no_mol) ! on coarse path
    real(rp) :: d2Alpha_dF2_Path_F(max_f,s_h*no_mol) ! on GL path
    real(rp) :: dB_dF(s_ts*max(s_a,s_t)*max_c)       ! dB / d one f on the path, for TScat
    real(rp) :: dBeta_dF_Path_c(max_c,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: dBeta_dF_Path_f(max_f,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: dBeta_dIWC_Path_c(max_c,s_tg*no_mol) ! dBeta_dIWC on coarse grid
    real(rp) :: dBeta_dIWC_Path_f(max_f,s_tg*no_mol) ! dBeta_dIWC on fine grid
    real(rp) :: dBeta_dN_Path_c(max_c,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on coarse grid
    real(rp) :: dBeta_dN_Path_f(max_f,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on fine grid
    real(rp) :: dBeta_dT_Path_c(max_c,s_t*no_mol)  ! dBeta_dT on coarse grid
    real(rp) :: dBeta_dT_Path_f(max_f,s_t*no_mol)  ! dBeta_dT on fine grid
    real(rp) :: dBeta_dV_Path_c(max_c,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on coarse grid
    real(rp) :: dBeta_dV_Path_f(max_f,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on fine grid
    real(rp) :: dBeta_dW_Path_c(max_c,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on coarse grid
    real(rp) :: dBeta_dW_Path_f(max_f,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on fine grid
    type(sparse_t) :: dH_dT_Path               ! dH/dT on path X (Zeta * Phi)
    real(rp) :: dHdZ_GLGrid(maxVert,no_sv_p_T) ! dH/dZ on glGrid surfs
    real(rp) :: dX_dT(no_tan_hts,s_t*sv_t_len) ! (No_tan_hts, nz*np)
    type (Sparse_Eta_t) :: Eta_ZP_N(size(grids_n%values)) ! Eta_z x Eta_p for N
    type (Sparse_Eta_t) :: Eta_ZP_V(size(grids_v%values)) ! Eta_z x Eta_p for V
    type (Sparse_Eta_t) :: Eta_ZP_W(size(grids_w%values)) ! Eta_z x Eta_p for W
    real(rp) :: H_GLGrid(maxVert,no_sv_p_T)    ! H on glGrid surfs (km)
    real(rp) :: IWC_Path(max_f,max(max(s_i,s_ts),s_ts)) ! IWC on path
    real(rp), target :: Mag_Path(s_p*max_f,4)  ! Magnetic field on path
    real(rp), target :: Rad_Avg_Path(max_c,s_pfa*noUsedChannels) ! Freq. Avgd.
                                               ! LBL radiance along the path
    real(rp) :: R_Eq  ! Radius of equivalent circular Earth tangent to the
                      ! surface of the Earth reference ellipsoid at the surface
                      ! location of the tangent point, in the plane defined by
                      ! the line of sight and the center of the Earth.
    real(rp) :: Radiances(noUsedChannels,no_tan_hts) ! (noChans,Nptg)
!     real(rp) :: RADIANCES_DIFF(noUsedChannels,no_tan_hts) ! (noChans,Nptg)     ! IGOR
    real(rp) :: Spect_N_Path(max_f,size(fwdModelConf%lineWidth_TDep)) ! Line Width Temperature Dependence
    real(rp) :: Spect_V_Path(max_f,size(fwdModelConf%lineCenter)) ! Line Center
    real(rp) :: Spect_W_Path(max_f,size(fwdModelConf%lineWidth)) ! Line Width
    real(rp) :: SPS_Path(max_f,no_mol)         ! species on path
    real(rp) :: SPS_Path_C(max_c,no_mol)       ! species on coarse path
    real(rp) :: SPS_Path_F(max_f,no_mol)       ! species on GL path
    real(rp) :: TT_Path_F(max_f,max(s_i,s_ts)) ! TScat on entire path
    real(rp) :: T_GLGrid(maxVert,no_sv_p_T)    ! Temp on glGrid surfs
    real(rp) :: T_Script_PFA(max_c,s_pfa*noUsedChannels) ! Delta_B in some notes
    real(r8) :: VMRArray(s_i*n_t_zeta,no_mol)  ! The VMRs for H2O, O3, N2

    ! Temporary space for DACS radiances if we're doing frequency averaging
    ! and there are any LBL molecules and any derivatives are calculated
    real(rp) :: DACsStaging2(lbound(fwdModelConf%DACsStaging,1): &
      &                      ubound(fwdModelConf%DACsStaging,1), &
      & merge(1,0,fwdModelConf%do_freq_avg .and. &
      &           any(fwdModelConf%anyLBL((fwdModelConf%sidebandStart+3)/2:    &
      &                                   (fwdModelConf%sidebandStop+3)/2))) * &
      &   max(s_t,s_a,s_lc,s_lw,s_td) *      & ! merge(1,0,any_der)
      &   max(sv_t_len,size(grids_f%values), &
      &       size(grids_w%values), size(grids_n%values), size(grids_v%values)), &
      & size(fwdModelConf%usedDACSSignals) )

    real(rp) :: DACsStaging3( lbound(DACsStaging2,1):ubound(DACsStaging2,1), &
                            & lbound(DACsStaging2,2):ubound(DACsStaging2,2), &
                            & lbound(DACsStaging2,2):ubound(DACsStaging2,2), &
                            & size(fwdModelConf%usedDACSSignals)                )

    real(rp), target :: DH_DT_GLGrid(maxVert,n_t_zeta,s_t*no_sv_p_T)

    complex(rp) :: D_Rad_Pol_dF(2,2,s_p*s_a*size(grids_f%values)) ! From mcrt_der
    complex(rp) :: D_Rad_Pol_dT(2,2,s_p*s_t*sv_t_len) ! From mcrt_der
    complex(rp), target :: Alpha_Path_Polarized(-1:1,s_p*max_f)
    complex(rp), pointer :: Alpha_Path_Polarized_C(:,:)
    complex(rp) :: Alpha_Path_Polarized_F(-1:1,s_p*max_f)
    complex(rp), target :: dAlpha_dT_Polarized_Path(-1:1,s_p*s_t*max_f)
    complex(rp), pointer :: dAlpha_dT_Polarized_Path_C(:,:)
    complex(rp) :: dAlpha_dT_Polarized_Path_F(-1:1,s_p*s_t*max_f)
    complex(rp) :: Beta_Path_Polarized(-1:1,s_p*max_c,no_mol)
    complex(rp) :: Beta_Path_Polarized_F(-1:1,s_p*max_f,no_mol)
    complex(rp) :: dBeta_dT_Polarized_Path_C(-1:1,s_p*s_t*max_c,no_mol)
    complex(rp) :: dBeta_dT_Polarized_Path_F(-1:1,s_p*s_t*2*max_f,no_mol)
    complex(rp) :: DE_DF(2,2,s_p*s_a*max_c,size(grids_f%values)) ! DE/Df in Michael's notes
    complex(rp) :: DE_DT(2,2,s_p*s_t*max_c,sv_t_len) ! DE/DT in Michael's notes
    complex(rp) :: DelTau_Pol(2,2,s_p*max_c) ! E in Michael's notes
!   complex(rp) :: dIncOptDepth_Pol_dT(2,2,s_p*s_t*max_c) ! D Incoptdepth_Pol / DT
!   complex(rp) :: GL_Delta_Polarized(-1:1,s_p*max_f)
    complex(rp) :: IncOptDepth_Pol(2,2,s_p*max_c)
    complex(rp) :: Prod_Pol(2,2,s_p*max_c) ! P in Michael's notes
    complex(rp) :: Tau_Pol(2,2,s_p*max_c)  ! Tau in Michael's notes

    real(rp) :: Est_ScGeocAlt(no_tan_hts)  ! Est S/C geocentric altitude /m
    real(rp) :: Est_LOS_Vel(no_tan_hts)    ! Est S/C line-of-sight velocity M/S
    real(rp) :: Tan_D2H_DHDT(s_t*sv_t_len) ! for convolution
    real(rp) :: Tan_Phi(no_tan_hts)        ! Radians
    real(rp) :: DDHIDHIDTL0(maxVert,n_t_zeta,s_t*no_sv_p_T)
    ! Frequency-averaged derivatives
    ! Channels x pointings x grid values == frequencies x surfaces x instances x molecules:
    real(r4) :: K_Atmos(noUsedChannels,no_tan_hts,s_a*size(grids_f%values))
    real(r4) :: H_Atmos(noUsedChannels,no_tan_hts,s_h*size(grids_f%values),s_h*size(grids_f%values))
    ! Channels x pointings x grid values == frequencies x surfaces x instances x molecules:
    real(r4) :: K_Spect_DN(noUsedChannels,no_tan_hts,s_td*size(grids_n%values))
    real(r4) :: K_Spect_DV(noUsedChannels,no_tan_hts,s_lc*size(grids_v%values))
    real(r4) :: K_Spect_DW(noUsedChannels,no_tan_hts,s_lw*size(grids_w%values))
    real(r4) :: K_Temp(noUsedChannels,no_tan_hts,s_t*sv_t_len)

    logical :: Do_GL(max_c)       ! GL indicator.  Before the tangent point,
                                  ! Do_GL(i) means the panel (i-1:i) on the
                                  ! coarse path needs GL.  After the tangent
                                  ! point, Do_GL(i) means panel(i:i+1) needs GL.
    logical :: T_der_Path_flags(s_t*max_f) ! a flag that tells where an
      ! absorption coefficient is needed for a temperature derivative.
      ! Only useful when subsetting temperature derivatives.

    integer, pointer :: C_Inds(:)        ! Indices of coarse grid in combined
                                         ! coarse & fine path
    integer, pointer :: LineCenter_IX(:) ! Where are line center offsets?
    integer, pointer :: LineWidth_IX(:)  ! Where are line width offsets?
    integer, pointer :: LineWidth_TDep_IX(:)  ! Where are line width TDep offsets?
    integer, pointer :: UsedDACSsignals(:) ! Indices in FwdModelConf of signals
                                         ! for our dacs

    real(rp) :: E_Rflty       ! Earth reflectivity at given tan. point
    real(rp) :: H_Surf        ! Height above earth surface of first (usually
                              ! zeta=-3) surface
    real(rp) :: Min_Zeta      ! Minimum zeta along the path
    real(rp) :: Min_Phi       ! Phi at which minimum zeta occurs
    real(rp) :: ROT(3,3)      ! ECR-to-FOV rotation matrix
    real(rp) :: Vel_Rel       ! Vel_z / c

    real(rp), pointer :: CT(:)           ! Cos(Theta), where theta
      ! is the angle between the line of sight and magnetic field vectors.
    real(r8), pointer :: Frequencies(:)  ! Frequencies to compute for
    real(rp), pointer :: H(:)            ! Magnetic field on path, in
                                         ! IFOVPP
    real(rp), allocatable :: RadV(:)     ! Radiances for 1 pointing on
                                         ! Freq_Grid
    real(rp), pointer :: STCP(:)         ! Sin(Theta) Cos(Phi) where
      ! theta is as for CT and phi (for this purpose only) is the angle
      ! between the plane defined by the line of sight and the magnetic
      ! field vector, and the "instrument field of view plane polarized"
      ! (IFOVPP) X axis.
    real(rp), pointer :: STSP(:)         ! Sin(Theta) Sin(Phi)
    real(rp), pointer :: DACsStaging(:,:) ! Temporary space for DACS radiances

    ! Cloud arrays have the same grids as temperature
    real(rp) :: Cext_Path(max_f,s_i)    ! Cloud extinction on path
    real(rp) :: Salb_Path(max_f,s_i)    ! Single Scattering Albedo on path
    real(rp) :: Tscat_Path(max_f,s_i*fwdModelConf%num_scattering_angles) ! TScat on path

    ! Beta on path coarse, which is needed to compute d_W0/dVMR
    real(rp), allocatable :: Inc_Rad_Path(:,:)   ! Incremental radiance along the path
    real(rp), allocatable :: K_Atmos_Frq(:,:)    ! dI/dVMR, ptg.frq X vmr-SV
    real(rp), allocatable :: K_Spect_DN_Frq(:,:) ! ****
    real(rp), allocatable :: K_Spect_DV_Frq(:,:) ! ****
    real(rp), allocatable :: K_Spect_DW_Frq(:,:) ! ****
    real(rp), allocatable :: K_Temp_Frq(:,:)     ! dI/dT, ptg.frq X T-SV
    real(rp), allocatable :: T_Script_LBL(:,:)   ! Delta_B in some notes, Path X Frq
    real(rp), allocatable :: H_Atmos_Frq(:,:,:)  ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr

    ! Used only to schlep from Convolution_Setup to Convolution
    real(rp) :: Chi_MIF_Tan(ptan%template%nosurfs) ! Chi angle to MIF tangent
    real(rp) :: DH_DZ_OUT(ptan%template%nosurfs)
    real(rp) :: DX_DH_OUT(ptan%template%nosurfs)
    real(rp) :: DXDT_Surface(1,s_t*sv_t_len)
    real(rp) :: DXDT_TAN(ptan%template%nosurfs,s_t*sv_t_len)
    real(rv), pointer :: L1BMIF_TAI(:,:)   ! MIF Times
    real(rv), pointer :: MIFDeadTime(:,:)  ! Not collecting data
    real(rp) :: Surf_Angle(1)

!  The 'all_radiometers grid file' approach variables declaration:

    real(rp) :: Max_ch_freq_grid, Min_ch_freq_grid

! *** Beta & Molecules grouping variables:
    type (Beta_Group_T), pointer :: Beta_Group(:) ! from FwdModelConf%Beta_Group

    ! Tangent point coordinates on GL zeta grid.  Used only for QTM.
    type (H_V_Geod) :: Tan_Pt_Geod(max_f)

    ! Interpolation factors for Temperature, IWC, and Temperature X IWC (not
    ! geometric interpolation factors) to put Mie Beta_c_a and Beta_c_s into
    ! path
    type (Sparse_Eta_t) :: Eta_IWC_Path_c, Eta_T_IWC_Path_c, Eta_T_Path_c

! Channel information from the signals database as specified by fwdModelConf
    type (Channels_T), pointer, dimension(:) :: Channels

    type (Grids_T) :: Grids_Tscat ! All the coordinates for scattering source function
    type (Grids_T) :: Grids_Salb  ! All the coordinates for single scattering albedo
    type (Grids_T) :: Grids_Cext  ! All the coordinates for cloud extinction

    type (PointingGrid_T), pointer :: WhichPointingGrid ! Pointing grids for one signal

    type (Signal_T), pointer :: FirstSignal        ! The first signal we're dealing with

    type (Slabs_Struct), allocatable :: GL_SLABS(:,:) ! Freq. independent single-
                                  ! line absorption data for the combined coarse
                                  ! & fine path; subsets selected by or c_inds
                                  ! or GL_inds.
    type (S_QTM_t), allocatable :: S(:)

    type (Tau_T) :: Tau_LBL, Tau_PFA

    ! Mixing-ratio derivatives of incremental opacity, to schlep from
    ! dRad_tran_df to Get_d_Deltau_Pol_df
    type (sparse_t) :: d_delta_df(s_p*size(fwdModelConf%beta_group))
    ! Interpolation coefficients from Freq X Zeta X Horizontal (phi or QTM)
    ! basis to path for all species
    type (Sparse_Eta_t) :: Eta_fzp(size(fwdModelConf%beta_group))
    ! Interpolation from horizontal (phi or QTM) basis to path for each VMR.
    type (Sparse_Eta_t) :: Eta_p(size(fwdModelConf%beta_group))
    ! Interpolation coefficients from horizontal (phi or QTM) basis to path
    ! for temperature
    type (Sparse_Eta_t) :: Eta_p_T
    ! Interpolation coefficients from zeta X horizontal (phi or QTM) basis to
    ! path for temperature; only needed for temperature derivatives
    type (Sparse_Eta_t) :: Eta_zp_T
    ! Interpolation coefficients from zeta X phi basis to path for all species
    type (Sparse_Eta_t) :: Eta_zp(size(fwdModelConf%beta_group))
    ! Interpolation coefficients from zeta for each VMR to path GL zeta.
    type (Sparse_Eta_t) :: Eta_z(size(fwdModelConf%beta_group))
    type (Sparse_Eta_t) :: Eta_zzT ! Interpolation coefficients from
                                   ! temperature Zeta to GL zeta.
    type (VectorValue_T), pointer :: BoundaryPressure
    type (VectorValue_T), pointer :: EarthRefl     ! Earth reflectivity
    type (VectorValue_T), pointer :: ECRtoFOV      ! Rotation matrices
    type (VectorValue_T), pointer :: F             ! An arbitrary species
    type (VectorValue_T), pointer :: GPH           ! Geopotential height
    type (VectorValue_T), pointer :: IWC           ! IWC at scattering points, for TScat gen.
    type (VectorValue_T), pointer :: LOSVel        ! Line of sight velocity m/s
    type (VectorValue_T), pointer :: OrbIncline    ! Orbital inclination
    type (VectorValue_T), pointer :: RefGPH        ! Reference geopotential height
    type (VectorValue_T), pointer :: ScatteringAngles ! for TScat computation
    type (VectorValue_T), pointer :: SCGeocAlt     ! S/C geocentric altitude /m
    type (VectorValue_T), pointer :: SpaceRadiance ! Emission from space
    type (VectorValue_T), pointer :: SurfaceHeight ! km above mean sea level
    type (VectorValue_T), pointer :: ThisRadiance  ! A radiance vector quantity

    ! Intermediate minor-frame tangent quantities calculated from LOS, for QTM
    type (VectorValue_T) :: Q_EarthRadC_sq
    type (VectorValue_T), target :: Q_PhiTan
    type (VectorValue_T) :: Q_TanHt

    ! Coarse-zeta grid tangent quantities interpolated from intermediate
    ! minor-frame tangent quantities calculated from LOS, for QTM.
    real(rp) :: EarthRadC_sq(no_tan_hts) ! Square of minor axis of plane-projected
                                         ! ellipse, meters^2
    real(rp) :: TanHt(no_tan_hts)        ! Tangent heights, meters

! Scattering source function for each temperature surface
    type (VectorValue_T) :: scat_src
    type (VectorValue_T) :: scat_alb
    type (VectorValue_T) :: cld_ext

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!                                                          !!!!!
    !!!!! If an array has an extent of No_SV_P_T or SV_T_Len, in   !!!!!
    !!!!! the QTM case it needs to be subscripted using the index  !!!!!
    !!!!! of a vertex adjacent to the path, in the extracted       !!!!!
    !!!!! subset of the entire state vector.  The mapping from QTM !!!!!
    !!!!! indices to path-adjacent indices is QTM%Path_Vertices(). !!!!!
    !!!!! The inverse mapping, to put derivatives into the correct !!!!!
    !!!!! places in the Jacobian, is F_and_V%Vertices.             !!!!!
    !!!!!                                                          !!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ! Executable code --------------------------------------------------------
    ! ------------------------------------------------------------------------

    call trace_begin ( me, 'FullForwardModelAuto, MAF=', index=fmstat%maf, &
      & cond=toggle(emit) )

    alpha_path_polarized_c(-1:,1:) => alpha_path_polarized ( -1:1, 1 :: ngp1 )
    dAlpha_dT_polarized_path_c(-1:,1:) => dAlpha_dT_polarized_path ( -1:1, 1 :: ngp1 )

    ! Get pointer to Alpha_Path_C, the coarse-path part of Alpha_Path
    alpha_path_c => alpha_path ( 1::ngp1 )

    ! Get pointer to dAlpha_df_Path_C, the coarse-path part of dAlpha_df_Path
    dAlpha_df_Path_C => dAlpha_df_Path(1::ngp1,:)

    ! Fill REAL local variables with NaN if requested
    if ( NaN_Fill ) then
      ! Scalar RP:
      call fill_IEEE_NaN ( e_rflty, h_surf, min_zeta, min_phi, vel_rel, &
        & max_ch_freq_grid, min_ch_freq_grid )
      ! Rank 1 RP:
      call fill_IEEE_NaN ( Alpha_path_c, Alpha_path_f, b, &
        & beta_path_cloud_c, beta_c_e_path_c, beta_c_s_path_c, &
        & dAlpha_dT_path_f, del_s, del_zeta, dBeta_c_a_dIWC_path_C, &
        & dBeta_c_s_dIWC_path_C, dBeta_c_a_dT_path_C, dBeta_c_s_dT_path_C, &
        & dhdz_path, dhdz_gw_path, dsdh_path, dsdz_c, dsdz_gw_path, dTanh_dT_c, &
        & dTanh_dT_f, h_path, h_path_c, n_path_f, phi_path, &
        & ptg_angles, ref_corr )
      call fill_IEEE_NaN ( tan_dh_dT, tanh1_c, tanh1_f, t_path, t_path_c, &
        & t_path_f, tt_path_c, w0_path_c, z_coarse, z_glgrid, z_path )
      call fill_IEEE_NaN ( earthradc_sq, est_scgeocalt, est_los_vel, &
        & tan_d2h_dhdT, tan_phi )
      call fill_IEEE_NaN ( dh_dz_out, dx_dh_out )
      call fill_IEEE_NaN ( chi_MIF_Tan, dB_df, surf_angle )
      ! Rank 1 R4:
      ! Rank 1 R8:
      call fill_IEEE_NaN ( Scat_ang, channelCenters )
      ! Rank 2 RP:
      call fill_IEEE_NaN ( dTScat_df, dTScat_dT, beta_path_f, &
        & d_t_scr_dT, d2x_dxdT, dAlpha_df_path, dAlpha_df_path_f, &
        & d2Alpha_df2_path_c, d2Alpha_df2_path_f, dBeta_df_path_c, &
        & dBeta_df_path_f, dBeta_dIWC_path_c, dBeta_dIWC_path_f, &
        & dBeta_dn_path_c, dBeta_dn_path_f, dBeta_dT_path_c, dBeta_dT_path_f, &
        & dBeta_dv_path_c, dBeta_dv_path_f, dBeta_dw_path_c, dBeta_dw_path_f )
      call fill_IEEE_NaN ( dhdz_glgrid, dx_dT, &
        & h_glgrid, IWC_path, mag_path, rad_avg_path, radiances, &
        & spect_n_path, spect_v_path, spect_w_path, sps_path, sps_path_c, &
        & sps_path_f )
      call fill_IEEE_NaN ( tt_path_f, t_glgrid, t_script_PFA, rot )
      call fill_IEEE_NaN (  cext_path, salb_path, TScat_path )
      call fill_IEEE_NaN ( dxdT_surface, dxdT_tan )
      ! Rank 2 R8:
      call fill_IEEE_NaN ( wc, vmrArray )
      ! Rank 3 RP:
      call fill_IEEE_NaN ( d2_delta_df2, DACsStaging2, dh_dT_glgrid, &
        & ddhidhidTl0 ) 
      ! Rank 3 R4:
      call fill_IEEE_NaN ( k_atmos, k_spect_dn, k_spect_dv, k_spect_dw, &
        & k_temp )
      ! Rank 3 R8:
      ! Rank 4 RP:
      call fill_IEEE_NaN ( DACsStaging3 )
      ! Rank 4 R4:
      call fill_IEEE_NaN ( h_atmos )
      ! Rank 4 R8:
    end if
    ! Set flags from command-line switches
    clean = ' '
    if ( switchDetail(switches, 'clean') > -1 ) clean = 'c'
    do_zmin = switchDetail(switches, 'dozm') > -1 ! Do minimum zeta only if requested
    dump_rad_pol = 0 ! Dump rad_tran_pol intermediates
    if ( switchDetail(switches, 'dpri') > -1 ) dump_rad_pol = 1 ! Dump if overflow
    if ( switchDetail(switches, 'Dpri') > -1 ) dump_rad_pol = 2 ! Dump all
    if ( switchDetail(switches, 'DPRI') > -1 ) dump_rad_pol = 3 ! Dump first and stop
    dump_rad_pol = switchDetail(switches, 'dpri') + 1
    dump_TScat = switchDetail(switches, 'dsct' ) > -1
    print_Frq = switchDetail(switches, 'ffrq' ) > -1
    print_Deltau_Pol = switchDetail(switches, 'deltaupol' )
    print_Incopt = switchDetail(switches, 'incp' ) > -1
    print_IncRad = switchDetail(switches, 'incr' ) > -1
    print_Mag = switchDetail(switches, 'mag')
    print_Pol_Rad = switchDetail(switches, 'polr')
    print_path = switchDetail(switches, 'path')
    print_Rad = switchDetail(switches, 'rad')
    print_Seez = switchDetail(switches, 'seez') > -1
    print_TauL = switchDetail(switches, 'taul') > -1
    print_TauP = switchDetail(switches, 'taup') > -1
    print_TScat = switchDetail(switches, 'TScat' ) > -1
    Print_TScat_Deriv = switchDetail(switches, 'dtsct' )
    print_TScat_detail = switchDetail(switches, 'psct' )
    print_more_points = switchDetail(switches, 'ZMOR' ) > -1
    do_more_points = switchDetail(switches, 'zmor') > -1

    usingQTM = s_QTM /= 0

    ! Nullify all our pointers that are allocated because the first thing
    ! Allocate_Test does is ask if they're associated.  If we don't nullify
    ! them, they're undefined, i.e., junk that might be mistaken for
    ! associated.

    nullify ( frequencies ) ! Pointer instead of allocatable because it might
                            ! be associated with channel centers instead of
                            ! being allocated

    ! Nullify pointers that are used to control whether calculations get done
    nullify ( linecenter_ix, linewidth_ix, linewidth_tdep_ix )

    d2_delta_df2 = 0.0

    ! Put zeros into H_Atmos so that the elements that aren't filled will
    ! be defined.  It has zero size if second derivatives aren't requested.

    h_atmos = 0.0

    h2o_ind = grids_f%s_ind(l_h2o)

    call both_sidebands_setup

    if ( FwdModelConf%generateTScat ) then
      call TScat_Gen_Setup ( fwdModelConf, fwdModelIn, fwdModelExtra,     &
      &                      fwdModelOut, noUsedChannels, temp, sideband, &
      &                      IWC, scatteringAngles )
    else if ( FwdModelConf%incl_cld ) then
      call cloud_setup
    end if

    ! Compute hydrostatic grid -----------------------------------------------
    ! If this is moved into BOTH_SIDEBANDS_SETUP the run time increases by
    ! a large unexplainable amount, at least in LF95.

    call Trace_Begin ( me_Hydro, 'ForwardModel.Hydrostatic', &
      & cond=toggle(emit) .and. levels(emit) > 0 )

    ! Get interpolation coefficients from temperature's zetas to Z_GLGrid.
    ! Temperature is coherent and stacked, so Eta_zzT is applicable everywhere.

    call eta_zzt%eta_1d ( Grids_tmp%zet_basis, z_glgrid, what=Grids_tmp%qty(1), &
                        & sorted=.true. )

    ! Insert into bill's 2d hydrostatic equation.
    ! The phi inputs for this subprogram are the orbit plane projected
    ! geodetic locations of the temperature phi basis -- not necessarily
    ! the tangent phi's, which might be somewhat different.

    ! For 2D, temperature's windowStart:windowFinish are correct here.
    ! RefGPH and temperature have the same horizontal basis.

    ! For QTM, WindowStart:WindowFinish is the entire grid.  The hydrostatic
    ! calculation is not done here.  Rather, it's done for each pointing.  We
    ! do the calculations only for serial numbers in the path description. 
    ! This entails splitting the Metrics-3D calculation into two parts: First,
    ! identify the facets that the path crosses and gather the vertex serial
    ! numbers.  Then do the hydrostatic calculation for those vertices. Then
    ! finish the vertical part of the Metrics-3D calculation.

    if ( .not. usingQTM ) then ! For QTM, we need a different t_glgrid,
                               ! h_glgrid, etc. for each pointing, so it's
                               ! done later.
!????? Maybe the hydrostatic could be done for QTM here if all the paths cross
!????? the same set of facets.
      if ( temp_der ) then
        call two_d_hydrostatic ( Grids_tmp, refGPH%template%surfs(1,1), &
          &  refGPH%values(1,windowStart:windowFinish), z_glgrid, &
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT, &
          &  dHidTlm=dh_dt_glgrid, ddHdHdTl0=ddhidhidtl0 )
      else
        call two_d_hydrostatic ( Grids_tmp, refGPH%template%surfs(1,1), &
          &  refGPH%values(1,windowStart:windowFinish), z_glgrid, &
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT )
      end if
    end if

    call Trace_End ( 'ForwardModel.Hydrostatic', &
      & cond=toggle(emit) .and. levels(emit) > 0 )

    ! Allocate space for the interpolator components for each quantity, and the
    ! components for each frequency-dependent quantity.  We create them here
    ! with enough rows for the longest path.  The number of columns is constant.

    ! Interpolation coefficients for Phi for temperature
    call eta_p_T%create ( max_f, no_sv_p_T, 2*max_f, what=grids_tmp%mol(1) )
    ! Interpolation coefficients for Zeta X Phi for temperature
    if ( temp_der ) then
      call eta_zp_T%create ( max_f, sv_t_len, 2*max_f, what=grids_tmp%mol(1) )
      call dh_dt_path%create ( max_f, sv_t_len, 2*max_f, what=grids_tmp%mol(1) )
    end if
    do i = 1, size(beta_group)
      ! For QTM, everything has the same horizontal grid.  The values of
      ! grids_f%l_p are computed from the longest path through the QTM.
      n_phi = grids_f%l_p(i) - grids_f%l_p(i-1)
      ! Interpolation coefficients for Zeta for all VMR
      call eta_z(i)%create ( max_f, grids_f%l_z(i) - grids_f%l_z(i-1), &
                           & 2*max_f, what=grids_f%mol(i) )
      ! Interpolation coefficients for Phi for all VMR
      call eta_p(i)%create ( max_f, n_phi, 2*max_f, what=grids_f%mol(i) )
      ! Interpolation coefficients for Zeta X Phi for all VMR
      call eta_zp(i)%create ( max_f, &
                            & ( grids_f%l_z(i) - grids_f%l_z(i-1) ) * n_phi, &
                            & 2*max_f, what=grids_f%mol(i) )
      ! Interpolation coefficients for Frequency X Zeta X Phi
      call eta_fzp(i)%create ( max_f, &
                             & grids_f%l_v(i) - grids_f%l_v(i-1), &
                             & 2*max_f, what=grids_f%mol(i) )
      ! Representation of d_delta_df for Get_d_Deltau_Pol_df (polarized)
      if ( s_p > 0 ) call d_delta_df(i)%create ( max_f, &
                            & ( grids_f%l_z(i) - grids_f%l_z(i-1) ) * n_phi, &
                            & 2*max_f, what=grids_f%mol(i) )
    end do
    if ( fwdModelConf%useTScat ) then
      ! Create them here instead of in One_Pointing so as not to need to
      ! do it for each pointing.
      if ( .not. allocated(t_s) ) call MLSMessage ( MLSMSG_Error, &
        & moduleName, "UseTScat requested but no Mie tables loaded" )
      call eta_IWC_path_c%create ( max_c, size(IWC_s)*size(T_s), 2*max_c )
      call eta_T_path_c%create ( max_c, size(IWC_s)*size(T_s), 2*max_c )
      call eta_T_IWC_path_c%create ( max_c, size(IWC_s)*size(T_s), 2*max_c )
    end if
    ! Create empty interpolation coefficients for spectroscopy derivatives
    if ( size(fwdModelConf%lineCenter) > 0 ) then
      do i = 1, size(grids_v%values)
        call eta_zp_v(i)%create ( max_f, &
                                & ( grids_v%l_z(i)-grids_v%l_z(i-1) ) * &
                                & ( grids_v%l_p(i)-grids_v%l_p(i-1) ), &
                                & 2*max_f, what=grids_v%mol(i) )
      end do
    end if
    if ( size(fwdModelConf%lineWidth) > 0 ) then
      do i = 1, size(grids_w%values)
        call eta_zp_v(i)%create ( max_f, &
                                & ( grids_w%l_z(i)-grids_w%l_z(i-1) ) * &
                                & ( grids_w%l_p(i)-grids_w%l_p(i-1) ), &
                                & 2*max_f, what=grids_v%mol(i) )
      end do
    end if
    if ( size(fwdModelConf%lineWidth_TDep) > 0 ) then
      do i = 1, size(grids_n%values)
        call eta_zp_v(i)%create ( max_f, &
                                & ( grids_n%l_z(i)-grids_n%l_z(i-1) ) * &
                                & ( grids_n%l_p(i)-grids_n%l_p(i-1) ), &
                                & 2*max_f, what=grids_v%mol(i) )
      end do
    end if

    ! Loop over sidebands ----------------------------------------------------
    call Trace_Begin ( me_SidebandLoop, 'ForwardModel.SidebandLoop', &
      & cond=toggle(emit) .and. levels(emit) > 0 )
    do thisSideband = fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, 2

      call Trace_Begin ( me_Sideband, 'ForwardModel.Sideband ', &
        & index=thisSideband, cond=toggle(emit) .and. levels(emit) > 1 )

      sx = ( thisSideband + 3 ) / 2 ! [-1,+1] => [1,2]

      ! Work out Frequency averaging / LBL / PFA / Derivatives steering.
      ! See the decision table in Frequency_Average for the meaning of
      ! values of Frq_Avg_Sel.
      frq_avg_sel = 0
      if ( fwdModelConf%do_freq_avg .or. &
        &  fwdModelConf%anyPFA(sx) .and. .not. &
        &  fwdModelConf%anyLBL(sx) )  frq_avg_sel = ior(frq_avg_sel, 8)
      if ( fwdModelConf%anyPFA(sx) )  frq_avg_sel = ior(frq_avg_sel, 4)
      if ( fwdModelConf%anyLBL(sx) )  frq_avg_sel = ior(frq_avg_sel, 2)
      if ( any_der )                  frq_avg_sel = ior(frq_avg_sel, 1)

      ! Now, allocate gl_slabs arrays
      call allocateSlabs ( gl_slabs, max_f, &
        & fwdModelConf%catalog(thisSideband,:fwdModelConf%cat_size(sx)), &
        & moduleName, temp_der )

      call frequency_setup_1 ( tan_press, grids )

      ! Loop over pointings --------------------------------------------------
      call Trace_Begin ( me_PointingLoop, 'ForwardModel.PointingLoop', &
        & cond=toggle(emit) .and. levels(emit) > 2 )

      if ( switchDetail( switches, 'nfmpt', options='-fc' ) > -1 ) then
       ! no op; maybe print
        if ( toggle(emit) .and. levels(emit) > 2 ) &
          & call output( '(Skipping loop of pointings)', advance='yes' )
      else if ( .not. FwdModelConf%generateTScat ) then



        do ptg_i = 1, no_tan_hts

          vel_rel = est_los_vel(ptg_i) / speedOfLight

          ! If we're doing frequency averaging, get the frequencies we need for
          ! this pointing.

          if ( associated(whichPointingGrid) ) &
            & call frequency_setup_2 ( (1.0_rp - vel_rel) * &
            & whichPointingGrid%oneGrid(grids(ptg_i))%frequencies )

          ! Do the ray tracing
          if ( .not. usingQTM ) then
            ! Calculate R_Eq in the orbit plane projected ellipse, for which
            ! Earthradc_sq has the same value for all tangent points in the
            ! non-QTM case because they're all in the same plane.
            r_eq = get_r_eq ( tan_phi(ptg_i), earthradc_sq(ptg_i) )
            call one_pointing ( ptg_i, vel_rel, r_eq, tan_phi=tan_phi(ptg_i), &
              &                 tan_press=tan_press(ptg_i), &
              &                 est_scGeocAlt=est_scGeocAlt(ptg_i) )
          else

            ! For the QTM case, R_Eq might have different values for each
            ! tangent point in the QTM.
            r_eq = radius_of_curvature_normal ( QTM_paths(ptg_i)%lines(2,1), &
                                              & tan_pt_geod(ptg_i)%surf_ECR(.false.) )
            call one_pointing ( ptg_i, vel_rel, r_eq,               &
              &                 tan_loc=tan_pt_geod(ptg_i),         &
              &                 qtm=QTM,                            &
              &                 tan_press=tan_press(ptg_i),         &
              &                 est_scGeocAlt=est_scGeocAlt(ptg_i), &
              &                 path=QTM_paths(ptg_i), s=s,         &
              &                 f_and_v=F_and_V(min(ptg_i,size(F_And_V))) )
          end if
        end do ! ptg_i

      else
        ! Do ray tracing at specified scattering angles
        call generate_TScat ( fwdModelConf )
      end if

      call Trace_End ( 'ForwardModel.PointingLoop', &
        & cond=toggle(emit) .and. levels(emit) > 2 )

      if ( .not. fwdModelConf%generateTScat ) then
        if ( thisSideband == fwdModelConf%sidebandStart ) then
           ! Same for both sidebands, so only need to do it once
          if ( .not. usingQTM ) then
            call convolution_setup ( dh_dz_out, dx_dh_out, dxdT_surface, &
              & dxdT_tan, Q_EarthRadC_sq, Est_ScGeocAlt, &
              & FwdModelConf, &
              & FwdModelExtra, FwdModelIn, Grids_f, Grids_tmp, &
              & L1BMIF_TAI, MAF, MIFDeadTime, &
              & PhiTan, PTan, RefGPH, SCGeocAlt, &
              & Surf_Angle, Chi_MIF_Tan, Tan_Phi, Tan_Press, &
              & WindowFinish, WindowStart )
          else ! QTM
            call convolution_setup ( dh_dz_out, dx_dh_out, dxdT_surface, &
              & dxdT_tan, Q_EarthRadC_sq, Est_ScGeocAlt, &
              & FwdModelConf, &
              & FwdModelExtra, FwdModelIn, Grids_f, Grids_tmp, &
              & L1BMIF_TAI, MAF, MIFDeadTime, &
              & PhiTan, PTan, RefGPH, SCGeocAlt, &
              & Surf_Angle, Chi_MIF_Tan, Tan_Phi, Tan_Press, &
              & WindowFinish, WindowStart, &
              & n_path_c(1), scECR_MIF, ECRtoFOV )
          end if
        end if
        call convolution & ! or interpolate to ptan
          ( dh_dz_out, dx_dh_out, dx_dT, dxdT_surface, &
          & dxdT_tan, d2x_dxdT, F_and_V, &
          & Q_EarthRadC_sq, Est_ScGeocAlt, FirstSignal, FmStat, &
          & FwdModelConf, FwdModelExtra, FwdModelIn, FwdModelOut, &
          & Grids_f, Grids_n, Grids_tmp, Grids_v, Grids_w, &
          & H_Atmos, K_Atmos, K_Spect_DN, K_Spect_DV, K_Spect_DW, &
          & K_Temp, L1BMIF_TAI, MIFDeadTime, PTan, PTan_Der, &
          & Ptg_Angles, Radiances, Sideband, S_T, Surf_Angle, &
          & Chi_MIF_Tan, Tan_Phi, Temp, ThisSideband, &
          & Jacobian, ExtraJacobian, Hessian )
      end if

      ! Frequency averaging and any LBL:
      if ( .not. associated(frequencies,channelCenters) ) &
        & call deallocate_test ( frequencies, 'frequencies',       moduleName )

      ! Deallocate maxNoPtgFreqs-sized stuff
      call deallocate_test ( inc_rad_path,     'Inc_Rad_Path',     moduleName )
      call deallocate_test ( radv,             'RadV',             moduleName )
      if ( FwdModelConf%anyLBL(sx) ) then
        call deallocate_test ( t_script_LBL,   'T_Script_LBL',     moduleName )
        call destroy_tau ( tau_LBL,            'Tau_LBL',          moduleName )
      end if

      call DestroyCompleteSlabs ( gl_slabs )
      if ( temp_der ) &
        & call deallocate_test ( k_temp_frq,   'k_temp_frq',       moduleName )

      call deallocate_test ( k_atmos_frq,  'k_atmos_frq',          moduleName )
      call deallocate_test ( h_atmos_frq,  'h_atmos_frq',          moduleName )

      call deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq',     moduleName )
      call deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq',     moduleName )
      call deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq',     moduleName )

      call trace_end ( 'ForwardModel.Sideband ', index=thisSideband, &
        & cond=toggle(emit) .and. levels(emit) > 1 )

    end do            ! End of loop over sidebands -------------------------

    call Trace_End ( 'ForwardModel.SidebandLoop', &
      & cond=toggle(emit) .and. levels(emit) > 0 )

    if ( FwdModelConf%anyPFA(1) .or. FwdModelConf%anyPFA(2) ) &
      & call destroy_tau ( tau_PFA, "Tau_PFA", moduleName )

    !  **** DEBUG Printing cycle ...

! *** Create *seez* file for "nasty" purposes:

    if ( print_Seez ) call dump_print_code

! *** End of include

    call GetNameOfSignal ( firstSignal, sigName )
    i = index(sigName, '.B')
    j = index(sigName(i+2:), '.' )
    if ( j /= 0 ) sigName(i+j+1:) = ''

    if ( print_Rad > -1 ) then
      print '(6a)', 'Signal: ', trim(sigName), &
        & ' Convolution: ', trim(merge('ON ','OFF',FwdModelConf%do_conv)), &
        & ' Frequency Averaging: ', trim(merge('ON ','OFF', &
          & FwdModelConf%do_freq_avg .and. any(fwdModelConf%anyLBL)))

      k = ptan%template%noSurfs
      print "( /'ptan\ ',i3.3)", k
      print "( 4(3x, f11.7) )", Ptan%values(1:k,maf)

      do i = 1, noUsedChannels
        print "(/, 'ch', i3.3, '_pfa_rad\ ', i3.3 )", channels(i)%used, k
        thisRadiance => GetQuantityForForwardModel (fwdModelOut,  &
          & quantityType=merge(l_tscat,l_radiance,fwdModelConf%GenerateTScat), &
          & signal=fwdModelConf%signals(channels(i)%signal)%index, &
          & sideband=sideband, config=fwdModelConf )
        channel = channels(i)%used - channels(i)%origin + 1
!         j = thisRadiance%template%noChans
!         This caused a bogus bounds-check violation with -check bounds, or
!         undefined variable violation with -check undef, from ifort 17.0.0.098
!         print "( 4(2x, 1pg15.8) )", &
!           & thisRadiance%values(channel:channel+j*(k-1):j, maf)
        print "( 1p, 4g17.8 )", thisRadiance%value3(channel,:,maf)
      end do

    end if

    ! **** End of Printing cycle ...

    call destroygrids_t ( grids_tscat )
    call destroygrids_t ( grids_salb )
    call destroygrids_t ( grids_cext )

    if ( FwdModelConf%incl_cld ) then
      call DestroyVectorQuantityValue ( scat_src, forWhom='scat_src' )
      call DestroyVectorQuantityValue ( scat_alb, forWhom='scat_alb' )
      call DestroyVectorQuantityValue ( cld_ext, forWhom='cld_ext' )
    end if

    ! If hGrids were QTM, destroy intermediate minor-frame quantities
    if ( usingQTM ) then
      call DestroyVectorQuantityValue ( Q_EarthRadC_sq, forWhom='Q_EarthRadC_sq' )
      call DestroyVectorQuantityValue ( Q_PhiTan, forWhom='Q_PhiTan' )
      call DestroyVectorQuantityValue ( Q_TanHt, forWhom='Q_TanHt' )
    end if

    call trace_end ( 'FullForwardModelAuto, MAF=', fmStat%maf, &
      & cond=toggle(emit) )

  contains

  ! .............................................  Announce_Error  .....
    subroutine Announce_Error ( Message )
    ! Announce Message using MLSMessage.  Include the configuration name
    ! in the message.
      use MLSMessageModule, only: MLSMSG_Error
      use MoreMessage, only: MLSMessage
      character(len=*), intent(in) :: Message
      call MLSMessage ( MLSMSG_Error, moduleName, &
        & "With config(%S): " // message, datum=fwdModelConf%name )
    end subroutine Announce_Error

  ! .......................................  Both_Sidebands_Setup  .....
    subroutine Both_Sidebands_Setup
    ! Setup stuff done for both sidebands, other than output angles
    ! for convolution and stuff for clouds.

      use Geometry, only: Orbit_Plane_Minor_Axis_sq
      use Interpolate_MIF_to_Tan_Press_m, only: Interpolate_MIF_to_Tan_Press
      use Intrinsic, only: L_EarthRefl, L_ECRtoFOV, L_GPH,  &
        & L_LOSVel, L_SurfaceHeight, L_OrbitInclination, L_RefGPH, &
        & L_ScGeocAlt, L_SpaceRadiance
      use ManipulateVectorQuantities, only: DoHGridsMatch
      use Tangent_Quantities_m, only: Tangent_Quantities

      integer :: Me = -1  ! String index for trace
      integer :: SigInd   ! Signal index, loop counter

      call trace_begin ( me, 'ForwardModel.Both_Sidebands_Setup', &
        & cond=toggle(emit)  .and. levels(emit) > 0  )

      fmStat%flags = 0   ! Assume no errors

      MAF = fmStat%maf

      if ( usingQTM ) then
        ! Compute minor-frame tangent quantities from the minor-frame
        ! lines-of-sight (Q_LOS) provided by level 1.
        call tangent_quantities ( MAF, fwdModelConf, fwdModelIn, fwdModelExtra, &
                                & Q_LOS, Q_EarthRadC_sq, Q_PhiTan, Q_TanHt )
        phiTan => Q_PhiTan ! Use the calculated one, not the one in FwdModelIn
      end if

      temp_der = fwdModelConf%temp%derivOK
      atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der
      atmos_second_der = present ( hessian ) .and. FwdModelConf%atmos_second_der

      spect_der = present ( jacobian ) .and. FwdModelConf%spect_der
      spect_der_center = spect_der .and. size(fwdModelConf%lineCenter) > 0
      spect_der_width = spect_der .and. size(fwdModelConf%lineWidth) > 0
      spect_der_width_TDep = spect_der .and. size(fwdModelConf%lineWidth_TDep) > 0
      spect_der = spect_der .and. &
        & ( spect_der_center .or. spect_der_width .or. spect_der_width_TDep )

      any_der = temp_der .or. atmos_der .or. spect_der

      ! Work out what we've been asked to do -----------------------------------

      beta_group => fwdModelConf%beta_group
      channels => fwdModelConf%channels
      DACsStaging => fwdModelConf%DACsStaging
      usedDACSSignals => fwdModelConf%usedDACSSignals
      noUsedDacs = size(usedDACSSignals)

      ! Identify the vector quantities we're going to need.
      ! The key is to identify the signal we'll be working with first
      firstSignal => fwdModelConf%signals(1) ! Config has verified that signals
        ! are all for same radiometer (actually LO), module and sideband
      sideband = merge ( 0, firstSignal%sideband, fwdModelConf%forceFoldedOutput )

      ! Start sorting out stuff from state vector ------------------------------

      ! Identify the appropriate state vector components
      ! VMRS are in Beta_group%qty, gotten by get_species_data.
      ! First the minor frame quantities:
      losVel => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule, &
        & config=fwdModelConf )
      scGeocAlt => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_scGeocAlt, config=fwdModelConf )

      ! Now the others:
      earthRefl => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_earthRefl, config=fwdModelConf )
      refGPH => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_refGPH, config=fwdModelConf )
      spaceRadiance => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_spaceRadiance, config=fwdModelConf )
      surfaceHeight => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_surfaceHeight, config=fwdModelConf, noError=.true. )
      if ( FwdModelConf%polarized .or. usingQTM ) then
        ECRtoFOV => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_ECRtoFOV, config=fwdModelConf )
      end if
      if ( FwdModelConf%incl_cld ) then
        gph => GetQuantityForForwardModel (fwdModelIn, fwdModelExtra, &
          & quantityType=l_gph, config=fwdModelConf )
      end if
      if ( FwdModelConf%generateTScat .or. .not. usingQTM ) then
        orbIncline => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_orbitInclination, config=fwdModelConf )
      end if

      ! Check that RefGPH and Temp have the same hGrid.  This is not checked in
      ! Construct or when the config is created.
      if ( .not. doHGridsMatch ( refGPH, temp ) ) call Announce_Error ( &
        & 'Different horizontal grids for refGPH and temperature' )

      if ( .not. fwdModelConf%generateTScat ) then
        ! Check that we have radiances for the channels that are used
        do sigInd = 1, size(fwdModelConf%signals)
          ! This just emits an error message and stops if we don't have a radiance.
          ! We don't use the vector quantity -- at least not right away.  We get
          ! it again later.
          thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
            & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband )
        end do
      end if

      windowStart = grids_tmp%windowStart(1)
      windowFinish = grids_tmp%windowFinish(1)

  ! Compute reference Gauss Legendre (GL) grid ------------------------------

      call compute_GL_grid ( z_psig, z_glgrid )

      ! interpolate Tan_Phi, ScGeocAlt and LOSVel from MIFs to pointings
      if ( .not. FwdModelConf%generateTScat ) then
        if ( .not. usingQTM ) then
          ! At pressure levels PTan, interpolate
          ! phitan,  scgeocalt,     losvel, to
          ! tan_phi, est_scgeocalt, est_los_vel
          ! at pressure levels given by Tan_Press
          call interpolate_MIF_to_tan_press ( nlvl, maf, ptan, phitan, &
            & scgeocalt, losvel, tan_press, &
            & tan_phi, est_scgeocalt, est_los_vel )

          ! Create minor-frame values, all the same:
          ! Q_earthRadC_sq is an array of orbit-plane-projected Earth radii,
          ! all the same, used for convolution.
          call cloneVectorQuantity ( Q_earthRadC_sq, phitan )
          Q_EarthRadC_sq%values = &
            & orbit_plane_minor_axis_sq ( orbIncline%values(1,MAF) * deg2rad )
          ! Create coarse-grid tangent-point values, all the same
          earthradc_sq = &
            & orbit_plane_minor_axis_sq ( orbIncline%values(1,MAF) * deg2rad )
        else
          ! At pressure levels PTan, interpolate
          ! phitan,  scgeocalt,     losvel,      Q_EarthRadC_sq, Q_TanHt to
          ! tan_phi, est_scgeocalt, est_los_vel, earthRadC_sq,   tanHt
          ! at pressure levels given by Tan_Press
          call interpolate_MIF_to_tan_press ( nlvl, maf, ptan, phitan, &
            & scgeocalt, losvel, tan_press, &
            & tan_phi, est_scgeocalt, est_los_vel, &
            & Q_EarthRadC_sq, Q_TanHt, &
            & earthRadC_sq,   tanHt, tan_pt_Geod  )
        end if
      else ! Generating TScat
        ! Compute the square of the minor axis of the orbit plane projected
        ! Earth ellipse.
        earthradc_sq = orbit_plane_minor_axis_sq ( orbIncline%values(1,maf) * deg2rad )
      end if

      ! Now, allocate other variables we're going to need later --------

      if ( FwdModelConf%anyPFA(1) .or. FwdModelConf%anyPFA(2) ) then
        call allocate_test ( tau_PFA%tau, max_c, noUsedChannels, 'Tau_PFA%Tau', &
          & moduleName )
        call allocate_test ( tau_PFA%i_stop, noUsedChannels, 'Tau_PFA%I_Stop', &
          & moduleName )
      end if

      call trace_end ( 'ForwardModel.Both_Sidebands_Setup', &
        & cond=toggle(emit) .and. levels(emit) > 0  )

    end subroutine Both_Sidebands_Setup

  ! ................................................  Cloud_Setup  .....
    subroutine Cloud_Setup

      use Intrinsic, only: L_BOUNDARYPRESSURE, L_CLEAR
      use Load_Sps_Data_m, only: Modify_values_for_supersat
      use ManipulateVectorQuantities, only: FindOneClosestInstance
      use VectorsModule, only: CreateVectorValue

      integer :: Ispec                        ! Species index in cloud model
      integer :: J                            ! Loop inductor, subscript
      type (VectorValue_T), pointer :: VMR    ! Quantity

      ! Find the instance in temp that is closest to the current MAF
      inst = FindOneClosestInstance ( temp, ptan, fmStat%maf )

      ! checking done in ForwardModelSupport%ConstructForwardModelConfig
      nspec = no_mol ! Will be at least 3 if l_n2o is included, because
                     ! l_h2o and l_o3 are required
      vmrarray = 0.0_r8

      do j = 1, nspec      ! Loop over species

        if ( fwdModelConf%molecules(j) == l_h2o ) then
          ispec = 1
        else if ( fwdModelConf%molecules(j) == l_o3 ) then
          ispec = 2
        else if ( fwdModelConf%molecules(j) == l_n2o ) then
          ispec = 3
        else
          cycle
        end if

        vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molecule=fwdModelConf%molecules(j) )

        call InterpolateValues ( vmr%template%surfs(:,1),    &    ! Old X
                               & vmr%values(:,inst),         &    ! Old Y
                               & temp%template%surfs(:,1),   &    ! New X
                               & vmrArray(:,ispec),          &    ! New Y
                               & 'Linear', extrapolate='Clamp' )  ! Options

      end do ! End of Loop over species

      scat_src%template = temp%template
      scat_src%template%noInstances = fwdModelConf%num_scattering_angles
      scat_alb%template = temp%template
      scat_alb%template%noInstances = 2
      cld_ext%template = temp%template
      cld_ext%template%noInstances = 2

      call createVectorValue ( scat_src, 'scat_src' )
      call createVectorValue ( scat_alb, 'scat_alb' )
      call createVectorValue (  cld_ext, 'cld_ext' )

      if ( FwdModelConf%i_saturation /= l_clear ) then
        boundaryPressure => GetQuantityForForwardModel ( fwdModelIn, &
          & fwdModelExtra, quantityType=l_boundaryPressure, config=fwdModelConf )
        ! modify h2o mixing ratio if a special supersaturation is requested
        call modify_values_for_supersat ( fwdModelConf, grids_f, h2o_ind, &
          & grids_tmp, boundaryPressure )
      end if

    end subroutine Cloud_Setup

  ! ............................................  Dump_Print_Code  .....
    subroutine Dump_Print_Code
      include "dump_print_code.f9h"
    end subroutine Dump_Print_Code

  ! ..........................................  Frequency_Average  .....
    subroutine Frequency_Average ( Ptg_i )

      ! Here we either frequency average to get the unconvolved radiances, or
      ! we just store what we have as we're using monochromatic channels

      use Freq_Avg_m, only: Freq_Avg, Freq_Avg_DACS
      use SCRT_dn_m, only: SCRT_PFA

      integer, intent(in) :: Ptg_i ! Pointing index

      integer :: C, ShapeInd
      integer :: Me = -1           ! String index for trace

      call trace_begin ( me, 'ForwardModel.Frequency_Average', &
        & cond=toggle(emit) .and. levels(emit) > 4 )

! Conditions:  8 Frequency averaging?   -  N N - - N N Y Y Y Y
!  - means     4 PFA?                   N  N N Y Y Y Y N N Y Y
! "macht nix"  2 LBL?                   N  Y Y N N Y Y Y Y Y Y
!              1 Derivatives?           -  N Y N Y N Y N Y N Y
!                ---------------------------------------------
!                Frq_Avg_Sel value     0,1 2 3 4 5 6 7
!                                      8,9     C D     A B E F
! ============================================================
! Actions:
! Impossible                            x
! Radiances = RadV                         x x x x
! K = K_frq                                  x   x
! Frq Avg path integrated rad                          x x x
! Combine total path radiances                     x x
! Frq Avg path integrated LBL deriv                      x
! Frq Avg rad Along Path                                     x
! Combine radiances along path                             x x
! Combine LBL and PFA derivs                         x       x

      ! Do DACs stuff for all DACs channels first
      select case ( frq_avg_sel )
      case ( 10 : 15 )
        do c = 1, noUsedDACS
          shapeInd = MatchSignal ( dacsFilterShapes%filter%signal, &
            & fwdModelConf%signals(usedDacsSignals(c)), sideband = thisSideband )
          call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
            & RadV(:noFreqs), DACsStaging(:,c) )
        end do
      end select

      select case ( frq_avg_sel )
      case ( 0, 1, 8, 9 )  ! Impossible: No LBL or PFA
      case ( 2, 3, 4, 5, 12, 13 ) ! Just copy radiance. PFA + DACS - LBL impossible
        radiances(:,ptg_i) = radV(:noFreqs)
      case ( 6, 7 ) ! PFA + monochromatic LBL
        do c = 1, noUsedChannels
          if ( channels(c)%dacs == 0 ) then
            ! Combine LBL and PFA Tau's to get radiances.
            call SCRT_PFA (c, tau_LBL, tau_PFA, t_script_pfa, radiances(c:c,ptg_i) )
          else
            radiances(c,ptg_i) = DACsStaging(channels(c)%used,channels(c)%dacs)
          end if
        end do
      case ( 10, 11, 14 )   ! Frq Avg path integrated radiance
        ! Now go through channel by channel
        do c = 1, noUsedChannels
          if ( channels(c)%dacs == 0 ) then
            if ( fwdModelConf%anyPFA(sx) ) then ! frq_avg_sel = 14
            ! Combine LBL and PFA Tau's to get radiances.
            ! It's OK to combine the Tau's before doing the frequency
            ! averaging because the filter function is normalized.
              call SCRT_PFA (c, tau_LBL, tau_PFA, t_script_pfa, radV(:noFreqs) )
            end if
            shapeInd = channels(c)%shapeInds(sx)
            call freq_Avg ( frequencies, &
              &   filterShapes(shapeInd)%filterGrid,  &
              &   filterShapes(shapeInd)%filterShape, &
              &   radV(:noFreqs), radiances(c,ptg_i) )
          else
            radiances(c,ptg_i) = DACsStaging(channels(c)%used,channels(c)%dacs)
          end if
        end do
      case ( 15 )   ! Frq Avg rad along path
        ! For every channel, we've frequency averaged the incremental radiance
        ! at every point along the path, giving Rad_Avg_Path for every channel
        ! and every point along the path.  Rad_Avg_Path was multiplied by
        ! Tau_PFA in One_Frequency to combine LBL and PFA contributions.
        do c = 1, noUsedChannels
          if ( channels(c)%dacs == 0 ) then
            radiances(c,ptg_i) = radV(c) ! Computed in One_Frequency
          else
            radiances(c,ptg_i) = DACsStaging(channels(c)%used,channels(c)%dacs)
          end if
        end do
      end select

      if ( any_der ) then
        call frequency_average_derivatives ( ptg_i, combine=iand(frq_avg_sel,7) == 7 )
        if ( atmos_second_der ) then
          call frequency_avg_second_derivs ( ptg_i, frq_avg_sel == 15 )
        end if

      end if


      call trace_end ( 'ForwardModel.Frequency_Average', &
        & cond=toggle(emit) .and. levels(emit) > 4 )
    end subroutine Frequency_Average

  ! ...............................  Frequency_Average_Derivative  .....
    subroutine Frequency_Average_Derivative ( Grids, K_Frq, K, Mol, Combine )
      ! Frequency average or simply copy K_Frq to give K, the final
      ! Jacobian.

      use Freq_Avg_m, only: Freq_Avg, Freq_Avg_DACS

      type(grids_T), intent(in) :: Grids
      real(rp), intent(in) :: K_FRQ(:,:)    ! To be averaged  Frq X Grid
      real(r4), intent(inout) :: K(:,:)     ! Averaged        Chan X Grid
      integer, intent(in) :: Mol            ! Which molecule
      logical, intent(in) :: Combine        ! "Combine LBL and PFA"

      integer :: C, ShapeInd
      integer :: Me = -1 ! String index for trace
      real(rp) :: R      ! Frequency-averaged value
      integer :: SV_I    ! State-vector index

      call trace_begin ( me, 'ForwardModel.Frequency_Average_Derivative=', &
          & index=mol, cond=toggle(emit) .and. levels(emit) > 6 )

      if ( combine ) then
        ! Simply add newly-computed PFA derivatives in K_frq to
        ! previously-averaged or monochromatic LBL derivatives in K.
        ! Remember that for PFA, the frequency dimension has extent
        ! noUsedChannels, not maxNoPtgFreqs.  The first dimension of K_frq is
        ! at least noUsedChannels, so we're guaranteed this will fit.
        do c = 1, noUsedChannels
          do sv_i = grids%l_v(mol-1)+1, grids%l_v(mol)
            k(c,sv_i) = k(c,sv_i) + k_frq(c,sv_i)
          end do
        end do
        call trace_end ( 'ForwardModel.Frequency_Average_Derivative=', &
          & index=mol, cond=toggle(emit) .and. levels(emit) > 6 )
        return
      end if

      ! Only possible values for Frq_avg_sel here are 3, 5, 11, 13, 15.
      ! See Frequency_Average for definition of Frq_avg_sel.

      select case ( frq_avg_sel )
      case ( 3, 5, 7, 13 ) ! Not frequency averaging, or PFA alone, or
                      ! Monochromatic LBL + PFA + Derivatives after
                      ! first call to One_Frequency; copy.
                      ! Shouldn't get here after both LBL and PFA passes
                      ! through One_Frequency -- should be handled by
                      ! combine == .true.
        do sv_i = grids%l_v(mol-1)+1, grids%l_v(mol)
          if ( grids%deriv_flags(sv_i) ) then
            k(:,sv_i) = min ( max ( k_frq(:,sv_i), &
                          &   real(-huge(0.0_r4), rp ) ), &
                          &   real( huge(0.0_r4), rp ) )
          else
            k(:,sv_i) = 0.0
          end if
        end do

      case ( 11, 15 ) ! See Frequency_Average.  LBL and PFA have already
                      ! been combined.  It's OK to frequency average the
                      ! PFA contribution again because the filter function
                      ! is normalized.
        ! Do DACs stuff for all DACs channels first
        do c = 1, noUsedDACS
          shapeInd = MatchSignal ( dacsFilterShapes%filter%signal, &
            & fwdModelConf%signals(usedDacsSignals(c)), sideband = thisSideband )
          do sv_i = grids%l_v(mol-1)+1, grids%l_v(mol)
            call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
              & k_frq(:,sv_i), DACsStaging2(:,sv_i,c) )
          end do                  ! Surface loop X Instance loop
        end do
        ! Now go through channel by channel
        do c = 1, noUsedChannels
          shapeInd = channels(c)%shapeInds(sx)
          do sv_i = grids%l_v(mol-1)+1, grids%l_v(mol)
            if ( grids%deriv_flags(sv_i) ) then
              if ( channels(c)%dacs == 0 ) then
                call Freq_Avg ( frequencies,            &
                  & FilterShapes(shapeInd)%FilterGrid,  &
                  & FilterShapes(shapeInd)%FilterShape, &
                  & k_frq(:,sv_i), r )
              else
                r = DACsStaging2 ( channels(c)%used, sv_i, channels(c)%dacs )
              end if
            else
              r = 0.0
            end if
            k(c,sv_i) = r
          end do                ! Grid loop
        end do                  ! Channel loop
      case default              ! Impossible
      end select                ! Frequency averaging or not

      call trace_end ( 'ForwardModel.Frequency_Average_Derivative=', &
        & index=mol, cond=toggle(emit) .and. levels(emit) > 6 )

    end subroutine Frequency_Average_Derivative

  ! ..............................  Frequency_Average_Derivatives  .....
    subroutine Frequency_Average_Derivatives ( Ptg_i, Combine )
      integer, intent(in) :: Ptg_i          ! Pointing index
      logical, intent(in) :: Combine        ! "Combine LBL and PFA"

      ! Frequency Average the temperature derivatives with the appropriate
      ! filter shapes

      integer :: K       ! Loop inductor
      integer :: Me = -1 ! String index for trace
      integer :: UB      ! Upper bound for first dimension of k_..._frq

      call trace_begin ( me, 'ForwardModel.Frequency_Average_Derivatives', &
        & cond=toggle(emit) .and. levels(emit) > 5 )

      ub = noFreqs
      if ( combine ) ub = max(ub,noUsedChannels)

      if ( temp_der ) call frequency_average_derivative ( grids_tmp, &
        &               k_temp_frq(:ub,:), k_temp(:,ptg_i,:), 1, combine )

      ! Frequency Average the atmospheric derivatives with the appropriate
      ! filter shapes
      if ( atmos_der ) then
        do k = 1, no_mol
          if ( fwdModelConf%moleculeDerivatives(k) ) then
            call frequency_average_derivative ( grids_f, &
              & k_atmos_frq(:ub,:), k_atmos(:,ptg_i,:), k, combine )
          else
            k_atmos(:,ptg_i,grids_f%l_v(k-1)+1:grids_f%l_v(k)) = 0.0
          end if
        end do                        ! Loop over major molecules
      end if                          ! Want derivatives for atmos

      ! Frequency Average the spectroscopic derivatives with the appropriate
      ! filter shapes

      do k = 1, size(fwdModelConf%lineCenter)
        call frequency_average_derivative &
          & ( grids_v, k_spect_dv_frq(:ub,:), k_spect_dv(:,ptg_i,:), k, &
          & combine )
      end do
      do k = 1, size(fwdModelConf%lineWidth)
        call frequency_average_derivative &
          & ( grids_w, k_spect_dw_frq(:ub,:), k_spect_dw(:,ptg_i,:), k, &
          & combine )
      end do
      do k = 1, size(fwdModelConf%lineWidth_TDep)
        call frequency_average_derivative &
          & ( grids_n, k_spect_dn_frq(:ub,:), k_spect_dn(:,ptg_i,:), k, &
          & combine )
      end do

      call trace_end ( 'ForwardModel.Frequency_Average_Derivatives', &
        & cond=toggle(emit) .and. levels(emit) > 5 )

    end subroutine Frequency_Average_Derivatives

  ! .....................................  Frequency_Avg_Rad_Path  .....
    subroutine Frequency_Avg_Path ( Frequencies, Path_Freq, Path_Chan )
      ! PFA + LBL + Derivatives, and maybe or maybe not frequency averaging.
      ! Frq_Avg_Sel = 7 (no frequency averaging) or 15 (frequency averaging).
      ! For every channel, frequency average or copy Path_Freq at every
      ! point along the path, giving Path_Chan for every channel and
      ! every point along the path.

      use Freq_Avg_m, only: Freq_Avg

      real(r8), intent(in) :: Frequencies(:)
      real(rp), intent(in) :: Path_Freq(:,:)  ! Path X Frequencies
      real(rp), intent(out) :: Path_Chan(:,:) ! Path X Channels

      integer :: C, P, ShapeInd

      if ( fwdModelConf%do_freq_avg ) then ! Frequency average
        do c = 1, noUsedChannels
          shapeInd = channels(c)%shapeInds(sx)
          if ( channels(c)%dacs == 0 ) then
            do p = 1, size(path_freq,1)
              call Freq_Avg ( frequencies,            &
                      & FilterShapes(shapeInd)%FilterGrid,  &
                      & FilterShapes(shapeInd)%FilterShape, &
                      & path_freq(p,:), path_chan(p,c) )
            end do
          end if
        end do
      else ! Copy
        path_chan = path_freq
      end if
    end subroutine Frequency_Avg_Path

  ! ...............................  Frequency_Avg_Second_Derivative  .....
    subroutine Frequency_Avg_Second_Derivative ( Grids, H_Frq, H, Mol1, Mol2, Combine )

      ! Frequency average or simply copy H_Frq to give H, the final HESSIAN

      use Freq_Avg_m, only: Freq_Avg, Freq_Avg_DACS

      type(grids_T), intent(in) :: Grids
      real(rp), intent(in) :: H_FRQ(:,:,:)    ! To be averaged  Frq X Grid X Grid
      real(r4), intent(inout) :: H(:,:,:)     ! Averaged        Chan X Grid X Grid
      integer, intent(in) :: Mol1, Mol2       ! Which molecules
      logical, intent(in) :: Combine          ! "Combine LBL and PFA"

      integer :: C, ShapeInd
      real(rp) :: H_AVG      ! Frequency-averaged value
      integer :: SV_Q, SV_R  ! State-vector indexes

      if ( combine ) then
        ! Simply add newly-computed PFA derivatives in K_frq to
        ! previously-averaged LBL derivatives in K.  Remember that
        ! for PFA, the frequency dimension has extent noUsedChannels,
        ! not maxNoPtgFreqs.  The first dimension of K_frq is at least
        ! noUsedChannels, so we're guaranteed this will fit.
        do c = 1, noUsedChannels
          do sv_q = grids%l_v(mol1-1)+1, grids%l_v(mol1)
            do sv_r = grids%l_v(mol2-1)+1, grids%l_v(mol2)
              h(c,sv_q,sv_r) = h(c,sv_q,sv_r) + h_frq(c,sv_q,sv_r)
            end do
          end do
        end do
        return
      end if

      ! Only possible values for Frq_avg_sel here are 3, 7, 11, 13, 15.
      ! See Frequency_Average for definition of Frq_avg_sel.

      select case ( frq_avg_sel )
      case ( 11, 15 ) ! See Frequency_Average.
        ! Do DACs stuff for all DACs channels first
        do c = 1, noUsedDACS
          shapeInd = MatchSignal ( dacsFilterShapes%filter%signal, &
            & fwdModelConf%signals(usedDacsSignals(c)), sideband = thisSideband )

          do sv_q = grids%l_v(mol1-1)+1, grids%l_v(mol1)
            do sv_r = grids%l_v(mol2-1)+1, grids%l_v(mol2)
              call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), h_frq(:,sv_q,sv_r), DACsStaging3(:,sv_q,sv_r,c) )
            end do
          end do                  ! Surface loop X Instance loop

        end do

       ! Now go through channel by channel
        do c = 1, noUsedChannels
          shapeInd = channels(c)%shapeInds(sx)
          do sv_q = grids%l_v(mol1-1)+1, grids%l_v(mol1)
            do sv_r = grids%l_v(mol2-1)+1, grids%l_v(mol2)
              if ( grids%deriv_flags(sv_q) .and. grids%deriv_flags(sv_r) ) then
                if ( channels(c)%dacs == 0 ) then
                  call Freq_Avg ( frequencies,            &
                    & FilterShapes(shapeInd)%FilterGrid,  &
                    & FilterShapes(shapeInd)%FilterShape, &
                    & h_frq(:,sv_q,sv_r), h_avg )
                else
                  h_avg = DACsStaging3 ( channels(c)%used, sv_q, sv_r, channels(c)%dacs )
                end if
              else
                h_avg = 0.0
              end if
              h(c,sv_q,sv_r) = h_avg
            end do              ! Grid loop 2
          end do                ! Grid loop 1
        end do                  ! Channel loop
      case ( 3, 7, 13 )         ! Not frequency averaging, or PFA alone; copy.
        do sv_q = grids%l_v(mol1-1)+1, grids%l_v(mol1)
          do sv_r = grids%l_v(mol2-1)+1, grids%l_v(mol2)
            if ( grids%deriv_flags(sv_q) .and. grids%deriv_flags(sv_r) ) then
              h(:,sv_q,sv_r) = min ( max ( h_frq(:,sv_q,sv_r), &
                            &   real(-huge(0.0_r4), rp ) ), &
                            &   real( huge(0.0_r4), rp ) )
            else
              h(:,sv_q,sv_r) = 0.0
            end if
          end do
        end do
      case default             ! Impossible
      end select               ! Frequency averaging or not
    end subroutine Frequency_Avg_Second_Derivative

  ! ................................  Frequency_Avg_Second_Derivs  .....
    subroutine Frequency_Avg_Second_Derivs ( Ptg_i, Combine )

      integer, intent(in) :: Ptg_i          ! Pointing index
      logical, intent(in) :: Combine        ! "Combine LBL and PFA"

      integer :: K, KK  ! Loop inductor
      integer :: UB     ! Upper bound for first dimension of h_..._frq

      ub = noFreqs
      if ( combine ) ub = max(ub,noUsedChannels)

      ! Frequency Average the atmospheric (ONLY) SECOND derivatives
      ! with the appropriate filter shapes
      if ( atmos_second_der ) then

        do k = 1, no_mol
          do kk = 1, no_mol

            if ( fwdModelConf%moleculeSecondDerivatives(k) .and. &
               & fwdModelConf%moleculeSecondDerivatives(kk) ) then
              call frequency_avg_second_derivative ( &
                &  grids_f, h_atmos_frq(:ub,:,:), h_atmos(:,ptg_i,:,:), k, kk, combine )
            else
              h_atmos(:, ptg_i, grids_f%l_v(k-1)+1:grids_f%l_v(k), &
                              & grids_f%l_v(kk-1)+1:grids_f%l_v(kk)) = 0.0
            end if

          end do                      ! Loop over major molecules
        end do                        ! Loop over major molecules

      end if                          ! Want derivatives for atmos

    end subroutine Frequency_Avg_Second_Derivs

  ! ..........................................  Frequency_Setup_1  .....
    subroutine Frequency_Setup_1 ( Tan_Press, Grids )

      ! Work out which pointing frequency grid we're going to need

      ! Code splits into two sections, one for when we're doing frequency
      ! averaging, and one when we're not.

      real(rp), intent(in) :: Tan_Press(:)
      integer, intent(out) :: Grids(:)

      integer :: I, K, Ptg_i, ShapeInd
      integer :: MaxNoPtgFreqs     ! Used for sizing arrays
      integer :: MinSuperset       ! Min. value of superset > 0
      real(rp) :: R1, R2           ! real variables for various uses
      integer :: Superset          ! Output from AreSignalsSuperset
      integer :: SV_Dim            ! Second dimension of K_*_FRQ, or zero
      integer, parameter :: DumpingDetails = -1 ! Used in case of trouble

      nullify ( whichPointingGrid )

      if ( fwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) then

        minSuperset = huge(0)
        do i = 1, size(pointingGrids)
          superset = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals, sideband=thisSideband )
          if ( superset >= 0 .and. superset <= minSuperset ) then
            minSuperset = superset
            whichPointingGrid => pointingGrids(i)
          end if
        end do
        if ( .not. associated(whichPointingGrid) ) then
          call HeadLine ( 'Trouble in FullForwardModel line-by-line' )
          call output( 'ForwardModel signals', advance='yes' )
          call Dump( fwdModelConf%signals, Details=DumpingDetails )
          do i=1, size(pointingGrids)
            call outputNamedValue ( 'ptg grid num', i )
            call Dump_Pointing_Grid(  pointingGrids(i), Details=DumpingDetails )
          enddo
          call output( 'Consider the above carefully. You may consider', advance='yes' )
          call output( '(a) Merging 2 or more pointing grids', advance='yes' )
          call output( '(b) Splitting the fwdmdl signals among separate models', advance='yes' )
          call Announce_Error ( &
               & "No matching pointing frequency grids." )
        endif

        ! Now we've identified the pointing grids.  Locate the tangent grid
        ! within it.
        call Hunt ( whichPointingGrid%oneGrid%height, &
                      & tan_press, grids, allowTopValue=.TRUE., nearest=.TRUE. )
        ! Work out the maximum number of frequencies
        maxNoPtgFreqs = 0
        do ptg_i = 1, no_tan_hts
          maxNoPtgFreqs = max ( maxNoPtgFreqs, &
            & Size(whichPointingGrid%oneGrid(grids(ptg_i))%frequencies) )
        end do

        min_ch_freq_grid =  huge(min_ch_freq_grid)
        max_ch_freq_grid = -huge(min_ch_freq_grid)
        do i = 1, noUsedChannels
          shapeInd = channels(i)%shapeInds(sx)
          if ( channels(i)%dacs == 0 ) then
            k = Size(FilterShapes(shapeInd)%FilterGrid)
            r1 = FilterShapes(shapeInd)%FilterGrid(1)
            r2 = FilterShapes(shapeInd)%FilterGrid(k)
          else
            k = Size(dacsFilterShapes(shapeInd)%filter%FilterGrid)
            r1 = dacsFilterShapes(shapeInd)%filter%FilterGrid(1)
            r2 = dacsFilterShapes(shapeInd)%filter%FilterGrid(k)
          end if
          min_ch_freq_grid = MIN(r1, r2, min_ch_freq_grid)
          max_ch_freq_grid = MAX(r1, r2, max_ch_freq_grid)
        end do

        if ( FwdModelConf%anyPFA(sx) ) &
          & call get_channel_centers ( thisSideband, channelCenters )

      else ! ----------------------------- Not frequency averaging -----

        noFreqs = noUsedChannels
        maxNoPtgFreqs = noUsedChannels
        call get_channel_centers ( thisSideband, channelCenters )
        frequencies => channelCenters

      end if ! ----------------- Either frequency averaging or not -----

      call allocate_test ( RadV, maxNoPtgFreqs, 'RadV', moduleName )

      if ( FwdModelConf%anyLBL(sx) ) then
        call allocate_test ( T_Script_LBL, max_c, maxNoPtgFreqs, 'T_Script_LBL', moduleName )
        call allocate_test ( tau_LBL%tau,  max_c, maxNoPtgFreqs, 'Tau_LBL%Tau', &
          & moduleName )
        call allocate_test ( tau_LBL%i_stop, maxNoPtgFreqs, 'Tau_LBL%I_Stop', &
          & moduleName )
      end if

      call allocate_test ( inc_rad_path, max_c, &
        & max(maxNoPtgFreqs,noUsedChannels), 'Inc_Rad_Path', moduleName )

      call allocate_test ( k_temp_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & merge(sv_t_len,0,temp_der), 'k_temp_frq', &
                         & moduleName )

      ! Allocate temporary derivative arrays with zero size if they're
      ! not needed.  We can't simply leave them unallocated since they're
      ! used as actual arguments to One_Frequency.  They are allocated with
      ! zero extent in second dimension if they're not needed, because the
      ! first dimension is subscripted.

      ! SV_Dim is calculated as it is here because if the various flags
      ! indicating requests for derivatives are false the VALUES component
      ! of the Grids_t structures might not be associated.  In those cases,
      ! invoking the MERGE intrinsic function might require accessing an
      ! undefined or disassociated pointer.
      sv_dim = 0
      if ( atmos_der ) sv_dim = size(grids_f%values)
      call allocate_test ( k_atmos_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, 'k_atmos_frq', moduleName )

      sv_dim = 0
      if ( atmos_second_der ) sv_dim = size(grids_f%values)
      call allocate_test ( h_atmos_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, sv_dim, 'h_atmos_frq', moduleName )

      sv_dim = 0
      if ( spect_der_width ) sv_dim = size(grids_w%values)
      call allocate_test ( k_spect_dw_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, 'k_spect_dw_frq', moduleName )

      sv_dim = 0
      if ( spect_der_width_TDep ) sv_dim = size(grids_n%values)
      call allocate_test ( k_spect_dn_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, 'k_spect_dn_frq', moduleName )

      sv_dim = 0
      if ( spect_der_center ) sv_dim = size(grids_v%values)
      call allocate_test ( k_spect_dv_frq, max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, 'k_spect_dv_frq', moduleName )

    end subroutine Frequency_Setup_1

  ! ..........................................  Frequency_Setup_2  .....
    subroutine Frequency_Setup_2 ( GridFrequencies )

      ! Work out what frequencies we're using for
      ! frequency averaging case for this pointing

      real(r8), intent(in) :: GridFrequencies(:) ! from PointingGrids
      ! Include the VELOCITY shift correction in GridFrequencies!

      integer :: J, K, L, M

      j = -1
      k = SIZE(GridFrequencies)
      call purehunt ( min_ch_freq_grid, GridFrequencies, k, j, l )
      call purehunt ( max_ch_freq_grid, GridFrequencies, k, l, m )
      noFreqs = m - j + 1
      call allocate_test ( frequencies, noFreqs, "frequencies", moduleName )

      frequencies = GridFrequencies(j:m)

      if ( print_frq ) call dump ( frequencies, 'Frequencies' )

    end subroutine Frequency_Setup_2

  ! .............................................  Generate_TScat  .....
    include 'Generate_TScat.f9h'

  ! ........................................  Get_Channel_Centers  .....
    subroutine Get_Channel_Centers ( ThisSideband, ChannelCenters )

      integer, intent(in) :: ThisSideband ! +1 for USB, -1 for LSB
      real(r8), intent(out) :: ChannelCenters(:)

      integer :: Channel           ! Loop inductor and subscript
      integer :: Sig               ! Subscript for fwdModelConf%signals

      select case ( thisSideband )
      case ( -1, +1 ) ! OK
      case ( 0 )
        call Announce_Error ( &
          & 'Folded signal requested in non-frequency-averaged forward model' )
      case default
        call Announce_Error ( 'Bad value of signal%sideband' )
      end select

      do channel = 1, noUsedChannels
        sig = channels(channel)%signal
        channelCenters(channel) = firstSignal%lo + thisSideband * &
          & ( fwdModelConf%signals(sig)%centerFrequency + &
          &   fwdModelConf%signals(sig)%direction * &
          &   fwdModelConf%signals(sig)%frequencies(channels(channel)%used) )
      end do

    end subroutine Get_Channel_Centers

  ! ..............................................  One_Frequency  .....
    subroutine One_Frequency ( Ptg_i, Frq_i, Alpha_Path_c, Beta_Path_c,     &
      & C_Inds, Del_S, Del_Zeta, Do_GL, Frq, H_Path_C, Tan_Ht, IncOptDepth, &
      & P_Path, PFA, Ref_Corr, Sps_Path, Tau, T_Path_c, T_Script, Tanh1_c,  &
      & TT_Path_c, W0_Path_c, Z_Path, I_Start, I_End, Inc_Rad_Path, RadV,   &
      & dAlpha_dT_Path, H_Atmos_Frq, K_Atmos_Frq, K_Spect_dN_Frq,           &
      & K_Spect_dV_Frq, K_Spect_dW_Frq, K_Temp_Frq )

      ! Having arguments instead of using host association serves two
      ! purposes:  The array sizes are implicit, so we don't need explicitly
      ! to mention them, and the pointer attribute gets stripped during the
      ! trip through the CALL statement -- hopefully thereby helping optimizers.
      use Comp_Eta_And_Sps_m, only: Comp_Sps
      use Comp_Sps_Path_Sparse_m, only: Comp_Sps_Path_Sparse
      use CS_ExpMat_m, only: CS_ExpMat
      use Do_T_Script_m, only: Two_D_T_Script, Two_D_T_Script_Cloud
      use Dump_0, only: Dump_2x2xn
      use D_T_Script_dTNP_m, only: DT_Script_dT_Sparse
      use Dump_Path_m, only: Dump_Path, SPS_List
      use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, &
        & Get_Beta_Path_PFA, Get_Beta_Path_Polarized
      use Get_dAlpha_dF_m, only: Get_dAlpha_dF
      use Get_D_Deltau_Pol_m, only: Get_d_Deltau_Pol_dF, Get_d_Deltau_Pol_dT
      use Hessians_m, only: d2Rad_Tran_dF2, Get_d2Alpha_dF2
      use Interpolate_Mie_m, only: Interpolate_Mie
      use Load_Sps_data_m, only:  Load_One_Item_Grid
      use L2PC_m, only: L2PC_T
      use MCRT_m, only: MCRT_Der
      use Opacity_m, only: Opacity
      use Path_Contrib_m, only: Path_Contrib
      use Physics, only: H_Over_K
      use Rad_Tran_m, only: Rad_Tran_Pol, dRad_Tran_dF, dRad_Tran_dT, &
        & dRad_Tran_dX
      use ScatSourceFunc, only: T_Scat, Interp_TScat
      use Tau_m, only: Get_Tau
      use TScat_Support_m, only: Get_dB_dT, Get_TScat, Get_TScat_Setup, &
        & Get_TScat_Teardown, Mie_Freq_Index

      integer, intent(in) :: Ptg_i        ! Pointing index
      integer, intent(in) :: Frq_i        ! Frequency loop index
      real(rp), intent(out) :: Alpha_Path_c(:) ! \sum Beta_Path * mixing ratio
      real(rp), intent(out) :: Beta_Path_c(:,:) ! path x species
      integer, intent(in) :: C_Inds(:)    ! Selectors from complete path to coarse path
      real(rp), intent(in) :: Del_S(:)    ! Integration lengths along path
      real(rp), intent(in) :: Del_Zeta(:) ! Integration lengths in Zeta coords
      logical, intent(out) :: Do_GL(:)    ! Where to do GL correction
      real(r8), intent(in) :: Frq         ! The frequency
      real(rp), intent(in) :: H_Path_C(:) ! Heights on coarse path
      real(rp), intent(in) :: Tan_Ht      ! Geometric tangent height, km,
                                          ! from equivalent Earth center
      real(rp), intent(out) :: IncOptDepth(:)  ! Incremental optical depth
      real(rp), intent(in) :: P_Path(:)   ! Pressures along complete path
      logical, intent(in) :: PFA          ! Are we doing PFA or not?
      real(rp), intent(in) :: Ref_Corr(:) ! Refraction correction
      real(rp), intent(inout) :: Sps_Path(:,:) ! Species on path
      type(tau_t), intent(inout) :: Tau   ! Optical depth, inout so as not to
                                          ! undefine components' association status
      real(rp), intent(in) :: T_Path_c(:) ! Temperature on coarse path
      real(rp), intent(out) :: T_Script(:)! Planck function, Delta_B in some notes
      real(rp), intent(out) :: TT_Path_c(:) ! TScat on coarse path
      real(rp), intent(out) :: Tanh1_c(:) ! tanh(frqhk/t_path_c)
      real(rp), intent(out) :: W0_Path_c(:) ! w0 on coarse path
      real(rp), intent(in) :: Z_Path(:)   ! -Log10(Pressures) along complete path
      integer, intent(in) :: I_Start      ! Start of coarse path integration
      integer, intent(inout) :: I_End     ! End of coarse path integration
      ! INC_RAD_Path is (out) if .not. PFA, and (inout) if PFA
      real(rp), intent(inout) :: Inc_Rad_Path(:) ! Incremental radiance along the path
      real(rp), intent(out) :: RadV       ! Radiance
      real(rp), intent(out), target :: dAlpha_dT_Path(:) ! dAlpha/dT on
                                          ! composite coarse & fine path
      real(rp), intent(out) :: H_Atmos_Frq(:,:) ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr
      real(rp), intent(out) :: K_Atmos_Frq(:)  ! dI/dVMR, ptg.frq X vmr-SV
      real(rp), intent(out) :: K_Spect_dN_Frq(:) ! ****
      real(rp), intent(out) :: K_Spect_dV_Frq(:) ! ****
      real(rp), intent(out) :: K_Spect_dW_Frq(:) ! ****
      real(rp), intent(out) :: K_Temp_Frq(:)   ! dI/dT, ptg.frq X T-SV

      integer, pointer :: CG_Inds(:) ! Indices on coarse grid where GL needed
      real(rp), pointer :: dAlpha_dT_Path_c(:)
      real(r8) :: FrqHK              ! 0.5 * Frq * H_Over_K
      integer, pointer :: GL_Inds(:) ! Indices of GL points within combined
                                     ! coarse & fine path that are GL points for
                                     ! panels needing GL -- subset of f_inds.
      integer :: I                   ! Loop inductor and subscript
      integer :: I_Stop              ! Stop path integration before I_End
      integer :: J, L                ! Loop inductor and subscript
      integer :: Me = -1             ! String index for trace
      integer :: Mie_Frq_Index       ! Index of Frq in F_s in Read_Mie
      integer :: NCG                 ! Number of panels needing GL = Size(cg_inds)
      integer :: NGL                 ! Total # of GL points = Size(gl_inds)
      integer :: P_Stop              ! Where to stop in polarized case
      logical :: PFA_or_not_pol      ! PFA .or. .not. fwdModelConf%polarized
      real(rp) :: PhiWindowRadians
      integer :: RadInL2PC           ! Which TScat radiance in L2PC to use
      complex(rp) :: Rad_Pol(2,2)    ! polarized radiance output of mcrt for one freq and pointing
        ! (-1,:,:) are Sigma_-, (0,:,:) are Pi, (+1,:,:) are Sigma_+

      type (Vector_T) :: dX, TScat   ! Clones of Column, Row vectors from TScat L2PC

      type(L2PC_t), pointer :: L2PC  ! The selected TScat L2PC

      ! Cloud stuff
      logical, parameter :: Cld_Fine = .false.
      real(r8), parameter :: TOL = 1.D-190

      call Trace_Begin ( me, 'ForwardModel.One_Frequency=', index=frq_i, &
        & cond=toggle(emit) .and. levels(emit) > 4 )

      pfa_or_not_pol = pfa .or. .not. fwdModelConf%polarized

      do_gl = .false.

      ! Set up path quantities --------------------------------------

      phi_path_c => phi_path(1:npf:ngp1)
      dAlpha_dT_Path_c => dAlpha_dT_Path(1:npf:ngp1)

      ! Compute the sps_path for this Frequency for all frequency-dependent sps
      call comp_sps_path_sparse ( grids_f, frq, eta_zp, eta_fzp, &
                                & sps_path(1:npf,:), firstSignal%lo, thisSideband )

      associate ( sps_path_x => sps_path(1:npf:ngp1,:) )
        sps_path_c(i_start:i_end,:) = sps_path_x(i_start:i_end,:)
      end associate
      sps_path_c(:i_start-1,:) = 0.0
      sps_path_c(i_end+1:npc,:) = 0.0

      if ( pfa ) then
        call get_beta_path_PFA ( frq, frq_i, z_path, c_inds, t_path_c, &
          & beta_group, sx, vel_rel, sps_path, beta_path_c,            &
          & t_der_path_flags, dBeta_dT_path_c, dBeta_dw_path_c,        &
          & dBeta_dn_path_c, dBeta_dv_path_c, dBeta_dIWC_path_c )
      else
        frqhk = 0.5_r8 * frq * h_over_k    ! h nu / 2 k
        tanh1_c = tanh( frqhk / t_path_c ) ! tanh ( h nu / 2 k T )
        ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
        if ( temp_der ) dTanh_dT_c(:npc) = &
            & frqhk / t_path_c**2 * ( tanh1_c - 1.0_rp / tanh1_c )
        call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_c,      &
          &  tanh1_c, beta_group, sx, fwdModelConf%polarized, gl_slabs,  &
          &  c_inds, beta_path_c, t_der_path_flags,                      &
          &  dTanh_dT_c, vel_rel, dBeta_dT_path_c, dBeta_dw_path_c,      &
          &  dBeta_dn_path_c, dBeta_dv_path_c, dBeta_df_path_c,          &
          &  grids_f%where_dBeta_df, sps_path(:npf,:) )
      end if

      if ( FwdModelConf%incl_cld .and. .not. pfa ) then
        ! Compute Scattering source function based on temperature profile
        ! at all angles U for each temperature layer assuming a plane
        ! parallel atmosphere.

        if ( ptg_i == 1 ) then
        ! ??? Can this work?  On all pointings after the first one, ???
        ! ??? it uses the result for the first frequency.           ???
        ! ??? We have a different frequency grid for each pointing, ???
        ! ??? so is this the wrong idea in the first place?         ???

          call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),      &
             & 10.0**(-temp%template%surfs), vmrArray(:,1), vmrArray(:,2), &
             & vmrArray(:,3),fwdModelConf%num_scattering_angles,           &
             & fwdModelConf%num_azimuth_angles,                            &
             & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,      &
             & fwdModelConf%no_cloud_species,                              &
             & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang )

        end if

        call load_one_item_grid ( grids_tscat, scat_src, maf, phitan, &
          & fwdModelConf, SetDerivFlags=.false., SetTscatFlag=.true. )

        call comp_sps ( grids_tscat, tan_pt_f, z_path(1:npf), &
                      & phi_path(1:npf), tscat_path(1:npf,:) )

        ! project Tscat onto LOS
        call interp_tscat ( tscat_path(1:npf,:), Scat_ang(:), &
          & phi_path(1:npf), tt_path_f(1:npf,:) )

        if ( .not. cld_fine ) then  ! interpolate onto gl grids along the LOS

          scat_alb%template = temp%template
          cld_ext%template  = temp%template

          call load_one_item_grid ( grids_salb,  scat_alb, maf, phitan, fwdModelConf, .false.)
          call load_one_item_grid ( grids_cext,  cld_ext,  maf, phitan, fwdModelConf, .false.)

          where ( abs(grids_salb%values) < TOL ) grids_salb%values = 0.0
          where ( abs(grids_cext%values) < TOL ) grids_cext%values = 0.0

          call comp_sps ( Grids_salb, tan_pt_f, z_path(1:npf), &
            &  phi_path(1:npf), salb_path(1:npf,:) )

          call comp_sps ( Grids_cext, tan_pt_f, z_path(1:npf), &
            &  phi_path(1:npf), cext_path(1:npf,:) )

          beta_path_cloud_c(1:npc) = cext_path(1:npf:ngp1,1)
          w0_path_c(1:npc) = salb_path(1:npf:ngp1,1)
          tt_path_c(1:npc) = tt_path_f(1:npf:ngp1,1)

        else

          ! cld_fine              re-compute cext and w0 along the LOS
          call get_beta_path_cloud ( Frq, t_path(1:npf), tt_path_f(1:npf,:), &
            &  c_inds, beta_path_cloud_c(1:npc), w0_path_c, tt_path_c,     &
            &  IPSD(1:npf),  WC(:,1:npf), fwdModelConf )

        end if

        do j = 1, npc ! Don't trust compilers to fuse loops
          alpha_path_c(j) = dot_product( sps_path_c(j,:), &
                                &        beta_path_c(j,:) )     &
                                & + beta_path_cloud_c(j)
          incoptdepth(j) = alpha_path_c(j) * del_s(j)
        end do

        ! Needed to compute inc_rad_path and by rad_tran_pol
        ! Don't restrict this to (i_start:i_end) because the end points
        ! at 1 and npc are special.
        call two_d_t_script_cloud ( t_path_c, tt_path_c, w0_path_c, &
          & spaceRadiance%values(1,1), frq, t_script, B(:npc) )

      else ! Not full cloud model

        !{ {\tt incoptdepth} is $\Delta \delta_{s\rightarrow s-1} =
        !  \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
        !    \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
        !  $G(\zeta)$ is {\tt Alpha_path_c}, which is approximated
        !  here by the rectangle rule, \emph{viz.}
        !  $\Delta \delta_{i\rightarrow i-1} \approx G(\zeta_i) \delta s_i$.

        do j = i_start, i_end ! Don't trust compilers to fuse loops
          alpha_path_c(j) = dot_product( sps_path_c(j,:), &
                                       & beta_path_c(j,:) )
          incoptdepth(j) = alpha_path_c(j) * del_s(j)
        end do
        incoptdepth(:i_start-1) = 0.0  ! in case not integrating full path
        incoptdepth(i_end+1:npc) = 0.0 ! in case not integrating full path

        if ( fwdModelConf%useTScat .and. .not. pfa ) then
          include 'Using_TScat.f9h'
        else ! Not TScat model

          !{ Compute $\Delta B_{ij}$ for $j$ = Frq_i.  See page 42 in
          !  19 August 2004 ATBD JPL D-18130.
          !  T_Script and B needed to compute inc_rad_path by rad_tran_pol.
          !  Don't restrict this to (i_start:i_end) because the end points
          !  at 1 and npc are special.
          call two_d_t_script ( t_path_c(i_start:i_end), &
            & spaceRadiance%values(1,1), frq, &
            & t_script(i_start:i_end), &
            & B(i_start:i_end) )

        end if

      end if ! end of check cld

      if ( .not. fwdModelConf%polarized ) then
        ! Determine where to use Gauss-Legendre for scalar instead of a trapezoid.

        call path_contrib ( incoptdepth, tan_pt_c, i_start, i_end, &
          &                 e_rflty, fwdModelConf%tolerance, do_gl )

      else ! Extra stuff for polarized case
           ! Can't be doing TScat, so process the whole path

        call get_beta_path_polarized ( frq, h, beta_group%lbl(sx), gl_slabs, &
          & c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )

        ! We put an explicit extent of -1:1 for the first dimension in
        ! the hope a clever compiler will do better optimization with
        ! a constant extent.
        ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
        ! to Alpha here.

        do j = 1, npc
          alpha_path_polarized_c(-1:1,j) = &
            & matmul( beta_path_polarized(-1:1,j,:), sps_path_c(j,:) ) *  &
            & tanh1_c(j) + 0.25 * alpha_path_c(j)
          alpha_path_polarized_c(0,j) = alpha_path_polarized_c(0,j) + &
            & 0.25 * alpha_path_c(j)
        end do

        ! Turn sigma-, pi, sigma+ into 2X2 matrix incoptdepth_pol
        call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
          & alpha_path_polarized_c(:,1:npc), incoptdepth_pol(:,:,1:npc) )

        ! We don't add unpolarized incremental optical depth to diagonal
        ! of polarized incremental optical depth because we added the
        ! scalar Alpha_path to the sigma-, pi and sigma+ parts of
        ! Alpha_Path_Polarized_c above.  If we did add it here, we would
        ! need 0.5 factors to scale unpolarized "power absorption" to
        ! get "field absorption"

        do j = 2, npc-1
          incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j)
          incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j) * del_s(j)
          incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j) * del_s(j)
          incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j)
        end do

        if ( print_incopt ) call dump_2x2xn ( incoptdepth_pol, 'IncoptDepth_Pol' )

        do j = 2, npc-1
          ! deltau_pol = exp(incoptdepth_pol)
          call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
        end do

        if ( print_deltau_pol > -1 ) call dump_2x2xn ( deltau_pol, 'Deltau_Pol' )

        ! Determine where to do GL
        call path_contrib ( deltau_pol(:,:,1:npc), tan_pt_c, e_rflty, &
           & fwdModelConf%tolerance, do_gl )

      end if

      !{ We want $\Delta \delta_{s\rightarrow s-1} = \int_{\zeta_i}^{\zeta_{i-1}}
      ! G(\zeta) \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      ! \text{d} \zeta$ where $G(\zeta)$ is {\tt Alpha_path_c}.  We start with a
      ! rectangular estimate $\Delta \delta_{s\rightarrow s-1} \approx\alpha(s_i)
      ! \, \delta s_i$.  Where this is sufficiently accurate, it is replaced with
      ! a trapezoidal estimate $(\alpha(s_i) + \alpha(s_{i-1}))\, \delta s_i$. 
      ! Where GL is needed, we compute $\Delta \delta_{s\rightarrow s-1} =
      ! G(\zeta_i)\, \delta s_i + \int_{\zeta_i}^{\zeta_{i-1}}
      ! \left(G(\zeta)-G(\zeta_i)\right) \frac{\text{d}s}{\text{d}h}
      ! \frac{\text{d}h}{\text{d}\zeta} \,\text{d} \zeta$.  This cancels the
      ! singularity in $\frac{\text{d}s}{\text{d}h}$ at the tangent point,
      ! assuming $\left(G(\zeta)-G(\zeta_i) \right) \frac{\text{d}s}{\text{d}h}
      ! \rightarrow 0$ at the tangent point.
      !
      ! At one time, for the trapezoidal estimate, we inscrutably used
      ! dsdz_c~*~del_z as an approximation for del_s (compare to computation of
      ! rectangular estimate above) but we don't do that any longer because
      ! $\frac{\text{d}s}{\text{d}h}$ is singular at the tangent, therefore
      ! $\frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}\, \delta z
      ! \neq \delta s$. We maybe could have used sum(dsdz_gw_path) as a GL
      ! estimate of $\int \frac{\text{d}s}{\text{d}h}
      ! \frac{\text{d}h}{\text{d}\zeta}\,{\text{d}\zeta}$, but del_s is simpler.

      if ( WrongTrapezoidal ) then
        do j = i_start+1, min(i_end,tan_pt_c)
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = incoptdepth(j) + &
              & ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1) * del_zeta(j)
        end do
        do j = tan_pt_c+1, i_end-1
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = incoptdepth(j) + &
              & ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1) * del_zeta(j)
        end do
      else
        ! Before the tangent point, del_s(j) is the path length from J-1 to J
        do j = i_start+1, min(i_end,tan_pt_c)
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = &
              & ( alpha_path_c(j-1) + alpha_path_c(j) ) * 0.5 * del_s(j)
        end do
        ! After the tangent point, del_s(j) is the path length from J to J+1
        do j = tan_pt_c+1, i_end-1
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = &
              & ( alpha_path_c(j+1) + alpha_path_c(j) ) * 0.5 * del_s(j)
        end do
      end if

      if ( dump_ds ) then
        write ( 42, '(5(a,i0))' ) &
          & 'dsdz_c(', i_start, ':', min(i_end,tan_pt_c)-1, ') * del_zeta(', &
          & i_start+1, ':', min(i_end,tan_pt_c), ') \', &
          & min(i_end,tan_pt_c)-1 - i_start + 1
        write ( 42, '(1p5g15.6)' ) &
          & dsdz_c(i_start:min(i_end,tan_pt_c)-1)*del_zeta(i_start+1:min(i_end,tan_pt_c))
        write ( 42, '(5(a,i0))' ) &
          & 'dsdz_c(', tan_pt_c+2,':',i_end,') * del_zeta(', &
          & tan_pt_c+1, ':', i_end-1, ') \', i_end - tan_pt_c - 1
        write ( 42, '(1p5g15.6)' ) dsdz_c(tan_pt_c+2:i_end)*del_zeta(tan_pt_c+1:i_end-1)
        write ( 43, '(2(a,i0),a,i0)' ) &
          & 'del_s(', i_start+1, ':', min(i_end,tan_pt_c), ') \', &
          & min(i_end,tan_pt_c) - i_start
        write ( 43, '(1p5g15.6)' ) 0.5*del_s(i_start+1:min(i_end,tan_pt_c))
        write ( 43, '(2(a,i0),a,i0)' ) &
          & 'del_s(', tan_pt_c+1,':',i_end-1,') \', i_end - tan_pt_c - 1
        write ( 43, '(1p5g15.6)' ) 0.5*del_s(tan_pt_c+1:i_end-1)
      end if

      ! Get indices for GL points only for panels that need GL, then copy
      ! temperature and mixing ratios only for those points to T_Path_f and
      ! Sps_Path_f
      do_gl(1:npc:npc-1) = .false.
      call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, ngl, cg_inds_b, ncg, where_gl )
      cg_inds => cg_inds_b(:ncg)
      gl_inds => gl_inds_b(:ngl)
      ! ngl is ng * count(do_gl)
      t_path_f(:ngl) = t_path(gl_inds)
      sps_path_f(:ngl,:) = sps_path(gl_inds,:)

      if ( pfa ) then

        call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds, t_path_f(:ngl), &
          & beta_group, sx, vel_rel, sps_path, beta_path_f(:ngl,:),           &
          & t_der_path_flags, dBeta_dT_path_f, dBeta_dw_path_f,               &
          & dBeta_dn_path_f, dBeta_dv_path_f, dBeta_dIWC_path_f )

      else

        tanh1_f(1:ngl) = tanh( frqhk / t_path_f(:ngl) )
        ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
        if ( temp_der ) &
          & dTanh_dT_f(1:ngl) = frqhk / t_path_f(1:ngl)**2 * &
            & ( tanh1_f(1:ngl) - 1.0_rp / tanh1_f(1:ngl) )

        ! The derivatives that get_Beta_path computes depend upon which
        ! derivative arrays are allocated, not which ones are present.
        ! This avoids having multiple paths through the code, each with a
        ! different set of optional arguments.

        call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_f(:ngl),     &
          & tanh1_f(1:ngl), beta_group, sx, fwdModelConf%polarized, gl_slabs, &
          & gl_inds, beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,       &
          & vel_rel, dBeta_dT_path_f, dBeta_dw_path_f, dBeta_dn_path_f,       &
          & dBeta_dv_path_f, dBeta_df_path_f, grids_f%where_dBeta_df,         &
          & sps_path )

      end if ! .not. pfa

      do j = 1, ngl ! loop around dot_product instead of doing sum(a*b,2)
                    ! to avoid path-length array temps
        alpha_path_f(j) = dot_product( sps_path_f(j,:), beta_path_f(j,:) )
        alpha_path(gl_inds(j)) = alpha_path_f(j)
      end do

      if ( print_incopt ) then
        call sps_list ( fwdModelConf )
        call output ( tan_pt_c, before='Tan_pt_c = ' )
        call output ( tan_pt_f, before=' Tan_pt_f = ', advance='yes' )
        call dump ( beta_path_c(i_start:i_end,:), name="Beta_Path_C", lbound=i_start )
        call dump ( sps_path_c(i_start:i_end,:), name="SPS_Path_C", lbound=i_start )
        call dump ( alpha_path_c(i_start:i_end), name="Alpha_Path_C", lbound=i_start )
        call dump ( incoptdepth(i_start+1:i_end-1), name="Incoptdepth", lbound=i_start+1 )
        call dump ( del_s(i_start+1:i_end-1), name="Del_s", lbound=i_start+1 )
        call dump ( gl_inds(:ngl), name="GL_Inds -- fine path indices needing GL integrands" )
        call dump ( cg_inds, name="CG_Inds -- coarse path indices needing GL" )
      end if

      if ( .not. fwdModelConf%polarized ) then

      ! Compute SCALAR radiative transfer --------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! TScat computation wants only incoptdepth(i_start+1:i_end-1),
!!!! but this breaks the gold brick
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        call get_tau ( frq_i, gl_inds, cg_inds, i_start, e_rflty,  &
          & del_zeta, alpha_path, ref_corr(:i_end), incoptdepth(:i_end), &
          & tan_pt_c, dsdz_gw_path, tau )

        i_stop = tau%i_stop(frq_i) ! total_opacity(i_stop) < underflow for exp

        radV = 0.0
        if ( .not. pfa .or. .not. fwdModelConf%anyLBL(sx) ) then
          ! Not doing PFA, or doing PFA but haven't done LBL.
          ! Get incremental radiance and radiance from Tau and T_Script.
          ! Don't clobber them if doing PFA and already did LBL.  If
          ! doing LBL, inc_rad_path will be frequency averaged to give
          ! Rad_Avg_Path.
          do j = i_start, i_stop
            inc_rad_path(j) = t_script(j) * tau%tau(j,frq_i)
            radV = radV + inc_rad_path(j)
          end do ! j
        end if

        if ( pfa .and. iand(frq_avg_sel,7) == 7 ) then ! See Frequency_Average.
          ! Doing PFA and did LBL and need derivatives.  Multiply Inc_Rad_Path
          ! by Tau to combine LBL and PFA.  Then sum to give RadV.
          ! Inc_Rad_Path is channel(-averaged) LBL radiance. Remember, when
          ! doing PFA, Frq_I is a channel number, and tau is tau_PFA.  See
          ! wvs-026 and wvs-027.
          do j = i_start, i_stop
            inc_rad_path(j) = inc_rad_path(j) * tau%tau(j,frq_i)
            radV = radV + inc_rad_path(j)
          end do ! j
        end if

        inc_rad_path(:i_start-1) = 0.0
        inc_rad_path(i_stop+1:) = 0.0

        if ( print_incRad ) then
          call dump ( tau%tau(i_start:i_stop,frq_i), name="Tau", lbound=i_start )
          call dump ( inc_rad_path(i_start:i_stop), name="Inc_Rad_Path", lbound=i_start )
          call dump ( t_script(i_start:i_stop), name="T_Script", lbound=i_start )
          call output ( frq_i, before="RadV(" )
          call output ( radV, before=") = ", advance="yes" )
        end if

        if ( print_path > -1 ) then
          call dump_path ( print_path, fwdModelConf, &
            & i_start, i_stop, i_end, phi_path_c, z_path(1:npf:ngp1),       &
            & sps_path_c(:npc,:), beta_path_c, alpha_path_c, incoptdepth,   &
            & inc_rad_path, t_path_c, frq_i, tau, frq )
            if ( print_path > 0 ) stop
        end if

      else ! Polarized model; can't combine with PFA or TScat

      ! Compute POLARIZED radiative transfer -----------------------------

        i_stop = npc ! needed by drad_tran_df.  We don't compute a total opacity
                     ! black out point for polarized like we do for scalar.

        ! Get the corrections to integrals for layers that need GL for
        ! the polarized species.
        call get_beta_path_polarized ( frq, h,beta_group%lbl(sx), gl_slabs, &
          & gl_inds, beta_path_polarized_f, dBeta_dT_polarized_path_f )

        ! We put an explicit extent of -1:1 for the first dimension in
        ! the hope a clever compiler will do better optimization with
        ! a constant extent.
        ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
        ! to Alpha here.
        do j = 1, ngl
          alpha_path_polarized_f(-1:1,j) = &
            & matmul( beta_path_polarized_f(-1:1,j,:), &
            &         sps_path_f(j,:) ) * tanh1_f(j) &
            & + 0.25 * Alpha_path_f(j)
          alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) +               &
            & 0.25 * alpha_path_f(j)
          alpha_path_polarized(-1:1,gl_inds(j)) = alpha_path_polarized_f(-1:1,j)
        end do

        call rad_tran_pol ( tan_pt_c, gl_inds, cg_inds, e_rflty, del_zeta,   &
          & alpha_path_polarized(:,1:npf), ref_corr,                         &
          & incoptdepth_pol(:,:,1:npc), deltau_pol(:,:,1:npc), dsdz_gw_path, &
          & ct, stcp, stsp, t_script, dump_rad_pol, prod_pol(:,:,1:npc),     &
          & tau_pol(:,:,1:npc), rad_pol, p_stop )

        if ( p_stop < 0 ) then ! exp(incoptdepth_pol(:,:,-p_stop)) failed
          call output ( 'Exp(incoptdepth_pol(:,:,' )
          call output ( -p_stop )
          call output ( ') failed.  Value is', advance='yes' )
          call dump ( incoptdepth_pol(:,:,-p_stop), options='c' ) ! clean=.TRUE.
          call output ( thisSideband, before='thisSideband = ' )
          call output ( ptg_i, before=', ptg_i = ' )
          call output ( frq_i, before=', frq_i = ', advance='true' )
          call dump ( t_path_c(:npc), name='T_Path' )
          call dump ( ref_corr(:npc), name='Ref_Corr' )
          call dump ( n_path_c(:npc), name='N_Path' )
          call dump ( h_path_c(:npc), name='H_Path' )
          call Announce_Error ( 'exp(incoptdepth_pol) failed' )
        end if

        if ( print_pol_rad > -1 ) then
          call output ( 'Radiance' )
          do j = 1, 2
            do i = 1, 2
              call output ( i, before=' (' )
              call output ( j, before=',' )
              call output ( real(rad_pol(i,j)), before=' (' )
              call output ( aimag(rad_pol(i,j)), before=',', after=')' )
            end do
          end do
          if ( print_pol_rad > 0 ) call output ( ptg_i, before=' Pointing ' )
          if ( print_pol_rad > 1 ) call output ( frq_i, before=' Frequency ' )
          call newLine
        end if

        if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
          radV = real(rad_pol(1,1))
        else
          radV = real(rad_pol(2,2))
        end if

      end if

      ! Compute derivatives if needed ----------------------------------

      if ( atmos_der ) then

        ! On coarse grid points
        call get_dAlpha_df ( sps_path_c(:npc,:), beta_path_c(:npc,:), &
          &                  dBeta_df_path_c(:npc,:), Grids_f,      &
          &                  dAlpha_df_path_c(:npc,:) )

        ! On fine grid points for panels where GL is needed.  Data for these
        ! have been extracted from the composite path and stored contiguously.
        call get_dAlpha_df ( sps_path_f(:ngl,:), beta_path_f(:ngl,:), &
          &                  dBeta_df_path_f(:ngl,:), Grids_f,      &
          &                  dAlpha_df_path_f(:ngl,:) )

        ! Put dAlpha_df_path_f into their correct places in dAlpha_df_path
        dAlpha_df_path(gl_inds,:) = dAlpha_df_path_f(:ngl,:)

        if ( fwdModelConf%useTScat ) then ! TScat and not polarized

          call drad_tran_df ( gl_inds, del_zeta, Grids_f, eta_fzp, do_gl,   &
            &  del_s, ref_corr, dsdz_gw_path, inc_rad_path, dAlpha_df_path, &
            &  i_start, tan_pt_c, i_stop, k_atmos_frq, dB_df,               &
            &  tau=tau%tau(:,frq_i), alpha_path_c=alpha_path_c,             &
            &  beta_c_e=beta_c_e_path_c(:npc),                              &
            &  dBeta_c_a_dIWC=dBeta_c_a_dIWC_path_c(:npc),                  &
            &  dBeta_c_s_dIWC=dBeta_c_s_dIWC_path_c(:npc),                  &
            &  dTScat_df=dTScat_df, w0=w0_path_c(:npc) )

        else if ( fwdModelConf%polarized .or. atmos_second_der ) then
          ! ( polarized or Hessians ) and not TScat
          ! print *, 'Calling drad_tran_df polarized'

          call drad_tran_df ( gl_inds, del_zeta, Grids_f, eta_fzp, do_gl,   &
            &  del_s, ref_corr, dsdz_gw_path, inc_rad_path, dAlpha_df_path, &
            &  i_start, tan_pt_c, i_stop, k_atmos_frq, dB_df, d_delta_df )

        else ! ! not TScat and not polarized

          call drad_tran_df ( gl_inds, del_zeta, Grids_f, eta_fzp, do_gl,   &
            &  del_s, ref_corr, dsdz_gw_path, inc_rad_path, dAlpha_df_path, &
            &  i_start, tan_pt_c, i_stop, k_atmos_frq, dB_df )

        end if

        if ( atmos_second_der ) then

          call get_d2Alpha_df2 ( sps_path_c(:npc,:), beta_path_c(:npc,:), &
            &                  dBeta_df_path_c(:npc,:), Grids_f,      &
            &                  d2Alpha_df2_path_c(:npc,:) )

          call get_d2Alpha_df2 ( sps_path_f(:ngl,:), beta_path_f(:ngl,:), &
            &                  dBeta_df_path_f(:ngl,:), Grids_f,      &
            &                  d2Alpha_df2_path_f(:ngl,:) )


          call d2rad_tran_df2 ( gl_inds, del_zeta, Grids_f, eta_fzp, do_gl, &
            &  del_s, ref_corr, dsdz_gw_path, inc_rad_path,                 &
            &  d2Alpha_df2_path_c(:npc,:), d2Alpha_df2_path_f, i_start,     &
            &  tan_pt_c, i_stop, d_delta_df, d2_delta_df2, h_atmos_frq )

        end if ! atmos_second_der

        if ( .not. pfa_or_not_pol ) then ! polarized and not PFA

          ! This block of code is returning faulty results.
          ! Unfortunately it was coded in a way that does not parallel
          ! how vmr derivatives are coded for  non-polarized forward models
          ! which makes debugging even harder.
!           print *, 'VMR derivatives for polarized radiance.'
!           print *, shape(de_df(:,:,1:p_stop,:))
          ! VMR derivatives for polarized radiance.
          ! Compute DE / Df from D Incoptdepth_pol / Df and put it
          ! into DE_DF.
          call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, Grids_f, tan_pt_c,        &
            &  beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc),               &
            &  eta_fzp, sps_path, del_s, incoptdepth_pol(:,:,1:p_stop),        &
            &  ref_corr(1:p_stop), d_delta_df, de_df(:,:,1:p_stop,:) )

          ! Compute D radiance / Df from Tau, Prod, T_Script
          ! and DE / Df.
!           print *, 'Compute D radiance / Df.'
!           print *, shape(de_df(:,:,1:npc,:))
          call mcrt_der ( t_script, sqrt(e_rflty),             &
            & deltau_pol(:,:,1:npc), de_df(:,:,1:npc,:),       &
            & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &
            & tan_pt_c, d_rad_pol_df )

          if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
            ! print *, 'l_a'
            k_atmos_frq(:) = real(d_rad_pol_df(1,1,:))
          else
            ! print *, 'not l_a'
            k_atmos_frq(:) = real(d_rad_pol_df(2,2,:))
          end if
!           if ( any(abs(k_atmos_frq(:)) > 0.) ) &
!             & print *, 'non-zero'

        end if ! polarized and not PFA

      end if ! atmos_der

      if ( temp_der ) then

        dAlpha_dT_path_c(:npc) = sum( sps_path_c(:npc,:) *  &
                                      dBeta_dT_path_c(1:npc,:),dim=2 )
        dAlpha_dT_path_f(:ngl) = sum( sps_path_f(:ngl,:) * &
                                      dBeta_dT_path_f(1:ngl,:),dim=2 )
        ! Put dAlpha_dT_path_f, values for GL points only, back into the
        ! composite path
        dAlpha_dT_path(gl_inds) = dAlpha_dT_path_f(:ngl)

        ! get d Delta B / d T * d T / eta
        if ( fwdModelConf%useTScat ) then

          call get_dB_dT ( alpha_path_c, B(:npc), t_path_c(:npc), frq,    &
                         & beta_c_e_path_c(:npc), dAlpha_dT_Path_c(:npc), &
                         & dBeta_c_a_dT_path_c(:npc),                     &
                         & dBeta_c_s_dT_path_c(:npc), tt_path_c(:npc),    &
                         & dTScat_dT(:npc,:), w0_path_c(:npc),            &
                         & eta_zp_T, i_start, i_stop, d_t_scr_dt(1:npc,:) )

        else

          call dT_script_dT_sparse ( t_path_c(:npc), B(:npc), eta_zp_T,         &
                                   & i_start, i_stop, frq, d_t_scr_dt(1:npc,:), &
                                   & skip=ngp1 )

        end if

        if ( pfa_or_not_pol ) then

          call drad_tran_dt ( gl_inds, del_zeta, h_path_c, dh_dt_path, &
            & alpha_path(1:npf), dAlpha_dT_path(:npf), eta_zp_T,       &
            & del_s, ref_corr, tan_ht, tan_pt_f, do_gl, h_path(:npf),  &
            & t_path(:npf), dsdh_path, dhdz_gw_path, dsdz_gw_path,     &
            & d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i), inc_rad_path,  &
            & i_start, tan_pt_c, i_stop,  grids_tmp%deriv_flags,       &
            & pfa .and. iand(frq_avg_sel,7) == 7, k_temp_frq )

            ! pfa .and. iand(frq_avg_sel,7) == 7 means doing PFA and did LBL
            ! and need derivatives.

        else ! pol and not pfa

          ! Temperature derivatives for polarized radiance
          ! Compute DE / DT from D Incoptdepth_Pol / DT and put
          ! into DE_DT.

          dAlpha_dT_polarized_path_c(:,1:npc) = 0.0
          dAlpha_dT_polarized_path_f(:,1:ngl) = 0.0
          do j = 1, no_mol
            do l = -1, 1
              dAlpha_dT_polarized_path_c(l,1:npc) = &
            & dAlpha_dT_polarized_path_c(l,1:npc) + &
                & sps_path_c(:npc,j) * dBeta_dT_polarized_path_c(l,1:npc,j)
              dAlpha_dT_polarized_path_f(l,1:ngl) = &
            & dAlpha_dT_polarized_path_f(l,1:ngl) + &
                & sps_path_f(:ngl,j) * dBeta_dT_polarized_path_f(l,1:ngl,j)
            end do ! l
          end do ! j
          do l = -1, 1
            dAlpha_dT_polarized_path_c(l,1:npc) =               &
              & dAlpha_dT_polarized_path_c(l,1:npc) * tanh1_c + &
              & alpha_path_polarized_c(l,:npc) * dTanh_dT_c(:npc)
            dAlpha_dT_polarized_path_f(l,1:ngl) =                     &
              & dAlpha_dT_polarized_path_f(l,1:ngl) * tanh1_f(:ngl) + &
              & alpha_path_polarized_f(l,:ngl) * dTanh_dT_f(:ngl)
            ! Put GL for panels needing it back into composite path
            dAlpha_dT_polarized_path(l,gl_inds) = &
              & dAlpha_dT_polarized_path_f(l,1:ngl)
          end do

          call get_d_deltau_pol_dT ( ct, stcp, stsp, tan_pt_c,            &
            & t_path(:npf), alpha_path_polarized(:,1:npf),                &
            & dAlpha_dT_path(:npf), dAlpha_dT_polarized_path,             &
            & eta_zp_T, p_stop, del_s, gl_inds, del_zeta,                 &
            & do_gl(1:p_stop), dsdh_path, dhdz_gw_path, dsdz_gw_path,     &
            & incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),          &
            & h_path(:npf), dh_dt_path, tan_ht, tan_pt_f,                 &
            & grids_tmp%deriv_flags, de_dt(:,:,1:p_stop,:) )

          ! Compute D radiance / DT from Tau, Prod, T_Script, D_T_Scr_dT
          ! and DE / DT.

          call mcrt_der ( t_script, sqrt(e_rflty),             &
            & deltau_pol(:,:,1:npc), de_dt(:,:,1:npc,:),       &
            & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &
            & tan_pt_c, d_rad_pol_dt, d_t_scr_dt(1:npc,:) )

          if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
            k_temp_frq(:) = real(d_rad_pol_dt(1,1,:))
          else
            k_temp_frq(:) = real(d_rad_pol_dt(2,2,:))
          end if

        end if ! pol and not pfa

      end if ! temp_der

      if ( spect_der ) then

        if ( fwdModelConf%polarized ) then
          call Announce_Error ( &
            & "Spectroscopic derivatives for Polarized species not implemented yet." )
        else if ( pfa ) then
          call Announce_Error ( &
            & "Spectroscopic derivatives for PFA not implemented yet." )
        else

          ! Spectroscopic derivative  wrt: W
          if ( spect_der_width ) &
            & call dRad_Tran_dX ( gl_inds, del_zeta, grids_w, eta_zp_w,    &
              &  sps_path, fwdModelConf%lineWidth%beta(sx),                &
              &  dBeta_dw_path_c, dBeta_dw_path_f, do_gl, del_s, ref_corr, &
              &  dhdz_gw_path, inc_rad_path, tan_pt_c, i_stop, k_spect_dw_frq )

          ! Spectroscopic derivative  wrt: N
          if ( spect_der_width_TDep ) &
            & call dRad_Tran_dX ( gl_inds, del_zeta, grids_n, eta_zp_n,    &
              &  sps_path, fwdModelConf%lineWidth_tDep%beta(sx),           &
              &  dBeta_dn_path_c, dBeta_dn_path_f, do_gl, del_s, ref_corr, &
              &  dhdz_gw_path, inc_rad_path, tan_pt_c, i_stop, k_spect_dn_frq )

          ! Spectroscopic derivative  wrt: Nu0
          if ( spect_der_center ) &
            & call dRad_Tran_dX ( gl_inds, del_zeta, grids_v, eta_zp_v,    &
              &  sps_path, fwdModelConf%lineCenter%beta(sx),               &
              &  dBeta_dv_path_c, dBeta_dv_path_f, do_gl, del_s, ref_corr, &
              &  dhdz_gw_path, inc_rad_path, tan_pt_c, i_stop, k_spect_dv_frq )

        end if

      end if

      call Trace_End ( 'ForwardModel.One_Frequency=', index=frq_i, &
        & cond=toggle(emit) .and. levels(emit) > 4 )

    end subroutine One_Frequency

  ! ...............................................  One_Pointing  .....
    subroutine One_Pointing ( Ptg_i, Vel_Rel, R_Eq, Tan_Phi, Tan_Loc, QTM,  &
      & Tan_Press, Est_SCGeocAlt, Path, S, F_and_V, Scat_Zeta, Scat_Phi, &
      & Scat_Ht, Xi, Scat_Index, Scat_Tan_Ht, Forward, Rev, Which )

      use Comp_Eta_And_Sps_m, only: Comp_Sps
      use Comp_Eta_Docalc_Sparse_m, only: Comp_Eta
      use Comp_Sps_Path_Sparse_m, only: Comp_1_Sps_Path_Sparse_No_Frq
      use Generate_QTM_m, only: QTM_Tree_t
      use Get_Chi_Angles_M, only: Get_Chi_Angles
      use GLNP, only: GW
      use Load_SPS_Data_M, only: Load_One_Item_Grid, Load_SPS_Data
      use Metrics_m, only: Height_Metrics, More_Metrics, Tangent_Metrics
      use Metrics_3D_m, only: Metrics_3D_QTM, Horizontal
      use Min_Zeta_m, only: Lower_Path_Crossings
      use Path_Representation_m, only: Path_t
      use Phi_Refractive_Correction_M, only: Phi_Refractive_Correction
      use QTM_Tangent_Metrics_m, only: QTM_Tangent_Metrics
      use Read_Mie_M, only: IWC_S, T_S
      use Refraction_M, only: Comp_Refcor, MaxRefraction, Refractive_Index
      use Slabs_sw_M, only: Get_GL_SLABS_Arrays
      use TScat_Support_m, only: Find_Scattering_Point

      integer, intent(in) :: Ptg_i     ! Tangent height pointing index
      real(rp), intent(in) :: Vel_Rel  ! Vel_z / speedOfLight
       real(rp), intent(in) :: R_EQ    ! Equivalent Earth Radius at true surface
      real(rp), intent(in), optional :: Tan_Phi     ! orbit angle at tangent, radians
      class(h_v_geod), intent(in), optional :: Tan_Loc   ! (lon,Lat,ht)
                                       ! degrees and km, for QTM case
      type(QTM_tree_t), intent(inout), optional :: QTM ! for QTM case; only
        ! QTM%Path_Vertices is changed here.
      real(rp), intent(in), optional :: Tan_Press     ! hPa, not zeta
      real(rp), intent(in), optional :: Est_SCGeocAlt ! Est S/C geocentric
        ! altitude /m, used only to compute chi angles for convolution
      type(Path_t), intent(inout), optional :: Path    ! Path from
        ! instrument to tangent.  Path%Lines(1,1) is (probably) the instrument
        ! location.  Path%Lines(1,2) is a vector in the direction from the
        ! instrument to the tangent. Path%Lines(1,2) is the tangent or
        ! reflection point.  Path%Lines(2,2) is a vector in the direction of the
        ! ray after the tangent, which is either the same as Path%Lines(2,1), or
        ! the direction of the reflected ray.  Present iff UsingQTM.
      type(s_QTM_t), allocatable, intent(out), optional :: S(:) ! Positions on
        ! the line of sight are Path%Lines(:,1) + s%s*Path%Lines(:,2).
        ! Present if UsingQTM.
      type(facets_and_vertices_t), intent(in), optional :: F_and_V ! Indices
                                       ! of facets and vertices under Path.
                                       ! Present only for QTM.

      ! The following are all present iff fwdModelConf%generateTScat
      real(rp), intent(in), optional :: Scat_Zeta   ! of scattering point
      real(rp), intent(in), optional :: Scat_Phi    ! of scattering point
      real(rp), intent(in), optional :: Scat_Ht     ! To check we hit the
                                                    ! scattering point
      real(rp), intent(in), optional :: Xi          ! Scattering angle
      integer, intent(out), optional :: Scat_Index  ! in coarse grid
      real(rp), intent(in), optional :: Scat_Tan_Ht ! Tangent height above earth
                                                    ! geometric surface, km, for
                                                    ! subsurface rays and
                                                    ! generateTScat
      logical, intent(in), optional :: Forward      ! For subsurface rays
                                                    ! and Generate_TScat
      logical, intent(in), optional :: Rev          ! Reverse the path
      integer, intent(in), optional :: Which        ! Which TScat call got us here?
                                                    ! Negative if we're trying to
                                                    ! trace an Earth-intersecting ray.

      integer :: Frq_I          ! Frequency loop index
      integer :: I              ! Do index
      integer :: I_start, I_end ! Boundaries of coarse path to use
      integer :: J              ! Do index
      integer :: Me = -1        ! String index for trace
      integer :: Me_Etc = -1    ! String index for trace
      real(rp) :: REQ_S  ! Equivalent Earth Radius at height reference surface
      real(rp) :: Tan_Ht ! Geometric tangent height, km, from equivalent Earth center
      real(rp) :: Tan_Ht_S ! Tangent height above 1 bar reference surface, km

      call Trace_Begin ( me, 'ForwardModel.Pointing=', index=ptg_i, &
        & cond=toggle(emit) .and. levels(emit) > 3 )

      ! Assume it's not an earth-intersecting ray and min zeta is at
      ! the tangent point
      e_rflty = 1.0

      call Trace_Begin ( me_Etc, 'ForwardModel.Metrics_Etc', &
        & cond=toggle(emit) .and. levels(emit) > 4 )

      if ( .not. same_facets ) then ! Same_Facets is false only if UsingQTM
        call load_one_item_grid ( grids_tmp, temp, fmStat%maf, phitan, &
          & fwdModelConf, setDerivFlags=.true., subset=F_and_V%vertices )

        call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f, &
          & subset=F_and_V%vertices )
      end if

      ! Compute the index in the pressure grids where the tangent is,
      ! assuming Zeta_Only if QTM.
      tan_ind_c = max(1,ptg_i-surfaceTangentIndex+1) ! On coarse grid
      tan_ind_f = (tan_ind_c-1) * ngp1 + 1           ! On Z_GLgrid

      nz_ig = nlvl
      nz_if = (nz_ig-1) * ngp1 + 1                ! On Z_GLgrid
      tan_pt_f = nz_if + 1 - tan_ind_f            ! fine path tangent index
      tan_pt_c = (tan_pt_f + Ng) / Ngp1           ! coarse path tangent index
      npc = 2 * tan_pt_c
      npf = 2 * tan_pt_f + ng

      ! Coarse path extraction indices, assuming Zeta_Only if QTM
      c_inds => c_inds_b(:npc)
      c_inds = (/ (i*Ngp1-Ng,i=1,npc) /) ! 1:npf:ngp1
      ! And fine path extraction indices, assuming Zeta_Only if QTM
      do_gl(1:npc:npc-1) = .false.; do_gl(2:npc-1) = .true.
      call get_gl_inds ( do_gl(:npc), tan_pt_c, f_inds, nglMax )

      ! Zetas on the coarse path, assuming Zeta_Only if QTM
      z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
      z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)

      ! Compute the height of the pressure reference surface and the
      ! tangent height above that surface.
      if ( .not. usingQTM ) then
        if ( associated(surfaceHeight) ) then
          call tangent_metrics ( tan_phi, grids_tmp%phi_basis,      &
            &                    h_glgrid, tan_ind_f,               & ! in
            &                    h_surf, tan_ht_s,                  & ! output
            &                    surf_height=surfaceHeight%values(1,:) ) ! optional
        else if ( ptg_i < surfaceTangentIndex ) then
          call tangent_metrics ( tan_phi, grids_tmp%phi_basis,      &
            &                    h_glgrid, tan_ind_f,               & ! in
            &                    h_surf, tan_ht_s,                  & ! output
            &                    z_ref=z_psig(1),                   & ! optional
            &                    Tan_Press=tan_press,               & ! optional
            &                    Surf_Temp=temp%values(1,windowstart:windowfinish) )
        else
          call tangent_metrics ( tan_phi, grids_tmp%phi_basis,      &
            &                    h_glgrid, tan_ind_f,               & ! in
            &                    h_surf, tan_ht_s )                   ! output
        end if

        if ( present(scat_tan_ht) ) tan_ht_s = scat_tan_ht + h_surf

        ! Get H_Path and Phi_Path on the fine grid.
        call Height_Metrics ( tan_phi, tan_ind_f, grids_tmp%phi_basis, & ! in
          &  h_glgrid, h_surf, tan_ht_s, z_glgrid(:nz_if), r_eq,       & ! in
          &  req_s, vert_inds(1:npf), h_path(1:npf), phi_path(1:npf),  & ! out
          &  forward=forward )                                           ! opt
        tan_ht = tan_ht_s + req_s
        phi_path_c => phi_path(1:npf:ngp1)

      else ! QTM

        ! Put the inverse of F_and_V%Vertices in QTM%Path_Vertices.  The values
        ! therein are used to index elements of arrays that only exist
        ! adjacent to the path.
        QTM%path_vertices = 0 ! If this turns out to be expensive, keep an
                              ! "old F_and_V" and use it to put zeros here.
        do i_start = 1, size(F_and_V%vertices) ! I_Start is a temp here
          QTM%path_vertices(F_and_V%vertices(i_start)) = i_start
        end do

        ! Interpolate temperatures that are adjacent to the path onto T_GLgrid
        ! and compute H_GLgrid etc. at those places.  The second extent of
        ! T_GLgrid etc. is the maximum number of vertices adjacent to any path.
        ! The hydrostatic calculation for the non-QTM case is done before the
        ! pointing loop.  For the QTM case, each pointing might cross a different
        ! set of vertices, which would require T_GLgrid etc. to be larger,
        ! perhaps as large as the entire QTM.
        if ( temp_der ) then
          call two_d_hydrostatic ( grids_tmp, refGPH%template%surfs(1,1), &
            &  refGPH%values(1,:), z_glgrid, &
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT, &
            &  dHidTlm=dh_dt_glgrid, ddHdHdTl0=ddhidhidtl0, &
            &  vertices=F_and_V%vertices )
        else
          call two_d_hydrostatic ( grids_tmp, refGPH%template%surfs(1,1), &
            &  refGPH%values(1,:), z_glgrid, &
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT, &
            &  vertices=F_and_V%vertices )
        end if

        if ( associated(surfaceHeight) ) then
          call QTM_tangent_metrics ( tan_loc, QTM, h_glgrid, tan_ind_f, & ! in
            &                 h_surf, tan_ht_s, &                     ! output
            &                 surf_height=surfaceHeight%values(1,:) ) ! optional
        else if ( ptg_i < surfaceTangentIndex ) then
          call QTM_tangent_metrics ( tan_loc, QTM, h_glgrid, tan_ind_f, & ! in
            &                 h_surf, tan_ht_s, &                     ! output
            &                 Tan_Press=tan_press,               &    ! optional
            &                 Surf_Temp=temp%values(1,windowstart:windowfinish) )
        else
          call QTM_tangent_metrics ( tan_loc, QTM, h_glgrid, tan_ind_f, & ! in
            &                 h_surf, tan_ht_s )                      ! output
        end if
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!!!!                                                         !!!!!
        !!!!! At this point Tan_Loc%v (geodetic tangent height        !!!!!
        !!!!! in meters) should equal 1000 * ( h_surf + tan_ht_s )    !!!!!
        !!!!!                                                         !!!!!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        call path%get_path_ready ! Calculate tangent or reflection, and
                                 ! continuation of the path thereafter.
                                 ! The reflection is from the surface of the
                                 ! Earth, not the reference pressure surface.
        call metrics_3d_QTM ( path, QTM, h=h_glgrid, s=s, &
          & tangent_index=tan_ind_f, pad=NG, f_and_v=F_and_V, &
          & eta_p=eta_p, eta_p_t=eta_p_T, which=horizontal )
        ! ECR coordinates of points on the line-of-sight are
        ! Path%Lines(1,1) + S%s(:tan_ind_f) * Path%Lines(2,1) from the
        ! instrument to the tangent, and
        ! Path%Lines(1,2) + S%s(tan_ind_f+ngp1:) * Path%Lines(2,2) from the
        ! tangent onward. All values of |S%face| should be Top_Face, with
        ! S(.)%Face < 0 if the intersection is outside the QTM.  S(.)%H_ind is
        ! the subscript of z_psig, and the first subscript of H_GLGrid, i.e.,
        ! the index of the zeta surface in the fine zeta grid.  If it's zero,
        ! S(.) is an Earth-reflecting point below H_GLGrid.

      end if ! QTM

      ! Handle Earth-intersecting ray.  It is assumed to reflect from the
      ! reference height surface (h_glgrid(1,:)) so we didn't add a new
      ! zeta at the reflection point, so we don't need to recompute
      ! heights from hydrostatic principles.
      if ( tan_ht_s <= 0.0 ) e_rflty = earthRefl%values(1,1)

      ! If we're integrating from a scattering point, find where it is.
      if ( present(scat_zeta) .and. .not. usingQTM ) then
        call Find_Scattering_Point ( Scat_Zeta, Scat_Phi, Scat_Ht, Xi, &
                                   & Scat_Index, Tan_Phi, Npc, Npf, &
                                   & Print_Incopt, Print_IncRad, &
                                   & Print_Path, Req_S, PhiTan, Tan_Ht, &
                                   & FwdModelConf, MAF, Z_Coarse, Vert_Inds, &
                                   & H_Path, Phi_Path, Tan_Pt_C, Tan_Pt_F, &
                                   & Forward, Rev, Which )
        if ( scat_index < 1 ) then
          call trace_end ( 'ForwardModel.Metrics_Etc', &
            & cond=toggle(emit) .and. levels(emit) > 4 )
          call trace_end ( 'ForwardModel.Pointing=', index=ptg_i, &
            & cond=toggle(emit) .and. levels(emit) > 3 )
          return ! No ray to trace
        end if
        i_start = 1
        i_end = scat_index
      else
        i_start = 1
        i_end = npc
      end if

      ! Look for path crossings at zetas below the tangent point.
      ! These can only happen if the minimum zeta isn't at the tangent,
      ! and the ray isn't an earth-intersecting ray.
      if ( tan_ht_s > 0.0 .and. .not. present(QTM) ) call Lower_Path_Crossings ( &
        & Tan_Ht_s, Tan_Ht, Tan_Phi, Tan_Ind_f, grids_tmp%Phi_Basis, NZ_IF, &
        & Z_Coarse, Z_GLGrid, H_GLGrid, Vert_Inds, Req_S, H_Surf, Phi_Path, &
        & H_Path, NPC, NPF, T_GLGrid, Do_More_Points, Do_Zmin, &
        & Tan_Pt_C, Tan_Pt_F, More_Z_Path, More_H_Path, More_Phi_Path, &
        & N_More, Print_More_Points, Ptg_i )

      ! Compute Gauss Legendre (GL) zeta and pressure grids on the path
      call compute_GL_grid ( z_coarse(:tan_pt_c), z_path(:tan_pt_f), &
        &                    p_path(:tan_pt_f) )
      p_path(tan_pt_f+1:tan_pt_f+ng) = p_path(tan_pt_f) ! So they're not undefined
      z_path(tan_pt_f+1:tan_pt_f+ng) = z_path(tan_pt_f) ! So they're not undefined
      ! z_path, p_path, and t_path all the same within the zero-thickness
      ! tangent layer
      call compute_GL_grid ( z_coarse(tan_pt_c+1:npc), z_path(tan_pt_f+ngp1:npf), &
        &                    p_path(tan_pt_f+ngp1:npf) )

      ! The 0.5 factor is to compensate for the GL weights adding up to 2.0
      ! because the GL abscissae are on -1..+1.  This is a place where attention
      ! will be needed if present(QTM) .and. .not. Zeta_Only
      del_zeta(1:npc:npc-1) = 0.0_rp ! First and last ones
      del_zeta(2:tan_pt_c) = 0.5_rp * ( z_coarse(1:tan_pt_c-1) - &
        &                               z_coarse(2:tan_pt_c) )
      del_zeta(tan_pt_c+1:npc-1) = 0.5_rp * ( z_coarse(tan_pt_c+2:npc) - &
        &                                     z_coarse(tan_pt_c+1:npc-1) )

      ! Do phi refractive correction
      if ( FwdModelConf%refract .and. .not. usingQTM ) then
        ! Get t_path (and dhdz_path, which we don't need yet) so we can
        ! calculate the refractive index.  We don't do this for QTM because the
        ! horizontal coordinate isn't Phi, which is what's adjusted here.
        ! T_path and dhdz_path will be gotten again later, with slightly
        ! different phi.
        call more_metrics ( tan_ind_f, tan_pt_f, grids_tmp,            &
          &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf), &
          &  eta_p_T, t_path(1:npf), dhdz_path(1:npf) )
        ! Compute refractive index on the path.
        if ( h2o_ind > 0 ) then
          ! Compute eta_fzp (Zeta & Phi only) for water.
          call comp_eta ( grids_f, tan_pt_f, z_path(1:npf), &
                        & eta_z(h2o_ind), phi_path(1:npf),  &
                        & eta_p(h2o_ind), eta_fzp(h2o_ind), &
                        & n=h2o_ind, skip=ngp1 )
          call comp_1_sps_path_sparse_no_frq ( grids_f, eta_fzp(h2o_ind), &
                                             & sps_path(1:npf,h2o_ind),   &
                                             & n=h2o_ind )
          call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf), &
            &  h2o_path=sps_path(1:npf, h2o_ind) )
        else
          call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf) )
          n_path_c(:npc) = n_path_f(1:npf:ngp1)
        end if
        ! Do the refractive correction.  Use t_path to store the correction,
        ! since we're going to recompute t_path right away.
        ! The correction is zero at the tangent points and the zero-thickness
        ! layer between the tangent points.
        n_path_f(1:npf) = min ( n_path_f(1:npf), MaxRefraction )
        call phi_refractive_correction ( tan_pt_f, n_path_f(1:npf), &
          & h_path(1:npf), t_path(1:npf) )
        phi_path(:tan_pt_f) = phi_path(:tan_pt_f) - t_path(:tan_pt_f)
        phi_path(tan_pt_f+ngp1:npf) = phi_path(tan_pt_f+ngp1:npf) + &
                                    & t_path(tan_pt_f+ngp1:npf)
      end if

      ! Get other metrics-related quantities: t_path, dhdz_path, dh_dt_path...
      ! This also works for QTM because Eta_p_T and Eta_zp_T also work for QTM.
      if ( temp_der ) then
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp,              &
          &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
          &  eta_p_T, t_path(1:npf), dhdz_path(1:npf),                   &
          !  Stuff for temperature derivatives:
          &  ddHidHidTl0 = ddhidhidtl0, dHidTlm = dh_dt_glgrid,          &
          &  Z_Ref=z_glgrid,                                             &
          &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path,          &
          &  dHtdTl0 = tan_dh_dt, eta_zp = eta_zp_T,                     &
          &  t_der_path_flags = t_der_path_flags )
      else
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp ,             &
          &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
          &  eta_p_T, t_path(1:npf), dhdz_path(1:npf) )
      end if

      h_path_c(1:npc) = h_path(1:npf:ngp1)
      t_path_c(1:npc) = t_path(1:npf:ngp1)

      ! Compute Eta_ZP and Eta_FZP for all species
      call comp_eta ( grids_f, tan_pt_f, z_path(1:npf), eta_z, &
                    & phi_path(1:npf), eta_p, eta_zp, eta_fzp, &
                    & skip=ngp1 )

      ! Compute sps_path for all those with no frequency component, especially
      ! to get WATER (H2O) contribution for refraction calculations.
      call comp_sps_path_sparse ( Grids_f, eta_zp, sps_path(1:npf,:), eta_fzp )

      ! Compute the refractive index - 1
      if ( h2o_ind > 0 ) then
        ! Even if we did the refractive correction we need to do this,
        ! because the refractive correction changes phi_path, which
        ! changes sps_path.

        call refractive_index ( p_path(1:npf:ngp1), &
          &  t_path_c(1:npc), n_path_c(1:npc),  &
          &  h2o_path=sps_path(1:npf:ngp1, h2o_ind) )
      else if ( .not. FwdModelConf%refract ) then
        ! If we didn't do the refractive correction, we haven't yet
        ! computed the refractive index.
        call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf) )
        n_path_c(:npc) = n_path_f(1:npf:ngp1)
      end if

      n_path_c(1:npc) = min ( n_path_c(1:npc), MaxRefraction )

      ! Special path quantities for spectroscopy derivatives
      if ( size(fwdModelConf%lineCenter) > 0 ) then
        call comp_sps ( grids_v, tan_pt_f, z_path(1:npf), &
          & phi_path(1:npf), eta_zp_v, spect_v_path(1:npf,:) )
        lineCenter_ix => beta_group%lbl(sx)%spect_der_ix(lineCenter)
      end if
      if ( size(fwdModelConf%lineWidth) > 0 ) then
        call comp_sps ( grids_w, tan_pt_f, z_path(1:npf), &
          & phi_path(1:npf), eta_zp_w, spect_w_path(1:npf,:) )
        lineWidth_ix => beta_group%lbl(sx)%spect_der_ix(lineWidth)
      end if
      if ( size(fwdModelConf%lineWidth_TDep) > 0 ) then
        call comp_sps ( grids_n, tan_pt_f, z_path(1:npf), &
          & phi_path(1:npf), eta_zp_n, spect_n_path(1:npf,:) )
        lineWidth_TDep_ix => beta_group%lbl(sx)%spect_der_ix(lineWidth_TDep)
      end if

      ! Special path quantities for cloud model
      if ( fwdModelConf%Incl_Cld .or. fwdModelConf%useTScat ) then ! s_i == 1 or s_ts == 1 here

        call comp_sps ( grids_IWC, tan_pt_f, z_path(1:npf), phi_path(1:npf), &
                      & iwc_path(1:npf,:) )

        if ( fwdModelConf%Incl_Cld ) then
          !set some cloud parameters to zero
          WC(1,1:npf)=iwc_path(1:npf,1)
          WC(2,1:npf)=0.
          IPSD(1:npf)=1000
        end if
      end if

      if ( FwdModelConf%polarized ) then

        block
          use Magnetic_Field_On_Path_m, only: Magnetic_Field_On_Path

          ! Get the rotation matrix for the magnetic field.  Use the
          ! matrix for the MIF having ptan nearest to tan_press.  They are
          ! nearly identical anyway.
          mif = minloc(abs(tan_press - &
              &            ptan%values(:ptan%template%nosurfs,maf)),1)

          ! Dimensions of ECRtoFOV%value3 are ( chans, surfs,
          ! instances*cross angles ). Chans is actually 3x3, so we need to
          ! reform it.
          rot = reshape ( ECRtoFOV%value3(1:9,mif,maf), [ 3, 3 ] )

          call magnetic_field_on_path ( grids_mag, tan_pt_f, &
            & h_path(1:npf), r_eq, z_path(1:npf), phi_path(1:npf), &
            & rot, mag_path(1:npf,1:4) )
        end block

        ct => mag_path(1:npf,3)   ! cos(theta)
        stcp => mag_path(1:npf,1) ! sin(theta) cos(phi)
        stsp => mag_path(1:npf,2) ! sin(theta) sin(phi)
        h => mag_path(1:npf,4)    ! magnitude of magnetic field

        if ( print_Mag > -1 ) then
          call output ( maf, before='ECR to FOV matrix for MAF ' )
          call output ( mif, before=' and MIF ', advance='yes' )
          call dump ( rot, '', options=clean )
          call dump ( h_path(1:npf), 'Path height (km)', options=clean )
          call dump ( h, 'H', options=clean )
          call dump ( ct, 'Cos(theta)', options=clean )
          call dump ( stcp, 'Sin(theta) Cos(phi)', options=clean )
          call dump ( stsp, 'Sin(theta) Sin(phi)', options=clean )
          if ( iand(print_Mag,1) > 0 ) &
            & call dump ( mag_path(1:npf,1:3), 'Mag_Path', options=clean )
        end if

      end if ! polarized

      if ( .not. usingQTM ) then
        if ( present(est_scGeocAlt) .and. .not. fwdModelConf%generateTScat .and. &
           & thisSideband == fwdModelConf%sidebandStart ) then
          ! Compute the pointing angles.  These are needed for antenna
          ! convolution, not for ray tracing.  They are the same for both
          ! sidebands, so there's no need to compute them twice.  We can't easily
          ! move these computations into the convolution code because they need
          ! Tan_Ht_s and Req_s, which are gotten from Tangent_Metrics and
          ! Height_Metrics.
          n_path_inst = 0.0
          if ( temp_der ) then
            ! Est_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
            call get_chi_angles ( 0.001_rp*est_scGeocAlt, n_path_c(tan_pt_c), &
               & n_path_inst, tan_ht_s, tan_phi, req_s, 0.0_rp, &
               & ptg_angles(ptg_i), tan_dh_dt, tan_d2h_dhdt, dx_dt(ptg_i,:), &
               & d2x_dxdt(ptg_i,:) )
          else
            ! Est_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
            call get_chi_angles ( 0.001_rp*est_scGeocAlt, n_path_c(tan_pt_c), &
               & n_path_inst, tan_ht_s, tan_phi, req_s, 0.0_rp, &
               & ptg_angles(ptg_i) )
          end if
        end if
      else ! Using QTM
        block
          use Get_Chi_Angles_3D_m, only: Get_Chi_Angles
          if ( .not. fwdModelConf%generateTScat .and. &
             & thisSideband == fwdModelConf%sidebandStart ) then
            n_path_inst = n_path_c(1)
            if ( temp_der ) then
              call get_chi_angles ( n_path_c(tan_pt_c), n_path_inst, &
                & Q_LOS(k)%lines(1,1)%xyz, Q_LOS(k)%lines(2,1)%xyz, & ! ECR & LOS
                & tan_ht_s, req_s, 0.0_rp, & ! Elev_Offset
                & ptg_angles(ptg_i), &
                & tan_dh_dt, tan_d2h_dhdt, dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
            else
              call get_chi_angles ( n_path_c(tan_pt_c), n_path_inst, &
                & Q_LOS(k)%lines(1,1)%xyz, Q_LOS(k)%lines(2,1)%xyz, & ! ECR & LOS
                & tan_ht_s, req_s, 0.0_rp, & ! Elev_Offset
                & ptg_angles(ptg_i) )
            end if
          end if
        end block
      end if
      ! Compute refractive correction and Del_s
      n_path_c(1:npc) = n_path_c(1:npc) + 1.0_rp

      call comp_refcor ( tan_pt_c, h_path_c(:npc), n_path_c(:npc), &
                    &    tan_ht, del_s(:npc), ref_corr(:npc), ier )

      if ( ier /= 0 ) fmStat%flags = ior(fmStat%flags,b_refraction)

      !{ Since $s = \sqrt{h^2-h_t^2}$, $\frac{ds}{dh} = \frac{h}s$. We
      ! need {\tt dsdh_path} on the fine grid for Gauss-Legendre or
      ! Gauss-Lobatto quadrature, and on the coarse grid except at the
      ! tangent point for trapezoidal quadrature and Gauss-Lobatto
      ! quadrature, so compute it everywhere except at the tangent point
      ! and in the zero-thickness tangent layer, where it has a pole. 
      ! Besides, it's probably faster not to use a vector subscript to
      ! restrict it to the fine grid.

      dsdh_path(:tan_pt_f-1) = h_path(:tan_pt_f-1) / &
        & ( sqrt(h_path(:tan_pt_f-1)**2 - tan_ht**2 ) )
      dsdh_path(tan_pt_f:tan_pt_f+ngp1) = 0.0
      dsdh_path(tan_pt_f+ngp1+1:npf) = h_path(tan_pt_f+ngp1+1:npf) / &
        & ( sqrt(h_path(tan_pt_f+ngp1+1:npf)**2 - tan_ht**2 ) )

      do i = 1, 2
        do j = 1, nglMax, ng ! Avoid a temp for (/ ( gw, j = 1, nglMax/ng ) /)
          dhdz_gw_path(f_inds(j:j+ng-1)) = dhdz_path(f_inds(j:j+ng-1)) * gw
        end do

        dsdz_gw_path(f_inds(:nglMax)) = dsdh_path(f_inds(:nglMax)) * &
          & dhdz_gw_path(f_inds(:nglMax))

        ! We need dsdz = ds/dh * dh/dz, not multiplied by GW, for
        ! trapezoidal quadrature on the coarse grid.
        if ( WrongTrapezoidal ) &
          & dsdz_c(:npc) = dsdh_path(1:npf:ngp1) * dhdz_path(1:npf:ngp1)

        ! Multiply dhdz_path by ds / ( sum( ds/dh dh/dz gw ) d zeta ) =
        ! del_s / ( sum (dsdz_gw_path) * del_zeta ), which ought to be 1.0

        if ( i == 2 .or. .not. fwdModelConf%do_path_norm ) exit
        do j = 1, npc-2 ! do_gl is always false at the ends
          dhdz_path(f_inds((j-1)*ng+1:j*ng)) = &
            & dhdz_path(f_inds((j-1)*ng+1:j*ng)) * del_s(j+1) / &
            & (sum(dsdz_gw_path(f_inds((j-1)*ng+1:j*ng)))*del_zeta(j+1))
        end do
      end do

      ! Compute ALL the slabs_prep entities over the path's GL grid for this
      ! pointing & mmaf:
      if ( temp_der ) then
        call get_gl_slabs_arrays ( p_path(1:npf), t_path(1:npf), &
          &  vel_rel, gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
          &  spect_v_path, lineCenter_ix, &
          &  spect_w_path, lineWidth_ix, &
          &  spect_n_path, lineWidth_TDep_ix, &
          &  t_der_path_flags(1:npf) )
      else
        call get_gl_slabs_arrays ( p_path(1:npf), t_path(1:npf), &
          &  vel_rel, gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
          &  spect_v_path, lineCenter_ix, &
          &  spect_w_path, lineWidth_ix, &
          &  spect_n_path, lineWidth_TDep_ix )
      end if

      if ( fwdModelConf%useTScat ) then
        ! Get interpolating coefficients for Mie tables onto path
        ! Make sure Mie tables have been loaded.
        if ( .not. allocated(t_s) ) call MLSMessage ( MLSMSG_Error, &
          & moduleName, "UseTScat requested but no Mie tables loaded" )
        ! Get interpolation coefficients for IWC
        call eta_IWC_path_c%eta ( iwc_s, iwc_path(1:npf:ngp1,1) )
        ! Get interpolation coefficients for Temperature
        call eta_T_path_c%eta ( t_s, t_path_c )
        ! Get interpolation coefficients for Temperature X IWC
        call eta_T_IWC_path_c%eta ( eta_T_path_c, eta_IWC_path_c )

        ! Indicate we don't have Mie tables for this path
        prev_Mie_frq_ind = -1
      end if

      call trace_end ( 'ForwardModel.Metrics_Etc', &
        & cond=toggle(emit) .and. levels(emit) > 4  )

!{{\bfseries Notations}
!
! $N_f$ is the number of points in the pointing frequency grid.\\
! $n$ is an index in the pointing frequency grid.\\
! $N_p$ is the number of points in the line-of-sight path.\\
! $i$ is an index in the line-of-sight path.  $c$ is a channel index.\\
! $s$ indicates a strong-line (LBL) result.
!   $w$ indicates a weak-line (PFA) result.\\
! $\delta I^\sigma_{iq} = \Delta B_{iq} \tau^\sigma_{iq}$ is the incremental
!  radiance contribution at the $i^{\text{th}}$ point along the line-of-sight
!  path, for $\sigma$ either $s$  or $w$ and $q$ either $c$ or $n$.
!
! There are four possible combinations of LBL, PFA and
! frequency-averaging.

!{{\bfseries Frequency averaged, LBL only}
!      \begin{equation*}\begin{split}
!       I^s_c = \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc}
!             \sum_{i=1}^{N_p} \delta I^s_{in}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I^s_n}{\partial x_k} =&
!        \sum_{i=1}^{N_p}
!         \tau^s_{in} \frac{\partial \Delta B_{in}}{\partial x_k}
!         - \delta I^s_{in}
!          \sum_{j=1}^i \frac{\partial \delta^s_{jn}}{\partial x_k}\\
! %
!       \frac{\partial I_c}{\partial x_k} =&
!       \frac{\partial I^s_c}{\partial x_k} =
!        \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc}
!        \frac{\partial I^s_n}{\partial x_k}
!      \end{split}\end{equation*}

!{{\bfseries Monochromatic, LBL only}
!      \begin{equation*}
!       I^s_c = \sum_{i=1}^{N_p} \delta I^s_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I^s_c}{\partial x_k} =
!        \sum_{i=1}^{N_p}
!         \tau^s_{ic} \frac{\partial \Delta B_{ic}}{\partial x_k}
!         - \delta I^s_{ic}
!          \sum_{j=1}^i \frac{\partial \delta^s_{jc}}{\partial x_k}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!       \frac{\partial I^s_c}{\partial x_k}
!      \end{equation*}

!{{\bfseries Frequency averaged, PFA only}
!      \begin{equation*}
!       I_c = \sum_{i=1}^{N_p} \delta I^w_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!        \sum_{i=1}^{N_p}
!         \tau^w_{ic} \frac{\partial \Delta B_{ic}}{\partial x_k}
!           - \delta I^w_{ic}
!            \sum_{j=1}^i \frac{\partial \delta^w_{jc}}{\partial x_k}
!       \text{\phantom{xxxx}}
!      \end{equation*}

!{{\bfseries Frequency averaged, LBL and PFA}
!      \begin{equation*}
! %
!       \overline{\delta I^s_{ic}} =
!        \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc} \delta I^s_{in}
!       \text{\phantom{xxxx}}
! %
!       I_{ic} = \overline{\delta I^s_{ic}} \tau^w_{ic}
!       \text{\phantom{xxxx}}
! %
!       I_c = \sum_{i=1}^{N_p} I_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!       \frac{\partial I^s_c}{\partial x_k}
!        - \sum_{i=1}^{N_p} I_{ic}
!          \sum_{j=1}^i \frac{\partial \delta^w_{jc}}{\partial x_k}
!      \end{equation*}

!{{\bfseries Program variables}
!
! \begin{tabular}{llll}
! $\Delta B_{in}$ is {\tt T_Script_LBL} &
! $\Delta B_{ic}$ is {\tt T_Script_PFA} &
! $\tau^s_{in}$ is {\tt Tau_LBL} &
! $\tau^w_{ic}$ is {\tt Tau_PFA}
! \\
! $\delta I^\sigma_{iq}$ is {\tt Inc_Rad_Path} &
! $\overline{\delta I^s_{ic}}$ is {\tt Rad_Avg_Path} &
! $I_{ic}$ is also {\tt Rad_Avg_Path} &
! \\
! $\sum_{i=1}^{N_p} \delta I^\sigma_{iq}$ is {\tt RadV} &
! $I_c$ or $I^s_c$ is {\tt Radiances} &
! $\frac{\partial I^\sigma_q}{\partial x_k}$ is {\tt K_}$x${\tt_FRQ} &
! $\frac{\partial I_c}{\partial x_k}$ is {\tt K_}$x$
! \\
! \end{tabular}

      if ( FwdModelConf%anyLBL(sx) ) then
        do frq_i = 1, size(frequencies)
          call one_frequency ( ptg_i, frq_i, alpha_path_c(:npc),              &
            & beta_path_c(:npc,:), c_inds(:npc), del_s(:npc), del_zeta(:npc), &
            & do_GL(:npc), frequencies(frq_i), h_path_c, tan_ht,              &
            & incoptdepth(:npc), p_path(:npf), pfaFalse, ref_corr(:npc),      &
            & sps_path(:npf,:), tau_lbl, t_path_c(:npc),                      &
            & t_script_lbl(:npc,frq_i), tanh1_c(:npc), tt_path_c(:s_i*npc),   &
            & w0_path_c(:max(s_i,s_ts)*npc), z_path(:npf), i_start, i_end,    &
            & inc_rad_path(:,frq_i), RadV(frq_i), dAlpha_dT_path(:npf),       &
            & H_Atmos_Frq(frq_i,:,:), K_Atmos_Frq(frq_i,:),                   &
            & K_Spect_dN_Frq(frq_i,:), K_Spect_dV_Frq(frq_i,:),               &
            & K_Spect_dW_Frq(frq_i,:), K_Temp_Frq(frq_i,:) )
        end do
        if ( print_TauL ) then
          call output ( thisSideband, before='Sideband ' )
          call output ( ptg_i, before=' Pointing ' )
          call dump ( tau_lbl, noFreqs, ' Tau_LBL:', scat_index )
          if ( present(scat_index) ) then
            call dump ( t_script_lbl(scat_index:npc-1,:noFreqs), 'T_Script_LBL' )
          else
            call dump ( t_script_lbl(2:npc-1,:noFreqs), 'T_Script_LBL' )
          end if
        end if
      end if

      ! Handle PFA molecules
      if ( FwdModelConf%anyPFA(sx) ) then
        if ( iand(frq_avg_sel,7) == 7 ) then ! LBL + PFA + Derivs
          ! For every channel, frequency average the incremental radiance at
          ! every point along the path, giving Rad_Avg_Path for every channel
          ! and every point along the path.
          call frequency_avg_path ( frequencies, &
            & inc_rad_path(:npc,:), rad_avg_path(:npc,:) )
          ! Multiply by Tau_PFA to combine PFA contribution in One_Frequency.
            call frequency_average_derivatives ( ptg_i, combine=.false. )
            if ( atmos_second_der ) call frequency_avg_second_derivs ( ptg_i, .false. )
        end if

        do frq_i = 1, size(channelCenters)
          call one_frequency ( ptg_i, frq_i, alpha_path_c(:npc),                &
            & beta_path_c(:npc,:), c_inds(:npc), del_s(:npc), del_zeta(:npc),   &
            & do_GL(:npc),  channelCenters(frq_i), h_path_c, tan_ht,            &
            & incoptdepth(:npc), p_path(:npf), pfaTrue, ref_corr(:npc),         &
            & sps_path(:npf,:), tau_pfa, t_path_c(:npc),                        &
            & t_script_pfa(:npc,frq_i), tanh1_c(:npc), tt_path_c(:s_i*npc),     &
            & w0_path_c(:max(s_i,s_ts)*npc), z_path(:npf), i_start, i_end,      &
            & rad_avg_path(:,frq_i), RadV(frq_i), dAlpha_dT_path(:npf),         &
            & H_Atmos_Frq(frq_i,:,:), K_Atmos_Frq(frq_i,:),                     &
            & K_Spect_dN_Frq(frq_i,:), K_Spect_dV_Frq(frq_i,:),                 &
            & K_Spect_dW_Frq(frq_i,:), K_Temp_Frq(frq_i,:) )
        end do
        if ( print_TauP ) then
          call output ( thisSideband, before='Sideband ' )
          call output ( ptg_i, before=' Pointing ' )
          call dump ( tau_pfa, noUsedChannels, ' Tau_PFA:' )
          call dump ( t_script_pfa(2:npc-1,:), 'T_Script_PFA' )
        end if

      end if ! FwdModelConf%anyPFA(sx)

      if ( print_Rad > 0 ) then
        print '("Pointing ", i0)', ptg_i
        call dump ( frequencies, name='frequencies', options='c' )
        call dump ( radV, name='radV', options='c' )
      end if

      ! Frequency average, or store, or combine LBL and PFA
      call frequency_average ( ptg_i )

      ! If we're doing frequency averaging, there's a different frequency
      ! grid for each pointing, but we don't need to deallocate it here
      ! because the allocate_test in frequency_setup_2 will deallocate it.

      call trace_end ( 'ForwardModel.Pointing=', index=ptg_i, &
        & cond=toggle(emit) .and. levels(emit) > 3 )

      ! End of pointing loop -------------------------------------------------
    end subroutine One_Pointing

  ! ..............................................  One_TScat_Ray  .....
    include 'One_TScat_Ray.f9h'

  end subroutine FullForwardModelAuto

! ------------------------------------------------  not_used_here  -----
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: FullForwardModel_m.f90,v 2.410 2023/06/23 20:45:07 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module FullForwardModel_m

! $Log: FullForwardModel_m.f90,v $
! Revision 2.410  2023/06/23 20:45:07  pwagner
! In middle of debugging pol fwdmdl
!
! Revision 2.409  2020/08/28 21:41:58  vsnyder
! Set up to calculate chi angles for QTM
!
! Revision 2.408  2020/05/05 23:57:56  vsnyder
! Made F_and_V_MIF dummy argument of FullForwardModelAuto allocatable. Intel
! ifort 19 gets a seg fault at the call if the actual argument is not allocated,
! which it isn't if the run isn't QTM.
!
! Revision 2.407  2020/04/22 01:59:27  vsnyder
! Move TScat stuff to includes. Some work on QTM chi angles
!
! Revision 2.406  2020/02/07 01:11:08  pwagner
! Offers advice and sympathy if fwdmdl config fails superset test
!
! Revision 2.405  2019/10/07 20:05:53  vsnyder
! Get WrongTrapezoidal from the config
!
! Revision 2.404  2019/09/05 17:10:33  pwagner
! Dont try to deallocate F_and_V_MIF unless allocated already
!
! Revision 2.403  2019/06/24 23:28:16  pwagner
! Updated to reflect TA-01-143
!
! Revision 2.402  2018/10/30 23:14:36  vsnyder
! Make sure RadV always has a value in One_Frequency
!
! Revision 2.401  2018/10/26 22:05:47  vsnyder
! Don't do the trapezoidal update beyond I_End if it's before the tangent.
!
! Revision 2.400  2018/09/12 22:51:16  vsnyder
! Changed name of dRad_Tran_dX_Sparse to dRad_Tran_dX
!
! Revision 2.399  2018/09/12 22:07:42  vsnyder
! Convert interpolators for full cloud forward model from dense to sparse.
! Convert interpolators for spectroscopy derivatives from dense to sparse.
! Use Comp_Sps.  use dRad_Tran_dX_Sparse instead of dRad_Tran_dX.  Use
! Comp_Eta instead of Comp_Eta_DoCalc_Sparse (because we no longer calculate
! Do_Calc -- which Comp_Eta_DoCalc_Sparse didn't calculate anyway).
!
! Revision 2.398  2018/09/05 20:56:10  vsnyder
! Use sparse interpolation for magnetic field on path
!
! Revision 2.397  2018/08/28 22:17:53  vsnyder
! Add WrongTrapezoidal with the value .true. to indicate the incorrect
! trapezoid rule is used to calculate incOptDepth.  Some changes because of
! rearranged argument lists in Comp_Sps_Path_Sparse_m and
! Comp_Eta_DoCalc_Sparse_m.
!
! Revision 2.396  2018/08/15 01:18:50  vsnyder
! Get S_QTM_t from Metrics_2D_m instead of QTM_Interpolation_Weights_3D_m.
! Eliminate dSdZ_C.  Eliminate Do_Clac_T and Do_Calc_T_1.  Get T_Der_Path_Flags
! from More_Metrics.
!
! Revision 2.395  2018/05/24 03:24:36  vsnyder
! Use sparse representation for dh_dt_path
!
! Revision 2.394  2018/05/17 02:15:45  vsnyder
! Use sparse instead of dense interpolation
!
! Revision 2.393  2018/05/15 03:26:25  vsnyder
! Change Mie tables from pointer to allocatable
!
! Revision 2.392  2018/05/14 23:40:58  vsnyder
! Change to sparse eta representation
!
! Revision 2.390  2017/11/01 00:11:32  vsnyder
! Comment out a bunch of testing stuff, soon to disappear entierly
!
! Revision 2.389  2017/11/01 00:09:32  vsnyder
! Remove recently-added ScECR because it's not needed
!
! Revision 2.388  2017/10/31 23:49:35  vsnyder
! Make Coefficients a parameterized type
!
! Revision 2.387  2017/10/31 17:36:46  vsnyder
! Change QTM path from type MIFLOS vector quantity to Path_T
!
! Revision 2.386  2017/09/20 01:18:49  vsnyder
! Change name of Comp_Eta_DoCalc_Sparse to Comp_Eta_DoCalc_List.  Change
! names of Eta_p and Eta_z to Eta_p_List and Eta_z_list.  Get some state
! vector quantities only if they're needed.
!
! Revision 2.385  2017/08/10 00:15:53  vsnyder
! Add Tan_Pt_C in calls to Get_d_Deltau_Pol_df.  Do trapezoidal update using
! Del_s instead of Del_z because ds/dh is singular at the tangent.  More
! stuff getting ready for QTM.
!
! Revision 2.384  2017/03/31 00:49:43  vsnyder
! Use F_and_V to map to Jacobian for QTM.  Make F_and_V scalar in
! One_Pointing.  Cosmetic changes.
!
! Revision 2.383  2017/03/24 00:10:43  vsnyder
! Change the first extent of nz_d_delta_df back to max_f because the number
! of nonzeroes in a column of d_delta_df is not limited unless the vertical
! grids are the same for all species.
!
! Revision 2.382  2017/03/20 23:25:40  vsnyder
! Double row dimension of Nz_d_Delta_df
!
! Revision 2.381  2017/03/11 00:58:13  vsnyder
! Many changes leading to 3D/QTM model
!
! Revision 2.380  2017/01/14 02:58:48  vsnyder
! Inching toward 3D QTM forward model
!
! Revision 2.379  2016/12/02 02:04:50  vsnyder
! Use 'P' Eta list for Eta_ZZ
!
! Revision 2.378  2016/11/23 21:35:13  vsnyder
! Compute Eta_ZZ to interpolate from Temperature's zeta basis to the GL
! zeta grid, and use it for hydrostatic calculations.
!
! Revision 2.377  2016/11/23 00:14:36  vsnyder
! Use types from Indexed_Values_m.  Some cannonball polishing.
!
! Revision 2.376  2016/11/17 01:45:26  vsnyder
! Use Comp_Sps_Path_No_Frq to get H2O for phi refractive correction.  Some
! work on QTM also.
!
! Revision 2.375  2016/11/14 21:10:47  vsnyder
! Change scat zeta tolerance test from relative to absolute
!
! Revision 2.374  2016/11/14 19:17:12  vsnyder
! Change scat zeta tolerance to 'half the bits match'
!
! Revision 2.373  2016/11/12 01:42:32  vsnyder
! Put the inverse of F_and_V%Vertices into QTM_Tree%Path_Vertices.  Replace
! Facets argument to Metrics_3D with F_and_V.
!
! Revision 2.372  2016/11/11 02:06:27  vsnyder
! For QTM, get LOS from MIF LOS before FullForwardModelAuto.  Use it to
! calculate facets and vertices on all paths.  Use maximum number of vertices
! on any path as the horizontal extent for temperature-related arrays.  Pass
! Vertices array to Two_D_Hydrostatic.  Don't call Two_D_Hydrostatic before
! the loop over sidebands.  Pass RefGPH values as m instead of km because
! Two_D_Hydrostatic does the conversion now.  Other stuff for inching toward
! 3D QTM model.
!
! Revision 2.371  2016/11/09 00:38:10  vsnyder
! Move Interpolate_MIF_to_Tan_Press to a separate model.  Get list of facets
! and pass it to Metrics_3D.  Other stuff for inching toward 3D model.
!
! Revision 2.370  2016/11/03 19:11:47  vsnyder
! Inching toward 3D forward model
!
! Revision 2.369  2016/10/25 22:27:39  vsnyder
! Inching toward 3D QTM
!
! Revision 2.368  2016/10/24 22:20:32  vsnyder
! A bunch of stuff for QTM etc.
!
! Revision 2.367  2016/06/03 23:47:23  vsnyder
! Make Tan_Press allocatable instead of a pointer.  Provide minor-frame
! quantities for "orbit" inclination, minor axis length, phiTan, and tangent
! height if the hGrid for temperature is QTM.  Ensure either temperature and
! all molecules are QTM, or none of them are.
!
! Revision 2.366  2016/05/02 23:32:52  vsnyder
! Get temperature quantity from FwdModelConf, remove some unused stuff
!
! Revision 2.365  2016/04/21 02:00:12  vsnyder
! Move Convolution and Convolution_Setup to Convolution_m
!
! Revision 2.364  2016/03/25 02:02:37  vsnyder
! Add a dump for polarized incremental optical depth just before its
! exponential is attempted to be computed.
!
! Revision 2.363  2016/02/25 00:57:58  vsnyder
! Include bounds of t_path_c in call to dt_script_dt
!
! Revision 2.362  2016/01/23 02:55:24  vsnyder
! Add printing for polarized radiance
!
! Revision 2.361  2015/12/08 23:23:42  vsnyder
! Put bound (:i_end) on Ref_Corr in call to Get_Tau
!
! Revision 2.360  2015/12/08 19:13:08  vsnyder
! Define pointer association status of Phi_Path_C immediately after Height_Metrics
!
! Revision 2.359  2015/10/28 00:34:13  vsnyder
! Add more magnetic field-related dumps
!
! Revision 2.358  2015/09/22 23:37:26  vsnyder
! Add 3D magnetic field
!
! Revision 2.357  2015/08/25 17:23:05  vsnyder
! Compute PhiWindow in radians for TScat
!
! Revision 2.356  2015/05/28 23:22:44  vsnyder
! Use height above geoid for interpolating the magnetic field to the path.
!
! Revision 2.355  2015/05/01 02:08:36  vsnyder
! Interpolate in height or zeta for magnetic field
!
! Revision 2.354  2015/04/11 01:26:03  vsnyder
! Add more dumps, add (km) to comments about h_path and h_glgrid
!
! Revision 2.353  2015/03/28 02:16:24  vsnyder
! Compute the viewing azimuth to determine whether cross-track viewing is
! taking place.  Use Orbit_Plane_Minor_Axis_sq from Geometry.  Use 3-d
! Value field for ECRtoFOV array.  Use Norm2 to normalize Mag_Path.
!
! Revision 2.352  2014/09/05 20:49:32  vsnyder
! Avoid reference to undefined array elements
!
! Revision 2.351  2014/08/01 01:06:05  vsnyder
! Add code to fill real arrays with sNaN if the private parameter NaN_Fill
! is true.  Set p_path to zero between the tangent points, so it's not
! undefined.  It's not actually used for anything productive, but if the
! compiler has an option to fill with sNaN, and those elements are referenced
! (and the results subsequently not used), a pointless trap occurs.
!
! Revision 2.350  2014/07/18 23:15:44  pwagner
! Aimed for consistency in names passed to allocate_test
!
! Revision 2.349  2014/01/11 01:28:53  vsnyder
! Decruftification
!
! Revision 2.348  2013/08/31 02:30:03  vsnyder
! Improve tracing
!
! Revision 2.347  2013/08/30 03:56:23  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.346  2013/08/17 02:56:19  vsnyder
! Regularize trace usage
!
! Revision 2.345  2013/08/08 02:35:25  vsnyder
! Set Qty_Stuff%derivOK if ExtraJacobian is present
!
! Revision 2.344  2013/08/02 01:24:06  vsnyder
! Add ExtraJacobian to compute derivatives not in state vector
!
! Revision 2.343  2013/07/13 00:06:20  vsnyder
! Move computation of tangent pressures from Compute_Z_PSIG to Tangent_Pressures.
! Remove declarations for unused symbols.
!
! Revision 2.342  2013/06/12 02:35:22  vsnyder
! Make Z_psig allocatable instead of pointer
!
! Revision 2.341  2013/05/22 00:19:10  vsnyder
! Remove unreferenced USE names
!
! Revision 2.340  2013/05/18 00:34:43  vsnyder
! Insert NG fine-grid (GL) points between tangent points, thereby
! regularizing coarse-grid spacing, and reducing significantly the need
! to use c_inds to extract coarse-grid points from the composite grid.
!
! Revision 2.339  2013/04/09 18:23:56  pwagner
! Fixed error in failing to use DerivativeMissingFromStateFun
!
! Revision 2.338  2013/02/04 22:06:27  pwagner
! Added dmiss switch to downgrade severity when qty missing from state
!
! Revision 2.337  2013/01/23 21:24:26  vsnyder
! Use |sin| in TScat phase convolution
!
! Revision 2.336  2012/08/08 20:06:37  vsnyder
! Use CreateVectorValue, DestroyVectorQuantityValue in full cloud model.
! Exchange subscript ordering for vmrArray to improve locality.
!
! Revision 2.335  2012/07/07 00:14:33  vsnyder
! Shorten some comments to avoid gripes about long lines
!
! Revision 2.334  2012/07/06 21:30:41  yanovsky
! Make the module ready for making calls to Convolve_Radiance_Normalization
! and Convolve_Temperature_Deriv_Normalization that compute normalized
! Temperature derivatives.  These calls are currently commented.
!
! Revision 2.333  2012/06/15 23:33:13  vsnyder
! Include sin(theta) factor in TScat phase convolution.  Improve dumps.
!
! Revision 2.332  2012/02/13 23:20:12  pwagner
! DerivativeMissingFromState eases switch from strict to lenient
!
! Revision 2.331  2012/02/10 23:51:33  vsnyder
! Move DeriveFromForwardModelConfig to Retrieval module
!
! Revision 2.330  2011/11/10 23:23:32  vsnyder
! Correct computation of 'combine' argument in frequency averaging
!
! Revision 2.329  2011/11/09 00:29:48  vsnyder
! Monochromatic PFA, more debugging
!
! Revision 2.327  2011/08/12 18:59:57  vsnyder
! Add Do_Calc_Fzp into one call to Comp_Sps_Path_Frq, because it is no longer
! optional, and it is actually needed where it wasn't specified.  Add checks
! that temperature and mixing ratio quantities for which derivatives are
! requested appear in the first state vector.
!
! Revision 2.326  2011/07/29 01:55:18  vsnyder
! Use CloudIce instead of Cloud_A and Cloud_S.  Only one IWC, not IWC_A and
! IWC_S.  More dumps.
!
! Revision 2.325  2011/07/21 20:48:38  honghanh
! Fix an array-index-out-of-bound bug by fixing the declaration fo DBeta_DF_Path_C
! and DBeta_DF_Path_F
!
! Revision 2.324  2011/07/08 18:19:35  yanovsky
! Use get_d2Alpha_df2
!
! Revision 2.323  2011/06/24 23:15:53  pwagner
! Fixed erroneous declaration for D2_DELTA_DF2 that gave non-Hessian runs excess memory footprint
!
! Revision 2.322  2011/06/02 22:31:48  yanovsky
! Add D2_DELTA_DF2 for computations of analytical Hessians in logarithmic basis
!
! Revision 2.321  2011/05/09 17:46:38  pwagner
! Converted to using switchDetail
!
! Revision 2.320  2011/03/31 19:51:03  vsnyder
! Allow 'scattering point not in path' to be a warning
!
! Revision 2.319  2011/03/25 20:46:59  vsnyder
! Delete declarations of unused objects
!
! Revision 2.318  2011/03/23 23:50:42  vsnyder
! Finishing -- hopefully -- TScat derivatives
!
! Revision 2.317  2011/03/23 23:45:32  vsnyder
! This log entry is bogus.  Check in again to get the right one.
! FOV_Convolve_m.f90
!
! Revision 2.316  2011/03/11 03:09:08  vsnyder
! Use Get_dAlpha_df
!
! Revision 2.315  2011/03/04 03:44:40  vsnyder
! Remove declarations for unused stuff
!
! Revision 2.314  2011/02/12 03:57:40  vsnyder
! Add mixing-ratio dependence for H2O derivatives
!
! Revision 2.313  2011/01/29 00:52:32  vsnyder
! Allow PFA without frequency averaging
!
! Revision 2.312  2011/01/28 19:18:44  vsnyder
! Lots of stuff for TScat
!
! Revision 2.311  2010/11/05 23:03:18  pwagner
! Lots of new NaN checks--should make them optional
!
! Revision 2.310  2010/11/03 18:43:51  vsnyder
! Initialize eta_fzp and H_Atmos.  Frequency average LBL second derivatives.
!
! Revision 2.309  2010/09/25 01:08:39  vsnyder
! Cannonball polishing
!
! Revision 2.308  2010/08/28 00:03:12  vsnyder
! Shortened some overly long names.  Corrected allocation for H_Atmos_Frq.
! Moved some TScat stuff to TScat_Support.  Some cannonball polishing.
!
! Revision 2.307  2010/08/27 06:02:39  yanovsky
! Major additions to support for computations of atmospheric second
! derivatives (atmospheric Hessians). FullForwardModel subroutine
! now has dummy variable Hessian.  Also, added
! Frequency_Average_Second_Derivative and
! Frequency_Average_Second_Derivatives subroutines.
!
! Revision 2.306  2010/08/19 02:14:03  vsnyder
! Substantial changes, the most significant being to put the body of the
! frequency loop in a subroutine of its own called One_Frequency, delete
! the subroutine Frequency_Loop, put the frequency loop around the calls
! to One_Frequency, and pass in sections of some arrays that used to be
! accessed by host association, and subscripted with the frequency index.
! Also, some other stuff inching toward TScat processing.
!
! Revision 2.305  2010/06/12 01:30:54  vsnyder
! Give frequency dimension to Alpha_path_c and Beta_path_c.  Make
! Frequency_Loop the body of the frequency loop instead of doing the
! loop in it.  Pass in lower-dimensional sections of several arrays,
! with the section selected according to the frequency loop index.
!
! Revision 2.304  2010/06/07 23:23:53  vsnyder
! Numerous changes inching toward using TScat tables, some of which will
! almost certainly prove to have been dead ends.
!
! Revision 2.303  2010/05/18 18:13:35  honghanh
! Change both_sidebands_setup to get GPH quantity with GetQuantityForForwardModel as the rest of the quantity
!
! Revision 2.302  2010/03/24 20:50:02  vsnyder
! Add more checks to TScat generation code
!
! Revision 2.301  2010/02/05 03:29:19  vsnyder
! Remove unused stuff
!
! Revision 2.300  2010/02/02 01:39:06  vsnyder
! Move USEs closer to where the used stuff is referenced.  Don't compute
! theta if it trying to do so will cause an exception.  Finish applying the
! product rule correctly for TScat derivatives.
!
! Revision 2.299  2010/01/23 01:30:49  vsnyder
! Move USEs into closer proximity to references.  Get cloudIce as vmr if it
! isn't available as a quantityType.  Create TScat stuff with zero size if
! not doing TScat table generation.  Get index of Cloud_A if there is one.
! Provide that Betas for Cloud_A and Cloud_S depend upon IWC mixing ratio.
! Calculate TScat derivatives (still not complete).  Don't compute TScat
! or derivatives where there's no IWC.  Don't use the logIWC quantity type.
! During TScat table computation, interpolate P to pointing angles rather
! than interpolating incident radiance to angles where T is tabluated.
!
! Revision 2.298  2009/12/15 03:30:04  vsnyder
! TScat radiance calculation working again -- P interpreted to xi instead
! of radiance interpolated to theta.
! Exchange order of subscripts of "radiances" to be consistent with k_...
! and to get better locality in frequency loop
!
! Revision 2.297  2009/11/17 23:45:32  vsnyder
! Add R_eq, R_sc arguments to FOV_Convolve_Setup, incomplete TScat stuff
!
! Revision 2.296  2009/09/25 02:45:06  vsnyder
! TScat computation appears to be working
!
! Revision 2.295  2009/06/23 18:26:10  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.294  2009/06/16 17:38:17  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.293  2009/06/13 01:15:03  vsnyder
! Intermediate commit of extensive changes for TScat calculation
!
! Revision 2.292  2009/05/14 00:46:02  pwagner
! Gets Deg2Rad from Constants now
!
! Revision 2.291  2009/01/21 01:00:39  pwagner
! Compatible with hastily committed select_nz_list
!
! Revision 2.290  2008/10/03 16:27:14  livesey
! Pushed down LO to support EXTINCTIONV2
!
! Revision 2.289  2008/06/26 00:28:03  vsnyder
! Simplify call to Compute_Z_PSIG.  Simplify some stuff.  Correct a bug:
! If H-PHI iteration doesn't converge and no new zeta is added, z_ig isn't
! defined.  Sneak up a little bit on TScat computation.
!
! Revision 2.288  2008/05/20 00:23:21  vsnyder
! Much rearranging to prepare for TScat calculation.
! Use pointing-interpolated LOS velocity instead of MIF(1) for Doppler
! correction for pointing frequency grid.
! Send vel/C instead of vel to slabs_prep.
!
! Revision 2.287  2008/02/29 01:59:39  vsnyder
! Added a separate H2O continuum routine
!
! Revision 2.286  2007/11/08 02:02:19  vsnyder
! Change name of path_dsdh to dsdh_path for consistency with other names.
! Add do_path_norm switch.  Rearrange printing if switches set to show
! desires to add points but not to add them.
!
! Revision 2.285  2007/07/31 23:49:21  vsnyder
! Add an argument metrics needs for H/Phi failure recovery
!
! Revision 2.284  2007/07/11 22:26:32  vsnyder
! More dumps, change some error handling
!
! Revision 2.283  2007/06/29 19:33:59  vsnyder
! Put the pointing loop body into an internal subroutine
! Make ForwardModelIntermediate_t private to ScanModelModule
!
! Revision 2.282  2007/06/26 01:05:02  vsnyder
! Use column-sparse eta
!
! Revision 2.281  2007/06/08 22:05:33  vsnyder
! Faster d_delta_df = 0, metrics stuff
!
! Revision 2.280  2007/02/01 02:53:47  vsnyder
! Stuff for min zeta and more intersections, plus cannonball polishing
!
! Revision 2.279  2007/01/20 01:08:08  vsnyder
! Decrufting
!
! Revision 2.278  2007/01/19 02:38:53  vsnyder
! Include water in phi refractive correction
!
! Revision 2.277  2007/01/18 00:27:10  vsnyder
! Split Pure_Metrics into Tangent_Metrics and Height_Metrics, insert Earth
! intersection into Zeta grid.
!
! Revision 2.276  2006/12/21 22:59:00  vsnyder
! Get rid of some unused variables
!
! Revision 2.275  2006/12/21 01:34:53  vsnyder
! Finally implemented minimum Zeta
!
! Revision 2.274  2006/12/20 21:22:16  vsnyder
! Split metrics into pure H-Phi calculation, and everything else, in
! preparation for inserting the minimum-Zeta point into the path.
!
! Revision 2.273  2006/12/19 02:53:15  vsnyder
! Change some names, send max coarse path from FullForwardModel to
! FullForwardModelAuto instead of using 2*NLVL, get rid of STATUS
! argument from Metrics, reference H_Path from Earth center instead
! of surface.
!
! Revision 2.272  2006/12/13 02:32:02  vsnyder
! Drag the tangent point around instead of assuming it's the middle one
!
! Revision 2.271  2006/12/08 23:57:08  vsnyder
! Revise earth-intersecting metrics
!
! Revision 2.270  2006/12/04 21:17:28  vsnyder
! Reorganize FullForwardModel to use automatic arrays instead of allocating
! pointer arrays.  Requires testing for zero size instead of testing for
! associated in several subsidiary procedures.
!
! Revision 2.267  2006/08/25 19:42:31  vsnyder
! Recommited to get correct comment into the log: Compute earthradc_sq for
! metrics, since we both need it, more accurate tracing, cannonball polishing.
!
! Revision 2.266  2006/08/25 19:37:07  vsnyder
! Earthradc_sq, etc.
!
! Revision 2.265  2006/07/06 23:16:19  vsnyder
! Need to allocate dh_dt_glgrid even if no temperature derivatives
!
! Revision 2.264  2006/06/29 19:34:43  vsnyder
! Changes due to metrics handling only one tangent
!
! Revision 2.263  2006/06/19 19:26:56  vsnyder
! OOPS, out of bounds subscript possible in dsdh_path
!
! Revision 2.262  2006/06/16 20:32:30  vsnyder
! Define NGP1 in glnp
!
! Revision 2.261  2006/06/16 00:49:10  vsnyder
! Improved non-GL correction, add TeXnicalities
!
! Revision 2.260  2006/04/25 23:25:36  vsnyder
! Revise DACS filter shape data structure
!
! Revision 2.259  2006/04/21 22:25:20  vsnyder
! Cannonball polishing
!
! Revision 2.258  2006/04/11 18:34:37  vsnyder
! Add tanh(h nu / k T) to Get_D_Deltau_Pol.  Use DACS frequencies in
! Frequency_Setup_1.
!
! Revision 2.257  2006/03/06 20:44:06  vsnyder
! Avoid appearance of out-of-bounds subscript during frequency averaging
!
! Revision 2.256  2006/02/08 21:38:18  vsnyder
! Add relative humidity (RHi) calculation
!
! Revision 2.255  2006/02/08 01:02:01  vsnyder
! More stuff for spectroscopy derivatives
!
! Revision 2.254  2006/01/05 00:03:52  vsnyder
! Implement refractive correction for Phi
!
! Revision 2.253  2005/12/10 01:51:54  vsnyder
! Cannonball polishing
!
! Revision 2.252  2005/12/07 19:43:32  vsnyder
! Mistakenly committed needing Phi_Refractive_Correction
!
! Revision 2.251  2005/12/07 01:30:04  vsnyder
! More on getting correct size for RadV
!
! Revision 2.250  2005/12/07 00:35:04  vsnyder
! Allocate RadV with correct size for PFA and no LBL
!
! Revision 2.249  2005/11/21 22:57:41  vsnyder
! PFA derivatives stuff, plug some memory leaks
!
! Revision 2.248  2005/11/05 03:38:13  vsnyder
! Frequency_Average_Derivative doesn't need Tau, cannonball polishing
!
! Revision 2.247  2005/11/03 03:57:45  vsnyder
! Don't try to look at filter shapes for DACS
!
! Revision 2.246  2005/11/02 21:38:48  vsnyder
! Repair a broken tracing message
!
! Revision 2.245  2005/11/01 23:02:08  vsnyder
! PFA Derivatives, use precomputed ShapeInds
!
! Revision 2.244  2005/09/17 01:02:38  vsnyder
! Out of bounds subscript
!
! Revision 2.243  2005/09/17 00:49:53  vsnyder
! Revise arrays for spectroscopic derivatives, plus some cannonball polishing
!
! Revision 2.242  2005/09/03 01:21:33  vsnyder
! Spectral parameter offsets stuff
!
! Revision 2.241  2005/08/03 18:03:42  vsnyder
! Scan averaging, some spectroscopy derivative stuff
!
! Revision 2.240  2005/07/08 19:40:51  vsnyder
! OOPS, forgot to nullify Rad_FFT
!
! Revision 2.239  2005/07/08 00:12:11  vsnyder
! Get Rad_FFT from Convolve_Radiance to Convolve_Temperature_Deriv
!
! Revision 2.238  2005/07/06 02:17:20  vsnyder
! Revisions for spectral parameter derivatives
!
! Revision 2.237  2005/06/09 02:34:16  vsnyder
! Move stuff from l2pc_pfa_structures to slabs_sw_m
!
! Revision 2.236  2005/06/03 01:59:25  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades
!
! Revision 2.235  2005/04/19 20:16:45  livesey
! Added a couple of nullifys
!
! Revision 2.234  2005/03/28 20:26:25  vsnyder
! Lots of PFA stuff
!
! Revision 2.233  2005/03/10 00:28:09  pwagner
! Better patching of ptg_angles avoids list-out-of-order in Hunt
!
! Revision 2.232  2005/02/17 02:35:29  vsnyder
! Do PFA on fine path if necessary
!
! Revision 2.231  2005/02/16 23:16:49  vsnyder
! Revise data structures for split-sideband PFA
!
! Revision 2.230  2004/12/28 00:28:02  vsnyder
! Remove unreferenced use name
!
! Revision 2.229  2004/12/13 20:37:23  vsnyder
! Moved stuff from get_species_data to ForwardModelConfig, some cannonball polishing
!
! Revision 2.228  2004/11/05 19:38:39  vsnyder
! Got rid of DerivedFromForwardModel component of config
!
! Revision 2.227  2004/11/01 20:26:35  vsnyder
! Reorganization of representation for molecules and Beta groups; PFA may be broken for now
!
! Revision 2.226  2004/10/13 01:08:27  vsnyder
! Moved some checking to ForwardModelSupport
!
! Revision 2.225  2004/10/07 23:26:09  vsnyder
! Changes in Beta_Group structure
!
! Revision 2.224  2004/10/06 21:27:41  vsnyder
! More work on PFA -- seems to work now
!
! Revision 2.223  2004/09/14 17:20:45  bill
! add mif dependent los vel correction-wgr
!
! Revision 2.222  2004/09/04 01:50:30  vsnyder
! get_Beta_path_m.f90
!
! Revision 2.221  2004/09/01 01:48:27  vsnyder
! Status flags, more work on PFA
!
! Revision 2.220  2004/08/06 22:40:17  livesey
! Better patch for ptg_angles
!
! Revision 2.219  2004/08/06 01:40:39  livesey
! Upgraded the precision of the ptg dump.
!
! Revision 2.218  2004/08/06 01:24:55  livesey
! Typo!
!
! Revision 2.217  2004/08/06 01:24:22  livesey
! Minor bug fix in ptg_angles dump
!
! Revision 2.216  2004/08/05 20:53:50  vsnyder
! More PFA preparations, some cannonball polishing
!
! Revision 2.215  2004/08/05 20:24:00  livesey
! Added ptg switch to dump ptg_angles
!
! Revision 2.214  2004/08/03 22:07:10  vsnyder
! Inching further toward PFA
!
! Revision 2.213  2004/07/30 19:53:18  livesey
! Bug fix, forbid extrapolation in Estimate_tan_phi
!
! Revision 2.212  2004/07/08 21:00:23  vsnyder
! Inching toward PFA
!
! Revision 2.211  2004/06/10 00:59:56  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 2.210  2004/05/27 23:23:50  pwagner
! named parameter clean= to dump procedures
!
! Revision 2.209  2004/05/17 22:05:11  livesey
! A change to refraction and to k_atmos handling to avoid explosions.
!
! Revision 2.208  2004/04/24 02:27:05  vsnyder
! Cosmetic changes
!
! Revision 2.207  2004/04/19 21:01:37  vsnyder
! Put size of gl_slabs in call to get_gl_slabs_arrays
!
! Revision 2.206  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.205  2004/04/05 21:08:42  jonathan
! delet temp_prof
!
! Revision 2.204  2004/04/02 00:59:24  vsnyder
! Get catalog from slabs structure
!
! Revision 2.203  2004/03/31 20:35:26  jonathan
! bug fix in handling clouds
!
! Revision 2.202  2004/03/30 02:26:17  livesey
! Bug fix in Jonathan's w0 handling
!
! Revision 2.201  2004/03/30 02:00:36  vsnyder
! Remove USE for unreferenced symbol.  Don't try to fill tpath_m and
! tpath_p if they're not allocated.
!
! Revision 2.200  2004/03/27 03:35:27  vsnyder
! Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
! line centers and line widths around.  Write slabs_lines and slabswint_lines
! to get sum of Beta over all lines; put slabs_struct instead of its components
! in the calling sequence.
!
! Revision 2.199  2004/03/20 04:05:50  vsnyder
! Moved SpeedOfLight from units to physics
!
! Revision 2.198  2004/03/20 01:15:16  jonathan
! add in scattering correction term in two t_script
!
! Revision 2.196  2004/03/01 19:22:14  jonathan
! following the changes made to load_one_item
!
! Revision 2.195  2004/02/14 00:23:48  vsnyder
! New DACS convolution algorithm
!
! Revision 2.194  2004/02/05 23:30:01  livesey
! Finally implemented code to do correct handing of sideband fraction in
! single sideband radiometers.
!
! Revision 2.193  2004/02/03 02:48:35  vsnyder
! Progress (hopefully) on polarized temperature derivatives.
! Implement DACs frequency convolution.
!
! Revision 2.192  2004/01/23 19:13:42  jonathan
! add an extra-flag for tscat in load_one_item
!
! Revision 2.191  2003/12/08 21:38:33  jonathan
! some minor changes
!
! Revision 2.190  2003/12/08 17:52:02  jonathan
! update for 2d cldfwm
!
! Revision 2.189  2003/12/07 19:45:46  jonathan
! update for 2D cloud FWM
!
! Revision 2.188  2003/12/01 17:24:05  jonathan
! add scat_alb
!
! Revision 2.187  2003/11/24 22:10:14  vsnyder
! Multiply Beta_path_polarized_f by tanh1_f if derivatives needed
!
! Revision 2.186  2003/11/20 17:33:50  pwagner
! Nullify some things otherwise left unassociated
!
! Revision 2.185  2003/11/19 22:21:34  jonathan
! interpolate scat_src to tscat_path
!
! Revision 2.184  2003/11/17 18:04:15  jonathan
! scat_src output from T_scat is correct
!
! Revision 2.183  2003/11/12 00:10:55  jonathan
! some changes due to cloud construction
!
! Revision 2.182  2003/11/07 03:18:49  vsnyder
! Cosmetic changes
!
! Revision 2.181  2003/11/06 01:13:14  bill
! fixed DACS freq extrapolation problem
!
! Revision 2.180  2003/11/05 19:26:01  jonathan
! add stuff for use later in cld model
!
! Revision 2.179  2003/11/04 02:49:13  vsnyder
! Calculate coarse-path indices where GL is needed
!
! Revision 2.178  2003/11/04 01:57:15  vsnyder
! Move trapezoid correction to a better place, cosmetics
!
! Revision 2.177  2003/11/03 23:15:16  vsnyder
! Get rid of path_ds_dh procedure -- a one-liner used in one place
!
! Revision 2.176  2003/11/01 03:02:57  vsnyder
! Compute del_zeta, ds_dz_gw and dh_dz_gw for [d]rad_tran*; change
! indices_c to c_inds for consistency with usage in rad_tran_m.
!
! Revision 2.175  2003/10/30 20:37:00  vsnyder
! Compute del_zeta here for *rad_tran_*
!
! Revision 2.174  2003/10/29 00:43:51  livesey
! Added support for the forceFoldedOutput option
!
! Revision 2.173  2003/10/28 22:05:53  jonathan
! add l_gph for use in cloud model
!
! Revision 2.172  2003/10/09 19:30:18  vsnyder
! Cosmetic changes
!
! Revision 2.171  2003/09/24 02:53:48  vsnyder
! Cosmetic changes
!
! Revision 2.170  2003/09/09 00:04:27  vsnyder
! Supply E and Sqrt_Earth_Rflty to mcrt_der
!
! Revision 2.169  2003/08/16 01:14:58  vsnyder
! Use radiometers%polarization to choose 1,1 or 2,2 element
!
! Revision 2.168  2003/08/15 20:29:26  vsnyder
! Implement polarized VMR derivatives
!
! Revision 2.167  2003/08/15 18:50:21  vsnyder
! Preparing the way for polarized vmr derivatives
!
! Revision 2.166  2003/08/12 23:07:32  vsnyder
! Futzing with comments
!
! Revision 2.165  2003/08/12 21:58:37  vsnyder
! Use trapezoid instead of rectangle to integrate non-GL panels
!
! Revision 2.164  2003/08/12 18:22:10  michael
! Contribution of scalar molecules to polarized absorption is now added to
! coarse grid Alpha_path_polarized (1/4 1/2 1/4) instead of to diagonal of
! incoptdepth_pol.  This make Alpha_path_polarized correct for later use
! in gl corrections.
!
! Revision 2.163  2003/07/15 23:07:21  vsnyder
! Simplify Freq_Avg
!
! Revision 2.162  2003/07/15 22:10:09  livesey
! Added support for hybridModel
!
! Revision 2.161  2003/07/15 18:16:48  livesey
! Catalog now split by sideband, also changed no_ele to max_ele in
! allocates
!
! Revision 2.160  2003/07/09 23:40:13  vsnyder
! Use new AllocateSlabs routine
!
! Revision 2.159  2003/07/09 22:27:42  vsnyder
! More futzing
!
! Revision 2.158  2003/07/09 20:23:50  vsnyder
! Futzing
!
! Revision 2.157  2003/07/09 20:14:19  livesey
! Anticipative bug fix commented out.
!
! Revision 2.156  2003/07/04 03:40:13  vsnyder
! Simplify dump in case exp(incoptdepth_pol) fails
!
! Revision 2.155  2003/07/04 02:50:15  vsnyder
! Simplify interface to Get_GL_Slabs_Arrays, correct a blunder introduced around July 17
!
! Revision 2.154  2003/06/27 23:43:34  vsnyder
! Remove unreferenced USE names
!
! Revision 2.153  2003/06/27 22:09:48  vsnyder
! Check status from rad_tran_pol and report an error if overflow occurred
!
! Revision 2.152  2003/06/27 00:59:53  vsnyder
! Simplify interface to Get_Species_Data
!
! Revision 2.151  2003/06/25 02:41:37  vsnyder
! Futzing
!
! Revision 2.150  2003/06/18 22:26:41  vsnyder
! Restored the check to the wrong place at 2.149
!
! Revision 2.149  2003/06/18 19:29:30  vsnyder
! Replace a check inadvertently deleted in rev 2.146
!
! Revision 2.148  2003/06/18 17:23:16  bill
! fixed NAG associated bug
!
! Revision 2.147  2003/06/18 14:54:04  bill
! added subsetting feature for T-ders
!
! Revision 2.146  2003/06/18 01:59:20  vsnyder
! Move checking that all signals in config are for same radiometer, module
! and sideband, and computation of sidebandStart and sidebandStop, to
! ForwardModelSupport.  Remove vector quantity validation, as that's now
! done in Construct.  Futzing.
!
! Revision 2.145  2003/06/13 00:00:27  vsnyder
! Move multiplication of Beta_path by tanh into FullForwardModel
!
! Revision 2.144  2003/06/10 15:06:54  bill
! fixed polarized t-derivs
!
! Revision 2.143  2003/06/09 20:52:37  vsnyder
! More work on polarized derivatives
!
! Revision 2.142  2003/06/09 17:38:47  livesey
! Use GetQuantityForForwardModel in more places
!
! Revision 2.141  2003/05/29 16:37:38  livesey
! Renamed sideband fraction
!
! Revision 2.140  2003/05/26 01:42:50  michael
! Two temporary fixes only relevant to the polarized model.
! Added a bug-fix removing scalar contribution to magnetic GL.
! I don't know why this works but it makes agreement with scalar model
! much better.  I also added an undocumented switch -Scrosspol to allow
! the use of the (2,2) element of the radiance tensor rather than the (1,1).
! This code should be removed when we set up the l2cf to do this properly.
!
! Revision 2.139  2003/05/22 20:01:17  vsnyder
! Cosmetic changes
!
! Revision 2.138  2003/05/22 04:03:41  livesey
! Now handles elevation offset as a channel by channel quantity
!
! Revision 2.137  2003/05/20 00:05:39  vsnyder
! Move some stuff to subroutines
!
! Revision 2.136  2003/05/15 03:29:44  vsnyder
! Implement polarized model's temperature derivatives
!
! Revision 2.135  2003/05/09 19:26:36  vsnyder
! Expect T+DT instead of T and DT separately in Get_GL_Slabs_Arrays,
! initial stuff for temperature derivatives of polarized radiance.
!
! Revision 2.134  2003/05/05 23:00:24  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.126.2.40  2003/04/24 21:57:05  vsnyder
! Check FwdModelConf%incl_cld instead of associated(cloudIce)
!
! Revision 2.126.2.39  2003/04/24 19:01:19  vsnyder
! Compute MIF correctly
!
! Revision 2.126.2.38  2003/04/16 20:44:20  vsnyder
! Move allocate for scat_src%values out of the loops
!
! Revision 2.126.2.37  2003/04/16 19:32:02  vsnyder
! Move working storage for T_Scat into T_Scat
!
! Revision 2.126.2.36  2003/04/15 23:45:45  vsnyder
! Correct choice of mag field coordinate indices, futzing
!
! Revision 2.126.2.35  2003/04/15 17:55:19  jonathan
! FullForwardModel_m.f90 change scat_src as non-pointer
!
! Revision 2.126.2.34  2003/04/15 14:18:22  jonathan
! interpolate scat_src%values to LOS
!
! Revision 2.126.2.33  2003/04/10 16:16:06  jonathan
! fix bug
!
! Revision 2.126.2.32  2003/04/08 21:44:23  jonathan
! remove if condition for Modify_values_for_supersat
!
! Revision 2.126.2.31  2003/04/07 17:13:52  jonathan
! modified cal to T_scat
!
! Revision 2.126.2.30  2003/04/04 20:43:53  jonathan
! update call to T_scat
!
! Revision 2.126.2.29  2003/03/28 18:14:19  jonathan
! add new scaterring source module
!
! Revision 2.126.2.28  2003/03/27 23:32:19  vsnyder
! Houst a reshape out of a loop
!
! Revision 2.126.2.27  2003/03/27 00:50:35  vsnyder
! Get ECRtoFOV, use it to rotate mag_path
!
! Revision 2.126.2.26  2003/03/22 04:19:13  vsnyder
! Cosmetic changes
!
! Revision 2.126.2.25  2003/03/22 04:03:04  vsnyder
! Move Beta_Group_T and Dump_Beta_Group from get_Beta_path to Get_Species_Data
!
! Revision 2.126.2.24  2003/03/22 02:48:53  vsnyder
! Interpolate the magnetic field onto the path
!
! Revision 2.126.2.23  2003/03/21 02:49:55  vsnyder
! Use an array of pointers to quantities instead of searching several times
! using GetQuantityForForwardModel.  Move stuff around.  Cosmetic changes.
!
! Revision 2.126.2.22  2003/03/20 19:21:05  vsnyder
! More futzing with grids_t and stuff that uses it
!
! Revision 2.126.2.21  2003/03/20 01:42:25  vsnyder
! Revise Grids_T structure
!
! Revision 2.126.2.19  2003/03/07 23:17:05  vsnyder
! Use ASSOCIATED instead of PRESENT for "optional" arguments GET_CHI_OUT
!
! Revision 2.126.2.18  2003/03/06 22:47:29  vsnyder
! Polarized radiative transfer sort-of works
!
! Revision 2.126.2.17  2003/03/05 03:40:07  vsnyder
! Do tanh correction for polarized, more polarized work, simplifications
!
! Revision 2.126.2.16  2003/03/04 20:24:44  dwu
! add a temporay fix for the tangent height crossover problem
!
! Revision 2.126.2.15  2003/03/01 03:19:28  vsnyder
! More work on polarized radiative transfer.  Still doesn't work, but at
! least it doesn't break the nonpolarized case.
!
! Revision 2.126.2.14  2003/02/28 00:15:59  vsnyder
! Print 3 digits in channel number in 'rad' diagnostic output
!
! Revision 2.126.2.13  2003/02/27 23:35:01  vsnyder
! Revise polarized processing
!
! Revision 2.126.2.12  2003/02/25 00:53:09  jonathan
! add grids_tscat
!
! Revision 2.126.2.11  2003/02/24 23:40:31  jonathan
! change input for get_Beta_path_cloud
!
! Revision 2.126.2.10  2003/02/24 23:26:43  jonathan
! change temp_supersat to temp_prof
!
! Revision 2.126.2.9  2003/02/22 00:49:26  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
! Revision 2.126.2.8  2003/02/21 21:34:32  michael
! Made index for dumping dacs radiances be 1:129 for dacs channels 0:128
!
! Revision 2.126.2.7  2003/02/15 00:29:11  vsnyder
! Don't exp(incoptdepth) in mcrt -- it's done here
!
! Revision 2.126.2.6  2003/02/14 23:31:14  vsnyder
! Delete unreferenced names
!
! Revision 2.126.2.5  2003/02/14 23:27:31  vsnyder
! Move stuff to Get_Species_Data
!
! Revision 2.126.2.4  2003/02/14 03:53:41  vsnyder
! Initial commit of polarized model
!
! Revision 2.126.2.3  2003/02/14 00:21:42  jonathan
! add singl. scat. albedo W0, ph funct PHH
!
! Revision 2.126.2.2  2003/02/13 22:26:18  jonathan
! changes dimension for Beta_path_cloud also delocate it
!
! Revision 2.126.2.1  2003/02/13 17:35:01  bill
! fixes gl_ind bug and interfaces to get_Beta
!
! Revision 2.126  2003/02/11 00:48:18  jonathan
! changes made after adding get_Beta_path_cloud
!
! Revision 2.125  2003/02/08 01:03:00  livesey
! Bug fix in call to rad_tran
!
! Revision 2.124  2003/02/07 01:07:41  jonathan
! add in option to compute dry and super-saturation case in load_sps
!
! Revision 2.123  2003/02/06 22:04:25  vsnyder
! Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
!
! Revision 2.122  2003/02/06 19:15:47  jonathan
!  fix a bug
!
! Revision 2.121  2003/02/06 19:06:49  jonathan
! add eta_iwc, eta_iwc_zp, do_calc_iwc, do_cala_iwc_zp and also not passing
! through comp_eta_docalc and comp_sps_path_frq if fwdModelConf%Incl_Cld is
! false
!
! Revision 2.120  2003/02/06 05:55:47  livesey
! Fix to sort of fix Jonathan's cloud ice stuff.
!
! Revision 2.119  2003/02/06 00:20:08  jonathan
! Add in many stuff to deal with clouds CloudIce, iwc_path, etc
!
! Revision 2.118  2003/02/03 23:18:43  vsnyder
! Squash a bug in deallocating Beta_path_polarized
!
! Revision 2.117  2003/02/03 22:58:17  vsnyder
! Plug a memory leak, delete gl_ndx, some polarized stuff
!
! Revision 2.116  2003/02/03 19:00:36  bill
! changed interface to rad tran to speed up program
!
! Revision 2.115  2003/02/01 02:33:22  vsnyder
! Plug a bunch of memory leaks
!
! Revision 2.114  2003/01/31 17:53:39  jonathan
! change z_path to z_path_c in passing to get_Beta_path
!
! Revision 2.113  2003/01/31 17:15:49  jonathan
! add Inc_Cld to get_Beta_path
!
! Revision 2.112  2003/01/31 01:53:01  vsnyder
! Move array temps to arrays explicitly allocated outside the loop
!
! Revision 2.111  2003/01/30 00:16:35  jonathan
! add z_path to get_Beta_path
!
! Revision 2.110  2003/01/26 04:42:42  livesey
! Added profiles/angle options for phiWindow
!
! Revision 2.109  2003/01/21 18:20:32  vsnyder
! Put dimensions back onto actual arguments to path_contrib
!
! Revision 2.108  2003/01/18 03:36:09  vsnyder
! Undo ill-advised cosmetic changes -- that weren't cosmetic
!
! Revision 2.106  2003/01/16 23:13:03  livesey
! Added MaxRefraction stuff
!
! Revision 2.105  2003/01/16 18:04:01  jonathan
! add Do_1D option to get_gl_slabs_arrays
!
! Revision 2.104  2003/01/14 21:48:58  jonathan
! add i_saturation
!
! Revision 2.103  2003/01/10 21:55:26  vsnyder
! Move SpeedOfLight from Geometry ot Units
!
! Revision 2.102  2003/01/08 00:16:39  vsnyder
! Use "associated" instead of "present" to control optional computations.
! Cosmetic changes, too.
!
! Revision 2.101  2002/12/12 01:12:47  vsnyder
! Let InvalidQuantity have a length > 1
!
! Revision 2.100  2002/11/15 01:33:08  livesey
! Added allLinesForRadiometer functionality.
!
! Revision 2.99  2002/11/13 17:07:44  livesey
! Passes FwdModelExtra into convolve/no_conv
!
! Revision 2.98  2002/10/26 00:13:35  livesey
! Made the warning about lines less common as it checks for continuum
! aswell.
!
! Revision 2.97  2002/10/25 01:12:43  livesey
! Added an array to accumulate the stuff such as one_tan_ht etc.
! Also put in but commented out some code to dump it.
!
! Revision 2.96  2002/10/10 19:38:22  vsnyder
! Mostly cosmetic, some performance improvements
!
! Revision 2.95  2002/10/10 01:46:50  livesey
! Whoops, typo fix
!
! Revision 2.94  2002/10/10 01:28:06  livesey
! Bug fix in k_temp windowing
!
! Revision 2.93  2002/10/08 17:08:03  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.92  2002/10/04 23:49:50  vsnyder
! More cosmetic changes
!
! Revision 2.91  2002/10/02 23:06:42  vsnyder
! Add 'seez' switch, instead of uncommenting include, to get Zvi's debug print.
! Get SpeedOfLight from Geometry.  Cosmetic changes.
!
! Revision 2.90  2002/09/26 18:02:49  livesey
! Now uses GetQuantityForForwardModel.
!
! Revision 2.89  2002/09/10 17:05:38  livesey
! New update arguments to convolve/noconvole
!
! Revision 2.88  2002/09/07 02:18:50  vsnyder
! More cosmetic changes
!
! Revision 2.87  2002/09/06 20:23:22  livesey
! Merged in bug fixes with change from Van
!
! Revision 2.86  2002/09/06 18:19:04  vsnyder
! Cosmetic changes
!
! Revision 2.85  2002/09/05 21:00:38  vsnyder
! Get rid of some auxiliary variables
!
! Revision 2.84  2002/08/26 20:02:22  livesey
! Checks whether the jacobian is present when setting internal
! temp/atmos_der
!
! Revision 2.83  2002/08/22 23:13:03  livesey
! New intermediate frequency based frq_bases
!
! Revision 2.82  2002/08/20 23:33:23  livesey
! Fixed bug with handling of extinction
!
! Revision 2.81  2002/08/20 22:37:04  livesey
! Moved uses inside routine
!
! Revision 2.80  2002/08/02 00:12:07  bill
! just testing
!
! Revision 2.79  2002/07/31 23:27:54  bill
! added feature to user supply grid points to the psig and tangent grids
!
! Revision 2.78  2002/07/31 00:03:45  livesey
! Embarassing bug fix, was seeking wrong vector quantity.
!
! Revision 2.77  2002/07/30 20:03:59  livesey
! More sideband fixes
!
! Revision 2.76  2002/07/30 20:03:19  livesey
! Fixed bug which had it using the wrong sideband ratio
!
! Revision 2.75  2002/07/29 21:41:30  bill
! no changes, just debugging
!
! Revision 2.74  2002/07/23 22:26:31  livesey
! Added ptan_der, set k_atmos to zero on creation
!
! Revision 2.73  2002/07/19 23:35:49  bill
! fixed undefined surf angle
!
! Revision 2.72  2002/07/11 20:51:20  bill
! fixed bug regarding req
!
! Revision 2.71  2002/07/09 17:37:10  livesey
! Fixed more DACs problems
!
! Revision 2.70  2002/07/08 17:45:37  zvi
! Make sure spect_der is turned off for now
!
! Revision 2.69  2002/07/05 07:52:45  zvi
! Coor. switch (phi,z) -> (z,phi)
!
! Revision 2.68  2002/06/28 21:41:36  livesey
! Repeat of bug fix with atmos_der being deallocated in wrong place.
!
! Revision 2.67  2002/06/28 11:06:46  zvi
! Now computing dI/dPtan using chain rule
!
! Revision 2.66  2002/06/26 19:58:48  livesey
! Bug fix with DAC channel numbering
!
! Revision 2.65  2002/06/24 21:11:24  zvi
! Adding Grids_tmp stracture and modifying calling sequences
!
! Revision 2.61  2002/06/17 17:12:15  bill
! fixed yet another bug--wgr
!
! Revision 2.60  2002/06/17 16:30:52  bill
! inc zvis changes--wgr
!
! Revision 2.58  2002/06/13 22:40:38  bill
! some variable name changes--wgr
!
! Revision 2.57  2002/06/11 22:20:10  bill
! work in progress--wgr
!
! Revision 2.56  2002/06/07 23:22:58  bill
! add debug switch--wgr
!
! Revision 2.55  2002/06/07 23:01:25  bill
! work in progress
!
! Revision 2.54  2002/06/07 04:50:03  bill
! fixes and improvements--wgr
!
! Revision 2.53  2002/06/05 17:20:28  livesey
! Fixed tan_temp
!
! Revision 2.52  2002/06/04 23:06:47  livesey
! On the way to having phiTan
!
! Revision 2.51  2002/06/04 10:27:59  zvi
! Encorporate deriv. flag into convolution
!
! Revision 2.50  2002/05/28 17:09:14  livesey
! Removed print statement
!
! Revision 2.49  2002/05/24 17:10:57  livesey
! Fixed bug with my_catalog(?)%lines not being associated for parent
! species.
!
! Revision 2.48  2002/05/23 21:01:11  livesey
! No, that was the wrong thing to do.  Think a bit more.
!
! Revision 2.47  2002/05/23 20:55:20  livesey
! Put more checking around case where a molecule has no lines.
!
! Revision 2.46  2002/05/22 19:44:51  zvi
! Fix a bug in the mol. index loop
!
! Revision 2.45  2002/05/17 22:13:20  livesey
! Bug fix for case where channels start at zero.
!
! Revision 2.44  2002/05/14 22:40:45  livesey
! Bug fix in change in line gathering.  Never got to run it mercifully!
!
! Revision 2.43  2002/05/14 22:32:45  livesey
! Added single sideband stuff.  Also skip line gathering for parent
! molecules.
!
! Revision 2.42  2002/05/14 00:19:10  livesey
! Minor bug fixes
!
! Revision 2.41  2002/05/10 16:18:45  livesey
! Code for dealing with new channel shape information
!
! Revision 2.40  2002/05/08 08:53:42  zvi
! All radiometers grid concept implemented
!
! Revision 2.39  2002/05/03 23:29:18  livesey
! Added direction and split sideband ratio stuff
!
! Revision 2.38  2002/02/22 00:52:06  bill
! fixed units error for light speed--wgr
!
! Revision 2.37  2002/02/20 22:19:45  zvi
! Reversing the subset logic ..
!
! Revision 2.36  2002/02/16 10:32:16  zvi
! Fixing small bug..
!
! Revision 2.35  2002/02/16 06:49:59  zvi
! Retain deriv flag code ..
!
! Revision 2.32  2002/02/14 19:05:01  bill
! Fixed no spectral avg bug--wgr
!
! Revision 2.31  2002/02/13 20:35:47  livesey
! Added some nullifies
!
! Revision 2.30  2002/02/08 00:46:05  zvi
! Some cosmetic changes..
!
! Revision 2.29  2002/02/07 00:36:31  zvi
! Fix a bug - phi_tan non defined..
!
! Revision 2.28  2002/02/05 21:54:29  zvi
! Fix a bug ..
!
! Revision 2.27  2002/02/04 22:44:40  zvi
! Fixing some bugs in the automatic grid selection process
!
! Revision 2.26  2002/02/02 11:20:17  zvi
! Code to overwrite the l2cf integration & tanget grids
!
! Revision 2.25  2002/01/30 01:11:18  zvi
! Fix bug in user selectable coeff. code
!
! Revision 2.24  2002/01/27 08:37:45  zvi
! Adding Users selected coefficients for derivatives
!
! Revision 2.22  2002/01/08 01:01:19  livesey
! Some changes to my_catalog and one_tan_height and one_tan_temp
!
! Revision 2.21  2001/12/26 04:05:04  zvi
! Convert phi_tan to Radians
!
! Revision 2.20  2001/12/14 23:43:05  zvi
! Modification for Grouping concept
!
! Revision 2.19  2001/11/25 07:57:12  zvi
! Fixing inconsistency in k_xxx instance loops
!
! Revision 2.18  2001/11/20 10:23:27  zvi
! Fixing window bug & diemsion
!
! Revision 2.17  2001/11/20 01:18:59  zvi
! Fixing Shifting Window bug
!
! Revision 2.16  2001/11/15 01:21:57  zvi
! Extiction debug fix
!
! Revision 2.15  2001/11/10 00:46:40  zvi
! Adding the EXTINCTION capabilitis
!
! Revision 2.14  2001/11/08 21:52:23  jonathan
! add spec_tags to Molecules
!
! Revision 2.13  2001/11/08 09:56:59  zvi
! Fixing a bug..
!
! Revision 2.12  2001/11/08 00:11:29  livesey
! Added extinction stuff
!
! Revision 2.11  2001/11/07 21:19:01  livesey
! Put Zvi's change comments back
!
! Revision 2.10  2001/11/07 21:16:56  livesey
! Now defaults to *not* using a line if no bands listed.
!
! Revision 2.9  2001/11/07 09:58:41  zvi
! More effective code for sps_path calculations
!
! Revision 2.8  2001/11/03 01:33:35  livesey
! Add more informative message if no spectroscopy information available
! for a molecule
!
! Revision 2.7  2001/11/02 10:47:57  zvi
! Implementing frequecy grid
!
! Revision 2.6  2001/10/12 20:40:25  livesey
! Moved sideband ratio check
!
! Revision 2.5  2001/10/09 22:39:08  livesey
! Allow for molecules with zero lines.  This may need attention
! from Bill/Zvi later on.
!
! Revision 2.4  2001/10/02 16:51:41  livesey
! Removed fmStat%finished and reordered loops in forward models
!
! Revision 2.3  2001/09/19 04:38:48  livesey
! Lines per band stuff works now
!
! Revision 2.2  2001/09/18 02:04:38  livesey
! Bug fix with signals/spectroscopy interaction
!
! Revision 2.1  2001/09/18 01:23:19  livesey
! Added band discrimination for lines catalog.  Not tested yet.
!
! Revision 2.0  2001/09/17 20:26:25  livesey
! New forward model
!
! Revision 1.5.2.56  2001/09/14 22:19:39  livesey
! Fixed bug with sv_i in frequency averaging of k_atmos_frq
!
! Revision 1.5.2.55  2001/09/13 19:57:43  livesey
! Fixed a small memory leak
!
! Revision 1.5.2.54  2001/09/13 19:36:27  livesey
! Added some more useful diagnotics/trace statements
!
! Revision 1.5.2.53  2001/09/13 11:18:15  zvi
! Fix temp. derv. bug
!
! Revision 1.5.2.52  2001/09/13 02:03:08  livesey
! Left a print statement in by mistake
!
! Revision 1.5.2.51  2001/09/13 01:48:39  livesey
! Added lots of deallocates, slight problem with temperature derivatives
! and convolution.
!
! Revision 1.5.2.50  2001/09/13 00:42:18  livesey
! Fixed memory leak

! Revision 1.5.2.49  2001/09/12 23:44:18  livesey
! Fixed bug with calling sequence for metrics

! Revision 1.5.2.48  2001/09/12 22:56:05  livesey
! Got rid of print statement.

! Revision 1.5.2.47  2001/09/12 22:46:26  livesey
! Put dimension limit back on dh_dt_path

! Revision 1.5.2.46  2001/09/12 22:38:25  livesey
! Bug fix

! Revision 1.5.2.45  2001/09/12 04:42:32  zvi
! Fixing Conv. bug

! Revision 1.5.2.44  2001/09/12 01:00:34  livesey
! Fixed problem with vmr derivatives

! Revision 1.5.2.43  2001/09/12 00:32:36  livesey
! Fixed printing

! Revision 1.5.2.42  2001/09/12 00:30:00  zvi
! Put printing stmt. back

! Revision 1.5.2.41  2001/09/12 00:12:03  livesey
! Single channel no convolution, derivatives or frequency averaging works

! Revision 1.5.2.40  2001/09/11 21:24:27  livesey
! Interim version

! Revision 1.5.2.39  2001/09/11 20:48:04  livesey
! Added dump and stop statement

! Revision 1.5.2.38  2001/09/11 20:48:22  zvi
! Develop.

! Revision 1.5.2.37  2001/09/11 08:13:33  zvi
! Fixing bugs, adding printing code

! Revision 1.5.2.36  2001/09/11 01:36:54  livesey
! More tidy ups

! Revision 1.5.2.35  2001/09/11 01:27:14  livesey
! It compiles

! Revision 1.5.2.34  2001/09/11 00:50:32  zvi
! Convolution code..done

! Revision 1.5.2.33  2001/09/11 00:01:06  zvi
! adding convolution..incomplete yet

! Revision 1.5.2.32  2001/09/10 23:50:47  livesey
! Added a use statement

! Revision 1.5.2.31  2001/09/10 23:34:51  zvi
! Added freq_avg code..

! Revision 1.5.2.30  2001/09/10 21:07:58  livesey
! Interim

! Revision 1.5.2.29  2001/09/10 21:06:42  livesey
! Interim

! Revision 1.5.2.28  2001/09/10 20:46:42  livesey
! Interim

! Revision 1.5.2.27  2001/09/10 20:24:06  livesey
! More tidying up

! Revision 1.5.2.26  2001/09/10 19:56:36  livesey
! Added call to AllocateOneSlabs

! Revision 1.5.2.25  2001/09/10 19:38:19  livesey
! Tidied up variable definitions a bit.

! Revision 1.5.2.24  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90

! Revision 1.5.2.23  2001/09/09 11:17:43  zvi
! Cleaning up..

! Revision 1.5.2.22  2001/09/09 03:16:48  livesey
! End of working day (ha ha!)

! Revision 1.5.2.21  2001/09/09 03:03:25  livesey
! More

! Revision 1.5.2.20  2001/09/09 03:02:53  zvi
! more definitions ..

! Revision 1.5.2.19  2001/09/09 02:42:52  zvi
! more definitions ..

! Revision 1.5.2.18  2001/09/09 02:16:56  livesey
! More..

! Revision 1.5.2.17  2001/09/09 02:18:03  zvi
! more definirions ..

! Revision 1.5.2.16  2001/09/09 01:57:31  livesey
! Work

! Revision 1.5.2.15  2001/09/09 01:57:41  zvi
! more Allocatios ..

! Revision 1.5.2.14  2001/09/09 01:40:18  livesey
! More work

! Revision 1.5.2.13  2001/09/09 01:41:58  zvi
! Allocatios ..

! Revision 1.5.2.12  2001/09/09 00:43:34  zvi
! more metric work

! Revision 1.5.2.11  2001/09/09 00:09:15  livesey
! Another intermediate

! Revision 1.5.2.10  2001/09/08 23:47:52  livesey
! More updates

! Revision 1.5.2.9  2001/09/08 23:11:23  livesey
! Sent to zvi

! Revision 1.5.2.8  2001/09/08 21:41:14  zvi
! Starting to import codes

! Revision 1.5.2.7  2001/09/07 22:49:10  livesey
! Very intermediate

! Revision 1.5.2.6  2001/09/07 22:34:21  zvi
! change comments..

! Revision 1.5.2.5  2001/09/07 22:18:04  livesey
! More comments

! Revision 1.5.2.4  2001/09/07 20:16:37  livesey
! Changed stuff to lower case

! Revision 1.5.2.3  2001/09/07 20:05:26  livesey
! Cosmetic change again.

! Revision 1.5.2.2  2001/09/07 19:58:49  zvi
! Starting new code developement

! Revision 1.5  2001/07/04 00:34:24  zvi
! Modified & new code(s) for better timing

! Revision 1.4  2001/06/22 02:35:08  zvi
! Fixing some memory leaks..

! Revision 1.3  2001/06/21 15:05:42  livesey
! Gets tolerance from fwdModelConf

! Revision 1.2  2001/06/21 13:07:08  zvi
! Speed enhancement MAJOR update

! Revision 1.1  2001/05/29 22:53:51  livesey
! First version, taken from old ForwardModelInterface.f90
@


2.410
log
@In middle of debugging pol fwdmdl
@
text
@d3078 1
a3078 1
          print *, 'Calling drad_tran_df polarized'
d3116 2
a3117 2
          print *, 'VMR derivatives for polarized radiance.'
          print *, shape(de_df(:,:,1:p_stop,:))
d3128 2
a3129 2
          print *, 'Compute D radiance / Df.'
          print *, shape(de_df(:,:,1:npc,:))
d3136 1
a3136 1
            print *, 'l_a'
d3139 1
a3139 1
            print *, 'not l_a'
d3142 2
a3143 2
          if ( any(abs(k_atmos_frq(:)) > 0.) ) &
            & print *, 'non-zero'
d4037 1
a4037 1
       "$Id: FullForwardModel_m.f90,v 2.409 2020/08/28 21:41:58 vsnyder Exp $"
d4047 3
@


2.409
log
@Set up to calculate chi angles for QTM
@
text
@d3078 1
d3112 6
d3128 2
d3136 1
d3139 1
d3142 2
d4037 1
a4037 1
       "$Id: FullForwardModel_m.f90,v 2.408 2020/05/05 23:57:56 vsnyder Exp $"
d4047 3
@


2.408
log
@Made F_and_V_MIF dummy argument of FullForwardModelAuto allocatable. Intel
ifort 19 gets a seg fault at the call if the actual argument is not allocated,
which it isn't if the run isn't QTM.
@
text
@d296 1
a296 1
      ScECR_MIF => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
d530 5
a534 6
                              & Q_LOS,                                         &
                              & QTM_Paths, F_and_V, F_and_V_MIF, no_mol,       &
                              & noUsedChannels, no_sv_p_T,                     &
                              & n_t_zeta, sv_t_len, nlvl,                      &
                              & no_tan_hts, surfaceTangentIndex,  max_c,       &
                              & maxVert, max_f, ptan_der,                      &
d583 1
a583 1
                             & Q_LOS, QTM_Paths,                               &
d678 2
d1483 1
a1483 1
        if ( thisSideband == fwdModelConf%sidebandStart ) &
d1485 2
a1486 3
!????? Need work here for QTM, especially Grids_Tmp, which is used
!????? for calculating Chi angles.
          & call convolution_setup ( dh_dz_out, dx_dh_out, dxdT_surface, &
d1494 12
d1706 1
a1706 1
      if ( FwdModelConf%polarized ) then
d3708 22
a3729 20
      if ( present(est_scGeocAlt) .and. .not. fwdModelConf%generateTScat .and. &
         & thisSideband == fwdModelConf%sidebandStart ) then
        ! Compute the pointing angles.  These are needed for antenna
        ! convolution, not for ray tracing.  They are the same for both
        ! sidebands, so there's no need to compute them twice.  We can't easily
        ! move these computations into the convolution code because they need
        ! Tan_Ht_s and Req_s, which are gotten from Tangent_Metrics and
        ! Height_Metrics.
        n_path_inst = merge ( n_path_c(1), 0.0_rp, usingQTM )
        if ( temp_der ) then
          ! Est_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
          call get_chi_angles ( 0.001_rp*est_scGeocAlt, n_path_c(tan_pt_c), &
             & n_path_inst, tan_ht_s, tan_phi, req_s, 0.0_rp, &
             & ptg_angles(ptg_i), tan_dh_dt, tan_d2h_dhdt, dx_dt(ptg_i,:), &
             & d2x_dxdt(ptg_i,:) )
        else
          ! Est_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
          call get_chi_angles ( 0.001_rp*est_scGeocAlt, n_path_c(tan_pt_c), &
             & n_path_inst, tan_ht_s, tan_phi, req_s, 0.0_rp, &
             & ptg_angles(ptg_i) )
d3731 20
d4024 1
a4024 1
       "$Id: FullForwardModel_m.f90,v 2.407 2020/04/22 01:59:27 vsnyder Exp $"
d4034 5
@


2.407
log
@Move TScat stuff to includes. Some work on QTM chi angles
@
text
@d60 5
d682 5
a686 4
    type (Facets_and_Vertices_t), intent(in) :: F_and_V_MIF(:) ! of QTM under MIF
                                            ! paths.  Used for hydrostatic equilibrium
                                            ! calculation that is used to calculate
                                            ! MIF-based Chi angles.
d2827 20
d3990 1
a3990 1
       "$Id: FullForwardModel_m.f90,v 2.406 2020/02/07 01:11:08 pwagner Exp $"
d4000 3
@


2.406
log
@Offers advice and sympathy if fwdmdl config fails superset test
@
text
@d634 1
d915 4
a918 4
    real(rp) :: R_Eq  ! Radius of equivalent circular Earth tangent to the surface
                      ! of the Earth reference ellipsoid at the surface location
                      ! of the tangent point, in the plane defined by the line of
                      ! sight and the center of the Earth.
d1125 1
a1125 1
    ! Coarse-zeta grid tangent quantities interpreted from intermediate
d1429 2
a1441 7
          ! Calculate R_Eq in the orbit plane projected ellipse, for which
          ! Earthradc_sq has the same value for all tangent points in the
          ! non-QTM case because they're all in the same plane, but might have
          ! different values for each tangent point in the QTM case because
          ! they're not necessarily all in the same plane.
          r_eq = get_r_eq ( tan_phi(ptg_i), earthradc_sq(ptg_i) )

d1444 4
d1452 5
d1463 1
a1463 1
              &                 f_and_v=F_and_V(ptg_i) )
d1743 1
a1743 1
            & orbit_plane_minor_axis_sq ( orbIncline%values(1,maf) * deg2rad )
d2428 1
a2428 617
    subroutine Generate_TScat ( FwdModelConf )

      ! Generate tables of TScat and its derivatives w.r.t. temperature
      ! and IWC.  The geometric calculations are described in wvs_074.

      use Constants, only: PI
      use Convolve_All_m, only: Store_Other_Deriv, Store_Temperature_Deriv
      use ForwardModelConfig, only: ForwardModelConfig_T, QtyStuff_t
      USE Load_SPS_Data_m, only: FindInGrid
      use MLSNumerics, only: Coefficients, InterpolateArraySetup, &
        & InterpolateArrayTeardown
      use MLSSignals_m, only: GetNameOfSignal
      use Molecules, only: L_CloudIce
      use Read_Mie_m, only: DP_DIWC, DP_DT, F_S, IWC_S, P, T_S, Theta_S
      use Sort_m, only: Sortp
      use Sparse_Eta_m, only: Sparse_Eta_t
      use Tscat_Support_m, only: Interpolate_P_To_Theta_E
      use VectorsModule, only: Dump

      type(forwardModelConfig_T), intent(in) :: FwdModelConf

      real(rp) :: DPhi         ! Scat_Phi - Phi_Ref
      real(rp) :: DPhi_Xi      ! dPhi - xi = psi in wvs-074
      real(rp) :: DXi          ! acos(cos(xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1))))
      type(sparse_eta_t) :: Eta_s ! Coeffs to Scat_Tan_Phi
      real(rp) :: Phi_Old      ! Used during iteration for Scat_Tan_Phi
      real(rp) :: Phi_Ref      ! Tangent phi for the scattered ray
      real(rp) :: Rads(noUsedChannels,4*nlvl+2*scatteringAngles%template%noSurfs)
      real(r4) :: K_Atmos_TScat(noUsedChannels,size(rads,2),s_a*size(grids_f%values))
      real(rp) :: K_Atmos_p(s_a*size(grids_f%values)) ! K_Atmos convolved with P
      real(r4) :: K_Temp_TScat(noUsedChannels,size(rads,2),s_t*sv_t_len)
      real(rp) :: K_Temp_p(s_t*sv_t_len) ! K_Temp convolved with P
      real(rp) :: LogIWC       ! log10(iwc)
      real(rp) :: P_On_Xi(size(rads,2)) ! P * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: dP_dIWC_On_Xi(size(rads,2)) ! dP/dIWC * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: dP_dT_On_Xi(size(rads,2)) ! dP/dT * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: R_Eq         ! Equivalent circular earth radius at Phi_Ref
      real(rp) :: Scat_Ht      ! km from center of equivalent circular earth
      real(rp) :: Scat_Phi     ! Of the scattering point, radians
      real(rp) :: Scat_Tan_Ht  ! Of the ray to be scattered, Km from center
      real(rp) :: Scat_Tan_Phi ! Of the ray to be scattered
      real(rp) :: Scat_Zeta    ! Of the scattering point
      real(rp) :: Theta        ! Angle from direct to reflected
                               ! earth-intersecting ray
      real(rp) :: Theta_e(2*size(theta_s)+1) ! Extended to -theta_s
      real(rp) :: Vel_Rel      ! LOS velocity / speed of light, along scattered
                               ! ray
      real(rp) :: Xi           ! Scattering angle
      real(rp) :: Xi_Sub       ! Angle from horizon to scattering point's
                               ! subsurface point
      real(rp) :: Xis(size(rads,2))

      ! Interpolating factors
      type(sparse_eta_t) :: Eta_IWC, Eta_T, Eta_T_IWC

      integer :: Beg_Pos_Theta ! 1 if theta_s(1) /= 0, else 2
!       integer :: IWC_IX        ! Which IWC index for phase function
!       integer :: T_IX          ! Which Temperature index for phase function

      integer :: F_I           ! Frequency (channel) index
      logical :: Forward       ! Half-ray is an earth-intersecting ray
                               ! in the forward direction, xi >= xi_sub
      integer :: Freq_Ix(noUsedChannels) ! Frequency indices for phase tables
      integer :: Grid_IWC      ! Index in grids_f%values for cloud
      integer :: Grid_T        ! Index in grids_tmp%values
      integer :: I             ! Loop inductor
      integer :: I_R           ! Index in Rad, Xis, eventually number of them
      integer :: I_Z           ! Index of scattering point zeta in Z_psig
      integer :: Me = -1       ! String index for trace
      integer :: N_Theta_e     ! size(theta_e) or size(theta_e)-1, depending
                               ! upon whether theta_e covers 0..360 or lacks one
      integer :: Phi_i         ! Loop inductor and subscript
      integer :: Ptg_i, Ptg_j  ! Loop inductors and subscripts
      logical :: Reject        ! Reject the scattering point
      integer :: Sort_Xi(size(Xis)) ! Permutation vector to sort Xis
      integer :: Surf_i        ! Surface (first) subscript for TScat%values,
                               ! which combines frequency and zeta index
      logical :: Switch42      ! "42" appears in Switches
      integer :: Zeta_i        ! Loop inductor and subscript for TScat zetas
      integer :: Zeta_f        ! I_z on find grid

      character(128) :: Sig    ! Signal name, scratch for debug output

      type (coefficients(rp)) :: Coeffs_Theta_e_Xi ! To interpolate from Theta_e to Xi
      type (QtyStuff_T) :: TScats(noUsedChannels)
      type (VectorValue_T), pointer :: TScat

      real(rp), parameter :: PIX2 = 2.0_rp * pi
      real(rp), parameter :: PID2 = 0.5 * pi

      call trace_begin ( me, 'Generate_TScat', cond=toggle(emit) )
      switch42 = switchDetail(switches,"42") > -1
      if ( switch42 ) write ( 42, '(a)' ) &
        & 'Phi_Ref  Scat_Phi  Scat_Ht   Scat_Zeta      Xi     Rad    Signal'

      ! Work out by-channel stuff

      ! Get channel centers if we don't already have them
      if ( fwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) .and. .not. &
        &  fwdModelConf%anyPFA(sx) ) &
          & call get_channel_centers ( thisSideband, channelCenters )

      if ( print_TScat .or. print_TScat_detail > -1 ) &
        & call output ( "Signals used for TScat computation:", advance="yes" )
      do f_i = 1, noUsedChannels
        ! Vector quantities for results, one for each channel
        TScats(f_i)%qty => GetQuantityForForwardModel ( &
          & fwdModelOut, quantityType=l_TScat, &
          & signal=fwdModelConf%signals(channels(f_i)%signal)%index, &
          & sideband=sideband, config=fwdModelConf )
        TScats(f_i)%qty%values = 0.0 ! Is this needed?
        if ( print_TScat .or. print_TScat_detail > -1 ) then
          call GetNameOfSignal ( fwdModelConf%signals(channels(f_i)%signal), sig, &
            & channel=channels(f_i)%used, sideband=thisSideband )
          call output ( trim(sig), advance="yes" )
        end if
        ! Choose which frequency panel of phase function to use (don't
        ! bother interpolating because the change as a result of the change
        ! of frequency within a single radiometer is small).  Make sure it's
        ! close enough.
        freq_ix(f_i) = minloc(abs(channelCenters(f_i)-f_s),1)
        if ( abs(channelCenters(f_i)-f_s(freq_ix(f_i))) > fwdModelConf%frqTol ) then
          call output ( f_i, before="f_i = " )
          call output ( freq_ix(f_i), before=", freq_ix(f_i) = " )
          call output ( f_s(freq_ix(f_i)), before=", f_s(freq_ix(f_i)) = " )
          call output ( channelCenters(f_i), before=", channelCenters(f_i) = " )
          call output ( fwdModelConf%frqTol, before=", fwdModelConf%frqTol = ", &
            & advance='yes' )
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'In TScat computation, phase function frequency coordinate too far from desired frequency' )
        end if
      end do

      ! Get TScat quantity for first signal, to access its grids (they all have
      ! the same grids)
      TScat => TScats(1)%qty

      vel_rel = LOSVel%values(FwdModelConf%TScatMIF,MAF) / speedOfLight

      phi_ref = mod(phitan%values(FwdModelConf%TScatMIF,MAF),360.0_r8) * deg2rad
      r_eq = get_R_eq ( phi_ref, earthradc_sq(1) )

      if ( print_TScat_detail > 0 .and. .not. print_TScat_deriv > -1 .and. .not. &
        & print_incopt .and. .not. print_incrad .and. print_path <= 0 ) then
        call output ( rad2deg*phi_ref, before="Phi_Ref = " )
        call output ( r_eq, before=", R_eq = ", advance="yes" )
        ! Debugging output header
        call output ( TScat_Detail_Heading, advance="yes" )
      end if

      ! Create an array of theta's extended to negative values, onto which
      ! to interpolate the xi's.  The phase function is sign-symmetric on
      ! theta_s, but the radiances are not sign-symmetric on xi's.
      theta_e(1:size(theta_s)) = -theta_s(size(theta_s):1:-1)
      beg_pos_theta = merge(2,1,theta_s(1)==0.0)
      theta_e(size(theta_s)+1:2*size(theta_s)+1-beg_pos_theta) = &
        & theta_s(beg_pos_theta:)
      ! Set up theta_e to cover 2 pi, to prepare it for periodic spline
      ! interpolation to the input abscissa set.
      n_theta_e = 2*size(theta_s) + 1 - beg_pos_theta
      if ( abs(theta_e(n_theta_e)-theta_e(1)-pix2) > 0.001 ) then
        n_theta_e = n_theta_e + 1
        theta_e(n_theta_e) = theta_e(n_theta_e) + pix2
      end if

      ! Loop over observer zetas
      do zeta_i = 1, TScat%template%noSurfs
        scat_zeta = TScat%template%surfs(zeta_i,1)

        ! Find index of Z_psig element closest to scat_zeta.
        ! Assuming observer zetas got put into Z_psig as they should have been,
        ! this should hit one element exactly.  An absolute test is good enough
        ! because |zeta| is usually < 3.
        i_z = minloc(abs(z_psig-scat_zeta),1)
        if ( abs(z_psig(i_z)-scat_zeta) > &
          & sqrt(max(epsilon(scat_zeta),epsilon(z_psig))) ) then
          call output ( scat_zeta, before="Scattering point Zeta ", advance="yes" )
          call output ( i_z, before="Zeta grid Z_Psig(" )
          call output ( z_psig(i_z), before=") = " )
          call dump ( z_psig, name=", Entire Zeta grid" )
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'Scattering point Zeta does not appear to be in Zeta grid' )
        end if
        zeta_f = (i_z-1) * ngp1 + 1 ! On Z_GLgrid, for H_GLGrid

        ! Loop over observer phis
        do phi_i = 1, TScat%template%noInstances

          reject = .false.

          if ( iwc%values(zeta_i,phi_i) <= 0.0 ) then ! no IWC, no scattering
            call output ( mod(real(TScat%template%phi(1,phi_i)),360.0), &
              & before='Scattering point at (' )
            call output ( z_glgrid(zeta_f), before=',', &
              & after=') rejected because there is no IWC there.', advance='yes' )
            reject = .true.
          end if

          if ( .not. reject ) then
            logIWC = log10(iwc%values(zeta_i,phi_i))

            ! Get interpolating factors for scattering-point IWC to phase function
            ! IWC_s for Mie tables.
            ! IWC_s(iwc_ix) <= logIWC < IWC_s(iwc_ix+1_).
            reject = logIWC < IWC_s(1) .or. logIWC > IWC_s(size(IWC_s))
            if ( .not. reject ) then
              ! Get interpolating factors for scattering-point temperature to phase
              ! function temperatures.
              ! T_s(T_ix) <= temp%values(zeta_i,phi_i) < T_s(T_ix+1).
              reject = temp%values(zeta_i,phi_i) < T_s(1) .or. &
                     & temp%values(zeta_i,phi_i) > T_s(size(T_s))
            end if

            ! Reject the scattering point if IWC or T is outside the Mie table range.
            if ( reject ) then
              call output ( phi_i, before='Scattering point at (' )
              call output ( zeta_f, before=',' )
              call output ( mod(real(TScat%template%phi(1,phi_i)),360.0), before=') = (' )
              call output ( z_glgrid(zeta_f), format='(f5.2)', before=',', &
                & after=') rejected because T or IWC is outside Mie table range.' )
              call output ( temp%values(zeta_i,phi_i), format='(f6.2)', before='  T = ' )
              call output ( logIWC, before=', log10(IWC) = ', advance='yes' )
            end if
          end if

          if ( .not. reject ) then

            scat_phi = mod(TScat%template%phi(1,phi_i),360.0_r8) * deg2rad

            grid_IWC = findInGrid ( grids_f, scat_phi, scat_zeta, l_cloudIce )
            grid_t = findInGrid ( grids_tmp, scat_phi, scat_zeta )

            dPhi = scat_phi - phi_ref
            ! Interpolate in H_GLGrid at (phi_i,zeta_f) to get Scat_Ht
            call eta_s%eta ( Grids_tmp%phi_basis, scat_phi )
            scat_ht = eta_s%row_dot_vec ( 1, h_glgrid(zeta_f,:) )

            ! Subsurface scattering points handled by explicit angles
            if ( scat_ht < r_eq ) then
              call output ( mod(real(TScat%template%phi(1,phi_i)),360.0), &
                & before='Scattering point at (' )
              call output ( z_glgrid(zeta_f), before=',' )
              call output ( scat_ht, format='(f8.3)', &
                & before=') rejected because its height (' )
              call output ( r_eq, format='(f8.3)', &
                & before=') is below the Earth surface (', after=').', advance='yes' )
              reject = .true.
            end if
          end if

          ! Fill TScat and derivatives at rejected scattering points
          ! with zeros
          if ( reject ) then
            do f_i = 1, noUsedChannels
              TScat => TScats(f_i)%qty
              surf_i = channels(f_i)%used - channels(f_i)%origin + 1 + &
                     & TScat%template%noChans * (zeta_i-1)
              TScat%values(surf_i,phi_i) = 0.0
              if ( atmos_der ) then
                k_atmos_p = 0.0
                call store_other_deriv ( phi_i, surf_i, TScat, &
                                       & beta_group%qty, Grids_f, k_atmos_p, &
                                       & F_and_V, jacobian )
              end if
              if ( temp_der ) then
                k_temp_p = 0.0
                call store_temperature_deriv ( phi_i, surf_i, TScat, &
                                       & temp, grids_tmp, k_temp_p, &
                                       & F_and_V, jacobian )
              end if
            end do
            cycle
          end if

          ! First do pointings to each zeta surface below the scattering
          ! point zeta.  Pointings to specified angles aren't guaranteed to
          ! be tangent at a pressure in the zeta grid.

          i_r = 0
          do ptg_i = 1, i_z

            ! Handle earth-intersecting rays using explicit angles
            if ( ptg_i < surfaceTangentIndex ) cycle

            ! Compute scat_tan_ht and scat_tan_phi for the ray to be scattered.
            ! Start with scat_tan_phi == phi_ref and iterate.

            scat_tan_phi = phi_ref
            do i = 1, 20
              phi_old = scat_tan_phi

              ! Interpolate in H_GLGrid at (phi_i,zeta_f) to get Scat_Tan_Ht
              call eta_s%eta ( Grids_tmp%phi_basis, scat_tan_phi )
              scat_tan_ht = eta_s%row_dot_vec ( 1, h_glgrid(zeta_f,:) ) + &
                          & r_eq

              ! Compute scattering angle and tan phi for the ray to be
              ! scattered.  This is measured anti clockwise from the ray from
              ! the scattering point to the external observer, so the
              ! "downward" ray is at a negative angle.
              dPhi_xi = acos(min(scat_tan_ht,scat_ht)/scat_ht)
              xi = dPhi - dPhi_xi
              scat_tan_phi = phi_ref + xi
              if ( abs(scat_tan_phi-phi_old) < 0.0001 ) exit
            end do

            ! Handle earth-intersecting rays using explicit angles
            if ( scat_tan_ht < r_eq ) cycle

            ! Rays from the scattering point can't be tangent to higher altitudes

            if ( scat_tan_ht > scat_ht ) cycle

            ! If we're doing frequency averaging, get the frequencies we need
            ! for this pointing.

            if ( associated(whichPointingGrid) ) &
              & call frequency_setup_2 ( (1.0_rp - vel_rel) * &
                & whichPointingGrid%oneGrid(grids(ptg_i))%frequencies )

            ! Do the ray tracing and radiative transfer, four times: once each
            ! for forward and reverse scattering, and once each for upwelling
            ! and downwelling rays
            call one_tscat_ray ( ptg_i, 1, vel_rel, scat_tan_phi,    &
              &                  scat_zeta, scat_phi, scat_ht,       &
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, rev=.true. )

            xi = xi + pi
            call one_tscat_ray ( ptg_i, 2, vel_rel, scat_tan_phi,    &
              &                  scat_zeta, scat_phi, scat_ht,       &
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, rev=.false. )

            if ( abs(dPhi_xi) > epsilon(1.0) ) then
              ! The next two rays are different from the previous two
              xi = dPhi_xi + dPhi - pi
              ! Put xi in -180..180:
              if ( abs(xi) > pi ) xi = xi - sign(pix2,xi)
              scat_tan_phi = scat_tan_phi + 2.0 * dphi_xi
              call one_tscat_ray ( ptg_i, 3, vel_rel, scat_tan_phi,    &
                &                  scat_zeta, scat_phi, scat_ht,       &
                &                  r_eq, xi, xis, rads, k_atmos_TScat, &
                &                  k_temp_TScat, i_r, rev=.false. )

              xi = xi + pi
              ! Put xi in -180..180:
              if ( abs(xi) > pi ) xi = xi - sign(pix2,xi)
              call one_tscat_ray ( ptg_i, 4, vel_rel, scat_tan_phi,    &
                &                  scat_zeta, scat_phi, scat_ht,       &
                &                  r_eq, xi, xis, rads, k_atmos_TScat, &
                &                  k_temp_TScat, i_r, rev=.true. )
            end if

          end do ! ptg_i

          ! Now do pointings to specified angles, but only those that result
          ! in earth-intersecting rays.  Use the surface-pressure frequency
          ! pointing grid for all pointings.

          ! If we're doing frequency averaging, get the frequencies we need.

          if ( associated(whichPointingGrid) ) &
            & call frequency_setup_2 ( (1.0_rp - vel_rel) * &
              & whichPointingGrid%oneGrid(grids(1))%frequencies )

          do ptg_j = 1, scatteringAngles%template%noSurfs

            xi = scatteringAngles%template%surfs(ptg_j,1) * deg2rad

            ! Reject angles not pointing downward

            if ( xi > 0.0 .or. xi < -pi ) cycle

            ! Compute scat_tan_ht and scat_tan_phi for the ray to be scattered.

            ! Rays that aren't earth-intersecting rays must be handled by
            ! specified tangent zeta (else there is no unique tangent
            ! point), not by specified angle.  They could be handled by
            ! solving for tangent zeta using inverse interpolation in the
            ! h_ref array, and then adding that zeta to the grid, but it's
            ! much easier just to reject them.

            scat_tan_ht = scat_ht * abs(cos(dPhi - xi)) ! -pi <= xi <= 0 here
            if ( scat_tan_ht > r_eq ) cycle
            theta = 2.0 * acos(scat_tan_ht/r_eq)

            scat_tan_ht = scat_tan_ht - r_eq

            xi_sub = dPhi - pid2
            forward = xi >= xi_sub
            scat_tan_phi = phi_ref + xi
            if ( xi < xi_sub ) scat_tan_phi = scat_tan_phi - pi
            scat_tan_phi = mod(scat_tan_phi,pix2) ! pix2 = 2.0*pi
            if ( scat_tan_phi < -pi ) then
              scat_tan_phi = scat_tan_phi + pix2
            else if ( scat_tan_phi > pi ) then
              scat_tan_phi = scat_tan_phi - pix2
            end if

            if ( print_TScat_detail > 0 ) then
              ! "sig" is a handy otherwise-unused character variable.
              write ( sig, "('scat_tan_ht = ', f10.4,', scat_tan_phi = ', f7.2, &
              & ', xi_sub =', f7.2, ', theta = ', f7.2)" ) &
              & scat_tan_ht, rad2deg*scat_tan_phi, rad2deg*xi_sub, rad2deg*theta
              call output ( trim(sig), advance='yes' )
            end if

            ! Do the ray tracing and radiative transfer, once for the ray
            ! at angle xi, and once for xi + 180 degrees.
            call one_tscat_ray ( 1, -1, vel_rel, scat_tan_phi,       &
              &                  scat_zeta, scat_phi, scat_ht,       &
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, scat_tan_ht, forward )

            xi = xi + pi
            call one_tscat_ray ( 1, -2, vel_rel, scat_tan_phi,       &
              &                  scat_zeta, scat_phi, scat_ht,       &
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, scat_tan_ht, forward )

          end do ! ptg_j

          if ( print_TScat ) then
            call output ("Phi_Ref  Scat_Phi   Scat_Ht  Scat_Zeta     Xi    Radiances", advance="yes" )
            ! ptg_i and sig are just conveniently otherwise unused variables here
            do ptg_i = 1, i_r
              write ( sig, "(f7.2,f9.2,f12.4,f8.3,f11.2)" ) rad2deg*phi_ref, &
                & rad2deg*scat_phi, scat_ht, scat_zeta, rad2deg*xis(ptg_i)
              call output ( trim(sig) )
              do f_i = 1, noUsedChannels
                call output ( rads(f_i,ptg_i), format="(f9.3)" )
              end do ! f_i
              call newLine
            end do ! ptg_i
          end if
          if ( switch42 ) then ! Output to unit 42
            do ptg_i = 1, i_r
              do f_i = 1, noUsedChannels
                call GetNameOfSignal ( fwdModelConf%signals(channels(f_i)%signal), &
                  & sig, channel=channels(f_i)%used, sideband=thisSideband )
                write ( 42, "(f7.2,f9.2,f12.4,f8.3,f11.2,f9.3,2x,a)" ) &
                  & rad2deg*phi_ref, rad2deg*scat_phi, scat_ht, scat_zeta, &
                  & rad2deg*xis(ptg_i), rads(f_i,ptg_i), trim(sig)
              end do
            end do
          end if

          ! Sort the xis in preparation for interpolating.
          call sortp ( xis(:i_r), 1, i_r, sort_xi(:i_r) )

          !{ Interpolate the phase function and its IWC and temperature
          !  derivatives to IWC and Temperature at the scattering point,
          !  and the $\xi$'s, and convolve the interpolated phase function
          !  with the interpolated radiances.  The interpolated values are
          !  in order according to the sorted $\xi$'s.
          !
          !  Let $x$ be temperature, $y$
          !  be IWC, and $z$ be the phase function.
          !
          ! Let $\xi_1 = \frac{x-x_0}{x_1-x_0}$, $\xi_0 = \frac{x_1-x}{x_1-x_0} =
          ! 1-\xi_1$,
          ! $\eta_1 = \frac{y-y_0}{y_1-y_0}$, $\eta_0 = \frac{y_1-y}{y_1-y_0} =
          ! 1-\eta_1$,
          ! $\xi = [\xi_0,\xi_1]^T$, $\eta = [\eta_0,\eta_1]^T$, and
          ! $Z = \left| \begin{array}{cc} z_{00} & z_{01} \\ z_{10} & z_{11}\\
          !             \end{array} \right|$.
          !
          ! The interpolation can be done either by interpolating in $x$ to
          ! $z_c = \xi_0 z_{00} + \xi_1 z_{10}$ and $z_d = \xi_0 z_{01} +
          ! \xi_1 z_{11}$ and then in $y$ to $z = \eta_0 z_c + \eta_1 z_d$,
          ! or interpolating in $y$ to $z_a = \eta_0 z_{00} + \eta_1 z_{01}$
          ! and $z_b = \eta_0 z_{10} + \eta_1 z_{11}$ and then in $x$ to $z =
          ! \xi_0 z_a + \xi_1 z_b$.  The two orders of interpolation are
          ! equivalent, and when expanded give
          !%
          ! $
          ! z(x,y) = \xi_0 \eta_0 z_{00} + \xi_1 \eta_0 z_{10} +
          ! \xi_0 \eta_1 z_{10} + \xi_1 \eta_1 z_{11},
          ! $
          !%
          ! which can be expressed in matrix-vector form as $\xi^T Z \eta$.

          ! Get bilinear interpolation coefficients from T_s X IWC_s to LogIWC
          ! and temp%values(zeta_i,phi_i)
          call eta_iwc%eta ( IWC_s, logIWC )
          call eta_t%eta ( T_s, temp%values(zeta_i,phi_i) )
          call eta_t_iwc%eta ( eta_t, eta_iwc )

          ! Get spline interpolation coefficients from Theta_e to Xis
          call interpolateArraySetup ( theta_e(:n_theta_e), xis(sort_xi(:i_r)), &
            & method='S', coeffs=coeffs_Theta_e_Xi, extrapolate='P' )
          do f_i = 1, noUsedChannels
            TScat => TScats(f_i)%qty
            surf_i = channels(f_i)%used - channels(f_i)%origin + 1 + &
                   & TScat%template%noChans * (zeta_i-1)
            ! Interpolate P to scattering point IWC and temperature, and
            ! angles Xi at which radiative transfer was done.  The normalizing
            ! factor of abs(sin(theta)) is applied in interpolate_P_to_theta_e.
            call interpolate_P_to_theta_e ( p(:,:,:,freq_ix(f_i)), Eta_t_iwc, &
              & Theta_e(:n_theta_e), Beg_Pos_Theta, Xis(sort_xi(:i_r)), &
              & coeffs_Theta_e_Xi, P_on_Xi(:i_r) )
            ! Interpolate P's derivatives
            if ( atmos_der ) &
              & call interpolate_P_to_theta_e ( dP_dIWC(:,:,:,freq_ix(f_i)), &
                & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
                & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
                & dP_dIWC_on_Xi(:i_r) )
            if ( temp_der ) &
              & call interpolate_P_to_theta_e ( dP_dT(:,:,:,freq_ix(f_i)), &
                & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
                & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
                & dP_dT_on_Xi(:i_r) )

            !{ Compute $\int_{-\pi}^\pi \, f(\xi) P(\xi)\, \text{d}\xi$ using
            ! trapezoidal quadrature, without assuming equal abscissa spacing,
            ! and including the factor of 0.5 in Equation 4.50 in the 4 June
            ! 2004 cloud forward model ATBD.  Start with the wrap-around panel.
            ! We use acos(cos(x-y)) so as not to worry about negative angles,
            ! angles near 360 degrees that ought to be near zero degrees, etc.
            dXi = acos(cos(xis(sort_xi(1)) - xis(sort_xi(i_r))) )
            TScat%values(surf_i,phi_i) = &
              & 0.25 * ( p_on_xi(i_r)*rads(f_i,sort_xi(i_r)) + &
              &          p_on_xi(  1)*rads(f_i,sort_xi(  1)) ) * dXi
            if ( atmos_der ) then
              k_atmos_p =  &
                & 0.25 * ( p_on_xi(i_r)*k_atmos_TScat(f_i,sort_xi(i_r),:) + &
                &          p_on_xi(  1)*k_atmos_TScat(f_i,sort_xi(  1),:) ) * dXi
              if ( grid_IWC /= 0 ) &
                k_atmos_p(grid_IWC) = k_atmos_p(grid_IWC) + &
                  & 0.25 * ( dP_dIWC_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                  &          dP_dIWC_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * dXi
            end if
            if ( temp_der ) then
              k_temp_p =  &
                & 0.25 * ( p_on_xi(i_r)*k_temp_TScat(f_i,sort_xi(i_r),:) + &
                &          p_on_xi(  1)*k_temp_TScat(f_i,sort_xi(  1),:) ) * dXi
              if ( grid_t /= 0 ) then
                k_temp_p(grid_t) = k_temp_p(grid_t) + &
                  & 0.25 * ( dP_dT_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                  &          dP_dT_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * dXi
              end if
            end if
            do ptg_i = 2, i_r ! Now do the rest.
              dXi = xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1))
              TScat%values(surf_i,phi_i) = TScat%values(surf_i,phi_i) + &
                & 0.25 * ( p_on_xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                &          p_on_xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * dXi
              if ( atmos_der ) then
                k_atmos_p = k_atmos_p + &
                  & 0.25 * ( p_on_xi(ptg_i-1)*k_atmos_TScat(f_i,sort_xi(ptg_i-1),:) + &
                  &          p_on_xi(ptg_i  )*k_atmos_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                  &        dXi
                if ( grid_IWC /= 0 ) &
                  k_atmos_p(grid_IWC) = k_atmos_p(grid_IWC) + &
                    & 0.25 * ( dP_dIWC_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                    &          dP_dIWC_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                    &        dXi
              end if
              if ( temp_der ) then
                k_temp_p = k_temp_p + &
                  & 0.25 * ( p_on_xi(ptg_i-1)*k_temp_TScat(f_i,sort_xi(ptg_i-1),:) + &
                  &          p_on_xi(ptg_i  )*k_temp_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                  &        dXi
                if ( grid_t /= 0 ) then
                  k_temp_p(grid_t) = k_temp_p(grid_t) + &
                    & 0.25 * ( dP_dT_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                    &          dP_dT_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                    &        dXi
                end if
              end if
            end do ! ptg_i = 2, i_r

            !{ It isn't necessary to divide by
            ! $\int \, P(\xi) \sin\xi \, \text{d}\xi$
            ! because that normalization was done when the $P$ tables were
            ! constructed.
            if ( atmos_der ) &
              & call store_other_deriv ( phi_i, surf_i, TScat, &
                                       & beta_group%qty, Grids_f, k_atmos_p, &
                                       & F_and_V, jacobian )
            if ( temp_der ) then
              call store_temperature_deriv ( phi_i, surf_i, TScat, &
                                       & temp, grids_tmp, k_temp_p, &
                                       & F_and_V, jacobian )
              if ( print_TScat_deriv > 1 ) then
                call output ( f_i, before='K_temp_TScat(' )
                call output ( i_r, before=',sort_xi(:' )
                call dump ( k_temp_TScat(f_i,sort_xi(:i_r),:), name='),:)' )
                call dump ( rad2deg*Xis(sort_xi(:i_r)), name='Xis' )
                call dump ( P_on_Xi(:i_r), name='P_on_Xi' )
                call dump ( dP_dT_on_Xi(:i_r), name='dP_dT_on_Xi' )
                call dump ( k_temp_p, name='k_temp_p' )
                call output ( surf_i, before='TScat%values(' )
                call output ( phi_i, before=',' )
                call output ( TScat%values(surf_i,phi_i), before=') = ', advance='yes' )
                if ( print_TScat_deriv > 2 ) stop
              end if
            end if
          end do ! f_i = 1, noUsedChannels
          call interpolateArrayTeardown ( coeffs_Theta_e_Xi )

        end do ! phi_i
      end do ! zeta_i

      if ( dump_TScat ) then
        do f_i = 1, noUsedChannels
          call dump ( TScats(f_i)%qty%values, name = 'TScat' )
        end do
      end if

      call Trace_End ( 'Generate_TScat', cond=toggle(emit) )

    end subroutine Generate_TScat
d2517 1
a2517 1
      real(rp), intent(out) :: TT_Path_c(:) ! tscat on coarse path
d2696 1
a2696 40
          ! Determine the frequency subscript for the Mie tables.
          Mie_frq_index = Mie_freq_index ( frq, fwdModelConf%frqTol )
          ! Each Mie table applies to many frequencies, so don't interpolate
          ! again if not needed.
          if ( Mie_frq_index /= prev_Mie_frq_ind ) then
            call interpolate_Mie ( Mie_frq_index, eta_T_IWC_path_c,       &
              & atmos_der, temp_der, beta_c_e_path_c(:npc),               &
              & beta_c_s_path_c(:npc), dBeta_c_a_dIWC_path_c(:npc),       &
              & dBeta_c_s_dIWC_path_c(:npc), dBeta_c_a_dT_path_c(:npc),   &
              & dBeta_c_s_dT_path_c(:npc) )
            prev_Mie_frq_ind = Mie_frq_index
          end if
          ! Ignore contribution of PFA Alpha to w0.
          w0_path_c = beta_c_s_path_c(:npc) / ( alpha_path_c + beta_c_e_path_c(:npc) )

          call Get_TScat_Setup ( fwdModelConf, FwdModelIn, FwdModelExtra, &
           &                     FwdModelOut, Sideband, Frq, MAF, phiTan, &
           &                     L2PC, RadInL2PC, dX, TScat, Grids_TScat )

          ! Get TScat and derivatives on the path from the L2PC model
          phiWindowRadians = deg2rad * &
            & ( maxval(phiTan%values(:,windowFinish)) - &
            &   minval(phiTan%values(:,windowStart)) )
          call Get_TScat ( fwdModelIn, fwdModelExtra,                          &
            &              phiWindowRadians, MAF, phiTan,                      &
            &              frq, z_coarse, phi_path_c, tan_pt_c, grids_f,       &
            &              L2PC, dX, TScat, radInL2PC, grids_TScat, tt_path_c, &
            &              atmos_der, temp_der, dTScat_df, dTScat_dT )

          call Get_TScat_Teardown ( dX, TScat, Grids_TScat )

          ! Get combined clear-sky and TScat Delta B (t_script)
          ! Don't restrict this to (i_start:i_end) because the end points
          ! at 1 and npc are special.
          call two_d_t_script_cloud ( t_path_c(i_start:i_end),    &
            & tt_path_c(i_start:i_end), w0_path_c(i_start:i_end), &
            & spaceRadiance%values(1,1), frq, &
            & t_script(i_start:i_end), &
            & B(i_start:i_end) )

d3261 1
a3307 1
      real(rp) :: R_EQ          ! Equivalent Earth Radius at true surface
d3355 1
a3355 1
      if ( .not. present(QTM) ) then
d3461 1
a3461 1
      if ( present(scat_zeta) .and. .not. present(QTM) ) then
d3956 1
a3956 55
    subroutine One_TScat_Ray ( Ptg_i, Which, Vel_Rel, Scat_Tan_Phi,        &
      &                        Scat_Zeta, Scat_Phi, Scat_Ht, Use_R_Eq,     &
      &                        Xi, Xis, Rads, K_Atmos_TScat, K_Temp_TScat, &
      &                        I_R, Scat_Tan_Ht, Forward, Rev)

      ! Do one of the four TScat rays for the current pointing.

      integer, intent(in) :: Ptg_i          ! Pointing index for One_Pointing
      integer, intent(in) :: Which          ! Which call got us here
      real(rp), intent(in) :: Vel_Rel       ! LOS Vel / speed of light
      real(rp), intent(in) :: Scat_Tan_Phi  ! of scattering point
      real(rp), intent(in) :: Scat_Zeta     ! of scattering point
      real(rp), intent(in) :: Scat_Phi      ! of scattering point
      real(rp), intent(in) :: Scat_Ht       ! of scattering point
      real(rp), intent(in) :: Use_R_Eq      ! R_Eq to use instead of at tangent
      real(rp), intent(in) :: Xi            ! Scattering angle, radians
      real(rp), intent(inout) :: Xis(:)     ! Store Xi in Xis(I_R) if OK
      real(rp), intent(inout) :: Rads(:,:)  ! Store radiance in Rads(:,I_R)
      real(r4), intent(inout) :: K_Atmos_TScat(:,:,:) ! Store partials in K_Atmos_TScat(:,I_R,:)
      real(r4), intent(inout) :: K_Temp_TScat(:,:,:) ! Store partials in K_Temp_TScat(:,I_R,:)
      integer, intent(inout) :: I_R         ! Index in Xis, Update if OK
      real(rp), intent(in), optional :: Scat_Tan_Ht ! Tangent height above
                                            ! earth geometric surface, km, for
                                            ! subsurface rays
      logical, intent(in), optional :: Forward      ! For subsurface rays
                                            ! "xi >= xi_sub" in Generate_TScat
      logical, intent(in), optional :: Rev  ! Reverse the integration order

      integer :: My_Scat_Index

      ! Do the ray tracing for all the signals
      call one_pointing ( ptg_i, vel_rel, use_r_eq, scat_tan_phi,            &
        &                 scat_zeta=scat_zeta, scat_phi=scat_phi,            &
        &                 scat_ht=scat_ht, xi=xi, scat_index=my_scat_index,  &
        &                 scat_tan_ht=scat_tan_ht, forward=forward, rev=rev, &
        &                 which=which )

      if ( my_scat_index <= 0 ) return ! No ray to trace

      i_r = i_r + 1
      xis(i_r) = xi
      rads(:,i_r) = radiances(:,ptg_i)
      if ( atmos_der ) k_atmos_TScat(:,i_r,:) = k_atmos(:,ptg_i,:)
      if ( temp_der ) then
        k_temp_TScat(:,i_r,:) = k_temp(:,ptg_i,:)
        if ( print_TScat_deriv > -1 ) then
          call output ( i_r, before='For TScat ray ' )
          call output ( rad2deg*xi, before=' at angle ', format='(f7.2)' )
          call output ( i_r, before=' k_temp_TScat(:,', after=',:) ', advance='yes' )
          call dump ( k_temp_TScat(:,i_r,:) )
          call dump ( rads(:,i_r), name='Rads' )
        end if
      end if

    end subroutine One_TScat_Ray
d3964 1
a3964 1
       "$Id: FullForwardModel_m.f90,v 2.405 2019/10/07 20:05:53 vsnyder Exp $"
d3974 3
@


2.405
log
@Get WrongTrapezoidal from the config
@
text
@d614 1
d622 2
a623 1
    use MLSSignals_M, only: AreSignalsSuperset, GetNameOfSignal, MatchSignal, &
d632 2
a633 1
    use PointingGrid_M, only: PointingGrids, PointingGrid_T
d2273 1
d2288 12
a2299 1
        if ( .not. associated(whichPointingGrid) ) call Announce_Error ( &
d2301 1
d4668 1
a4668 1
       "$Id: FullForwardModel_m.f90,v 2.404 2019/09/05 17:10:33 pwagner Exp $"
d4678 3
@


2.404
log
@Dont try to deallocate F_and_V_MIF unless allocated already
@
text
@d50 1
a50 5
  logical, parameter, private :: UseTrapezoidal = .true.   ! Use trapezoidal
    ! quadrature for radiance instead of rectangular quadrature on panels for
    ! which GL is not used.  In any case, on panels where GL is used, keep
    ! the result of rectangular quadrature to cancel the singularity at the
    ! tangent point.  See Equation (10.13) in the 19 August 2004 ATBD.
d52 1
a52 1
  logical, parameter, private :: WrongTrapezoidal = useTrapezoidal .and. .true.
d83 1
a83 1
      & L_TScat, L_VMR
d252 2
d3957 2
a3958 2
        call load_one_item_grid ( grids_tmp, temp, fmStat%maf, phitan, fwdModelConf, &
          & setDerivFlags=.true., subset=F_and_V%vertices )
d4652 1
a4652 1
       "$Id: FullForwardModel_m.f90,v 2.403 2019/06/24 23:28:16 pwagner Exp $"
d4662 3
@


2.403
log
@Updated to reflect TA-01-143
@
text
@d553 4
a556 2
    deallocate ( F_and_V_MIF, stat=stat, errmsg=ermsg )
    call test_deallocate ( stat, moduleName, "F_and_V_MIF", ermsg=ermsg )
d4654 1
a4654 1
       "$Id: FullForwardModel_m.f90,v 2.402 2018/10/30 23:14:36 vsnyder Exp $"
d4664 3
@


2.402
log
@Make sure RadV always has a value in One_Frequency
@
text
@d48 1
a48 1
    ! FullForwardModelAuto demend upon them
d50 13
a62 7
  logical, parameter, private :: WrongTrapezoidal = .true. ! If GL is not used
    ! on a panel, the rectangular estimate used to cancel the singularity at
    ! the tangent point is replaced by a trapezoidal estimate.  Originally,
    ! this was done incorrectly, using delta s ~ ds/dh dh/dz delta z, which is
    ! a rectangular quadrature approximation of delta s.  We have delta s, so
    ! we ought to use it.  This flag indicates whether the incorrect computation
    ! ought to be preserved.
d117 5
a121 1
                                ! the QTM.
d134 1
a134 2
                                ! vertices under all paths through
                                ! the QTM.
d260 5
d275 6
d330 1
a330 1
        no_sv_p_T = size(f_and_v(1)%vertices)
d350 12
d384 1
a384 1
      ! test whether its Vertices component is allocated.
d525 1
a525 1
                              & ptan, phitan, temp, &
d527 4
a530 4
                              & Q_LOS,          &
                              & QTM_Paths, f_and_v, no_mol, noUsedChannels,    &
                              & no_sv_p_T, &
                              & n_t_zeta, sv_t_len, nlvl,&
d553 2
d579 3
a581 3
                             & Q_LOS, QTM_Paths,      &
                             & f_and_v, no_mol, noUsedChannels, No_sv_p_T,     &
                             & n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
d609 1
d635 1
a635 1
    use TAU_M, only: Destroy_TAU, Dump, TAU_T
d651 1
a651 1
    real(rp), intent(in) :: TAN_Press(:)    ! Pressures corresponding to Z_PSIG
d670 8
a677 1
    type (Facets_and_Vertices_t), intent(in) :: F_and_V(:) ! of QTM under path
d727 1
a727 1
    integer :: INST               ! Instance of temperature nearest to MAF
d817 1
a817 1
    real(rp) :: Beta_Path_cloud_C(s_i*max_c) ! Beta on path coarse
d823 12
a834 4
    real(rp) :: DEL_S(max_c)          ! Integration lengths along coarse path,
                                      !  (2:npc-1)
    real(rp) :: DEL_Zeta(max_c)       ! Integration lengths in Zeta coords
                                      !  along coarse path, (2:npc-1)
d854 2
d864 5
a868 5
    real(rp) :: T_Path(max_f)         ! Temperatures on path
    real(rp) :: T_Path_C(max_c)       ! T_Path on coarse grid
    real(rp) :: T_Path_F(max_f)       ! T_Path on fine grid
    real(rp) :: TT_Path_C(max(s_i,s_ts)*max_c)  ! TScat on path coarse
    real(rp) :: W0_Path_C(max(s_i,s_ts)*max_c)  ! w0 on path coarse
d875 1
a875 1
    real(rp) :: D2_Delta_dF2(max_c,size(grids_f%values),s_h*size(grids_f%values))
d878 1
a878 1
    real(rp) :: D_T_SCR_dT(max_c,s_t*sv_t_len)     ! D Delta_B in some notes
d880 2
a881 2
    real(rp) :: D2X_DXDT(no_tan_hts,s_t*sv_t_len)    ! (No_tan_hts, nz*np)
    real(rp), target :: DAlpha_DF_Path(max_f,s_a*no_mol) ! on composite coarse &
d883 20
a902 20
    real(rp), pointer :: DAlpha_DF_Path_C(:,:)       ! on coarse path
    real(rp) :: DAlpha_DF_Path_F(max_f,s_a*no_mol)   ! GL points only
    real(rp) :: D2Alpha_DF2_Path_C(max_c,s_h*no_mol) ! on coarse path
    real(rp) :: D2Alpha_DF2_Path_F(max_f,s_h*no_mol) ! on GL path
    real(rp) :: DB_DF(s_ts*max(s_a,s_t)*max_c)       ! dB / d one f on the path, for TScat
    real(rp) :: DBeta_DF_Path_C(max_c,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: DBeta_DF_Path_F(max_f,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: DBeta_DIWC_Path_C(max_c,s_tg*no_mol) ! dBeta_dIWC on coarse grid
    real(rp) :: DBeta_DIWC_Path_F(max_f,s_tg*no_mol) ! dBeta_dIWC on fine grid
    real(rp) :: DBeta_DN_Path_C(max_c,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on coarse grid
    real(rp) :: DBeta_DN_Path_F(max_f,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on fine grid
    real(rp) :: DBeta_DT_Path_C(max_c,s_t*no_mol)  ! dBeta_dT on coarse grid
    real(rp) :: DBeta_DT_Path_F(max_f,s_t*no_mol)  ! dBeta_dT on fine grid
    real(rp) :: DBeta_DV_Path_C(max_c,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on coarse grid
    real(rp) :: DBeta_DV_Path_F(max_f,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on fine grid
    real(rp) :: DBeta_DW_Path_C(max_c,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on coarse grid
    real(rp) :: DBeta_DW_Path_F(max_f,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on fine grid
    type(sparse_t) :: DH_dT_Path               ! dH/dT on path X (Zeta * Phi)
    real(rp) :: DHDZ_GLGrid(maxVert,no_sv_p_T) ! dH/dZ on glGrid surfs
    real(rp) :: DX_DT(no_tan_hts,s_t*sv_t_len) ! (No_tan_hts, nz*np)
d923 1
a923 1
    real(rp) :: TT_Path(max_f,max(s_i,s_ts))   ! TScat on path along the LOS
d962 2
a963 2
!   complex(rp) :: DINCOPTDEPTH_POL_DT(2,2,s_p*s_t*max_c) ! D Incoptdepth_Pol / DT
!   complex(rp) :: GL_DELTA_Polarized(-1:1,s_p*max_f)
d1038 1
a1045 1
    real(rp) :: TAN_CHI_OUT(ptan%template%nosurfs)
d1177 1
a1177 1
      call fill_IEEE_NaN ( dB_df, surf_angle, tan_chi_out )
d1192 1
a1192 1
      call fill_IEEE_NaN ( tt_path, t_glgrid, t_script_PFA, rot )
d1266 2
a1267 12
    else
      if ( FwdModelConf%incl_cld ) call cloud_setup
!????? Need work here for QTM, especially Grids_Tmp, which is used
!????? for calculating Chi angles.
      call convolution_setup ( dh_dz_out, dx_dh_out, dxdT_surface, &
                             & dxdT_tan, Q_EarthRadC_sq, Est_ScGeocAlt, &
                             & FwdModelConf, &
                             & FwdModelExtra, FwdModelIn, Grids_f, Grids_tmp, &
                             & L1BMIF_TAI, MAF, MIFDeadTime, &
                             & PhiTan, PTan, RefGPH, SCGeocAlt, &
                             & Surf_Angle, Tan_Chi_Out, Tan_Phi, TAN_Press, &
                             & WindowFinish, WindowStart )
d1427 1
a1427 1
          Vel_Rel = est_los_vel(ptg_i) / speedOfLight
d1433 1
a1433 1
            & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
a1448 1
            call QTM_paths(ptg_i)%new_path ! Initialize to empty
d1451 1
d1455 1
a1455 1
              &                 f_and_v=f_and_v(ptg_i) )
d1467 25
a1491 11
      if ( .not. fwdModelConf%generateTScat ) call convolution & ! or interpolate to ptan
        ( dh_dz_out, dx_dh_out, dx_dT, dxdT_surface, &
        & dxdT_tan, d2x_dxdT, f_and_v, &
        & Q_EarthRadC_sq, Est_ScGeocAlt, FirstSignal, FmStat, &
        & FwdModelConf, FwdModelExtra, FwdModelIn, FwdModelOut, &
        & Grids_f, Grids_n, Grids_tmp, Grids_v, Grids_w, &
        & H_Atmos, K_Atmos, K_Spect_DN, K_Spect_DV, K_Spect_DW, &
        & K_Temp, L1BMIF_TAI, MIFDeadTime, PTan, PTan_Der, &
        & Ptg_Angles, Radiances, Sideband, S_T, Surf_Angle, &
        & Tan_Chi_Out, Tan_Phi, Temp, ThisSideband, &
        & Jacobian, ExtraJacobian, Hessian )
d1670 1
d2672 1
a2672 1
                                       & f_and_v, jacobian )
d2678 1
a2678 1
                                       & f_and_v, jacobian )
d2727 1
a2727 1
              & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
d2773 1
a2773 1
            & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
d2990 1
a2990 1
                                       & f_and_v, jacobian )
d2994 1
a2994 1
                                       & f_and_v, jacobian )
d3228 1
a3228 1
          & phi_path(1:npf), tt_path(1:npf,:) )
d3249 1
a3249 1
          tt_path_c(1:npc) = tt_path(1:npf:ngp1,1)
d3254 1
a3254 1
          call get_beta_path_cloud ( Frq, t_path(1:npf), tt_path(1:npf,:), &
d3958 1
a3958 1
          & setDerivFlags=.true., subset=f_and_v%vertices )
d3961 1
a3961 1
          & subset=f_and_v%vertices )
d4025 2
a4026 2
        do i_start = 1, size(f_and_v%vertices) ! I_Start is a temp here
          QTM%path_vertices(f_and_v%vertices(i_start)) = i_start
d4041 1
a4041 1
            &  vertices=f_and_v%vertices )
d4046 1
a4046 1
            &  vertices=f_and_v%vertices )
d4074 1
a4074 1
          & tangent_index=tan_ind_f, pad=NG, f_and_v=f_and_v, &
d4081 4
a4084 4
        ! S%Face < 0 if the intersection is outside the QTM.  S(.)%H_ind is the
        ! subscript of z_psig, and the first subscript of H_GLGrid, i.e., the
        ! index of the zeta surface in the fine zeta grid.  If it's zero, S(.)
        ! is an Earth-reflecting point below H_GLGrid.
d4304 2
a4305 1
      if ( present(est_scGeocAlt) .and. .not. fwdModelConf%generateTScat ) then
d4307 6
a4312 3
        ! convolution, not for ray tracing.  We can't easily move these
        ! computations into the convolution code because they need Tan_Ht_s
        ! and Req_s, which are gotten from Tangent_Metrics and Height_Metrics.
d4316 3
a4318 2
             & tan_ht_s, tan_phi, req_s, 0.0_rp, ptg_angles(ptg_i),      &
             & tan_dh_dt, tan_d2h_dhdt, dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
d4320 1
d4322 2
a4323 1
             & tan_ht_s, tan_phi, req_s, 0.0_rp, ptg_angles(ptg_i) )
a4325 1

d4652 1
a4652 1
       "$Id: FullForwardModel_m.f90,v 2.401 2018/10/26 22:05:47 vsnyder Exp $"
d4662 3
@


2.401
log
@Don't do the trapezoidal update beyond I_End if it's before the tangent.
@
text
@d3471 1
a3477 1
          radV = 0.0
a3489 1
          radV = 0.0
d4589 1
a4589 1
       "$Id: FullForwardModel_m.f90,v 2.400 2018/09/12 22:51:16 vsnyder Exp $"
d4599 3
@


2.400
log
@Changed name of dRad_Tran_dX_Sparse to dRad_Tran_dX
@
text
@d3059 2
a3060 1
      integer, intent(in) :: I_Start, I_End ! Bounds for coarse path integration
d3306 1
a3306 1
        ! to Alpha here
d3373 1
a3373 1
        do j = i_start+1, tan_pt_c
d3385 1
a3385 1
        do j = i_start+1, tan_pt_c
d4590 1
a4590 1
       "$Id: FullForwardModel_m.f90,v 2.399 2018/09/12 22:07:42 vsnyder Exp $"
d4600 3
@


2.399
log
@Convert interpolators for full cloud forward model from dense to sparse.
Convert interpolators for spectroscopy derivatives from dense to sparse.
Use Comp_Sps.  use dRad_Tran_dX_Sparse instead of dRad_Tran_dX.  Use
Comp_Eta instead of Comp_Eta_DoCalc_Sparse (because we no longer calculate
Do_Calc -- which Comp_Eta_DoCalc_Sparse didn't calculate anyway).
@
text
@d3028 1
a3028 1
        & dRad_Tran_dX_Sparse
d3785 2
a3786 2
            & call drad_tran_dx_sparse ( gl_inds, del_zeta, grids_w,       &
              &  eta_zp_w, sps_path, fwdModelConf%lineWidth%beta(sx),      &
d3792 2
a3793 2
            & call drad_tran_dx_sparse ( gl_inds, del_zeta, grids_n,       &
              &  eta_zp_n, sps_path, fwdModelConf%lineWidth_tDep%beta(sx), &
d3799 2
a3800 2
            & call drad_tran_dx_sparse ( gl_inds, del_zeta, grids_v,       &
              &  eta_zp_v, sps_path, fwdModelConf%lineCenter%beta(sx),     &
d4589 1
a4589 1
       "$Id: FullForwardModel_m.f90,v 2.397 2018/08/28 22:17:53 vsnyder Exp $"
d4599 7
@


2.398
log
@Use sparse interpolation for magnetic field on path
@
text
@a564 2
    use Comp_Eta_DoCalc_No_Frq_M, only: Comp_Eta_DoCalc_No_Frq
use Comp_SPS_Path_Frq_M, only: Comp_SPS_Path_No_Frq
a578 1
!Q    use HGridsDatabase, only: HGrid_T
a632 1
!Q    type (HGrid_T), pointer, intent(in) :: QTM_HGrid ! HGrid that has finest QTM resolution.
a766 4
    ! Cloud arrays are on the same grids as temperature
    logical :: Do_Calc_Salb_ZP(max_f,s_i*sv_t_len)  ! 'Avoid zeros' indicator
    logical :: Do_Calc_Cext_ZP(max_f,s_i*sv_t_len)  ! 'Avoid zeros' indicator

d851 3
a853 4
    real(rp) :: Eta_IWC_ZP(max_f,max(s_i,s_ts)*grids_iwc%p_len)
    real(rp) :: Eta_ZXP_N(max_f,size(grids_n%values)) ! Eta_z x Eta_p for N
    real(rp) :: Eta_ZXP_V(max_f,size(grids_v%values)) ! Eta_z x Eta_p for V
    real(rp) :: Eta_ZXP_W(max_f,size(grids_w%values)) ! Eta_z x Eta_p for W
a938 5
    ! 'Avoid zeros' indicators
    logical :: Do_Calc_N(max_f, size(grids_n%values) ) ! on entire grid
    logical :: Do_Calc_V(max_f, size(grids_v%values) ) ! on entire grid
    logical :: Do_Calc_W(max_f, size(grids_w%values) ) ! on entire grid

a970 6
    real(rp) :: Eta_Tscat(max_f,s_i*sv_t_len)
    real(rp) :: Eta_Tscat_ZP(max_f,s_i*sv_t_len)
    real(rp) :: Eta_Salb(max_f,s_i*sv_t_len)
    real(rp) :: Eta_Salb_ZP(max_f,s_i*sv_t_len)
    real(rp) :: Eta_Cext(max_f,s_i*sv_t_len)
    real(rp) :: Eta_Cext_ZP(max_f,s_i*sv_t_len)
d1136 2
a1137 3
      call fill_IEEE_NaN ( dhdz_glgrid, dx_dT, eta_IWC_zp, &
        & eta_zxp_n, eta_zxp_v, &
        & eta_zxp_w, h_glgrid, IWC_path, mag_path, rad_avg_path, radiances, &
d1141 1
a1141 2
      call fill_IEEE_NaN ( eta_TScat, eta_TScat_zp, eta_salb, eta_salb_zp, &
        & eta_cext, cext_path, salb_path, TScat_path )
d1319 25
d2409 2
a2410 2
!       integer :: IWC_IX        ! Which IWC index to use for phase function
!       integer :: T_IX          ! Which Temperature index to use for phase functio
d3008 1
d3028 1
a3028 1
        & dRad_Tran_dX
d3165 2
a3166 9
        block
          use Comp_Eta_DoCalc_Sparse_m, only: Comp_Eta_Docalc_Sparse
          type (Sparse_Eta_t) :: Eta_TScat_ZP
          call comp_eta_docalc_sparse ( grids_tscat, tan_pt_f, z_path(1:npf), &
                                      & phi_path(1:npf), eta_tscat_zp )
          ! There's only one Zeta X Phi grid for all the scattering angles.
          call comp_sps_path_sparse ( grids_tscat, eta_tscat_zp, &
                                      & tscat_path(1:npf,:) )
        end block
d3183 2
a3184 10
          call comp_eta_docalc_no_frq ( Grids_salb, z_path, &
            &  phi_path(1:npf), eta_salb_zp(1:npf,:),       &
            &  do_calc_salb_zp(1:npf,:), tan_pt=tan_pt_f )

          call comp_sps_path_no_frq ( Grids_salb, eta_salb_zp(1:npf,:), &
            & salb_path(1:npf,:) )

          call comp_eta_docalc_no_frq ( Grids_cext, z_path, &
            &  phi_path(1:npf), eta_cext_zp(1:npf,:),       &
            &  do_calc_cext_zp(1:npf,:), tan_pt=tan_pt_f )
d3186 2
a3187 2
          call comp_sps_path_no_frq ( Grids_cext,  eta_cext_zp(1:npf,:), &
            & cext_path(1:npf,:) )
a3783 1

d3785 2
a3786 2
            & call drad_tran_dx ( gl_inds, del_zeta, grids_w, eta_zxp_w,   &
              &  sps_path, fwdModelConf%lineWidth%beta(sx), do_calc_w,     &
a3790 1

d3792 3
a3794 3
            & call drad_tran_dx ( gl_inds, del_zeta, grids_n, eta_zxp_n,    &
              &  sps_path, fwdModelConf%lineWidth_tDep%beta(sx), do_calc_n, &
              &  dBeta_dn_path_c, dBeta_dn_path_f, do_gl, del_s, ref_corr,  &
a3797 1

d3799 2
a3800 2
            & call drad_tran_dx ( gl_inds, del_zeta, grids_v, eta_zxp_v,   &
              &  sps_path, fwdModelConf%lineCenter%beta(sx), do_calc_v,    &
d3818 2
a3819 1
      use Comp_Eta_Docalc_Sparse_m, only: Comp_Eta_Docalc_Sparse
d4102 4
a4105 4
          call comp_eta_docalc_sparse ( grids_f, tan_pt_f, z_path(1:npf), &
                                      & eta_z(h2o_ind), phi_path(1:npf),  &
                                      & eta_p(h2o_ind), eta_fzp(h2o_ind), &
                                      & n=h2o_ind, skip=ngp1 )
d4148 4
a4151 3
      call comp_eta_docalc_sparse ( grids_f, tan_pt_f, z_path(1:npf), eta_z, &
                                  & phi_path(1:npf), eta_p, eta_zp, eta_fzp, &
                                  & skip=ngp1 )
d4177 2
a4178 4
        call comp_eta_docalc_no_frq ( grids_v, z_path(1:npf), &
          & phi_path(1:npf), eta_zxp_v(1:npf,:), do_calc_v(1:npf,:), tan_pt=tan_pt_f )
        call comp_sps_path_no_frq ( grids_v, eta_zxp_v(1:npf,:), &
          & spect_v_path(1:npf,:) )
d4182 2
a4183 4
        call comp_eta_docalc_no_frq ( grids_w, z_path(1:npf), &
          & phi_path(1:npf), eta_zxp_w(1:npf,:), do_calc_w(1:npf,:), tan_pt=tan_pt_f )
        call comp_sps_path_no_frq ( grids_w, eta_zxp_w(1:npf,:), &
          & spect_w_path(1:npf,:) )
d4187 2
a4188 4
        call comp_eta_docalc_no_frq ( grids_n, z_path(1:npf), &
          & phi_path(1:npf), eta_zxp_n(1:npf,:), do_calc_n(1:npf,:), tan_pt=tan_pt_f )
        call comp_sps_path_no_frq ( grids_n, eta_zxp_n(1:npf,:), &
          & spect_n_path(1:npf,:) )
d4195 2
a4196 2
        call comp_eta_docalc_no_frq ( grids_IWC, z_path(1:npf), &
          &  phi_path(1:npf), eta_IWC_zp(1:npf,:), tan_pt=tan_pt_f )
a4197 3
        ! Compute IWC_Path
        call comp_sps_path_no_frq ( Grids_IWC, eta_IWC_zp(1:npf,:), &
          & iwc_path(1:npf,:) )
a4206 1
      ! Magnetic field on the path, for Polarized (magnetic) model
d4599 3
@


2.397
log
@Add WrongTrapezoidal with the value .true. to indicate the incorrect
trapezoid rule is used to calculate incOptDepth.  Some changes because of
rearranged argument lists in Comp_Sps_Path_Sparse_m and
Comp_Eta_DoCalc_Sparse_m.
@
text
@d566 1
a566 1
use Comp_SPS_Path_Frq_M, only: Comp_SPS_Path, Comp_SPS_Path_No_Frq
d582 1
a582 2
    use Intrinsic, only: L_A, L_GeocAltitude, L_GeodAltitude, L_Radiance, &
      & L_TScat, L_VMR, L_Zeta
d698 3
a700 1
    integer :: MIF                ! MIF number for tan_press(ptg_i)
a771 1
    logical :: Do_Calc_Tscat_ZP(max_f,s_i*sv_t_len) ! 'Avoid zeros' indicator
a859 1
    real(rp) :: Eta_Mag_ZP(max_f,grids_mag%p_len)  ! Eta_z x Eta_p x Eta_x
d1156 1
a1156 1
      call fill_IEEE_NaN ( dhdz_glgrid, dx_dT, eta_IWC_zp, eta_mag_zp, &
a2379 2
      real(rp) :: P_On_T_IWC(size(p,3)) ! P interpolated to T and IWC for one
                               ! frequency and several Theta_e's.
a2381 2
      real(rp), pointer :: P_T_IWC(:) ! 1D pointer to P(:,:,theta_i,frq_i):
                               ! the T x IWC space for particular theta and frq
d2406 2
a2407 2
      integer :: IWC_IX        ! Which IWC index for phase function to use
      integer :: T_IX          ! Which Temperature index for phase functio to use
a2422 1
      integer :: Ptg_f         ! Ptg_i, Ptg_j on fine grid
a2633 2
            ptg_f = (ptg_i-1) * ngp1 + 1 ! On Z_GLgrid, for H_GLGrid

d3166 3
a3168 5
          do i = 1, size(tscat_path,2)
            ! There's only one Zeta X Phi grid for all the scattering angles.
            call comp_sps_path_sparse ( grids_tscat, eta_tscat_zp, &
                                      & tscat_path(1:npf,i) )
          end do
a4226 1
      ! Special path quantities for Polarized (magnetic) model
d4228 1
d4230 18
a4247 43
        select case ( grids_mag%z_coord(1) ) ! grids_mag is a one-quantity grid
        case ( l_geocAltitude, l_geodAltitude )
          ! load_sps_data_m%Fill_Grids_2 has converted geocentric height
          ! to geodetic altitude above the geoid, and converted to km.
          ! H_Path is km above the equivalent Earth center, so subtract R_Eq
          ! to get it on the same basis as Grids_Mag%zet_basis, which is
          ! altitude in km here, not zeta.
          call comp_eta_docalc_no_frq ( grids_mag, h_path(1:npf) - r_eq, &
            &  phi_path(1:npf), eta_mag_zp(1:npf,:), tan_pt=tan_pt_f )
        case ( l_zeta )
          call comp_eta_docalc_no_frq ( grids_mag, z_path(1:npf), &
            &  phi_path(1:npf), eta_mag_zp(1:npf,:), tan_pt=tan_pt_f )
        end select

        ! Compute the first three components of MAG_Path
        call comp_sps_path ( grids_mag, 1, eta_mag_zp(1:npf,:), &
          & mag_path(1:npf,1:3) )

        ! Get the rotation matrix for the magnetic field.  Use the
        ! matrix for the MIF having ptan nearest to tan_press.
        mif = minloc(abs(tan_press - &
            &            ptan%values(:ptan%template%nosurfs,maf)),1)

        ! Dimensions of ECRtoFOV%value3 are ( chans, surfs, instances*cross angles ).
        ! Chans is actually 3x3, so we need to reform it.
        rot = reshape ( ECRtoFOV%value3(1:9,mif,maf), [ 3, 3 ] )

        do j = 1, npf
          ! Rotate mag_path from ECR to IFOVPP (R1A) coordinates.  Use
          ! the rotation matrix for the MIF nearest to the current
          ! pointing angle instead of interpolating.  They are nearly
          ! identical anyway.
          mag_path(j,1:3) = matmul ( rot, mag_path(j,1:3) )
          ! Put the magnitude of mag_path(j,1:3) in mag_path(j,4)
          mag_path(j,4) = norm2(mag_path(j,1:3))
          ! Normalize mag_path(j,1:3).
          if ( mag_path(j,4) /= 0.0_rp ) then
            mag_path(j,1:3) = mag_path(j,1:3) / mag_path(j,4)
          else
            mag_path(j,1:3) = 0.0_rp
            mag_path(j,3) = 1.0_rp ! arbitrarily, theta=0 for zero field
          end if
        end do
a4264 2
          if ( iand(print_Mag,2) > 0 ) &
            & call dump ( eta_mag_zp(1:npf,:), 'Eta_Mag_zp', options=clean )
d4611 1
a4611 1
       "$Id: FullForwardModel_m.f90,v 2.396 2018/08/15 01:18:50 vsnyder Exp $"
d4621 6
@


2.396
log
@Get S_QTM_t from Metrics_2D_m instead of QTM_Interpolation_Weights_3D_m.
Eliminate dSdZ_C.  Eliminate Do_Clac_T and Do_Calc_T_1.  Get T_Der_Path_Flags
from More_Metrics.
@
text
@d50 8
d800 1
d1138 1
a1138 1
        & dhdz_path, dhdz_gw_path, dsdh_path, dsdz_gw_path, dTanh_dT_c, &
d3169 11
a3179 6
        call comp_eta_docalc_no_frq ( grids_tscat, z_path, &
          &  phi_path(1:npf), eta_tscat_zp(1:npf,:),       &
          &  do_calc_tscat_zp(1:npf,:), tan_pt=tan_pt_f )

        call comp_sps_path_no_frq ( Grids_tscat, eta_tscat_zp(1:npf,:), &
          & tscat_path(1:npf,:) )
d3392 25
a3416 12
      ! Before the tangent point, del_s(j) is the path length from J-1 to J
      do j = i_start+1, tan_pt_c
        if ( .not. do_gl(j) ) &
          & incoptdepth(j) = &
            & ( alpha_path_c(j-1) + alpha_path_c(j) ) * 0.5 * del_s(j)
      end do
      ! After the tangent point, del_s(j) is the path length from J to J+1
      do j = tan_pt_c+1, i_end-1
        if ( .not. do_gl(j) ) &
          & incoptdepth(j) = &
            & ( alpha_path_c(j+1) + alpha_path_c(j) ) * 0.5 * del_s(j)
      end do
d3698 8
a3723 8
        dAlpha_dT_path_c(:npc) = sum( sps_path_c(:npc,:) *  &
                                      dBeta_dT_path_c(1:npc,:),dim=2 )
        dAlpha_dT_path_f(:ngl) = sum( sps_path_f(:ngl,:) * &
                                      dBeta_dT_path_f(1:ngl,:),dim=2 )
        ! Put dAlpha_dT_path_f, values for GL points only, back into the
        ! composite path
        dAlpha_dT_path(gl_inds) = dAlpha_dT_path_f(:ngl)

d3729 1
a3729 1
            & t_path(:npf), dsdh_path, dhdz_gw_path,dsdz_gw_path,      &
d4125 7
a4131 7
          call comp_eta_docalc_sparse ( grids_f, h2o_ind, tan_pt_f,      &
                                      & z_path(1:npf), eta_z(h2o_ind),   &
                                      & phi_path(1:npf), eta_p(h2o_ind), &
                                      & eta_fzp(h2o_ind), skip=ngp1 )
          call comp_1_sps_path_sparse_no_frq ( grids_f, h2o_ind, &
                                             & eta_fzp(h2o_ind), &
                                             & sps_path(1:npf,h2o_ind) )
d4177 1
a4177 2
      call comp_sps_path_sparse ( Grids_f, eta_zp, eta_fzp, &
                                & sps_path(1:npf,:) )
d4353 5
d4648 1
a4648 1
       "$Id: FullForwardModel_m.f90,v 2.395 2018/05/24 03:24:36 vsnyder Exp $"
d4658 5
@


2.395
log
@Use sparse representation for dh_dt_path
@
text
@d578 1
a591 1
    use QTM_Interpolation_Weights_3D_m, only: S_QTM_t
a791 1
    real(rp) :: DSDZ_C(max_c)         ! ds/dH * dH/dZ on coarse path (1:tan_pt_c-1,tan_pt_c+2:npc)
a941 2
    logical, target :: Do_Calc_T_1(s_t* max_f * sv_t_len)
    logical, pointer :: Do_Calc_T(:,:)         ! path Z X temp (Z * phi )
d1060 1
a1060 1
                                  ! temperature Zeta to GL zeta.
a1111 1
    do_calc_t(1:max_f,1:s_t*sv_t_len) => do_calc_t_1
d1129 1
a1129 1
        & dhdz_path, dhdz_gw_path, dsdh_path, dsdz_c, dsdz_gw_path, dTanh_dT_c, &
d4133 2
a4134 2
          &  dHtdTl0 = tan_dh_dt, eta_zp = eta_zp_T )
        t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
a4147 1

d4278 1
a4278 1
      end if
a4326 4
        ! We need dsdz = ds/dh * dh/dz, not multiplied by GW, for
        ! trapezoidal quadrature on the coarse grid.
        dsdz_c(:npc) = dsdh_path(1:npf:ngp1) * dhdz_path(1:npf:ngp1)

d4617 1
a4617 1
       "$Id: FullForwardModel_m.f90,v 2.394 2018/05/17 02:15:45 vsnyder Exp $"
d4627 3
@


2.394
log
@Use sparse instead of dense interpolation
@
text
@a73 1
!Q    use Intrinsic, only: L_None
a150 1
!Q    integer :: N_Frq_Dep        ! Number of frequency-dependent VMRs
a446 8
!Q    n_frq_dep = 0
!Q    if ( usingQTM ) then
!Q      do k = 1, size(fwdModelConf%beta_group)
!Q        if ( fwdModelConf%beta_group(k)%qty%qty%template% &
!Q           & frequencyCoordinate /= l_none ) n_frq_dep = n_frq_dep + 1
!Q      end do
!Q    end if

a489 1
!Q                              & n_frq_dep, &
a538 1
!Q                             & n_frq_dep, &
a573 1
!Q    use Indexed_Values_m, only: Value_QTM_2D_Lists_t, Value_QTM_3D_Lists_t
a575 1
!Q    use Intrinsic, only: L_None
a635 1
!Q    integer, intent(in) :: N_Frq_Dep        ! Number of frequency-dependent VMRs
d693 1
d848 1
a848 3
    real(rp), target :: DH_DT_Path_1(s_t*max_f*sv_t_len) ! for dH/dT on path Zeta X Phi
    real(rp), pointer :: DH_DT_Path(:,:)           ! dH/dT on path X (Zeta * Phi)
    real(rp) :: DH_DT_Path_C(max_c,s_t*sv_t_len)   ! DH_DT_Path on coarse grid
d850 1
a850 1
    real(rp) :: DX_DT(no_tan_hts,s_t*sv_t_len)     ! (No_tan_hts, nz*np)
d856 1
a856 1
    real(rp) :: H_GLGrid(maxVert,no_sv_p_T)        ! H on glGrid surfs (km)
d858 1
a858 1
    real(rp), target :: Mag_Path(s_p*max_f,4)      ! Magnetic field on path
d860 1
a860 1
                                                   ! LBL radiance along the path
d870 5
a874 5
    real(rp) :: SPS_Path(max_f,no_mol)             ! species on path
    real(rp) :: SPS_Path_C(max_c,no_mol)           ! species on coarse path
    real(rp) :: SPS_Path_F(max_f,no_mol)           ! species on GL path
    real(rp) :: TT_Path(max_f,max(s_i,s_ts))       ! TScat on path along the LOS
    real(rp) :: T_GLGrid(maxVert,no_sv_p_T)        ! Temp on glGrid surfs
d876 1
a876 1
    real(r8) :: VMRArray(s_i*n_t_zeta,no_mol)      ! The VMRs for H2O, O3, N2
a941 3
    logical, target :: Do_Calc_Hyd_1(s_t * max_f * sv_t_len) ! dH_dT_Path /= 0
    logical, pointer :: Do_Calc_Hyd(:,:)     ! dH_dT_Path /= 0 on path X (Zeta * Phi)
    logical, pointer :: Do_Calc_Hyd_C(:,:)   ! DO_Calc_Hyd on coarse grid
d1056 1
a1056 1
    ! path for temperature
a1114 3
    ! Get two-D pointer to dh_dt_path_1, do_calc_hyd_1 and do_calc_t_1
    dh_dt_path(1:max_f,1:s_t*sv_t_len) => dh_dt_path_1
    do_calc_hyd(1:max_f,1:s_t*sv_t_len) => do_calc_hyd_1
d1151 1
a1151 2
        & dBeta_dv_path_c, dBeta_dv_path_f, dBeta_dw_path_c, dBeta_dw_path_f, &
        & dh_dT_path, dh_dT_path_c )
d1298 5
a1302 13
    if ( usingQTM .or. .not. usingQTM ) then
!     if ( usingQTM ) then
!       do i = 1, size(beta_group)
!         allocate ( eta_zQ(i)%eta(max_f) )
!         if ( beta_group(i)%qty%qty%template%frequencyCoordinate /= l_none ) then
!           allocate ( eta_fzQ(i)%eta(max_f) )
!         end if
!       end do
!       allocate ( eta_zqT%eta(max_f) )
!     else
      ! Interpolation coefficients for Phi for temperature
      call eta_p_T%create ( max_f, no_sv_p_T, 2*max_f, what=grids_tmp%mol(1) )
      ! Interpolation coefficients for Zeta X Phi for temperature
d1304 18
a1321 3
      do i = 1, size(beta_group)
        ! Interpolation coefficients for Zeta for all VMR
        call eta_z(i)%create ( max_f, grids_f%l_z(i) - grids_f%l_z(i-1), &
d1323 5
a1327 16
        ! Interpolation coefficients for Zeta X Phi for all VMR
        call eta_zp(i)%create ( max_f, &
                              & ( grids_f%l_z(i) - grids_f%l_z(i-1) ) * &
                              & ( grids_f%l_p(i) - grids_f%l_p(i-1) ), &
                              & 2*max_f, what=grids_f%mol(i) )
        ! Interpolation coefficients for Frequency X Zeta X Phi
        call eta_fzp(i)%create ( max_f, &
                               & grids_f%l_v(i) - grids_f%l_v(i-1), &
                               & 2*max_f, what=grids_f%mol(i) )
        ! Representation of d_delta_df for Get_d_Deltau_Pol_df
        if ( s_p > 0 ) call d_delta_df(i)%create ( max_f, &
                              & ( grids_f%l_z(i) - grids_f%l_z(i-1) ) * &
                              & ( grids_f%l_p(i) - grids_f%l_p(i-1) ), &
                              & 2*max_f, what=grids_f%mol(i) )
      end do
    end if
d3517 2
a3518 1
        i_stop = npc ! needed by drad_tran_df
d3703 6
a3708 7
          call drad_tran_dt ( gl_inds, del_zeta, h_path_c, dh_dt_path(1:npf,:), &
            & alpha_path(1:npf), dAlpha_dT_path(:npf), eta_zp_T,                &
            & do_calc_hyd_c(1:npc,:), del_s, ref_corr, tan_ht,                  &
            & dh_dt_path(tan_pt_f,:), do_gl, h_path(:npf), t_path(:npf),        &
            & dsdh_path, dhdz_gw_path, dsdz_gw_path, d_t_scr_dt(1:npc,:),       &
            & tau%tau(:npc,frq_i), inc_rad_path, i_start, tan_pt_c, i_stop,     &
            & grids_tmp%deriv_flags, &
d3750 1
a3750 2
            & h_path(:npf), dh_dt_path(:npf,:), tan_ht,                   &
            & dh_dt_path(tan_pt_f,:), do_calc_hyd_c(1:p_stop,:),          &
d4128 16
a4143 49
      if ( .not. present(QTM) .or. present(QTM) ) then
!       if ( .not. present(QTM) ) then
        if ( temp_der ) then
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp,              &
            &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
            &  eta_p_T, t_path(1:npf), dhdz_path(1:npf),                   &
            !  Stuff for temperature derivatives:
            &  ddHidHidTl0 = ddhidhidtl0, dHidTlm = dh_dt_glgrid,          &
            &  Z_Ref=z_glgrid,                                             &
            &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path(1:npf,:), &
            &  dHtdTl0 = tan_dh_dt, Do_Calc_Hyd = do_calc_hyd(1:npf,:),    &
            &  eta_zp = eta_zp_T )
          dh_dt_path_c(1:npc,:) = dh_dt_path(1:npf:ngp1,:)
          if ( print_tscat_detail > 0 ) &
             & call dump ( dh_dt_path_c(:npc,:), name='dh_dT_path_c' )
          do_calc_hyd(:i_start*ngp1-ngp1,:) = .false.
          do_calc_hyd(i_end*ngp1-ng+1:npf,:) = .false.
          do_calc_hyd_c => do_calc_hyd(1:npf:ngp1,:)
          t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
        else
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp ,             &
            &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
            &  eta_p_T, t_path(1:npf), dhdz_path(1:npf) )
        end if
!Q      else ! QTM
!Q        block
!Q          use More_Metrics_3D_m, only: More_Metrics_3D
!Q          real(rp), pointer :: DH_DT_Path_3(:,:,:) ! dH/dT on path X Zeta X Phi
!Q          logical, pointer :: Do_Calc_Hyd_3(:,:,:) ! dH_dT_Path /= 0 on path X Zeta X Phi
!Q          logical, pointer :: Do_Calc_T_3(:,:,:)   ! path Z X temp Z X temp phi
!Q          if ( temp_der ) then
!Q            dh_dt_path_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_T) => dh_dt_path_1
!Q            do_calc_hyd_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_T) => do_calc_hyd_1
!Q            do_calc_t_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_T) => do_calc_t_1
!Q            call more_metrics_3d ( S, tan_pt_f, t_glgrid, dhdz_glgrid,         &
!Q              &  t_path(1:npf), dhdz_path(1:npf),                              &
!Q              !  Stuff for temperature derivatives:
!Q              &  QTM_hGrid%QTM_tree, ddHidHidTl0 = ddhidhidtl0,                &
!Q              &  dHidTlm = dh_dt_glgrid, T_Sv = Grids_tmp, Z_Ref=z_glgrid,     &
!Q              &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path_3(1:npf,:,:), &
!Q              &  dHtdTl0 = tan_dh_dt, Eta_zQT = eta_zQT%eta, &
!Q              &  do_calc_t = do_calc_t_3(1:npf,:,:), &
!Q              &  do_calc_hyd = do_calc_hyd_3(1:npf,:,:) )
!Q          else
!Q            call more_metrics_3d ( S, tan_pt_f, t_glgrid, dhdz_glgrid, &
!Q              & t_path(1:npf), dhdz_path(1:npf) )
!Q          end if
!Q        end block
      end if ! QTM
d4626 1
a4626 1
       "$Id: FullForwardModel_m.f90,v 2.393 2018/05/15 03:26:25 vsnyder Exp $"
d4636 3
@


2.393
log
@Change Mie tables from pointer to allocatable
@
text
@a582 1
    use Get_ETA_Matrix_M, only: Eta_D_T ! Type for Eta struct
d606 1
d1039 4
a1042 3
    ! Interpolation factors for Temperature and IWC (not geometric interpolation
    ! factors) to put Mie Beta_c_a and Beta_c_s into path
    type (Eta_d_t), dimension(s_ts*max_c) :: Eta_IWC_path_C, Eta_T_path_C
a1068 3
!Q    type (Value_QTM_3D_Lists_t) :: Eta_fzQ(n_frq_dep) ! Interpolation coefficients
!Q                                  ! for frequency-dependent species, computed
!Q                                  ! from Eta_zQ and frequency grids.
a1078 7
!Q    type (value_QTM_2D_lists_t) :: Eta_zQ(s_qtm*size(grids_f%values)) ! Interpolation
!Q                                  ! coefficients from 3D QTM state vector to
!Q                                  ! path for VMRs, taking only zeta and QTM
!Q                                  ! position into account.  For each frequency-
!Q                                  ! dependent VMR, there's an index into Eta_fzQ.
!Q    type (Value_QTM_2D_Lists_t) :: Eta_zQT ! Interpolation coefficients
!Q                                  ! from 3D QTM to path for temperature.
d1330 1
a1330 1
    else
d1355 9
d1439 1
a1439 1
        call generate_TScat
d2370 1
a2370 1
    subroutine Generate_TScat
d2377 1
a2377 2
      use ForwardModelConfig, only: QtyStuff_t
      use Get_Eta_Matrix_m, only: Get_Eta_Sparse, Get_Eta_1D_Hunt
d2385 1
d2389 2
d2394 1
a2394 1
      real(rp) :: Eta_s(size(Grids_tmp%phi_basis)) ! Coeffs to Scat_Tan_Phi
d2403 2
d2407 2
d2430 1
a2430 3
      real(rp) :: Eta_IWC(0:1) ! for current IWC - for Mie tables
      real(rp) :: Eta_T(0:1)   ! for current temperature
      real(rp) :: Eta_T_IWC(0:1,0:1) ! for both
a2436 1
      integer :: First_s, Last_s ! How much of Eta_s to use
d2582 8
a2589 5
            call get_eta_1d_hunt ( IWC_s, logIWC, eta_iwc, iwc_ix )
            ! Get interpolating factors for scattering-point temperature to phase
            ! function temperatures.
            ! T_s(T_ix) <= temp%values(zeta_i,phi_i) < T_s(T_ix+1).
            call get_eta_1d_hunt ( T_s, temp%values(zeta_i,phi_i), eta_t, t_ix )
d2592 1
a2592 2
            if ( iwc_ix < 1 .or. iwc_ix >= size(IWC_s) .or. &
               & t_ix < 1 .or. t_ix >= size(T_s) ) then
a2599 1
              reject = .true.
a2603 2
            forall ( ptg_i=0:1, ptg_j = 0:1 ) &
              & eta_t_iwc(ptg_i,ptg_j) = eta_t(ptg_i) * eta_iwc(ptg_j)
d2612 2
a2613 4
            call get_eta_sparse ( Grids_tmp%phi_basis, scat_phi, &
                                & eta_s, first_s, last_s )
            scat_ht = dot_product(h_glgrid(zeta_f,first_s:last_s), &
                   &             eta_s(first_s:last_s)) + r_eq
d2671 4
a2674 5
              call get_eta_sparse ( Grids_tmp%phi_basis, scat_tan_phi, &
                                  & eta_s, first_s, last_s )

              scat_tan_ht = dot_product(h_glgrid(ptg_f,first_s:last_s), &
                          &             eta_s(first_s:last_s)) + r_eq
d2863 7
d2879 4
a2882 5
            call interpolate_P_to_theta_e ( &
              & p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & P_on_Xi(:i_r) )
d2884 1
a2884 2
              & call interpolate_P_to_theta_e ( &
                & dP_dIWC(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
d2888 2
a2889 3
            if ( temp_der ) then
              call interpolate_P_to_theta_e ( &
                & dP_dT(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
a2892 1
            end if
d3276 5
a3280 5
            call interpolate_Mie ( Mie_frq_index, eta_T_path_c,           &
              & eta_IWC_path_c, atmos_der, temp_der,                      &
              & beta_c_e_path_c(:npc), beta_c_s_path_c(:npc),             &
              & dBeta_c_a_dIWC_path_c(:npc), dBeta_c_s_dIWC_path_c(:npc), &
              & dBeta_c_a_dT_path_c(:npc), dBeta_c_s_dT_path_c(:npc) )
a3850 1
      use Get_Eta_Matrix_M, only: Get_Eta_Stru
d4430 8
a4437 3
        call get_eta_stru ( t_s, t_path_c, eta_T_path_c )
        call get_eta_stru ( iwc_s, iwc_path(1:npf:ngp1,1), eta_IWC_path_c )
        ! We don't have Mie tables for this path
d4687 1
a4687 1
       "$Id: FullForwardModel_m.f90,v 2.392 2018/05/14 23:40:58 vsnyder Exp $"
d4697 3
@


2.392
log
@Change to sparse eta representation
@
text
@d4427 1
a4427 1
        if ( .not. associated(t_s) ) call MLSMessage ( MLSMSG_Error, &
d4681 1
a4681 1
       "$Id: FullForwardModel_m.f90,v 2.390 2017/11/01 00:11:32 vsnyder Exp $"
d4691 3
@


2.391
log
@Made ECRtoFOV request a module
@
text
@d72 3
a74 2
    use Intrinsic, only: Lit_Indices, L_ECRtoFOV, L_None, L_PhiTan, L_PTan, &
      & L_ScECR, L_TScat, L_VMR
d140 2
a141 2
    integer :: Max_F            ! Length of longest possible fine path
                                ! (all npf<max_f)
d152 1
a152 1
    integer :: N_Frq_Dep        ! Number of frequency-dependent VMRs
d263 1
a263 3
        & quantityType=l_ECRtoFOV, &
        & instrumentModule=fwdModelConf%signals(1)%instrumentModule, &
        & config=fwdModelConf )
d287 1
a287 1
      ! Otherwise, assume the each MIF of a MAF covers approximately the same
d289 1
a289 1
      no_sv_p_t = 0
d294 2
a295 2
        if ( size(f_and_v(k)%vertices) > no_sv_p_t ) then
          no_sv_p_t = size(f_and_v(k)%vertices)
d300 1
a300 1
      same_facets = size(path_union(1)%vertices) <= 2 * no_sv_p_t
d304 1
a304 1
        no_sv_p_t = size(f_and_v(1)%vertices)
d307 4
a310 3
      ! Copy the temperature quantity from the state vector via the
      ! configuration into Grids_tmp.  Automatic extents of arrays in
      ! FullForwardModelAuto depend upon components of Grids_Tmp.
d318 2
a319 1
      ! depend upon components of Grids_F.
d324 1
a324 1
    else
d326 2
a327 1
      same_facets = .true. ! even when not QTM, One_Pointing looks at this
d336 3
a338 3
      ! Copy the mixing ratios from the state vector via the
      ! configuration into Grids_f.  Automatic extents of arrays in FullForwardModelAuto
      ! depend upon components of Grids_F.
d345 2
a346 2
      ! One element is needed because routines in Convolve_All_m test whether
      ! its Vertices component is allocated.
d350 1
a350 1
      no_sv_p_t = grids_tmp%l_p(1)  ! size of temperature's horizontal grid ==
d352 3
a354 2
    end if
    sv_t_len = no_sv_p_t * n_t_zeta ! Number of temperature values
d449 7
a455 7
    n_frq_dep = 0
    if ( usingQTM ) then
      do k = 1, size(fwdModelConf%beta_group)
        if ( fwdModelConf%beta_group(k)%qty%qty%template% &
           & frequencyCoordinate /= l_none ) n_frq_dep = n_frq_dep + 1
      end do
    end if
d495 3
a497 1
                              & ptan, phitan, temp, QTM_HGrid, Q_LOS,          &
d499 3
a501 1
                              & no_sv_p_t, n_frq_dep, n_t_zeta, sv_t_len, nlvl,&
d546 6
a551 3
                             & phitan, temp, QTM_HGrid, Q_LOS, QTM_Paths,      &
                             & f_and_v, no_mol, noUsedChannels, no_sv_p_t,     &
                             & n_frq_dep, n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
d570 1
a570 5
    use Comp_Eta_DoCalc_List_m, only: Comp_Eta_DoCalc_List
    use Comp_SPS_Path_Frq_M, only: Comp_SPS_Path, Comp_SPS_Path_No_Frq
use Comp_SPS_Path_Frq_M, only: Comp_SPS_Path, Comp_SPS_Path_Frq, &
! & Comp_SPS_Path_Frq_NZ, &
  & Comp_SPS_Path_No_Frq, Comp_1_SPS_Path_No_Frq
a582 1
    use Get_Eta_List_m, only: Get_Eta_List
d586 5
a590 6
    use HGridsDatabase, only: HGrid_T
    use Indexed_Values_m, only: Value_QTM_2D_Lists_t, Value_QTM_3D_Lists_t, &
      & Value_1D_List_t, Value_1D_Lists_t, Value_2D_List_t, Value_2D_Lists_t, &
      & Value_3d_Lists_t
    use Intrinsic, only: L_A, L_GeocAltitude, L_GeodAltitude, L_None, &
      & L_Radiance, L_TScat, L_VMR, L_Zeta
d608 1
d643 1
a643 1
    type (HGrid_T), pointer, intent(in) :: QTM_HGrid ! HGrid that has finest QTM resolution.
d650 1
a650 1
    integer, intent(in) :: N_Frq_Dep        ! Number of frequency-dependent VMRs
a693 1
    integer :: Frq_I              ! Frequency loop index
d712 1
a712 1
    integer :: NPF                ! Length of a gl path
a718 2
    integer :: SigInd             ! Signal index, loop counter
    integer :: SV_I               ! Loop index and other uses .
d764 2
a765 1
    integer :: F_Inds(max_c*ng)         ! Indices on fine grid
a768 4
    integer :: nz_d_delta_df(max_c,s_a*size(grids_f%values)) ! nonzeros in
                                        ! each column of d_delta_df.
    integer :: nnz_d_delta_df(size(nz_d_delta_df,2)) ! Column lengths in
                                        ! nz_d_delta_df.
d771 4
d784 4
a787 2
    real(rp) :: Alpha_Path_C(max_c)   ! coarse grid absorption coefficient
    real(rp) :: Alpha_Path_F(max_f)   ! fine grid absorption coefficient
d793 2
a794 2
!   real(rp) :: DAlpha_DT_Path_C(max_c)   ! dAlpha/dT on coarse grid
    real(rp) :: DAlpha_DT_Path_F(max_f)   ! dAlpha/dT on fine grid
a813 1
    real(rp) :: H_Path_F(max_f)       ! H_Path on fine grid (km)
d835 2
a836 7
    ! Beta_Path_C has a frequency dimension.  It is d_Alpha/dVMR, which is
    ! needed to compute d_W0/dVMR.
!   real(rp) :: Beta_Path_C(max_c,no_mol)          ! on path coarse
    real(rp) :: Beta_Path_F(max_f,no_mol)          ! on path fine
    real(rp) :: D_Delta_dF(max_c,s_a*size(grids_f%values)) ! Incremental
                                      ! opacity derivative; computed in drad_tran_df
                                      ! and is used to get_d_deltau_pol_df.  Path x SVE.
d843 4
a846 2
    real(rp) :: DAlpha_DF_Path_C(max_c,s_a*no_mol)   ! on coarse path
    real(rp) :: DAlpha_DF_Path_F(max_f,s_a*no_mol)   ! on GL path
a863 1
    real(rp), pointer :: DH_DT_Path_3(:,:,:)       ! dH/dT on path X Zeta X Phi
d865 1
a865 2
    real(rp) :: DH_DT_Path_F(max_f,s_t*sv_t_len)   ! DH_DT_Path on fine grid
    real(rp) :: DHDZ_GLGrid(maxVert,no_sv_p_t) ! dH/dZ on glGrid surfs
a866 1
    real(rp) :: Eta_FZP(max_f,size(grids_f%values)) ! Path x Eta_f * Eta_z * Eta_p
a868 1
real(rp) :: Eta_ZP(max_f,grids_f%p_len)        ! Eta_z x Eta_p on Path X SV
a869 3
    real(rp) :: Eta_ZXP_T(max_f,s_t*sv_t_len)      ! Eta_t_z x Eta_t_p
    type(value_2d_list_t) :: Eta_ZXP_T_List(s_t*max_f) ! Zeta X Phi => Path
    real(rp) :: Eta_ZXP_T_C(max_c,s_t*sv_t_len)    ! Eta_ZXP_T on coarse grid
d872 1
a872 1
    real(rp) :: H_GLGrid(maxVert,no_sv_p_t)        ! H on glGrid surfs (km)
d890 1
a890 1
    real(rp) :: T_GLGrid(maxVert,no_sv_p_t)        ! Temp on glGrid surfs
d911 1
a911 1
    real(rp), target :: DH_DT_GLGrid(maxVert,n_t_zeta,s_t*no_sv_p_t)
d915 2
a916 1
    complex(rp) :: Alpha_Path_Polarized(-1:1,s_p*max_c)
d918 2
a919 1
    complex(rp) :: dAlpha_dT_Polarized_Path_C(-1:1,s_p*s_t*max_c)
d938 1
a938 1
    real(rp) :: DDHIDHIDTL0(maxVert,n_t_zeta,s_t*no_sv_p_t)
d949 4
a952 1
    logical :: DO_GL(max_c)       ! GL indicator
a957 1
    logical :: Do_Calc_FZP(max_f, size(grids_f%values))
d960 1
a960 2
    logical, pointer :: Do_Calc_Hyd_3(:,:,:) ! dH_dT_Path /= 0 on path X Zeta X Phi
    logical :: Do_Calc_Hyd_C(max_c, sv_t_len)  ! DO_Calc_Hyd on coarse grid
a963 3
    logical, pointer :: Do_Calc_T_3(:,:,:)     ! path Z X temp Z X temp phi
    logical :: Do_Calc_T_C(max_c, s_t*sv_t_len)! DO_Calc_T on coarse path
    logical :: Do_Calc_T_F(max_f, s_t*sv_t_len)! DO_Calc_T on fine path
a965 11
logical :: Do_Calc_ZP(max_f,grids_f%p_len) ! same shape as eta_zp

integer :: NZ_ZP(size(eta_zp,1),size(eta_zp,2)) ! same shape as eta_zp
integer :: NNZ_ZP(size(eta_zp,2))               ! number of columns of eta_zp
    integer :: NZ_FZP(max_f,size(grids_f%values))   ! same shape as eta_fzp
    integer :: NNZ_FZP(size(grids_f%values))        ! number of columns of eta_fzp

    integer :: NZ_ZXP_T(max_f,s_t*sv_t_len)         ! same shape as Eta_zxp_t
    integer :: NNZ_ZXP_T(s_t*sv_t_len)              ! number of columns of Eta_zxp_t
    integer :: NZ_ZXP_T_C(max_c,s_t*sv_t_len)       ! same shape as Eta_zxp_t_c
    integer :: NNZ_ZXP_T_C(s_t*sv_t_len)            ! number of columns of Eta_zxp_t
d967 2
a968 1
    integer, pointer :: C_Inds(:)        ! Indices on coarse grid
a1008 2
    ! dAlpha/dT on coarse grid, which is needed to compute d_W0/dT
    real(rp), allocatable :: DAlpha_DT_Path_C(:,:) ! (max_c,max_frq)
a1009 2
    real(rp), allocatable :: Beta_Path_C(:,:,:)! (max_c,no_mol,max_frq)
    ! Incremental opacity derivatives, Path X SVE:
d1054 4
a1057 2
    type (Slabs_Struct), allocatable :: GL_SLABS(:,:) ! Freq. indep. stuff

d1062 30
a1091 30
    ! Interpolation coefficients from Freq X Zeta X Phi basis to path for all
    ! species
    type (Value_3d_Lists_t) :: Eta_fzp_list((1-s_qtm)*size(fwdModelConf%beta_group))
    type (Value_QTM_3D_Lists_t) :: Eta_fzQ(n_frq_dep) ! Interpolation coefficients
                                  ! for frequency-dependent species, computed
                                  ! from Eta_zQ and frequency grids.
    ! Interpolation coefficients from phi basis to path for all species
    type (Value_1D_Lists_t) :: Eta_p_List((1-s_qtm)*size(fwdModelConf%beta_group))
    type (sparse_t) :: Eta_p_Sparse((1-s_qtm)*size(fwdModelConf%beta_group)) ! Interpolation
                                  ! from phi basis for each VMR to path phi.
    type (Value_1D_List_t) :: Eta_p_t(max_f) ! Interpolation coefficients from
                                  ! phi basis to path for temperature
    type (Value_2d_Lists_t) :: Eta_zp_list((1-s_qtm)*size(fwdModelConf%beta_group))
    type (sparse_t) :: Eta_zp_Sparse((1-s_qtm)*size(fwdModelConf%beta_group))
    type (value_QTM_2D_lists_t) :: Eta_zQ(s_qtm*size(grids_f%values)) ! Interpolation
                                  ! coefficients from 3D QTM state vector to
                                  ! path for VMRs, taking only zeta and QTM
                                  ! position into account.  For each frequency-
                                  ! dependent VMR, there's an index into Eta_fzQ.
    type (Value_QTM_2D_Lists_t) :: Eta_zQT ! Interpolation coefficients
                                  ! from 3D QTM to path for temperature.
    type (sparse_t) :: Eta_z_Sparse(size(fwdModelConf%beta_group)) ! Interpolation
                                  ! from zeta for each VMR to path GL zeta.
    type (Value_1D_Lists_t) :: Eta_Z_List(size(fwdModelConf%beta_group)) ! Interpolation
                                  ! from zeta basis for each VMR to GL zeta.
    type (Value_1D_Lists_t) :: Eta_zzT ! Interpolation coefficients from
                                  ! temperature Zeta to GL zeta.  Since this is
                                  ! a 1D interpolation, there can be at most
                                  ! two nonzero coefficients of T zeta for each
                                  ! element GL zeta.
d1141 3
a1143 1
    ! Get two-d pointer to dh_dt_path_1, do_calc_hyd_1 and do_calc_t_1
d1148 6
d1177 2
a1178 2
      call fill_IEEE_NaN ( dTScat_df, dTScat_dT, beta_path_f, d_delta_df, &
        & d_t_scr_dT, d2x_dxdT, dAlpha_df_path_c, dAlpha_df_path_f, &
d1183 3
a1185 3
        & dh_dT_path, dh_dT_path_c, dh_dT_path_f )
      call fill_IEEE_NaN ( dhdz_glgrid, dx_dT, eta_fzp, eta_IWC_zp, eta_mag_zp, &
        & eta_zxp_n, eta_zxp_T, eta_zxp_T_c, eta_zxp_T, eta_zxp_v, &
a1248 10
    ! Put zeros into d_delta_df so that drad_tran_df doesn't do it in
    ! every call.  Most of its time is spent doing this.  Instead, when
    ! drad_tran_df starts, it replaces only the nonzeros (encoded by
    ! nz_d_delta_df and nnz_d_delta_df) by zeros.

    ! Don't need to initialize nz_d_delta_df because only the parts of it
    ! indexed by nnz_d_delta_df are referenced.

    d_delta_df = 0.0
    nnz_d_delta_df = 0
a1250 20
    ! Put zeros into eta_fzp so that we don't need to fill all zeroes later. 
    ! Instead, when eta_fzp is computed, the nonzeros (encoded by nz_fzp and
    ! nnz_fzp) are first replaced by zeros.
 eta_zp = 0.0
 nnz_zp = 0
 do_calc_zp = .false.

    eta_fzp = 0.0
    nnz_fzp = 0
    do_calc_fzp = .false.

    ! Put zeros into eta_zxp_t so that metrics doesn't need to do it in every
    ! call. Instead, when eta_zxp_t is computed, the nonzeros (encoded by
    ! nz_zxp_t and nnz_zxp_t) are first replaced by zeros.  Metrics doesn't
    ! spend much time doing this. We want this representation for dt_script_dt.

    eta_zxp_t = 0.0
    nnz_zxp_t = 0
    do_calc_t = .false.

d1266 2
d1288 2
a1289 2
    allocate ( eta_zzt%eta(maxVert) )
    call get_eta_list ( Grids_tmp%zet_basis, z_glgrid, eta_zzT, sorted=.true. )
d1294 1
a1294 1
    ! the tangent phi's, which may be somewhat different.
d1299 7
a1305 6
    ! For QTM, WindowStart:WindowFinish is the entire grid.  We do the
    ! calculations only for serial numbers in the path description.  This
    ! entails splitting the Metrics-3D calculation into two parts: First,
    ! identify the facets that the path crosses and gather the vertex
    ! serial numbers.  Then do the hydrostatic calculation for those vertices.
    ! Then finish the vertical part of the Metrics-3D calculation.
d1310 2
d1315 1
a1315 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT%eta(:eta_zzT%n), &
d1320 1
a1320 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT%eta(:eta_zzT%n) )
d1327 12
a1338 18
    ! Allocate space for the Eta_z_List components for each quantity.
    do i = 1, size(beta_group)
      allocate ( eta_z_list(i)%eta(max_f) )
    end do

    ! Allocate space for the Eta_zQ components for each quantity, and the
    ! Eta_fzQ components for each frequency-dependent quantity.  The Eta_zQ
    ! values interpolate from the state vector onto the path, so they're
    ! computed for each path.  Eta_fzQ are computed from the frequency grid
    ! for frequency-dependent species, and its Etq_zQ, for each frequency.
    if ( usingQTM ) then
      do i = 1, size(beta_group)
        allocate ( eta_zQ(i)%eta(max_f) )
        if ( beta_group(i)%qty%qty%template%frequencyCoordinate /= l_none ) then
          allocate ( eta_fzQ(i)%eta(max_f) )
        end if
      end do
      allocate ( eta_zqT%eta(max_f) )
d1340 4
d1345 17
a1361 5
        allocate ( eta_p_list(i)%eta(max_f) )
        allocate ( eta_zp_list(i)%eta(max_f) )
        if ( beta_group(i)%qty%qty%template%frequencyCoordinate /= l_none ) then
          allocate ( eta_fzp_list(i)%eta(max_f) )
        end if
a1461 2
      call deallocate_test ( dAlpha_dT_path_c, 'dAlpha_dT_path_c', moduleName )
      call deallocate_test ( beta_path_c,      'Beta_Path_C',      moduleName )
d1580 1
a2299 5
      call allocate_test ( dAlpha_dT_path_c, max_c, maxNoPtgFreqs, &
        & 'dAlpha_dT_path_c', moduleName )
      call allocate_test ( beta_path_c, max_c, no_mol, maxNoPtgFreqs, &
        & 'Beta_Path_C', moduleName )

d3023 5
a3027 5
      & C_Inds, Del_S, Del_Zeta, Do_Calc_fzp, Do_GL, Frq, H_Path_C, Tan_Ht, &
      & IncOptDepth, P_Path, PFA, Ref_Corr, Sps_Path, Tau, T_Path_c,        &
      & T_Script, Tanh1_c, TT_Path_c, W0_Path_c, Z_Path, I_Start, I_End,    &
      & Inc_Rad_Path, RadV, dAlpha_dT_Path_C, H_Atmos_Frq, K_Atmos_Frq,     &
      & K_Spect_dN_Frq, K_Spect_dV_Frq, K_Spect_dW_Frq, K_Temp_Frq )
d3033 1
d3037 1
a3037 1
      use D_T_Script_dTNP_m, only: DT_Script_dT
d3041 1
a3041 1
      use Get_dAlpha_dF_m, only: Get_dAlpha_dF, Get_d2Alpha_dF2
d3043 1
a3043 1
      use Get_Eta_Matrix_m, only: Select_NZ_List
d3051 2
a3052 2
      use Rad_Tran_m, only: Rad_Tran_Pol, dRad_Tran_dF, &
        & d2Rad_Tran_dF2, dRad_Tran_dT, dRad_Tran_dX
a3064 1
      logical, intent(inout) :: Do_Calc_fzp(:,:) ! 'Avoid zeros' indicator
d3087 2
a3088 1
      real(rp), intent(out) :: dAlpha_dT_Path_c(:) ! dAlpha/dT on coarse path
d3097 1
d3099 4
a3102 1
      integer, pointer :: GL_Inds(:) ! Index of GL points -- subset of f_inds
d3134 1
d3136 3
a3138 33
      ! Compute the sps_path for this Frequency
      call comp_sps_path_sparse ( grids_f, frq, eta_zp_list, &
      eta_fzp_list, sps_path(1:npf,:), firstSignal%lo, thisSideband )
block
! Get eta_fzp and do_calc_fzp from eta_fzp_list while we still need them
! to compute derivatives.
use Get_Do_Calc_m, only: Clean_Out_Nonzeros, Get_Eta_Do_Calc
use Load_SPS_Data_m, only: Get_SPS_Bounds
integer :: SPS, V1, V2
integer :: Four_D_Shape(4) ! F_Coeffs, Z_Coeffs, P_Coeffs, X_Coeffs
call clean_out_nonzeros ( eta_fzp, do_calc_fzp, nz_fzp, nnz_fzp )
do sps = 1, size(eta_fzp_list)
call get_sps_bounds ( grids_f, sps, v1, v2 ) ! 1D bounds
eta_fzp(tan_pt_f+1:tan_pt_f+ng,v1:v2) = 0
do_calc_fzp(tan_pt_f+1:tan_pt_f+ng,v1:v2) = .false.
four_d_shape = shape(grids_f%c(sps)%v4) ! Freq, Zeta, Phi, Cross  
if ( allocated(eta_fzp_list(sps)%eta) ) then ! there is frequency dependence     
call get_eta_do_calc ( eta_fzp_list(sps)%eta(:npf), four_d_shape(1:3), &         
  & eta_fzp(:,v1:v2), do_calc_fzp(:,v1:v2), nz_fzp(:,v1:v2), nnz_fzp(v1:v2), &   
  & derivFlags=grids_f%c(sps)%l1 )                                               
else ! there is no frequency dependence                                          
call get_eta_do_calc ( eta_zp_list(sps)%eta(:npf), four_d_shape(2:3), &          
  & eta_fzp(:,v1:v2), do_calc_fzp(:,v1:v2), nz_fzp(:,v1:v2), nnz_fzp(v1:v2), &   
  & derivFlags=grids_f%c(sps)%l1 )                                               
end if                                                                           
end do ! sps

end block
      ! Compute the sps_path for this Frequency
      call comp_sps_path_frq ( Grids_f, Frq, eta_zp(:npf,:), &
        & do_calc_zp(:npf,:), sps_path(:npf,:),              &
        & eta_fzp(:npf,:), do_calc_fzp(:npf,:),              &
        & firstSignal%lo, thisSideband, already_spread=.true. )
d3344 1
a3344 1
          alpha_path_polarized(-1:1,j) = &
d3347 1
a3347 1
          alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
d3353 1
a3353 1
          & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )
d3358 1
a3358 1
        ! Alpha_path_polarized above.  If we did add it here, we would
d3384 13
a3396 9
      !{ We want $\Delta \delta_{s\rightarrow s-1} =
      ! \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
      ! $G(\zeta)$ is {\tt Alpha_path_c}, but $\frac{\text{d}s}{\text{d}h}$
      ! is singular at the tangent point, so we compute
      ! $\Delta \delta_{s\rightarrow s-1} = G(\zeta_i) \delta s_i +
      ! \int_{\zeta_i}^{\zeta_{i-1}} \left(G(\zeta)-G(\zeta_i)\right)
      ! \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      ! \text{d} \zeta$.
d3398 8
a3405 4
      ! Where we do GL, the second integral is approximated using GL (in
      ! {\tt Get_Tau}).  Where we don't do GL, approximate it using the
      ! trapezoid rule (here).  We don't use dsdz_c because ds/dh is singular
      ! at the tangent, therefore ds/dh dh/dz dz /= ds.
d3407 1
a3407 2
      ! There is already a factor of 0.5 in
      ! del_zeta, to compensate for the GL weights summing to 2.0.
d3410 2
a3411 2
          & incoptdepth(j) = incoptdepth(j) + &
            & ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1) * del_zeta(j)
d3413 1
d3416 2
a3417 2
          & incoptdepth(j) = incoptdepth(j) + &
            & ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1) * del_zeta(j)
d3423 2
a3424 1
      call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, ngl, cg_inds_b, ncg )
d3463 1
d3475 1
a3475 1
        call dump ( gl_inds, name="GL_Inds -- fine path indices needing GL integrands" )
d3487 3
a3490 3
        call get_tau ( frq_i, gl_inds, cg_inds, i_start, e_rflty,  &
          & del_zeta, alpha_path_c, ref_corr(:i_end), incoptdepth(:i_end), &
          & tan_pt_c, alpha_path_f(1:ngl), dsdz_gw_path, tau )
d3530 7
a3536 4
        if ( print_path > -1 ) call dump_path ( print_path, fwdModelConf, &
          & i_start, i_stop, i_end, phi_path_c, z_path(1:npf:ngp1),       &
          & sps_path_c(:npc,:), beta_path_c, alpha_path_c, incoptdepth,   &
          & inc_rad_path, t_path_c, frq_i, tau, frq )
d3561 1
d3564 4
a3567 4
        call rad_tran_pol ( tan_pt_c, gl_inds, cg_inds, e_rflty, del_zeta,        &
          & alpha_path_polarized(:,1:npc), ref_corr, incoptdepth_pol(:,:,1:npc),  &
          & deltau_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl), dsdz_gw_path, &
          & ct, stcp, stsp, t_script, dump_rad_pol, prod_pol(:,:,1:npc),          &
d3612 1
d3617 2
d3623 26
a3648 1
        if ( fwdModelConf%useTScat ) then
a3649 35
          ! It is important NOT to put :npf and :ngl bounds on the first
          ! dimensions of eta_fzp and dAlpha_df_path_f, or put a :npc bound
          ! on the first dimension of d_delta_df, because these correspond
          ! to explicit-shape dummy arguments.  Doing so would cause the
          ! compiler to take a copy, and the first dimension of the actual
          ! argument might well be different from the first dimension of the
          ! dummy argument, which would be a catastrophe!

          call drad_tran_df ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,     &
            &  do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, dAlpha_df_path_c(:npc,:), dAlpha_df_path_f,      &
            &  i_start, tan_pt_c, i_stop,                                     &
            &  size(d_delta_df,1), d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
!             &  k_atmos_frq, dB_df, tau%tau(:,frq_i), nz_fzp, nnz_fzp,         &
&  k_atmos_frq, dB_df, tau%tau(:,frq_i), nz_zp, nnz_zp,         &
            &  alpha_path_c, beta_c_e_path_c(:npc),                           &
            &  dBeta_c_a_dIWC_path_c(:npc), dBeta_c_s_dIWC_path_c(:npc),      &
            &  dTScat_df, w0_path_c(:npc) )

        else ! not TScat

          ! It is important NOT to put :npf and :ngl bounds on the first
          ! dimensions of eta_fzp and dAlpha_df_path_f, or put a :npc bound
          ! on the first dimension of d_delta_df, because these correspond
          ! to explicit-shape dummy arguments.  Doing so would cause the
          ! compiler to take a copy, and the first dimension of the actual
          ! argument might well be different from the first dimension of the
          ! dummy argument, which would be a catastrophe!

          call drad_tran_df ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,     &
            &  do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, dAlpha_df_path_c(:npc,:), dAlpha_df_path_f,      &
            &  i_start, tan_pt_c, i_stop,                                     &
            &  size(d_delta_df,1), d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
            &  k_atmos_frq, dB_df )
d3663 4
a3666 6
          call d2rad_tran_df2 ( max_f, gl_inds, del_zeta, Grids_f, eta_fzp,   &
            &  do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, d2Alpha_df2_path_c(:npc,:), d2Alpha_df2_path_f,  &
            &  i_start, tan_pt_c, i_stop,  size(d_delta_df,1),                &
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df,                     &
            &  d2_delta_df2, h_atmos_frq )
d3675 4
a3678 5
          call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, Grids_f, tan_pt_c,       &
            &  beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc), eta_fzp,     &
            &  do_calc_fzp, sps_path, del_s, incoptdepth_pol(:,:,1:p_stop),   &
            &  ref_corr(1:p_stop), d_delta_df, nz_d_delta_df, nnz_d_delta_df, &
            &  de_df(:,:,1:p_stop,:) )
a3698 4
        ! put indices of nonzeros in nz_zxp_t that are in c_inds into nz_zxp_t_c
        call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds(:i_stop), i_start, &
          & nz_zxp_t_c, nnz_zxp_t_c )

d3707 1
a3707 2
                         & eta_zxp_t_c(1:npc,:), nz_zxp_t_c, nnz_zxp_t_c, &
                         & d_t_scr_dt(1:npc,:) )
d3711 3
a3713 2
          call dt_script_dt ( t_path_c(:npc), B(:npc), eta_zxp_t_c(1:npc,:), &
                            & nz_zxp_t_c, nnz_zxp_t_c, frq, d_t_scr_dt(1:npc,:) )
a3716 3
        dh_dt_path_f(:ngl,:) = dh_dt_path(gl_inds,:)
        do_calc_t_f(:ngl,:) = do_calc_t(gl_inds,:)
        h_path_f(:ngl) = h_path(gl_inds)
d3721 3
d3727 8
a3734 13
          call drad_tran_dt ( gl_inds, del_zeta, h_path_c,                 &
            & dh_dt_path_c(1:npc,:), alpha_path_c,                         &
            & dAlpha_dT_path_c(:npc), eta_zxp_t,                           &
            & do_calc_t_c(1:npc,:), do_calc_hyd_c(1:npc,:), del_s,         &
            & ref_corr, tan_ht, dh_dt_path(tan_pt_f,:),                    &
            & do_gl, h_path_f(:ngl), t_path_f(:ngl),                       &
            & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),                   &
            & dAlpha_dT_path_f(:ngl),                                      &
            & do_calc_t_f(:ngl,:), dsdh_path, dhdz_gw_path, dsdz_gw_path,  &
            & d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i),                    &
            & inc_rad_path, i_start, tan_pt_c, i_stop,                     &
            & grids_tmp%deriv_flags, pfa .and. iand(frq_avg_sel,7) == 7,   &
            & k_temp_frq )
d3760 1
a3760 1
              & alpha_path_polarized(l,:npc) * dTanh_dT_c(:npc)
d3764 3
d3770 8
a3777 13
            & t_path_f(:ngl), alpha_path_polarized(:,1:p_stop),           &
            & alpha_path_polarized_f(:,1:ngl),                            &
            & dAlpha_dT_path_c(:npc), dAlpha_dT_path_f(:ngl),             &
            & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f,     &
            & eta_zxp_t_c(1:p_stop,:), eta_zxp_t(:npf,:), del_s,          &
            & gl_inds, del_zeta, do_calc_t_c(1:p_stop,:),                 &
            & do_calc_t_f(:ngl,:), do_gl(1:p_stop), dsdh_path,            &
            & dhdz_gw_path, dsdz_gw_path, incoptdepth_pol(:,:,1:p_stop),  &
            & ref_corr(1:p_stop), h_path_c(1:p_stop), h_path_f(:ngl),     &
            & dh_dt_path_c(1:p_stop,:),dh_dt_path_f(:ngl,:),              &
            & tan_ht, dh_dt_path(tan_pt_f,:),                             &
            & do_calc_hyd_c(1:p_stop,:), grids_tmp%deriv_flags,           &
            & de_dt(:,:,1:p_stop,:) )
d3845 2
d3850 1
a3850 1
      use GLNP, only: GW, NG
a3854 1
      use More_Metrics_3D_m, only: More_Metrics_3D
d3863 1
a3863 1
      integer, intent(in) :: Ptg_i     ! Pointing index
d3905 2
d3908 1
d3961 1
a3961 1
          call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
d3966 1
a3966 1
          call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
d3973 1
a3973 1
          call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
d3981 1
a3981 1
        call Height_Metrics ( tan_phi, tan_ind_f, Grids_tmp%phi_basis, & ! in
d4009 1
a4009 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT%eta(:eta_zzT%n), &
d4015 1
a4015 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zzT%eta(:eta_zzT%n), &
d4045 1
a4045 1
          & which=horizontal )
d4055 2
a4056 1
      end if
d4119 5
a4123 5
        ! calculate the refractive index.  We don't do this for QTM because
        ! the horizontal coordinate isn't Phi, which is what's adjusted here.
        ! T_path, dhdz_path, and eta_fzp will be gotten again later, with
        ! slightly different phi.
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp,            &
d4125 1
a4125 1
          &  eta_p_t(1:npf), t_path(1:npf), dhdz_path(1:npf) )
d4128 8
a4135 15
          ! Compute eta_zp_list (Zeta & Phi only) for water.
          call comp_eta_docalc_list ( grids_f, h2o_ind, z_path(1:npf),  &
                                      & eta_z_list(h2o_ind),  phi_path(1:npf), &
                                      & eta_p_list(h2o_ind), eta_zp_list(h2o_ind) )
          call comp_sps_path_sparse ( grids_f, h2o_ind, eta_zp_list(h2o_ind), &
                                    & sps_path(1:npf,h2o_ind) )
! Compute eta_zp & do_calc_zp (Zeta & Phi only) for water.
! It is important to send all of eta_zp, do_calc_zp, nz_zp and
! nnz_zp so that nonzeros from previous invocations can be
! cleared without violating array bounds.
call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
  &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
  &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp )
call comp_1_sps_path_no_frq ( Grids_f, h2o_ind, eta_zp(1:npf,:), &
  & sps_path(1:npf,h2o_ind) )
d4155 2
a4156 1
      if ( .not. present(QTM) ) then
d4160 1
a4160 1
            &  eta_p_t(1:npf), t_path(1:npf), dhdz_path(1:npf),            &
d4166 1
a4166 3
            &  eta_zp = eta_zxp_t_list(1:npf), &
            &  Do_Calc_T = do_calc_t, Eta_zxp = eta_zxp_t,                 &
            &  NZ_zxp = nz_zxp_t, NNZ_zxp = nnz_zxp_t )
d4172 1
a4172 3
          do_calc_hyd_c(1:npc,:) = do_calc_hyd(1:npf:ngp1,:)
          do_calc_t_c(1:npc,:) = do_calc_t(1:npf:ngp1,:)
          eta_zxp_t_c(1:npc,:) = eta_zxp_t(1:npf:ngp1,:)
d4177 1
a4177 19
            &  eta_p_t(1:npf), t_path(1:npf), dhdz_path(1:npf) )
        end if
      else ! QTM
        if ( temp_der ) then
          dh_dt_path_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_t) => dh_dt_path_1
          do_calc_hyd_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_t) => do_calc_hyd_1
          do_calc_t_3(1:max_f,1:n_t_zeta,1:s_t*no_sv_p_t) => do_calc_t_1
          call more_metrics_3d ( S, tan_pt_f, t_glgrid, dhdz_glgrid,         &
            &  t_path(1:npf), dhdz_path(1:npf),                              &
            !  Stuff for temperature derivatives:
            &  QTM_hGrid%QTM_tree, ddHidHidTl0 = ddhidhidtl0,                &
            &  dHidTlm = dh_dt_glgrid, T_Sv = Grids_tmp, Z_Ref=z_glgrid,     &
            &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path_3(1:npf,:,:), &
            &  dHtdTl0 = tan_dh_dt, Eta_zQT = eta_zQT%eta, &
            &  do_calc_t = do_calc_t_3(1:npf,:,:), &
            &  do_calc_hyd = do_calc_hyd_3(1:npf,:,:) )
        else
          call more_metrics_3d ( S, tan_pt_f, t_glgrid, dhdz_glgrid, &
            & t_path(1:npf), dhdz_path(1:npf) )
d4179 25
a4203 1
      end if
d4208 3
a4210 1
      ! Compute eta_zp_list (for Zeta & Phi only)
a4211 47
      if ( .not. usingQTM ) then
        call comp_eta_docalc_list ( grids_f, z_path(1:npf), eta_z_list, &
                                    & phi_path(1:npf), eta_p_list, eta_zp_list )
! It is important to send all of eta_zp, do_calc_zp, nz_zp and
! nnz_zp so that nonzeros from previous invocations can be
! cleared without violating array bounds.
call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
  &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
  &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp, &
  &  eta_fzp=eta_fzp(1:npf,:), do_calc_fzp=do_calc_fzp(:npf,:) )
! block
! use comp_eta_docalc_sparse_m, only: comp_eta_docalc_sparse
! use get_eta_matrix_m, only: dump_eta_column_sparse
! use load_sps_data_m, only: Dump
! use indexed_values_m, only: Dump
! use intrinsic, only: Lit_Indices
! use sparse_eta_m, only: Sparse_Eta_1D
! use sparse_m, only: add_element, create_sparse, dump
! use String_Table, only: Display_String
! integer :: I, J, L
! call dump ( grids_f, 'Grids_f' )
! call dump ( grids_f%zet_basis(1:grids_f%l_z(1)), name='Zet_Basis' )
! call dump ( Z_Path(:npf), name='Z_Path' )
! call comp_eta_docalc_sparse ( grids_f, tan_pt_f, z_path(1:npf), eta_z_sparse, &
! & phi_path(1:npf), eta_p_sparse, eta_zp_sparse )
! do l = 1, 1 ! size(eta_p_list)
! call dump ( eta_z_sparse(l), 'Eta_Z_Sparse', colon=.true. )
! call display_string ( lit_indices(beta_group(l)%molecule), before='eta_z_List ', advance='yes' )
! call dump ( eta_z_list(l)%eta(1:npf) )
! end do
! do l = 1, 1 ! size(eta_p_list)
! call dump ( eta_p_sparse(l), 'Eta_P_Sparse', colon=.true. )
! call display_string ( lit_indices(beta_group(l)%molecule), before='Eta_p_List ', advance='yes' )
! call dump ( eta_p_list(l)%eta(1:npf) )
! end do
! do l = 1, 1 ! size(eta_zp_list)
! call display_string ( lit_indices(beta_group(l)%molecule), before='Eta_zp_List ', advance='yes' )
! call dump ( eta_zp_list(l)%eta )
! call dump ( Eta_zp_sparse(l), name='Eta_zp_Sparse' )
! end do ! l
! stop
! end block

      else
        call comp_eta_docalc_list ( grids_f, z_path, eta_z_list, s(1:npf)%coeff, &
                                    & eta_zQ )
      end if
d4215 3
a4217 2
      call comp_sps_path_sparse ( Grids_f, eta_zp_list, &
                                & eta_fzp_list, sps_path(1:npf,:) )
d4223 1
d4540 10
a4549 10
          call one_frequency ( ptg_i, frq_i, alpha_path_c(:npc),                &
            & beta_path_c(:npc,:,frq_i), c_inds(:npc), del_s(:npc),             &
            & del_zeta(:npc), do_calc_fzp, do_GL(:npc), frequencies(frq_i),     &
            & h_path_c, tan_ht, incoptdepth(:npc), p_path(:npf), pfaFalse,      &
            & ref_corr(:npc), sps_path(:npf,:), tau_lbl, t_path_c(:npc),        &
            & t_script_lbl(:npc,frq_i), tanh1_c(:npc), tt_path_c(:s_i*npc),     &
            & w0_path_c(:max(s_i,s_ts)*npc), z_path(:npf), i_start, i_end,      &
            & inc_rad_path(:,frq_i), RadV(frq_i), dAlpha_dT_path_c(:npc,frq_i), &
            & H_Atmos_Frq(frq_i,:,:), K_Atmos_Frq(frq_i,:),                     &
            & K_Spect_dN_Frq(frq_i,:), K_Spect_dV_Frq(frq_i,:),                 &
d4579 4
a4582 4
            & beta_path_c(:npc,:,frq_i), c_inds(:npc), del_s(:npc),             &
            & del_zeta(:npc), do_calc_fzp, do_GL(:npc),  channelCenters(frq_i), &
            & h_path_c, tan_ht, incoptdepth(:npc), p_path(:npf), pfaTrue,       &
            & ref_corr(:npc), sps_path(:npf,:), tau_pfa, t_path_c(:npc),        &
d4585 1
a4585 1
            & rad_avg_path(:,frq_i), RadV(frq_i), dAlpha_dT_path_c(:npc,frq_i), &
@


2.390
log
@Comment out a bunch of testing stuff, soon to disappear entierly
@
text
@d262 3
a264 1
        & quantityType=l_ECRtoFOV, config=fwdModelConf )
d4785 1
a4785 1
       "$Id: FullForwardModel_m.f90,v 2.389 2017/11/01 00:09:32 vsnyder Exp $"
d4795 3
@


2.389
log
@Remove recently-added ScECR because it's not needed
@
text
@a66 1
    use Geolocation_0, only: ECR_t
d4279 32
a4310 32
block
use comp_eta_docalc_sparse_m, only: comp_eta_docalc_sparse
use get_eta_matrix_m, only: dump_eta_column_sparse
use load_sps_data_m, only: Dump
use indexed_values_m, only: Dump
use intrinsic, only: Lit_Indices
use sparse_eta_m, only: Sparse_Eta_1D
use sparse_m, only: add_element, create_sparse, dump
use String_Table, only: Display_String
integer :: I, J, L
call dump ( grids_f, 'Grids_f' )
call dump ( grids_f%zet_basis(1:grids_f%l_z(1)), name='Zet_Basis' )
call dump ( Z_Path(:npf), name='Z_Path' )
call comp_eta_docalc_sparse ( grids_f, tan_pt_f, z_path(1:npf), eta_z_sparse, &
& phi_path(1:npf), eta_p_sparse, eta_zp_sparse )
do l = 1, 1 ! size(eta_p_list)
call dump ( eta_z_sparse(l), 'Eta_Z_Sparse', colon=.true. )
call display_string ( lit_indices(beta_group(l)%molecule), before='eta_z_List ', advance='yes' )
call dump ( eta_z_list(l)%eta(1:npf) )
end do
do l = 1, 1 ! size(eta_p_list)
call dump ( eta_p_sparse(l), 'Eta_P_Sparse', colon=.true. )
call display_string ( lit_indices(beta_group(l)%molecule), before='Eta_p_List ', advance='yes' )
call dump ( eta_p_list(l)%eta(1:npf) )
end do
do l = 1, 1 ! size(eta_zp_list)
call display_string ( lit_indices(beta_group(l)%molecule), before='Eta_zp_List ', advance='yes' )
call dump ( eta_zp_list(l)%eta )
call dump ( Eta_zp_sparse(l), name='Eta_zp_Sparse' )
end do ! l
stop
end block
d4783 1
a4783 1
       "$Id: FullForwardModel_m.f90,v 2.388 2017/10/31 23:49:35 vsnyder Exp $"
d4793 3
@


2.388
log
@Make Coefficients a parameterized type
@
text
@a126 3
    type (ECR_t), allocatable :: ScECR(:)     ! Instrument positions for each
                                ! QTM_Paths position, interpolated from PTan
                                ! to Tan_Press
d275 1
a275 1
                              & QTM_paths, scECR )
d4784 1
a4784 1
       "$Id: FullForwardModel_m.f90,v 2.387 2017/10/31 17:36:46 vsnyder Exp $"
d4794 3
@


2.387
log
@Change QTM path from type MIFLOS vector quantity to Path_T
@
text
@d67 1
d113 2
a114 1
    type (Path_t), allocatable :: QTM_Paths(:)! LOS through QTM
d127 4
a130 1
    type (VectorValue_T), pointer :: ScECR    ! Instrument position in ECR
d270 1
a270 1
      scECR => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
d273 2
a274 2
        Q_LOS(k)%lines(1,1)%xyz = scECR%value3(1:3,k,fmstat%maf)    ! C vec
        Q_LOS(k)%lines(2,1)%xyz = ECRtoFOV%value3(7:9,k,fmstat%maf) ! U vec
d277 2
a278 1
      call get_lines_of_sight ( fmStat%maf, pTan, tan_press, Q_LOS, QTM_paths )
d606 1
d1090 2
d1095 1
d1103 2
d2413 2
a2414 2
      use MLSNumerics, only: Coefficients=>Coefficients_r8, &
        & InterpolateArraySetup, InterpolateArrayTeardown
d2491 1
a2491 1
      type (coefficients) :: Coeffs_Theta_e_Xi ! To interpolate from Theta_e to Xi
d4283 32
d4787 1
a4787 1
       "$Id: FullForwardModel_m.f90,v 2.386 2017/09/20 01:18:49 vsnyder Exp $"
d4797 3
@


2.386
log
@Change name of Comp_Eta_DoCalc_Sparse to Comp_Eta_DoCalc_List.  Change
names of Eta_p and Eta_z to Eta_p_List and Eta_z_list.  Get some state
vector quantities only if they're needed.
@
text
@d72 2
a73 2
    use Intrinsic, only: Lit_Indices, L_MIFLOS, L_None, L_PhiTan, L_PTan, &
      & L_TScat, L_VMR
d117 2
d123 1
a123 1
    type (VectorValue_T), pointer :: Q_LOS    ! Line-of-sight, for QTM,
d125 2
d246 1
d256 15
a270 15
      Q_LOS => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_MIFLOS, config=fwdModelConf, &
        & instrumentModule=fwdModelConf%signals(1)%instrumentModule )

      ! Check that Q_LOS has at least 6 channels (two ECR quantities).
      if ( Q_LOS%template%noChans < 6 ) then
        if ( Q_LOS%template%name == 0 ) then
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & "Quantity MIF LOS does not have %d ECR components.", 6 )
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & "Quantity %s does not have %d ECR components.", &
            & [ Q_LOS%template%name, 6 ] )
        end if
      end if
a335 1
      nullify ( Q_LOS )
d634 1
a634 1
    type (VectorValue_T), pointer :: Q_LOS  ! Minor-frame lines of sight for QTM
d1094 1
a1094 1
                                  ! from zeta for each VMR to GL zeta.
d1235 1
a1235 1
    usingQTM = associated(Q_LOS)
d1442 1
a1442 1
            call QTM_paths(ptg_i)%new_path
d4743 1
a4743 1
       "$Id: FullForwardModel_m.f90,v 2.385 2017/08/10 00:15:53 vsnyder Exp $"
d4753 5
@


2.385
log
@Add Tan_Pt_C in calls to Get_d_Deltau_Pol_df.  Do trapezoidal update using
Del_s instead of Del_z because ds/dh is singular at the tangent.  More
stuff getting ready for QTM.
@
text
@d552 1
a552 1
    use Comp_Eta_DoCalc_Sparse_m, only: Comp_Eta_DoCalc_Sparse
d1078 2
a1079 2
    type (Value_1D_Lists_t) :: Eta_p((1-s_qtm)*size(fwdModelConf%beta_group))
    type(Value_1D_List_t) :: Eta_p_t(max_f) ! Interpolation coefficients from
d1089 1
a1089 1
    type (Value_1D_Lists_t) :: Eta_Z(size(fwdModelConf%beta_group)) ! Interpolation
d1316 1
a1316 1
    ! The phi inputa for this subprogram are the orbit plane projected
d1331 2
a1332 1
                               ! h_glgrid, etc. for each pointing.
d1348 1
a1348 1
    ! Allocate space for the Eta_z components for each quantity.
d1350 1
a1350 1
      allocate ( eta_z(i)%eta(max_f) )
d1368 1
a1368 1
        allocate ( eta_p(i)%eta(max_f) )
a1643 2
      orbIncline => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_orbitInclination, config=fwdModelConf )
a1646 2
      gph => GetQuantityForForwardModel (fwdModelIn, fwdModelExtra, &
        & quantityType=l_gph, config=fwdModelConf )
d1659 8
d4172 3
a4174 3
          call comp_eta_docalc_sparse ( grids_f, h2o_ind, z_path(1:npf),  &
                                      & eta_z(h2o_ind),  phi_path(1:npf), &
                                      & eta_p(h2o_ind), eta_zp_list(h2o_ind) )
d4258 2
a4259 2
        call comp_eta_docalc_sparse ( grids_f, z_path(1:npf), eta_z, &
                                    & phi_path(1:npf), eta_p, eta_zp_list )
d4269 1
a4269 1
        call comp_eta_docalc_sparse ( grids_f, z_path, eta_z, s(1:npf)%coeff, &
d4739 1
a4739 1
       "$Id: FullForwardModel_m.f90,v 2.384 2017/03/31 00:49:43 vsnyder Exp $"
d4749 5
@


2.384
log
@Use F_and_V to map to Jacobian for QTM.  Make F_and_V scalar in
One_Pointing.  Cosmetic changes.
@
text
@d554 3
d728 1
d757 1
a757 1
    integer :: nz_d_delta_df(max_f,s_a*size(grids_f%values)) ! nonzeros in
d859 1
a859 1
    real(rp) :: Eta_FZP(max_f,size(grids_f%values)) ! Eta_z x Eta_p * Eta_f
d862 1
d922 1
a922 1
    complex(rp) :: DelTAU_POL(2,2,s_p*max_c) ! E in Michael's notes
d963 1
d965 2
d1215 1
d1260 3
a3149 1
! integer :: J
a3150 1
! integer :: MxC, MxE
a3151 1

a3152 1
! mxc = 0; mxe=0
d3155 12
a3166 14
four_d_shape = shape(grids_f%c(sps)%v4) ! Freq, Zeta, Phi, Cross
if ( allocated(eta_fzp_list(sps)%eta) ) then ! there is frequency dependence
call get_eta_do_calc ( eta_fzp_list(sps)%eta(:npf), four_d_shape(1:3), &
  & eta_fzp(:,v1:v2), do_calc_fzp(:,v1:v2), nz_fzp(:,v1:v2), nnz_fzp(v1:v2), &
  & derivFlags=grids_f%c(sps)%l1 )
else ! there is no frequency dependence
call get_eta_do_calc ( eta_zp_list(sps)%eta(:npf), four_d_shape(2:3), &
  & eta_fzp(:,v1:v2), do_calc_fzp(:,v1:v2), nz_fzp(:,v1:v2), nnz_fzp(v1:v2), &
  & derivFlags=grids_f%c(sps)%l1 )
end if
! do j = 1, size(do_calc_fzp,1)
! mxc = max(count(do_calc_fzp(j,v1:v2)),mxc)
! mxe = max(count(eta_fzp(j,v1:v2)/=0),mxe)
! end do ! j
d3168 1
a3168 3
! print '(3(a,i0))', 'Max Do_Calc_fzp per row per sps ', mxc, &
! ' Max Eta_fzp per row per sps ', mxe
! print '(a,i0)', 'Maxval(NNZ_Fzp) = ', Maxval(NNZ_Fzp)
d3170 5
d3412 2
d3432 2
a3433 2
      ! trapezoid rule (here).  There is already a factor of 0.5 in
      ! {\tt del_zeta}, to compensate for the GL weights summing to 2.0.
d3435 2
d3494 2
d3501 2
a3502 2
        call dump ( gl_inds, name="GL_Inds" )
        call dump ( cg_inds, name="CG_Inds" )
d3517 1
a3517 1
        i_stop = tau%i_stop(frq_i)
d3588 1
a3588 1
          & deltau_pol(:,:,1:npc), Alpha_path_polarized_f(:,1:ngl), dsdz_gw_path, &
d3644 8
a3651 4
          ! It is important NOT to put :nfp and :ngl bounds on the first
          ! dimensions of eta_fzp and dAlpha_df_path_f because these
          ! correspond to explicit-shape dummy arguments.  Doing so would
          ! cause the compiler to take a copy!
d3657 2
a3658 1
            &  k_atmos_frq, dB_df, tau%tau(:,frq_i), nz_fzp, nnz_fzp,         &
d3663 1
a3663 1
        else
d3665 7
a3671 4
          ! It is important NOT to put :nfp and :ngl bounds on the first
          ! dimensions of eta_fzp and dAlpha_df_path_f because these
          ! correspond to explicit-shape dummy arguments.  Doing so would
          ! cause the compiler to take a copy!
a3678 1

d3706 5
a3710 5
          call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, Grids_f,               &
            &  beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc), eta_fzp,   &
            &  do_calc_fzp, sps_path, del_s, incoptdepth_pol(:,:,1:p_stop), &
            &  ref_corr(1:p_stop), d_delta_df(1:npc,:), nz_d_delta_df,      &
            &  nnz_d_delta_df, de_df(:,:,1:p_stop,:) )
d4118 1
a4118 1
        i_start = 1;
d4172 9
d4255 7
d4734 1
a4734 1
       "$Id: FullForwardModel_m.f90,v 2.383 2017/03/24 00:10:43 vsnyder Exp $"
d4744 4
@


2.383
log
@Change the first extent of nz_d_delta_df back to max_f because the number
of nonzeroes in a column of d_delta_df is not limited unless the vertical
grids are the same for all species.
@
text
@d335 4
a338 2
      allocate ( F_and_V(0), stat=stat, errmsg=ermsg )
      call test_allocate ( stat, moduleName, "F_and_V", 1, no_tan_hts, &
d1280 2
a1281 2
      call convolution_setup ( DH_DZ_Out, DX_DH_Out, DXDT_Surface, &
                             & DXDT_Tan, Q_EarthRadC_sq, Est_ScGeocAlt, &
d1430 2
a1431 1
              &                 path=QTM_paths(ptg_i), s=s, f_and_v=f_and_v )
d1444 2
a1445 2
        ( DH_DZ_OUT, DX_DH_OUT, DX_DT, DXDT_Surface, &
        & DXDT_TAN, D2X_DXDT, &
d1574 1
a1574 1
        & L_LOSVel, L_SurfaceHeight, L_OrbitInclination, L_REFGPH, &
d2375 13
a2387 13
      use CONSTANTS, only: PI
      use CONVOLVE_ALL_M, only: STORE_OTHER_DERIV, STORE_TEMPERATURE_DERIV
      use FORWARDMODELCONFIG, only: QTYSTUFF_T
      use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE, GET_ETA_1D_HUNT
      USE LOAD_SPS_DATA_M, only: FINDINGRID
      use MLSNUMERICS, only: COEFFICIENTS_R8, INTERPOLATEARRAYSETUP, &
        & INTERPOLATEARRAYTEARDOWN
      use MLSSIGNALS_M, only: GETNAMEOFSIGNAL
      use MOLECULES, only: L_CLOUDICE
      use READ_MIE_M, only: DP_DIWC, DP_DT, F_S, IWC_S, P, T_S, THETA_S
      use SORT_M, only: SORTP
      use TSCAT_SUPPORT_M, only: INTERPOLATE_P_TO_THETA_E
      use VECTORSMODULE, only: DUMP
d2458 1
a2458 1
      type (Coefficients_r8) :: Coeffs_Theta_e_Xi ! To interpolate from Theta_e to Xi
d2465 1
a2465 1
      call Trace_Begin ( me, 'Generate_TScat', cond=toggle(emit) )
d2640 1
a2640 1
                                       & jacobian )
d2646 1
a2646 1
                                       & jacobian )
d2958 1
a2958 1
                                       & jacobian )
d2962 1
a2962 1
                                       & jacobian )
d3045 1
a3045 1
      USE L2PC_m, only: L2PC_T
d3135 1
d3427 1
a3427 1
            & ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1)*del_zeta(j)
d3432 1
a3432 1
            & ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1)*del_zeta(j)
d3435 3
d3460 1
a3460 1
        ! The derivatives that get_Beta_path computes depend on which
d3871 1
a3871 1
      use Metrics_M, only: Height_Metrics, More_Metrics, Tangent_Metrics
d3903 1
a3903 1
      type(facets_and_vertices_t), intent(in), optional :: F_and_V(:) ! Indices
d3945 1
a3945 1
          & setDerivFlags=.true., subset=f_and_v(ptg_i)%vertices )
d3948 1
a3948 1
          & subset=f_and_v(ptg_i)%vertices )
d4012 2
a4013 2
        do i_start = 1, size(f_and_v(ptg_i)%vertices) ! I_Start is a temp here
          QTM%path_vertices(f_and_v(ptg_i)%vertices(i_start)) = i_start
d4024 1
a4024 1
          call two_d_hydrostatic ( Grids_tmp, refGPH%template%surfs(1,1), &
d4028 1
a4028 1
            &  vertices=f_and_v(ptg_i)%vertices )
d4030 1
a4030 1
          call two_d_hydrostatic ( Grids_tmp, refGPH%template%surfs(1,1), &
d4033 1
a4033 1
            &  vertices=f_and_v(ptg_i)%vertices )
d4061 1
a4061 1
          & tangent_index=tan_ind_f, pad=NG, f_and_v=f_and_v(ptg_i), &
d4696 1
a4696 1
       "$Id: FullForwardModel_m.f90,v 2.382 2017/03/20 23:25:40 vsnyder Exp $"
d4706 5
@


2.382
log
@Double row dimension of Nz_d_Delta_df
@
text
@d751 2
a752 4
    integer :: nz_d_delta_df(2*(ngp1+1),s_a*size(grids_f%values)) ! nonzeros in
                                        ! d_delta_df; can never be more than one
                                        ! at each end of a panel, + NG between,
                                        ! per state vector element.
d3160 1
d4689 1
a4689 1
       "$Id: FullForwardModel_m.f90,v 2.381 2017/03/11 00:58:13 vsnyder Exp $"
d4699 3
@


2.381
log
@Many changes leading to 3D/QTM model
@
text
@a313 1

d751 1
a751 1
    integer :: nz_d_delta_df(s_a*(ngp1+1),size(grids_f%values)) ! nonzeros in
d755 1
a755 1
    integer :: nnz_d_delta_df(s_a*size(grids_f%values)) ! Column lengths in
d4690 1
a4690 1
       "$Id: FullForwardModel_m.f90,v 2.380 2017/01/14 02:58:48 vsnyder Exp $"
d4700 3
@


2.380
log
@Inching toward 3D QTM forward model
@
text
@d41 9
d82 1
a82 1
    use Path_Representation_m, only: Facets_and_Vertices_t, Path_t
d98 1
a98 1
                                          ! and species grids, sans duplicates.
d102 2
a103 2
                                          ! vertices under each path through
                                          ! the QTM.
d114 3
d130 2
d183 3
d189 6
a219 6
    ! Copy the temperature quantity from the state vector via the
    ! configuration into Grids_f.

    temp => fwdModelConf%temp%qty
    call load_one_item_grid ( grids_tmp, temp, fmStat%maf, phitan, fwdModelConf, .true. )

a229 4
    ! Copy the mixing ratios from the state vector into Grids_f.

    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f )

d236 1
a236 6
    n_t_zeta = grids_tmp%l_z(1)  ! Number of zeta levels for temperature

    ! Check whether temperature and all the mixing ratios either all have QTM
    ! HGrid, or none do.  If so, find the QTM HGrid with the finest resolution.

    call check_QTM ( grids_tmp, grids_f, QTM_HGrid, usingQTM )
d248 3
d275 6
d282 1
d284 7
a290 2
        call QTM_Facets_Under_Path ( QTM_paths(k), QTM_HGrid%QTM_tree, F_and_V(k) )
        no_sv_p_t = max(no_sv_p_t,size(f_and_v(k)%vertices))
d292 23
a314 1
      sv_t_len = no_sv_p_t * n_t_zeta
d316 16
d339 2
a340 5
      no_sv_p_t = grids_tmp%l_p(1) ! size of temperature's horizontal grid ==
                                   ! windowFinish - windowStart + 1.
      sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t =
                                   ! grids_tmp%l_p(1) * grids_tmp%l_l(1) =
                                   ! size(grids_tmp%values,1)
d342 1
d367 1
a367 1
        else
d444 1
a444 1
        
d454 2
a455 1
    if ( switchDetail(switches,'Grids') > -1 ) then ! dump the grids
d550 4
a553 7
    use Comp_ETA_DoCalc_No_Frq_M, only: Comp_ETA_DoCalc_No_Frq
    use Comp_ETA_DoCalc_Sparse_m, only: Comp_ETA_DoCalc_Sparse
    use Comp_SPS_Path_Frq_M, only: Comp_SPS_Path, Comp_SPS_Path_Frq, &
    ! & Comp_SPS_Path_Frq_NZ, &
      & Comp_SPS_Path_No_Frq, Comp_1_SPS_Path_No_Frq
    use Comp_Sps_Path_Sparse_m, only: Value_2d_Lists_F_t, &
      & Value_QTM_2D_Lists_f_t
d571 2
a572 1
      & Value_1D_Lists_t, Value_3d_Lists_t
a645 1
    integer, intent(in) :: S_T  ! Multiplier for temp derivative sizes, 0 or 1
d648 1
a650 1
    integer, intent(in) :: S_TD ! Multiplier for temp dependence deriv sizes, 0 or 1
d653 3
a655 1
    integer, intent(in) :: S_I  ! Multiplier for ice/cloud sizes, 0 or 1
a657 1
    integer, intent(in) :: S_QTM ! Multiplier for sizes of QTM-related stuff, 0 or 1
d752 6
a757 4
    integer :: nz_d_delta_df(s_a*max_c,size(grids_f%values)) ! nonzeros in
                                        ! d_delta_df
    integer :: nnz_d_delta_df(size(grids_f%values)) ! Column lengths in
                                        ! nz_d_delta_df
a858 1
    real(rp) :: Eta_ZP(max_f,grids_f%p_len)        ! Eta_z x Eta_p on Path X SV
d861 1
a958 1
    logical :: Do_Calc_ZP(max_f,grids_f%p_len) ! same shape as eta_zp
d960 2
a961 4
    integer :: NZ_ZP(size(eta_zp,1),size(eta_zp,2)) ! same shape as eta_zp
    integer :: NNZ_ZP(size(eta_zp,2))               ! number of columns of eta_zp
!     integer :: NZ_FZP(max_f,size(grids_f%values))   ! same shape as eta_fzp
!     integer :: NNZ_FZP(size(grids_f%values))        ! number of columns of eta_fzp
d1064 2
d1070 6
a1075 4
    type (Value_1D_Lists_t) :: Eta_p(max_f)         ! Interpolation coefficients
                                  ! from phi basis to path
    type (Value_2d_Lists_F_t) :: Eta_zp_list((1-s_qtm)*size(fwdModelConf%beta_group))
    type (value_QTM_2D_lists_f_t) :: Eta_zQ(s_qtm*size(grids_f%values)) ! Interpolation
d1174 1
a1174 1
        & eta_zp, eta_zxp_n, eta_zxp_T, eta_zxp_T_c, eta_zxp_T, eta_zxp_v, &
d1249 3
a1251 18
    ! Put zeros into eta_zp so that comp_eta_docalc_no_frq doesn't need to
    ! do it in every call.  Most of its time is spent doing this.  Instead,
    ! when eta_zp is computed, the nonzeros (encoded by nz_zp and nnz_zp)
    ! are first replaced by zeros.  Make Do_Calc_zp false because
    ! Multiply_Eta_Column_Sparse (called from Comp_Eta_Docalc_No_Frq) is
    ! only set where there are nonzeroes indicated by nz_zp, leaving
    ! others undefined until nonzeroes land in the same place.

    eta_zp = 0.0
    nnz_zp = 0
    do_calc_zp = .false.

    ! Put zeros into eta_fzp so that comp_sps_path_frq_nz doesn't need to
    ! do it in every call.  Instead, when eta_fzp is computed, the nonzeros
    ! (encoded by nz_fzp and nnz_fzp) are first replaced by zeros.  Do_Calc_fzp
    ! probably doesn't presently need to be preset to false, but if we ever
    ! handle it sparsely as we do for Do_Calc_zp, it would only be set where
    ! Eta_fzp is nonzero.
d1254 1
a1254 1
!     nnz_fzp = 0
d1258 3
a1260 3
    ! call. Instead, when eta_zp is computed, the nonzeros (encoded by nz_zp
    ! and nnz_zp) are first replaced by zeros.  Metrics doesn't spend much
    ! time doing this. We want this representation for dt_script_dt.
a1345 1
    k = 0 ! Index of frequency-dependent VMR
d1350 1
a1350 5
          k = k + 1
          allocate ( eta_fzQ(k)%eta(max_f) )
          eta_zQ(i)%frq_index = k
      ! else
      !   eta_zQ(i)%frq_index = 0 ! default initialized
d1359 1
a1359 5
          k = k + 1
          allocate ( eta_fzp_list(k)%eta(max_f) )
          eta_zp_list(i)%frq_index = k
      ! else
      !   eta_zQ(i)%frq_index = 0 ! default initialized
d3023 5
a3027 6
      & C_Inds, Del_S, Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL, Frq,       &
      & H_Path_C, Tan_Ht, IncOptDepth, P_Path, PFA, Ref_Corr, Sps_Path,     &
      & Tau, T_Path_c, T_Script, Tanh1_c, TT_Path_c, W0_Path_c,             &
      & Z_Path, I_Start, I_End, Inc_Rad_Path, RadV, dAlpha_dT_Path_C,       &
      & H_Atmos_Frq, K_Atmos_Frq, K_Spect_dN_Frq, K_Spect_dV_Frq,           &
      & K_Spect_dW_Frq, K_Temp_Frq )
d3033 2
a3034 2
      use CS_EXPMAT_m, only: CS_EXPMAT
      use DO_T_SCRIPT_m, only: TWO_D_T_SCRIPT, TWO_D_T_SCRIPT_CLOUD
d3036 1
a3036 1
      use D_T_SCRIPT_DTNP_m, only: DT_SCRIPT_DT
d3038 7
a3044 7
      use Get_Beta_Path_m, only: GET_Beta_Path, GET_Beta_Path_CLOUD, &
        & Get_Beta_Path_PFA, GET_Beta_Path_POLARIZED
      use Get_DAlpha_DF_m, only: GET_DAlpha_DF, GET_D2Alpha_DF2
      use Get_D_Deltau_Pol_m, only: GET_D_DELTAU_POL_DF, GET_D_DELTAU_POL_DT
      use GET_ETA_MATRIX_m, only: SELECT_NZ_LIST
      use INTERPOLATE_MIE_m, only: INTERPOLATE_MIE
      use LOAD_SPS_DATA_m, only:  LOAD_ONE_ITEM_GRID
d3046 2
a3047 2
      use MCRT_m, only: MCRT_DER
      use OPACITY_m, only: OPACITY
d3049 7
a3055 7
      use PHYSICS, only: H_OVER_K
      use RAD_TRAN_m, only: RAD_TRAN_POL, DRAD_TRAN_DF, &
        & D2RAD_TRAN_DF2, DRAD_TRAN_DT, DRAD_TRAN_DX
      use SCATSOURCEFUNC, only: T_SCAT, INTERP_TSCAT
      use TAU_m, only: GET_TAU
      USE TSCAT_SUPPORT_m, only: GET_DB_DT, GET_TSCAT, GET_TSCAT_SETUP, &
        & GET_TSCAT_TEARDOWN, MIE_FREQ_INDEX
a3064 1
      logical, intent(in) :: Do_Calc_zp(:,:) ! 'Avoid zeros' indicator
d3088 11
a3098 11
      real(rp), intent(out) :: H_ATMOS_FRQ(:,:) ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr
      real(rp), intent(out) :: K_ATMOS_FRQ(:)  ! dI/dVMR, ptg.frq X vmr-SV
      real(rp), intent(out) :: K_SPECT_DN_FRQ(:) ! ****
      real(rp), intent(out) :: K_SPECT_DV_FRQ(:) ! ****
      real(rp), intent(out) :: K_SPECT_DW_FRQ(:) ! ****
      real(rp), intent(out) :: K_TEMP_FRQ(:)   ! dI/dT, ptg.frq X T-SV

      integer, pointer :: CG_INDS(:) ! Indices on coarse grid where GL needed
      real(r8) :: FRQHK              ! 0.5 * Frq * H_Over_K
      integer, pointer :: GL_INDS(:) ! Index of GL points -- subset of f_inds
      integer :: I_STOP              ! Stop path integration before I_End
d3108 1
a3108 1
      complex(rp) :: RAD_POL(2,2)    ! polarized radiance output of mcrt for one freq and pointing
d3116 1
a3116 1
      logical, parameter :: cld_fine = .false.
d3131 33
a3163 12
      call comp_sps_path_frq ( Grids_f, Frq, eta_zp(:npf,:), &
        & do_calc_zp, sps_path(:npf,:),                      &
        & eta_fzp(:npf,:), do_calc_fzp(:npf,:),              &
        & firstSignal%lo, thisSideband, already_spread=.true. )
!         ! Send all of eta_zp so comp_sps_path_frq_nz doesn't get an array
!         ! bounds error when it's clearing parts indexed by nz_zp.
! I don't know why this doesn't work -- maybe nz_... and nnz_... have not
! been computed?
!         call comp_sps_path_frq_nz ( Grids_f, Frq, eta_zp, nz_zp, nnz_zp, &
!           & do_calc_zp, sps_path(:npf,:),                                &
!           & do_calc_fzp, eta_fzp(:npf,:), nz_fzp, nnz_fzp,               &
!           & firstSignal%lo, thisSideband )
d3633 1
a3633 1
            &  k_atmos_frq, dB_df, tau%tau(:,frq_i), nz_zp, nnz_zp,           &
d3644 1
a3860 2
use Dump_Row_Sparse_m, only: Dump_Row_Sparse
use Indexed_Values_m, only: Dump
d3865 1
d3938 8
d4091 1
a4091 1
        i_start = 1
d4132 1
a4132 1
        ! T_path, dhdz_path, and eta_zp will be gotten again later, with
d4136 1
a4136 1
          &  t_path(1:npf), dhdz_path(1:npf) )
d4139 6
a4144 9
          ! Compute eta_zp & do_calc_zp (Zeta & Phi only) for water.
          ! It is important to send all of eta_zp, do_calc_zp, nz_zp and
          ! nnz_zp so that nonzeros from previous invocations can be
          ! cleared without violating array bounds.
          call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
            &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
            &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp )
          call comp_1_sps_path_no_frq ( Grids_f, h2o_ind, eta_zp(1:npf,:), &
            & sps_path(1:npf,h2o_ind) )
d4168 1
a4168 1
            &  t_path(1:npf), dhdz_path(1:npf),                            &
d4174 1
d4189 1
a4189 1
            &  t_path(1:npf), dhdz_path(1:npf) )
d4197 1
a4197 1
            & t_path(1:npf), dhdz_path(1:npf),                               &
d4214 1
a4214 1
      ! Compute eta_zp & do_calc_zp (for Zeta & Phi only)
d4217 3
a4219 28
        ! It is important to send all of eta_zp, do_calc_zp, nz_zp and
        ! nnz_zp so that nonzeros from previous invocations can be
        ! cleared without violating array bounds.
        call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
          &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
          &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp, &
          &  eta_fzp=eta_fzp(1:npf,:), do_calc_fzp=do_calc_fzp(:npf,:) )
! block
! integer :: I, J, K
! k = 0
! do i = 1, 1 ! ubound(grids_f%l_p,1)
! j = k + 1
! k = k + (grids_f%l_p(i)-grids_f%l_p(i-1)) * (grids_f%l_z(i)-grids_f%l_z(i-1))
! call output ( i, before='Eta_ZP(', after=')', advance='yes' )
! call dump_row_sparse ( eta_zp(:,j:k), width=6, &
! bounds2= [ grids_f%l_z(i)-grids_f%l_z(i-1), grids_f%l_p(i)-grids_f%l_p(i-1) ] )
! end do
! end block
! call comp_eta_docalc_sparse ( beta_group, z_path(1:npf), eta_z, phi_path(1:npf), &
! & eta_p, eta_zp_list%value_2d_lists_t )
! call dump ( deg2rad*beta_group(1)%qty%qty%template%phi(1,:), 'beta_group(1)%qty%qty%template%phi' )
! call dump ( phi_path(1:npf), 'Phi_Path (radians) in fullForwardModel' )
! call dump ( eta_p(1)%eta(1:eta_p(1)%n), 'Eta_p list' )
! do i = 1, 1 ! size(beta_group)
! call dump ( eta_z(i)%eta(1:eta_z(i)%n), 'Eta_z list' )
! call dump ( eta_zp_list(i)%value_2d_lists_t%eta, 'Eta_ZP_List' )
! end do
! stop
d4221 2
a4222 2
!         call comp_eta_docalc_sparse ( beta_group, z_path, eta_z, &
!           & s%coeff, eta_zQ%value_QTM_2d_lists_t )
d4227 2
a4228 2
      call comp_sps_path_no_frq ( Grids_f, eta_zp(1:npf,:), sps_path(1:npf,:) )

d4552 3
a4554 4
            & del_zeta(:npc), do_calc_fzp(:npf,:), do_calc_zp(:npf,:),          &
            & do_GL(:npc), frequencies(frq_i), h_path_c, tan_ht,                &
            & incoptdepth(:npc), p_path(:npf), pfaFalse, ref_corr(:npc),        &
            & sps_path(:npf,:), tau_lbl, t_path_c(:npc),                        &
d4556 2
a4557 3
            & w0_path_c(:max(s_i,s_ts)*npc),                                    &
            & z_path(:npf), i_start, i_end, inc_rad_path(:,frq_i), RadV(frq_i), &
            & dAlpha_dT_path_c(:npc,frq_i),                                     &
d4590 3
a4592 4
            & del_zeta(:npc), do_calc_fzp(:npf,:), do_calc_zp(:npf,:),          &
            & do_GL(:npc),  channelCenters(frq_i), h_path_c, tan_ht,            &
            & incoptdepth(:npc), p_path(:npf), pfaTrue, ref_corr(:npc),         &
            & sps_path(:npf,:), tau_pfa, t_path_c(:npc),                        &
d4594 2
a4595 3
            & w0_path_c(:max(s_i,s_ts)*npc),                                    &
            & z_path(:npf), i_start, i_end, rad_avg_path(:,frq_i), RadV(frq_i), &
            & dAlpha_dT_path_c(:npc,frq_i),                                     &
d4691 1
a4691 1
       "$Id: FullForwardModel_m.f90,v 2.379 2016/12/02 02:04:50 vsnyder Exp $"
d4701 3
@


2.379
log
@Use 'P' Eta list for Eta_ZZ
@
text
@d63 2
a64 1
    use Intrinsic, only: Lit_Indices, L_MIFLOS, L_PhiTan, L_PTan, L_TScat, L_VMR
d132 1
d378 8
d425 1
a425 1
                              & no_sv_p_t, n_t_zeta, sv_t_len, nlvl,           &
d472 1
a472 1
                             & n_t_zeta, sv_t_len, nlvl, no_tan_hts,           &
d491 1
d495 2
d508 1
a508 1
    use Get_Eta_List_m, only: Eta_List_1D
d513 3
a515 2
    use Indexed_Values_m, only: Value_1D_p_t, Value_QTM_2D_List_t
    use Intrinsic, only: L_A, L_GeocAltitude, L_GeodAltitude, &
d574 1
d1007 21
a1027 11
    type (value_1D_p_t) :: Eta_ZZ(2*maxVert)       ! Interpolation coefficients
                                                   ! from temperature Zeta to
                                                   ! GL zeta.  Since this is a
                                                   ! 1D interpolation, there can
                                                   ! be at most two nonzero
                                                   ! coefficients of T zeta
                                                   ! for each element GL zeta.
    integer :: N_ZZ               ! Number of used elements in  Eta_ZZ
    type (Value_QTM_2D_List_t) :: Eta_zQT(s_qtm*max_f) ! Interpolation coefficients
                                  ! from 3D QTM to path for temperature

d1253 1
a1253 1
    ! Temperature is coherent and stacked, so Eta_ZZ is applicable everywhere.
d1255 2
a1256 1
    call eta_list_1d ( Grids_tmp%zet_basis, z_glgrid, eta_zz, n_zz, sorted=.true. )
d1278 1
a1278 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz(:n_zz), &
d1283 1
a1283 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz(:n_zz) )
d1290 37
d3804 2
d3957 1
a3957 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz(:n_zz), &
d3963 1
a3963 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz(:n_zz), &
d4140 1
a4140 1
            &  dHtdTl0 = tan_dh_dt, Eta_zQT = eta_zQT, &
d4154 33
a4186 7
      ! It is important to send all of eta_zp, do_calc_zp, nz_zp and
      ! nnz_zp so that nonzeros from previous invocations can be
      ! cleared without violating array bounds.
      call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
        &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
        &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp, &
        &  eta_fzp=eta_fzp(1:npf,:), do_calc_fzp=do_calc_fzp(:npf,:) )
d4658 1
a4658 1
       "$Id: FullForwardModel_m.f90,v 2.378 2016/11/23 21:35:13 vsnyder Exp $"
d4668 3
@


2.378
log
@Compute Eta_ZZ to interpolate from Temperature's zeta basis to the GL
zeta grid, and use it for hydrostatic calculations.
@
text
@d500 1
a500 1
    use Indexed_Values_m, only: Value_1D_List_t, Value_QTM_2D_List_t
d992 1
a992 1
    type (Value_1D_List_t) :: Eta_ZZ(maxVert)      ! Interpolation coefficients
d994 6
a999 1
                                                   ! GL zeta
d1230 1
a1230 1
    call eta_list_1d ( Grids_tmp%zet_basis, z_glgrid, eta_zz, sorted=.true. )
d1252 1
a1252 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz, &
d1257 1
a1257 1
          &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz )
d3892 1
a3892 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz, &
d3898 1
a3898 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, eta_zz, &
d4567 1
a4567 1
       "$Id: FullForwardModel_m.f90,v 2.377 2016/11/23 00:14:36 vsnyder Exp $"
d4577 4
@


2.377
log
@Use types from Indexed_Values_m.  Some cannonball polishing.
@
text
@d495 1
d500 1
a500 1
    use Indexed_Values_m, only: Value_QTM_2D_List_t
d992 3
d1222 5
d1228 1
a1228 1
    ! The phi input for this program are the orbit plane projected
d1234 4
a1237 7
    ! RefGPH is in meters, but Two_D_Hydrostatic wants it in km.
    ! RefGPH is assumed to be coherent, and to have one surface, so Surfs
    ! is spread out to the same extent as the window.

    ! For QTM, WindowStart:WindowFinish is the entire grid.  We could do the
    ! calculations only for serial numbers in the path description.  This would
    ! entail splitting the Metrics-3D calculation into two parts: First,
a1240 1
    ! For now, do them all, until a profiler says this expense is significant.
d1245 1
a1245 2
        call two_d_hydrostatic ( Grids_tmp, &
          &  spread(refGPH%template%surfs(1,1),1,windowFinish-windowStart+1), &
d1247 2
a1248 2
          &  t_glgrid, h_glgrid, dhdz_glgrid, &
          &  dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
d1250 1
a1250 2
        call two_d_hydrostatic ( Grids_tmp, &
          &  spread(refGPH%template%surfs(1,1),1,windowFinish-windowStart+1), &
d1252 1
a1252 1
          &  t_glgrid, h_glgrid, dhdz_glgrid )
d3885 1
a3885 2
          call two_d_hydrostatic ( Grids_tmp, &
            &  spread(refGPH%template%surfs(1,1),1,size(f_and_v(ptg_i)%vertices)), &
d3887 3
a3889 2
            &  t_glgrid, h_glgrid, dhdz_glgrid, &
            &  dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0, vertices=f_and_v(ptg_i)%vertices )
d3891 1
a3891 2
          call two_d_hydrostatic ( Grids_tmp, &
            &  spread(refGPH%template%surfs(1,1),1,size(f_and_v(ptg_i)%vertices)), &
d3893 2
a3894 1
            &  t_glgrid, h_glgrid, dhdz_glgrid, vertices=f_and_v(ptg_i)%vertices )
d4562 1
a4562 1
       "$Id: FullForwardModel_m.f90,v 2.376 2016/11/17 01:45:26 vsnyder Exp $"
d4572 3
@


2.376
log
@Use Comp_Sps_Path_No_Frq to get H2O for phi refractive correction.  Some
work on QTM also.
@
text
@d480 1
a480 2
    use Comp_ETA_DoCalc_No_Frq_M, only: Comp_ETA_DoCalc_No_Frq, &
      & Spread_Eta_FZP_from_Eta_ZP
d495 1
a495 1
    use Get_ETA_Matrix_M, only: ETA_D_T ! TYPE FOR ETA STRUCT
d499 1
d517 1
a517 1
    use QTM_Interpolation_Weights_3D_m, only: S_QTM_t, Weight_ZQ_t
a685 3
    logical :: Do_Calc_Tscat(max_f,s_i*sv_t_len)    ! 'Avoid zeros' indicator
    logical :: Do_Calc_Salb(max_f,s_i*sv_t_len)     ! 'Avoid zeros' indicator
    logical :: Do_Calc_cext(max_f,s_i*sv_t_len)     ! 'Avoid zeros' indicator
a689 2
    real(r8), parameter :: Frq_0 = 0.0_r8     ! Fake for comp_sps_Path_frq

d780 9
a788 9
    real(rp) :: ETA_FZP(max_f,size(grids_f%values)) ! Eta_z x Eta_p * Eta_f
    real(rp) :: ETA_IWC_ZP(max_f,max(s_i,s_ts)*grids_iwc%p_len)
    real(rp) :: ETA_Mag_ZP(max_f,grids_mag%p_len)  ! Eta_z x Eta_p x Eta_x
    real(rp) :: ETA_ZP(max_f,grids_f%p_len)        ! Eta_z x Eta_p on Path X SV
    real(rp) :: ETA_ZXP_N(max_f,size(grids_n%values)) ! Eta_z x Eta_p for N
    real(rp) :: ETA_ZXP_T(max_f,s_t*sv_t_len)      ! Eta_t_z x Eta_t_p
    real(rp) :: ETA_ZXP_T_C(max_c,s_t*sv_t_len)    ! ETA_ZXP_T on coarse grid
    real(rp) :: ETA_ZXP_V(max_f,size(grids_v%values)) ! Eta_z x Eta_p for V
    real(rp) :: ETA_ZXP_W(max_f,size(grids_w%values)) ! Eta_z x Eta_p for W
d926 6
a931 6
    real(rp) :: ETA_Tscat(max_f,s_i*sv_t_len)
    real(rp) :: ETA_Tscat_ZP(max_f,s_i*sv_t_len)
    real(rp) :: ETA_Salb(max_f,s_i*sv_t_len)
    real(rp) :: ETA_Salb_ZP(max_f,s_i*sv_t_len)
    real(rp) :: ETA_Cext(max_f,s_i*sv_t_len)
    real(rp) :: ETA_Cext_ZP(max_f,s_i*sv_t_len)
d991 1
a991 1
    type (weight_ZQ_t) :: Eta_zQT(s_qtm*max_f) ! Interpolation coefficients
a3090 5
!         call comp_sps_path_frq ( grids_tscat,                &
!           & frq_0, eta_tscat_zp(1:npf,:),                    &
!           & do_calc_tscat_zp(1:npf,:), tscat_path(1:npf,:),  &
!           & eta_tscat(1:npf,:), do_calc_tscat(1:npf,:) )

a3112 5
!           call comp_sps_path_frq ( Grids_salb,               &
!             & frq_0, eta_salb_zp(1:npf,:),                   &
!             & do_calc_salb_zp(1:npf,:), salb_path(1:npf,:),  &
!             & eta_salb(1:npf,:), do_calc_salb(1:npf,:) )

a3119 5
!           call comp_sps_path_frq ( Grids_cext,               &
!             & frq_0, eta_cext_zp(1:npf,:),                   &
!             & do_calc_cext_zp(1:npf,:), cext_path(1:npf,:),  &
!             & eta_cext(1:npf,:), do_calc_cext(1:npf,:) )

d3834 1
a3834 1
      if ( .not.present(QTM) ) then
d3877 4
d3916 2
d3939 1
a3939 1
      if ( present(scat_zeta) ) then
d3964 1
a3964 1
      if ( tan_ht_s > 0.0 .and. .not. usingQTM ) call Lower_Path_Crossings ( &
d3983 1
a3983 1
      ! will be needed if .usingQTM .and. .not. Zeta_Only
d4030 1
a4030 1
      if ( .not.present(QTM) ) then
d4056 1
a4056 1
      else
d4086 2
a4087 1
        &  your_nz_zp=nz_zp, your_nnz_zp=nnz_zp )
d4089 2
a4090 7
      call spread_eta_fzp_from_eta_zp ( Grids_f, &
                                      & eta_zp(1:npf,:), do_calc_zp(:npf,:), &
                                      & eta_fzp(1:npf,:), do_calc_fzp(:npf,:) )

      ! Compute sps_path with a FAKE frequency, mainly to get the
      ! WATER (H2O) contribution for refraction calculations, but also
      ! to compute sps_path for all those with no frequency component
d4559 1
a4559 1
       "$Id: FullForwardModel_m.f90,v 2.375 2016/11/14 21:10:47 vsnyder Exp $"
d4569 4
@


2.375
log
@Change scat zeta tolerance test from relative to absolute
@
text
@d278 3
a280 1
      sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t
d473 5
a477 1
  ! and deallocated.
d480 2
a481 1
    use Comp_ETA_DoCalc_No_Frq_M, only: Comp_ETA_DoCalc_No_Frq
d686 6
a691 6
    logical :: Do_Calc_Tscat(max_f,s_i*size(grids_tmp%values)) ! 'Avoid zeros' indicator
    logical :: Do_Calc_Salb(max_f,s_i*size(grids_tmp%values))  ! 'Avoid zeros' indicator
    logical :: Do_Calc_cext(max_f,s_i*size(grids_tmp%values))  ! 'Avoid zeros' indicator
    logical :: Do_Calc_Tscat_ZP(max_f,s_i*grids_tmp%p_len)     ! 'Avoid zeros' indicator
    logical :: Do_Calc_Salb_ZP(max_f,s_i*grids_tmp%p_len)      ! 'Avoid zeros' indicator
    logical :: Do_Calc_Cext_ZP(max_f,s_i*grids_tmp%p_len)      ! 'Avoid zeros' indicator
d723 1
a723 1
    real(rp) :: dTScat_dT(s_ts*max_c,size(grids_tmp%values)) ! on coarse path w.r.t. SVE
d778 3
a780 1
    real(rp) :: DH_DT_Path(max_f,s_t*sv_t_len)     ! dH/dT on path
d876 4
a879 2
    logical :: Do_Calc_Hyd(max_f, sv_t_len)
    logical :: Do_Calc_Hyd_C(max_c, sv_t_len)  ! DO_Calc_HYD on coarse grid
d881 5
a885 3
    logical :: Do_Calc_T(max_f, sv_t_len)
    logical :: Do_Calc_T_C(max_c, sv_t_len)    ! DO_Calc_T on coarse grid
    logical :: Do_Calc_T_F(max_f, sv_t_len)    ! DO_Calc_T on fine grid
d931 6
a936 6
    real(rp) :: ETA_Tscat(max_f,s_i*size(grids_tmp%values))
    real(rp) :: ETA_Tscat_ZP(max_f,s_i*grids_tmp%p_len)
    real(rp) :: ETA_Salb(max_f,s_i*size(grids_tmp%values))
    real(rp) :: ETA_Salb_ZP(max_f,s_i*grids_tmp%p_len)
    real(rp) :: ETA_Cext(max_f,s_i*size(grids_tmp%values))
    real(rp) :: ETA_Cext_ZP(max_f,s_i*grids_tmp%p_len)
d1030 12
d1048 5
d2296 1
a2296 1
      real(rp) :: K_Temp_p(s_t*size(grids_tmp%values)) ! K_Temp convolved with P
d3033 1
a3033 1
        & firstSignal%lo, thisSideband )
d3036 2
a3037 1
! I don't know why this doesn't work
a3042 2
!c      sps_path_c(i_start:i_end,:) = sps_path(c_inds(i_start:i_end),:)
!c      sps_path_c(i_start:i_end,:) = sps_path(ngp1*i_start-ng:ngp1*i_end-ng:ngp1,:)
d3096 7
a3102 8
        call comp_sps_path_frq ( grids_tscat,                &
          & frq_0, eta_tscat_zp(1:npf,:),                    &
          & do_calc_tscat_zp(1:npf,:), tscat_path(1:npf,:),  &
          & eta_tscat(1:npf,:), do_calc_tscat(1:npf,:) )

! I don't know why this doesn't work
!           call comp_sps_path_no_frq ( Grids_tscat, eta_tscat_zp(1:npf,:), &
!             & tscat_path(1:npf,:) )
d3108 1
a3108 1
        if ( .not. cld_fine ) then                 ! interpolate onto gl grids along the LOS
d3123 7
a3129 8
          call comp_sps_path_frq ( Grids_salb,               &
            & frq_0, eta_salb_zp(1:npf,:),                   &
            & do_calc_salb_zp(1:npf,:), salb_path(1:npf,:),  &
            & eta_salb(1:npf,:), do_calc_salb(1:npf,:) )

! I don't know why this doesn't work
!             call comp_sps_path_no_frq ( Grids_salb, eta_salb_zp(1:npf,:), &
!               & salb_path(1:npf,:) )
d3135 7
a3141 8
          call comp_sps_path_frq ( Grids_cext,               &
            & frq_0, eta_cext_zp(1:npf,:),                   &
            & do_calc_cext_zp(1:npf,:), cext_path(1:npf,:),  &
            & eta_cext(1:npf,:), do_calc_cext(1:npf,:) )

! I don't know why this doesn't work
!             call comp_sps_path_no_frq ( Grids_cext,  eta_cext_zp(1:npf,:), &
!               & cext_path(1:npf,:) )
a3143 1
!c          beta_path_cloud_c(1:npc) = cext_path(c_inds,1)
a3144 1
!c          w0_path_c(1:npc) = salb_path(c_inds,1)
a3145 1
!c          tt_path_c(1:npc) = tt_path(c_inds,1)
d3888 2
d4009 3
a4011 1
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,  &
d4046 1
a4046 1
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
d4051 1
a4051 2
            &  T_Deriv_Flag = Grids_tmp%deriv_flags,                       &
            &  Z_Basis = Grids_tmp%zet_basis, Z_Ref=z_glgrid,              &
d4066 1
a4066 1
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
d4072 3
d4079 5
a4083 4
            &  dHidTlm = dh_dt_glgrid, T_Deriv_Flag = Grids_tmp%deriv_flags, &
            &  Z_Basis = Grids_tmp%zet_basis, Z_Ref=z_glgrid,                &
            &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path(1:npf,:),   &
            &  dHtdTl0 = tan_dh_dt, Eta_zQT = eta_zQT )
d4102 4
d4109 1
a4109 11
      call comp_sps_path_frq ( Grids_f,           &
        & frq_0, eta_zp(1:npf,:),                 &
        & do_calc_zp(1:npf,:), sps_path(1:npf,:), &
        & eta_fzp(1:npf,:), do_calc_fzp(:npf,:) )
!       ! Send all of eta_zp so comp_sps_path_frq_nz doesn't get an array
!       ! bounds error when it's clearing parts indexed by nz_zp.
! I don't know why this doesn't work
!       call comp_sps_path_frq_nz ( Grids_f,                         &
!         & frq_0, eta_zp, nz_zp, nnz_zp,                            &
!         & do_calc_zp(1:npf,:), sps_path(1:npf,:),                  &
!         & do_calc_fzp(1:npf,:), eta_fzp(1:npf,:), nz_fzp, nnz_fzp )
d4577 1
a4577 1
       "$Id: FullForwardModel_m.f90,v 2.374 2016/11/14 19:17:12 vsnyder Exp $"
d4587 3
@


2.374
log
@Change scat zeta tolerance to 'half the bits match'
@
text
@d2413 2
a2414 1
        ! this should hit one element exactly.
d2417 1
a2417 1
          & sqrt(max(epsilon(scat_zeta),epsilon(z_psig))) * abs(scat_zeta) ) then
d2419 3
a2421 1
          call dump ( z_psig, name="Zeta grid" )
d4553 1
a4553 1
       "$Id: FullForwardModel_m.f90,v 2.373 2016/11/12 01:42:32 vsnyder Exp $"
d4563 3
@


2.373
log
@Put the inverse of F_and_V%Vertices into QTM_Tree%Path_Vertices.  Replace
Facets argument to Metrics_3D with F_and_V.
@
text
@d2415 2
a2416 1
        if ( abs(z_psig(i_z)-scat_zeta) > 10.0 * epsilon(scat_zeta) * abs(scat_zeta) ) then
d4550 1
a4550 1
       "$Id: FullForwardModel_m.f90,v 2.372 2016/11/11 02:06:27 vsnyder Exp $"
d4560 4
@


2.372
log
@For QTM, get LOS from MIF LOS before FullForwardModelAuto.  Use it to
calculate facets and vertices on all paths.  Use maximum number of vertices
on any path as the horizontal extent for temperature-related arrays.  Pass
Vertices array to Two_D_Hydrostatic.  Don't call Two_D_Hydrostatic before
the loop over sidebands.  Pass RefGPH values as m instead of km because
Two_D_Hydrostatic does the conversion now.  Other stuff for inching toward
3D QTM model.
@
text
@d3747 2
a3748 1
      type(QTM_tree_t), intent(in), optional :: QTM ! for QTM case
d3858 7
d3903 2
a3904 2
        call metrics_3d_QTM ( path, QTM_hGrid%QTM_tree, h=h_glgrid, s=s, &
          & tangent_index=tan_ind_f, pad=NG, facets=f_and_v(ptg_i)%facets, &
d4549 1
a4549 1
       "$Id: FullForwardModel_m.f90,v 2.371 2016/11/09 00:38:10 vsnyder Exp $"
d4559 9
@


2.371
log
@Move Interpolate_MIF_to_Tan_Press to a separate model.  Get list of facets
and pass it to Metrics_3D.  Other stuff for inching toward 3D model.
@
text
@d52 1
a52 1
    use Allocate_Deallocate, only: Deallocate_Test
d62 2
a63 1
    use Intrinsic, only: Lit_Indices, L_PhiTan, L_PTan, L_TScat, L_VMR
d72 2
d90 4
d102 1
d104 1
a104 1
    type (VectorValue_T), pointer :: PhiTan ! Tangent geodAngle component of
d106 1
a106 1
    type (VectorValue_T), pointer :: PTan   ! Tangent pressure component of
d108 7
a114 1
    type (VectorValue_T), pointer :: Temp   ! Temperature component of state vector
d132 1
d162 1
a162 1
    ! This has to be done AFTER deriveFromForwardModelConfig, which is
d170 17
d215 8
d228 27
a254 6
    ! Compute some sizes
    no_sv_p_t = grids_tmp%l_p(1) ! size of temperature's horizontal grid ==
                                 ! windowFinish - windowStart + 1 if not QTM,
                                 ! else the number of vertices in the QTM
    n_t_zeta = grids_tmp%l_z(1)  ! zeta
    sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t
d256 24
a279 4
    ptan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, foundInFirst=ptan_der, config=fwdModelConf, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule )
    ptan_der = ptan_der .and. present ( jacobian )
a361 17
  ! Compute the preselected integration grid (all surfs from temperature,
  ! tangent grid and species).  Tan_Press is thrown in for free.
    if ( fwdModelConf%generateTScat ) then
      ! Make sure the TScat zeta is in the preselected grid.
      call compute_Z_PSIG ( fwdModelConf, z_psig,                  &
                          & GetQuantityForForwardModel (            &
                          &  fwdModelOut, quantityType=l_TScat,     &
                          &  signal=fwdModelConf%signals(1)%index,  &
                          &  config=fwdModelConf ) )

    else
      call compute_Z_PSIG ( fwdModelConf, z_psig )
    end if
    nlvl = size(z_psig)
    call tangent_pressures ( fwdModelConf, z_psig, no_tan_hts,   &
                           & surfaceTangentIndex, tan_press )

d411 5
a415 5
                              & ptan, phitan, temp, QTM_HGrid, UsingQTM,       &
                              & no_mol, noUsedChannels, no_sv_p_t, n_t_zeta,   &
                              & sv_t_len, nlvl, no_tan_hts,                    &
                              & surfaceTangentIndex,                           &
                              & max_c, maxVert, max_f, ptan_der,               &
d432 5
d458 3
a460 3
                             & phitan, temp, QTM_HGrid, UsingQTM, no_mol,      &
                             & noUsedChannels, no_sv_p_t, n_t_zeta,            &
                             & sv_t_len, nlvl, no_tan_hts,                     &
d487 1
a487 1
    use Geolocation_0, only: ECR_t, H_V_Geod
d507 1
a507 1
    use Path_Representation_m, only: Path_t
a509 1
    use QTM_Facets_Under_Path_m, only: QTM_Facets_Under_Path
d546 3
a548 1
    logical, intent(in) :: UsingQTM         ! Temperature and all species have QTM hGrids
a594 1
    integer, allocatable :: Facets(:)  ! Facets of QTM under path
d657 2
a674 1
    integer, allocatable :: Vertices(:) ! Vertices of QTM adjacent to path
a972 2
    type (Path_t) :: Path         ! of one LOS, to calculate facets under it

a1002 2
    type (VectorValue_T) :: Q_Incline
    type (VectorValue_T) :: Q_LOS
a1007 5
    type (ECR_T) :: LOS(2,no_tan_hts)    ! (1,:) are intersection or tangent,    
                                         ! (2,:) are unit vector along                                            
                                         ! lines-of-sight.
    real(rp) :: Incline(no_tan_hts)      ! Inclination of plane containing LOS
                                         ! and Earth center, degrees
d1103 2
d1212 14
a1225 11
    if ( temp_der ) then
      call two_d_hydrostatic ( Grids_tmp, &
        &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
        &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
        &  t_glgrid, h_glgrid, dhdz_glgrid, &
        &  dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
    else
      call two_d_hydrostatic ( Grids_tmp, &
        &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
        &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
        &  t_glgrid, h_glgrid, dhdz_glgrid )
a1268 12
        if ( usingQTM ) then ! Find facets under the path and vertices
                             ! adjacent to it, assuming all pointings are
                             ! in a vertical plane.  If pointings are not
                             ! in a vertical plane, QTM_Facets_Under_Path
                             ! should be used for each line of sight.
          call path%new_path
          path%lines(:,1) = LOS(:,1)
          call path%get_path_ready
          call QTM_Facets_Under_Path ( path, QTM_hGrid%QTM_tree, facets, &
                                     & vertices )
        end if

d1293 1
a1293 2
            call path%new_path
            path%lines(:,1) = LOS(:,ptg_i)
d1298 1
a1298 2
              &                 path=path, s=s, facets=facets,      &
              &                 vertices=vertices )
a1412 2
      call DestroyVectorQuantityValue ( Q_Incline, forWhom='Q_Incline' )
      call DestroyVectorQuantityValue ( Q_LOS, forWhom='Q_LOS' )
d1439 1
a1439 1
      use interpolate_MIF_to_tan_press_m, only: interpolate_MIF_to_tan_press
d1456 2
a1457 1
        ! Compute minor-frame tangent quantities from LOS provided by level 1
d1459 1
a1459 2
                                & Q_EarthRadC_sq, Q_Incline, Q_LOS, Q_PhiTan, &
                                & Q_TanHt )
d1544 4
d1551 4
a1554 3
          ! Create minor-frame values, all the same
          !!!!! I don't remember why we want these for the non-QTM case !!!!!
          call cloneVectorQuantity ( Q_Incline, phitan )
a1555 2

          Q_Incline%values = orbIncline%values(1,MAF)
d1557 1
a1557 1
            & orbit_plane_minor_axis_sq ( Q_Incline%values * deg2rad )
d1562 4
d1569 2
a1570 5
            & Q_EarthRadC_sq, Q_Incline, Q_LOS, Q_TanHt, &
            & earthRadC_sq,   incline,   LOS,   tanHt, tan_pt_Geod  )
          ! Q_EarthRadC_sq, Q_Incline, Q_LOS, Q_TanHt are interpolated to
          ! earthRadC_sq,   incline,   LOS,   tanHt by
          ! interpolate_MIF_to_tan_press
d3723 2
a3724 2
      & Tan_Press, Est_SCGeocAlt, Path, S, Facets, Vertices, Scat_Zeta,     &
      & Scat_Phi, Scat_Ht, Xi, Scat_Index, Scat_Tan_Ht, Forward, Rev, Which )
d3761 3
a3763 4
      integer, intent(in), optional :: Facets(:) ! Indices in QTM tree of
                                       ! facets under Path.  Present only for QTM.
      integer, intent(in), optional :: Vertices(:) ! Indices in QTM of vertices
                                       ! adjacent to Path.  Present only for QTM.
d3857 16
d3896 2
a3897 1
          & tangent_index=tan_ind_f, pad=NG, facets=facets, which=horizontal )
d4208 1
a4208 1
          call get_chi_angles ( 0.001*est_scGeocAlt, n_path_c(tan_pt_c), &
d4212 1
a4212 1
          call get_chi_angles ( 0.001*est_scGeocAlt, n_path_c(tan_pt_c), &
d4541 1
a4541 1
       "$Id: FullForwardModel_m.f90,v 2.370 2016/11/03 19:11:47 vsnyder Exp $"
d4551 4
@


2.370
log
@Inching toward 3D forward model
@
text
@a158 6
    temp => fwdModelConf%temp%qty
    
    ! Find the phiTan quantity in the state vector.  The phiTan quantity is
    ! only used to compute the instance window for the temperature quantity.
    ! If the temperature grid is QTM, phiTan isn't actually used because the
    ! entire QTM is used, instead of having an instance window.
d162 5
d179 1
a179 1
    ! Copy the mixing ratios from the state vector into Grids_f
d184 1
a184 1
    ! HGrid, or none do.  If so, find the QTM HGrid with the finest resolution
d189 3
a191 1
    no_sv_p_t = grids_tmp%l_p(1) ! phi == windowFinish - windowStart + 1
d438 1
d441 1
d525 1
d604 1
d903 2
d1202 13
d1239 2
d1245 2
a1246 1
              &                 los=LOS(:,ptg_i), s=s )
d1389 1
d3669 2
a3670 2
      & Tan_Press, Est_SCGeocAlt, LOS, S, Scat_Zeta, Scat_Phi, Scat_Ht, Xi, &
      & Scat_Index, Scat_Tan_Ht, Forward, Rev, Which )
a3672 1
      use Geolocation_0, only: ECR_t
d3697 7
a3703 4
      type(ECR_t), intent(in), optional :: LOS(2)     ! Line-of-sight
        ! from instrument to tangent, meters.  LOS(1) is (probably) the
        ! instrument.  LOS(2) is a vector in the direction from the instrument
        ! to the tangent.  Present if UsingQTM.
d3705 1
a3705 1
        ! the line of sight are MyLOS%Lines(:,1) + s%s*MyLOS%Lines(:,2).
d3707 4
d3733 1
a3733 10
      type(path_t) :: MyLOS     ! LOS from instrument to tangent, then LOS from
                                ! tangent.  MyLOS%Lines(1,1) is (probably) the
                                ! instrument.  MyLOS%Lines(2,1) is a vector in
                                ! the direction from the instrument to the
                                ! tangent.  MyLOS%Lines(1,2) is the tangent
                                ! point.  MyLOS%Lines(2,2) is a vector in the
                                ! direction of the ray after the tangent, which
                                ! is either the same as MyLOS%Lines(2,1), or the
                                ! direction of the reflected ray. Equivalent
      real(rp) :: R_EQ          ! Earth Radius at true surface
d3806 2
a3807 2
            &                    h_surf, tan_ht_s, &                  ! output
            &                    surf_height=surfaceHeight%values(1,:) ) ! optional
d3810 3
a3812 3
            &                    h_surf, tan_ht_s, &                  ! output
            &                    Tan_Press=tan_press,               & ! optional
            &                    Surf_Temp=temp%values(1,windowstart:windowfinish) )
d3815 1
a3815 1
            &                    h_surf, tan_ht_s )                   ! output
d3824 4
a3827 4
        call myLos%new_path
        myLOS%Lines(:,1) = LOS ! Line of from instrument to tangent point
        call metrics_3d_QTM ( myLOS, QTM_hGrid%QTM_tree, h=h_glgrid, s=s, &
          & tangent_index=tan_ind_f, pad=NG, which=horizontal )
d3829 1
a3829 1
        ! MyLOS%Lines(1,1) + S%s(:tan_ind_f) * MyLOS%Lines(2,1) from the
d3831 1
a3831 1
        ! MyLOS%Lines(1,2) + S%s(tan_ind_f+ngp1:) * MyLOS%Lines(2,2) from the
d3833 4
a3836 4
        ! S%Face < 0 if the intersection is outside the QTM.  S(.)%H_ind is
        ! the subscript of z_psig, and the first subscript of H_GLGrid, i.e.,
        ! the index of the zeta surface in the fine zeta grid.  If it's zero,
        ! S(.) is an Earth-reflecting point below H_GLGrid.
d4086 1
a4086 1
        &                  ptan%values(:ptan%template%nosurfs,maf)),1)
d4428 1
a4428 1
      real(r4), intent(inout) :: K_Temp_TScat(:,:,:) ! Store partials in K_Atmos_TScat(:,I_R,:)
d4440 5
a4444 5
        call one_pointing ( ptg_i, vel_rel, use_r_eq, scat_tan_phi,            &
          &                 scat_zeta=scat_zeta, scat_phi=scat_phi,            &
          &                 scat_ht=scat_ht, xi=xi, scat_index=my_scat_index,  &
          &                 scat_tan_ht=scat_tan_ht, forward=forward, rev=rev, &
          &                 which=which )
a4466 198
! =====     Private procedures     =====================================

    ! -------------------------------  Interpolate_MIF_to_Tan_Press  -----
  subroutine Interpolate_MIF_to_Tan_Press ( Nlvl, MAF, PTan, &
                              & PhiTan,  ScGeocAlt,     LOSVel, &
                              & Tan_Press, &
                              & Tan_Phi, Est_ScGeocAlt, Est_LOS_Vel, &
                              & Q_EarthRadC_sq, Q_Incline, Q_LOS, Q_TanHt, &
                              & EarthRadC,      Incline,   LOS,   TanHt, &
                              & Tan_Pt_Geod )

  ! Interpolate minor frame quantities PhiTan, ScGeocAlt, and LOSVel, at
  ! pressure levels given by PTan, to Tan_Phi, SC_Geoc_Alt and LOS Velocity, at
  ! pressure levels given by Tan_Press.  If Q_... are present, interpolate
  ! them too.

    use Geolocation_0, only: ECR_T, H_V_Geod, Lon_T
    use MLSKinds, only: RK => RP
    use MLSNumerics, only: InterpolateValues
    use Constants, only: Deg2Rad
    use VectorsModule, only: VectorValue_T

    implicit NONE

  ! Inputs
    integer, intent(in) :: NLvl                   ! Size of integration grid
    integer, intent(in) :: MAF                    ! MAF under consideration
    type(vectorValue_T), intent(in) :: PTan       ! Tangent pressure (minor
                                                  ! frame), zeta
    type(vectorValue_T), intent(in) :: PhiTan     ! Tangent geodAngle (minor
                                                  ! frame), degrees
    type(vectorValue_T), intent(in) :: ScGeocAlt  ! S/C geocentric altitude
                                                  ! (minor frame), meters
    type(vectorValue_T), intent(in) :: LOSVel     ! Line of sight velocity
                                                  ! (minor frame), m/s
    real(rk), intent(in) :: Tan_Press(:)          ! Tangent pressure levels
                                                  ! where the output quantities
                                                  ! are desired, zeta.

  ! Outputs, on pressure levels given by Tan_Press
    real(rk), intent(out) :: Tan_Phi(:)       ! Radians
    real(rk), intent(out) :: Est_ScGeocAlt(:) ! Est S/C geocentric altitude /m
    real(rk), intent(out) :: Est_LOS_Vel(:)

  ! Optional minor frame inputs, for QTM-based model
    type(vectorValue_T), intent(in), optional :: Q_EarthRadC_sq ! square of orbit-
                                                  ! plane projected ellipse, m^2
    type(vectorValue_t), intent(in), optional :: Q_Incline ! Degrees, geocentric
    type(vectorValue_t), intent(in), optional :: Q_LOS     ! LOS as C + s U
    type(vectorValue_t), intent(in), optional :: Q_TanHt   ! Geodetic height, above
                                                  ! plane-projected ellipse, meters
  ! Optional outputs, interpolated to Tan_Press, for QTM-based model
    real(rk), intent(out), optional :: EarthRadC(:) ! Plane-projected
                                                  ! minor axis**2, m**2
    real(rk), intent(out), optional :: Incline(:) ! Inclination of the plane
                                                  ! defined by LOS and the
                                                  ! Earth center, degrees.
    type(ECR_t), intent(out), optional :: LOS(:,:)! (1,:) are points on LOS,
                                                  ! (2,:) are unit directions.
    real(rk), intent(out), optional :: TanHt(:)   ! Tangent height, m
    type(H_V_Geod), intent(out), optional :: Tan_Pt_Geod(:) ! Tangent point
                                                  ! coordinates at Tan_Press
                                                  ! (lon,lat,geod ht) degrees,m

  ! Local variables
    integer :: I, IP, J, K, SUB
!   real(rk), dimension(merge(size(tan_press),0,present(tan_pt_Geod))) :: Lat, Lon
    real(rk), dimension(size(tan_press)) :: Lat, Lon
    real(rk) :: RZ ! for sorting Z_MIF
    integer :: P(ptan%template%noSurfs) ! Permutation result of sorting Z_MIF
    real(rk) :: Z_MIF(0:ptan%template%noSurfs)    ! Zetas for sorting MIFs
                                                  ! 0'th is a sentinel

    sub = size(tan_press) - nlvl ! # subsurface levels = SurfaceTangentIndex-1

    ! Use first MIF value for subsurface values
    tan_phi(1:sub) = phitan%values(1,maf)
    est_scgeocalt(1:sub) = scGeocalt%values(1,maf)
    est_los_vel(1:sub) = losvel%values(1,maf)

    ! Since the interpolateValues routine needs the OldX array to be sorted
    ! we have to sort ptan%values and re-arrange phitan%values, scgeocalt%values
    ! and losvel%values accordingly

    k = ptan%template%noSurfs

    z_mif(0) = -0.5 * huge(1.0_rk)    ! Sentinel to simplify sort. Use 0.5*Huge
                                      ! instead of Huge in case some compiler
                                      ! uses subtraction to compare.
    z_mif(1:k) = ptan%values(1:k,maf) ! Zeta
    p = [ ( i, i = 1, k ) ]           ! Initial permutation of Z_MIF

    ! Sort Z_MIF.
    ! Use insertion sort since things might be nearly in order already.
    ! Compute the permutation of Z_MIF that puts it in order, to permute
    ! other minor-frame quantities from which we interpolate.
    do i = 2, k ! Invariant: z_mif(0:i-1) are sorted.
      rz = z_mif(i)
      ip = p(i)
      if ( rz < z_mif(i-1) ) then
        j = i
        do ! Find where to insert RZ.  Make room as we go.
          z_mif(j) = z_mif(j-1)
          p(j) = p(j-1)
          j = j - 1
          if ( rz >= z_mif(j-1) ) exit ! z_mif(0) is -huge(1.0_rk)
        end do
        z_mif(j) = rz
        p(j) = ip
      end if
    end do

    ! Interpolate from minor frame zetas to pointing grid zetas.
    ! Tangent phi.  This actually isn't interesting for QTM.
    call interpolateValues ( z_mif(1:k),        phitan%values(p,maf), &
                           & tan_press(sub+1:), tan_phi(sub+1:), &
                           & METHOD = 'L', EXTRAPOLATE='C' )
    tan_phi = tan_phi * deg2rad
    ! Geocentric altitude
    call interpolateValues ( z_mif(1:k),        scgeocalt%values(p,maf), &
                           & tan_press(sub+1:), est_scgeocalt(sub+1:), &
                           & METHOD='L', EXTRAPOLATE='C' )
    ! LOS velocity
    call interpolateValues ( z_mif(1:k),        losvel%values(p,maf), &
                           & tan_press(sub+1:), est_los_vel(sub+1:), &
                           & METHOD='L', EXTRAPOLATE='C' )

    if ( present(Q_EarthRadC_sq) ) then
      earthRadC(:sub) = Q_EarthRadC_sq%values(1,maf)
      call interpolateValues ( z_mif(1:k),        Q_EarthRadC_sq%values(p,maf), &
                             & tan_press(sub+1:), earthRadC(sub+1:), &
                             & METHOD = 'L', EXTRAPOLATE='C' )
    end if

    if ( present(Q_Incline) ) then
      incline(:sub) = Q_Incline%values(1,maf)
      call interpolateValues ( z_mif(1:k),        Q_Incline%values(p,maf), &
                             & tan_press(sub+1:), incline(sub+1:), &
                             & METHOD = 'L', EXTRAPOLATE='C' )
    end if

    ! ==========================================================================
    ! !!!!! This doesn't create LOS for Earth-intersecting rays correctly. !!!!!
    ! !!!!! I'm not sure what to do here because we don't know which MIF   !!!!!
    ! !!!!! zetas are for intersecting rays.  Even if we did, we don't     !!!!!
    ! !!!!! have zetas for subsurface tangent points to which to           !!!!!
    ! !!!!! interpolate them.                                              !!!!!
    ! ==========================================================================
    if ( present(Q_LOS) ) then
      do i = 1, 2 ! 1 = C, 2 = U
        ! Use the first MAF value for subsurface values, if any.
        ! ==================================================================
        ! !!!!! This is wrong.  LOS(1,:) ought to be the vector from   !!!!!
        ! !!!!! the instrument to the intersection point, and LOS(2,:) !!!!!
        ! !!!!! ought to be the vector that's a reflection of the      !!!!!
        ! !!!!! direction to the intersection, but we don't know what  !!!!!
        ! !!!!! direction that is.  Tangent_Quantities does compute    !!!!!
        ! !!!!! MIF LOS correctly, but how do we interpolate that to   !!!!!
        ! !!!!! pointing-grid LOS without subsurface MIF zetas?        !!!!!
        ! !!!!! Eventually, we could do the radiative transfer on MIF  !!!!!
        ! !!!!! rays instead of aiming at an hypothetical subsurface   !!!!!
        ! !!!!! tangent pressure.  This would affect many places,      !!!!!
        ! !!!!! setting up convolution.                                !!!!!
        ! ==================================================================
        LOS(i,:sub) = ECR_t(Q_LOS%value3(3*i-2:3*i,1,maf))
        ! Now interpolate rays that don't intersect the surface from MIF zetas
        ! to pointing-grid zetas.
        do j = 1, 3 ! XYZ
          call interpolateValues ( z_mif(1:k),        Q_LOS%value3(3*i-3+j,p,maf), &
                                 & tan_press(sub+1:), LOS(i,sub+1:)%xyz(j), &
                                 & METHOD = 'L', EXTRAPOLATE='C' )
        end do
      end do
    end if

    if ( present(Q_TanHt) ) then
      tanHt(:sub) = Q_TanHt%values(1,maf)
      call interpolateValues ( z_mif(1:k),        Q_TanHt%values(p,maf), &
                             & tan_press(sub+1:), tanHt(sub+1:), &
                             & METHOD = 'L', EXTRAPOLATE='C' )
      if ( present(tan_pt_Geod) ) then
        call interpolateValues ( z_mif(1:k),        phitan%template%geodLat(p,maf), &
                               & tan_press(sub+1:), lat(sub+1:), &
                               & METHOD = 'L', EXTRAPOLATE='C' )
        call interpolateValues ( z_mif(1:k),        phitan%template%lon(p,maf), &
                               & tan_press(sub+1:), lon(sub+1:), &
                               & METHOD = 'L', EXTRAPOLATE='C' )
        ! Subsurface values all the same.  These might also be changed to MIF
        ! some day.
        tan_pt_geod(:sub) = h_v_geod ( lon_t(lon(1)), lat(1), tanHt(1) )
        do i = 1, nlvl
          tan_pt_geod(sub+i) = h_v_geod ( lon_t(lon(sub+i)), lat(sub+i), tanHt(sub+i) )
        end do
      end if
    end if

  end subroutine Interpolate_MIF_to_Tan_Press

d4471 1
a4471 1
       "$Id: FullForwardModel_m.f90,v 2.369 2016/10/25 22:27:39 vsnyder Exp $"
d4481 3
@


2.369
log
@Inching toward 3D QTM
@
text
@d1128 1
a1128 1
    ! Temperature's windowStart:windowFinish are correct here.
d1134 8
d1146 2
a1147 2
        &  t_glgrid, h_glgrid, &
        &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
d3654 1
a3654 1
      use Metrics_3D_m, only: Metrics_3D_QTM
d3657 1
d3679 2
a3680 1
        ! the line of sight are MyLOS(:,1) + s%s*MyLOS(:,2).  Present if UsingQTM.
d3703 10
a3712 10
      type(ECR_t) :: MyLOS(2,2) ! LOS from instrument to tangent, then LOS from
                                ! tangent.  MyLOS(1,1) is (probably) the
                                ! instrument.  MyLOS(2,1) is a vector in the
                                ! direction from the instrument to the tangent. 
                                ! MyLOS(1,2) is the tangent point.  MyLOS(2,2)
                                ! is a vector in the direction of the ray after
                                ! the tangent, which is either the same as
                                ! MyLOS(2,1), or the direction of the reflected
                                ! ray.
      real(rp) :: R_EQ          ! Equivalent Earth Radius at true surface
d3803 2
a3804 1
        myLOS(:,1) = LOS ! Line of from instrument to tangent point
d3806 1
a3806 1
          & tangent_index=tan_ind_f, pad=NG, zeta_only=zeta_only )
d3808 8
a3815 8
        ! myLos(1,1) + S%s(:tan_ind_f) * myLos(2,1) from the instrument to
        ! the tangent, and
        ! myLos(1,2) + S%s(tan_ind_f+ngp1:) * myLos(2,2) from the tangent
        ! onward. All values of |S%face| should be Top_Face, with S%Face < 0
        ! if the intersection is outside the QTM.  S(.)%H_ind is the subscript
        ! of z_psig, and the first subscript of H_GLGrid, i.e., the index of the
        ! zeta surface in the fine zeta grid.  If it's zero, S(.) is an Earth-
        ! reflecting point below H_GLGrid.
d4648 1
a4648 1
       "$Id: FullForwardModel_m.f90,v 2.368 2016/10/24 22:20:32 vsnyder Exp $"
d4658 3
@


2.368
log
@A bunch of stuff for QTM etc.
@
text
@d439 1
a439 1
    use QTM_Interpolation_Weights_3D_m, only: S_QTM_t
d908 3
d3932 8
a3939 10
          call more_metrics_3d ( S, tan_pt_f, t_glgrid, dhdz_glgrid, &
            & t_path(1:npf), dhdz_path(1:npf),                       &
                        !  Stuff for temperature derivatives:
            &  ddHidHidTl0 = ddhidhidtl0, dHidTlm = dh_dt_glgrid,          &
            &  T_Deriv_Flag = Grids_tmp%deriv_flags,                       &
            &  Z_Basis = Grids_tmp%zet_basis, Z_Ref=z_glgrid,              &
            &  ddHtdHtdTl0 = tan_d2h_dhdt, dHitdTlm = dh_dt_path(1:npf,:), &
            &  dHtdTl0 = tan_dh_dt, Do_Calc_Hyd = do_calc_hyd(1:npf,:),    &
            &  Do_Calc_T = do_calc_t, Eta_zxp = eta_zxp_t,                 &
            &  NZ_zxp = nz_zxp_t, NNZ_zxp = nnz_zxp_t )
d4637 1
a4637 1
       "$Id: FullForwardModel_m.f90,v 2.367 2016/06/03 23:47:23 vsnyder Exp $"
d4647 3
@


2.367
log
@Make Tan_Press allocatable instead of a pointer.  Provide minor-frame
quantities for "orbit" inclination, minor axis length, phiTan, and tangent
height if the hGrid for temperature is QTM.  Ensure either temperature and
all molecules are QTM, or none of them are.
@
text
@d34 7
d53 1
a54 1
    use Constants, only: Rad2Deg
a55 1
    use ForwardModelGeometry, only: Azimuth_Tol, Viewing_Azimuth
d58 1
d61 2
a62 2
    use Intrinsic, only: Lit_Indices, L_GeodAltitude, L_MagneticField, &
      & L_PhiTan, L_PTan, L_TScat, L_VMR, L_Zeta
a70 1
    use Output_m, only: Output
a83 5
    real(rp) :: Azimuth               ! Angle (degrees) between the normal to
                                      ! the plane defined by the spacecraft
                                      ! position and velocity vectors, and the
                                      ! plane defined by the spacecraft
                                      ! position and PTan vectors.
d94 1
a95 1
    type (VectorValue_T), pointer :: MagField ! Magnetic field
d103 10
d114 2
a116 1
    integer :: No_sv_p_T        ! number of phi basis for temperature
a117 4
    integer :: Sv_T_len         ! Number of t_phi*t_zeta in the window
    integer :: Nlvl             ! Number of levels in coarse zeta grid
    integer :: NO_TAN_HTS       ! Number of tangent heights
    integer :: Print_Mag        ! For debugging output
d120 6
a125 14
    integer :: MaxVert          ! Number of points in gl-refined vertical grid:
                                ! (NLVL-1) * (NG+1) + 1, i.e., 1 + NG
                                ! per level, except the last,
                                ! where there's no GL space.
    integer :: Max_C            ! Length of longest possible coarse path,
                                ! Z_PSIG & Min Zeta & surface Zeta
    integer :: Max_F            ! Length of longest possible fine path
                                ! (all npf<max_f)
    integer :: Me = -1          ! String index for trace
    integer :: S_A  ! Multiplier for atmos derivative sizes, 0 or 1
    integer :: S_H  ! Multiplier for atmos second derivative sizes, 0 or 1
    integer :: S_I  ! Multiplier for ice/cloud sizes, 0 or 1
    integer :: S_LC ! Multiplier for line center deriv sizes, 0 or 1
    integer :: S_LW ! Multiplier for line width deriv sizes, 0 or 1
d127 7
a133 5
    integer :: S_P  ! Multiplier for polarized sizes, 0 or 1
    integer :: S_T  ! Multiplier for temp derivative sizes, 0 or 1
    integer :: S_TD ! Multiplier for temp dependence deriv sizes, 0 or 1
    integer :: S_TG ! Multiplier for TScat generation sizes, 0 or 1
    integer :: S_TS ! Multiplier for using TScat tables, 0 or 1
d155 4
a158 6
    ! Find temperature and phiTan quantities in the state vector.  Here, the
    ! temperature quantity is just used to set the sizes of some arrays, but
    ! it's passed along to FullForwardModelAuto.  The phiTan quantity is only
    ! used to compute the instance window for the temperature quantity.  If the
    ! temperature grid is QTM, phiTan isn't actually used because the entire
    ! QTM is used, instead of having an instance window.
d160 5
a168 3
    no_sv_p_t = grids_tmp%l_p(1) ! phi == windowFinish - windowStart + 1
    n_t_zeta = grids_tmp%l_z(1)  ! zeta
    sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t
d170 2
a173 3

    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f )

d180 14
d264 2
a265 26
    if ( FwdModelConf%polarized ) then

      ! Compute the viewing azimuth angle
      azimuth = viewing_azimuth ( FwdModelIn, FwdModelExtra, FwdModelConf, &
                                & MIF=1, MAF=fmstat%maf )
      magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,          &
        & quantityType=l_magneticField, config=fwdModelConf )
      if ( .not. (magField%template%stacked .and. magField%template%coherent) ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Magnetic field is not stacked and coherent' )
      if ( magField%template%verticalCoordinate /= l_geodAltitude .and. &
           magField%template%verticalCoordinate /= l_zeta ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Magnetic field vertical coordinate is not geodetic altitude or zeta' )
      call load_one_item_grid ( grids_mag, magField, fmStat%maf, phitan, &
        & fwdModelConf, .false., across=abs(azimuth) > azimuth_tol )
      print_mag = switchDetail(switches, 'MagGrid')
      if ( print_mag > -1 ) then
        if ( switchDetail(switches, 'Azimuth') < 0 ) & ! viewing_azimuth didn't print it
          & call output ( rad2deg*azimuth, before='Azimuth ', &
            & after=' degrees', advance='yes' )
        call dump ( grids_mag, 'Grids_Mag', print_mag )
      end if
    else
      call emptyGrids_t ( grids_mag ) ! Allocate components with zero size
    end if
d297 1
a297 1
    max_c = 2*nlvl + max_new + 1 ! Maximum coarse path length
d299 9
a307 1
    max_f = 2 * maxVert + ngp1 ! Maximum fine path, including minimum Zeta panel
d333 1
d346 1
a346 1
                              & ptan, phitan, temp,                            &
d352 1
a352 1
                              & s_i, s_tg, s_ts,                               &
d388 3
a390 2
                             & phitan, temp, no_mol, noUsedChannels,           &
                             & no_sv_p_t, n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
d394 1
a394 1
                             & s_i, s_tg, s_ts,                                &
d417 1
a417 1
    use Geolocation_0, only: ECR_T
d422 2
a423 1
    use Intrinsic, only: L_A, L_GeocAltitude, L_GeodAltitude, L_QTM, &
d428 1
a428 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d439 1
d444 2
a445 1
    use TScat_Support_M, ONLY: TScat_Gen_Setup
d474 2
d503 1
a535 3
    integer :: Min_Index          ! If > 0, P_Path(min_index) <= Min_Phi <=
                                  ! P_Path(min_index+1), else min zeta is at
                                  ! or too close to the tangent
a582 7
    integer :: Print_TScat_Deriv  ! For debugging, Temp deriv, from -Sdtsct
    integer :: Print_TScat_Detail ! For debugging, from -Spsct
    logical :: UsingQTM           ! Temperature and all species have the same
                                  ! QTM hGrid

    character(len=*), parameter :: TScat_Detail_Heading = &
      & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi Which Rev Fwd"
d654 1
a654 1
    real(rp) :: Tan_dH_dT(s_t*sv_t_len) ! dH/dT at Tangent
d704 1
a704 1
    real(rp) :: ETA_ZP(max_f,grids_f%p_len)        ! Eta_z x Eta_p
d715 4
d767 2
a768 2
    complex(rp) :: Prod_Pol(2,2,s_p*max_c)   ! P in Michael's notes
    complex(rp) :: Tau_Pol(2,2,s_p*max_c)    ! Tau in Michael's notes
d770 4
a773 4
    real(rp) :: Est_ScGeocAlt(no_tan_hts) ! Est S/C geocentric altitude /m
    real(rp) :: Est_LOS_Vel(no_tan_hts)   ! Est S/C line-of-sight velocity M/S
    real(rp) :: Tan_D2H_DHDT(s_t*sv_t_len)
    real(rp) :: Tan_Phi(no_tan_hts)
d832 1
a832 1
    real(rp), pointer :: RadV(:)         ! Radiances for 1 pointing on
d854 1
a854 1
    real(rp), pointer :: DAlpha_DT_Path_C(:,:) ! (max_c,max_frq)
d856 1
a856 1
    real(rp), pointer :: Beta_Path_C(:,:,:)! (max_c,no_mol,max_frq)
d858 8
a865 8
    real(rp), pointer :: INC_RAD_Path(:,:) ! Incremental radiance along the path
    real(rp), pointer :: K_Atmos_FRQ(:,:)  ! dI/dVMR, ptg.frq X vmr-SV
    real(rp), pointer :: K_Spect_DN_FRQ(:,:) ! ****
    real(rp), pointer :: K_Spect_DV_FRQ(:,:) ! ****
    real(rp), pointer :: K_Spect_DW_FRQ(:,:) ! ****
    real(rp), pointer :: K_Temp_FRQ(:,:)   ! dI/dT, ptg.frq X T-SV
    real(rp), pointer :: T_SCRIPT_LBL(:,:) ! Delta_B in some notes, Path X Frq
    real(rp), pointer :: H_Atmos_FRQ(:,:,:)  ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr
d884 3
d895 2
a896 2
    type (Grids_T) :: Grids_Salb ! All the coordinates for single scattering albedo
    type (Grids_T) :: Grids_Cext ! All the coordinates for cloud extinction
d902 3
a904 1
    type (Slabs_Struct), dimension(:,:), pointer :: GL_SLABS ! Freq. indep. stuff
d931 3
a933 5
    ! minor-frame tangent quantities calculated from LOS, for QTM
    type (ECR_T) :: LOS(2,2,no_tan_hts)  ! Lines-of-sight, (1:2,1,:) are before
                                         ! intersection or tangent, (1:2,2,:) are
                                         ! after.  (1,:,:) are intersection or
                                         ! tangent, (2,:,:) are unit vector along
a947 1
!   Print *, '** Enter ForwardModel, MAF =',fmstat%maf   ! ** ZEBUG
d1037 3
a1039 3
    nullify ( dAlpha_dT_path_c, beta_path_c, frequencies, inc_rad_path, &
      & k_atmos_frq, k_spect_dn_frq, k_spect_dv_frq, k_spect_dw_frq,    &
      & k_temp_frq, h_atmos_frq, RadV, t_script_lbl )
d1103 2
a1104 2
      call convolution_setup ( DH_DZ_OUT, DX_DH_OUT, DXDT_Surface, &
                             & DXDT_TAN, Q_EarthRadC_sq, Est_ScGeocAlt, &
d1108 1
a1108 1
                             & OrbIncline, PhiTan, PTan, RefGPH, SCGeocAlt, &
d1117 3
a1124 3
    call Trace_Begin ( me_Hydro, 'ForwardModel.Hydrostatic', &
      & cond=toggle(emit) .and. levels(emit) > 0 )

d1128 2
d1135 1
a1135 1
        &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
d1141 1
a1141 2
        &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
        &  dhdz_glgrid )
d1146 2
a1149 2

    ! Loop over sidebands ----------------------------------------------------
d1195 7
d1203 11
a1213 2
          call one_pointing ( ptg_i, vel_rel, tan_phi(ptg_i), &
            &                 tan_press(ptg_i), est_scGeocAlt(ptg_i) )
d1286 4
a1289 12
      if ( FwdModelConf%do_conv ) then
        print *, 'Convolution: ON'
      else
        print *, 'Convolution: OFF'
      end if

      if ( FwdModelConf%do_freq_avg .and. any(fwdModelConf%anyLBL) ) then
        print *, 'Frequency Averaging: ON'
      else
        print *, 'Frequency Averaging: OFF'
!       print '(a,f12.4,a)', ' (All computations done at Frq =',Frequencies(1), ')'
      end if
d1297 4
a1300 12
        if ( .not. fwdModelConf%GenerateTScat ) then
          thisRadiance =>  &
            GetQuantityForForwardModel (fwdModelOut, quantityType=l_radiance, &
            & signal=fwdModelConf%signals(channels(i)%signal)%index, &
            & sideband=sideband, config=fwdModelConf )
        else
          thisRadiance =>  &
            GetQuantityForForwardModel (fwdModelOut, quantityType=l_tscat, &
            & signal=fwdModelConf%signals(channels(i)%signal)%index, &
            & sideband=sideband, config=fwdModelConf )
        end if
        j = thisRadiance%template%noChans
d1302 6
a1307 2
        print "( 4(2x, 1pg15.8) )", &
          & thisRadiance%values(channel:channel+j*(k-1):j, maf)
d1341 1
a1341 1
    ! in the message
d1355 3
a1357 3
      use Intrinsic, only: L_EarthRefl, L_ECRtoFOV, L_GPH, L_LOSVel,  &
        & L_SurfaceHeight, L_OrbitInclination, L_REFGPH, L_ScGeocAlt, &
        & L_SpaceRadiance
a1361 2
      logical :: QTM_fail
      logical :: SpsQTM   ! Species being examined in Grids_F has QTM hGrid
a1366 1
      QTM_fail = .false. ! Assume no errors
d1368 2
a1369 25
      ! If temperature is QTM, verify that all the species hGrids are the
      ! same QTM, and if not, verify that no species hGrid is QTM.
      usingQTM = associated(temp%template%the_hGrid)
      if ( usingQTM ) usingQTM = temp%template%the_hGrid%type == l_QTM
      do k = 1, size(grids_f%qtyStuff)
        spsQTM = associated(grids_f%qtyStuff(k)%qty%template%the_hGrid)
        if ( spsQTM ) &
          & spsQTM = grids_f%qtyStuff(k)%qty%template%the_hGrid%type == l_QTM
        if ( spsQTM ) then
          if ( .not. usingQTM ) then
            call MLSMessage ( MLSMSG_Warning, moduleName, &
              & 'Species %s has QTM hGrid, but temperature does not.', &
              & grids_f%qtyStuff(k)%qty%template%the_hGrid%name )
            QTM_fail = .true.
          end if
          spsQTM = grids_f%qtyStuff(k)%qty%template%the_hGrid%name == &
                   temp%template%the_hGrid%name
        end if
        if ( usingQTM .and. .not. spsQTM ) then
          call MLSMessage ( MLSMSG_Warning, moduleName, &
            & 'Quantity %s does not have same QTM hGrid as temperature.', &
            & grids_f%qtyStuff(k)%qty%template%the_hGrid%name )
          QTM_fail = .true.
        end if
      end do
d1371 1
a1371 3
        if ( QTM_fail ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Quantities do not have identical QTM hGrids.' )
        ! Compute tangent quantities from LOS provided by level 1
a1448 2
      MAF = fmStat%maf

d1456 1
a1456 1
      ! interpolate tan_phi, scgeocalt and losvel from MIFs to pointings
d1459 5
a1463 3
          call estimate_tan_phi ( nlvl, maf, phitan, ptan, &
                                & scgeocalt, losvel, tan_press, &
                                & tan_phi, est_scgeocalt, est_los_vel )
d1466 1
a1466 1
          ! Create minor-frame values, all the same
d1474 5
a1478 5
          call estimate_tan_phi ( nlvl, maf, phitan, ptan, &
                                & scgeocalt, losvel, tan_press, &
                                & tan_phi, est_scgeocalt, est_los_vel, &
                                & Q_EarthRadC_sq, Q_Incline, Q_LOS, Q_TanHt, &
                                & earthRadC_sq,   incline,   LOS,   tanHt  )
d1480 2
a1481 1
          ! earthRadC_sq,   incline,   LOS,   tanHt by Estimate_Tan_Phi
d1483 1
a1483 1
      else
a1485 1

a1497 1

d2000 3
a2002 3
      integer :: I, K, PTG_I, ShapeInd
      integer :: MAXNOPTGFREQS     ! Used for sizing arrays
      integer :: MINSUPERSET       ! Min. value of superset > 0
d2004 1
a2004 1
      integer :: SUPERSET          ! Output from AreSignalsSuperset
d2157 1
a2157 1
      USE LOAD_SPS_DATA_M, ONLY: FINDINGRID
d2820 1
a2820 1
      USE L2PC_m, ONLY: L2PC_T
d2829 1
a2829 1
      USE TSCAT_SUPPORT_m, ONLY: GET_DB_DT, GET_TSCAT, GET_TSCAT_SETUP, &
d3633 3
a3635 3
    subroutine One_Pointing ( Ptg_i, Vel_Rel, Tan_Phi, Tan_Press, Est_SCGeocAlt, &
      & Use_R_Eq, Scat_Zeta, Scat_Phi, Scat_Ht, Xi, Scat_Index, Scat_Tan_Ht,     &
      & Forward, Rev, Which )
d3637 2
a3638 2
      use Add_Points_M, only: Add_Points
      use Constants, only: PI
d3642 4
a3645 3
      use Metrics_M, only: Height_Metrics, More_Metrics, More_Points, &
        & Tangent_Metrics
      use Min_Zeta_M, only: Get_Min_Zeta
d3647 1
d3651 1
d3655 4
a3658 1
      real(rp), intent(in) :: Tan_Phi  ! orbit geodetic angle at tangent, radians
d3662 6
a3668 1
      real(rp), intent(in), optional :: Use_R_Eq    ! instead of at tangent
a3687 1
      character(max(128,len(TScat_Detail_Heading)+10)) :: Line    ! Of output
d3690 9
a3698 1
      logical :: MyRev          ! "Reverse the integration path"
a3700 3
      real(rp) :: Scat_D1, Scat_D2   ! To compute scat_index
      integer :: Scat_Temp           ! To compute scat_index
      real(rp), parameter :: Scat_Tol = 1.0 ! max miss of scattering pt, (km/h)**2
d3714 2
a3715 1
      ! Compute where the tangent is.
d3726 1
a3726 1
      ! This is not pretty but we need some coarse path extraction indices
a3727 2
!c      c_inds = (/(i*Ngp1-Ng,i=1,tan_pt_c),((i-1)*Ngp1-Ng+ngp1,i=tan_pt_c+1,npc)/)
!c      c_inds = (/(i*Ngp1-Ng,i=1,tan_pt_c),((i-1)*Ngp1-Ng+1,i=tan_pt_c+1,npc)/)
d3729 1
a3729 1
      ! And some fine path extraction indices
d3733 1
d3739 63
a3801 16
      if ( associated(surfaceHeight) ) then
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
          &                    h_glgrid, tan_ind_f,               & ! in
          &                    h_surf, tan_ht_s,                  & ! output
          &                    surf_height=surfaceHeight%values(1,:) ) ! optional
      else if ( ptg_i < surfaceTangentIndex ) then
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
          &                    h_glgrid, tan_ind_f,               & ! in
          &                    h_surf, tan_ht_s,                  & ! output
          &                    z_ref=z_psig(1),                   & ! optional
          &                    Tan_Press=tan_press,               & ! optional
          &                    Surf_Temp=temp%values(1,windowstart:windowfinish) )
      else
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis,      &
          &                    h_glgrid, tan_ind_f,               & ! in
          &                    h_surf, tan_ht_s )                   ! output
a3803 2
      if ( present(scat_tan_ht) ) tan_ht_s = scat_tan_ht + h_surf

d3806 1
a3806 1
      ! zeta at the reflection point so we don't need to recompute
a3809 17
      ! Compute equivalent earth radius r_eq at tan_phi.

      if ( present(use_r_eq) ) then
        r_eq = use_r_eq
      else
        !!!!!  QTM needs earthradc_sq(:)  !!!!!
        r_eq = get_r_eq ( tan_phi, earthradc_sq(1) ) ! Geometric earth radius
      end if

      ! Get H_Path and Phi_Path on the fine grid.
      call Height_Metrics ( tan_phi, tan_ind_f, Grids_tmp%phi_basis, & ! in
        &  h_glgrid, h_surf, tan_ht_s, z_glgrid(:nz_if), r_eq,       & ! in
        &  req_s, vert_inds(1:npf), h_path(1:npf), phi_path(1:npf),  & ! out
        &  forward=forward )                                           ! opt
      tan_ht = tan_ht_s + req_s
      phi_path_c => phi_path(1:npf:ngp1)

d3812 7
a3818 77
        scat_index = 0
        scat_d2 = huge(1.0_rp)
        do scat_temp = 1, npc
          scat_d1 = sin(phi_path_c(scat_temp)-scat_phi)**2 + &
                  &  (h_path(scat_temp*ngp1-ng)/scat_ht-1.0_rp)**2
          if ( scat_d1 < scat_d2 ) then
            scat_index = scat_temp
            scat_d2 = scat_d1
          end if
        end do

        if ( present(rev) ) then
          myRev = rev
        else
          myRev = (xi > -pi .and. xi < 0.0) .neqv. (scat_index < tan_pt_c)
        end if
        if ( myRev ) then
          ! Ray from below the scattering point won't see the tangent point, or
          ! Ray from above the scattering point will see the tangent point, so
          ! reverse the path
          z_coarse(:npc) = z_coarse(npc:1:-1)
          vert_inds(:npf) = vert_inds(npf:1:-1)
          h_path(:npf) = h_path(npf:1:-1)
          phi_path(:npf) = phi_path(npf:1:-1)
          scat_index = npc - scat_index + 1
          tan_pt_c = npc - tan_pt_c ! The first one, not the same one
          tan_pt_f = ngp1 * tan_pt_c - ng
        end if
        if ( scat_index == tan_pt_c + 1 ) scat_index = tan_pt_c

        ! Check that we hit it well enough.
        if ( abs(z_coarse(scat_index)-scat_zeta) > 0.05 .or. &
          &  scat_d2 > scat_tol .or. &
          ! or print details if requested
          &  print_TScat_detail > -1 ) then
          if ( print_TScat_detail /= 0 .or. print_TScat_Deriv > -1 .or. &
            & print_incopt .or. print_incrad .or. print_path > -1 ) &
            & call output ( TScat_Detail_Heading, advance="yes" )
          write ( line, "(f7.2,f12.4,f9.3,f11.2,f10.6,f9.2,f11.4,f8.2,i4,f8.2,i4,4x,L1)" ) &
            & rad2deg*scat_phi, scat_ht, scat_zeta, rad2deg*xi, sqrt(scat_d2), & ! km/ht, not (km/ht)**2
            & rad2deg*tan_phi, tan_ht, rad2deg*phi_path(1), scat_index*ngp1-ng, &
            & rad2deg*phi_path_c(scat_index), which, myRev
          if ( present(forward) ) then; line = trim(line) // merge("   T", "   F", forward)
          else ; line = trim(line) // "   T"
          end if
          if ( abs(z_coarse(scat_index)-scat_zeta) > 0.05 .or. &
            &  scat_d2 > scat_tol ) then
            ! Are we trying to trace an Earth-intersecting ray, for TScat
            ! generation, but the detailed Metrics calculation discovered
            ! it's not one?
            line(len(TScat_detail_heading)+1:) = "> abandoned"
            call output ( trim(line), advance="yes" ) ! Too far away from scattering point
            if ( scat_ht <= tan_ht .or. which > 0 .or. print_TScat_detail > -1 ) then
              call output ( req_s, before="Req_s = " )
              call output ( mod(phitan%values(FwdModelConf%TScatMIF,MAF),360.0_r8), &
                & before=", Phi_ref = ", advance="yes" )
              call dump ( z_coarse(:npc), name="Z_Coarse" )
              call dump ( rad2deg*phi_path_c, name="Phi_Path", format="(f14.8)" )
              call dump ( h_path(1:npf:ngp1), name="H_Path", format="(f14.6)" )
            end if
            if ( scat_ht <= tan_ht .or. which > 0 ) &
              call MLSMessage ( merge(MLSMSG_Warning,MLSMSG_Error,switchDetail(switches,'igsc')>0), &
                & moduleName, 'Scattering point appears not to be in path' )
            scat_index = -1
          else
            call output ( trim(line) // " <", advance="yes" ) ! Close enough
            if ( print_TScat_detail > 0 ) then
              call output ( tan_pt_c, before='Tan_Pt_C = ' )
              call dump ( rad2deg*phi_path_c(:scat_index), name=', Phi_Path_C' )
!c              call dump ( h_path(:scat_index*ngp1-ng:ngp1), name='H_Path_C' )
              associate ( h_path_x => h_path(1:npf:ngp1) )
                call dump ( h_path_x(:scat_index), name='H_Path_C' )
              end associate
              call dump ( z_coarse(:scat_index), name='Z_Coarse' )
            end if
          end if
        end if
d3836 6
a3841 24
      if ( tan_ht_s > 0.0 ) then
        call more_points ( tan_phi, tan_ind_f, Grids_tmp%phi_basis,   &
        &   z_glgrid, h_glgrid, req_s, h_surf, tan_ht_s, phi_path(1:npf), & ! in
        &   more_z_path, more_h_path, more_phi_path, n_more )
        if ( n_more > 0 .and. .not. do_more_points ) then
          if ( print_more_points ) then
            call output ( n_more, before='Want to add ', after=' more points', advance='yes' )
            call dump ( more_h_path(:n_more), name='more_h_path', format='(f14.7)' )
            call dump ( more_phi_path(:n_more), name='more_phi_path', format='(f14.8)' )
            call dump ( more_z_path(:n_more), name='more_z_path' )
            call output ( ptg_i, before='tan_phi(' )
            call output ( tan_phi, before=') = ', format='(f12.6)' )
            call output ( tan_ind_f, before=', tan_ind_f = ' )
            call output ( tan_pt_f, before=', tan_pt_f = ' )
            call output ( req_s, before=', req_s = ', format='(f12.6)', advance='yes' )
            call output ( h_surf, before='h_surf = ', format='(f12.6)' )
            call output ( tan_ht_s, before=', tan_ht_s = ', format='(f12.6)', advance='yes' )
            call dump ( Grids_tmp%phi_basis, name='phi_basis', format='(f14.8)' )
            call dump ( h_glgrid, name='h_glgrid', format='(f14.7)' )
            call dump ( h_path(1:npf), name='h_path', format='(f14.7)' )
            call dump ( phi_path(1:npf), name='phi_path', format='(f14.8)' )
          end if
          n_more = 0 !??? Code appears not to work yet, so turn it off
        end if
d3843 1
a3843 45
        ! Get minimum zeta on the path
        call Get_Min_Zeta ( Grids_tmp%phi_basis, h_glgrid(tan_ind_f,:), &
                          & t_glgrid(tan_ind_f,:), z_glgrid(tan_ind_f), &
                          & phi_path, tan_ind_f, tan_ht,                &
                          & min_zeta, min_phi, min_index )

        ! Add minimum zeta to the path
        if ( min_index > 0 ) then ! minimum zeta not at or near tangent point
          if ( do_zmin ) then
            n_more = n_more + 1
            more_z_path(n_more) = min_zeta
            more_phi_path(n_more) = min_phi
            more_h_path(n_more) = tan_ht/cos(min_phi)
          else
            if ( switchDetail(switches,'zdet') > -1 ) then
              call output ( min_index, before='Want to add minimum zeta at ' )
              call output ( tan_ind_f, before=' (tan_ind_f = ' )
              call output ( min_phi, before=') where phi = ' )
              call output ( min_zeta, before=' and zeta = ', advance='yes' )
              call dump ( Grids_tmp%phi_basis, name='phi_basis' )
              call dump ( h_glgrid(tan_ind_f,:), 'h_glgrid' )
              call dump ( t_glgrid(tan_ind_f,:), 't_glgrid' )
              call dump ( phi_path, name='phi_path' )
              call output ( z_glgrid(tan_ind_f), before='z_glgrid = ' )
              call output ( tan_ind_f, before=', tan_ind_f =' )
              call output ( tan_ht, before=', tan_ht = ', advance='yes' )
            end if
          end if
        else
          min_index = 0
        end if

        call add_points ( more_h_path(:n_more), more_phi_path(:n_more),     &
          &               more_z_path(:n_more), min_index, z_glgrid, nz_if, &
          &               z_coarse, h_path, phi_path, vert_inds,            &
          &               npc, npf, tan_pt_c, tan_pt_f )

        if ( print_more_points .and. n_more > 0 ) then
          call dump ( Grids_tmp%phi_basis, name='phi_basis' )
          call dump ( h_path(1:npf), name='h_path' )
          call dump ( phi_path(1:npf), name='phi_path' )
        end if
      end if

      ! Compute Gauss Legendre (GL) grid ----------------------------------
d3846 4
a3849 2
      p_path(tan_pt_f+1:tan_pt_f+ng) = 0.0 ! So they're not undefined
      ! z_path and t_path all the same within the zero-thickness tangent layer
d3854 2
a3855 1
      ! because the GL abscissae are on -1..1.
d3863 1
a3863 1
      if ( FwdModelConf%refract ) then
d3865 2
a3866 1
        ! calculate the refractive index
d3878 1
a3878 1
            &  nz_zp=nz_zp, nnz_zp=nnz_zp )
d3900 27
a3926 21
      if ( temp_der ) then
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
          &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
          &  t_path(1:npf), dhdz_path(1:npf),                            &
          !  Stuff for temperature derivatives:
          &  DDHIDHIDTL0 = ddhidhidtl0, DHIDTLM = dh_dt_glgrid,          &
          &  T_DERIV_FLAG = Grids_tmp%deriv_flags,                       &
          &  Z_BASIS = Grids_tmp%zet_basis, Z_REF=z_glgrid,              &
          &  DDHTDHTDTL0 = tan_d2h_dhdt, DHITDTLM = dh_dt_path(1:npf,:), &
          &  DHTDTL0 = tan_dh_dt, DO_CALC_HYD = do_calc_hyd(1:npf,:),    &
          &  DO_CALC_T = do_calc_t, ETA_ZXP = eta_zxp_t,                 &
          &  NZ_ZXP = nz_zxp_t, NNZ_ZXP = nnz_zxp_t )
        dh_dt_path_c(1:npc,:) = dh_dt_path(1:npf:ngp1,:)
        if ( print_tscat_detail > 0 ) &
           & call dump ( dh_dt_path_c(:npc,:), name='dh_dT_path_c' )
        do_calc_hyd(:i_start*ngp1-ngp1,:) = .false.
        do_calc_hyd(i_end*ngp1-ng+1:npf,:) = .false.
        do_calc_hyd_c(1:npc,:) = do_calc_hyd(1:npf:ngp1,:)
        do_calc_t_c(1:npc,:) = do_calc_t(1:npf:ngp1,:)
        eta_zxp_t_c(1:npc,:) = eta_zxp_t(1:npf:ngp1,:)
        t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
d3928 15
a3942 3
        call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
          &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
          &  t_path(1:npf), dhdz_path(1:npf) )
d3955 1
a3955 1
        &  nz_zp=nz_zp, nnz_zp=nnz_zp )
d4407 5
a4411 5
      call one_pointing ( ptg_i, vel_rel, scat_tan_phi, use_r_eq=use_r_eq,   &
        &                 scat_zeta=scat_zeta, scat_phi=scat_phi,            &
        &                 scat_ht=scat_ht, xi=xi, scat_index=my_scat_index,  &
        &                 scat_tan_ht=scat_tan_ht, forward=forward, rev=rev, &
        &                 which=which )
d4436 4
a4439 3
  ! -------------------------------------------  Estimate_Tan_Phi  -----
  subroutine Estimate_Tan_Phi ( Nlvl, MAF, PhiTan, PTan, &
                              & ScGeocAlt, LOSVel, Tan_Press, &
d4442 2
a4443 1
                              & EarthRadC, Incline, LOS, TanHt  )
d4445 4
a4448 3
  ! Interpolate minor frame quantities PhiTan, ScGeocAlt, and LOSVel at
  ! pressure levels given by PTan to Tan_Phi, SC_Geoc_Alt and LOS Velocity at
  ! pressure levels given by Tan_Press.
d4450 1
a4450 1
    use Geolocation_0, only: ECR_T
d4461 2
a4464 2
    type(vectorValue_T), intent(in) :: PTan       ! Tangent pressure (minor
                                                  ! frame), zeta
d4467 4
a4470 4
    type(vectorValue_T), intent(in) :: LOSVel     ! Line of sight velocity by mif
                                                  ! and maf (minor frame), m/s
    real(rk), dimension(:), intent(in) :: Tan_press ! Tangent pressure levels
                                                  ! where the other quantities
d4473 2
a4474 2
  ! Outputs
    real(rk), intent(out) :: Tan_Phi(:)
d4478 1
a4478 1
  ! Optional inputs, for QTM-based model
d4486 2
a4487 2
    type(ECR_t), intent(out), optional :: LOS(:,:,:) ! (1,1:2,:) are points on LOS,
                                                  ! (2,1:2,:) are unit directions
d4491 2
a4492 2
    real(rk), intent(out), optional :: EarthRadC(:) ! Plane-projected
                                                  ! minor axis**2, m**2
d4494 3
d4499 7
a4505 8
    integer :: I, JF, K, SUB
    real(rk) :: RP, RT, RV, RZ ! real variables for various uses
    real(rk), dimension(ptan%template%noSurfs) :: &
      & P_MIF, &               ! Pressures for MIFs
      & T_MIF, &               ! Temperatures for MIFs
      & V_MIF                  ! LOS velocities for MIFs
    real(rk), dimension(0:ptan%template%noSurfs) :: & ! 0'th is a sentinel
      & Z_MIF                  ! Zetas for MIFs
d4509 1
d4514 3
a4516 3
! Since the interpolateValues routine needs the OldX array to be sorted
! we have to sort ptan%values and re-arrange phitan%values, scgeocalt%values
! and losvel%values accordingly
d4520 10
a4529 9
    z_mif(0) = -0.5 * huge(1.0_rk) ! Sentinel to simplify sort. Use only
               ! 0.5*huge in case some compiler does compare using subtract
    z_mif(1:k) = ptan%values(1:k,maf)
    p_mif = phitan%values(1:k,maf)
    t_mif = scgeocalt%values(1:k,maf)
    v_mif = losvel%values(1:k,maf)

    ! Sort Z_MIF.  Permute P_MIF, T_MIF and V_MIF the same way.
    ! Use insertion sort since things may be nearly in order already.
d4532 1
d4534 1
a4534 4
        rp = p_mif(i)
        rt = t_mif(i)
        rv = v_mif(i)
        jf = i
d4536 4
a4539 6
          z_mif(jf) = z_mif(jf-1)
          p_mif(jf) = p_mif(jf-1)
          t_mif(jf) = t_mif(jf-1)
          v_mif(jf) = v_mif(jf-1)
          jf = jf - 1
          if ( rz >= z_mif(jf-1) ) exit ! z_mif(0) is -huge(1.0_rk)
d4541 2
a4542 4
        z_mif(jf) = rz
        p_mif(jf) = rp
        t_mif(jf) = rt
        v_mif(jf) = rv
d4546 5
a4550 6
    call interpolateValues ( z_mif(1:k), p_mif, tan_press(sub+1:), &
      &  tan_phi(sub+1:), METHOD = 'L', EXTRAPOLATE='C' )
    call interpolateValues ( z_mif(1:k), t_mif, tan_press(sub+1:), &
       & est_scgeocalt(sub+1:), METHOD='L', EXTRAPOLATE='C' )
    call interpolateValues ( z_mif(1:k), v_mif, tan_press(sub+1:), &
       & est_los_vel(sub+1:), METHOD='L', EXTRAPOLATE='C' )
d4552 15
d4568 63
a4630 1
  end subroutine Estimate_Tan_Phi
d4636 1
a4636 1
       "$Id: FullForwardModel_m.f90,v 2.364 2016/03/25 02:02:37 vsnyder Exp $"
d4646 6
@


2.366
log
@Get temperature quantity from FwdModelConf, remove some unused stuff
@
text
@d71 1
a71 1
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
d83 3
a85 3
    real(rp), allocatable :: Z_PSIG(:)   ! Surfs from Temperature, tangent grid
                                         ! and species grids, sans duplicates.
    real(rp), pointer :: TAN_PRESS(:)    ! Pressures corresponding to Z_PSIG
d95 4
a98 2
    type (VectorValue_T), pointer :: PhiTan ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTan   ! Tangent pressure component of state vector
a141 2
    nullify ( tan_press )

d143 2
a144 2
    ! spectroscopy parameters from the state vector.  Get the temperature
    ! quantity from the state vector.
d153 7
a159 2
    ! Find quantities in the state vector.  For now, these are just
    ! used to set the sizes of other arrays.
a162 4
    ptan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, foundInFirst=ptan_der, config=fwdModelConf, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule )
    temp => fwdModelConf%temp%qty
d170 1
a170 1
      
d179 3
d293 1
a293 1
      call compute_Z_PSIG ( fwdModelConf, z_psig,                   &
d408 1
a408 1
    use CONSTANTS, only: Deg2Rad, Rad2Deg
d416 1
d421 1
a421 1
    use Intrinsic, only: L_A, L_GeocAltitude, L_GeodAltitude, &
d432 1
d443 1
a443 1
    use VectorsModule, only: DestroyVectorQuantityValue, &
d447 1
a447 1
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
d465 4
a468 2
    type (VectorValue_T), intent(in) :: PTan ! Tangent pressure component of state vector
    type (VectorValue_T), intent(in) :: PhiTan ! Tangent geodAngle component of state vector
d581 2
d876 3
a878 1
    real(rp) :: EarthRadC_sq ! (minor axis of orbit plane projected Earth ellipse)**2
d908 1
a908 1
    type (VectorValue_T), pointer :: LOSVel        ! Line of sight velocity
d917 19
a935 3
!  The 'all_radiometers grid file' approach variables declaration:

    real(rp) :: max_ch_freq_grid, min_ch_freq_grid
d953 1
a953 1
        & earthradc_sq, max_ch_freq_grid, min_ch_freq_grid )
d960 2
a961 2
        & dTanh_dT_f, h_path, h_path_c, n_path_f, phi_path, ptg_angles, &
        & ref_corr )
d964 2
a965 2
      call fill_IEEE_NaN ( est_scgeocalt, est_los_vel, tan_d2h_dhdT, &
        & tan_phi )
d1101 1
a1101 1
                             & DXDT_TAN, EarthRadC_sq, Est_ScGeocAlt, &
d1207 1
a1207 1
        & EarthRadC_sq, Est_ScGeocAlt, FirstSignal, FmStat, &
d1316 9
d1347 3
a1349 3
      use Intrinsic, only: L_EARTHREFL, L_ECRtoFOV, L_GPH, L_LOSVEL,  &
        & L_SurfaceHeight, L_ORBITINCLINATION, L_REFGPH, L_SCGEOCALT, &
        & L_SPACERADIANCE
d1351 1
d1353 3
a1355 1
      integer :: Me = -1    ! String index for trace
d1360 37
a1396 1
      fmStat%flags = 0 ! Assume no errors
d1428 2
a1429 5
      ! VMRS are in Beta_group%qty, gotten by get_species_data
      gph => GetQuantityForForwardModel (fwdModelIn, fwdModelExtra, &
        & quantityType=l_gph, config=fwdModelConf )
      earthRefl => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_earthRefl, config=fwdModelConf )
d1435 7
a1443 2
      scGeocAlt => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_scGeocAlt, config=fwdModelConf )
d1480 2
a1481 1
         call estimate_tan_phi ( nlvl, maf, phitan, ptan, &
d1484 23
a1517 4
      ! Compute the square of the minor axis of the orbit plane projected Earth
      ! ellipse.

      earthradc_sq = orbit_plane_minor_axis_sq ( orbIncline%values(1,maf) * deg2rad )
d2314 1
a2314 1
      r_eq = get_R_eq ( phi_ref, earthradc_sq )
d3776 2
a3777 1
        r_eq = get_r_eq ( tan_phi, earthradc_sq ) ! Geometric earth radius
d4525 15
a4539 10
  subroutine Estimate_Tan_Phi ( nlvl, maf, phitan, ptan, &
                              & scgeocalt, losvel, tan_press, &
                              & tan_phi, est_scgeocalt, est_los_vel )

  ! Estimate Tan_Phi, SC_geoc_alt and LOS Velocity.

    use MLSKINDS, only: RK => RP
    use MLSNUMERICS, only: INTERPOLATEVALUES
    use CONSTANTS, only: DEG2RAD
    use VECTORSMODULE, only: VECTORVALUE_T
d4544 13
a4556 7
    integer, intent(in) :: NLVL                    ! Size of integration grid
    integer, intent(in) :: MAF                     ! MAF under consideration
    type (VectorValue_T), intent(in) :: PHITAN     ! Tangent geodAngle component of state vector
    type (VectorValue_T), intent(in) :: PTAN       ! Tangent pressure component of state vector
    type (VectorValue_T), intent(in) :: SCGEOCALT  ! S/C geocentric altitude /m
    type (VectorValue_T), intent(in) :: losvel     ! line of sight velocity by mif and maf
    real(rk), dimension(:), intent(in) :: Tan_press
d4559 20
a4578 3
    real(rk), dimension(:), intent(out) :: Tan_phi
    real(rk), dimension(:), intent(out) :: Est_scgeocalt ! Est S/C geocentric altitude /m
    real(rk), dimension(:), intent(out) :: est_los_vel
d4582 1
a4582 1
    real(rk) :: RP, RT, RV, RZ       ! real variables for various uses
d4647 1
a4647 1
       "$Id: FullForwardModel_m.f90,v 2.365 2016/04/21 02:00:12 vsnyder Exp $"
d4657 3
@


2.365
log
@Move Convolution and Convolution_Setup to Convolution_m
@
text
@d55 1
a55 1
      & L_PhiTan, L_PTan, L_Temperature, L_TScat, L_VMR, L_Zeta
a133 1
    logical :: Temp_Der, Temp_In_First
d143 4
a146 2
    ! spectroscopy parameters from the state vector.
    ! This has to be done AFTER deriveFromForwardModelConfig.
d161 1
a161 3
    temp => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature, foundInFirst=temp_in_first, &
      & config=fwdModelConf )
d172 2
a173 2
    temp_der = present ( jacobian ) .and. FwdModelConf%temp_der
    if ( temp_der .and. .not. temp_in_first ) &
d289 1
a289 1
      call compute_Z_PSIG ( fwdModelConf, temp, z_psig,             &
d296 1
a296 1
      call compute_Z_PSIG ( fwdModelConf, temp, z_psig )
d330 1
a330 1
    s_t = merge(1,0,temp_der)
d410 1
a410 2
    use ForwardModelIntermediate, only: ForwardModelStatus_T, &
                                    &   B_Ptg_Angles, B_Refraction
a565 1
    logical :: Print_Ptg          ! For debugging, from -Sptg
a989 1
    print_Ptg = switchDetail(switches, 'ptg') > -1
d1072 2
a1073 2
      call convolution_setup ( DH_DZ_OUT, DX_DH_OUT, DX_DT, DXDT_Surface, &
                             & DXDT_TAN, D2X_DXDT, EarthRadC_sq, Est_ScGeocAlt, &
d1322 1
a1322 1
      temp_der = present ( jacobian ) .and. FwdModelConf%temp_der
d4520 1
a4520 1
       "$Id: FullForwardModel_m.f90,v 2.364 2016/03/25 02:02:37 vsnyder Exp $"
d4530 3
@


2.364
log
@Add a dump for polarized incremental optical depth just before its
exponential is attempted to be computed.
@
text
@a172 3
    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der
    atmos_second_der = present (hessian ) .and. FwdModelConf%atmos_second_der

d174 1
a174 1
    if ( temp_der .and. .not. temp_in_first) &
d406 1
d1076 8
a1083 1
      call convolution_setup
d1180 11
a1190 1
      if ( .not. fwdModelConf%generateTScat ) call convolution ! or interpolate to ptan
a1493 334
  ! ................................................  Convolution  .....
    subroutine Convolution ! or simply interpolation to output grid

      ! Convolution if needed, or interpolation to ptan ----------------

      use ANTENNAPATTERNS_M, only: ANTENNAPATTERNS
      use INTRINSIC, only: L_ELEVOFFSET, L_LIMBSIDEBANDFRACTION
      use CONVOLVE_ALL_M, only: CONVOLVE_RADIANCE, CONVOLVE_TEMPERATURE_DERIV, &
        & CONVOLVE_OTHER_DERIV, CONVOLVE_OTHER_SECOND_DERIV, INTERPOLATE_RADIANCE, &
        & INTERPOLATE_TEMPERATURE_DERIV, INTERPOLATE_OTHER_DERIV
!       use CONVOLVE_ALL_M, only: CONVOLVE_TEMPERATURE_DERIV_NORMALIZATION, &
!         & CONVOLVE_RADIANCE_NORMALIZATION
      use DUMP_0, only: DUMP
      use FOV_CONVOLVE_M, only: CONVOLVE_SUPPORT_T, FOV_CONVOLVE_SETUP, &
        & FOV_CONVOLVE_TEARDOWN, NO_FFT
      use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_WARNING
      use MLSNUMERICS, only: COEFFICIENTS => COEFFICIENTS_R8, &
        & INTERPOLATEARRAYSETUP, INTERPOLATEARRAYTEARDOWN

      integer ChanInd, Channel, I, J, SigInd, Ptg_I
      real(rp) :: DELTAPTG         ! Used for patching the pointings
      integer :: Me = -1           ! String index for trace
      integer :: MINSUPERSET       ! Min. value of superset > 0
      logical :: PATCHEDAPTG       ! Used in patching the pointings
      integer :: PTG_J             ! Loop counters for patching the pointings
      real(r8) :: RAD_FFT(s_t*no_fft) ! FFT(I)                                 ! IGOR
!       real(r8) :: RAD_DIFF_FFT(s_t*no_fft) ! FFT(I-IA)                         ! IGOR
      integer :: SUPERSET          ! Output from AreSignalsSuperset
      real(rp) :: THISELEV         ! An elevation offset
      real(rp) :: THISFRACTION     ! A sideband fraction
      logical :: Update            ! Just update radiances etc.
      integer :: WHICHPATTERN      ! Index of antenna pattern
      type (Coefficients) :: Coeffs ! For interpolation
      type (Convolve_Support_T) :: Convolve_Support
      type (VectorValue_T), pointer :: ELEVOFFSET       ! Elevation offset
      type (VectorValue_T), pointer :: SIDEBANDFRACTION ! The sideband fraction to use
      type (VectorValue_T), pointer :: THISRADIANCE     ! A radiance vector quantity

      call trace_begin ( me, 'ForwardModel.Convolution', &
        & cond=toggle(emit) .and. levels(emit) > 2 )

      ! Check that the angles are in the correct order.  If they
      ! are not it means (give or take some approximations in the
      ! horizontal according to Bill), that the rays crossed over
      ! between the tangent point and the spacecraft.  One could dream
      ! up all sorts of elegant schemes to get around that problem, but
      ! it's simplest just to bail out (and is certainly preferable to
      ! the infinite loop in the convolution (Hunt on angles) that
      ! results otherwise).

      if ( print_Ptg ) &
        & call Dump ( ptg_angles, 'ptg_angles (before any patch)', format='(1PG22.17)' )

      ! This code is needed to ensure that the ptg_angles are monotonic
      ! (and not flat even)
      deltaPtg = 1e-3              ! Some starting value
      patchedAPtg = .false.
      do ptg_i = 2, no_tan_hts
        if ( ptg_angles(ptg_i) <= ptg_angles(ptg_i-1) ) then
          patchedAPtg = .true.
          ! This one is at or below its predecessor, find the next one above
          ! If there is no next one above just use the previous spacing
          do ptg_j = ptg_i + 1, no_tan_hts
            if ( ptg_angles(ptg_j) > ptg_angles(ptg_i-1) ) then
              ! Found one above.  Work out spacing to fill in with
              deltaPtg = ( ptg_angles(ptg_j) - ptg_angles(ptg_i-1) ) / ( ptg_j - ptg_i + 1 )
              exit
            end if
          end do
          ptg_angles(ptg_i) = ptg_angles(ptg_i-1) + deltaPtg
        else
          ! This value is above the previous one so compute a delta from it
          ! to use if needed later
          deltaPtg = ptg_angles(ptg_i) - ptg_angles(ptg_i-1)
        end if
      end do

      if ( patchedAPtg ) then
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'Had to patch some out-of-order ptg_angles' )
        fmStat%flags = ior(fmStat%flags,b_ptg_angles)
        if ( print_Ptg ) &
          & call dump ( ptg_angles, 'ptg_angles (after patching)', format='(1PG22.17)' )
      end if

      ! Work out which antenna patterns we're going to need ------------------
      do i = 1, noUsedChannels
        channel = channels(i)%used
        chanInd = channel + 1 - channels(i)%origin
        sigInd = channels(i)%signal
        ! Get the radiance
        thisRadiance =>  &
          GetQuantityForForwardModel (fwdModelOut, quantityType=l_radiance, &
          & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband,   &
          & config=fwdModelConf )
        ! Get the sideband fraction if we need to
        if ( firstSignal%sideband == 0 .or. fwdModelConf%forceSidebandFraction ) then
          sidebandFraction => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_limbSidebandFraction, &
            & signal=fwdModelConf%signals(sigInd)%index, &
            & sideband=thisSideband, config=fwdModelConf )
          thisFraction = sidebandFraction%values(chanInd,1)
        else                  ! Otherwise, want just unfolded signal
          thisFraction = 1.0
        end if
        ! Get the elevation offset
        elevOffset => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_elevOffset, signal=fwdModelConf%signals(sigInd)%index, &
          & sideband=thisSideband, config=fwdModelConf )
        thisElev = elevOffset%values(chanInd,1) * deg2Rad

        ! Here comes the Convolution (or not) codes
        update = ( thisSideband /= fwdModelConf%sidebandStart )

        if ( FwdModelConf%do_conv ) then

          whichPattern = -1
          minSuperset = huge(0)
          do j = 1, size(antennaPatterns)
            superset = AreSignalsSuperset ( antennaPatterns(j)%signals, &
              & fwdModelConf%signals(sigInd:sigInd), sideband=thisSideband, &
              & channel=channel )
            if ( superset >= 0 .and. superset <= minSuperset ) then
              minSuperset = superset
              whichPattern = j
            end if
          end do
          if ( whichPattern < 0 ) call Announce_Error ( &
            & "No matching antenna patterns." )

          call fov_convolve_setup ( antennaPatterns(whichPattern), ptg_angles, &
            & tan_chi_out-thisElev, convolve_support, &
            & get_r_eq(sum(tan_phi)/no_tan_hts,earthradc_sq), & ! Average r_eq
            & sum(0.001_rp*est_scgeocalt)/no_tan_hts,         & ! Average alt
            & do_dRad_dx=ptan_der, do_Scan_Avg=fwdModelConf%scanAverage )

          if ( temp_der ) then

            ! To turn on/off Temperature Derivatives Normalization:
            ! comment/uncomment two function calls:

            call convolve_radiance ( convolve_support, maf, chanInd, &
              & radiances(i,:), thisFraction, update, ptan, thisRadiance, &
              & L1BMIF_TAI, MIFDeadTime, &
              & Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, ptan_der, rad_FFT )    ! IGOR

            !call convolve_radiance_normalization ( convolve_support, maf, chanInd, &
            !  & radiances(i,:), thisFraction, update, ptan, thisRadiance, &
            !  & L1BMIF_TAI, MIFDeadTime, &
            !  & Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, ptan_der, rad_FFT, &
            !  & radiances_diff(i,:), rad_diff_FFT )                                  ! IGOR

            call convolve_temperature_deriv ( convolve_support, maf, chanInd, &
              & radiances(i,:), rad_fft, thisFraction, update, thisRadiance, &
              & temp, grids_tmp, surf_angle(1), L1BMIF_TAI, MIFDeadTime, &
              & real(k_temp(i,:,:),kind=rp), &
              & dx_dt, d2x_dxdt, dxdt_tan, dxdt_surface, Jacobian, fmStat%rows )    ! IGOR

            !call convolve_temperature_deriv_normalization ( convolve_support, maf, chanInd, &
            !  & radiances_diff(i,:), rad_diff_FFT, thisFraction, update, thisRadiance, &
            !  & temp, grids_tmp, surf_angle(1), L1BMIF_TAI, MIFDeadTime, &
            !  & real(k_temp(i,:,:),kind=rp), &
            !  & dx_dt, d2x_dxdt, dxdt_tan, dxdt_surface, Jacobian, fmStat%rows )     ! IGOR

          else ! No temperature derivative
            call convolve_radiance ( convolve_support, maf, chanInd, &
              & radiances(i,:), thisFraction, update, ptan, thisRadiance, &
              & L1BMIF_TAI, MIFDeadTime, &
              & Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, ptan_der )
          end if

          if ( atmos_der ) then
            call convolve_other_deriv ( convolve_support, maf, chanInd, &
            & thisFraction, update, thisRadiance, beta_group%qty, Grids_f, &
            & L1BMIF_TAI, MIFDeadTime, real(k_atmos(i,:,:),kind=rp), &
            & Jacobian, fmStat%rows, extraJacobian )

            if (atmos_second_der ) then
              call convolve_other_second_deriv ( convolve_support, maf, chanInd, &
              & thisFraction, update, thisRadiance, beta_group%qty, Grids_f, &
              & L1BMIF_TAI, MIFDeadTime, real(h_atmos(i,:,:,:),kind=rp), &
              & Hessian, fmStat%rows )
            end if
          end if

          if ( spect_der_center ) &
            & call convolve_other_deriv ( convolve_support, maf, chanInd, &
              & thisFraction, update, thisRadiance, &
              & fwdModelConf%lineCenter%qty, grids_v, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dv(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & extraJacobian )
          if ( spect_der_Width ) &
            & call convolve_other_deriv ( convolve_support, maf, chanInd, &
              & thisFraction, update, thisRadiance, &
              & fwdModelConf%lineWidth%qty, grids_w, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dw(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & extraJacobian )
          if ( spect_der_Width_TDep ) &
            & call convolve_other_deriv ( convolve_support, maf, chanInd, &
              & thisFraction, update, thisRadiance, &
              & fwdModelConf%lineWidth_TDep%qty, grids_n, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dn(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & extraJacobian )

          call fov_convolve_teardown ( convolve_support )

        else          ! No convolution needed ..

          call interpolateArraySetup ( ptg_angles, tan_chi_out-thisElev, &
            & method='S', extrapolate='C', coeffs=coeffs, &
            & dyByDx=ptan_der.or.fwdModelConf%scanAverage )

          call interpolate_radiance ( coeffs, maf, chanInd, ptg_angles, &
            & radiances(i,:), thisFraction, update, ptan, tan_chi_out-thisElev, &
            & thisRadiance, L1BMIF_TAI, MIFDeadTime, Jacobian, fmStat%rows, &
            & dh_dz_out, dx_dh_out, ptan_der )

          if ( temp_der ) &
            & call interpolate_temperature_deriv ( coeffs, maf, chanInd, &
              & ptg_angles, thisFraction, update, tan_chi_out-thisElev,  &
              & thisRadiance, temp, grids_tmp, L1BMIF_TAI, MIFDeadTime, &
              & real(k_temp(i,:,:),kind=rp), Jacobian, fmStat%rows )

          if ( atmos_der ) &
            call interpolate_other_deriv ( coeffs, maf, chanInd, ptg_angles, &
              & thisFraction, update, tan_chi_out-thisElev, thisRadiance, &
              & beta_group%qty, grids_f, L1BMIF_TAI, MIFDeadTime, &
              & real(k_atmos(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & linear=.true., extraJacobian=extraJacobian )

          if ( spect_der_center ) &
            & call interpolate_other_deriv ( coeffs, maf, chanInd, ptg_angles, &
              & thisFraction, update, tan_chi_out-thisElev, thisRadiance, &
              & fwdModelConf%lineCenter%qty, grids_v, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dv(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & linear=.true., extraJacobian=extraJacobian )

          if ( spect_der_Width ) &
            & call interpolate_other_deriv ( coeffs, maf, chanInd, ptg_angles, &
              & thisFraction, update, tan_chi_out-thisElev, thisRadiance, &
              & fwdModelConf%lineWidth%qty, grids_w, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dw(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & linear=.true., extraJacobian=extraJacobian )

          if ( spect_der_Width_TDep ) &
            & call interpolate_other_deriv ( coeffs, maf, chanInd, ptg_angles, &
              & thisFraction, update, tan_chi_out-thisElev, thisRadiance, &
              & fwdModelConf%lineWidth_TDep%qty, grids_n, L1BMIF_TAI, MIFDeadTime, &
              & real(k_spect_dn(i,:,:),kind=rp), Jacobian, fmStat%rows, &
              & linear=.true., extraJacobian=extraJacobian )

          call interpolateArrayTeardown ( coeffs )

        end if ! Convolve or interpolate

      end do                            ! Channel loop

      call trace_end ( 'ForwardModel.Convolution', &
        & cond=toggle(emit) .and. levels(emit) > 2 )

    end subroutine Convolution

    ! ----------------------------------------  Convolution_Setup  -----
    subroutine Convolution_Setup
    ! set up output pointing angles ------------------------------------

      use Get_Chi_Out_m, only: Get_Chi_Out
      use Intrinsic, only: L_MIFDEADTIME, L_L1BMIF_TAI

      real(rp) :: D2XDXDT_SURFACE(1,size(dxdt_surface,2))
      real(rp) :: D2XDXDT_TAN(size(dxdt_tan,1),size(dxdt_tan,2))
      real(rp) :: One_dhdz(1), One_dxdh(1)
      real(rp) :: REQ_OUT(phitan%template%nosurfs)

      integer :: Me = -1                    ! String index for trace
      type (VectorValue_T), pointer :: WORK ! Temporary stuff

      call trace_begin ( me, 'ForwardModel.Convolution_Setup', &
        & cond=toggle(emit)  .and. levels(emit) > 0 )

      ! Compute equivalent earth radius

      ! Although this is the same mathematical formula as used in metrics,
      ! the phi used here is different: These are on MIFs, not hypothetical
      ! pointings to the desired tangent zetas.  Therefore, we can't use
      ! these values in metrics, or where its output r_eq value is
      ! used.

      req_out = get_R_eq ( phitan%values(:,maf)*Deg2Rad, earthradc_sq )

      ! Temperature's windowStart:windowFinish are correct here.
      ! RefGPH and Temperature have the same horizontal basis.
      ! Grids_F is only needed for H2O, for calculating refractive index.
      ! SCgeocAlt and RefGPH are in meters, but Get_Chi_Out wants them in km.
      ! This is only used for convolution, which is done for both sidebands.
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp,                    &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /),              &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish),             &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp,                       &
         & req_out, grids_f, h2o_ind, tan_chi_out, dh_dz_out, dx_dh_out,   &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )

      ! This is a lazy way to get the surface angle
      ! Temperature's windowStart:windowFinish are correct here.
      ! refGPH and temperature have the same horizontal basis.
      ! Grids_tmp is only needed for H2O, for calculating refractive index.
      ! Est_scgeocalt and RefGPH are in meters, but Get_Chi_Out wants them in km.
      ! This is only used for convolution, which is done for both sidebands.
      call get_chi_out ( tan_press(1:1), tan_phi(1:1),                     &
         & 0.001_rp*est_scgeocalt(1:1), Grids_tmp,                         &
         & (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish),             &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp,                       &
         & req_out(1:1), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh, &
         & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )

      ! This is only used for convolution, which is done for both sidebands.
      if ( fwdModelConf%scanAverage ) then
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_l1bMIF_TAI, config=fwdModelConf )
        l1bMIF_TAI => work%values
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_MIFDeadTime, config=fwdModelConf )
        MIFDeadTime => work%values ! Only the (1,1) element is used.
      else
        nullify ( l1bMIF_TAI, MIFDeadTime )
      end if

      call trace_end ( 'ForwardModel.Convolution_Setup', &
        & cond=toggle(emit) .and. levels(emit) > 0 )

    end subroutine Convolution_Setup

d4524 1
a4524 1
       "$Id: FullForwardModel_m.f90,v 2.363 2016/02/25 00:57:58 vsnyder Exp $"
d4534 4
@


2.363
log
@Include bounds of t_path_c in call to dt_script_dt
@
text
@d3056 1
d3415 3
d3419 1
d4843 1
a4843 1
       "$Id: FullForwardModel_m.f90,v 2.362 2016/01/23 02:55:24 vsnyder Exp $"
d4853 3
@


2.362
log
@Add printing for polarized radiance
@
text
@d3738 1
a3738 1
          call dt_script_dt ( t_path_c, B(:npc), eta_zxp_t_c(1:npc,:), &
d4838 1
a4838 1
       "$Id: FullForwardModel_m.f90,v 2.361 2015/12/08 23:23:42 vsnyder Exp $"
d4848 3
@


2.361
log
@Put bound (:i_end) on Ref_Corr in call to Get_Tau
@
text
@d431 1
a431 1
    use Output_M, only: Output
d435 1
a435 1
    use SLABS_SW_M, only: AllocateSLABS, DestroyCompleteSLABS, SLABS_Struct
d567 3
d994 1
a2407 1
      use OUTPUT_M, only: NEWLINE
d3605 15
d3878 4
a3881 5
      use ADD_POINTS_M, only: ADD_POINTS
      use CONSTANTS, only: PI
      use GEOMETRY, only: MAXREFRACTION
      use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
      use GET_ETA_MATRIX_M, only: GET_ETA_STRU
d3883 7
a3889 7
      use METRICS_M, only: HEIGHT_METRICS, MORE_METRICS, MORE_POINTS, &
        & TANGENT_METRICS
      use MIN_ZETA_M, only: GET_MIN_ZETA
      use PHI_REFRACTIVE_CORRECTION_M, only: PHI_REFRACTIVE_CORRECTION
      use READ_MIE_M, only: IWC_S, T_S
      use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR
      use SLABS_SW_M, only: GET_GL_SLABS_ARRAYS
d4838 1
a4838 1
       "$Id: FullForwardModel_m.f90,v 2.360 2015/12/08 19:13:08 vsnyder Exp $"
d4848 3
@


2.360
log
@Define pointer association status of Phi_Path_C immediately after Height_Metrics
@
text
@d3510 1
a3510 1
          & del_zeta, alpha_path_c, ref_corr, incoptdepth(:i_end), &
d4821 1
a4821 1
       "$Id: FullForwardModel_m.f90,v 2.359 2015/10/28 00:34:13 vsnyder Exp $"
d4831 3
@


2.359
log
@Add more magnetic field-related dumps
@
text
@d3988 1
d4821 1
a4821 1
       "$Id: FullForwardModel_m.f90,v 2.358 2015/09/22 23:37:26 vsnyder Exp $"
d4831 3
@


2.358
log
@Add 3D magnetic field
@
text
@d564 1
a564 1
    logical :: Print_Mag          ! For debugging, from -Smag
d990 1
a990 1
    print_Mag = switchDetail(switches, 'mag') > -1
d4370 4
a4373 1
        if ( print_Mag ) then
d4379 4
d4820 1
a4820 1
       "$Id: FullForwardModel_m.f90,v 2.357 2015/08/25 17:23:05 vsnyder Exp $"
d4830 3
@


2.357
log
@Compute PhiWindow in radians for TScat
@
text
@d45 4
a48 3
    use ALLOCATE_DEALLOCATE, only: DEALLOCATE_TEST
    use COMPUTE_Z_PSIG_M, only: COMPUTE_Z_PSIG
    use FORWARDMODELCONFIG, only: DUMP, FORWARDMODELCONFIG_T
d50 15
a64 14
    use FORWARDMODELINTERMEDIATE, only: FORWARDMODELSTATUS_T
    use FORWARDMODELVECTORTOOLS, only: GETQUANTITYFORFORWARDMODEL
    use GET_SPECIES_DATA_M, only:  GET_SPECIES_DATA
    use HESSIANMODULE_1, only: HESSIAN_T
    use INTRINSIC, only: LIT_INDICES, L_MAGNETICFIELD, &
      & L_PHITAN, L_PTAN, L_TEMPERATURE, L_TSCAT, L_VMR
    use LOAD_SPS_DATA_M, only: DESTROYGRIDS_T, DUMP, EMPTYGRIDS_T, GRIDS_T, &
      & LOAD_ONE_ITEM_GRID, LOAD_SPS_DATA
    use MATRIXMODULE_1, only: MATRIX_T
    use MLSKINDS, only: RP
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR, MLSMSG_WARNING
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MOLECULES, only: L_CLOUDICE
    use MOREMESSAGE, only: MLSMESSAGE
d66 3
a68 3
    use TOGGLES, only: EMIT, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use VECTORSMODULE, only: VECTOR_T, VECTORVALUE_T
d94 4
a97 3
    type (VectorValue_T), pointer :: PHITAN ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTAN   ! Tangent pressure component of state vector
    type (VectorValue_T), pointer :: TEMP   ! Temperature component of state vector
d108 1
a108 1
    integer :: SURFACETANGENTINDEX  ! Index in tangent grid of earth's
d110 1
a110 1
    integer :: MAXVERT          ! Number of points in gl-refined vertical grid:
d114 1
a114 1
    integer :: MAX_C            ! Length of longest possible coarse path,
d116 1
a116 1
    integer :: MAX_F            ! Length of longest possible fine path
d132 1
a132 1
    logical :: atmos_der, atmos_second_der, ptan_der, spect_der
d134 1
a134 1
    logical :: temp_der, temp_in_first
d193 1
a193 1
    ! a place to put them if fwdModelConf%beta_group%qty%foundInFirst, but
d254 11
a264 5
      call load_one_item_grid ( grids_mag, &
        & GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,          &
        & quantityType=l_magneticField, config=fwdModelConf ), fmStat%maf, &
        & phitan, fwdModelConf, .false.,                                   &
        & across=abs(azimuth) > azimuth_tol )
d266 6
a271 1
      if ( print_mag > -1 ) call dump ( grids_mag, 'Grids_Mag', print_mag )
d319 1
a319 1
    if ( switchDetail(switches,'grids') > -1 ) then ! dump the grids
d402 16
a417 16
    use ALLOCATE_DEALLOCATE, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use COMP_ETA_DOCALC_NO_FRQ_M, only: COMP_ETA_DOCALC_NO_FRQ
    use COMP_SPS_PATH_FRQ_M, only: COMP_SPS_PATH, COMP_SPS_PATH_FRQ, &
    ! & COMP_SPS_PATH_FRQ_NZ, &
      & COMP_SPS_PATH_NO_FRQ, COMP_1_SPS_PATH_NO_FRQ
    use COMPUTE_GL_GRID_M, only: COMPUTE_GL_GRID
    use CONSTANTS, only: DEG2RAD, RAD2DEG
    use DUMP_0, only: DUMP
    use FILTERSHAPES_M, only: DACSFILTERSHAPES, FILTERSHAPES
    use FORWARDMODELCONFIG, only: BETA_GROUP_T, CHANNELS_T, &
      & FORWARDMODELCONFIG_T, LINECENTER, LINEWIDTH, LINEWIDTH_TDEP
    use FORWARDMODELINTERMEDIATE, only: FORWARDMODELSTATUS_T, &
                                    &   B_PTG_ANGLES, B_REFRACTION
    use FORWARDMODELVECTORTOOLS, only: GETQUANTITYFORFORWARDMODEL
    use GEOMETRY, only: GET_R_EQ
    use GET_ETA_MATRIX_M, only: ETA_D_T ! TYPE FOR ETA STRUCT
d419 24
a442 24
    use HESSIANMODULE_1, only: HESSIAN_T
    use INTRINSIC, only: L_A, L_GeocAltitude, L_GeodAltitude, &
      & L_RADIANCE, L_TSCAT, L_VMR, L_Zeta
    use LOAD_SPS_DATA_M, only: DESTROYGRIDS_T, DUMP, GRIDS_T
    use MATRIXMODULE_1, only: MATRIX_T
    use MLSKINDS, only: R4, R8, RP, RV
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSNUMERICS, only: HUNT, INTERPOLATEVALUES, PUREHUNT
    use MLSSIGNALS_M, only: ARESIGNALSSUPERSET, GETNAMEOFSIGNAL, MATCHSIGNAL, &
      & RADIOMETERS, SIGNAL_T
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MOLECULES, only: L_H2O, L_N2O, L_O3
    use OUTPUT_M, only: OUTPUT
    use PATH_CONTRIB_M, only: GET_GL_INDS
    use PHYSICS, only: SPEEDOFLIGHT
    use POINTINGGRID_M, only: POINTINGGRIDS, POINTINGGRID_T
    use SLABS_SW_M, only: ALLOCATESLABS, DESTROYCOMPLETESLABS, SLABS_STRUCT
    use TAU_M, only: DESTROY_TAU, DUMP, TAU_T
    use TOGGLES, only: EMIT, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
    use TSCAT_SUPPORT_M, ONLY: TSCAT_GEN_SETUP
    use TWO_D_HYDROSTATIC_M, only: TWO_D_HYDROSTATIC
    use VECTORSMODULE, only: DestroyVectorQuantityValue, &
      & GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T
d451 1
a451 1
    real(rp), intent(in) :: TAN_PRESS(:)    ! Pressures corresponding to Z_PSIG
d459 1
a459 1
    type (Grids_T), intent(in) :: Grids_mag ! All the coordinates for Magnetic field
d463 3
a465 3
    type (VectorValue_T), intent(in) :: PTAN ! Tangent pressure component of state vector
    type (VectorValue_T), intent(in) :: PHITAN ! Tangent geodAngle component of state vector
    type (VectorValue_T), intent(in) :: TEMP ! Temperature component of state vector
d472 2
a473 2
    integer, intent(in) :: NO_TAN_HTS       ! Number of tangent heights
    integer, intent(in) :: SURFACETANGENTINDEX ! Index in tangent grid of
d475 2
a476 2
    integer, intent(in) :: MAX_C            ! Length of longest possible coarse path
    integer, intent(in) :: MAXVERT          ! Number of points in gl-refined vertical grid:
d480 2
a481 2
    integer, intent(in) :: MAX_F            ! Length of longest possible path (all npf<max_f)
    logical, intent(in) :: PTAN_Der
d504 1
a504 1
    ! alphabetically
d506 1
a506 1
    integer :: CHANNEL            ! A Loop counter
d511 1
a511 1
    integer :: FRQ_I              ! Frequency loop index
d529 3
a531 3
    integer :: NGLMAX             ! NGL if all panels need GL
    integer :: NOFREQS            ! Number of frequencies for a pointing
    integer :: NOUSEDDACS         ! Number of different DACS in this run.
d539 2
a540 2
    integer :: SIDEBAND           ! Either zero or from firstSignal
    integer :: SIGIND             ! Signal index, loop counter
d543 7
a549 7
    integer :: TAN_IND_C          ! Index of tangent point in coarse zeta ref grid
    integer :: TAN_IND_F          ! Index of tangent point in fine zeta ref grid
    integer :: TAN_PT_C           ! Index of tangent point in coarse path
    integer :: TAN_PT_F           ! Index of tangent point in fine path
    integer :: THISSIDEBAND       ! Loop counter for sidebands, -1 = LSB, +1 = USB
    integer :: WINDOWFINISH       ! End of temperature `window'
    integer :: WINDOWSTART        ! Start of temperature `window'
d585 5
a589 5
    integer, target :: C_INDS_B(max_c)  ! Base array for C_INDS
    integer, target :: CG_INDS_B(max_c) ! Base array for CG_INDS
    integer :: F_INDS(max_c*ng)         ! Indices on fine grid
    integer, target :: GL_INDS_B(max_c*ng) ! Base array for GL_INDS
    integer :: GRIDS(no_tan_hts)        ! Indices in ptgGrid for each tangent
d599 6
a604 6
    logical :: DO_CALC_Tscat(max_f,s_i*size(grids_tmp%values)) ! 'Avoid zeros' indicator
    logical :: DO_CALC_Salb(max_f,s_i*size(grids_tmp%values))  ! 'Avoid zeros' indicator
    logical :: DO_CALC_cext(max_f,s_i*size(grids_tmp%values))  ! 'Avoid zeros' indicator
    logical :: DO_CALC_Tscat_ZP(max_f,s_i*grids_tmp%p_len)     ! 'Avoid zeros' indicator
    logical :: DO_CALC_Salb_ZP(max_f,s_i*grids_tmp%p_len)      ! 'Avoid zeros' indicator
    logical :: DO_CALC_Cext_ZP(max_f,s_i*grids_tmp%p_len)      ! 'Avoid zeros' indicator
d606 1
a606 1
    real(r8), parameter :: FRQ_0 = 0.0_r8     ! Fake for comp_sps_path_frq
d611 2
a612 2
    real(rp) :: ALPHA_PATH_C(max_c)   ! coarse grid absorption coefficient
    real(rp) :: ALPHA_PATH_F(max_f)   ! fine grid absorption coefficient
d614 3
a616 3
    real(rp) :: BETA_PATH_cloud_C(s_i*max_c) ! Beta on path coarse
    real(rp) :: Beta_c_e_path_c(s_ts*max_c)  ! Beta_c_e on coarse path
    real(rp) :: Beta_c_s_path_c(s_ts*max_c)  ! Beta_c_s on coarse path
d618 2
a619 2
!   real(rp) :: DALPHA_DT_PATH_C(max_c)   ! dAlpha/dT on coarse grid
    real(rp) :: DALPHA_DT_PATH_F(max_f)   ! dAlpha/dT on fine grid
d622 1
a622 1
    real(rp) :: DEL_ZETA(max_c)       ! Integration lengths in Zeta coords
d624 7
a630 7
    real(rp) :: dBeta_c_a_dIWC_path_C(s_ts*max_c)  ! on coarse path
    real(rp) :: dBeta_c_s_dIWC_path_C(s_ts*max_c)  ! on coarse path
    real(rp) :: dBeta_c_a_dT_path_C(s_ts*max_c)    ! on coarse path
    real(rp) :: dBeta_c_s_dT_path_C(s_ts*max_c)    ! on coarse path
    real(rp) :: DHDZ_PATH(max_f)      ! dH/dZ on fine path (1:npf)
    real(rp) :: DHDZ_GW_PATH(max_f)   ! dH/dZ * GW on fine path (1:npf)
    real(rp) :: DSDH_PATH(max_f)      ! dS/dH on fine path (1:tan_pt_f-1,tan_pt_f+ngp1+1:npf)
d632 1
a632 1
    real(rp) :: DSDZ_GW_PATH(max_f)   ! ds/dH * dH/dZ * GW on path
d637 4
a640 4
    real(rp) :: H_PATH(max_f)         ! Heights on path (km)
    real(rp) :: H_PATH_C(max_c)       ! H_PATH on coarse grid (km)
    real(rp) :: H_PATH_F(max_f)       ! H_PATH on fine grid (km)
    real(rp) :: INCOPTDEPTH(max_c)    ! Incremental Optical depth on coarse grid
d642 3
a644 3
    real(rp) :: N_PATH_C(max_c)       ! Refractive index - 1 on coarse path
    real(rp) :: N_PATH_F(max_f)       ! Refractive index - 1 on fine path
    real(rp), target :: PHI_PATH(max_f) ! Phi's on fine path, Radians
d646 14
a659 14
    real(rp) :: P_PATH(max_f)         ! Pressure on path
    real(rp) :: PTG_ANGLES(no_tan_hts)
    real(rp) :: REF_CORR(max_c)       ! Refraction correction
    real(rp) :: TAN_DH_DT(s_t*sv_t_len) ! dH/dT at Tangent
    real(rp) :: TANH1_C(max_c)        ! tanh(0.5 h nu / k T)
    real(rp) :: TANH1_F(max_f)        ! tanh1 on fine grid
    real(rp) :: T_PATH(max_f)         ! Temperatures on path
    real(rp) :: T_PATH_C(max_c)       ! T_PATH on coarse grid
    real(rp) :: T_PATH_F(max_f)       ! T_PATH on fine grid
    real(rp) :: TT_PATH_C(max(s_i,s_ts)*max_c)  ! TScat on path coarse
    real(rp) :: W0_PATH_C(max(s_i,s_ts)*max_c)  ! w0 on path coarse
    real(rp) :: Z_COARSE(max_c)       ! Z_PSIG & Z_min & surface zeta on path
    real(rp) :: Z_GLGRID(maxvert)     ! Zeta on initial glGrid surfs
    real(rp) :: Z_PATH(max_f)         ! Zeta on fine grid path tangent grid and
d661 1
a661 1
    ! BETA_PATH_C has a frequency dimension.  It is d_Alpha/dVMR, which is
d663 3
a665 3
!   real(rp) :: BETA_PATH_C(max_c,no_mol)          ! on path coarse
    real(rp) :: BETA_PATH_F(max_f,no_mol)          ! on path fine
    real(rp) :: D_DELTA_DF(max_c,s_a*size(grids_f%values)) ! Incremental
d668 1
a668 1
    real(rp) :: D2_DELTA_DF2(max_c,size(grids_f%values),s_h*size(grids_f%values))
d674 4
a677 4
    real(rp) :: DALPHA_DF_PATH_C(max_c,s_a*no_mol)   ! on coarse path
    real(rp) :: DALPHA_DF_PATH_F(max_f,s_a*no_mol)   ! on GL path
    real(rp) :: D2ALPHA_DF2_PATH_C(max_c,s_h*no_mol) ! on coarse path
    real(rp) :: D2ALPHA_DF2_PATH_F(max_f,s_h*no_mol) ! on GL path
d679 16
a694 16
    real(rp) :: DBETA_DF_PATH_C(max_c,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: DBETA_DF_PATH_F(max_f,count(grids_f%where_dBeta_df /= 0))
    real(rp) :: DBETA_DIWC_PATH_C(max_c,s_tg*no_mol) ! dBeta_dIWC on coarse grid
    real(rp) :: DBETA_DIWC_PATH_F(max_f,s_tg*no_mol) ! dBeta_dIWC on fine grid
    real(rp) :: DBETA_DN_PATH_C(max_c,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on coarse grid
    real(rp) :: DBETA_DN_PATH_F(max_f,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on fine grid
    real(rp) :: DBETA_DT_PATH_C(max_c,s_t*no_mol)  ! dBeta_dT on coarse grid
    real(rp) :: DBETA_DT_PATH_F(max_f,s_t*no_mol)  ! dBeta_dT on fine grid
    real(rp) :: DBETA_DV_PATH_C(max_c,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on coarse grid
    real(rp) :: DBETA_DV_PATH_F(max_f,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on fine grid
    real(rp) :: DBETA_DW_PATH_C(max_c,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on coarse grid
    real(rp) :: DBETA_DW_PATH_F(max_f,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on fine grid
    real(rp) :: DH_DT_PATH(max_f,s_t*sv_t_len)     ! dH/dT on path
    real(rp) :: DH_DT_PATH_C(max_c,s_t*sv_t_len)   ! DH_DT_PATH on coarse grid
    real(rp) :: DH_DT_PATH_F(max_f,s_t*sv_t_len)   ! DH_DT_PATH on fine grid
    real(rp) :: DHDZ_GLGRID(maxVert,no_sv_p_t) ! dH/dZ on glGrid surfs
d698 1
a698 1
    real(rp) :: ETA_Mag_ZP(max_f,grids_mag%p_len)  ! Eta_z x Eta_p
d705 4
a708 4
    real(rp) :: H_GLGRID(maxVert,no_sv_p_t)        ! H on glGrid surfs (km)
    real(rp) :: IWC_PATH(max_f,max(max(s_i,s_ts),s_ts)) ! IWC on path
    real(rp), target :: MAG_PATH(s_p*max_f,4)      ! Magnetic field on path
    real(rp), target :: RAD_AVG_PATH(max_c,s_pfa*noUsedChannels) ! Freq. Avgd.
d710 1
a710 1
    real(rp) :: RADIANCES(noUsedChannels,no_tan_hts) ! (noChans,Nptg)
d712 10
a721 10
    real(rp) :: SPECT_N_PATH(max_f,size(fwdModelConf%lineWidth_TDep)) ! Line Width Temperature Dependence
    real(rp) :: SPECT_V_PATH(max_f,size(fwdModelConf%lineCenter)) ! Line Center
    real(rp) :: SPECT_W_PATH(max_f,size(fwdModelConf%lineWidth)) ! Line Width
    real(rp) :: SPS_PATH(max_f,no_mol)             ! species on path
    real(rp) :: SPS_PATH_C(max_c,no_mol)           ! species on coarse path
    real(rp) :: SPS_PATH_F(max_f,no_mol)           ! species on GL path
    real(rp) :: TT_PATH(max_f,max(s_i,s_ts))       ! TScat on path along the LOS
    real(rp) :: T_GLGRID(maxVert,no_sv_p_t)        ! Temp on glGrid surfs
    real(rp) :: T_SCRIPT_PFA(max_c,s_pfa*noUsedChannels) ! Delta_B in some notes
    real(r8) :: VMRARRAY(s_i*n_t_zeta,no_mol)      ! The VMRs for H2O, O3, N2
d740 1
a740 1
    real(rp), target :: DH_DT_GLGRID(maxVert,n_t_zeta,s_t*no_sv_p_t)
d742 10
a751 10
    complex(rp) :: D_RAD_POL_DF(2,2,s_p*s_a*size(grids_f%values)) ! From mcrt_der
    complex(rp) :: D_RAD_POL_DT(2,2,s_p*s_t*sv_t_len) ! From mcrt_der
    complex(rp) :: ALPHA_PATH_POLARIZED(-1:1,s_p*max_c)
    complex(rp) :: ALPHA_PATH_POLARIZED_F(-1:1,s_p*max_f)
    complex(rp) :: dALPHA_dT_POLARIZED_PATH_C(-1:1,s_p*s_t*max_c)
    complex(rp) :: dALPHA_dT_POLARIZED_PATH_F(-1:1,s_p*s_t*max_f)
    complex(rp) :: BETA_PATH_POLARIZED(-1:1,s_p*max_c,no_mol)
    complex(rp) :: BETA_PATH_POLARIZED_F(-1:1,s_p*max_f,no_mol)
    complex(rp) :: dBETA_dT_POLARIZED_PATH_C(-1:1,s_p*s_t*max_c,no_mol)
    complex(rp) :: dBETA_dT_POLARIZED_PATH_F(-1:1,s_p*s_t*2*max_f,no_mol)
d754 1
a754 1
    complex(rp) :: DELTAU_POL(2,2,s_p*max_c) ! E in Michael's notes
d756 9
a764 9
!   complex(rp) :: GL_DELTA_POLARIZED(-1:1,s_p*max_f)
    complex(rp) :: INCOPTDEPTH_POL(2,2,s_p*max_c)
    complex(rp) :: PROD_POL(2,2,s_p*max_c)   ! P in Michael's notes
    complex(rp) :: TAU_POL(2,2,s_p*max_c)    ! Tau in Michael's notes

    real(rp) :: EST_SCGEOCALT(no_tan_hts) ! Est S/C geocentric altitude /m
    real(rp) :: EST_LOS_VEL(no_tan_hts)   ! Est S/C line-of-sight velocity M/S
    real(rp) :: TAN_D2H_DHDT(s_t*sv_t_len)
    real(rp) :: TAN_PHI(no_tan_hts)
d768 2
a769 2
    real(r4) :: K_ATMOS(noUsedChannels,no_tan_hts,s_a*size(grids_f%values))
    real(r4) :: H_ATMOS(noUsedChannels,no_tan_hts,s_h*size(grids_f%values),s_h*size(grids_f%values))
d771 4
a774 4
    real(r4) :: K_SPECT_DN(noUsedChannels,no_tan_hts,s_td*size(grids_n%values))
    real(r4) :: K_SPECT_DV(noUsedChannels,no_tan_hts,s_lc*size(grids_v%values))
    real(r4) :: K_SPECT_DW(noUsedChannels,no_tan_hts,s_lw*size(grids_w%values))
    real(r4) :: K_TEMP(noUsedChannels,no_tan_hts,s_t*sv_t_len)
d777 1
a777 1
    logical :: T_der_path_flags(s_t*max_f) ! a flag that tells where an
d782 10
a791 10
    logical :: DO_CALC_FZP(max_f, size(grids_f%values))
    logical :: DO_CALC_HYD(max_f, sv_t_len)
    logical :: DO_CALC_HYD_C(max_c, sv_t_len)  ! DO_CALC_HYD on coarse grid
    logical :: DO_CALC_N(max_f, size(grids_n%values) ) ! on entire grid
    logical :: DO_CALC_T(max_f, sv_t_len)
    logical :: DO_CALC_T_C(max_c, sv_t_len)    ! DO_CALC_T on coarse grid
    logical :: DO_CALC_T_F(max_f, sv_t_len)    ! DO_CALC_T on fine grid
    logical :: DO_CALC_V(max_f, size(grids_v%values) ) ! on entire grid
    logical :: DO_CALC_W(max_f, size(grids_w%values) ) ! on entire grid
    logical :: DO_CALC_ZP(max_f,grids_f%p_len) ! same shape as eta_zp
d803 1
a803 1
    integer, pointer :: C_INDS(:)   ! Indices on coarse grid
d807 2
a808 2
    integer, pointer :: USEDDACSSIGNALS(:) ! Indices in FwdModelConf of signals
                                    ! for our dacs
d810 1
a810 1
    real(rp) :: E_RFLTY       ! Earth reflectivity at given tan. point
d820 1
a820 1
    real(r8), pointer :: FREQUENCIES(:)  ! Frequencies to compute for
d823 1
a823 1
    real(rp), pointer :: RADV(:)         ! Radiances for 1 pointing on
d840 3
a842 3
    real(rp) :: Cext_PATH(max_f,s_i)    ! Cloud extinction on path
    real(rp) :: Salb_PATH(max_f,s_i)    ! Single Scattering Albedo on path
    real(rp) :: Tscat_PATH(max_f,s_i*fwdModelConf%num_scattering_angles) ! TScat on path
d845 1
a845 1
    real(rp), pointer :: DALPHA_DT_PATH_C(:,:) ! (max_c,max_frq)
d847 1
a847 1
    real(rp), pointer :: BETA_PATH_C(:,:,:)! (max_c,no_mol,max_frq)
d849 6
a854 6
    real(rp), pointer :: INC_RAD_PATH(:,:) ! Incremental radiance along the path
    real(rp), pointer :: K_ATMOS_FRQ(:,:)  ! dI/dVMR, ptg.frq X vmr-SV
    real(rp), pointer :: K_SPECT_DN_FRQ(:,:) ! ****
    real(rp), pointer :: K_SPECT_DV_FRQ(:,:) ! ****
    real(rp), pointer :: K_SPECT_DW_FRQ(:,:) ! ****
    real(rp), pointer :: K_TEMP_FRQ(:,:)   ! dI/dT, ptg.frq X T-SV
d856 1
a856 1
    real(rp), pointer :: H_ATMOS_FRQ(:,:,:)  ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr
d861 1
a861 1
    real(rp) :: DXDT_SURFACE(1,s_t*sv_t_len)
d864 2
a865 2
    real(rv), pointer :: MIFDEADTIME(:,:)  ! Not collecting data
    real(rp) :: surf_angle(1)
d868 1
a868 1
    real(rp) :: earthradc_sq ! (minor axis of orbit plane projected Earth ellipse)**2
d874 1
a874 1
    ! factors) to put Mie beta_c_a and beta_c_s into path
d884 1
a884 1
    type (PointingGrid_T), pointer :: WHICHPOINTINGGRID ! Pointing grids for one signal
d886 1
a886 1
    type (Signal_T), pointer :: FIRSTSIGNAL        ! The first signal we're dealing with
d892 2
a893 2
    type (VectorValue_T), pointer :: BOUNDARYPRESSURE
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
d898 3
a900 3
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination
    type (VectorValue_T), pointer :: REFGPH        ! Reference geopotential height
d902 2
a903 2
    type (VectorValue_T), pointer :: SCGEOCALT     ! S/C geocentric altitude /m
    type (VectorValue_T), pointer :: SPACERADIANCE ! Emission from space
d905 1
a905 1
    type (VectorValue_T), pointer :: THISRADIANCE  ! A radiance vector quantity
d929 1
a929 1
      call fill_IEEE_NaN ( alpha_path_c, alpha_path_f, b, &
d947 5
a951 5
        & d_t_scr_dT, d2x_dxdT, dalpha_df_path_c, dalpha_df_path_f, &
        & d2alpha_df2_path_c, d2alpha_df2_path_f, dbeta_df_path_c, &
        & dbeta_df_path_f, dbeta_dIWC_path_c, dbeta_dIWC_path_f, &
        & dbeta_dn_path_c, dbeta_dn_path_f, dbeta_dT_path_c, dbeta_dT_path_f, &
        & dbeta_dv_path_c, dbeta_dv_path_f, dbeta_dw_path_c, dbeta_dw_path_f, &
d1337 1
a1337 1
      ! VMRS are in beta_group%qty, gotten by get_species_data
d3051 15
a3065 15
      use CS_EXPMAT_M, only: CS_EXPMAT
      use DO_T_SCRIPT_M, only: TWO_D_T_SCRIPT, TWO_D_T_SCRIPT_CLOUD
      use D_T_SCRIPT_DTNP_M, only: DT_SCRIPT_DT
      use DUMP_PATH_M, only: DUMP_PATH, SPS_LIST
      use GET_BETA_PATH_M, only: GET_BETA_PATH, GET_BETA_PATH_CLOUD, &
        & GET_BETA_PATH_PFA, GET_BETA_PATH_POLARIZED
      use GET_DALPHA_DF_M, only: GET_DALPHA_DF, GET_D2ALPHA_DF2
      use GET_D_DELTAU_POL_M, only: GET_D_DELTAU_POL_DF, GET_D_DELTAU_POL_DT
      use GET_ETA_MATRIX_M, only: SELECT_NZ_LIST
      use INTERPOLATE_MIE_M, only: INTERPOLATE_MIE
      use LOAD_SPS_DATA_M, only:  LOAD_ONE_ITEM_GRID
      USE L2PC_M, ONLY: L2PC_T
      use MCRT_M, only: MCRT_DER
      use OPACITY_M, only: OPACITY
      use PATH_CONTRIB_M, only: PATH_CONTRIB
d3067 1
a3067 1
      use RAD_TRAN_M, only: RAD_TRAN_POL, DRAD_TRAN_DF, &
d3070 2
a3071 2
      use TAU_M, only: GET_TAU
      USE TSCAT_SUPPORT_M, ONLY: GET_DB_DT, GET_TSCAT, GET_TSCAT_SETUP, &
d3102 2
a3103 2
      ! INC_RAD_PATH is (out) if .not. PFA, and (inout) if PFA
      real(rp), intent(inout) :: INC_RAD_PATH(:) ! Incremental radiance along the path
d3172 2
a3173 2
          & t_der_path_flags, dbeta_dT_path_c, dbeta_dw_path_c,        &
          & dbeta_dn_path_c, dbeta_dv_path_c, dbeta_dIWC_path_c )
d3183 2
a3184 2
          &  dTanh_dT_c, vel_rel, dbeta_dT_path_c, dbeta_dw_path_c,      &
          &  dbeta_dn_path_c, dbeta_dv_path_c, dBeta_df_path_c,          &
d3300 1
a3300 1
        !  $G(\zeta)$ is {\tt alpha_path_c}, which is approximated
d3325 1
a3325 1
          ! Ignore contribution of PFA alpha to w0.
d3385 1
a3385 1
        ! to alpha here
d3401 2
a3402 2
        ! scalar alpha_path to the sigma-, pi and sigma+ parts of
        ! alpha_path_polarized above.  If we did add it here, we would
d3425 1
a3425 1
      ! $G(\zeta)$ is {\tt alpha_path_c}, but $\frac{\text{d}s}{\text{d}h}$
d3459 2
a3460 2
          & t_der_path_flags, dbeta_dT_path_f, dbeta_dw_path_f,               &
          & dbeta_dn_path_f, dbeta_dv_path_f, dbeta_dIWC_path_f )
d3470 1
a3470 1
        ! The derivatives that get_beta_path computes depend on which
d3478 2
a3479 2
          & vel_rel, dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f,       &
          & dbeta_dv_path_f, dbeta_df_path_f, grids_f%where_dBeta_df,         &
d3571 1
a3571 1
        ! to alpha here.
d3576 1
a3576 1
            & + 0.25 * alpha_path_f(j)
d3583 1
a3583 1
          & deltau_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl), dsdz_gw_path, &
d3827 1
a3827 1
              &  dbeta_dw_path_c, dbeta_dw_path_f, do_gl, del_s, ref_corr, &
d3835 1
a3835 1
              &  dbeta_dn_path_c, dbeta_dn_path_f, do_gl, del_s, ref_corr,  &
d3843 1
a3843 1
              &  dbeta_dv_path_c, dbeta_dv_path_f, do_gl, del_s, ref_corr, &
d4307 1
a4307 1
        ! Compute IWC_PATH
d4335 1
a4335 1
        ! Compute the first three components of MAG_PATH
d4813 1
a4813 1
       "$Id: FullForwardModel_m.f90,v 2.356 2015/05/28 23:22:44 vsnyder Exp $"
d4823 3
d4933 2
a4934 2
! Fix an array-index-out-of-bound bug by fixing the declaration fo DBETA_DF_PATH_C
! and DBETA_DF_PATH_F
d5005 1
a5005 1
! Give frequency dimension to alpha_path_c and beta_path_c.  Make
d5032 1
a5032 1
! Provide that betas for Cloud_A and Cloud_S depend upon IWC mixing ratio.
d5266 1
a5266 1
! Reorganization of representation for molecules and beta groups; PFA may be broken for now
d5281 1
a5281 1
! get_beta_path_m.f90
d5350 1
a5350 1
! to get sum of beta over all lines; put slabs_struct instead of its components
d5389 1
a5389 1
! Multiply beta_path_polarized_f by tanh1_f if derivatives needed
d5460 2
a5461 2
! coarse grid alpha_path_polarized (1/4 1/2 1/4) instead of to diagonal of
! incoptdepth_pol.  This make alpha_path_polarized correct for later use
d5523 1
a5523 1
! Move multiplication of beta_path by tanh into FullForwardModel
d5610 1
a5610 1
! Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
d5651 1
a5651 1
! change input for get_beta_path_cloud
d5678 1
a5678 1
! changes dimension for beta_path_cloud also delocate it
d5681 1
a5681 1
! fixes gl_ind bug and interfaces to get_beta
d5684 1
a5684 1
! changes made after adding get_beta_path_cloud
d5710 1
a5710 1
! Squash a bug in deallocating beta_path_polarized
d5722 1
a5722 1
! change z_path to z_path_c in passing to get_beta_path
d5725 1
a5725 1
! add Inc_Cld to get_beta_path
d5731 1
a5731 1
! add z_path to get_beta_path
@


2.356
log
@Use height above geoid for interpolating the magnetic field to the path.
@
text
@d3110 1
d3305 1
a3305 1
              & eta_IWC_path_c, atmos_der, temp_der,  &
d3315 1
a3315 1
           &                     FwdModelOut, Sideband, Frq, MAF, Phitan, &
d3319 6
a3324 3
          call Get_TScat ( fwdModelIn, fwdModelExtra, &
            &              deg2rad*fwdModelConf%phiWindow, MAF, phitan, frq,   &
            &              z_coarse, phi_path_c, tan_pt_c, grids_f,            &
d4799 1
a4799 1
       "$Id: FullForwardModel_m.f90,v 2.355 2015/05/01 02:08:36 vsnyder Exp $"
d4809 3
@


2.355
log
@Interpolate in height or zeta for magnetic field
@
text
@d4305 6
a4310 3
          ! load_sps_data_m%Fill_Grids_2 has converted geodetic altitude
          ! to geocentric altitude, and converted either one to km.
          call comp_eta_docalc_no_frq ( grids_mag, h_path(1:npf), &
d4795 1
a4795 1
       "$Id: FullForwardModel_m.f90,v 2.354 2015/04/11 01:26:03 vsnyder Exp $"
d4805 3
@


2.354
log
@Add more dumps, add (km) to comments about h_path and h_glgrid
@
text
@d406 2
a407 1
    use INTRINSIC, only: L_A, L_RADIANCE, L_TSCAT, L_VMR
d4303 10
a4312 2
        call comp_eta_docalc_no_frq ( grids_mag, h_path(1:npf), &
          &  phi_path(1:npf), eta_mag_zp(1:npf,:), tan_pt=tan_pt_f )
d4792 1
a4792 1
       "$Id: FullForwardModel_m.f90,v 2.353 2015/03/28 02:16:24 vsnyder Exp $"
d4802 3
@


2.353
log
@Compute the viewing azimuth to determine whether cross-track viewing is
taking place.  Use Orbit_Plane_Minor_Axis_sq from Geometry.  Use 3-d
Value field for ECRtoFOV array.  Use Norm2 to normalize Mag_Path.
@
text
@d104 1
d256 2
d622 3
a624 3
    real(rp) :: H_PATH(max_f)         ! Heights on path
    real(rp) :: H_PATH_C(max_c)       ! H_PATH on coarse grid
    real(rp) :: H_PATH_F(max_f)       ! H_PATH on fine grid
d690 1
a690 1
    real(rp) :: H_GLGRID(maxVert,no_sv_p_t)        ! H on glGrid surfs
d4341 1
d4783 1
a4783 1
       "$Id: FullForwardModel_m.f90,v 2.352 2014/09/05 20:49:32 vsnyder Exp $"
d4793 5
@


2.352
log
@Avoid reference to undefined array elements
@
text
@d48 1
d76 5
d159 1
a159 1
    call load_one_item_grid ( grids_tmp, temp, phitan, fmStat%maf, fwdModelConf, .true. )
d246 4
d251 4
a254 3
        & GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,      &
        & quantityType=l_magneticField, config=fwdModelConf ), phitan, &
        & fmStat%maf, fwdModelConf, .false. )
d266 1
a266 1
      call load_one_item_grid ( grids_IWC, cloudIce, phitan, fmStat%maf, &
a417 1
! use TESTFIELD_M
d1276 1
a1276 1
      use Geometry, only: Earth_Axis_Ratio_Squared_m1, EarthRadA
d1383 4
a1386 8
  !{ Compute minor axis of orbit plane projected Earth ellipse $c$, where
  !  $c^2 = \frac{a^2\,b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta} =
  !         \frac{a^2}{\left(\frac{a^2}{b^2}-1\right) \sin^2 \beta + 1}$.
  !  This is Equation (5.3) in the 19 August 2004 ATBD JPL D-18130.

      earthradc_sq = earthRadA**2 / &
                   &     ( Earth_Axis_Ratio_Squared_m1 * &
                   &       SIN(orbIncline%values(1,maf)*Deg2Rad)**2 + 1 )
d3190 1
a3190 1
        call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, &
d3215 2
a3216 2
          call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false.)
          call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false.)
d4282 1
a4282 1
        call comp_eta_docalc_no_frq ( Grids_IWC, z_path(1:npf), &
d4299 1
a4299 1
        call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:npf), &
d4303 1
a4303 1
        call comp_sps_path ( Grids_mag, 1, eta_mag_zp(1:npf,:), &
d4311 3
a4313 1
        rot = reshape(ECRtoFOV%values(9*mif-8:9*mif,maf), (/3,3/))
d4322 1
a4322 1
          mag_path(j,4) = sqrt(sum(mag_path(j,1:3)**2))
d4779 1
a4779 1
       "$Id: FullForwardModel_m.f90,v 2.351 2014/08/01 01:06:05 vsnyder Exp $"
d4789 3
@


2.351
log
@Add code to fill real arrays with sNaN if the private parameter NaN_Fill
is true.  Set p_path to zero between the tangent points, so it's not
undefined.  It's not actually used for anything productive, but if the
compiler has an option to fill with sNaN, and those elements are referenced
(and the results subsequently not used), a pointless trap occurs.
@
text
@d999 7
a1005 4
    ! Put zeros into eta_zp so that comp_eta_docalc_no_frq doesn't do it in
    ! every call.  Most of its time is spent doing this.  Instead, when
    ! eta_zp is computed, the nonzeros (encoded by nz_zp and nnz_zp) are
    ! first replaced by zeros.
d1009 1
d1011 6
a1016 3
    ! Put zeros into eta_fzp so that comp_sps_path_frq_nz doesn't do it in
    ! every call.  Instead, when eta_fzp is computed, the nonzeros (encoded
    ! by nz_fzp and nnz_fzp) are first replaced by zeros.
d1020 1
d1022 4
a1025 4
    ! Put zeros into eta_zxp_t so that metrics doesn't do it in every call.
    ! Instead, when eta_zp is computed, the nonzeros (encoded by nz_zp and
    ! nnz_zp) are first replaced by zeros.  Metrics doesn't spend much time
    ! doing this. We want this representation for dt_script_dt.
d4771 1
a4771 1
       "$Id: FullForwardModel_m.f90,v 2.350 2014/07/18 23:15:44 pwagner Exp $"
d4781 7
@


2.350
log
@Aimed for consistency in names passed to allocate_test
@
text
@d26 7
a32 4
  integer, private, parameter :: Max_New = NGP1 ! Maximum new points in
    ! coarse path in addition to ones derived from the preselected zeta grid:
    ! the minimum zeta point plus NG H_Glgrid intersections below the
    ! tangent zeta.
d390 1
d540 1
a540 1
    logical :: Print_Rad          ! For debugging, from -Srad
d687 1
a689 1
    real(rp) :: SPS_PATH(max_f,no_mol)             ! species on path
d895 54
d965 1
a965 1
    print_Rad = switchDetail(switches, 'rad') > -1
d1186 1
a1186 1
    if ( print_Rad ) then
d4121 1
d4588 6
d4763 1
a4763 1
       "$Id: FullForwardModel_m.f90,v 2.349 2014/01/11 01:28:53 vsnyder Exp $"
d4773 3
@


2.349
log
@Decruftification
@
text
@d2228 1
a2228 1
        & 'Beta_Path_c', moduleName )
d2231 1
a2231 1
        & max(maxNoPtgFreqs,noUsedChannels), 'Inc_Rad_path', moduleName )
d4698 1
a4698 1
       "$Id: FullForwardModel_m.f90,v 2.348 2013/08/31 02:30:03 vsnyder Exp $"
d4708 3
@


2.348
log
@Improve tracing
@
text
@a87 1
    integer :: Mol              ! A molecule's lit index
d192 1
a192 1
              & datum=(/ fwdModelConf%name, lit_indices(mol), lit_indices(mol) /) )
d4698 1
a4698 1
       "$Id: FullForwardModel_m.f90,v 2.347 2013/08/30 03:56:23 vsnyder Exp $"
d4708 3
@


2.347
log
@Revise use of trace_begin and trace_end
@
text
@d993 1
a993 1
    call Trace_Begin ( Me_Hydro, 'ForwardModel.Hydrostatic', &
d1849 1
a1849 1
      call trace_begin ( me, 'ForwardModel.Frequency_Average_Derivative ', &
d1863 1
a1863 1
        call trace_end ( 'ForwardModel.Frequency_Average_Derivative ', &
d1923 1
a1923 1
      call trace_end ( 'ForwardModel.Frequency_Average_Derivative ', &
d3047 1
a3047 1
      call Trace_Begin ( 'ForwardModel.One_Frequency ', index=frq_i, &
d3757 1
a3757 1
      call Trace_End ( 'ForwardModel.One_Frequency ', index=frq_i, &
d3820 1
a3820 1
      call Trace_Begin ( me, 'ForwardModel.Pointing ', index=ptg_i, &
d3978 1
a3978 1
          call trace_end ( 'ForwardModel.Pointing ', index=ptg_i, &
d4537 1
a4537 1
      call trace_end ( 'ForwardModel.Pointing ', index=ptg_i, &
d4699 1
a4699 1
       "$Id: FullForwardModel_m.f90,v 2.346 2013/08/17 02:56:19 vsnyder Exp $"
d4709 3
@


2.346
log
@Regularize trace usage
@
text
@d106 1
d126 2
a127 2
    if ( toggle(emit) ) & ! set by -f command-line switch
      & call trace_begin ( 'FullForwardModel, MAF=', index=fmstat%maf )
d337 1
a337 1
    if ( toggle(emit) ) call trace_end ( 'FullForwardModel, MAF=', fmStat%maf )
d488 5
d889 2
a890 2
    if ( toggle(emit) ) & ! set by -f command-line switch
      & call trace_begin ( 'FullForwardModelAuto, MAF=', index=fmstat%maf )
d993 2
a994 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_Begin ( 'ForwardModel.Hydrostatic' )
d1014 4
a1017 4
    if ( toggle(emit) .and. levels(emit) > 0 ) then
      call Trace_End ( 'ForwardModel.Hydrostatic' )
      call Trace_Begin ( 'ForwardModel.SidebandLoop' )
    end if
d1022 2
a1023 2
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call Trace_Begin ( 'ForwardModel.Sideband ', index=thisSideband )
d1046 2
a1047 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call Trace_Begin ( 'ForwardModel.PointingLoop' )
d1075 2
a1076 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call Trace_End ( 'ForwardModel.PointingLoop' )
d1105 2
a1106 2
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call trace_end ( 'ForwardModel.Sideband ',index=thisSideband )
d1110 2
a1111 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_End ( 'ForwardModel.SidebandLoop' )
d1180 2
a1181 1
    if ( toggle(emit) ) call trace_end ( 'FullForwardModelAuto, MAF=', fmStat%maf )
d1207 4
a1210 2
      if ( toggle(emit)  .and. levels(emit) > 0 ) &
      &  call trace_begin ( 'ForwardModel.Both_Sidebands_Setup' )
d1317 2
a1318 2
      if ( toggle(emit) .and. levels(emit) > 0 ) &
      &  call trace_end ( 'ForwardModel.Both_Sidebands_Setup' )
d1407 1
d1424 2
a1425 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call trace_begin ( 'ForwardModel.Convolution' )
d1643 2
a1644 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call trace_end ( 'ForwardModel.Convolution' )
d1660 2
a1661 1
      type (VectorValue_T), pointer :: WORK   ! Temporary stuff
d1663 2
a1664 2
      if ( toggle(emit)  .and. levels(emit) > 0 ) &
      &  call trace_begin ( 'ForwardModel.Convolution_Setup' )
d1715 2
a1716 2
      if ( toggle(emit) .and. levels(emit) > 0 ) &
      &  call trace_end ( 'ForwardModel.Convolution_Setup' )
d1737 1
d1739 2
a1740 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call trace_begin ( 'ForwardModel.Frequency_Average' )
d1827 2
a1828 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call trace_end ( 'ForwardModel.Frequency_Average' )
d1845 3
a1847 2
      real(rp) :: R    ! Frequency-averaged value
      integer :: SV_I  ! State-vector index
d1849 2
a1850 2
      if ( toggle(emit) .and. levels(emit) > 6 ) &
        call trace_begin ( 'ForwardModel.Frequency_Average_Derivative ', index=mol )
d1863 2
a1864 2
        if ( toggle(emit) .and. levels(emit) > 6 ) &
          call trace_end ( 'ForwardModel.Frequency_Average_Derivative ', index=mol )
d1923 2
a1924 2
      if ( toggle(emit) .and. levels(emit) > 6 ) &
        call trace_end ( 'ForwardModel.Frequency_Average_Derivative ', index=mol )
d1936 3
a1938 2
      integer :: K  ! Loop inductor
      integer :: UB ! Upper bound for first dimension of k_..._frq
d1940 2
a1941 2
      if ( toggle(emit) .and. levels(emit) > 5 ) &
        call trace_begin ( 'ForwardModel.Frequency_Average_Derivatives' )
d1981 2
a1982 2
      if ( toggle(emit) .and. levels(emit) > 5 ) &
        call trace_end ( 'ForwardModel.Frequency_Average_Derivatives' )
d2374 1
d2397 1
a2397 1
      if ( toggle(emit) ) call Trace_Begin ( 'Generate_TScat' )
d2917 1
a2917 1
      if ( toggle(emit) ) call Trace_End ( 'Generate_TScat' )
d3029 1
d3047 2
a3048 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call Trace_Begin ( 'ForwardModel.One_Frequency ', index=frq_i )
d3757 2
a3758 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call Trace_End ( 'ForwardModel.One_Frequency ', index=frq_i )
d3809 2
d3820 2
a3821 2
      if ( toggle(emit) .and. levels(emit) > 3 ) &
        & call Trace_Begin ( 'ForwardModel.Pointing ', index=ptg_i )
d3827 2
a3828 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call Trace_Begin ( 'ForwardModel.Metrics_Etc' )
d3976 4
a3979 4
          if ( toggle(emit) ) then
            if ( levels(emit) > 4 ) call trace_end ( 'ForwardModel.Metrics_Etc' )
            if ( levels(emit) > 3 ) call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )
          end if
d4362 2
a4363 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call trace_end ( 'ForwardModel.Metrics_Etc' )
d4537 2
a4538 2
      if ( toggle(emit) .and. levels(emit) > 3 ) &
        & call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )
d4699 1
a4699 1
       "$Id: FullForwardModel_m.f90,v 2.345 2013/08/08 02:35:25 vsnyder Exp $"
d4709 3
@


2.345
log
@Set Qty_Stuff%derivOK if ExtraJacobian is present
@
text
@d336 1
a336 1
    if ( toggle(emit) ) call trace_end ( 'FullForwardModel MAF=', fmStat%maf )
d1174 1
a1174 1
    if ( toggle(emit) ) call trace_end ( 'FullForwardModelAuto MAF=', fmStat%maf )
d4681 1
a4681 1
       "$Id: FullForwardModel_m.f90,v 2.344 2013/08/02 01:24:06 vsnyder Exp $"
d4691 3
@


2.344
log
@Add ExtraJacobian to compute derivatives not in state vector
@
text
@d155 3
d176 8
d187 6
a192 9
          if ( .not. fwdModelConf%beta_group(k)%qty%foundInFirst ) then
            ! If the vector quantity for the desired molecule is not in the
            ! "first" state vector, check whether there's an ExtraJacobian.
            if ( .not. present(extraJacobian) ) &
              & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
                & 'With config(%S): ' // &
                & '%S derivative requested but %S is not in "first" state vector, ' // &
                & 'or ExtraJacobian is not present', &
                & datum=(/ fwdModelConf%name, lit_indices(mol), lit_indices(mol) /) )
d1600 1
a1600 1
            & call interpolate_other_deriv ( coeffs, maf, chanInd, ptg_angles, &
d4681 1
a4681 1
       "$Id: FullForwardModel_m.f90,v 2.343 2013/07/13 00:06:20 vsnyder Exp $"
d4691 3
@


2.343
log
@Move computation of tangent pressures from Compute_Z_PSIG to Tangent_Pressures.
Remove declarations for unused symbols.
@
text
@d36 2
a37 1
                             &  FwdModelOut, FmStat, Jacobian, Hessian )
d69 1
d121 1
a121 1
    logical :: sps_in_first, temp_der, temp_in_first
d176 10
a185 14
          ! Check that there is a vector quantity for the desired molecule
          ! in the "first" state vector.  Otherwise, there's no place to
          ! store the derivative in the Jacobian.
          mol = fwdModelConf%beta_group(k)%molecule
          ! All we want here is the SPS_in_first side effect
          if ( associated( &
            & GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
            &  quantityType=l_vmr, molecule=mol, &
            &  foundInFirst=sps_in_first, config=fwdModelConf )) ) continue
          if ( .not. sps_in_first ) &
            & call MLSMessage ( DerivativeMissingFromStateFun(), moduleName, &
            & 'With config(%S): ' // &
            & '%S derivative requested but %S is not in "first" state vector', &
            & datum=(/ fwdModelConf%name, lit_indices(mol), lit_indices(mol) /) )
d194 34
d315 1
a315 1
                              & Jacobian, Hessian )
d356 1
a356 1
                             & Jacobian, Hessian )
d455 6
d1543 1
a1543 1
            & Jacobian, fmStat%rows )
d1557 2
a1558 1
              & real(k_spect_dv(i,:,:),kind=rp), Jacobian, fmStat%rows )
d1563 2
a1564 1
              & real(k_spect_dw(i,:,:),kind=rp), Jacobian, fmStat%rows )
d1569 2
a1570 1
              & real(k_spect_dn(i,:,:),kind=rp), Jacobian, fmStat%rows )
d1595 2
a1596 1
              & real(k_atmos(i,:,:),kind=rp), Jacobian, fmStat%rows, linear=.true. )
d1602 2
a1603 1
              & real(k_spect_dv(i,:,:),kind=rp), Jacobian, fmStat%rows, linear=.true. )
d1609 2
a1610 1
              & real(k_spect_dw(i,:,:),kind=rp), Jacobian, fmStat%rows, linear=.true. )
d1616 2
a1617 1
              & real(k_spect_dn(i,:,:),kind=rp), Jacobian, fmStat%rows, linear=.true. )
d4673 1
a4673 1
       "$Id: FullForwardModel_m.f90,v 2.342 2013/06/12 02:35:22 vsnyder Exp $"
d4683 4
@


2.342
log
@Make Z_psig allocatable instead of pointer
@
text
@d58 1
a82 1
    type (VectorValue_T), pointer :: SPS    ! A species component of state vector
d178 5
a182 3
          sps => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_vmr, molecule=mol, &
            & foundInFirst=sps_in_first, config=fwdModelConf )
d222 5
a226 6
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, no_tan_hts,   &
        &                   surfaceTangentIndex, z_psig, tan_press, &
        &                   GetQuantityForForwardModel (            &
        &                    fwdModelOut, quantityType=l_TScat,     &
        &                    signal=fwdModelConf%signals(1)%index,  &
        &                    config=fwdModelConf ) )
d229 1
a229 2
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, no_tan_hts,   &
        &                   surfaceTangentIndex, z_psig, tan_press )
d231 3
d293 1
a293 1
    ! Allocated in Compute_Z_PSIG:
d299 8
a306 10
    function DerivativeMissingFromStateFun() result( SEVERITY )
    ! Default severity (probably ERROR) can be reduced to a warning 
    ! by adding -Sdmiss to command line
    ! Args
    integer :: SEVERITY
    if ( switchDetail(switches,'dmiss') > -1 ) then ! be lenient
      severity = min( MLSMSG_Warning, DerivativeMissingFromState )
    else
      severity = DerivativeMissingFromState
    endif
d308 1
a346 1
    use GLNP, only: GX
d4628 1
a4628 1
       "$Id: FullForwardModel_m.f90,v 2.341 2013/05/22 00:19:10 vsnyder Exp $"
d4638 3
@


2.341
log
@Remove unreferenced USE names
@
text
@d69 1
a69 1
    real(rp), pointer :: Z_PSIG(:)       ! Surfs from Temperature, tangent grid
d126 1
a126 1
    nullify ( z_psig, tan_press )
a291 1
    call deallocate_test ( z_psig,       'z_psig',       moduleName )
a730 1
    real(rp), parameter :: Min_Phi_Tol = 0.25 * gx(1)**2 ! First GL point
a2270 1
      real(rp) :: Ref_Ht       ! Height of the ray at the reference phi
a2510 3
          ! Height of the ray at the phi_ref
          ref_ht = scat_ht * cos(dPhi)

d3002 4
a3005 4
      sps_path_c(i_start:i_end,:) = sps_path(ngp1*i_start-ng:ngp1*i_end-ng:ngp1,:)
!c      associate ( sps_path_x => sps_path(1:npf:ngp1,:) )
!c        sps_path_c(i_start:i_end,:) = sps_path_x(i_start:i_end,:)
!c      end associate
d3895 4
a3898 4
              call dump ( h_path(:scat_index*ngp1-ng:ngp1), name='H_Path_C' )
!c              associate ( h_path_x => h_path(1:npf:ngp1) )
!c                call dump ( h_path_x(:scat_index), name='H_Path_C' )
!c              end associate
d4627 1
a4627 1
       "$Id: FullForwardModel_m.f90,v 2.340 2013/05/18 00:34:43 vsnyder Exp $"
d4637 3
@


2.340
log
@Insert NG fine-grid (GL) points between tangent points, thereby
regularizing coarse-grid spacing, and reducing significantly the need
to use c_inds to extract coarse-grid points from the composite grid.
@
text
@d43 1
a43 2
    use FORWARDMODELCONFIG, only: DERIVEFROMFORWARDMODELCONFIG, &
      & DESTROYFORWARDMODELDERIVED, DUMP, FORWARDMODELCONFIG_T
d628 1
a628 1
    real(rp) :: RADIANCES_DIFF(noUsedChannels,no_tan_hts) ! (noChans,Nptg)     ! IGOR
a1339 1
        & CONVOLVE_RADIANCE_NORMALIZATION, CONVOLVE_TEMPERATURE_DERIV_NORMALIZATION, &
d1342 2
d1357 1
a1357 1
      real(r8) :: RAD_DIFF_FFT(s_t*no_fft) ! FFT(I-IA)                         ! IGOR
d3006 1
d3009 3
a3711 1
      use OUTPUT_M, only: NEWLINE
d3902 3
d4633 1
a4633 1
       "$Id: FullForwardModel_m.f90,v 2.339 2013/04/09 18:23:56 pwagner Exp $"
d4643 5
@


2.339
log
@Fixed error in failing to use DerivativeMissingFromStateFun
@
text
@d16 1
a16 1
  use GLNP, only: NGP1
d28 1
a28 1
    ! the minimum zeta point plus three H_Glgrid intersections below the
d141 2
a142 3
      & quantityType=l_phitan, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule, &
      & config=fwdModelConf )
d144 2
a145 3
      & quantityType=l_ptan, &
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule, &
      & foundInFirst=ptan_der, config=fwdModelConf )
d147 2
a148 2
      & quantityType=l_temperature, &
      & foundInFirst=temp_in_first, config=fwdModelConf )
d207 2
a208 1
        & quantityType=l_vmr, molecule=l_cloudIce, config=fwdModelConf, noError=.true. )
d225 2
a226 1
        &                    signal=fwdModelConf%signals(1)%index ) )
d505 2
a506 2
    integer :: F_INDS(max_f)            ! Indices on fine grid
    integer, target :: GL_INDS_B(max_f) ! Base array for GL_INDS
d548 1
a548 1
    real(rp) :: DSDH_PATH(max_f)      ! dS/dH on fine path (1:tan_pt_f-1,tan_pt_f+2:npf)
d562 2
a563 1
    real(rp) :: PHI_PATH(max_f)       ! Phi's on fine path, Radians
d1102 2
a1103 1
            & signal=fwdModelConf%signals(channels(i)%signal)%index, sideband=sideband )
d1107 2
a1108 1
            & signal=fwdModelConf%signals(channels(i)%signal)%index, sideband=sideband )
d1192 2
a1193 1
      gph => GetQuantityForForwardModel (fwdModelIn, fwdModelExtra, quantityType=l_gph )
d1204 1
a1204 1
        & quantityType=l_scGeocAlt )
d1324 2
a1325 2
        boundaryPressure => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_boundaryPressure, config=fwdModelConf )
d1424 2
a1425 1
          & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband )
d1643 1
a1643 1
          & quantityType=l_l1bMIF_TAI )
d1646 1
a1646 1
          & quantityType=l_MIFDeadTime )
d1882 1
d2257 1
d2350 1
a2350 1
          & sideband=sideband )
d2702 1
a2702 1

d2736 2
a2737 1
            ! angles Xi at which radiative transfer was done.
a2742 1
              P_on_Xi(:i_r) = P_on_Xi(:i_r) * abs(sin(Xis(sort_xi(:i_r))))
a2748 1
                dP_dIWC_on_Xi(:i_r) = dP_dIWC_on_Xi(:i_r) * abs(sin(Xis(sort_xi(:i_r))))
a2754 9
                dP_dT_on_Xi(:i_r) = dP_dT_on_Xi(:i_r) * sin(Xis(sort_xi(:i_r)))
              if ( print_TScat_deriv > 1 ) then
                call output ( f_i, before='K_temp_TScat(' )
                call output ( i_r, before=',sort_xi(:' )
                call dump ( k_temp_TScat(f_i,sort_xi(:i_r),:), name='),:)' )
                call dump ( rad2deg*Xis(sort_xi(:i_r)), name='Xis' )
                call dump ( P_on_Xi(:i_r), name='P_on_Xi' )
                call dump ( dP_dT_on_Xi(:i_r), name='dP_dT_on_Xi' )
              end if
d2761 3
a2763 1
            ! We use acos(cos(x-y)) so as not to worry about negative angles, etc.
d2766 1
a2766 2
              &          p_on_xi(  1)*rads(f_i,sort_xi(  1)) ) * &
              &        acos(cos(xis(sort_xi(1)) - xis(sort_xi(i_r))) )
d2770 1
a2770 2
                &          p_on_xi(  1)*k_atmos_TScat(f_i,sort_xi(  1),:) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
d2774 1
a2774 2
                  &          dP_dIWC_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                  &      acos(cos(xis(sort_xi(1)) - xis(sort_xi(i_r))) )
d2779 1
a2779 2
                &          p_on_xi(  1)*k_temp_TScat(f_i,sort_xi(  1),:) ) * &
                &        acos(cos(xis(sort_xi(1)) - xis(sort_xi(i_r))) )
d2783 1
a2783 2
                  &          dP_dT_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                  &        acos(cos(xis(sort_xi(1)) - xis(sort_xi(i_r))) )
d2787 1
d2790 1
a2790 2
                &          p_on_xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
d2795 1
a2795 1
                  &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
d2800 1
a2800 1
                    &        ( xis(sort_xi(ptg_i  )) - xis(sort_xi(ptg_i-1)) )
d2806 1
a2806 1
                  &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
d2811 1
a2811 1
                    &        ( xis(sort_xi(ptg_i  )) - xis(sort_xi(ptg_i-1)) )
d2829 6
d2917 1
a2917 1
      use SCATSOURCEFUNC, only: T_SCAT, INTERP_TSCAT, CONVERT_GRID
d2992 2
d3006 4
a3009 1
      sps_path_c(:npc,:) = sps_path(c_inds,:)
d3024 4
a3027 4
          &  c_inds, beta_path_c, t_der_path_flags, dTanh_dT_c, vel_rel, &
          &  dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c,          &
          &  dbeta_dv_path_c, dBeta_df_path_c, grids_f%where_dBeta_df,   &
          &  sps_path )
d3031 3
a3033 3
        ! Compute Scattering source function based on temp prof at all
        ! angles U for each temperature layer assuming a plane parallel
        ! atmosphere.
d3108 6
a3113 4
          call convert_grid ( salb_path(1:npf,:), cext_path(1:npf,:),  &
                            & tt_path(1:npf,:), c_inds,                &
                            & beta_path_cloud_c(1:npc), w0_path_c,     &
                            & tt_path_c )
d3132 2
d3151 2
a3152 1
        incoptdepth(i_end+1:npc) = 0.0 ! if not integrating full path
d3177 1
a3177 1
            &              z_coarse, phi_path(c_inds), tan_pt_c, grids_f,      &
d3184 2
d3196 3
a3198 1
          !  T_Script and B needed to compute inc_rad_path by rad_tran_pol
d3311 1
a3311 1
        ! This avoids having four paths through the code, each with a
d3344 2
a3345 1
!!!! TScat computation needs incoptdepth(:i_end-1), but this breaks the gold brick
d3391 2
a3392 2
          & i_start, i_stop, i_end, phi_path(c_inds), z_path(c_inds), &
          & sps_path_c(:npc,:), beta_path_c, alpha_path_c, incoptdepth, &
d3467 2
a3468 2
          call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f,      &
            &  eta_fzp, do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,    &
d3483 2
a3484 2
          call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f,      &
            &  eta_fzp, do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,    &
d3503 2
a3504 2
          call d2rad_tran_df2 ( max_f, c_inds, gl_inds, del_zeta, Grids_f,    &
            &  eta_fzp, do_calc_fzp, do_gl, del_s, ref_corr, dsdz_gw_path,    &
d3517 5
a3521 6
          call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop),    &
            &  Grids_f, beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc), &
            &  eta_fzp, do_calc_fzp, sps_path, del_s,                     &
            &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),         &
            &  d_delta_df(1:npc,:), nz_d_delta_df, nnz_d_delta_df,        &
            &  de_df(:,:,1:p_stop,:) )
d3574 1
a3574 1
          call drad_tran_dt ( c_inds, gl_inds, del_zeta, h_path_c,         &
d3647 1
a3647 1
        end if
d3649 1
a3649 1
      end if
d3664 4
a3667 5
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_w,      &
              &  eta_zxp_w, sps_path, fwdModelConf%lineWidth%beta(sx),     &
              &  do_calc_w, dbeta_dw_path_c, dbeta_dw_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dw_frq )
d3672 4
a3675 5
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_n,      &
              &  eta_zxp_n, sps_path, fwdModelConf%lineWidth_tDep%beta(sx),&
              &  do_calc_n, dbeta_dn_path_c, dbeta_dn_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dn_frq )
d3680 4
a3683 5
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_v,      &
              &  eta_zxp_v, sps_path, fwdModelConf%lineCenter%beta(sx),    &
              &  do_calc_v, dbeta_dv_path_c, dbeta_dv_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dv_frq )
d3770 1
a3770 1
      npf = 2 * tan_pt_f
d3774 3
a3776 1
      c_inds = (/(i*Ngp1-Ng,i=1,tan_pt_c),((i-1)*Ngp1-Ng+1,i=tan_pt_c+1,npc)/)
d3832 2
a3833 2
          scat_d1 = sin(phi_path(c_inds(scat_temp))-scat_phi)**2 + &
                  &  (h_path(c_inds(scat_temp))/scat_ht-1.0_rp)**2
d3869 2
a3870 2
            & rad2deg*tan_phi, tan_ht, rad2deg*phi_path(1), c_inds(scat_index), &
            & rad2deg*phi_path(c_inds(scat_index)), which, myRev
d3885 3
a3887 3
              call dump ( z_coarse(:size(c_inds)), name="Z_Coarse" )
              call dump ( rad2deg*phi_path(c_inds), name="Phi_Path", format="(f14.8)" )
              call dump ( h_path(c_inds), name="H_Path", format="(f14.6)" )
d3897 2
a3898 2
              call dump ( rad2deg*phi_path(c_inds(:scat_index)), name=', Phi_Path_C' )
              call dump ( h_path(c_inds(:scat_index)), name='H_Path_C' )
d3992 3
a3994 2
      call compute_GL_grid ( z_coarse(tan_pt_c+1:npc), z_path(tan_pt_f+1:npf), &
        &                    p_path(tan_pt_f+1:npf) )
d3996 2
a3997 1
      ! The 0.5 factor is to compensate for the GL weights adding up to 2.0.
d3999 4
a4002 4
      del_zeta(2:tan_pt_c) = 0.5_rp * ( z_path(c_inds(1:tan_pt_c-1)) - &
        &                               z_path(c_inds(2:tan_pt_c)) )
      del_zeta(tan_pt_c+1:npc-1) = 0.5_rp * ( z_path(c_inds(tan_pt_c+2:npc)) - &
        &                                     z_path(c_inds(tan_pt_c+1:npc-1)) )
d4022 1
a4022 2
          call refractive_index ( p_path(1:npf), t_path(1:npf), &
            &  n_path_f(1:npf),  &
d4026 1
a4026 1
          n_path_c(:npc) = n_path_f(c_inds)
d4030 2
d4036 2
a4037 1
        phi_path(tan_pt_f+1:npf) = phi_path(tan_pt_f+1:npf) + t_path(tan_pt_f+1:npf)
d4053 8
a4060 6
        dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds,:)
        do_calc_hyd(:c_inds(i_start)-1,:) = .false.
        do_calc_hyd(c_inds(i_end)+1:npf,:) = .false.
        do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds,:)
        do_calc_t_c(1:npc,:) = do_calc_t(c_inds,:)
        eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds,:)
d4068 2
a4069 2
      h_path_c(1:npc) = h_path(c_inds)
      t_path_c(1:npc) = t_path(c_inds)
d4100 1
a4100 1
        call refractive_index ( p_path(c_inds), &
d4102 1
a4102 1
          &  h2o_path=sps_path(c_inds, h2o_ind) )
d4107 1
a4107 1
        n_path_c(:npc) = n_path_f(c_inds)
d4221 1
d4224 8
a4231 6
      ! We need dsdh_path on the fine grid for Gauss-Legendre or Gauss-
      ! Lobatto quadrature, and on the coarse grid except at the tangent
      ! point for trapezoidal quadrature and Gauss-Lobatto quadrature, so
      ! compute it everywhere except at the tangent point.  Besides, it's
      ! probably faster not to use a vector subscript to restrict it to
      ! the fine grid.
d4235 3
a4237 3
      dsdh_path(tan_pt_f+2:npf) = h_path(tan_pt_f+2:npf) / &
        & ( sqrt(h_path(tan_pt_f+2:npf)**2 - tan_ht**2 ) )
      dsdh_path(tan_pt_f:tan_pt_f+1) = 0.0
d4249 1
a4249 1
        dsdz_c(:npc) = dsdh_path(c_inds) * dhdz_path(c_inds)
d4285 1
a4285 1
        call get_eta_stru ( iwc_s, iwc_path(c_inds,1), eta_IWC_path_c )
d4627 1
a4627 1
       "$Id: FullForwardModel_m.f90,v 2.338 2013/02/04 22:06:27 pwagner Exp $"
d4637 3
@


2.338
log
@Added dmiss switch to downgrade severity when qty missing from state
@
text
@d163 1
a163 1
      & call MLSMessage ( DerivativeMissingFromState, moduleName, &
d185 1
a185 1
            & call MLSMessage ( DerivativeMissingFromState, moduleName, &
d4605 1
a4605 1
       "$Id: FullForwardModel_m.f90,v 2.337 2013/01/23 21:24:26 vsnyder Exp $"
d4615 3
@


2.337
log
@Use |sin| in TScat phase convolution
@
text
@d297 12
d4605 1
a4605 1
       "$Id: FullForwardModel_m.f90,v 2.336 2012/08/08 20:06:37 vsnyder Exp $"
d4615 3
@


2.336
log
@Use CreateVectorValue, DestroyVectorQuantityValue in full cloud model.
Exchange subscript ordering for vmrArray to improve locality.
@
text
@d2723 1
a2723 1
              P_on_Xi(:i_r) = P_on_Xi(:i_r) * sin(Xis(sort_xi(:i_r)))
d2730 1
a2730 1
                dP_dIWC_on_Xi(:i_r) = dP_dIWC_on_Xi(:i_r) * sin(Xis(sort_xi(:i_r)))
a3133 1
          ! We expect size(F_s) to be small, so MINLOC is fast enough.
d4593 1
a4593 1
       "$Id: FullForwardModel_m.f90,v 2.335 2012/07/07 00:14:33 vsnyder Exp $"
d4603 4
@


2.335
log
@Shorten some comments to avoid gripes about long lines
@
text
@d158 1
a158 1
    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der      
d358 2
a359 1
    use VECTORSMODULE, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T
d570 1
a570 1
    real(rp) :: D_DELTA_DF(max_c,s_a*size(grids_f%values)) ! Incremental 
d626 1
a626 1
    real(r8) :: VMRARRAY(no_mol,s_i*n_t_zeta)      ! The VMRs
d639 1
a639 1
    
d784 1
a784 1
    type (Channels_T), pointer, dimension(:) :: Channels 
d870 1
a870 1
    ! nz_d_delta_df and nnz_d_delta_df) by zeros. 
d894 1
a894 1
    ! Put zeros into eta_zxp_t so that metrics doesn't do it in every call. 
d1006 1
a1006 1
        
d1020 1
a1020 1
      
d1110 3
a1112 3
      call deallocate_test ( scat_src%values, 'scat_src%values', moduleName )
      call deallocate_test ( scat_alb%values, 'scat_alb%values', moduleName )
      call deallocate_test ( cld_ext%values,  'cld_ext%values',  moduleName )
d1259 1
d1291 1
a1291 1
                               & vmrArray(ispec,:),          &    ! New Y
d1296 10
a1305 4
      call allocate_test ( scat_src%values, n_t_zeta, fwdModelConf%num_scattering_angles, &
                           &'scat_src', moduleName )
      call allocate_test ( scat_alb%values, n_t_zeta, 2, 'scat_alb', moduleName )
      call allocate_test (  cld_ext%values, n_t_zeta, 2, 'cld_ext', moduleName )
d1367 1
a1367 1
      
d1386 1
a1386 1
          ! This value is above the previous one so compute a delta from it 
d1391 1
a1391 1
      
d1539 1
a1539 1
 
d1670 6
a1675 6
! Impossible                            x                      
! Radiances = RadV                         x x x x            
! K = K_frq                                  x   x            
! Frq Avg path integrated rad                          x x x  
! Combine total path radiances                     x x        
! Frq Avg path integrated LBL deriv                      x    
d1742 1
a1742 1
      
d1772 1
a1772 1
        ! previously-averaged or monochromatic LBL derivatives in K. 
d1977 1
a1977 1
          
d1983 1
a1983 1
        
d1985 1
a1985 1
        
d2005 1
a2005 1
          end do                ! Grid loop 1  
d2142 1
a2142 1
      call allocate_test ( dAlpha_dT_path_c, max_c, maxNoPtgFreqs, & 
d2576 1
a2576 1
                &                  scat_zeta, scat_phi, scat_ht,       & 
d2683 1
a2683 1
          
d2922 1
a2922 1
      real(rp), intent(in) :: Tan_Ht      ! Geometric tangent height, km, 
d3020 1
a3020 1
        ! ??? it uses the result for the last frequency.            ???
d3024 3
a3026 3
          call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),      & 
             & 10.0**(-temp%template%surfs), vmrArray(1,:), vmrArray(2,:), &
             & vmrArray(3,:),fwdModelConf%num_scattering_angles,           &
a3033 2
        scat_src%template = temp%template

d3060 1
a3060 1
          call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false.)             
d3091 3
a3093 3
          call convert_grid ( salb_path(1:npf,:), cext_path(1:npf,:),  & 
                            & tt_path(1:npf,:), c_inds,                & 
                            & beta_path_cloud_c(1:npc), w0_path_c,     & 
d3113 1
a3113 1
        call two_d_t_script_cloud ( t_path_c, tt_path_c, w0_path_c, &  
d3342 1
a3342 1
          ! by Tau to combine LBL and PFA.  Then sum to give RadV. 
d3612 2
a3613 2
            & deltau_pol(:,:,1:npc), de_dt(:,:,1:npc,:),       &      
            & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &      
d4261 1
a4261 1
! 
d4281 1
a4281 1
!       \frac{\partial I^s_n}{\partial x_k} =& 
d4342 1
a4342 1
! 
d4350 1
a4350 1
! $\overline{\delta I^s_{ic}}$ is {\tt Rad_Avg_Path} & 
d4353 1
a4353 1
! $\sum_{i=1}^{N_p} \delta I^\sigma_{iq}$ is {\tt RadV} & 
d4594 1
a4594 1
       "$Id: FullForwardModel_m.f90,v 2.334 2012/07/06 21:30:41 yanovsky Exp $"
d4604 3
@


2.334
log
@Make the module ready for making calls to Convolve_Radiance_Normalization and Convolve_Temperature_Deriv_Normalization that compute normalized Temperature derivatives.  These calls are currently commented.
@
text
@d85 1
d266 3
a268 3
    if ( switchDetail(switches,'fmconf') > -1 ) then
      call dump( FwdModelConf, details=1 )
    end if
d466 1
d838 1
d2204 2
d4588 1
a4588 1
       "$Id: FullForwardModel_m.f90,v 2.333 2012/06/15 23:33:13 vsnyder Exp $"
d4598 5
@


2.333
log
@Include sin(theta) factor in TScat phase convolution.  Improve dumps.
@
text
@d613 1
d1314 1
d1329 2
a1330 1
      real(r8) :: RAD_FFT(s_t*no_fft) ! Convolved radiance on FFT grid
d1440 4
d1447 8
a1454 1
              & Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, ptan_der, rad_FFT )
d1459 8
a1466 1
              & dx_dt, d2x_dxdt, dxdt_tan, dxdt_surface, Jacobian, fmStat%rows )
d4583 1
a4583 1
       "$Id: FullForwardModel_m.f90,v 2.332 2012/02/13 23:20:12 pwagner Exp $"
d4593 3
@


2.332
log
@DerivativeMissingFromState eases switch from strict to lenient
@
text
@d476 2
a477 2
    logical :: Print_TScat_Deriv  ! For debugging, Temp deriv, from -Sdtsct
    integer :: Print_TScat_Detail ! For debugging, from -S[pP]sct
d845 2
a846 4
    Print_TScat_Deriv = switchDetail(switches, 'dtsct' ) > -1
    print_TScat_detail = 0
    if ( switchDetail(switches, 'psct' ) > -1 ) print_TScat_detail = 1
    if ( switchDetail(switches, 'Psct' ) > -1 ) print_TScat_detail = 2
d2290 1
a2290 1
      if ( print_TScat .or. print_TScat_detail > 0 ) &
d2299 1
a2299 1
        if ( print_TScat .or. print_TScat_detail > 0 ) then
d2330 1
a2330 1
      if ( print_TScat_detail > 1 .and. .not. print_TScat_Deriv .and. .not. &
d2447 1
a2447 1
                call store_other_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
d2453 1
a2453 1
                call store_temperature_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
d2593 1
a2593 1
            if ( print_TScat_detail > 1 ) then
d2689 1
d2692 21
a2712 10
               & dP_dIWC(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
               & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
               & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
               & dP_dIWC_on_Xi(:i_r) )
            if ( temp_der ) &
              & call interpolate_P_to_theta_e ( &
               & dP_dT(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
               & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
               & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
               & dP_dT_on_Xi(:i_r) )
d2781 1
a2781 1
              & call store_other_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
d2784 2
a2785 2
            if ( temp_der ) &
              & call store_temperature_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
d2788 8
d3807 2
a3808 2
          &  print_TScat_detail > 0 ) then
          if ( print_TScat_detail /= 1 .or. print_TScat_Deriv .or. &
d3825 1
a3825 1
            if ( scat_ht <= tan_ht .or. which > 0 .or. print_TScat_detail > 0 ) then
d3839 1
a3839 1
            if ( print_TScat_detail > 1 ) then
d4452 1
a4452 1
        if ( print_tscat_deriv ) then
d4455 1
a4455 1
          call output ( i_r, before=' k_temp_TScat(:,', after=',:) ' )
d4457 1
d4562 1
a4562 1
       "$Id: FullForwardModel_m.f90,v 2.331 2012/02/10 23:51:33 vsnyder Exp $"
d4572 3
@


2.331
log
@Move DeriveFromForwardModelConfig to Retrieval module
@
text
@d43 2
a44 1
    use FORWARDMODELCONFIG, only: DUMP, FORWARDMODELCONFIG_T
d55 1
a55 1
    use MLSMESSAGEMODULE, only: MLSMSG_ERROR
d58 3
a60 3
    use MOREMESSAGE, ONLY: MLSMESSAGE
    use TOGGLES, only: Emit, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
d120 2
d162 1
a162 1
      & call MLSMessage ( MLSMSG_Error, moduleName, &
d183 4
a186 2
          if ( .not. sps_in_first ) call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'With config(%S): %S derivative requested but %S is not in "first" state vector', &
d4543 1
a4543 1
       "$Id: FullForwardModel_m.f90,v 2.330 2011/11/10 23:23:32 vsnyder Exp $"
d4553 3
@


2.330
log
@Correct computation of 'combine' argument in frequency averaging
@
text
@d43 1
a43 2
    use FORWARDMODELCONFIG, only: DERIVEFROMFORWARDMODELCONFIG, &
      & DESTROYFORWARDMODELDERIVED, DUMP, FORWARDMODELCONFIG_T
a124 2
    call deriveFromForwardModelConfig ( fwdModelConf )

a288 2
    call destroyForwardModelDerived ( fwdModelConf )

d1380 1
a1380 1
          & call Dump ( ptg_angles, 'ptg_angles (after patching)', format='(1PG22.17)' )
d4538 1
a4538 1
       "$Id: FullForwardModel_m.f90,v 2.329 2011/11/09 00:29:48 vsnyder Exp $"
d4548 3
@


2.329
log
@Monochromatic PFA, more debugging
@
text
@d196 1
a196 1
        & GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
d219 1
a219 1
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, no_tan_hts, &
d221 2
a222 2
        &                   GetQuantityForForwardModel ( &
        &                    fwdModelOut, quantityType=l_TScat, &
d226 1
a226 1
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, no_tan_hts, &
d629 1
a629 1
      &           any(fwdModelConf%anyLBL((fwdModelConf%sidebandStart+3)/2: &
d631 1
a631 1
      &   max(s_t,s_a,s_lc,s_lw,s_td) * & ! merge(1,0,any_der)
d858 1
a858 1
      & k_atmos_frq, k_spect_dn_frq, k_spect_dv_frq, k_spect_dw_frq, &
d1133 1
a1133 1
      use Intrinsic, only: L_EARTHREFL, L_ECRtoFOV, L_GPH, L_LOSVEL, &
d1281 1
a1281 1
        vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
d1708 1
a1708 1
        call frequency_average_derivatives ( ptg_i, combine=iand(frq_avg_sel,15) == 7 )
d4543 1
a4543 1
       "$Id: FullForwardModel_m.f90,v 2.327 2011/08/12 18:59:57 vsnyder Exp $"
d4553 3
@


2.328
log
@purehunt recovers optimized functionality of fwdmdls own hunt
@
text
@d57 1
a57 1
    use MOLECULES, only: FIRST_MOLECULE, LAST_MOLECULE, L_CLOUDICE
a324 1
    ! use D_HUNT_M, only: HUNT
a337 1
    use L2PC_M, only: L2PC_T
d345 1
a345 2
    use MOLECULES, only: FIRST_MOLECULE, LAST_MOLECULE, &
      & L_H2O, L_N2O, L_O3
a432 1
    integer :: NCG                ! Number of panels needing GL = Size(cg_inds)
d466 1
d469 1
a469 1
    logical :: Print_Path         ! Nicer format than Print_Incopt, for few molecules
d476 1
d478 4
d667 2
d836 1
d839 1
a839 1
    print_path = switchDetail(switches, 'path') > -1
d845 1
d1629 1
a1629 1
        & call trace_begin ( 'ForwardModel.FrequencyAvg' )
d1631 18
a1648 17
!          8 Frequency averaging?  N N Y Y - - Y Y - N
!          4 PFA?                  N N N N Y Y Y Y N Y
!          2 LBL?                  Y Y Y Y N N Y Y N Y
!          1 Derivatives?          N Y N Y N Y N Y - -
!            Frq_Avg_Sel value     2 3 A B C D E F
!
! =======================================================
!
! Impossible?                                          x
! Radiances = RadV                 x x x x     x x       
! K = K_frq                          x   x       x       
! Frq Avg path integrated rad              x x     x
! Combine total path radiances           x         x     
! Frq Avg path integrated LBL deriv          x       x
! Frq Avg rad Along Path                             x
! Combine radiances along path           x           x   
! Combine LBL and PFA derivs             x           x   
d1662 2
a1663 1
      case ( 2, 3, 6, 7, 12, 13 ) ! Just copy radiance. PFA + DACS - LBL impossible
d1665 9
a1677 1
            shapeInd = channels(c)%shapeInds(sx)
d1684 1
a1704 2
      case default          ! Impossible cases: No LBL or PFA,
                            ! PFA and no frequency averaging
d1708 1
a1708 2
        call frequency_average_derivatives ( ptg_i, frq_avg_sel == 15 )
        
d1717 1
a1717 1
        & call trace_end ( 'ForwardModel.FrequencyAvg' )
a1721 1

d1737 3
d1742 4
a1745 4
        ! previously-averaged LBL derivatives in K.  Remember that
        ! for PFA, the frequency dimension has extent noUsedChannels,
        ! not maxNoPtgFreqs.  The first dimension of K_frq is at least
        ! noUsedChannels, so we're guaranteed this will fit.
d1751 2
d1756 1
a1756 1
      ! Only possible values for Frq_avg_sel here are 3, 7, 11, 13, 15.
d1760 20
a1779 1
      case ( 11, 15 ) ! See Frequency_Average.
d1808 6
a1813 12
      case ( 3, 7, 13 )         ! Not frequency averaging, or PFA alone; copy.
        do sv_i = grids%l_v(mol-1)+1, grids%l_v(mol)
          if ( grids%deriv_flags(sv_i) ) then
            k(:,sv_i) = min ( max ( k_frq(:,sv_i), &
                          &   real(-huge(0.0_r4), rp ) ), &
                          &   real( huge(0.0_r4), rp ) )
          else
            k(:,sv_i) = 0.0
          end if
        end do
      case default             ! Impossible
      end select               ! Frequency averaging or not
d1827 3
a1834 1

d1867 3
d2065 1
a2065 1
                 &  tan_press, grids, allowTopValue=.TRUE., nearest=.TRUE. )
a2194 1
      use MATRIXMODULE_1, only: FINDBLOCK
a2257 1
      integer :: Mol           ! Loop inductor, for molecules
d2282 2
d2332 2
a2333 1
      if ( print_TScat_detail > 0 ) then
d2337 1
a2337 3
        call output ( &
          & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi Which Rev Fwd", &
          & advance="yes" )
d2529 19
a2547 12
            xi = dPhi_xi + dPhi - pi
            scat_tan_phi = scat_tan_phi + 2.0 * dphi_xi
            call one_tscat_ray ( ptg_i, 3, vel_rel, scat_tan_phi,    &
              &                  scat_zeta, scat_phi, scat_ht,       &
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, rev=.false. )

            xi = xi + pi
            call one_tscat_ray ( ptg_i, 4, vel_rel, scat_tan_phi,    &
              &                  scat_zeta, scat_phi, scat_ht,       & 
              &                  r_eq, xi, xis, rads, k_atmos_TScat, &
              &                  k_temp_TScat, i_r, rev=.true. )
d2646 7
a2652 3
          !{ Interpolate the phase function to IWC and Temperature at the
          !  scattering point and convolve the interpolated phase function
          !  with the interpolated radiances.  Let $x$ be temperature, $y$
d2686 2
a2687 1
            call interpolate_P_to_theta_e ( p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
d2692 5
a2696 4
              & call interpolate_P_to_theta_e ( dP_dIWC(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & dP_dIWC_on_Xi(:i_r) )
d2698 5
a2702 4
              & call interpolate_P_to_theta_e ( dP_dT(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & dP_dT_on_Xi(:i_r) )
d2765 1
d2838 1
a2838 1
      use DUMP_PATH_M, only: DUMP_PATH
d2903 1
a2903 1
      integer :: NCG                ! Number of panels needing GL = Size(cg_inds)
d2920 1
a2920 1
        & call Trace_Begin ( 'ForwardModel.One_Frequency', index=frq_i )
d3254 8
a3261 5
        call dump ( beta_path_c(i_start:i_end,:), name="Beta_Path_C" )
        call dump ( sps_path_c(i_start:i_end,:), name="SPS_Path" )
        call dump ( alpha_path_c(i_start:i_end), name="Alpha_Path_C" )
        call dump ( incoptdepth(i_start+1:i_end-1), name="Incoptdepth" )
        call dump ( del_s(i_start+1:i_end-1), name="Del_s" )
d3268 4
d3306 4
a3309 3
        if ( print_incopt ) then
          call dump ( tau%tau(i_start:i_stop,frq_i), name="Tau" )
          call dump ( inc_rad_path(i_start:i_stop), name="Inc_Rad_Path" )
d3314 4
a3317 3
        if ( print_path ) call dump_path ( fwdModelConf, i_start, i_end, &
          & phi_path(c_inds), z_path(c_inds), sps_path_c(:npc,:), beta_path_c, &
          & alpha_path_c, incoptdepth, frq_i, tau, inc_rad_path )
d3512 1
d3618 1
a3618 1
        & call Trace_End ( 'ForwardModel.One_Frequency, index=frq_i' )
a3667 3
      character(len=*), parameter :: TScat_Detail_Heading = &
        & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi Which Rev Fwd"

d3669 1
a3669 1
      character(max(128,len(TScat_Detail_Heading)+2)) :: Line    ! Of output
d3687 1
a3687 1
        & call Trace_Begin ( 'ForwardModel.MetricsEtc' )
d3783 1
d3790 3
a3792 2
          if ( print_TScat_detail == 0 ) call output ( TScat_Detail_Heading, &
            & advance="yes" )
d3796 1
a3796 1
            & rad2deg*phi_path(npf), which, myRev
d3798 1
a3798 1
          else ; line = trim(line) // " T"
d3805 3
a3807 6
            line(len(TScat_detail_heading)+2:len(TScat_detail_heading)+2) = ">"
            call output ( trim(line) ) ! Too far away from scattering point
            if ( scat_ht > tan_ht .and. which < 0 ) then
              call output ( " abandoned", advance="yes" )
            else
              call newLine
d3814 2
a3817 1
              end if
d3821 6
d3828 5
a3832 8
          if ( print_TScat_detail > 1 ) then
            call output ( tan_pt_c, before='Tan_Pt_C = ', after=', ' )
            call output ( scat_index, before='Phi_Path_C(', after=':)', advance='yes' )
            call dump ( rad2deg*phi_path(c_inds(scat_index:)) )
            call output ( scat_index, before='H_Path_C(', after=':)', advance='yes' )
            call dump ( h_path(c_inds(scat_index:)) )
            call output ( scat_index, before='Z_Coarse(', after=':)', advance='yes' )
            call dump ( z_coarse(scat_index:npc) )
d3834 1
d3836 2
a3837 3
        if ( scat_index < 1 ) return ! No ray to trace
        i_start = scat_index
        i_end = npc
d4015 1
d4208 1
a4208 1
        & call Trace_End ( 'ForwardModel.MetricsEtc' )
d4347 2
a4348 2
          call frequency_average_derivatives ( ptg_i, .false. )
          if ( atmos_second_der ) call frequency_avg_second_derivs ( ptg_i, .false. )
d4350 1
d4375 2
a4376 1
      call frequency_average ( ptg_i )! or maybe just store
d4426 1
a4426 1
      if ( my_scat_index <= 1 ) return ! No ray to trace
d4432 10
a4441 1
      if ( temp_der ) k_temp_TScat(:,i_r,:) = k_temp(:,ptg_i,:)
@


2.327
log
@Add Do_Calc_Fzp into one call to Comp_Sps_Path_Frq, because it is no longer
optional, and it is actually needed where it wasn't specified.  Add checks
that temperature and mixing ratio quantities for which derivatives are
requested appear in the first state vector.
@
text
@d325 1
a325 1
    use D_HUNT_M, only: HUNT
d343 1
a343 1
    use MLSNUMERICS, only: HUNT, INTERPOLATEVALUES
d2139 2
a2140 2
      call Hunt ( min_ch_freq_grid, GridFrequencies, k, j, l )
      call Hunt ( max_ch_freq_grid, GridFrequencies, k, l, m )
d4471 1
a4471 1
       "$Id: FullForwardModel_m.f90,v 2.326 2011/07/29 01:55:18 vsnyder Exp $"
d4481 6
@


2.326
log
@Use CloudIce instead of Cloud_A and Cloud_S.  Only one IWC, not IWC_A and
IWC_S.  More dumps.
@
text
@d49 1
a49 1
    use INTRINSIC, only: L_MAGNETICFIELD, &
d55 1
a55 1
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR
d58 1
d83 1
d86 1
d117 1
a117 1
    logical :: atmos_der, atmos_second_der, ptan_der, spect_der, temp_der
d119 1
d148 2
a149 1
      & quantityType=l_temperature, config=fwdModelConf )
a156 1
    temp_der = present ( jacobian ) .and. FwdModelConf%temp_der
d160 6
a173 2
      ! Turn off deriv_flags where we don't want molecule derivatives, so we
      ! don't have to look at fwdModelConf%moleculeDerivatives
d175 16
a190 2
        if ( .not. fwdModelConf%moleculeDerivatives(k) ) &
          & grids_f%deriv_flags(grids_f%l_v(k-1)+1:grids_f%l_v(k)) = .false.
d1114 2
a1115 1
      use String_Table, only: Get_String, String_Length
d1117 2
a1118 11
      integer, parameter :: C = len('With config(')
      integer :: L
      character(511) :: Work ! Should be plenty of room
      l = string_length(fwdModelConf%name)
      work(:c) = 'With config('
      call get_string ( fwdModelConf%name, work(c+1:) )
      l = c + l + 1
      work(l:l+3) = '): '
      l = l + 3
      work(l+1:l+len_trim(message)) = message
      call MLSMessage ( MLSMSG_Error, moduleName, work(:l+len_trim(message)) )
d2342 1
a2342 1
            call output ( TScat%template%phi(1,phi_i), &
d2366 1
a2366 1
              call output ( TScat%template%phi(1,phi_i), before=') = (' )
d2393 1
a2393 1
              call output ( TScat%template%phi(1,phi_i), &
d3750 11
a3760 11
              return
            end if
            call newLine
            call output ( req_s, before="Req_s = " )
            call output ( mod(phitan%values(FwdModelConf%TScatMIF,MAF),360.0_r8), &
              & before=", Phi_ref = ", advance="yes" )
            call dump ( z_coarse(:size(c_inds)), name="Z_Coarse" )
            call dump ( rad2deg*phi_path(c_inds), name="Phi_Path", format="(f14.8)" )
            call dump ( h_path(c_inds), name="H_Path", format="(f14.6)" )
            call MLSMessage ( merge(MLSMSG_Warning,MLSMSG_Error,switchDetail(switches,'igsc')>0), &
              & moduleName, 'Scattering point appears not to be in path' )
d3945 2
a3946 1
        & do_calc_zp(1:npf,:), sps_path(1:npf,:), eta_fzp(1:npf,:) )
d4471 1
a4471 1
       "$Id: FullForwardModel_m.f90,v 2.325 2011/07/21 20:48:38 honghanh Exp $"
d4481 4
@


2.325
log
@Fix an array-index-out-of-bound bug by fixing the declaration fo DBETA_DF_PATH_C
and DBETA_DF_PATH_F
@
text
@d57 3
a59 2
    use MOLECULES, only: FIRST_MOLECULE, LAST_MOLECULE, L_CLOUD_A, L_CLOUD_S
    use TOGGLES, only: SWITCHES
d74 1
a74 2
    type (Grids_T) :: Grids_IWC_a ! All the coordinates for IWC absorption
    type (Grids_T) :: Grids_IWC_s ! All the coordinates for IWC scattering
d79 1
a79 2
    type (VectorValue_T), pointer :: CloudIce_a ! Ice water content - absorption
    type (VectorValue_T), pointer :: CloudIce_s ! Ice water content - scattering
a87 1
    integer :: S_IND(First_Molecule:Last_Molecule) ! Indices of species in Grids_f
d117 3
d150 1
a150 2
    call load_sps_data ( FwdModelConf, phitan, fmStat%maf, grids_f, &
      & s_ind=s_ind )
d181 1
a181 1
    nullify ( cloudIce_a, cloudIce_s )
d183 2
a184 4
      cloudIce_a => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_vmr, molecule=l_cloud_a, config=fwdModelConf, noError=.true. )
      cloudIce_s => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_vmr, molecule=l_cloud_s, config=fwdModelConf, noError=.true. )
d186 2
a187 7
    if ( associated(cloudIce_a) .neqv. associated(cloudIce_s) ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
        & "Either need both Cloud_a and Cloud_s, or neither of them" )
    if ( associated(cloudIce_a) ) then
      call load_one_item_grid ( grids_IWC_a, cloudIce_a, phitan, fmStat%maf, &
        & fwdModelConf, .false., .false. )
      call load_one_item_grid ( grids_IWC_s, cloudIce_s, phitan, fmStat%maf, &
d190 1
a190 2
      call emptyGrids_t ( grids_IWC_a ) ! Allocate components with zero size
      call emptyGrids_t ( grids_IWC_s ) ! Allocate components with zero size
d246 2
a247 2
                              & grids_tmp, grids_f, grids_mag, grids_iwc_a,    &
                              & grids_iwc_s, grids_n, grids_v, grids_w,        &
d252 1
a252 1
                              & max_c, maxVert, max_f, s_ind, ptan_der,        &
d259 1
a259 2
    call destroygrids_t ( grids_iwc_a )
    call destroygrids_t ( grids_iwc_s )
d272 2
d279 11
a289 11
                              & FwdModelOut, FmStat, z_psig, tan_press,        &
                              & grids_tmp,  grids_f, grids_mag, grids_iwc_a,   &
                              & grids_iwc_s, grids_n, grids_v, grids_w, ptan,  &
                              & phitan, temp, no_mol, noUsedChannels,          &
                              & no_sv_p_t,n_t_zeta, sv_t_len, nlvl, no_tan_hts,&
                              & surfaceTangentIndex,                           &
                              & max_c, maxVert, max_f, S_ind, ptan_der,        &
                              & s_t, s_a, s_h, s_lc, s_lw, s_td, s_p, s_pfa,   &
                              & s_i, s_tg, s_ts,                               &
                              ! Optional:
                              & Jacobian, Hessian )
d336 1
a336 2
    use TSCAT_SUPPORT_M, only: GET_TSCAT, GET_TSCAT_SETUP, GET_TSCAT_TEARDOWN, &
      & TSCAT_GEN_SETUP
d354 1
a354 2
    type (Grids_T), intent(in) :: Grids_IWC_a ! All the coordinates for IWC absorption
    type (Grids_T), intent(in) :: Grids_IWC_s ! All the coordinates for IWC scattering
a376 1
    integer, intent(in) :: S_IND(First_Molecule:Last_Molecule) ! Indices of species in Grids_f
d402 1
a402 1
    integer :: H2O_Ind            ! S_Ind(L_H2O) = index of H2O in Grids_f
a415 1
    integer :: NGL                ! Total # of GL points = Size(gl_inds)
a439 1
    logical :: cld_fine = .false.
d466 1
a466 1
    integer :: F_INDS(max_f)      ! Indices on fine grid
d468 1
a468 1
    integer :: GRIDS(no_tan_hts)  ! Indices in ptgGrid for each tangent
d471 1
a471 1
                                  ! d_delta_df
d473 3
a475 3
                                  ! nz_d_delta_df
    integer :: RadInL2PC          ! Which TScat radiance in L2PC to use
    integer :: Vert_Inds(max_f)   ! Height indices of fine path in H_Glgrid etc.
a493 1
    real(rp) :: Beta_c_a_path_c(s_ts*max_c)  ! Beta_c_a on coarse path
d514 2
a515 2
    real(rp) :: dTScat_df(s_ts*max_c,size(grids_f%values))   ! on path w.r.t. SVE
    real(rp) :: dTScat_dT(s_ts*max_c,size(grids_tmp%values)) ! on path w.r.t. SVE
d523 1
a523 1
    real(rp) :: PHI_PATH(max_f)       ! Phi's on path, Radians
d543 1
a543 1
    real(rp) :: D_DELTA_DF(s_a*max_c,size(grids_f%values)) ! Incremental 
d546 1
a546 1
    real(rp) :: D2_DELTA_DF2(s_h*max_c,size(grids_f%values),size(grids_f%values))
d550 7
a556 7
                                      ! path x state-vector-components
    real(rp) :: D2X_DXDT(no_tan_hts,s_t*sv_t_len)  ! (No_tan_hts, nz*np)
    real(rp) :: DALPHA_DF_PATH_C(max_c,no_mol)     ! on coarse path
    real(rp) :: DALPHA_DF_PATH_F(max_f,no_mol)     ! on GL path
    real(rp) :: D2ALPHA_DF2_PATH_C(max_c,no_mol)     ! on coarse path
    real(rp) :: D2ALPHA_DF2_PATH_F(max_f,no_mol)     ! on GL path
    real(rp) :: DB_DF(s_ts*max(s_a,s_t)*max_c)     ! dB / d one f on the path, for TScat
d559 2
a560 2
    real(rp) :: DBETA_DIWC_PATH_C(max_c,s_tg*no_mol)  ! dBeta_dIWC on coarse grid
    real(rp) :: DBETA_DIWC_PATH_F(max_f,s_tg*no_mol)  ! dBeta_dIWC on fine grid
d575 1
a575 2
    real(rp) :: ETA_IWC_a_ZP(max_f,s_i*grids_iwc_a%p_len)
    real(rp) :: ETA_IWC_s_ZP(max_f,s_i*grids_iwc_s%p_len)
d584 1
a584 2
    real(rp) :: IWC_PATH_a(max_f,max(s_i,s_ts))    ! IWC on path - absorption
    real(rp) :: IWC_PATH_s(max_f,max(s_i,s_ts))    ! IWC on path - scattering
d595 1
a595 1
    real(rp) :: TT_PATH(max_f,s_i)                 ! TScat on path along the LOS
a620 2
    complex(rp) :: RAD_POL(2,2)  ! polarized radiance output of mcrt for one freq and pointing
      ! (-1,:,:) are Sigma_-, (0,:,:) are Pi, (+1,:,:) are Sigma_+
a678 2
    integer, pointer :: CG_INDS(:)  ! Indices on coarse grid where GL needed
    integer, pointer :: GL_INDS(:)  ! Index of GL points -- subset of f_inds
d751 1
a751 2
    type (Eta_d_t), dimension(s_ts*max_c) :: Eta_T_path_C, &
    & Eta_IWC_a_path_C, Eta_IWC_s_path_C
d757 1
a757 1
    type (Grids_T) :: Grids_Salb ! All the coordinates for single scaterring albedo
a767 3
    type (Vector_T) :: dX, TScat  ! Clones of Column, Row vectors from TScat L2PC
    type(L2PC_t), pointer :: L2PC ! The selected TScat L2PC

a785 1
    real(r8) :: TOL = 1.D-190
d797 1
a797 1
      & call trace_begin ( 'Full ForwardModel, MAF=', index=fmstat%maf )
a847 1

d877 1
a877 1
    h2o_ind = s_ind(l_h2o)
d957 2
a958 2
       if ( toggle(emit) .and. levels(emit) > 2 ) &
         & call output( '(Skipping loop of pointings)', advance='yes' )
a959 4
        if ( fwdModelConf%useTScat ) &
           & call Get_TScat_Setup ( fwdModelConf, FwdModelIn, FwdModelExtra, &
           &                        Sideband, MAF, Phitan, L2PC,             &
           &                        RadInL2PC, dX, TScat, Grids_TScat )
a973 2
        if ( fwdModelConf%useTScat ) &
          & call Get_TScat_Teardown ( dX, TScat, Grids_TScat )
d1084 1
a1084 1
    if ( toggle(emit) ) call trace_end ( 'Full ForwardModel MAF=', fmStat%maf )
d2143 2
a2144 1
      use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE
d2149 1
d2176 1
a2176 1
      real(rp) :: Scat_Phi     ! Of the scattering point
d2204 2
d2209 1
d2215 1
a2215 2
      integer :: Row           ! Row number of Jacobian block
      integer :: Scat_Index(size(Xis)) ! of scattering point in coarse grid
d2220 1
a2220 1
      integer :: Zeta_i        ! Loop inductor and subscript
d2279 1
a2279 1
      phi_ref = phitan%values(FwdModelConf%TScatMIF,MAF) * deg2rad
d2283 2
a2284 1
        call output ( rad2deg*phi_ref, before="Phi_Ref = ", advance="yes" )
d2287 1
a2287 1
          & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi", &
d2291 15
d2325 2
d2332 1
a2332 1
            cycle
d2335 2
a2336 1
          logIWC = log10(iwc%values(zeta_i,phi_i))
d2338 22
a2359 7
          scat_phi = TScat%template%phi(1,phi_i) * deg2rad
          dPhi = scat_phi - phi_ref
          ! Interpolate in H_GLGrid at (phi_i,zeta_f) to get Scat_Ht
          call get_eta_sparse ( Grids_tmp%phi_basis, scat_phi, &
                              & eta_s, first_s, last_s )
          scat_ht = dot_product(h_glgrid(zeta_f,first_s:last_s), &
                 &             eta_s(first_s:last_s)) + r_eq
d2361 50
a2410 9
          ! Subsurface scattering points handled by explicit angles
          if ( scat_ht < r_eq ) then
            call output ( TScat%template%phi(1,phi_i), &
              & before='Scattering point at (' )
            call output ( z_glgrid(zeta_f), before=',' )
            call output ( scat_ht, format='(f8.3)', &
              & before=') rejected because its height (' )
            call output ( r_eq, format='(f8.3)', &
              & before=') is below the Earth surface (', after=').', advance='yes' )
d2464 1
a2464 1
              & whichPointingGrid%oneGrid(grids(ptg_i))%frequencies )
d2469 4
a2472 4
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.true. )
d2475 4
a2478 4
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.false. )
d2482 4
a2485 4
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.false. )
d2488 4
a2491 4
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       & 
              &                       scat_zeta, scat_phi, scat_ht,       & 
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.true. )
d2503 1
a2503 1
            & whichPointingGrid%oneGrid(grids(1))%frequencies )
d2522 1
a2522 1
            scat_tan_ht = scat_ht * abs(cos(dPhi - xi)) ! xi < 0 here
d2532 1
a2532 1
            scat_tan_phi = mod(scat_tan_phi,pix2)
d2540 1
d2547 6
a2552 6
            ! Do the ray tracing and radiative transfer
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,           &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index,      &
              &                       scat_tan_ht, forward )
d2555 4
a2558 5
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,           &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index,      &
              &                       scat_tan_ht, forward )
d2575 1
a2575 1
          if ( switch42 ) then
a2586 45
          ! Get interpolating factors for scattering-point IWC to phase function
          ! IWC_s for Mie tables.
          ! IWC_s(iwc_ix) <= logIWC < IWC_s(iwc_ix+1_).
          call hunt ( IWC_s, logIWC, iwc_ix )
          if ( logIWC < IWC_s(1) ) then
            eta_iwc = (/ 1.0, 0.0 /) ! constant extrapolation below range
          else if ( logIWC > IWC_s(size(IWC_s)) ) then
            eta_iwc = (/ 0.0, 1.0 /) ! constant extrapolation above range
          else
            eta_iwc(1) = (logIWC - iwc_s(iwc_ix)) / &
                       & ( iwc_s(iwc_ix+1) - iwc_s(iwc_ix) )
            eta_iwc(0) = 1.0 - eta_iwc(1)
          end if
          ! Get interpolating factors for scattering-point temperature to phase
          ! function temperatures.
          ! T_s(T_ix) <= temp%values(zeta_i,phi_i) < T_s(T_ix+1).
          call hunt ( T_s, temp%values(zeta_i,phi_i), t_ix )
          if ( temp%values(zeta_i,phi_i) < t_s(1) ) then
            eta_t = (/ 1.0, 0.0 /) ! constant extrapolation below range
          else if ( temp%values(zeta_i,phi_i) > t_s(size(t_s)) ) then
            eta_t = (/ 0.0, 1.0 /) ! constant extrapolation above range
          else
            eta_t(1) = (temp%values(zeta_i,phi_i) - t_s(t_ix)) / &
                     & ( t_s(t_ix+1) - t_s(t_ix) )
            eta_t(0) = 1.0 - eta_t(1)
          end if

          forall ( ptg_i=0:1, ptg_j = 0:1 ) &
            & eta_t_iwc(ptg_i,ptg_j) = eta_t(ptg_i) * eta_iwc(ptg_j)

          ! Create an array of theta's extended to negative values, onto which
          ! to interpolate the xi's.  The phase function is sign-symmetric on
          ! theta_s, but the radiances are not sign-symmetric on xi's.
          theta_e(1:size(theta_s)) = -theta_s(size(theta_s):1:-1)
          beg_pos_theta = merge(2,1,theta_s(1)==0.0)
          theta_e(size(theta_s)+1:2*size(theta_s)+1-beg_pos_theta) = &
            & theta_s(beg_pos_theta:)
          ! Set up theta_e to cover 2 pi, to prepare it for periodic spline
          ! interpolation input abscissa set.
          n_theta_e = 2*size(theta_s) + 1 - beg_pos_theta
          if ( abs(theta_e(n_theta_e)-theta_e(1)-pix2) > 0.001 ) then
            n_theta_e = n_theta_e + 1
            theta_s(n_theta_e) = theta_s(n_theta_e) + pix2
          end if

a2621 3
            row = findBlock ( jacobian%row, TScat%index, phi_i )
            if ( row == 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & "Unable to find row of Jacobian to store TScat derivatives" )
d2645 2
a2646 1
            TScat%values(surf_i,phi_i) =  &
d2649 1
a2649 1
              &        ( xis(sort_xi(1)) + pix2 - xis(sort_xi(i_r)) )
d2655 5
a2659 4
              k_atmos_p(scat_index(i_r)) = k_atmos_p(scat_index(i_r)) + &
                & 0.25 * ( dP_dIWC_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                &          dP_dIWC_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
d2665 6
a2670 5
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
              k_temp_p(scat_index(i_r)) = k_temp_p(scat_index(i_r)) + &
                & 0.25 * ( dP_dT_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                &          dP_dT_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
d2672 1
d2683 5
a2687 4
                k_atmos_p(scat_index(ptg_i-1)) = k_atmos_p(scat_index(ptg_i-1)) + &
                  & 0.25 * ( dP_dIWC_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                  &          dP_dIWC_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                  &        ( xis(sort_xi(ptg_i  )) + pix2 - xis(sort_xi(ptg_i-1)) )
d2694 6
a2699 4
                k_temp_p(scat_index(ptg_i-1)) = k_temp_p(scat_index(ptg_i-1)) + &
                  & 0.25 * ( dP_dT_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                  &          dP_dT_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                  &        ( xis(sort_xi(ptg_i  )) + pix2 - xis(sort_xi(ptg_i-1)) )
d2701 1
a2701 1
            end do
d2782 1
d2791 2
a2792 1
      use TSCAT_SUPPORT_M, only: GET_DB_DT, MIE_FREQ_INDEX
d2798 1
a2800 1
      integer, intent(in) :: C_Inds(:)    ! Selectors from complete path to coarse path
d2822 2
a2825 2
      ! INC_RAD_PATH is (out) if .not. PFA, and (inout) if PFA
      real(rp), intent(inout) :: INC_RAD_PATH(:) ! Incremental radiance along the path
d2833 21
a2853 6
      real(r8) :: FRQHK                   ! 0.5 * Frq * H_Over_K
      integer :: I_STOP                   ! Stop path integration before I_End
      integer :: J, L                     ! Loop inductor and subscript
      integer :: Mie_Frq_Index            ! Index of Frq in F_s in Read_Mie
      integer :: P_Stop                   ! Where to stop in polarized case
      logical :: PFA_or_not_pol           ! PFA .or. .not. fwdModelConf%polarized
d2867 1
a2867 1
        & do_calc_fzp, eta_fzp(:npf,:),                      &
d2923 2
a2924 2
        call comp_eta_docalc_no_frq ( grids_tscat, z_path(1:npf), &
          &  phi_path(1:npf), eta_tscat_zp(1:npf,:),              &
d2930 1
a2930 1
          & do_calc_tscat(1:npf,:), eta_tscat(1:npf,:) )
d2951 2
a2952 2
          call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:npf), &
            &  phi_path(1:npf), eta_salb_zp(1:npf,:),              &
d2958 1
a2958 1
            & do_calc_salb(1:npf,:), eta_salb(1:npf,:) )
d2964 2
a2965 2
          call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:npf), &
            &  phi_path(1:npf), eta_cext_zp(1:npf,:),              &
d2971 1
a2971 1
            & do_calc_cext(1:npf,:), eta_cext(1:npf,:) )
d3026 2
a3027 2
              & eta_IWC_a_path_c, eta_IWC_s_path_c, atmos_der, temp_der,  &
              & beta_c_a_path_c(:npc), beta_c_s_path_c(:npc),             &
d3035 4
d3040 7
a3046 4
          call Get_TScat ( fwdModelIn, fwdModelExtra, MAF, phitan, frq,   &
            &              z_coarse, phi_path(c_inds), tan_pt_c, grids_f, &
            &              L2PC, dX, TScat, radInL2PC, grids_TScat,       &
            &              tt_path_c, atmos_der, temp_der, dTScat_df, dTScat_dT )
d3148 1
a3148 1
      call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, cg_inds_b, ngl, ncg )
d3232 2
a3233 1
        inc_rad_path(i_stop+1:) = 0
d3324 1
a3324 1
            &  alpha_path_c, beta_c_a_path_c(:npc),                           &
d3401 6
a3406 6
          call get_dB_dT ( alpha_path_c, B(:npc), t_path_c(:npc), frq,       &
                         & beta_c_e_path_c(:npc), dAlpha_dT_Path_c(:npc),    &
                         & dBeta_c_a_dT_path_c(:npc), &
                         & dBeta_c_s_dT_path_c(:npc), tt_path_c(:npc),       &
                         & dTScat_dT(:npc,:), w0_path_c(:npc),               &
                         & eta_zxp_t_c(1:npc,:), nz_zxp_t_c, nnz_zxp_t_c,    &
d3551 1
a3551 1
      & Forward, Rev )
d3562 1
d3590 6
d3598 1
a3598 1
      character(100) :: Line    ! Of output
d3634 1
a3634 2
      call get_gl_inds ( do_gl(:npc), tan_pt_c, f_inds, cg_inds_b, nglMax, ncg )
      cg_inds => cg_inds_b(:ncg) ! Should be the whole thing here; probably not used
d3687 1
a3687 1
          scat_d1 = (phi_path(c_inds(scat_temp))-scat_phi)**2 + &
d3718 1
a3718 2
          if ( print_TScat_detail == 0 ) call output ( & ! need heading
            & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi", &
d3720 1
a3720 1
          write ( line, "(f7.2,f12.4,f9.3,f11.2,f10.6,f9.2,f11.4,f8.2,i4,f8.2,1x,L1)" ) &
d3723 2
a3724 2
            & rad2deg*phi_path(npf), myRev
          if ( present(forward) ) then; line = trim(line) // merge(" T", " F", forward)
d3729 10
a3738 1
            call output ( trim(line) // " >", advance="yes" ) ! Too far away
d3740 1
a3740 1
            call output ( phitan%values(FwdModelConf%TScatMIF,MAF), &
d3761 1
a3761 1
        if ( scat_index <= 1 ) return ! No ray to trace
d3902 2
d3931 1
a3931 2
        & do_calc_zp(1:npf,:), sps_path(1:npf,:), &
        & do_calc_fzp(1:npf,:), eta_fzp(1:npf,:) )
d3982 2
a3983 4
        call comp_eta_docalc_no_frq ( Grids_IWC_a, z_path(1:npf), &
          &  phi_path(1:npf), eta_IWC_a_zp(1:npf,:), tan_pt=tan_pt_f )
        call comp_eta_docalc_no_frq ( Grids_IWC_s, z_path(1:npf), &
          &  phi_path(1:npf), eta_IWC_s_zp(1:npf,:), tan_pt=tan_pt_f )
d3986 2
a3987 4
        call comp_sps_path_no_frq ( Grids_IWC_a, eta_IWC_a_zp(1:npf,:), &
          & iwc_path_a(1:npf,:) )
        call comp_sps_path_no_frq ( Grids_IWC_s, eta_IWC_s_zp(1:npf,:), &
          & iwc_path_s(1:npf,:) )
d3990 1
a3990 1
          WC(1,1:npf)=iwc_path_a(1:npf,1)
d4096 1
a4096 1
        do j = 1, ncg ! ncg = npc-2 here (do_gl is always false at the ends)
d4126 1
a4126 2
        call get_eta_stru ( iwc_s, iwc_path_a(c_inds,1), eta_IWC_a_path_c )
        call get_eta_stru ( iwc_s, iwc_path_s(c_inds,1), eta_IWC_s_path_c )
d4310 5
a4314 5
  ! .........................................  One_TScat_Pointing  .....
    subroutine One_TScat_Pointing ( Ptg_i, Vel_Rel, Scat_Tan_Phi, Scat_Zeta,  &
      &                             Scat_Phi, Scat_Ht, Use_R_Eq, Xi,          &
      &                             Xis, Rads, K_Atmos_TScat, K_Temp_TScat,   &
      &                             I_R, Scat_Index, Scat_Tan_Ht, Forward, Rev)
d4316 1
a4316 1
      ! Do one TScat pointing
d4319 1
d4331 1
a4331 2
      integer, intent(inout) :: I_R         ! Index in Xis, Scat_index; Update if OK
      integer, intent(out) :: Scat_Index(:) ! Index of scattering point in coarse grid
d4342 5
a4346 4
      call one_pointing ( ptg_i, vel_rel, scat_tan_phi, use_r_eq=use_r_eq, &
        &                 scat_zeta=scat_zeta, scat_phi=scat_phi,          &
        &                 scat_ht=scat_ht, xi=xi, scat_index=my_scat_index,&
        &                 scat_tan_ht=scat_tan_ht, forward=forward, rev=rev )
a4350 1
      scat_index(i_r) = my_scat_index
d4355 1
a4355 1
    end subroutine One_TScat_Pointing
d4456 1
a4456 1
       "$Id: FullForwardModel_m.f90,v 2.324 2011/07/08 18:19:35 yanovsky Exp $"
d4466 4
@


2.324
log
@Use get_d2Alpha_df2
@
text
@d570 2
a571 4
    real(rp) :: DBETA_DF_PATH_C(merge(max_c,0,any(grids_f%where_dBeta_df /= 0)),&
                                count(grids_f%where_dBeta_df /= 0))
    real(rp) :: DBETA_DF_PATH_F(merge(max_f,0,any(grids_f%where_dBeta_df /= 0)),&
                                count(grids_f%where_dBeta_df /= 0))
a1099 1
      print *
d1232 2
a1233 2
      if ( .not. FwdModelConf%generateTScat ) &
        & call estimate_tan_phi ( nlvl, maf, phitan, ptan, &
d1236 1
d4414 1
a4414 1
       "$Id: FullForwardModel_m.f90,v 2.322 2011/06/02 22:31:48 yanovsky Exp $"
d4424 3
@


2.323
log
@Fixed erroneous declaration for D2_DELTA_DF2 that gave non-Hessian runs excess memory footprint
@
text
@d567 2
d2772 1
a2772 1
      use GET_DALPHA_DF_M, only: GET_DALPHA_DF
d3314 10
d3325 2
a3326 3
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,                   &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,            &
d3330 1
d4426 3
@


2.322
log
@Add D2_DELTA_DF2 for computations of analytical Hessians in logarithmic basis
@
text
@d559 1
a559 1
    real(rp) :: D2_DELTA_DF2(s_a*max_c,size(grids_f%values),size(grids_f%values))
d4404 1
a4404 1
       "$Id: FullForwardModel_m.f90,v 2.321 2011/05/09 17:46:38 pwagner Exp $"
d4414 3
@


2.321
log
@Converted to using switchDetail
@
text
@d557 5
a561 2
                                      ! opacity derivative schlep from drad_tran_dt
                                      ! to get_d_deltau_pol_df.  Path x SVE.
d865 3
d870 2
d3317 2
a3318 1
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, h_atmos_frq )
d4404 1
a4404 1
       "$Id: FullForwardModel_m.f90,v 2.320 2011/03/31 19:51:03 vsnyder Exp $"
d4414 3
@


2.320
log
@Allow 'scattering point not in path' to be a warning
@
text
@d16 1
a16 1
  use GLnp, only: NGP1
d41 9
a49 9
    use Allocate_Deallocate, only: DEALLOCATE_TEST
    use Compute_Z_PSIG_m, only: Compute_Z_PSIG
    use ForwardModelConfig, only: DeriveFromForwardModelConfig, &
      & DestroyForwardModelDerived, Dump, ForwardModelConfig_t
    use ForwardModelIntermediate, only: ForwardModelStatus_t
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Get_Species_Data_M, only:  Get_Species_Data
    use HessianModule_1, only: HESSIAN_T
    use Intrinsic, only: L_MAGNETICFIELD, &
d51 9
a59 9
    use Load_Sps_Data_m, only: DestroyGrids_t, Dump, EmptyGrids_T, Grids_T, &
      & Load_One_Item_Grid, Load_Sps_Data
    use MatrixModule_1, only: MATRIX_T
    use MLSKinds, only: RP
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSStringLists, only: switchDetail
    use Molecules, only: First_Molecule, Last_Molecule, L_CLOUD_A, L_CLOUD_S
    use Toggles, only: Switches
    use VectorsModule, only: Vector_T, VectorValue_T
d229 1
a229 1
    if ( index(switches,'grids') /= 0 ) then ! dump the grids
d303 30
a332 30
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Comp_Eta_Docalc_No_Frq_m, only: Comp_Eta_Docalc_No_Frq
    use Comp_Sps_Path_Frq_m, only: Comp_Sps_Path, Comp_Sps_Path_Frq, &
    ! & Comp_Sps_Path_Frq_nz, &
      & Comp_Sps_Path_No_Frq, Comp_1_Sps_Path_No_Frq
    use Compute_GL_Grid_m, only: Compute_GL_Grid
    use Constants, only: Deg2Rad, Rad2Deg
    use D_Hunt_m, only: Hunt
    use Dump_0, only: Dump
    use FilterShapes_m, only: DACSFilterShapes, FilterShapes
    use ForwardModelConfig, only: Beta_Group_T, Channels_T, &
      & ForwardModelConfig_t, LineCenter, LineWidth, LineWidth_TDep
    use ForwardModelIntermediate, only: ForwardModelStatus_t, &
                                    &   B_Ptg_Angles, B_Refraction
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Geometry, only: Get_R_Eq
    use Get_Eta_Matrix_m, only: Eta_D_T ! Type for eta struct
    use GLnp, only: GX
    use HessianModule_1, only: HESSIAN_T
    use Intrinsic, only: L_A, L_RADIANCE, L_TScat, L_VMR
    use Load_Sps_Data_m, only: DestroyGrids_t, Dump, Grids_T
    use L2PC_m, only: L2PC_t
    use MatrixModule_1, only: MATRIX_T
    use MLSKinds, only: R4, R8, RP, RV
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use MLSNumerics, only: Hunt, InterpolateValues
    use MLSSignals_m, only: AreSignalsSuperset, GetNameOfSignal, MatchSignal, &
      & Radiometers, Signal_t
    use MLSStringLists, only: switchDetail
    use Molecules, only: First_Molecule, Last_Molecule, &
d334 4
a337 4
    use Output_m, only: OUTPUT
    use Path_Contrib_M, only: Get_GL_Inds
    use Physics, only: SpeedOfLight
    use PointingGrid_m, only: POINTINGGRIDS, PointingGrid_T
d339 8
a346 8
! use testfield_m
    use Tau_M, only: Destroy_Tau, Dump, Tau_T
    use Toggles, only: Emit, Levels, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
    use TScat_Support_m, only: Get_TScat, Get_TScat_Setup, Get_TScat_Teardown, &
      & TScat_Gen_Setup
    use TWO_D_HYDROSTATIC_M, only: Two_D_Hydrostatic
    use VectorsModule, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T
d822 2
a823 2
    if ( index(switches, 'clean') /= 0 ) clean = 'c'
    do_zmin = index(switches, 'dozm') /= 0 ! Do minimum zeta only if requested
d825 14
a838 14
    if ( index(switches, 'dpri') /= 0 ) dump_rad_pol = 1 ! Dump if overflow
    if ( index(switches, 'Dpri') /= 0 ) dump_rad_pol = 2 ! Dump all
    if ( index(switches, 'DPRI') /= 0 ) dump_rad_pol = 3 ! Dump first and stop
    dump_rad_pol = index(switches, 'dpri')
    dump_TScat = index(switches, 'dsct' ) /= 0
    print_Incopt = index(switches, 'incp' ) /= 0
    print_Mag = index(switches, 'mag') /= 0
    print_Ptg = index(switches, 'ptg') /= 0
    print_path = index(switches, 'path') /= 0
    print_Rad = index(switches, 'rad') /= 0
    print_Seez = index(switches, 'seez') /= 0
    print_TauL = index(switches, 'taul') /= 0
    print_TauP = index(switches, 'taup') /= 0
    print_TScat = index(switches, 'TScat' ) /= 0
d840 4
a843 4
    if ( index(switches, 'psct' ) /= 0 ) print_TScat_detail = 1
    if ( index(switches, 'Psct' ) /= 0 ) print_TScat_detail = 2
    print_more_points = index(switches, 'ZMOR' ) /= 0
    do_more_points = index(switches, 'zmor') /= 0
d1315 11
a1325 11
      use AntennaPatterns_m, only: ANTENNAPATTERNS
      use Intrinsic, only: L_ELEVOFFSET, L_LIMBSIDEBANDFRACTION
      use Convolve_All_m, only: Convolve_Radiance, Convolve_Temperature_Deriv, &
        & Convolve_Other_Deriv, Convolve_Other_Second_Deriv, Interpolate_Radiance, &
        & Interpolate_Temperature_Deriv, Interpolate_Other_Deriv
      use Dump_0, only: DUMP
      use FOV_Convolve_m, only: Convolve_Support_T, FOV_Convolve_Setup, &
        & FOV_Convolve_Teardown, No_FFT
      use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
      use MLSNumerics, only: Coefficients => Coefficients_r8, &
        & InterpolateArraySetup, InterpolateArrayTeardown
d2163 13
a2175 13
      use Constants, only: Pi
      use Convolve_All_m, only: Store_Other_Deriv, Store_Temperature_Deriv
      use ForwardModelConfig, only: QtyStuff_T
      use Get_Eta_Matrix_m, only: Get_Eta_Sparse
      use MatrixModule_1, only: FindBlock
      use MLSNumerics, only: Coefficients_r8, InterpolateArraySetup, &
        & InterpolateArrayTeardown
      use MLSSignals_m, only: GetNameOfSignal
      use Output_m, only: NewLine
      use Read_Mie_m, only: dP_dIWC, dP_dT, F_s, IWC_s, P, T_s, Theta_s
      use Sort_m, only: Sortp
      use TScat_Support_m, only: Interpolate_P_to_Theta_e
      use VectorsModule, only: Dump
d2252 1
a2252 1
      switch42 = index(switches,"42") /= 0
d2756 1
a2756 1
      use CS_Expmat_m, only: CS_Expmat
d2759 12
a2770 12
      use Dump_Path_m, only: Dump_Path
      use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, &
        & Get_Beta_Path_PFA, Get_Beta_Path_Polarized
      use Get_dAlpha_df_m, only: Get_dAlpha_df
      use Get_d_Deltau_pol_m, only: Get_d_Deltau_pol_df, Get_d_Deltau_pol_dT
      use Get_Eta_Matrix_m, only: Select_NZ_List
      use Interpolate_Mie_m, only: Interpolate_Mie
      use Load_Sps_Data_m, only:  Load_One_Item_Grid
      use Mcrt_m, only: Mcrt_der
      use Opacity_m, only: Opacity
      use Path_Contrib_M, only: Path_Contrib
      use Physics, only: H_OVER_K
d2773 3
a2775 3
      use ScatSourceFunc, only: T_SCAT, Interp_Tscat, Convert_Grid
      use Tau_M, only: Get_Tau
      use TScat_Support_m, only: Get_dB_dT, Mie_Freq_Index
d3502 11
a3512 11
      use Add_Points_m, only: Add_Points
      use Constants, only: Pi
      use Geometry, only: MaxRefraction
      use Get_Chi_Angles_m, only: Get_Chi_Angles
      use Get_Eta_Matrix_m, only: Get_Eta_Stru
      use GLnp, only: GW, NG
      use Metrics_m, only: Height_Metrics, More_Metrics, More_Points, &
        & Tangent_Metrics
      use Min_Zeta_m, only: Get_Min_Zeta
      use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction
      use Read_Mie_m, only: IWC_s, T_s
d3680 1
a3680 1
            call MLSMessage ( merge(MLSMSG_Warning,MLSMSG_Error,index(switches,'igsc')>0), &
d3746 1
a3746 1
            if ( index(switches,'zdet') /= 0 ) then
d4307 4
a4310 4
    use MLSKinds, only: RK => RP
    use MLSNumerics, ONLY: InterpolateValues
    use Constants, only: Deg2Rad
    use VectorsModule, only: VectorValue_T
d4395 1
a4395 1
       "$Id: FullForwardModel_m.f90,v 2.319 2011/03/25 20:46:59 vsnyder Exp $"
d4405 3
@


2.319
log
@Delete declarations of unused objects
@
text
@d327 1
a327 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d3680 3
a3682 2
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & 'Scattering point appears not to be in path' )
d4395 1
a4395 1
       "$Id: FullForwardModel_m.f90,v 2.318 2011/03/23 23:50:42 vsnyder Exp $"
d4405 3
@


2.318
log
@Finishing -- hopefully -- TScat derivatives
@
text
@a504 1
    real(rp) :: B_TScat(s_ts*max_c)   ! (TT_PATH_C - B) * W0_PATH_C
a516 1
    real(rp) :: dBeta_c_e_dIWC_path_C(s_ts*max_c)  ! on coarse path
a518 1
    real(rp) :: dBeta_c_e_dT_path_C(s_ts*max_c)    ! on coarse path
d3284 3
a3286 3
            &  alpha_path_c, B(:npc), beta_c_a_path_c(:npc),                  &
            &  dBeta_c_e_dIWC_path_c(:npc), dBeta_c_s_dIWC_path_c(:npc),      &
            &  tt_path_c(:npc), dTScat_df, w0_path_c(:npc) )
d4394 1
a4394 1
       "$Id: FullForwardModel_m.f90,v 2.317 2011/03/23 23:45:32 vsnyder Exp $"
d4404 3
@


2.317
log
@FOV_Convolve_m.f90
@
text
@d4397 1
a4397 1
       "$Id: FullForwardModel_m.f90,v 2.316 2011/03/11 03:09:08 vsnyder Exp $"
d4407 4
@


2.316
log
@Use Get_dAlpha_df
@
text
@d530 2
a531 2
    real(rp) :: dTScat_df(s_ts*max_c,size(grids_f%values))
    real(rp) :: dTScat_dT(s_ts*max_c,size(grids_tmp%values))
d3278 3
a3280 3
          ! dimensions of eta_fzp and dAlpha_df_path_f because these correspond
          ! to explicit-shape dummy arguments.  Doing so would cause the
          ! compiler to take a copy!
d3287 1
a3287 1
            &  alpha_path_c, B(:npc), beta_c_e_path_c(:npc),                  &
d3293 4
d3354 2
a3355 1
                         & beta_c_e_path_c(:npc), dBeta_c_e_dT_path_c(:npc), &
d3426 1
a3426 1
            & eta_zxp_t_c(1:p_stop,:), eta_zxp_t(:ngl,:), del_s,          &
d4397 1
a4397 1
       "$Id: FullForwardModel_m.f90,v 2.315 2011/03/04 03:44:40 vsnyder Exp $"
d4407 3
@


2.315
log
@Remove declarations for unused stuff
@
text
@d557 2
a558 2
!   real(rp) :: BETA_PATH_C(max_c,no_mol)  ! Beta on path coarse
    real(rp) :: BETA_PATH_F(max_f,no_mol)  ! Beta on path fine
d562 1
a562 1
    real(rp) :: D_T_SCR_dT(max_c,s_t*sv_t_len)  ! D Delta_B in some notes
d565 2
d607 2
d2765 1
d2837 1
a2837 1
        & do_calc_zp, sps_path,                              &
d2844 1
a2844 1
!           & do_calc_zp, sps_path,                                        &
d2847 1
d2963 1
a2963 1
          alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
d2983 1
a2983 1
          alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
d3053 2
a3054 3
            & matmul( beta_path_polarized(-1:1,j,:),       &
            &         sps_path(c_inds(j),:) ) * tanh1_c(j) &
            & + 0.25 * alpha_path_c(j)
d3117 1
d3144 1
a3144 1
          &  sps_path )
d3150 1
a3150 2
        alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                     & beta_path_f(j,:) )
d3155 1
a3155 1
        call dump ( sps_path(c_inds(i_start:i_end),:), name="SPS_Path" )
d3206 1
a3206 1
          & phi_path(c_inds), z_path(c_inds), sps_path(c_inds,:), beta_path_c, &
d3228 1
a3228 1
            &         sps_path(gl_inds(j),:) ) * tanh1_f(j) &
d3267 8
d3277 4
d3282 8
a3289 9
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,                   &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, dBeta_df_path_c, dBeta_df_path_f,                &
            &  i_start, tan_pt_c, i_stop, size(d_delta_df,1),                 &
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq, dB_df, &
            &  tau%tau(:,frq_i), nz_zp, nnz_zp,  alpha_path_c, B(:npc),       &
            &  beta_c_e_path_c(:npc), dBeta_c_e_dIWC_path_c(:npc),            &
            &  dBeta_c_s_dIWC_path_c(:npc), tt_path_c(:npc), dTScat_df,       &
            &  w0_path_c(:npc) )
d3294 5
a3298 5
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,                   &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,             &
            &  inc_rad_path, dBeta_df_path_c, dBeta_df_path_f,                &
            &  i_start, tan_pt_c, i_stop,  size(d_delta_df,1),                &
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq, dB_df )
d3320 2
a3321 1
            &  d_delta_df(1:npc,:), de_df(:,:,1:p_stop,:) )
d3366 1
a3366 1
        dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds,:) *  &
d3368 1
a3368 1
        dAlpha_dT_path_f(:ngl) = sum( sps_path(gl_inds,:) * &
d3401 1
a3401 1
                & sps_path(c_inds,j) * dBeta_dT_polarized_path_c(l,1:npc,j)
d3404 1
a3404 1
                & sps_path(gl_inds,j) * dBeta_dT_polarized_path_f(l,1:ngl,j)
d4392 1
a4392 1
       "$Id: FullForwardModel_m.f90,v 2.314 2011/02/12 03:57:40 vsnyder Exp $"
d4402 3
@


2.314
log
@Add mixing-ratio dependence for H2O derivatives
@
text
@d327 1
a327 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d333 2
a334 2
      & L_CLOUD_A, L_H2O, L_N2O, L_O3
    use Output_m, only: OUTPUT, OUTPUTNAMEDVALUE
a415 1
    integer :: IWC_Ind            ! S_Ind(L_IWC) = index of IWC in Grids_f
d1322 1
a1322 1
      use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
a1893 2
      integer :: status

a1972 1
      integer :: status
a2001 1
      use output_m, only: outputNamedValue
d2762 1
a2762 1
      use Get_Eta_Matrix_m, only: Interpolate_Stru, Select_NZ_List
a2770 1
      use Read_Mie_m, only: F_s
d3149 3
a3151 3
        call dump ( beta_path_c(i_start+1:i_end-1,:), name="Beta_Path" )
        call dump ( sps_path(c_inds(i_start+1:i_end-1),:), name="SPS_Path" )
        call dump ( alpha_path_c(i_start+1:i_end-1), name="Alpha_Path_C" )
a3521 1
      integer :: Mol            ! Loop index for frequency averaging
a3527 1
      integer :: status
d4375 1
a4375 1
       "$Id: FullForwardModel_m.f90,v 2.313 2011/01/29 00:52:32 vsnyder Exp $"
d4385 3
@


2.313
log
@Allow PFA without frequency averaging
@
text
@a415 1
    integer :: I_Cloud_A          ! Which beta group, if any, is Cloud_A
d567 4
a906 14
    ! Find which, if any, of the beta groups is Cloud_A.  This is needed
    ! because beta(Cloud_A) depends upon mixing ratio, which means the
    ! derivative of alpha isn't just beta, it's beta + (mixing ratio) *
    ! dBeta_d(mixing ratio).
    i_cloud_a = 0
    if ( size(dBeta_dIWC_path_c) /= 0 ) then
      do i = 1, size(beta_group)
        if ( beta_group(i)%molecule == l_cloud_a ) then
          i_cloud_a = i
          exit
        end if
      end do
    end if

d2864 2
a2865 1
          &  dbeta_dv_path_c, sps_path )
d3139 6
a3144 5
        call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_f(:ngl),    &
          & tanh1_f(1:ngl), beta_group, sx, fwdModelConf%polarized, gl_slabs,&
          & gl_inds, beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,      &
          & vel_rel, dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f,      &
          & dbeta_dv_path_f, sps_path )
d3273 4
a3276 4
            &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,            &
            &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1),      &
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq,        &
            &  dB_df, tau%tau(:,frq_i), nz_zp, nnz_zp, alpha_path_c, B(:npc), &
d3283 5
a3287 5
          call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f, &
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,              &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,        &
            &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,       &
            &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1), &
d3293 5
a3297 5
          call d2rad_tran_df2 ( max_f, c_inds, gl_inds, del_zeta, Grids_f, &
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,                &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,          &
            &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,         &
            &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1),   &
d4383 1
a4383 1
       "$Id: FullForwardModel_m.f90,v 2.312 2011/01/28 19:18:44 vsnyder Exp $"
d4393 3
@


2.312
log
@Lots of stuff for TScat
@
text
@d962 2
d965 2
a966 2
      if ( fwdModelConf%do_freq_avg ) frq_avg_sel = ior(frq_avg_sel, 8)
      if ( fwdModelConf%anyPFA(sx) .and. .not. &
d1651 1
a1651 1
! =====================================================
d1653 9
a1661 9
! Impossible?                                      x x
! Radiances = RadV                 x x     x x
! K = K_frq                          x       x
! Frq Avg path integrated rad          x x     x
! Combine total path radiances                 x
! Frq Avg path integrated LBL deriv      x       x
! Frq Avg rad Along Path                         x
! Combine radiances along path                   x
! Combine LBL and PFA derivs                     x
d1675 1
a1675 1
      case ( 2, 3, 12, 13 ) ! Just copy radiance. PFA + DACS - LBL impossible
d1758 1
a1758 1
      ! Only possible values for Frq_avg_sel here are 3, 11, 13, 15.
d1791 1
a1791 1
      case ( 3, 13 )            ! Not frequency averaging, or PFA alone; copy.
d1858 5
a1862 3
      ! For every channel, frequency average Path_Freq at every point
      ! along the path, giving Path_Chan for every channel and every
      ! point along the path.
d1872 15
a1886 11
      do c = 1, noUsedChannels
        shapeInd = channels(c)%shapeInds(sx)
        if ( channels(c)%dacs == 0 ) then
          do p = 1, size(path_freq,1)
            call Freq_Avg ( frequencies,            &
                    & FilterShapes(shapeInd)%FilterGrid,  &
                    & FilterShapes(shapeInd)%FilterShape, &
                    & path_freq(p,:), path_chan(p,c) )
          end do
        end if
      end do
d1900 1
a1900 1
      logical, intent(in) :: Combine        ! "Combine LBL and PFA"
d1924 1
a1924 1
      ! Only possible values for Frq_avg_sel here are 3, 11, 13, 15.
d1963 1
a1963 1
      case ( 3, 13 )            ! Not frequency averaging, or PFA alone; copy.
d2105 2
a2106 2
      call allocate_test ( inc_rad_path, max_c, maxNoPtgFreqs, 'Inc_Rad_path', &
        & moduleName )
d3193 6
a3198 6
        if ( pfa .and. frq_avg_sel == 15 ) then ! See Frequency_Average.
          ! Doing PFA and did LBL and need derivatives and will frequency
          ! average.  Multiply Inc_Rad_Path by Tau to combine LBL and PFA. 
          ! Then sum to give RadV.  Inc_Rad_Path is channel-averaged LBL
          ! radiance. Remember, when doing PFA, Frq_I is a channel number,
          ! and tau is tau_PFA.  See wvs-026.
d3382 1
a3382 1
            & grids_tmp%deriv_flags, pfa .and. frq_avg_sel == 15,          &
d3384 2
d4200 1
a4200 1
        if ( frq_avg_sel == 15 ) then ! FRQ_avg + LBL + PFA + Derivs
d4392 1
a4392 1
       "$Id: FullForwardModel_m.f90,v 2.311 2010/11/05 23:03:18 pwagner Exp $"
d4402 3
@


2.311
log
@Lots of new NaN checks--should make them optional
@
text
@d49 1
a49 1
    use Intrinsic, only: L_CLOUDICE, L_MAGNETICFIELD, &
d55 1
d57 1
a57 1
    use Molecules, only: First_Molecule, Last_Molecule, L_CLOUD_A
d73 2
a74 1
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC
d79 2
a80 1
    type (VectorValue_T), pointer :: CloudIce ! Ice water content
d150 1
a150 1
      & s_ind )
d181 1
a181 1
    nullify ( cloudIce )
d183 1
a183 5
      ! Try type l_cloudIce first
      cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_cloudIce, config=fwdModelConf, noError=.true. )
      if ( .not. associated(cloudIce) ) & ! now try type vmr with cloud_a molecule
        & cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
d185 2
d188 7
a194 2
    if ( associated(cloudIce) ) then
      call load_one_item_grid ( grids_iwc, cloudIce, phitan, fmStat%maf, &
d197 2
a198 1
      call emptyGrids_t ( grids_iwc ) ! Allocate components with zero size
d251 1
a251 1
    endif
d254 2
a255 2
                              & grids_tmp, grids_f, grids_mag, grids_iwc,      &
                              & grids_n, grids_v, grids_w,                     &
d267 2
a268 1
    call destroygrids_t ( grids_iwc )
d287 4
a290 4
                              & grids_tmp,  grids_f, grids_mag, grids_iwc,     &
                              & grids_n, grids_v, grids_w, ptan, phitan, temp, &
                              & no_mol, noUsedChannels, no_sv_p_t, n_t_zeta,   &
                              & sv_t_len, nlvl, no_tan_hts,                    &
d324 1
d343 2
a344 1
    use TScat_Support_m, only: TScat_Gen_Setup
d362 2
a363 1
    type (Grids_T), intent(in) :: Grids_iwc ! All the coordinates for WC
d488 1
d509 1
d519 1
d522 1
d532 2
d567 1
d584 2
a585 1
    real(rp) :: ETA_IWC_ZP(max_f,s_i*grids_iwc%p_len)
d594 2
a595 1
    real(rp) :: IWC_PATH(max_f,max(s_i,s_ts))      ! IWC on path
d763 3
a765 2
    ! factors) to put Mie beta_c_e and beta_c_s into path
    type (Eta_d_t), dimension(s_ts*max_c) :: Eta_T_path_C, Eta_IWC_path_C
d782 3
d985 5
a989 1
      elseif ( .not. FwdModelConf%generateTScat ) then
d1004 2
a1005 1

d1007 1
a1331 2
      use Intrinsic, only: L_ELEVOFFSET, L_LIMBSIDEBANDFRACTION
      use MLSFillValues, only: isNaN
a1473 5
              if ( any(isNaN(h_atmos(i,:,:,:)) ) ) then
                call dump( h_atmos(i,:,:,:), 'h_atmos(i,:,:,:)', options='-H' )
                call MLSMessage( MLSMSG_Warning, ModuleName // 'Convolution', &
                  & 'NaNs found in h_atmos (before convolve_other_second_deriv)' )
              endif
a1886 1
      use MLSFillValues, only: isNaN
a1899 10
      if ( any(isNaN(H_Frq) ) ) then
        call MLSMessage( MLSMSG_Warning, ModuleName // 'Frequency_Avg_Second_Derivative', &
          & 'NaNs found in h_frq', status=status )
        if ( status == 0 ) call dump( H_Frq, 'H_Frq', options='-H' )
      endif
      if ( any(isNaN(H) ) ) then
        call MLSMessage( MLSMSG_Warning, ModuleName // 'Frequency_Avg_Second_Derivative', &
          & 'NaNs found in h (input)', status=status )
        if ( status == 0 ) call dump( H_Frq, 'H_Frq', options='-H' )
      endif
a1968 10
      if ( any(isNaN(H) ) ) then
        call MLSMessage( MLSMSG_Warning, ModuleName // 'Frequency_Avg_Second_Derivative', &
          & 'NaNs found in h (output)', status=status )
        if ( status /= 0 ) return
        call outputNamedValue( 'noUsedChannels', noUsedChannels )
        call outputNamedValue( 'noUsedDACS', noUsedDACS )
        call outputNamedValue( 'frq_avg_sel', frq_avg_sel )
        call outputNamedValue( 'combine', combine )
        call dump( H, 'H', options='-H' )
      endif
a1972 1
      use MLSFillValues, only: isNaN
a2002 14
        if ( any(isNaN(h_atmos(:,ptg_i,:,:)) ) ) then
          call MLSMessage( MLSMSG_Warning, ModuleName // 'Frequency_Avg_Second_Derivs', &
            & 'NaNs found in h_atmos', status=status )
          if ( status == 0 ) then
            call outputNamedValue( 'no_mol', no_mol )
            call outputNamedValue( 'combine', combine )
            call outputNamedValue( 'ub', ub )
            call outputNamedValue( 'shape(h_atmos)', shape(h_atmos) )
            call outputNamedValue( 'shape(h_atmos_frq)', shape(h_atmos_frq) )
            call outputNamedValue( 'shape(h_atmos_frq(:ub,:,:))', shape(h_atmos_frq(:ub,:,:)) )
            call outputNamedValue( 'ptg_i', ptg_i )
            call dump( h_atmos(:,ptg_i,:,:), 'h_atmos(:,ptg_i,:,:)', options='-H' )
          endif
        endif
a2121 2
      call outputNamedValue( 'maxNoPtgFreqs', maxNoPtgFreqs )
      call outputNamedValue( 'noUsedChannels', noUsedChannels )
d2219 1
a2219 1
      real(rp) :: Eta_IWC(0:1) ! for current IWC
d2282 4
a2285 2
        ! Choose which frequency panel of phase function to use
        ! (don't interpolate).  Make sure it's close enough.
d2295 1
a2295 1
            & 'In TScat computation, phase function frequency coordinate too far from channel center' )
d2539 1
a2539 1
          ! IWC_s.
d2782 1
d2994 1
a2994 4
          Mie_frq_index = minloc(abs(f_s-frq),1)
          if ( abs(f_s(Mie_frq_index)-frq) > fwdModelConf%frqTol ) &
            & call MLSMessage ( MLSMSG_Error, moduleName, &
              & "UseTScat requested but no Mie tables near enough to Frq" )
d2998 5
a3002 4
            call interpolate_Mie ( Mie_frq_index, eta_T_path_c, eta_IWC_path_c, &
              & atmos_der, temp_der, beta_c_e_path_c(:npc), beta_c_s_path_c(:npc), &
              & dBeta_c_e_dIWC_path_c(:npc), dBeta_c_s_dIWC_path_c(:npc), &
              & dBeta_c_e_dT_path_c(:npc), dBeta_c_s_dT_path_c(:npc) )
d3008 22
a3029 1
        end if ! Not TScat model
d3031 1
a3031 7
        !{ Compute $\Delta B_{ij}$ for $j$ = Frq_i.  See page 42 in
        !  19 August 2004 ATBD JPL D-18130.
        !  T_Script and B needed to compute inc_rad_path by rad_tran_pol
        call two_d_t_script ( t_path_c(i_start:i_end), &  
          & spaceRadiance%values(1,1), frq, &
          & t_script(i_start:i_end), &
          & B(i_start:i_end) )
d3269 14
a3282 6
        call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f, &
          &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,              &
          &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,        &
          &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,       &
          &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1), &
          &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq )
d3284 10
a3293 1
          if ( atmos_second_der ) then
d3337 15
a3351 2
        call dt_script_dt ( t_path_c, B(:npc), eta_zxp_t_c(1:npc,:), &
                          & nz_zxp_t_c, nnz_zxp_t_c, frq, d_t_scr_dt(1:npc,:) )
a3496 1
      use MLSFillValues, only: isNaN
d3903 4
a3906 2
        call comp_eta_docalc_no_frq ( Grids_Iwc, z_path(1:npf), &
          &  phi_path(1:npf), eta_iwc_zp(1:npf,:), tan_pt=tan_pt_f )
d3909 4
a3912 2
        call comp_sps_path_no_frq ( Grids_iwc, eta_iwc_zp(1:npf,:), &
          & iwc_path(1:npf,:) )
d3915 1
a3915 1
          WC(1,1:npf)=iwc_path(1:npf,1)
d4051 2
a4052 1
        call get_eta_stru ( iwc_s, iwc_path(c_inds,1), eta_IWC_path_c )
a4174 10
          if ( any(isNaN(H_Atmos_Frq(frq_i,:,:)) ) ) then
            call MLSMessage( MLSMSG_Warning, ModuleName // 'One_Pointing', &
              & 'NaNs found in h_atmos_freq (after one_frequency)', status=status )
            if ( status == 0 ) then
              call output('Line-by-line', advance='yes' )
              call outputNamedValue( 'frq_i', frq_i )
              call outputNamedValue( 'ptg_i', ptg_i )
              call dump( H_Atmos_Frq(frq_i,:,:), 'H_Atmos_Frq(frq_i,:,:)', options='-H' )
            endif
          endif
a4213 10
          if ( any(isNaN(H_Atmos_Frq(frq_i,:,:)) ) ) then
            call MLSMessage( MLSMSG_Warning, ModuleName // 'One_Pointing', &
              & 'NaNs found in h_atmos_freq (after one_frequency)', status=status )
            if ( status == 0 ) then
              call output('PFA', advance='yes' )
              call outputNamedValue( 'frq_i', frq_i )
              call outputNamedValue( 'ptg_i', ptg_i )
              call dump( H_Atmos_Frq(frq_i,:,:), 'H_Atmos_Frq(frq_i,:,:)', options='-H' )
            endif
          endif
a4222 8
      if ( any(isNaN(H_Atmos(:,ptg_i,:,:)) ) ) then
        call MLSMessage( MLSMSG_Warning, ModuleName // 'One_Pointing', &
          & 'NaNs found in h', status=status )
        if ( status == 0 ) then
          call output('right before frequency average (will we zero them out?)', advance='yes' )
          call dump( H_Atmos(:,ptg_i,:,:), 'H_Atmos(:,ptg_i,:,:)', options='-H' )
        endif
      endif
a4224 8
      if ( any(isNaN(H_Atmos(:,ptg_i,:,:)) ) ) then
        call MLSMessage( MLSMSG_Warning, ModuleName // 'One_Pointing', &
          & 'NaNs found in h_atmos (at end of one_pointing)', status=status )
        if ( status == 0 ) then
          call output('right after frequency average (we did notzero them out)', advance='yes' )
          call dump( H_Atmos(:,ptg_i,:,:), 'H_Atmos(:,ptg_i,:,:)', options='-H' )
        endif
      endif
d4382 1
a4382 1
       "$Id: FullForwardModel_m.f90,v 2.310 2010/11/03 18:43:51 vsnyder Exp $"
d4392 3
@


2.310
log
@Initialize eta_fzp and H_Atmos.  Frequency average LBL second derivatives.
@
text
@d44 1
a44 1
      & DestroyForwardModelDerived, ForwardModelConfig_t
d55 1
d242 3
d322 1
d325 1
a325 1
    use Output_m, only: Output
d957 5
a961 1
      if ( .not. FwdModelConf%generateTScat ) then
d1299 1
d1302 3
d1440 12
a1451 1
              call convolve_other_deriv ( convolve_support, maf, chanInd, &
d1453 2
a1454 8
              & L1BMIF_TAI, MIFDeadTime, real(k_atmos(i,:,:),kind=rp), &
              & Jacobian, fmStat%rows )
            
              if (atmos_second_der ) then
                  call convolve_other_second_deriv ( convolve_support, maf, chanInd, &
                  & thisFraction, update, thisRadiance, beta_group%qty, Grids_f, &
                  & L1BMIF_TAI, MIFDeadTime, real(h_atmos(i,:,:,:),kind=rp), &
                  & Hessian, fmStat%rows )
d1864 1
d1876 12
d1957 10
a1968 1

d1971 1
d1978 1
d2002 14
a2019 1

d2022 1
d2135 2
d3466 1
d3504 1
d4140 10
d4189 10
d4208 8
d4218 8
d4383 1
a4383 1
       "$Id: FullForwardModel_m.f90,v 2.309 2010/09/25 01:08:39 vsnyder Exp $"
d4393 3
@


2.309
log
@Cannonball polishing
@
text
@d845 1
a845 1
!     eta_fzp = 0.0
d857 5
d1931 1
d4103 1
d4287 1
a4287 1
       "$Id: FullForwardModel_m.f90,v 2.308 2010/08/28 00:03:12 vsnyder Exp $"
d4297 3
@


2.308
log
@Shortened some overly long names.  Corrected allocation for H_Atmos_Frq.
Moved some TScat stuff to TScat_Support.  Some cannonball polishing.
@
text
@d2842 1
a2842 1
          & fwdModelConf, .false., .true. )
d4280 1
a4280 1
       "$Id: FullForwardModel_m.f90,v 2.307 2010/08/27 06:02:39 yanovsky Exp $"
d4290 4
@


2.307
log
@Major additions to support for computations of atmospheric second derivatives (atmospheric Hessians). FullForwardModel subroutine now has dummy variable Hessian.  Also, added Frequency_Average_Second_Derivative and Frequency_Average_Second_Derivatives subroutines.
@
text
@d111 2
a112 1
    logical :: temp_der, atmos_der, atmos_second_der, spect_der, ptan_der ! Flags for various derivatives
d308 1
a308 1
    use GLnp, only: GX, NGP1
d329 1
d490 1
a494 3
    real(rp) :: DALPHA_DT_PATH_A(max_c,s_ts*noUsedChannels) ! Frequency averaged
    ! dAlpha_dT_Path_C has a frequency dimension because it's needed to
    ! compute d_W0/dT.
d529 1
a529 1
    real(rp) :: TT_PATH_C(s_i*max_c)  ! tscat on path coarse
a534 2
    real(rp) :: BETA_PATH_A(max_c,no_mol,s_ts*noUsedChannels)  ! Frequency averaged
                                      ! Beta on path coarse
d737 2
a738 1
    ! Interpolation factors to put Mie beta_c_e and beta_c_s into path
d744 1
a744 1
    type (Grids_T) :: Grids_Tscat ! All the coordinates for scaterring source function
d862 3
a864 1
      call TScat_setup
d1668 1
a1668 1
          call frequency_average_second_derivatives ( ptg_i, frq_avg_sel == 15 )
a1807 1

d1835 2
a1836 3

  ! ...............................  Frequency_Average_Second_Derivative  .....
    subroutine Frequency_Average_Second_Derivative ( Grids, H_Frq, H, Mol1, Mol2, Combine )
d1921 1
a1921 1
    end subroutine Frequency_Average_Second_Derivative
d1924 2
a1925 2
  ! ..............................  Frequency_Average_Second_Derivatives  .....
    subroutine Frequency_Average_Second_Derivatives ( Ptg_i, Combine )
d1942 4
a1945 2
            if ( fwdModelConf%moleculeSecondDerivatives(k) .and. fwdModelConf%moleculeSecondDerivatives(kk) ) then
              call frequency_average_second_derivative ( grids_f, h_atmos_frq(:ub,:,:), h_atmos(:,ptg_i,:,:), k, kk, combine )
d1947 2
a1948 1
              h_atmos(:, ptg_i, grids_f%l_v(k-1)+1:grids_f%l_v(k), grids_f%l_v(kk-1)+1:grids_f%l_v(kk)) = 0.0
d1956 1
a1956 1
    end subroutine Frequency_Average_Second_Derivatives
d2074 1
a2074 2
                         & max(maxNoPtgFreqs,noUsedChannels), &
                         & sv_dim, 'h_atmos_frq', moduleName )
d2132 1
d2237 6
a2242 3
          call output ( freq_ix(f_i), before="freq_ix(f_i) = ", after=", " )
          call dump ( f_s, name="F_s" )
          call dump ( channelCenters, name="ChannelCenters" )
a2698 46
    ! ---------------------------------  Interpolate_P_to_theta_e  -----
    subroutine Interpolate_P_to_theta_e ( P, Eta_t_iwc, Theta_e, Beg_Pos_Theta, &
      &                                   Xis, Coeffs, P_on_Xi )

      ! Interpolate P or dP_dT or dP_dIWC from Theta to Xi, for TScat
      ! generation, using periodic spline interpolation.

      use MLSKinds, only: Rp
      use MLSNumerics, only: Coefficients_r8, InterpolateValues

      real(rp), intent(in) :: P(0:,0:,:) ! P or dP_dT or dP_dIWC on T x IWC x Theta
      real(rp), intent(in) :: Eta_T_IWC(0:,0:) ! 2x2, to interpolate to T, IWC
      real(rp), intent(in) :: Theta_e(:) ! Theta extended to negative values
      integer, intent(in) :: Beg_Pos_Theta ! 1 or 2, depending on whether
                                         ! theta_e(1) is nonzero or zero
      real(rp), intent(in) :: Xis(:) ! Angles on which radiative transfer calculated
      type(coefficients_r8), intent(in) :: Coeffs ! To interpolate from Theta_e to Xis
      real(rp), intent(out) :: P_on_Xi(:) ! Interpolated result

      real(rp) :: P_T_IWC(size(p,3)) ! P interpolated to T and IWC
      real(rp) :: P_on_Theta_e(2*size(p_t_iwc)+1-beg_pos_theta) ! P * sin(abs(theta))
                               ! interpolated to scattering point IWC and T for
                               ! each theta (including negative theta), intermediary
                               ! to getting P_On_Xi

      integer :: I

      ! Interpolate P to scattering point IWC and temperature and
      ! multiply that by sin(theta)
      do i = 1, size(p_t_iwc)
        p_t_iwc(i) = &
          & sum(eta_t_iwc(0:1,0:1) * p(0:1,0:1,i) ) * abs(sin(theta_e(i)))
      end do

      ! The phase function is symmetric in theta, but the radiances
      ! are not.  Unfold p_t_iwc to negative theta.
      p_on_theta_e(1:size(p_t_iwc)) = p_t_iwc(size(p_t_iwc):1:-1)
      p_on_theta_e(size(p_t_iwc)+1:2*size(p_t_iwc)+1-beg_pos_theta) = &
        & p_t_iwc(beg_pos_theta:)

      ! Now interpolate P_On_Theta_e to P_On_Xi using a periodic spline
      call interpolateValues ( coeffs, theta_e, p_on_theta_e, &
        & xis, p_on_xi, method='S', extrapolate='P' )

    end subroutine Interpolate_P_to_theta_e

d2705 1
a2705 1
      & K_Atmos_Frq, H_Atmos_Frq, K_Spect_dN_Frq, K_Spect_dV_Frq,           &
d2764 1
a2765 1
      real(rp), intent(out) :: H_ATMOS_FRQ(:,:) ! d2I/(dVMRq dVMRr), ptg.frq X vmr-SVq X vmr-SVr
d3950 2
a3951 2
        call get_eta_stru ( t_s, t_path_c, eta_t_path_c )
        call get_eta_stru ( iwc_s, iwc_path(c_inds,1), eta_iwc_path_c )
d4071 1
a4071 1
            & K_Atmos_Frq(frq_i,:), H_Atmos_Frq(frq_i,:,:),                     &
a4086 12
      if ( FwdModelConf%useTScat ) then
        ! Frequency average some quantities along the path so we can combine
        ! them with TScat table quantities, which are channel quantities.
        do mol = 1, no_mol
          call frequency_avg_path ( frequencies, &
            & beta_path_c(:npc,mol,:), beta_path_a(:npc,mol,:) )
        end do
        call frequency_avg_path ( frequencies, &
          & dAlpha_dT_path_c(:npc,:), dAlpha_dT_path_a(:npc,:) )
        !{ Compute $\tau^s_{ic}$ given by Equation (6) in wvs-095
      end if

d4109 1
a4109 1
            & K_Atmos_Frq(frq_i,:), H_Atmos_Frq(frq_i,:,:),                     &
a4180 80
  ! ...............................................  TScat_Config  .....
    subroutine TScat_Config ( TScat_Conf, FmConf, Signal )
      ! Create an ersatz ForwardModelConfig to drive the linearized
      ! model's computation of TScat radiances during clear-sky path
      ! integration.
      type(forwardModelConfig_T), intent(out) :: TScat_Conf
      type(forwardModelConfig_T), intent(in) :: FMconf
      type(signal_t), target :: Signal(1)
      TScat_conf = fmConf
      TScat_conf%signals => signal ! Linearized model requires only one signal
      TScat_conf%molecules => fmConf%TScatMolecules
      TScat_conf%moleculeDerivatives => fmConf%TScatMoleculeDerivatives
      TScat_conf%phiWindow = 0.0
      TScat_conf%xStar = 0
      TScat_conf%yStar = 0
    end subroutine TScat_Config

  ! ................................................  TScat_Setup  .....
    subroutine TScat_Setup
      ! Get ready for computation of TScat table
      use Intrinsic, only: L_ScatteringAngle
      use Read_Mie_m, only: dP_dT, F_s, P
      logical :: Error
      integer :: Q ! Loop index
      type (VectorValue_T), pointer :: TScat, TScat2
      if ( .not. associated(p) .or. .not. associated(F_s) .or. &
        &  .not. associated(dP_dT) ) &
        & call announce_error ( 'TScat table computation requires Mie tables.' )
      if ( FwdModelConf%do_conv ) call announce_error ( &
        & 'Convolution and TScat computation are incompatible.' )
      if ( FwdModelConf%incl_cld ) call announce_error ( &
        & 'Cloud modeling and TScat computation are incompatible.' )
      if ( FwdModelConf%polarized ) call announce_error ( &
        & 'Cannot compute TScat for the polarized model.' )
      if ( FwdModelConf%refract ) call announce_error ( &
        & 'Refractive correction and TScat computation are incompatible.' )
      if ( FwdModelConf%spect_der ) call announce_error ( &
        & 'Spectroscopy derivatives and TScat computation are incompatible.' )
      ! Get IWC field
      iwc => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_vmr, molecule=l_cloud_a, config=fwdModelConf )
      ! Make sure all the TScat quantities for the selected signals have the
      ! same grids
      TScat => GetQuantityForForwardModel ( &
          & fwdModelOut, quantityType=l_TScat, &
          & signal=fwdModelConf%signals(channels(1)%signal)%index, &
          & sideband=sideband )
      if ( .not. TScat%template%coherent .or. &
        &  .not. TScat%template%stacked ) call announce_error ( &
          & 'TScat coordinates must be stacked and coherent' )
      TScat%values = 0.0
      error = .false.
      do q = 2, noUsedChannels
        TScat2 => GetQuantityForForwardModel ( &
          & fwdModelOut, quantityType=l_TScat, &
          & signal=fwdModelConf%signals(channels(q)%signal)%index, &
          & sideband=sideband )
        error = .not. TScat2%template%coherent .or. &
          &     .not. TScat2%template%stacked .or. &
          &     TScat%template%noChans /= TScat2%template%noChans .or. &
          &     TScat%template%hGridIndex /= TScat2%template%hGridIndex .or. &
          &     TScat%template%vGridIndex /= TScat2%template%vGridIndex
        if ( error ) exit
        TScat2%values = 0.0
      end do
      if ( error ) call announce_error ( "TScat quantities must all have the same grids." )
      ! Make sure IWC and temperature are coherent and stacked
      if ( .not. temp%template%stacked .or. .not. temp%template%coherent .or. &
         & .not.  iwc%template%stacked .or. .not.  iwc%template%coherent ) &
         & call announce_error ( "IWC and temperature must be coherent and stacked." )
      ! Make sure IWC and temperature have the same grids as TScat
      if ( TScat%template%hGridIndex /= temp%template%hGridIndex .or. &
         & TScat%template%vGridIndex /= temp%template%vGridIndex .or. &
         & TScat%template%hGridIndex /=  iwc%template%hGridIndex .or. &
         & TScat%template%vGridIndex /=  iwc%template%vGridIndex ) &
         & call announce_error ( "TScat, IWC and temperature must have the same grids." )
      scatteringAngles => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_scatteringAngle, config=fwdModelConf )
    end subroutine TScat_Setup

d4280 1
a4280 1
       "$Id: FullForwardModel_m.f90,v 2.306 2010/08/19 02:14:03 vsnyder Exp $"
d4290 7
@


2.306
log
@Substantial changes, the most significant being to put the body of the
frequency loop in a subroutine of its own called One_Frequency, delete
the subroutine Frequency_Loop, put the frequency loop around the calls
to One_Frequency, and pass in sections of some arrays that used to be
accessed by host association, and subscripted with the frequency index.
Also, some other stuff inching toward TScat processing.
@
text
@d36 1
a36 1
                             &  FwdModelOut, FmStat, Jacobian )
d48 1
d64 1
d100 1
d111 1
a111 1
    logical :: temp_der, atmos_der, spect_der, ptan_der ! Flags for various derivatives
d148 3
a150 1
    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der
d229 1
d249 2
a250 2
                              & s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i,   &
                              & s_tg, s_ts,                                    &
d252 1
a252 1
                              & Jacobian )
d280 2
a281 2
                              & s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i,   &
                              & s_tg, s_ts,                                    &
d283 1
a283 1
                              & Jacobian )
d307 2
a308 1
    use GLnp, only: GX
d372 1
d382 2
a383 1
    type(matrix_T), intent(inout), optional :: Jacobian
d455 1
d597 5
d632 1
d722 1
d821 1
a821 1
      & k_temp_frq, RadV, t_script_lbl )
d991 2
a992 1
      call deallocate_test ( k_atmos_frq,  'k_atmos_frq',      moduleName )
d994 3
a996 3
      call deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq',   moduleName )
      call deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq',   moduleName )
      call deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq',   moduleName )
d1113 1
d1282 1
a1282 1
        & Convolve_Other_Deriv, Interpolate_Radiance, &
d1425 7
d1663 9
a1671 1
      if ( any_der ) call frequency_average_derivatives ( ptg_i, frq_avg_sel == 15 )
d1807 1
d1835 122
d2070 6
d2746 2
a2747 2
      & K_Atmos_Frq, K_Spect_dN_Frq, K_Spect_dV_Frq, K_Spect_dW_Frq,        &
      & K_Temp_Frq )
d2768 1
a2768 1
        & DRAD_TRAN_DT, DRAD_TRAN_DX
d2806 1
d3252 9
d4112 3
a4114 2
            & K_Atmos_Frq(frq_i,:), K_Spect_dN_Frq(frq_i,:),                    &
            & K_Spect_dV_Frq(frq_i,:), K_Spect_dW_Frq(frq_i,:), K_Temp_Frq(frq_i,:) )
d4162 3
a4164 2
            & K_Atmos_Frq(frq_i,:), K_Spect_dN_Frq(frq_i,:),                    &
            & K_Spect_dV_Frq(frq_i,:), K_Spect_dW_Frq(frq_i,:), K_Temp_Frq(frq_i,:) )
d4413 1
a4413 1
       "$Id: FullForwardModel_m.f90,v 2.305 2010/06/12 01:30:54 vsnyder Exp $"
d4423 8
@


2.305
log
@Give frequency dimension to alpha_path_c and beta_path_c.  Make
Frequency_Loop the body of the frequency loop instead of doing the
loop in it.  Pass in lower-dimensional sections of several arrays,
with the section selected according to the frequency loop index.
@
text
@d16 1
d26 2
a27 2
  integer, private, parameter :: Max_New = 4 ! Maximum new points in coarse
    ! path in addition to ones derived from the preselected zeta grid:
a47 1
    use GLnp, only: NGP1
d301 1
a301 1
    use GLnp, only: GX, NGP1
d409 1
d479 2
a480 2
    real(rp) :: Beta_c_e_path_C(s_ts*max_c)  ! Beta_c_e on path coarse
    real(rp) :: Beta_c_s_path_C(s_ts*max_c)  ! Beta_c_s on path coarse
d482 1
d491 4
d525 2
a558 1
    real(rp) :: ETA_ZXP_T_F(max_f,s_t*sv_t_len)    ! ETA_ZXP_T on fine grid
d571 1
a573 1
    real(rp) :: TT_PATH(max_f,s_i)                 ! TScat on path along the LOS
a693 3
    ! Fine path X frequency X 2, final subscript = 1 for j=i+1, 2 for j=i-1
    real(rp), pointer :: W0_FRQ_PATH(:,:,:) ! omega_0(j) * Tau(i)

d705 1
a705 1
    real(rp), pointer :: T_SCRIPT_LBL(:,:) ! Delta_B in some notes
d804 1
a804 1
      & k_temp_frq, RadV, t_script_lbl, w0_frq_path )
d958 1
a958 1
        & call deallocate_test ( frequencies, 'frequencies',   moduleName )
d961 4
a964 4
      call deallocate_test ( dAlpha_dT_path_c, 'dAlpha_dT_path_c',   moduleName )
      call deallocate_test ( beta_path_c,      'Beta_Path_C',        moduleName )
      call deallocate_test ( inc_rad_path,     'Inc_Rad_Path',       moduleName )
      call deallocate_test ( radv, 'RadV', moduleName )
d966 2
a967 2
        call deallocate_test ( t_script_LBL, 'T_Script_LBL',   moduleName )
        call destroy_tau ( tau_LBL, "Tau_LBL", moduleName )
a968 1
      call deallocate_test ( w0_frq_path,    'W0_Frq_Path',    moduleName )
d972 1
a972 1
        & call deallocate_test ( k_temp_frq,   'k_temp_frq',     moduleName )
d974 1
a974 2
      if ( atmos_der ) &
        & call deallocate_test ( k_atmos_frq,  'k_atmos_frq',    moduleName )
d976 3
a978 5
      if ( spect_der ) then
        call deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq', moduleName )
        call deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq', moduleName )
        call deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq', moduleName )
      end if
d1625 1
a1625 1
        ! Tau_PFA in Frequency_Loop to combine LBL and PFA contributions.
d1628 1
a1628 1
            radiances(c,ptg_i) = radV(c) ! Computed in Frequency_Loop
d1774 1
a1774 1
    subroutine Frequency_Avg_Path ( Path_Freq, Path_Chan )
d1781 1
d1790 1
a1790 1
          do p = 1, npc
d1800 2
a1801 7
  ! .............................................  Frequency_Loop  .....
    subroutine Frequency_Loop ( Ptg_i, Frq_i, Alpha_Path_c, Beta_Path_c,     &
      & C_Inds, Del_S, Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL, Frq,        &
      & H_Path_C, Tan_Ht, IncOptDepth, P_Path, PFA, Ref_Corr, Sps_Path,      &
      & Tau, T_Path_c, T_Script, Tanh1_c, TT_Path_c, W0_Path_c, Z_Path,      &
      & I_Start, I_End, Inc_Rad_Path, RadV, dAlpha_dT_Path_C, K_Atmos_Frq,   &
      & K_Spect_dN_Frq, K_Spect_dV_Frq, K_Spect_dW_Frq, K_Temp_Frq )
d1803 1
a1803 24
      ! Having arguments instead of using host association serves two
      ! purposes:  The array sizes are implicit, so we don't need explicitly
      ! to mention them, and the pointer attribute gets stripped during the
      ! trip through the CALL statement -- hopefully thereby helping optimizers.
      use CS_Expmat_m, only: CS_Expmat
      use DO_T_SCRIPT_M, only: TWO_D_T_SCRIPT, TWO_D_T_SCRIPT_CLOUD
      use D_T_SCRIPT_DTNP_M, only: DT_SCRIPT_DT
      use Dump_Path_m, only: Dump_Path
      use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, &
        & Get_Beta_Path_PFA, Get_Beta_Path_Polarized
      use Get_d_Deltau_pol_m, only: Get_d_Deltau_pol_df, Get_d_Deltau_pol_dT
      use Get_Eta_Matrix_m, only: Get_Eta_Stru, Interpolate_Stru, Select_NZ_List
      use Load_Sps_Data_m, only:  Load_One_Item_Grid
      use Mcrt_m, only: Mcrt_der
      use Opacity_m, only: Opacity
      use Path_Contrib_M, only: Path_Contrib
      use Physics, only: H_OVER_K
      use RAD_TRAN_M, only: RAD_TRAN_POL, DRAD_TRAN_DF, &
        & DRAD_TRAN_DT, DRAD_TRAN_DX
      use Read_Mie_m, only: dBeta_dIWC_c_e, dBeta_dIWC_c_s, &
        & dBeta_dIWC_c_e, dBeta_dT_c_s, F_s, IWC_s, Log_Beta_c_e, Log_Beta_c_s, &
        & Log_Mie, T_s
      use ScatSourceFunc, only: T_SCAT, Interp_Tscat, Convert_Grid
      use Tau_M, only: Get_Tau
d1805 2
a1806 36
      integer, intent(in) :: Ptg_i        ! Pointing index
      integer, intent(in) :: Frq_i        ! Frequency loop index
      real(rp), intent(out) :: Alpha_Path_c(:) ! \sum Beta_Path * mixing ratio
      real(rp), intent(out) :: Beta_Path_c(:,:) ! path x species
      real(rp), intent(in) :: Del_S(:)    ! Integration lengths along path
      real(rp), intent(in) :: Del_Zeta(:) ! Integration lengths in Zeta coords
      integer, intent(in) :: C_Inds(:)    ! Selectors from complete path to coarse path
      logical, intent(inout) :: Do_Calc_fzp(:,:) ! 'Avoid zeros' indicator
      logical, intent(in) :: Do_Calc_zp(:,:) ! 'Avoid zeros' indicator
      logical, intent(out) :: Do_GL(:)    ! Where to do GL correction
      real(r8), intent(in) :: Frq         ! The frequency
      real(rp), intent(in) :: H_Path_C(:) ! Heights on coarse path
      real(rp), intent(in) :: Tan_Ht      ! Geometric tangent height, km, 
                                          ! from equivalent Earth center
      real(rp), intent(out) :: IncOptDepth(:)  ! Incremental optical depth
      real(rp), intent(in) :: P_Path(:)   ! Pressures along complete path
      logical, intent(in) :: PFA          ! Are we doing PFA or not?
      real(rp), intent(in) :: Ref_Corr(:) ! Refraction correction
      real(rp), intent(inout) :: Sps_Path(:,:) ! Species on path
      type(tau_t), intent(inout) :: Tau   ! Optical depth, inout so as not to
                                          ! undefine components' association status
      real(rp), intent(in) :: T_Path_c(:) ! Temperature on coarse path
      real(rp), intent(out) :: T_Script(:)! Planck function, Delta_B in some notes
      real(rp), intent(out) :: TT_Path_c(:) ! tscat on coarse path
      real(rp), intent(out) :: Tanh1_c(:) ! tanh(frqhk/t_path_c)
      real(rp), intent(out) :: W0_Path_c(:) ! w0 on coarse path
      real(rp), intent(in) :: Z_Path(:)   ! -Log10(Pressures) along complete path
      integer, intent(in) :: I_Start, I_End ! Bounds for coarse path integration
      real(rp), intent(out) :: RadV       ! Radiance
      real(rp), intent(out) :: dAlpha_dT_Path_c(:) ! dAlpha/dT on coarse path
      real(rp), intent(out) :: INC_RAD_PATH(:) ! Incremental radiance along the path
      real(rp), intent(out) :: K_ATMOS_FRQ(:)  ! dI/dVMR, ptg.frq X vmr-SV
      real(rp), intent(out) :: K_SPECT_DN_FRQ(:) ! ****
      real(rp), intent(out) :: K_SPECT_DV_FRQ(:) ! ****
      real(rp), intent(out) :: K_SPECT_DW_FRQ(:) ! ****
      real(rp), intent(out) :: K_TEMP_FRQ(:)   ! dI/dT, ptg.frq X T-SV
d1808 2
a1809 6
      real(r8) :: FRQHK                   ! 0.5 * Frq * H_Over_K
      integer :: I_STOP                   ! Stop path integration before I_End
      integer :: J, L                     ! Loop inductor and subscript
      integer :: Mie_Frq_Index            ! Index of Frq in F_s in Read_Mie
      integer :: P_Stop                   ! Where to stop in polarized case
      logical :: PFA_or_not_pol           ! PFA .or. .not. fwdModelConf%polarized
d1811 6
a1816 1
      ! Loop over frequencies ----------------------------------------------
d1818 1
a1818 2
      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call Trace_Begin ( 'ForwardModel.FrequencyLoop' )
d1820 1
a1820 1
      pfa_or_not_pol = pfa .or. .not. fwdModelConf%polarized
d1822 11
a1832 2
      if ( toggle(emit) .and. levels(emit) > 5 ) &
        & call Trace_Begin ( 'ForwardModel.Frequency ', index=frq_i )
d1834 10
a1843 1
      do_gl = .false.
d1845 16
a1860 1
      ! Set up path quantities --------------------------------------
d1862 2
a1863 12
      ! Compute the sps_path for this Frequency
      call comp_sps_path_frq ( Grids_f, Frq, eta_zp(:npf,:), &
        & do_calc_zp, sps_path,                              &
        & do_calc_fzp, eta_fzp(:npf,:),                      &
        & firstSignal%lo, thisSideband )
!         ! Send all of eta_zp so comp_sps_path_frq_nz doesn't get an array
!         ! bounds error when it's clearing parts indexed by nz_zp.
! I don't know why this doesn't work
!         call comp_sps_path_frq_nz ( Grids_f, Frq, eta_zp, nz_zp, nnz_zp, &
!           & do_calc_zp, sps_path,                                        &
!           & do_calc_fzp, eta_fzp(:npf,:), nz_fzp, nnz_fzp,               &
!           & firstSignal%lo, thisSideband )
d1865 1
a1865 17
      if ( pfa ) then
        call get_beta_path_PFA ( frq, frq_i, z_path, c_inds, t_path_c, &
          & beta_group, sx, vel_rel, sps_path, beta_path_c,            &
          & t_der_path_flags, dbeta_dT_path_c, dbeta_dw_path_c,        &
          & dbeta_dn_path_c, dbeta_dv_path_c, dbeta_dIWC_path_c )
      else
        frqhk = 0.5_r8 * frq * h_over_k    ! h nu / 2 k
        tanh1_c = tanh( frqhk / t_path_c ) ! tanh ( h nu / 2 k T )
        ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
        if ( temp_der ) dTanh_dT_c(:npc) = &
            & frqhk / t_path_c**2 * ( tanh1_c - 1.0_rp / tanh1_c )
        call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_c,      &
          &  tanh1_c, beta_group, sx, fwdModelConf%polarized, gl_slabs,  &
          &  c_inds, beta_path_c, t_der_path_flags, dTanh_dT_c, vel_rel, &
          &  dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c,          &
          &  dbeta_dv_path_c, sps_path )
      end if
d1867 4
a1870 4
      if ( FwdModelConf%incl_cld .and. .not. pfa ) then
        ! Compute Scattering source function based on temp prof at all
        ! angles U for each temperature layer assuming a plane parallel
        ! atmosphere.
d1872 1
a1872 5
        if ( ptg_i == 1 ) then
        ! ??? Can this work?  On all pointings after the first one, ???
        ! ??? it uses the result for the last frequency.            ???
        ! ??? We have a different frequency grid for each pointing, ???
        ! ??? so is this the wrong idea in the first place?         ???
d1874 1
a1874 7
          call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),      & 
             & 10.0**(-temp%template%surfs), vmrArray(1,:), vmrArray(2,:), &
             & vmrArray(3,:),fwdModelConf%num_scattering_angles,           &
             & fwdModelConf%num_azimuth_angles,                            &
             & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,      &
             & fwdModelConf%no_cloud_species,                              &
             & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang )
d1876 7
a1882 1
        end if
d1884 4
a1887 1
        scat_src%template = temp%template
d1889 2
a1890 2
        call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, &
          & fwdModelConf, .false., .true. )
d1892 34
a1925 3
        call comp_eta_docalc_no_frq ( grids_tscat, z_path(1:npf), &
          &  phi_path(1:npf), eta_tscat_zp(1:npf,:),              &
          &  do_calc_tscat_zp(1:npf,:), tan_pt=tan_pt_f )
d1927 1
a1927 4
        call comp_sps_path_frq ( grids_tscat,                &
          & frq_0, eta_tscat_zp(1:npf,:),                    &
          & do_calc_tscat_zp(1:npf,:), tscat_path(1:npf,:),  &
          & do_calc_tscat(1:npf,:), eta_tscat(1:npf,:) )
d1929 2
a1930 3
! I don't know why this doesn't work
!           call comp_sps_path_no_frq ( Grids_tscat, eta_tscat_zp(1:npf,:), &
!             & tscat_path(1:npf,:) )
d1932 2
a1933 3
        ! project Tscat onto LOS
        call interp_tscat ( tscat_path(1:npf,:), Scat_ang(:), &
          & phi_path(1:npf), tt_path(1:npf,:) )
d1935 2
a1936 1
        if ( .not. cld_fine ) then                 ! interpolate onto gl grids along the LOS
d1938 1
a1938 2
          scat_alb%template = temp%template
          cld_ext%template  = temp%template
d1940 6
a1945 2
          call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false.)
          call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false.)             
d1947 1
a1947 2
          where ( abs(grids_salb%values) < TOL ) grids_salb%values = 0.0
          where ( abs(grids_cext%values) < TOL ) grids_cext%values = 0.0
d1949 1
a1949 3
          call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:npf), &
            &  phi_path(1:npf), eta_salb_zp(1:npf,:),              &
            &  do_calc_salb_zp(1:npf,:), tan_pt=tan_pt_f )
d1951 2
a1952 4
          call comp_sps_path_frq ( Grids_salb,               &
            & frq_0, eta_salb_zp(1:npf,:),                   &
            & do_calc_salb_zp(1:npf,:), salb_path(1:npf,:),  &
            & do_calc_salb(1:npf,:), eta_salb(1:npf,:) )
d1954 2
a1955 3
! I don't know why this doesn't work
!             call comp_sps_path_no_frq ( Grids_salb, eta_salb_zp(1:npf,:), &
!               & salb_path(1:npf,:) )
d1957 12
a1968 3
          call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:npf), &
            &  phi_path(1:npf), eta_cext_zp(1:npf,:),              &
            &  do_calc_cext_zp(1:npf,:), tan_pt=tan_pt_f )
d1970 38
a2007 4
          call comp_sps_path_frq ( Grids_cext,               &
            & frq_0, eta_cext_zp(1:npf,:),                   &
            & do_calc_cext_zp(1:npf,:), cext_path(1:npf,:),  &
            & do_calc_cext(1:npf,:), eta_cext(1:npf,:) )
d2009 3
a2011 3
! I don't know why this doesn't work
!             call comp_sps_path_no_frq ( Grids_cext,  eta_cext_zp(1:npf,:), &
!               & cext_path(1:npf,:) )
d2013 21
a2033 4
          call convert_grid ( salb_path(1:npf,:), cext_path(1:npf,:),  & 
                            & tt_path(1:npf,:), c_inds,                & 
                            & beta_path_cloud_c(1:npc), w0_path_c,     & 
                            & tt_path_c )
d2035 1
a2035 1
        else
d2037 3
a2039 4
          ! cld_fine              re-compute cext and w0 along the LOS
          call get_beta_path_cloud ( Frq, t_path(1:npf), tt_path(1:npf,:), &
            &  c_inds, beta_path_cloud_c(1:npc), w0_path_c, tt_path_c,     &
            &  IPSD(1:npf),  WC(:,1:npf), fwdModelConf )
d2041 2
a2042 1
        end if
d2044 2
a2045 6
        do j = 1, npc ! Don't trust compilers to fuse loops
          alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                &        beta_path_c(j,:) )     &
                                & + beta_path_cloud_c(j)
          incoptdepth(j) = alpha_path_c(j) * del_s(j)
        end do
d2047 1
a2047 3
        ! Needed to compute inc_rad_path and by rad_tran_pol
        call two_d_t_script_cloud ( t_path_c, tt_path_c, w0_path_c, &  
          & spaceRadiance%values(1,1), frq, t_script, B(:npc) )
d2049 4
a2052 1
      else ! Not cloud model
d2054 25
a2078 6
        !{ {\tt incoptdepth} is $\Delta \delta_{s\rightarrow s-1} =
        !  \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
        !    \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
        !  $G(\zeta)$ is {\tt alpha\_path\_c}, which is approximated
        !  here by the rectangle rule, \emph{viz.}
        !  $\Delta \delta_{i\rightarrow i-1} \approx G(\zeta_i) \delta s_i$.
d2080 3
a2082 6
        do j = i_start, i_end ! Don't trust compilers to fuse loops
          alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                       & beta_path_c(j,:) )
          incoptdepth(j) = alpha_path_c(j) * del_s(j)
        end do
        incoptdepth(i_end+1:npc) = 0.0 ! if not integrating full path
d2084 1
a2084 5
        ! T_Script and B needed to compute inc_rad_path and by rad_tran_pol
        call two_d_t_script ( t_path_c(i_start:i_end), &  
          & spaceRadiance%values(1,1), frq, &
          & t_script(i_start:i_end), &
          & B(i_start:i_end) )
d2086 2
a2087 1
      end if ! end of check cld 
d2089 6
a2094 21
      if ( fwdModelConf%useTScat .and. .not. pfa ) then
        ! Determine the frequency subscript for the Mie tables.
        ! We expect size(F_s) to be small.
        Mie_frq_index = minloc(abs(f_s-frq),1)
        if ( abs(f_s(Mie_frq_index)-frq) > fwdModelConf%frqTol ) &
          & call MLSMessage ( MLSMSG_Error, moduleName, &
            & "UseTScat requested but no Mie tables near enough to Frq" )
        call log_Mie ! Get log_beta_c_e and log_beta_c_s if not done yet
        ! Interpolate Mie beta_c_e and beta_c_s to T and IWC on path
        ! First get interpolating coefficients from Mie tables to T and
        ! IWC on the coarse path.
        call get_eta_stru ( t_s, t_path_c, eta_t_path_c )
        call get_eta_stru ( iwc_s, iwc_path(c_inds,1), eta_iwc_path_c )
        call interpolate_stru ( log_beta_c_e(:,:,Mie_frq_index), &
          & eta_t_path_c, eta_iwc_path_c, &
          & beta_c_e_path_c ) ! Actually getting log(beta_c_e_path_c)
        call interpolate_stru ( log_beta_c_s(:,:,Mie_frq_index), &
          & eta_t_path_c, eta_iwc_path_c, &
          & beta_c_s_path_c ) ! Actually getting log(beta_c_s_path_c)
        ! Get W0_Path
        w0_path_c = exp(beta_c_s_path_c) / ( alpha_path_c + exp(beta_c_e_path_c) )
d2097 26
a2122 2
      if ( .not. fwdModelConf%polarized ) then
        ! Determine where to use Gauss-Legendre for scalar instead of a trapezoid.
d2124 1
a2124 2
        call path_contrib ( incoptdepth, tan_pt_c, i_start, i_end, &
          &                 e_rflty, fwdModelConf%tolerance, do_gl )
d2126 7
a2132 2
      else ! Extra stuff for polarized case
           ! Can't be doing TScat, so process the whole path
d2134 11
a2144 2
        call get_beta_path_polarized ( frq, h, beta_group%lbl(sx), gl_slabs, &
          & c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )
d2146 2
a2147 5
        ! We put an explicit extent of -1:1 for the first dimension in
        ! the hope a clever compiler will do better optimization with
        ! a constant extent.
        ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
        ! to alpha here
d2149 3
a2151 8
        do j = 1, npc
          alpha_path_polarized(-1:1,j) = &
            & matmul( beta_path_polarized(-1:1,j,:),       &
            &         sps_path(c_inds(j),:) ) * tanh1_c(j) &
            & + 0.25 * alpha_path_c(j)
          alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
            & 0.25 * alpha_path_c(j)
        end do
d2153 2
a2154 3
        ! Turn sigma-, pi, sigma+ into 2X2 matrix incoptdepth_pol
        call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
          & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )
d2156 2
a2157 6
        ! We don't add unpolarized incremental optical depth to diagonal
        ! of polarized incremental optical depth because we added the
        ! scalar alpha_path to the sigma-, pi and sigma+ parts of
        ! alpha_path_polarized above.  If we did add it here, we would
        ! need 0.5 factors to scale unpolarized "power absorption" to
        ! get "field absorption"
d2159 1
a2159 5
        do j = 2, npc-1
          incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j)
          incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j) * del_s(j)
          incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j) * del_s(j)
          incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j)
d2161 2
a2162 3
          ! deltau_pol = exp(incoptdepth_pol)
          call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
        end do
d2164 3
a2166 3
        ! Determine where to do GL
        call path_contrib ( deltau_pol(:,:,1:npc), tan_pt_c, e_rflty, &
           & fwdModelConf%tolerance, do_gl )
d2168 2
a2169 1
      end if
d2171 2
a2172 14
      !{ We want $\Delta \delta_{s\rightarrow s-1} =
      ! \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
      ! $G(\zeta)$ is {\tt alpha\_path\_c}, but $\frac{\text{d}s}{\text{d}h}$
      ! is singular at the tangent point, so we compute
      ! $\Delta \delta_{s\rightarrow s-1} = G(\zeta_i) \delta s_i +
      ! \int_{\zeta_i}^{\zeta_{i-1}} \left(G(\zeta)-G(\zeta_i)\right)
      ! \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      ! \text{d} \zeta$.
      !
      ! Where we do GL, the second integral is approximated using GL (in
      ! {\tt Get\_Tau}).  Where we don't do GL, approximate it using the
      ! trapezoid rule (here).  There is already a factor of 0.5 in
      ! {\tt del\_zeta}, to compensate for the GL weights summing to 2.0.
d2174 9
a2182 10
      do j = i_start+1, tan_pt_c
        if ( .not. do_gl(j) ) &
          & incoptdepth(j) = incoptdepth(j) + &
            & ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1)*del_zeta(j)
      end do
      do j = tan_pt_c+1, i_end-1
        if ( .not. do_gl(j) ) &
          & incoptdepth(j) = incoptdepth(j) + &
            & ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1)*del_zeta(j)
      end do
d2184 2
a2185 5
      call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, cg_inds_b, ngl, ncg )
      cg_inds => cg_inds_b(:ncg)
      gl_inds => gl_inds_b(:ngl)
      ! ngl is ng * count(do_gl)
      t_path_f(:ngl) = t_path(gl_inds)
d2187 1
a2187 1
      if ( pfa ) then
d2189 1
a2189 4
        call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds, t_path_f(:ngl), &
          & beta_group, sx, vel_rel, sps_path, beta_path_f(:ngl,:),           &
          & t_der_path_flags, dbeta_dT_path_f, dbeta_dw_path_f,               &
          & dbeta_dn_path_f, dbeta_dv_path_f, dbeta_dIWC_path_f )
d2191 2
a2192 1
      else
d2194 3
a2196 5
        tanh1_f(1:ngl) = tanh( frqhk / t_path_f(:ngl) )
        ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
        if ( temp_der ) &
          & dTanh_dT_f(1:ngl) = frqhk / t_path_f(1:ngl)**2 * &
            & ( tanh1_f(1:ngl) - 1.0_rp / tanh1_f(1:ngl) )
d2198 7
a2204 4
        ! The derivatives that get_beta_path computes depend on which
        ! derivative arrays are allocated, not which ones are present.
        ! This avoids having four paths through the code, each with a
        ! different set of optional arguments.
d2206 5
a2210 5
        call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_f(:ngl),    &
          & tanh1_f(1:ngl), beta_group, sx, fwdModelConf%polarized, gl_slabs,&
          & gl_inds, beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,      &
          & vel_rel, dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f,      &
          & dbeta_dv_path_f, sps_path )
d2212 6
a2217 1
      end if ! .not. pfa
d2219 5
a2223 5
      do j = 1, ngl ! loop around dot_product instead of doing sum(a*b,2)
                    ! to avoid path-length array temps
        alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                     & beta_path_f(j,:) )
      end do
d2225 1
a2225 7
      if ( print_incopt ) then
        call dump ( beta_path_c(i_start+1:i_end-1,:), name="Beta_Path" )
        call dump ( sps_path(c_inds(i_start+1:i_end-1),:), name="SPS_Path" )
        call dump ( alpha_path_c(i_start+1:i_end-1), name="Alpha_Path_C" )
        call dump ( incoptdepth(i_start+1:i_end-1), name="Incoptdepth" )
        call dump ( del_s(i_start+1:i_end-1), name="Del_s" )
      end if
d2227 3
a2229 1
      if ( .not. fwdModelConf%polarized ) then
d2231 1
a2231 1
      ! Compute SCALAR radiative transfer --------------------------
d2233 3
a2235 4
        call get_tau ( frq_i, gl_inds, cg_inds, i_start, e_rflty,  &
          & del_zeta, alpha_path_c, ref_corr, incoptdepth(:i_end), &
          & tan_pt_c, alpha_path_f(1:ngl), dsdz_gw_path, tau )
        i_stop = tau%i_stop(frq_i)
d2237 1
a2237 12
        if ( .not. pfa .or. .not. fwdModelConf%anyLBL(sx) ) then
          ! Not doing PFA, or doing PFA but haven't done LBL.
          ! Get incremental radiance and radiance from Tau and T_Script.
          ! Don't clobber them if doing PFA and already did LBL.  If
          ! doing LBL, inc_rad_path will be frequency averaged to give
          ! Rad_Avg_Path.
          radV = 0.0
          do j = i_start, i_stop
            inc_rad_path(j) = t_script(j) * tau%tau(j,frq_i)
            radV = radV + inc_rad_path(j)
          end do ! j
        end if
d2239 1
a2239 12
        if ( pfa .and. frq_avg_sel == 15 ) then ! See Frequency_Average.
          ! Doing PFA and did LBL and need derivatives and will frequency
          ! average.  Multiply Inc_Rad_Path by Tau to combine LBL and PFA. 
          ! Then sum to give RadV.  Inc_Rad_Path is channel-averaged LBL
          ! radiance. Remember, when doing PFA, Frq_I is a channel number.
          ! See wvs-026.
          radV = 0.0
          do j = i_start, i_stop
            inc_rad_path(j) = inc_rad_path(j) * tau%tau(j,frq_i)
            radV = radV + inc_rad_path(j)
          end do ! j
        end if
d2241 1
a2241 1
        inc_rad_path(i_stop+1:) = 0
d2243 1
a2243 6
        if ( print_incopt ) then
          call dump ( tau%tau(i_start:i_stop,frq_i), name="Tau" )
          call dump ( inc_rad_path(i_start:i_stop), name="Inc_Rad_Path" )
          call output ( frq_i, before="RadV(" )
          call output ( radV, before=") = ", advance="yes" )
        end if
d2245 1
a2245 3
        if ( print_path ) call dump_path ( fwdModelConf, i_start, i_end, &
          & phi_path(c_inds), z_path(c_inds), sps_path(c_inds,:), beta_path_c, &
          & alpha_path_c, incoptdepth, frq_i, tau, inc_rad_path )
d2247 6
a2252 1
      else ! Polarized model; can't combine with PFA or TScat
d2254 3
a2256 1
      ! Compute POLARIZED radiative transfer -----------------------------
d2258 1
a2258 1
        i_stop = npc ! needed by drad_tran_df
d2260 10
a2269 4
        ! Get the corrections to integrals for layers that need GL for
        ! the polarized species.
        call get_beta_path_polarized ( frq, h,beta_group%lbl(sx), gl_slabs, &
          & gl_inds, beta_path_polarized_f, dBeta_dT_polarized_path_f )
d2271 6
a2276 13
        ! We put an explicit extent of -1:1 for the first dimension in
        ! the hope a clever compiler will do better optimization with
        ! a constant extent.
        ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
        ! to alpha here.
        do j = 1, ngl
          alpha_path_polarized_f(-1:1,j) = &
            & matmul( beta_path_polarized_f(-1:1,j,:), &
            &         sps_path(gl_inds(j),:) ) * tanh1_f(j) &
            & + 0.25 * alpha_path_f(j)
          alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) +               &
            & 0.25 * alpha_path_f(j)
        end do
d2278 6
a2283 5
        call rad_tran_pol ( tan_pt_c, gl_inds, cg_inds, e_rflty, del_zeta,        &
          & alpha_path_polarized(:,1:npc), ref_corr, incoptdepth_pol(:,:,1:npc),  &
          & deltau_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl), dsdz_gw_path, &
          & ct, stcp, stsp, t_script, dump_rad_pol, prod_pol(:,:,1:npc),          &
          & tau_pol(:,:,1:npc), rad_pol, p_stop )
d2285 6
a2290 14
        if ( p_stop < 0 ) then ! exp(incoptdepth_pol(:,:,-p_stop)) failed
          call output ( 'Exp(incoptdepth_pol(:,:,' )
          call output ( -p_stop )
          call output ( ') failed.  Value is', advance='yes' )
          call dump ( incoptdepth_pol(:,:,-p_stop), options='c' ) ! clean=.TRUE.
          call output ( thisSideband, before='thisSideband = ' )
          call output ( ptg_i, before=', ptg_i = ' )
          call output ( frq_i, before=', frq_i = ', advance='true' )
          call dump ( t_path_c(:npc), name='T_Path' )
          call dump ( ref_corr(:npc), name='Ref_Corr' )
          call dump ( n_path_c(:npc), name='N_Path' )
          call dump ( h_path_c(:npc), name='H_Path' )
          call Announce_Error ( 'exp(incoptdepth_pol) failed' )
        end if
d2292 1
a2292 5
        if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
          radV = real(rad_pol(1,1))
        else
          radV = real(rad_pol(2,2))
        end if
d2294 24
a2317 1
      end if
d2319 26
a2344 1
      ! Compute derivatives if needed ----------------------------------
d2346 2
a2347 1
      if ( atmos_der ) then
d2349 13
a2361 29
        call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f, &
          &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,              &
          &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,        &
          &  inc_rad_path, dBeta_dIWC_path_c, dBeta_dIWC_path_f,       &
          &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1), &
          &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq )

        if ( .not. pfa_or_not_pol ) then ! polarized and not PFA

          ! VMR derivatives for polarized radiance.
          ! Compute DE / Df from D Incoptdepth_pol / Df and put
          ! into DE_DF.
          call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop),    &
            &  Grids_f, beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc), &
            &  eta_fzp(:npf,:), do_calc_fzp, sps_path, del_s,             &
            &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),         &
            &  d_delta_df(1:npc,:), de_df(:,:,1:p_stop,:) )

          ! Compute D radiance / Df from Tau, Prod, T_Script
          ! and DE / Df.
          call mcrt_der ( t_script, sqrt(e_rflty),             &
            & deltau_pol(:,:,1:npc), de_df(:,:,1:npc,:),       &
            & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &
            & tan_pt_c, d_rad_pol_df )

          if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
            k_atmos_frq(:) = real(d_rad_pol_df(1,1,:))
          else
            k_atmos_frq(:) = real(d_rad_pol_df(2,2,:))
d2364 2
a2365 1
        end if ! polarized and not PFA
d2367 27
a2393 1
      end if ! atmos_der
d2395 25
a2419 1
      if ( temp_der ) then
d2421 68
a2488 3
        ! put indices of nonzeros in nz_zxp_t that are in c_inds into nz_zxp_t_c
        call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds(:i_stop), i_start, &
          & nz_zxp_t_c, nnz_zxp_t_c )
d2490 2
a2491 3
        ! get d Delta B / d T * d T / eta
        call dt_script_dt ( t_path_c, B(:npc), eta_zxp_t_c(1:npc,:), &
                          & nz_zxp_t_c, nnz_zxp_t_c, frq, d_t_scr_dt(1:npc,:) )
d2493 5
a2497 8
        dh_dt_path_f(:ngl,:) = dh_dt_path(gl_inds,:)
        do_calc_t_f(:ngl,:) = do_calc_t(gl_inds,:)
        eta_zxp_t_f(:ngl,:) = eta_zxp_t(gl_inds,:)
        h_path_f(:ngl) = h_path(gl_inds)
        dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds,:) *  &
                                      dBeta_dT_path_c(1:npc,:),dim=2 )
        dAlpha_dT_path_f(:ngl) = sum( sps_path(gl_inds,:) * &
                                      dBeta_dT_path_f(1:ngl,:),dim=2 )
d2499 1
a2499 1
        if ( pfa_or_not_pol ) then
d2501 1
a2501 13
          call drad_tran_dt ( del_zeta, h_path_c,                          &
            & dh_dt_path_c(1:npc,:), alpha_path_c,                         &
            & dAlpha_dT_path_c(:npc), eta_zxp_t_c(1:npc,:),                &
            & do_calc_t_c(1:npc,:), do_calc_hyd_c(1:npc,:), del_s,         &
            & ref_corr, tan_ht, dh_dt_path(tan_pt_f,:),                    &
            & do_gl, gl_inds, h_path_f(:ngl), t_path_f(:ngl),              &
            & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),                   &
            & dAlpha_dT_path_f(:ngl), eta_zxp_t_f(:ngl,:),                 &
            & do_calc_t_f(:ngl,:), dsdh_path, dhdz_gw_path, dsdz_gw_path,  &
            & d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i),                    &
            & inc_rad_path, i_start, tan_pt_c, i_stop,                     &
            & grids_tmp%deriv_flags, pfa .and. frq_avg_sel == 15,          &
            & k_temp_frq )
d2503 2
a2504 1
        else ! pol and not pfa
d2506 2
a2507 3
          ! Temperature derivatives for polarized radiance
          ! Compute DE / DT from D Incoptdepth_Pol / DT and put
          ! into DE_DT.
d2509 2
a2510 20
          dAlpha_dT_polarized_path_c(:,1:npc) = 0.0
          dAlpha_dT_polarized_path_f(:,1:ngl) = 0.0
          do j = 1, no_mol
            do l = -1, 1
              dAlpha_dT_polarized_path_c(l,1:npc) = &
            & dAlpha_dT_polarized_path_c(l,1:npc) + &
                & sps_path(c_inds,j) * dBeta_dT_polarized_path_c(l,1:npc,j)
              dAlpha_dT_polarized_path_f(l,1:ngl) = &
            & dAlpha_dT_polarized_path_f(l,1:ngl) + &
                & sps_path(gl_inds,j) * dBeta_dT_polarized_path_f(l,1:ngl,j)
            end do ! l
          end do ! j
          do l = -1, 1
            dAlpha_dT_polarized_path_c(l,1:npc) =               &
              & dAlpha_dT_polarized_path_c(l,1:npc) * tanh1_c + &
              & alpha_path_polarized(l,:npc) * dTanh_dT_c(:npc)
            dAlpha_dT_polarized_path_f(l,1:ngl) =                     &
              & dAlpha_dT_polarized_path_f(l,1:ngl) * tanh1_f(:ngl) + &
              & alpha_path_polarized_f(l,:ngl) * dTanh_dT_f(:ngl)
          end do
d2512 8
a2519 14
          call get_d_deltau_pol_dT ( ct, stcp, stsp, tan_pt_c,            &
            & t_path_f(:ngl), alpha_path_polarized(:,1:p_stop),           &
            & alpha_path_polarized_f(:,1:ngl),                            &
            & dAlpha_dT_path_c(:npc), dAlpha_dT_path_f(:ngl),             &
            & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f,     &
            & eta_zxp_t_c(1:p_stop,:), eta_zxp_t_f(:ngl,:), del_s,        &
            & gl_inds, del_zeta, do_calc_t_c(1:p_stop,:),                 &
            & do_calc_t_f(:ngl,:), do_gl(1:p_stop), dsdh_path,            &
            & dhdz_gw_path, dsdz_gw_path, incoptdepth_pol(:,:,1:p_stop),  &
            & ref_corr(1:p_stop), h_path_c, h_path_f(:ngl),               &
            & dh_dt_path_c(1:p_stop,:),dh_dt_path_f(:ngl,:),              &
            & tan_ht, dh_dt_path(tan_pt_f,:),                             &
            & do_calc_hyd_c(1:p_stop,:), grids_tmp%deriv_flags,           &
            & de_dt(:,:,1:p_stop,:) )
d2521 7
a2527 2
          ! Compute D radiance / DT from Tau, Prod, T_Script, D_T_Scr_dT
          ! and DE / DT.
d2529 1
a2529 4
          call mcrt_der ( t_script, sqrt(e_rflty),             &
            & deltau_pol(:,:,1:npc), de_dt(:,:,1:npc,:),       &      
            & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &      
            & tan_pt_c, d_rad_pol_dt, d_t_scr_dt(1:npc,:) )
d2531 3
a2533 5
          if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
            k_temp_frq(:) = real(d_rad_pol_dt(1,1,:))
          else
            k_temp_frq(:) = real(d_rad_pol_dt(2,2,:))
          end if
d2535 2
a2536 1
        end if
d2538 2
a2539 1
      end if
d2541 8
a2548 1
      if ( spect_der ) then
d2550 5
a2554 7
        if ( fwdModelConf%polarized ) then
          call Announce_Error ( &
            & "Spectroscopic derivatives for Polarized species not implemented yet." )
        else if ( pfa ) then
          call Announce_Error ( &
            & "Spectroscopic derivatives for PFA not implemented yet." )
        else
d2556 1
a2556 1
          ! Spectroscopic derivative  wrt: W
d2558 6
a2563 6
          if ( spect_der_width ) &
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_w,      &
              &  eta_zxp_w, sps_path, fwdModelConf%lineWidth%beta(sx),     &
              &  do_calc_w, dbeta_dw_path_c, dbeta_dw_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dw_frq )
d2565 5
a2569 1
          ! Spectroscopic derivative  wrt: N
d2571 3
a2573 6
          if ( spect_der_width_TDep ) &
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_n,      &
              &  eta_zxp_n, sps_path, fwdModelConf%lineWidth_tDep%beta(sx),&
              &  do_calc_n, dbeta_dn_path_c, dbeta_dn_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dn_frq )
d2575 1
a2575 1
          ! Spectroscopic derivative  wrt: Nu0
d2577 8
a2584 6
          if ( spect_der_center ) &
            & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_v,      &
              &  eta_zxp_v, sps_path, fwdModelConf%lineCenter%beta(sx),    &
              &  do_calc_v, dbeta_dv_path_c, dbeta_dv_path_f, do_gl, del_s,&
              &  ref_corr, dhdz_gw_path, inc_rad_path, tan_pt_c,           &
              &  i_stop, k_spect_dv_frq )
d2586 23
a2608 1
        end if
d2610 37
a2646 1
      end if
d2648 6
a2653 4
      ! End of frequency loop ----------------------------------------------

      if ( toggle(emit) .and. levels(emit) > 5 ) &
        & call Trace_End ( 'ForwardModel.Frequency ', index=frq_i )
d2656 1
a2656 1
        & call Trace_End ( 'ForwardModel.FrequencyLoop' )
d2658 1
a2658 1
    end subroutine Frequency_Loop
d2660 1
a2660 2
  ! ..........................................  Frequency_Setup_1  .....
    subroutine Frequency_Setup_1 ( Tan_Press, Grids )
d2662 1
a2662 1
      ! Work out which pointing frequency grid we're going to need
d2664 12
a2675 2
      ! Code splits into two sections, one for when we're doing frequency
      ! averaging, and one when we're not.
d2677 17
a2693 2
      real(rp), intent(in) :: Tan_Press(:)
      integer, intent(out) :: Grids(:)
d2695 4
a2698 5
      integer :: I, K, PTG_I, ShapeInd
      integer :: MAXNOPTGFREQS     ! Used for sizing arrays
      integer :: MINSUPERSET       ! Min. value of superset > 0
      real(rp) :: R1, R2           ! real variables for various uses
      integer :: SUPERSET          ! Output from AreSignalsSuperset
d2700 5
a2704 1
      nullify ( whichPointingGrid )
d2706 7
a2712 1
      if ( fwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) then
d2714 1
a2714 11
        minSuperset = huge(0)
        do i = 1, size(pointingGrids)
          superset = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals, sideband=thisSideband )
          if ( superset >= 0 .and. superset <= minSuperset ) then
            minSuperset = superset
            whichPointingGrid => pointingGrids(i)
          end if
        end do
        if ( .not. associated(whichPointingGrid) ) call Announce_Error ( &
               & "No matching pointing frequency grids." )
d2716 1
a2716 10
        ! Now we've identified the pointing grids.  Locate the tangent grid
        ! within it.
        call Hunt ( whichPointingGrid%oneGrid%height, &
                 &  tan_press, grids, allowTopValue=.TRUE., nearest=.TRUE. )
        ! Work out the maximum number of frequencies
        maxNoPtgFreqs = 0
        do ptg_i = 1, no_tan_hts
          maxNoPtgFreqs = max ( maxNoPtgFreqs, &
            & Size(whichPointingGrid%oneGrid(grids(ptg_i))%frequencies) )
        end do
d2718 2
a2719 16
        min_ch_freq_grid =  huge(min_ch_freq_grid)
        max_ch_freq_grid = -huge(min_ch_freq_grid)
        do i = 1, noUsedChannels
          shapeInd = channels(i)%shapeInds(sx)
          if ( channels(i)%dacs == 0 ) then
            k = Size(FilterShapes(shapeInd)%FilterGrid)
            r1 = FilterShapes(shapeInd)%FilterGrid(1)
            r2 = FilterShapes(shapeInd)%FilterGrid(k)
          else
            k = Size(dacsFilterShapes(shapeInd)%filter%FilterGrid)
            r1 = dacsFilterShapes(shapeInd)%filter%FilterGrid(1)
            r2 = dacsFilterShapes(shapeInd)%filter%FilterGrid(k)
          end if
          min_ch_freq_grid = MIN(r1, r2, min_ch_freq_grid)
          max_ch_freq_grid = MAX(r1, r2, max_ch_freq_grid)
        end do
d2721 3
a2723 1
        if ( FwdModelConf%anyPFA(sx) ) call get_channel_centers ( channelCenters )
d2725 4
a2728 1
      else ! ----------------------------- Not frequency averaging -----
d2730 3
a2732 4
        noFreqs = noUsedChannels
        maxNoPtgFreqs = noUsedChannels
        call get_channel_centers ( channelCenters )
        frequencies => channelCenters
d2734 3
a2736 1
      end if ! ----------------- Either frequency averaging or not -----
d2738 1
a2738 1
      call allocate_test ( RadV, maxNoPtgFreqs, 'RadV', moduleName )
d2740 2
a2741 7
      if ( FwdModelConf%anyLBL(sx) ) then
        call allocate_test ( T_Script_LBL, max_c, maxNoPtgFreqs, 'T_Script_LBL', moduleName )
        call allocate_test ( tau_LBL%tau,  max_c, maxNoPtgFreqs, 'Tau_LBL%Tau', &
          & moduleName )
        call allocate_test ( tau_LBL%i_stop, maxNoPtgFreqs, 'Tau_LBL%I_Stop', &
          & moduleName )
      end if
d2743 2
a2744 4
      call allocate_test ( dAlpha_dT_path_c, max_c, maxNoPtgFreqs, & 
        & 'dAlpha_dT_path_c', moduleName )
      call allocate_test ( beta_path_c, max_c, no_mol, maxNoPtgFreqs, &
        & 'Beta_Path_c', moduleName )
d2746 2
a2747 2
      call allocate_test ( inc_rad_path, max_c, maxNoPtgFreqs, 'Inc_Rad_path', &
        & moduleName )
d2749 3
a2751 2
      if ( FwdModelConf%useTScat ) call allocate_test ( w0_frq_path, &
        max_f, maxNoPtgFreqs, 2, 'W0_Frq_path', moduleName )
d2753 4
a2756 3
      if ( temp_der ) &
        & call allocate_test ( k_temp_frq, max(maxNoPtgFreqs,noUsedChannels), &
                             & sv_t_len, 'k_temp_frq', moduleName )
d2758 3
a2760 13
      if ( atmos_der ) &
        & call allocate_test ( k_atmos_frq, max(maxNoPtgFreqs,noUsedChannels), &
                             & size(grids_f%values), 'k_atmos_frq', moduleName )

      if ( spect_der_width ) &
        & call allocate_test ( k_spect_dw_frq, max(maxNoPtgFreqs,noUsedChannels), &
                             & size(grids_w%values), 'k_spect_dw_frq', moduleName )
      if ( spect_der_width_TDep ) &
        & call allocate_test ( k_spect_dn_frq, max(maxNoPtgFreqs,noUsedChannels), &
                             & size(grids_n%values), 'k_spect_dn_frq', moduleName )
      if ( spect_der_center ) &
        & call allocate_test ( k_spect_dv_frq, max(maxNoPtgFreqs,noUsedChannels), &
                             & size(grids_v%values), 'k_spect_dv_frq', moduleName )
d2762 3
a2764 1
    end subroutine Frequency_Setup_1
d2766 4
a2769 2
  ! ..........................................  Frequency_Setup_2  .....
    subroutine Frequency_Setup_2 ( GridFrequencies )
d2771 3
a2773 2
      ! Work out what frequencies we're using for
      ! frequency averaging case for this pointing
d2775 4
a2778 2
      real(r8), intent(in) :: GridFrequencies(:) ! from PointingGrids
      ! Include the VELOCITY shift correction in GridFrequencies!
d2780 1
a2780 1
      integer :: J, K, L, M
d2782 4
a2785 6
      j = -1
      k = SIZE(GridFrequencies)
      call Hunt ( min_ch_freq_grid, GridFrequencies, k, j, l )
      call Hunt ( max_ch_freq_grid, GridFrequencies, k, l, m )
      noFreqs = m - j + 1
      call allocate_test ( frequencies, noFreqs, "frequencies", moduleName )
d2787 1
a2787 1
      frequencies = GridFrequencies(j:m)
d2789 6
a2794 1
    end subroutine Frequency_Setup_2
d2796 3
a2798 2
  ! .............................................  Generate_TScat  .....
    subroutine Generate_TScat
d2800 1
a2800 2
      ! Generate tables of TScat and its derivatives w.r.t. temperature
      ! and IWC.  The geometric calculations are described in wvs_074.
d2802 6
a2807 12
      use Constants, only: Pi
      use Convolve_All_m, only: Store_Other_Deriv, Store_Temperature_Deriv
      use ForwardModelConfig, only: QtyStuff_T
      use Get_Eta_Matrix_m, only: Get_Eta_Sparse
      use MatrixModule_1, only: FindBlock
      use MLSNumerics, only: Coefficients_r8, InterpolateArraySetup, &
        & InterpolateArrayTeardown
      use MLSSignals_m, only: GetNameOfSignal
      use Output_m, only: NewLine
      use Read_Mie_m, only: dP_dIWC, dP_dT, F_s, IWC_s, P, T_s, Theta_s
      use Sort_m, only: Sortp
      use VectorsModule, only: Dump
d2809 6
a2814 33
      real(rp) :: DPhi         ! Scat_Phi - Phi_Ref
      real(rp) :: DPhi_Xi      ! dPhi - xi = psi in wvs-074
      real(rp) :: Eta_s(size(Grids_tmp%phi_basis)) ! Coeffs to Scat_Tan_Phi
      real(rp) :: Phi_Old      ! Used during iteration for Scat_Tan_Phi
      real(rp) :: Phi_Ref      ! Tangent phi for the scattered ray
      real(rp) :: Rads(noUsedChannels,4*nlvl+2*scatteringAngles%template%noSurfs)
      real(r4) :: K_Atmos_TScat(noUsedChannels,size(rads,2),s_a*size(grids_f%values))
      real(rp) :: K_Atmos_p(s_a*size(grids_f%values)) ! K_Atmos convolved with P
      real(r4) :: K_Temp_TScat(noUsedChannels,size(rads,2),s_t*sv_t_len)
      real(rp) :: K_Temp_p(s_t*size(grids_tmp%values)) ! K_Temp convolved with P
      real(rp) :: LogIWC       ! log10(iwc)
      real(rp) :: P_On_Xi(size(rads,2)) ! P * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: dP_dIWC_On_Xi(size(rads,2)) ! dP/dIWC * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: dP_dT_On_Xi(size(rads,2)) ! dP/dT * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each xi
      real(rp) :: Ref_Ht       ! Height of the ray at the reference phi
      real(rp) :: R_Eq         ! Equivalent circular earth radius at Phi_Ref
      real(rp) :: Scat_Ht      ! km from center of equivalent circular earth
      real(rp) :: Scat_Phi     ! Of the scattering point
      real(rp) :: Scat_Tan_Ht  ! Of the ray to be scattered, Km from center
      real(rp) :: Scat_Tan_Phi ! Of the ray to be scattered
      real(rp) :: Scat_Zeta    ! Of the scattering point
      real(rp) :: Theta        ! Angle from direct to reflected
                               ! earth-intersecting ray
      real(rp) :: Theta_e(2*size(theta_s)+1) ! Extended to -theta_s
      real(rp) :: Vel_Rel      ! LOS velocity / speed of light, along scattered
                               ! ray
      real(rp) :: Xi           ! Scattering angle
      real(rp) :: Xi_Sub       ! Angle from horizon to scattering point's
                               ! subsurface point
      real(rp) :: Xis(size(rads,2))
d2816 18
a2833 4
      ! Interpolating factors
      real(rp) :: Eta_IWC(0:1) ! for current IWC
      real(rp) :: Eta_T(0:1)   ! for current temperature
      real(rp) :: Eta_T_IWC(0:1,0:1) ! for both
d2835 1
a2835 3
      integer :: Beg_Pos_Theta ! 1 if theta_s(1) /= 0, else 2
      integer :: IWC_IX        ! Which IWC index for phase function to use
      integer :: T_IX          ! Which Temperature index for phase functio to use
d2837 7
a2843 21
      integer :: F_I           ! Frequency (channel) index
      integer :: First_s, Last_s ! How much of Eta_s to use
      logical :: Forward       ! Half-ray is an earth-intersecting ray
                               ! in the forward direction, xi >= xi_sub
      integer :: Freq_Ix(noUsedChannels) ! Frequency indices for phase tables
      integer :: I             ! Loop inductor
      integer :: I_R           ! Index in Rad, Xis, eventually number of them
      integer :: I_Z           ! Index of scattering point zeta in Z_psig
      integer :: N_Theta_e     ! size(theta_e) or size(theta_e)-1, depending
                               ! upon whether theta_e covers 0..360 or lacks one
      integer :: Phi_i         ! Loop inductor and subscript
      integer :: Ptg_i, Ptg_j  ! Loop inductors and subscripts
      integer :: Ptg_f         ! Ptg_i, Ptg_j on fine grid
      integer :: Row           ! Row number of Jacobian block
      integer :: Scat_Index(size(Xis)) ! of scattering point in coarse grid
      integer :: Sort_Xi(size(Xis)) ! Permutation vector to sort Xis
      integer :: Surf_i        ! Surface (first) subscript for TScat%values,
                               ! which combines frequency and zeta index
      logical :: Switch42      ! "42" appears in Switches
      integer :: Zeta_i        ! Loop inductor and subscript
      integer :: Zeta_f        ! I_z on find grid
d2845 1
a2845 1
      character(128) :: Sig    ! Signal name, scratch for debug output
d2847 2
a2848 3
      type (Coefficients_r8) :: Coeffs_Theta_e_Xi ! To interpolate from Theta_e to Xi
      type (QtyStuff_T) :: TScats(noUsedChannels)
      type (VectorValue_T), pointer :: TScat
d2850 2
a2851 5
      real(rp), parameter :: PIX2 = 2.0_rp * pi
      real(rp), parameter :: PID2 = 0.5 * pi

      if ( toggle(emit) ) call Trace_Begin ( 'Generate_TScat' )
      switch42 = index(switches,"42") /= 0
d2853 2
a2854 1
      ! Work out by-channel stuff
d2856 2
a2857 3
      ! Get channel centers if we don't already have them
      if ( fwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) .and. .not. &
        &  fwdModelConf%anyPFA(sx) ) call get_channel_centers ( channelCenters )
d2859 5
a2863 25
      if ( print_TScat .or. print_TScat_detail > 0 ) &
        & call output ( "Signals used for TScat computation:", advance="yes" )
      do f_i = 1, noUsedChannels
        ! Vector quantities for results, one for each channel
        TScats(f_i)%qty => GetQuantityForForwardModel ( &
          & fwdModelOut, quantityType=l_TScat, &
          & signal=fwdModelConf%signals(channels(f_i)%signal)%index, &
          & sideband=sideband )
        TScats(f_i)%qty%values = 0.0 ! Is this needed?
        if ( print_TScat .or. print_TScat_detail > 0 ) then
          call GetNameOfSignal ( fwdModelConf%signals(channels(f_i)%signal), sig, &
            & channel=channels(f_i)%used, sideband=thisSideband )
          call output ( trim(sig), advance="yes" )
        end if
        ! Choose which frequency panel of phase function to use
        ! (don't interpolate).  Make sure it's close enough.
        freq_ix(f_i) = minloc(abs(channelCenters(f_i)-f_s),1)
        if ( abs(channelCenters(f_i)-f_s(freq_ix(f_i))) > fwdModelConf%frqTol ) then
          call output ( freq_ix(f_i), before="freq_ix(f_i) = ", after=", " )
          call dump ( f_s, name="F_s" )
          call dump ( channelCenters, name="ChannelCenters" )
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'In TScat computation, phase function frequency coordinate too far from channel center' )
        end if
      end do
d2865 8
a2872 3
      ! Get TScat quantity for first signal, to access its grids (they all have
      ! the same grids)
      TScat => TScats(1)%qty
d2874 3
a2876 1
      vel_rel = LOSVel%values(FwdModelConf%TScatMIF,MAF) / speedOfLight
d2878 6
a2883 2
      phi_ref = phitan%values(FwdModelConf%TScatMIF,MAF) * deg2rad
      r_eq = get_R_eq ( phi_ref, earthradc_sq )
d2885 5
a2889 7
      if ( print_TScat_detail > 0 ) then
        call output ( rad2deg*phi_ref, before="Phi_Ref = ", advance="yes" )
        ! Debugging output header
        call output ( &
          & "Scat_Phi   Scat_Ht   Scat_Zeta     Xi       D2     Tan_Phi    Tan_Ht  Begin Phi   End Phi", &
          & advance="yes" )
      end if
d2891 3
a2893 3
      ! Loop over observer zetas
      do zeta_i = 1, TScat%template%noSurfs
        scat_zeta = TScat%template%surfs(zeta_i,1)
d2895 3
a2897 11
        ! Find index of Z_psig element closest to scat_zeta.
        ! Assuming observer zetas got put into Z_psig as they should have been,
        ! this should hit one element exactly.
        i_z = minloc(abs(z_psig-scat_zeta),1)
        if ( abs(z_psig(i_z)-scat_zeta) > 10.0 * epsilon(scat_zeta) * abs(scat_zeta) ) then
          call output ( scat_zeta, before="Scattering point Zeta ", advance="yes" )
          call dump ( z_psig, name="Zeta grid" )
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'Scattering point Zeta does not appear to be in Zeta grid' )
        end if
        zeta_f = (i_z-1) * ngp1 + 1 ! On Z_GLgrid, for H_GLGrid
d2899 1
a2899 2
        ! Loop over observer phis
        do phi_i = 1, TScat%template%noInstances
d2901 14
a2914 7
          if ( iwc%values(zeta_i,phi_i) <= 0.0 ) then ! no IWC, no scattering
            call output ( TScat%template%phi(1,phi_i), &
              & before='Scattering point at (' )
            call output ( z_glgrid(zeta_f), before=',', &
              & after=') rejected because there is no IWC there.', advance='yes' )
            cycle
          end if
d2916 10
a2925 1
          logIWC = log10(iwc%values(zeta_i,phi_i))
d2927 5
a2931 7
          scat_phi = TScat%template%phi(1,phi_i) * deg2rad
          dPhi = scat_phi - phi_ref
          ! Interpolate in H_GLGrid at (phi_i,zeta_f) to get Scat_Ht
          call get_eta_sparse ( Grids_tmp%phi_basis, scat_phi, &
                              & eta_s, first_s, last_s )
          scat_ht = dot_product(h_glgrid(zeta_f,first_s:last_s), &
                 &             eta_s(first_s:last_s)) + r_eq
d2933 1
a2933 11
          ! Subsurface scattering points handled by explicit angles
          if ( scat_ht < r_eq ) then
            call output ( TScat%template%phi(1,phi_i), &
              & before='Scattering point at (' )
            call output ( z_glgrid(zeta_f), before=',' )
            call output ( scat_ht, format='(f8.3)', &
              & before=') rejected because its height (' )
            call output ( r_eq, format='(f8.3)', &
              & before=') is below the Earth surface (', after=').', advance='yes' )
            cycle
          end if
d2935 4
a2938 2
          ! Height of the ray at the phi_ref
          ref_ht = scat_ht * cos(dPhi)
d2940 1
a2940 3
          ! First do pointings to each zeta surface below the scattering
          ! point zeta.  Pointings to specified angles aren't guaranteed to
          ! be tangent at a pressure in the zeta grid.
d2942 5
a2946 2
          i_r = 0
          do ptg_i = 1, i_z
d2948 4
a2951 2
            ! Handle earth-intersecting rays using explicit angles
            if ( ptg_i < surfaceTangentIndex ) cycle
d2953 5
a2957 1
            ptg_f = (ptg_i-1) * ngp1 + 1 ! On Z_GLgrid, for H_GLGrid
d2959 1
a2959 2
            ! Compute scat_tan_ht and scat_tan_phi for the ray to be scattered.
            ! Start with scat_tan_phi == phi_ref and iterate.
d2961 5
a2965 3
            scat_tan_phi = phi_ref
            do i = 1, 20
              phi_old = scat_tan_phi
d2967 7
a2973 2
              call get_eta_sparse ( Grids_tmp%phi_basis, scat_tan_phi, &
                                  & eta_s, first_s, last_s )
d2975 1
a2975 2
              scat_tan_ht = dot_product(h_glgrid(ptg_f,first_s:last_s), &
                          &             eta_s(first_s:last_s)) + r_eq
d2977 1
a2977 9
              ! Compute scattering angle and tan phi for the ray to be
              ! scattered.  This is measured anti clockwise from the ray from
              ! the scattering point to the external observer, so the
              ! "downward" ray is at a negative angle.
              dPhi_xi = acos(min(scat_tan_ht,scat_ht)/scat_ht)
              xi = dPhi - dPhi_xi
              scat_tan_phi = phi_ref + xi
              if ( abs(scat_tan_phi-phi_old) < 0.0001 ) exit
            end do
d2979 4
a2982 2
            ! Handle earth-intersecting rays using explicit angles
            if ( scat_tan_ht < r_eq ) cycle
d2984 12
a2995 1
            ! Rays from the scattering point can't be tangent to higher altitudes
d2997 12
a3008 1
            if ( scat_tan_ht > scat_ht ) cycle
d3010 1
a3010 2
            ! If we're doing frequency averaging, get the frequencies we need
            ! for this pointing.
d3012 6
a3017 11
            if ( associated(whichPointingGrid) ) &
              & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
              & whichPointingGrid%oneGrid(grids(ptg_i))%frequencies )

            ! Do the ray tracing and radiative transfer, four times: once each
            ! for forward and reverse scattering, and once each for upwelling
            ! and downwelling rays
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.true. )
d3019 3
a3021 5
            xi = xi + pi
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.false. )
d3023 1
a3023 6
            xi = dPhi_xi + dPhi - pi
            scat_tan_phi = scat_tan_phi + 2.0 * dphi_xi
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.false. )
d3025 1
a3025 5
            xi = xi + pi
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi,       & 
              &                       scat_zeta, scat_phi, scat_ht,       & 
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index, rev=.true. )
d3027 1
a3027 1
          end do ! ptg_i
d3029 4
a3032 3
          ! Now do pointings to specified angles, but only those that result
          ! in earth-intersecting rays.  Use the surface-pressure frequency
          ! pointing grid for all pointings.
d3034 13
a3046 1
          ! If we're doing frequency averaging, get the frequencies we need.
d3048 5
a3052 3
          if ( associated(whichPointingGrid) ) &
            & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
            & whichPointingGrid%oneGrid(grids(1))%frequencies )
d3054 14
a3067 1
          do ptg_j = 1, scatteringAngles%template%noSurfs
d3069 5
a3073 1
            xi = scatteringAngles%template%surfs(ptg_j,1) * deg2rad
d3075 1
a3075 1
            ! Reject angles not pointing downward
d3077 1
a3077 1
            if ( xi > 0.0 .or. xi < -pi ) cycle
d3079 1
a3079 1
            ! Compute scat_tan_ht and scat_tan_phi for the ray to be scattered.
d3081 6
a3086 6
            ! Rays that aren't earth-intersecting rays must be handled by
            ! specified tangent zeta (else there is no unique tangent
            ! point), not by specified angle.  They could be handled by
            ! solving for tangent zeta using inverse interpolation in the
            ! h_ref array, and then adding that zeta to the grid, but it's
            ! much easier just to reject them.
d3088 1
a3088 3
            scat_tan_ht = scat_ht * abs(cos(dPhi - xi)) ! xi < 0 here
            if ( scat_tan_ht > r_eq ) cycle
            theta = 2.0 * acos(scat_tan_ht/r_eq)
d3090 8
a3097 1
            scat_tan_ht = scat_tan_ht - r_eq
d3099 6
a3104 10
            xi_sub = dPhi - pid2
            forward = xi >= xi_sub
            scat_tan_phi = phi_ref + xi
            if ( xi < xi_sub ) scat_tan_phi = scat_tan_phi - pi
            scat_tan_phi = mod(scat_tan_phi,pix2)
            if ( scat_tan_phi < -pi ) then
              scat_tan_phi = scat_tan_phi + pix2
            else if ( scat_tan_phi > pi ) then
              scat_tan_phi = scat_tan_phi - pix2
            end if
d3106 5
a3110 6
            if ( print_TScat_detail > 1 ) then
              write ( sig, "('scat_tan_ht = ', f10.4,', scat_tan_phi = ', f7.2, &
              & ', xi_sub =', f7.2, ', theta = ', f7.2)" ) &
              & scat_tan_ht, rad2deg*scat_tan_phi, rad2deg*xi_sub, rad2deg*theta
              call output ( trim(sig), advance='yes' )
            end if
d3112 1
a3112 6
            ! Do the ray tracing and radiative transfer
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,           &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index,      &
              &                       scat_tan_ht, forward )
d3114 1
a3114 6
            xi = xi + pi
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,           &
              &                       scat_zeta, scat_phi, scat_ht,       &
              &                       r_eq, xi, xis, rads, k_atmos_TScat, &
              &                       k_temp_TScat, i_r, scat_index,      &
              &                       scat_tan_ht, forward )
d3116 1
a3116 1
          end do ! ptg_j
d3118 3
a3120 24
          if ( print_TScat ) then
            call output ("Phi_Ref  Scat_Phi   Scat_Ht  Scat_Zeta     Xi    Radiances", advance="yes" )
            ! ptg_i and sig are just conveniently otherwise unused variables here
            do ptg_i = 1, i_r
              write ( sig, "(f7.2,f9.2,f12.4,f8.3,f11.2)" ) rad2deg*phi_ref, &
                & rad2deg*scat_phi, scat_ht, scat_zeta, rad2deg*xis(ptg_i)
              call output ( trim(sig) )
              do f_i = 1, noUsedChannels
                call output ( rads(f_i,ptg_i), format="(f9.3)" )
              end do ! f_i
              call newLine
            end do ! ptg_i
          end if
          if ( switch42 ) then
            do ptg_i = 1, i_r
              do f_i = 1, noUsedChannels
                call GetNameOfSignal ( fwdModelConf%signals(channels(f_i)%signal), &
                  & sig, channel=channels(f_i)%used, sideband=thisSideband )
                write ( 42, "(f7.2,f9.2,f12.4,f8.3,f11.2,f9.3,2x,a)" ) &
                  & rad2deg*phi_ref, rad2deg*scat_phi, scat_ht, scat_zeta, &
                  & rad2deg*xis(ptg_i), rads(f_i,ptg_i), trim(sig)
              end do
            end do
          end if
d3122 3
a3124 26
          ! Get interpolating factors for scattering-point IWC to phase function
          ! IWC_s.
          ! IWC_s(iwc_ix) <= logIWC < IWC_s(iwc_ix+1_).
          call hunt ( IWC_s, logIWC, iwc_ix )
          if ( logIWC < IWC_s(1) ) then
            eta_iwc = (/ 1.0, 0.0 /) ! constant extrapolation below range
          else if ( logIWC > IWC_s(size(IWC_s)) ) then
            eta_iwc = (/ 0.0, 1.0 /) ! constant extrapolation above range
          else
            eta_iwc(1) = (logIWC - iwc_s(iwc_ix)) / &
                       & ( iwc_s(iwc_ix+1) - iwc_s(iwc_ix) )
            eta_iwc(0) = 1.0 - eta_iwc(1)
          end if
          ! Get interpolating factors for scattering-point temperature to phase
          ! function temperatures.
          ! T_s(T_ix) <= temp%values(zeta_i,phi_i) < T_s(T_ix+1).
          call hunt ( T_s, temp%values(zeta_i,phi_i), t_ix )
          if ( temp%values(zeta_i,phi_i) < t_s(1) ) then
            eta_t = (/ 1.0, 0.0 /) ! constant extrapolation below range
          else if ( temp%values(zeta_i,phi_i) > t_s(size(t_s)) ) then
            eta_t = (/ 0.0, 1.0 /) ! constant extrapolation above range
          else
            eta_t(1) = (temp%values(zeta_i,phi_i) - t_s(t_ix)) / &
                     & ( t_s(t_ix+1) - t_s(t_ix) )
            eta_t(0) = 1.0 - eta_t(1)
          end if
d3126 7
a3132 2
          forall ( ptg_i=0:1, ptg_j = 0:1 ) &
            & eta_t_iwc(ptg_i,ptg_j) = eta_t(ptg_i) * eta_iwc(ptg_j)
d3134 1
a3134 14
          ! Create an array of theta's extended to negative values, onto which
          ! to interpolate the xi's.  The phase function is sign-symmetric on
          ! theta_s, but the radiances are not sign-symmetric on xi's.
          theta_e(1:size(theta_s)) = -theta_s(size(theta_s):1:-1)
          beg_pos_theta = merge(2,1,theta_s(1)==0.0)
          theta_e(size(theta_s)+1:2*size(theta_s)+1-beg_pos_theta) = &
            & theta_s(beg_pos_theta:)
          ! Set up theta_e to cover 2 pi, to prepare it for periodic spline
          ! interpolation input abscissa set.
          n_theta_e = 2*size(theta_s) + 1 - beg_pos_theta
          if ( abs(theta_e(n_theta_e)-theta_e(1)-pix2) > 0.001 ) then
            n_theta_e = n_theta_e + 1
            theta_s(n_theta_e) = theta_s(n_theta_e) + pix2
          end if
d3136 13
a3148 30
          ! Sort the xis in preparation for interpolating.
          call sortp ( xis(:i_r), 1, i_r, sort_xi(:i_r) )

          !{ Interpolate the phase function to IWC and Temperature at the
          !  scattering point and convolve the interpolated phase function
          !  with the interpolated radiances.  Let $x$ be temperature, $y$
          !  be IWC, and $z$ be the phase function.
          !
          ! Let $\xi_1 = \frac{x-x_0}{x_1-x_0}$, $\xi_0 = \frac{x_1-x}{x_1-x_0} =
          ! 1-\xi_1$,
          ! $\eta_1 = \frac{y-y_0}{y_1-y_0}$, $\eta_0 = \frac{y_1-y}{y_1-y_0} =
          ! 1-\eta_1$,
          ! $\xi = [\xi_0,\xi_1]^T$, $\eta = [\eta_0,\eta_1]^T$, and
          ! $Z = \left| \begin{array}{cc} z_{00} & z_{01} \\ z_{10} & z_{11}\\
          !             \end{array} \right|$.
          !
          ! The interpolation can be done either by interpolating in $x$ to
          ! $z_c = \xi_0 z_{00} + \xi_1 z_{10}$ and $z_d = \xi_0 z_{01} +
          ! \xi_1 z_{11}$ and then in $y$ to $z = \eta_0 z_c + \eta_1 z_d$,
          ! or interpolating in $y$ to $z_a = \eta_0 z_{00} + \eta_1 z_{01}$
          ! and $z_b = \eta_0 z_{10} + \eta_1 z_{11}$ and then in $x$ to $z =
          ! \xi_0 z_a + \xi_1 z_b$.  The two orders of interpolation are
          ! equivalent, and when expanded give
          !%
          ! $
          ! z(x,y) = \xi_0 \eta_0 z_{00} + \xi_1 \eta_0 z_{10} +
          ! \xi_0 \eta_1 z_{10} + \xi_1 \eta_1 z_{11},
          ! $
          !%
          ! which can be expressed in matrix-vector form as $\xi^T Z \eta$.
d3150 1
a3150 25
          call interpolateArraySetup ( theta_e(:n_theta_e), xis(sort_xi(:i_r)), &
            & method='S', coeffs=coeffs_Theta_e_Xi, extrapolate='P' )
          do f_i = 1, noUsedChannels
            TScat => TScats(f_i)%qty
            row = findBlock ( jacobian%row, TScat%index, phi_i )
            if ( row == 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & "Unable to find row of Jacobian to store TScat derivatives" )
            surf_i = channels(f_i)%used - channels(f_i)%origin + 1 + &
                   & TScat%template%noChans * (zeta_i-1)
            ! Interpolate P to scattering point IWC and temperature, and
            ! angles Xi at which radiative transfer was done.
            call interpolate_P_to_theta_e ( p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & P_on_Xi(:i_r) )
            if ( atmos_der ) &
              & call interpolate_P_to_theta_e ( dP_dIWC(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & dP_dIWC_on_Xi(:i_r) )
            if ( temp_der ) &
              & call interpolate_P_to_theta_e ( dP_dT(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,:,freq_ix(f_i)), &
              & Eta_t_iwc, Theta_e(:n_theta_e), Beg_Pos_Theta, &
              & Xis(sort_xi(:i_r)), coeffs_Theta_e_Xi, &
              & dP_dT_on_Xi(:i_r) )
d3152 3
a3154 68
            !{ Compute $\int_{-\pi}^\pi \, f(\xi) P(\xi)\, \text{d}\xi$ using
            ! trapezoidal quadrature, without assuming equal abscissa spacing,
            ! and including the factor of 0.5 in Equation 4.50 in the 4 June
            ! 2004 cloud forward model ATBD.  Start with the wrap-around panel.
            TScat%values(surf_i,phi_i) =  &
              & 0.25 * ( p_on_xi(i_r)*rads(f_i,sort_xi(i_r)) + &
              &          p_on_xi(  1)*rads(f_i,sort_xi(  1)) ) * &
              &        ( xis(sort_xi(1)) + pix2 - xis(sort_xi(i_r)) )
            if ( atmos_der ) then
              k_atmos_p =  &
                & 0.25 * ( p_on_xi(i_r)*k_atmos_TScat(f_i,sort_xi(i_r),:) + &
                &          p_on_xi(  1)*k_atmos_TScat(f_i,sort_xi(  1),:) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
              k_atmos_p(scat_index(i_r)) = k_atmos_p(scat_index(i_r)) + &
                & 0.25 * ( dP_dIWC_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                &          dP_dIWC_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
            end if
            if ( temp_der ) then
              k_temp_p =  &
                & 0.25 * ( p_on_xi(i_r)*k_temp_TScat(f_i,sort_xi(i_r),:) + &
                &          p_on_xi(  1)*k_temp_TScat(f_i,sort_xi(  1),:) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
              k_temp_p(scat_index(i_r)) = k_temp_p(scat_index(i_r)) + &
                & 0.25 * ( dP_dT_on_Xi(i_r)*rads(f_i,sort_xi(i_r)) + &
                &          dP_dT_on_Xi(  1)*rads(f_i,sort_xi(  1)) ) * &
                &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
              end if
            do ptg_i = 2, i_r ! Now do the rest.
              TScat%values(surf_i,phi_i) = TScat%values(surf_i,phi_i) + &
                & 0.25 * ( p_on_xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                &          p_on_xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
              if ( atmos_der ) then
                k_atmos_p = k_atmos_p + &
                  & 0.25 * ( p_on_xi(ptg_i-1)*k_atmos_TScat(f_i,sort_xi(ptg_i-1),:) + &
                  &          p_on_xi(ptg_i  )*k_atmos_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                  &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
                k_atmos_p(scat_index(ptg_i-1)) = k_atmos_p(scat_index(ptg_i-1)) + &
                  & 0.25 * ( dP_dIWC_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                  &          dP_dIWC_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                  &        ( xis(sort_xi(ptg_i  )) + pix2 - xis(sort_xi(ptg_i-1)) )
              end if
              if ( temp_der ) then
                k_temp_p = k_temp_p + &
                  & 0.25 * ( p_on_xi(ptg_i-1)*k_temp_TScat(f_i,sort_xi(ptg_i-1),:) + &
                  &          p_on_xi(ptg_i  )*k_temp_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                  &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
                k_temp_p(scat_index(ptg_i-1)) = k_temp_p(scat_index(ptg_i-1)) + &
                  & 0.25 * ( dP_dT_on_Xi(ptg_i-1)*rads(f_i,sort_xi(ptg_i-1)) + &
                  &          dP_dT_on_Xi(ptg_i  )*rads(f_i,sort_xi(ptg_i  )) ) * &
                  &        ( xis(sort_xi(ptg_i  )) + pix2 - xis(sort_xi(ptg_i-1)) )
              end if
            end do
            !{ It isn't necessary to divide by
            ! $\int \, P(\xi) \sin\xi \, \text{d}\xi$
            ! because that normalization was done when the $P$ tables were
            ! constructed.
            if ( atmos_der ) &
              & call store_other_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
                                       & beta_group%qty, Grids_f, k_atmos_p, &
                                       & jacobian )
            if ( temp_der ) &
              & call store_temperature_deriv ( phi_i, surf_i, TScats(f_i)%qty, &
                                       & temp, grids_tmp, k_temp_p, &
                                       & jacobian )
          end do ! f_i = 1, noUsedChannels
          call interpolateArrayTeardown ( coeffs_Theta_e_Xi )
d3156 20
a3175 2
        end do ! phi_i
      end do ! zeta_i
d3177 14
a3190 5
      if ( dump_TScat ) then
        do f_i = 1, noUsedChannels
          call dump ( TScats(f_i)%qty%values, name = 'TScat' )
        end do
      end if
d3192 2
a3193 1
      if ( toggle(emit) ) call Trace_End ( 'Generate_TScat' )
d3195 4
a3198 1
    end subroutine Generate_TScat
d3200 5
a3204 3
  ! ........................................  Get_Channel_Centers  .....
    subroutine Get_Channel_Centers ( channelCenters )
      real(r8) :: ChannelCenters(:)
d3206 1
a3206 3
      integer :: Channel           ! Loop inductor and subscript
      real(r8) :: Dir              ! +1 for USB, -1 for LSB
      integer :: Sig               ! Subscript for fwdModelConf%signals
d3208 1
a3208 8
      select case ( thisSideband )
      case ( -1, +1 ) ! OK
      case ( 0 )
        call Announce_Error ( &
          & 'Folded signal requested in non-frequency-averaged forward model' )
      case default
        call Announce_Error ( 'Bad value of signal%sideband' )
      end select
d3210 1
a3210 8
      dir = thisSideband
      do channel = 1, noUsedChannels
        sig = channels(channel)%signal
        channelCenters(channel) = firstSignal%lo + dir * &
          & ( fwdModelConf%signals(sig)%centerFrequency + &
          &   fwdModelConf%signals(sig)%direction * &
          &   fwdModelConf%signals(sig)%frequencies(channels(channel)%used) )
      end do
d3212 7
a3218 1
    end subroutine Get_Channel_Centers
d3220 1
a3220 3
    ! ---------------------------------  Interpolate_P_to_theta_e  -----
    subroutine Interpolate_P_to_theta_e ( P, Eta_t_iwc, Theta_e, Beg_Pos_Theta, &
      &                                   Xis, Coeffs, P_on_Xi )
d3222 6
a3227 1
      ! Interpolate P or dP_dT or dP_dIWC from Theta to Xi, for TScat generation.
d3229 1
a3229 2
      use MLSKinds, only: Rp
      use MLSNumerics, only: Coefficients_r8, InterpolateValues
d3231 6
a3236 8
      real(rp), intent(in) :: P(0:,0:,:) ! P or dP_dT or dP_dIWC on T x IWC x Theta
      real(rp), intent(in) :: Eta_T_IWC(0:,0:) ! 2x2, to interpolate to T, IWC
      real(rp), intent(in) :: Theta_e(:) ! Theta extended to negative values
      integer, intent(in) :: Beg_Pos_Theta ! 1 or 2, depending on whether
                                         ! theta_e(1) is nonzero or zero
      real(rp), intent(in) :: Xis(:) ! Angles on which radiative transfer calculated
      type(coefficients_r8), intent(in) :: Coeffs ! To interpolate from Theta_e to Xis
      real(rp), intent(out) :: P_on_Xi(:) ! Interpolated result
d3238 1
a3238 5
      real(rp) :: P_T_IWC(size(p,3)) ! P interpolated to T and IWC
      real(rp) :: P_on_Theta_e(2*size(p_t_iwc)+1-beg_pos_theta) ! P * sin(abs(theta))
                               ! interpolated to scattering point IWC and T for
                               ! each theta (including negative theta), intermediary
                               ! to getting P_On_Xi
d3240 6
a3245 1
      integer :: I
d3247 1
a3247 6
      ! Interpolate P to scattering point IWC and temperature and
      ! multiply that by sin(theta)
      do i = 1, size(p_t_iwc)
        p_t_iwc(i) = &
          & sum(eta_t_iwc(0:1,0:1) * p(0:1,0:1,i) ) * abs(sin(theta_e(i)))
      end do
d3249 1
a3249 5
      ! The phase function is symmetric in theta, but the radiances
      ! are not.  Unfold p_t_iwc to negative theta.
      p_on_theta_e(1:size(p_t_iwc)) = p_t_iwc(size(p_t_iwc):1:-1)
      p_on_theta_e(size(p_t_iwc)+1:2*size(p_t_iwc)+1-beg_pos_theta) = &
        & p_t_iwc(beg_pos_theta:)
d3251 2
a3252 3
      ! Now interpolate P_On_Theta_e to P_On_Xi using a periodic spline
      call interpolateValues ( coeffs, theta_e, p_on_theta_e, &
        & xis, p_on_xi, method='S', extrapolate='P' )
d3254 1
a3254 1
    end subroutine Interpolate_P_to_theta_e
d3265 1
d3271 1
d3300 1
d3813 11
d3911 4
a3914 4
! $\Delta B_{in}$ is {\tt T\_Script\_LBL} &
! $\Delta B_{ic}$ is {\tt T\_Script\_PFA} &
! $\tau^s_{in}$ is {\tt Tau\_LBL} &
! $\tau^w_{ic}$ is {\tt Tau\_PFA}
d3916 3
a3918 3
! $\delta I^\sigma_{iq}$ is {\tt Inc\_Rad\_Path} &
! $\overline{\delta I^s_{ic}}$ is {\tt Rad\_Avg\_Path} & 
! $I_{ic}$ is also {\tt Rad\_Avg\_Path} &
d3922 2
a3923 2
! $\frac{\partial I^\sigma_q}{\partial x_k}$ is {\tt K\_}$x${\tt\_FRQ} &
! $\frac{\partial I_c}{\partial x_k}$ is {\tt K\_}$x$
d3929 11
a3939 10
          call frequency_loop ( ptg_i, frq_i, alpha_path_c(:npc),                &
            & beta_path_c(:npc,:,frq_i), c_inds(:npc), del_s(:npc),              &
            & del_zeta(:npc), do_calc_fzp(:npf,:), do_calc_zp(:npf,:),           &
            & do_GL(:npc), frequencies(frq_i), h_path_c, tan_ht,                 &
            & incoptdepth(:npc), p_path(:npf), pfaFalse, ref_corr(:npc),         &
            & sps_path(:npf,:), tau_lbl, t_path_c(:npc),                         &
            & t_script_lbl(:npc,frq_i), tanh1_c(:npc), tt_path_c(:s_i*npc),      &
            & w0_path_c(:s_i*npc), z_path(:npf), i_start, i_end,                 &
            & inc_rad_path(:,frq_i), RadV(frq_i), dAlpha_dT_path_c(:npc,frq_i),  &
            & K_Atmos_Frq(frq_i,:), K_Spect_dN_Frq(frq_i,:),                     &
d3954 12
d3972 3
a3974 2
          call frequency_avg_path ( inc_rad_path, rad_avg_path )
          ! Multiply by Tau_PFA to combine PFA contribution in Frequency_Loop.
d3978 11
a3988 10
          call frequency_loop ( ptg_i, frq_i, alpha_path_c(:npc),                &
            & beta_path_c(:npc,:,frq_i), c_inds(:npc), del_s(:npc),              &
            & del_zeta(:npc), do_calc_fzp(:npf,:), do_calc_zp(:npf,:),           &
            & do_GL(:npc),  channelCenters(frq_i), h_path_c, tan_ht,             &
            & incoptdepth(:npc), p_path(:npf), pfaTrue, ref_corr(:npc),          &
            & sps_path(:npf,:), tau_pfa, t_path_c(:npc),                         &
            & t_script_pfa(:npc,frq_i), tanh1_c(:npc), tt_path_c(:s_i*npc),      &
            & w0_path_c(:s_i*npc), z_path(:npf), i_start, i_end,                 &
            & rad_avg_path(:,frq_i), RadV(frq_i), dAlpha_dT_path_c(:npc,frq_i),  &
            & K_Atmos_Frq(frq_i,:), K_Spect_dN_Frq(frq_i,:),                     &
d3998 1
a3998 1
      end if
d4238 1
a4238 1
       "$Id: FullForwardModel_m.f90,v 2.304 2010/06/07 23:23:53 vsnyder Exp $"
d4248 6
@


2.304
log
@Numerous changes inching toward using TScat tables, some of which will
almost certainly prove to have been dead ends.
@
text
@d384 1
d481 3
a483 1
    real(rp) :: DALPHA_DT_PATH_C(max_c)   ! dAlpha/dT on coarse grid
d519 3
a521 1
    real(rp) :: BETA_PATH_C(max_c,no_mol)  ! Beta on path coarse
d690 4
d798 3
a800 3
    nullify ( frequencies, inc_rad_path, k_atmos_frq, k_spect_dn_frq, &
      & k_spect_dv_frq, k_spect_dw_frq, k_temp_frq, RadV, t_script_lbl, &
      & w0_frq_path )
d957 3
a959 1
      call deallocate_test ( inc_rad_path,   'Inc_Rad_Path',   moduleName )
d1774 4
a1777 4
    subroutine Frequency_Avg_Rad_Path
      ! For every channel, frequency average the incremental radiance at
      ! every point along the path, giving Rad_Avg_Path for every channel
      ! and every point along the path.
d1781 3
d1793 1
a1793 1
                    & inc_rad_path(p,:), rad_avg_path(p,c) )
d1797 1
a1797 1
    end subroutine Frequency_Avg_Rad_Path
d1800 2
a1801 2
    subroutine Frequency_Loop ( Ptg_i, Alpha_Path_c, Beta_Path_c, C_Inds,    &
      & Del_S, Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL, Frequencies,        &
d1804 2
a1805 1
      & I_Start, I_End )
a1820 2
      use Read_Mie_m, only: dBeta_dIWC_c_e, dBeta_dIWC_c_s, &
        & dBeta_dIWC_c_e, dBeta_dT_c_s, Log_Beta_c_e, Log_Beta_c_s, Log_Mie
d1826 3
a1828 1
      use Read_Mie_m, only: F_s, IWC_s, T_s ! Mie table coordinates
d1833 1
d1842 1
a1842 1
      real(r8), intent(in) :: Frequencies(:)  ! The frequency grid
d1854 1
a1854 1
      real(rp), intent(out) :: T_Script(:,:)! Delta_B in some notes
d1860 8
a1868 2
      integer :: FRQ_I                    ! Frequency loop index
      real(r8) :: FRQ                     ! Frequency
a1875 6
      ! The following kludge is to work around a defect in the Fujitsu
      ! compiler: It appears to want to take a copy of inc_rad_path when
      ! a slice of it is used as an actual argument, thereby increasing
      ! run time by 10-20%.
      real(rp), pointer :: Inc_Rad_Path_Slice(:)

d1883 2
a1884 6
      do frq_i = 1, size(frequencies)

        if ( toggle(emit) .and. levels(emit) > 5 ) &
          & call Trace_Begin ( 'ForwardModel.Frequency ', index=frq_i )

        Frq = frequencies(frq_i)
d1886 1
a1886 1
        do_gl = .false.
d1888 1
a1888 5
        ! The following kludge is to work around a defect in the Fujitsu
        ! compiler: It appears to want to take a copy of inc_rad_path when
        ! a slice of it is used as an actual argument, thereby increasing
        ! run time by 10-20%.
        inc_rad_path_slice => inc_rad_path(:npc,frq_i)
d1890 5
a1894 7
        ! Set up path quantities --------------------------------------

        ! Compute the sps_path for this Frequency
        call comp_sps_path_frq ( Grids_f, Frq, eta_zp(:npf,:), &
          & do_calc_zp, sps_path,                              &
          & do_calc_fzp, eta_fzp(:npf,:),                      &
          & firstSignal%lo, thisSideband )
d1903 17
a1919 17
        if ( pfa ) then
          call get_beta_path_PFA ( frq, frq_i, z_path, c_inds, t_path_c, &
            & beta_group, sx, vel_rel, sps_path, beta_path_c,            &
            & t_der_path_flags, dbeta_dT_path_c, dbeta_dw_path_c,        &
            & dbeta_dn_path_c, dbeta_dv_path_c, dbeta_dIWC_path_c )
        else
          frqhk = 0.5_r8 * frq * h_over_k    ! h nu / 2 k
          tanh1_c = tanh( frqhk / t_path_c ) ! tanh ( h nu / 2 k T )
          ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
          if ( temp_der ) dTanh_dT_c(:npc) = &
              & frqhk / t_path_c**2 * ( tanh1_c - 1.0_rp / tanh1_c )
          call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_c,      &
            &  tanh1_c, beta_group, sx, fwdModelConf%polarized, gl_slabs,  &
            &  c_inds, beta_path_c, t_der_path_flags, dTanh_dT_c, vel_rel, &
            &  dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c,          &
            &  dbeta_dv_path_c, sps_path )
        end if
d1921 18
a1938 18
        if ( FwdModelConf%incl_cld .and. .not. pfa ) then
          ! Compute Scattering source function based on temp prof at all
          ! angles U for each temperature layer assuming a plane parallel
          ! atmosphere.

          if ( ptg_i == 1 ) then
          ! ??? Can this work?  On all pointings after the first one, ???
          ! ??? it uses the result for the last frequency.            ???
          ! ??? We have a different frequency grid for each pointing, ???
          ! ??? so is this the wrong idea in the first place?         ???

            call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),      & 
               & 10.0**(-temp%template%surfs), vmrArray(1,:), vmrArray(2,:), &
               & vmrArray(3,:),fwdModelConf%num_scattering_angles,           &
               & fwdModelConf%num_azimuth_angles,                            &
               & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,      &
               & fwdModelConf%no_cloud_species,                              &
               & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang )
d1940 1
a1940 1
          end if
d1942 1
a1942 1
          scat_src%template = temp%template
d1944 2
a1945 2
          call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, &
            & fwdModelConf, .false., .true. )
d1947 8
a1954 8
          call comp_eta_docalc_no_frq ( grids_tscat, z_path(1:npf), &
            &  phi_path(1:npf), eta_tscat_zp(1:npf,:),              &
            &  do_calc_tscat_zp(1:npf,:), tan_pt=tan_pt_f )

          call comp_sps_path_frq ( grids_tscat,                &
            & frq_0, eta_tscat_zp(1:npf,:),                    &
            & do_calc_tscat_zp(1:npf,:), tscat_path(1:npf,:),  &
            & do_calc_tscat(1:npf,:), eta_tscat(1:npf,:) )
d1960 3
a1962 3
          ! project Tscat onto LOS
          call interp_tscat ( tscat_path(1:npf,:), Scat_ang(:), &
            & phi_path(1:npf), tt_path(1:npf,:) )
d1964 1
a1964 1
          if ( .not. cld_fine ) then                 ! interpolate onto gl grids along the LOS
d1966 2
a1967 2
            scat_alb%template = temp%template
            cld_ext%template  = temp%template
d1969 2
a1970 2
            call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false.)
            call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false.)             
d1972 2
a1973 2
            where ( abs(grids_salb%values) < TOL ) grids_salb%values = 0.0
            where ( abs(grids_cext%values) < TOL ) grids_cext%values = 0.0
d1975 3
a1977 3
            call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:npf), &
              &  phi_path(1:npf), eta_salb_zp(1:npf,:),              &
              &  do_calc_salb_zp(1:npf,:), tan_pt=tan_pt_f )
d1979 4
a1982 4
            call comp_sps_path_frq ( Grids_salb,               &
              & frq_0, eta_salb_zp(1:npf,:),                   &
              & do_calc_salb_zp(1:npf,:), salb_path(1:npf,:),  &
              & do_calc_salb(1:npf,:), eta_salb(1:npf,:) )
d1988 8
a1995 8
            call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:npf), &
              &  phi_path(1:npf), eta_cext_zp(1:npf,:),              &
              &  do_calc_cext_zp(1:npf,:), tan_pt=tan_pt_f )

            call comp_sps_path_frq ( Grids_cext,               &
              & frq_0, eta_cext_zp(1:npf,:),                   &
              & do_calc_cext_zp(1:npf,:), cext_path(1:npf,:),  &
              & do_calc_cext(1:npf,:), eta_cext(1:npf,:) )
d2001 4
a2004 4
            call convert_grid ( salb_path(1:npf,:), cext_path(1:npf,:),  & 
                              & tt_path(1:npf,:), c_inds,                & 
                              & beta_path_cloud_c(1:npc), w0_path_c,     & 
                              & tt_path_c )
d2006 1
a2006 6
          else

            ! cld_fine              re-compute cext and w0 along the LOS
            call get_beta_path_cloud ( Frq, t_path(1:npf), tt_path(1:npf,:), &
              &  c_inds, beta_path_cloud_c(1:npc), w0_path_c, tt_path_c,     &
              &  IPSD(1:npf),  WC(:,1:npf), fwdModelConf )
d2008 4
a2011 1
          end if
a2012 56
          do j = 1, npc ! Don't trust compilers to fuse loops
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                  &        beta_path_c(j,:) )     &
                                  & + beta_path_cloud_c(j)
            incoptdepth(j) = alpha_path_c(j) * del_s(j)
          end do

          ! Needed to compute inc_rad_path_slice and by rad_tran_pol
          call two_d_t_script_cloud ( t_path_c, tt_path_c, w0_path_c, &  
            & spaceRadiance%values(1,1), frq, t_script(:,frq_i), B(:npc) )

        else ! Not cloud model

          !{ {\tt incoptdepth} is $\Delta \delta_{s\rightarrow s-1} =
          !  \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
          !    \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
          !  $G(\zeta)$ is {\tt alpha\_path\_c}, which is approximated
          !  here by the rectangle rule, \emph{viz.}
          !  $\Delta \delta_{i\rightarrow i-1} \approx G(\zeta_i) \delta s_i$.

          do j = i_start, i_end ! Don't trust compilers to fuse loops
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                         & beta_path_c(j,:) )
            incoptdepth(j) = alpha_path_c(j) * del_s(j)
          end do
          incoptdepth(i_end+1:npc) = 0.0 ! if not integrating full path

          ! T_Script and B needed to compute inc_rad_path_slice and by rad_tran_pol
          call two_d_t_script ( t_path_c(i_start:i_end), &  
            & spaceRadiance%values(1,1), frq, &
            & t_script(i_start:i_end,frq_i), &
            & B(i_start:i_end) )

        end if ! end of check cld 

        if ( fwdModelConf%useTScat .and. .not. pfa ) then
          ! Determine the frequency subscript for the Mie tables.
          ! We expect size(F_s) to be small.
          Mie_frq_index = minloc(abs(f_s-frq),1)
          if ( abs(f_s(Mie_frq_index)-frq) > fwdModelConf%frqTol ) &
            & call MLSMessage ( MLSMSG_Error, moduleName, &
              & "UseTScat requested but no Mie tables near enough to Frq" )
          call log_Mie ! Get log_beta_c_e and log_beta_c_s if not done yet
          ! Interpolate Mie beta_c_e and beta_c_s to T and IWC on path
          ! First get interpolating coefficients from Mie tables to T and
          ! IWC on the coarse path.
          call get_eta_stru ( t_s, t_path_c, eta_t_path_c )
          call get_eta_stru ( iwc_s, iwc_path(c_inds,1), eta_iwc_path_c )
          call interpolate_stru ( log_beta_c_e(:,:,Mie_frq_index), &
            & eta_t_path_c, eta_iwc_path_c, &
            & beta_c_e_path_c ) ! Actually getting log(beta_c_e_path_c)
          call interpolate_stru ( log_beta_c_s(:,:,Mie_frq_index), &
            & eta_t_path_c, eta_iwc_path_c, &
            & beta_c_s_path_c ) ! Actually getting log(beta_c_s_path_c)
          ! Get W0_Path
          w0_path_c = exp(beta_c_s_path_c) / ( alpha_path_c + exp(beta_c_e_path_c) )
d2015 6
a2020 2
        if ( .not. fwdModelConf%polarized ) then
          ! Determine where to use Gauss-Legendre for scalar instead of a trapezoid.
d2022 19
a2040 2
          call path_contrib ( incoptdepth, tan_pt_c, i_start, i_end, &
            &                 e_rflty, fwdModelConf%tolerance, do_gl )
d2042 30
a2071 2
        else ! Extra stuff for polarized case
             ! Can't be doing TScat, so process the whole path
d2073 2
a2074 17
          call get_beta_path_polarized ( frq, h, beta_group%lbl(sx), gl_slabs, &
            & c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )

          ! We put an explicit extent of -1:1 for the first dimension in
          ! the hope a clever compiler will do better optimization with
          ! a constant extent.
          ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
          ! to alpha here

          do j = 1, npc
            alpha_path_polarized(-1:1,j) = &
              & matmul( beta_path_polarized(-1:1,j,:),       &
              &         sps_path(c_inds(j),:) ) * tanh1_c(j) &
              & + 0.25 * alpha_path_c(j)
            alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
              & 0.25 * alpha_path_c(j)
          end do
d2076 2
a2077 16
          ! Turn sigma-, pi, sigma+ into 2X2 matrix incoptdepth_pol
          call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
            & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )

          ! We don't add unpolarized incremental optical depth to diagonal
          ! of polarized incremental optical depth because we added the
          ! scalar alpha_path to the sigma-, pi and sigma+ parts of
          ! alpha_path_polarized above.  If we did add it here, we would
          ! need 0.5 factors to scale unpolarized "power absorption" to
          ! get "field absorption"

          do j = 2, npc-1
            incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j)
            incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j) * del_s(j)
            incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j) * del_s(j)
            incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j)
d2079 2
a2080 3
            ! deltau_pol = exp(incoptdepth_pol)
            call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
          end do
d2082 17
a2098 3
          ! Determine where to do GL
          call path_contrib ( deltau_pol(:,:,1:npc), tan_pt_c, e_rflty, &
             & fwdModelConf%tolerance, do_gl )
d2100 16
a2115 1
        end if
d2117 2
a2118 24
        !{ We want $\Delta \delta_{s\rightarrow s-1} =
        ! \int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
        !   \frac{\text{d}h}{\text{d}\zeta} \text{d} \zeta$ where
        ! $G(\zeta)$ is {\tt alpha\_path\_c}, but $\frac{\text{d}s}{\text{d}h}$
        ! is singular at the tangent point, so we compute
        ! $\Delta \delta_{s\rightarrow s-1} = G(\zeta_i) \delta s_i +
        ! \int_{\zeta_i}^{\zeta_{i-1}} \left(G(\zeta)-G(\zeta_i)\right)
        ! \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
        ! \text{d} \zeta$.
        !
        ! Where we do GL, the second integral is approximated using GL (in
        ! {\tt Get\_Tau}).  Where we don't do GL, approximate it using the
        ! trapezoid rule (here).  There is already a factor of 0.5 in
        ! {\tt del\_zeta}, to compensate for the GL weights summing to 2.0.

        do j = i_start+1, tan_pt_c
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = incoptdepth(j) + &
              & ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1)*del_zeta(j)
        end do
        do j = tan_pt_c+1, i_end-1
          if ( .not. do_gl(j) ) &
            & incoptdepth(j) = incoptdepth(j) + &
              & ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1)*del_zeta(j)
d2121 3
a2123 12
        call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, cg_inds_b, ngl, ncg )
        cg_inds => cg_inds_b(:ncg)
        gl_inds => gl_inds_b(:ngl)
        ! ngl is ng * count(do_gl)
        t_path_f(:ngl) = t_path(gl_inds)

        if ( pfa ) then

          call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds, t_path_f(:ngl), &
            & beta_group, sx, vel_rel, sps_path, beta_path_f(:ngl,:),           &
            & t_der_path_flags, dbeta_dT_path_f, dbeta_dw_path_f,               &
            & dbeta_dn_path_f, dbeta_dv_path_f, dbeta_dIWC_path_f )
d2125 1
a2125 1
        else
d2127 25
a2151 5
          tanh1_f(1:ngl) = tanh( frqhk / t_path_f(:ngl) )
          ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
          if ( temp_der ) &
            & dTanh_dT_f(1:ngl) = frqhk / t_path_f(1:ngl)**2 * &
              & ( tanh1_f(1:ngl) - 1.0_rp / tanh1_f(1:ngl) )
d2153 12
a2164 18
          ! The derivatives that get_beta_path computes depend on which
          ! derivative arrays are allocated, not which ones are present.
          ! This avoids having four paths through the code, each with a
          ! different set of optional arguments.

          call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_f(:ngl),    &
            & tanh1_f(1:ngl), beta_group, sx, fwdModelConf%polarized, gl_slabs,&
            & gl_inds, beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,      &
            & vel_rel, dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f,      &
            & dbeta_dv_path_f, sps_path )

        end if ! .not. pfa

        do j = 1, ngl ! loop around dot_product instead of doing sum(a*b,2)
                      ! to avoid path-length array temps
          alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                       & beta_path_f(j,:) )
        end do
d2166 1
a2166 7
        if ( print_incopt ) then
          call dump ( beta_path_c(i_start+1:i_end-1,:), name="Beta_Path" )
          call dump ( sps_path(c_inds(i_start+1:i_end-1),:), name="SPS_Path" )
          call dump ( alpha_path_c(i_start+1:i_end-1), name="Alpha_Path_C" )
          call dump ( incoptdepth(i_start+1:i_end-1), name="Incoptdepth" )
          call dump ( del_s(i_start+1:i_end-1), name="Del_s" )
        end if
d2168 24
a2191 1
        if ( .not. fwdModelConf%polarized ) then
d2193 7
a2199 1
        ! Compute SCALAR radiative transfer --------------------------
d2201 1
a2201 17
          call get_tau ( frq_i, gl_inds, cg_inds, i_start, e_rflty,  &
            & del_zeta, alpha_path_c, ref_corr, incoptdepth(:i_end), &
            & tan_pt_c, alpha_path_f(1:ngl), dsdz_gw_path, tau )
          i_stop = tau%i_stop(frq_i)

          if ( .not. pfa .or. .not. fwdModelConf%anyLBL(sx) ) then
            ! Not doing PFA, or doing PFA but haven't done LBL.
            ! Get incremental radiance and radiance from Tau and T_Script.
            ! Don't clobber them if doing PFA and already did LBL.  If
            ! doing LBL, inc_rad_path will be frequency averaged to give
            ! Rad_Avg_Path.
            radV(frq_i) = 0.0
            do j = i_start, i_stop
              inc_rad_path_slice(j) = t_script(j,frq_i) * tau%tau(j,frq_i)
              radV(frq_i) = radV(frq_i) + inc_rad_path_slice(j)
            end do ! j
          end if
d2203 1
a2203 13
          if ( pfa .and. frq_avg_sel == 15 ) then ! See Frequency_Average.
            ! Doing PFA and did LBL and need derivatives and will frequency
            ! average.  Multiply Rad_Avg_Path by Tau to combine LBL and PFA. 
            ! Then sum to give RadV.  Rad_Avg_Path is channel-averaged LBL
            ! radiance. Remember, when doing PFA, Frq_I is a channel number.
            ! See wvs-026.
            radV(frq_i) = 0.0
            do j = i_start, i_stop
              Rad_Avg_Path(j,frq_i) = Rad_Avg_Path(j,frq_i) * tau%tau(j,frq_i)
              radV(frq_i) = radV(frq_i) + Rad_Avg_Path(j,frq_i)
            end do ! j
            inc_rad_path_slice => Rad_Avg_Path(:npc,frq_i)
          end if
d2205 17
a2221 1
          inc_rad_path_slice(i_stop+1:) = 0
d2223 14
a2236 6
          if ( print_incopt ) then
            call dump ( tau%tau(i_start:i_stop,frq_i), name="Tau" )
            call dump ( inc_rad_path_slice(i_start:i_stop), name="Inc_Rad_Path_Slice" )
            call output ( frq_i, before="RadV(" )
            call output ( radV(frq_i), before=") = ", advance="yes" )
          end if
d2238 6
a2243 28
          if ( print_path ) call dump_path ( fwdModelConf, i_start, i_end, &
            & phi_path(c_inds), z_path(c_inds), sps_path(c_inds,:), beta_path_c, &
            & alpha_path_c, incoptdepth, frq_i, tau, inc_rad_path_slice )

        else ! Polarized model; can't combine with PFA or TScat

        ! Compute POLARIZED radiative transfer -----------------------------

          i_stop = npc ! needed by drad_tran_df

          ! Get the corrections to integrals for layers that need GL for
          ! the polarized species.
          call get_beta_path_polarized ( frq, h,beta_group%lbl(sx), gl_slabs, &
            & gl_inds, beta_path_polarized_f, dBeta_dT_polarized_path_f )

          ! We put an explicit extent of -1:1 for the first dimension in
          ! the hope a clever compiler will do better optimization with
          ! a constant extent.
          ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
          ! to alpha here.
          do j = 1, ngl
            alpha_path_polarized_f(-1:1,j) = &
              & matmul( beta_path_polarized_f(-1:1,j,:), &
              &         sps_path(gl_inds(j),:) ) * tanh1_f(j) &
              & + 0.25 * alpha_path_f(j)
            alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) +               &
              & 0.25 * alpha_path_f(j)
          end do
d2245 28
a2272 20
          call rad_tran_pol ( tan_pt_c, gl_inds, cg_inds, e_rflty, del_zeta,        &
            & alpha_path_polarized(:,1:npc), ref_corr, incoptdepth_pol(:,:,1:npc),  &
            & deltau_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl), dsdz_gw_path, &
            & ct, stcp, stsp, t_script(:,frq_i), dump_rad_pol, prod_pol(:,:,1:npc), &
            & tau_pol(:,:,1:npc), rad_pol, p_stop )

          if ( p_stop < 0 ) then ! exp(incoptdepth_pol(:,:,-p_stop)) failed
            call output ( 'Exp(incoptdepth_pol(:,:,' )
            call output ( -p_stop )
            call output ( ') failed.  Value is', advance='yes' )
            call dump ( incoptdepth_pol(:,:,-p_stop), options='c' ) ! clean=.TRUE.
            call output ( thisSideband, before='thisSideband = ' )
            call output ( ptg_i, before=', ptg_i = ' )
            call output ( frq_i, before=', frq_i = ', advance='true' )
            call dump ( t_path_c(:npc), name='T_Path' )
            call dump ( ref_corr(:npc), name='Ref_Corr' )
            call dump ( n_path_c(:npc), name='N_Path' )
            call dump ( h_path_c(:npc), name='H_Path' )
            call Announce_Error ( 'exp(incoptdepth_pol) failed' )
          end if
d2274 20
a2293 5
          if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
            RadV(frq_i) = real(rad_pol(1,1))
          else
            RadV(frq_i) = real(rad_pol(2,2))
          end if
d2295 4
d2301 3
a2303 1
        ! Compute derivatives if needed ----------------------------------
d2305 1
a2305 1
        if ( atmos_der ) then
d2307 24
a2330 24
          call drad_tran_df ( max_f, c_inds, gl_inds, del_zeta, Grids_f, &
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,              &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,        &
            &  inc_rad_path_slice, dBeta_dIWC_path_c, dBeta_dIWC_path_f, &
            &  i_cloud_a, i_start, tan_pt_c, i_stop, size(d_delta_df,1), &
            &  d_delta_df, nz_d_delta_df, nnz_d_delta_df, k_atmos_frq(frq_i,:) )

          if ( .not. pfa_or_not_pol ) then ! polarized and not PFA

            ! VMR derivatives for polarized radiance.
            ! Compute DE / Df from D Incoptdepth_pol / Df and put
            ! into DE_DF.
            call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop),    &
              &  Grids_f, beta_path_polarized(:,1:p_stop,:), tanh1_c(:npc), &
              &  eta_fzp(:npf,:), do_calc_fzp, sps_path, del_s,             &
              &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),         &
              &  d_delta_df(1:npc,:), de_df(:,:,1:p_stop,:) )

            ! Compute D radiance / Df from Tau, Prod, T_Script
            ! and DE / Df.
            call mcrt_der ( t_script(:,frq_i), sqrt(e_rflty),    &
              & deltau_pol(:,:,1:npc), de_df(:,:,1:npc,:),       &
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &
              & tan_pt_c, d_rad_pol_df )
d2332 5
a2336 5
            if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
              k_atmos_frq(frq_i,:) = real(d_rad_pol_df(1,1,:))
            else
              k_atmos_frq(frq_i,:) = real(d_rad_pol_df(2,2,:))
            end if
d2338 1
a2338 1
          end if ! polarized and not PFA
d2340 1
a2340 1
        end if ! atmos_der
d2342 1
a2342 1
        if ( temp_der ) then
d2344 42
a2385 51
          ! put indices of nonzeros in nz_zxp_t that are in c_inds into nz_zxp_t_c
          call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds(:i_stop), i_start, &
            & nz_zxp_t_c, nnz_zxp_t_c )

          ! get d Delta B / d T * d T / eta
          call dt_script_dt ( t_path_c, B(:npc), eta_zxp_t_c(1:npc,:), &
                            & nz_zxp_t_c, nnz_zxp_t_c, frq, d_t_scr_dt(1:npc,:) )

          dh_dt_path_f(:ngl,:) = dh_dt_path(gl_inds,:)
          do_calc_t_f(:ngl,:) = do_calc_t(gl_inds,:)
          eta_zxp_t_f(:ngl,:) = eta_zxp_t(gl_inds,:)
          h_path_f(:ngl) = h_path(gl_inds)
          dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds,:) *  &
                                        dBeta_dT_path_c(1:npc,:),dim=2 )
          dAlpha_dT_path_f(:ngl) = sum( sps_path(gl_inds,:) * &
                                        dBeta_dT_path_f(1:ngl,:),dim=2 )

          if ( pfa_or_not_pol ) then

            call drad_tran_dt ( del_zeta, h_path_c,                          &
              & dh_dt_path_c(1:npc,:), alpha_path_c,                         &
              & dAlpha_dT_path_c(:npc), eta_zxp_t_c(1:npc,:),                &
              & do_calc_t_c(1:npc,:), do_calc_hyd_c(1:npc,:), del_s,         &
              & ref_corr, tan_ht, dh_dt_path(tan_pt_f,:),                    &
              & do_gl, gl_inds, h_path_f(:ngl), t_path_f(:ngl),              &
              & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),                   &
              & dAlpha_dT_path_f(:ngl), eta_zxp_t_f(:ngl,:),                 &
              & do_calc_t_f(:ngl,:), dsdh_path, dhdz_gw_path, dsdz_gw_path,  &
              & d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i),                    &
              & inc_rad_path_slice, i_start, tan_pt_c, i_stop,               &
              & grids_tmp%deriv_flags, pfa .and. frq_avg_sel == 15,          &
              & k_temp_frq(frq_i,:) )

          else ! pol and not pfa

            ! Temperature derivatives for polarized radiance
            ! Compute DE / DT from D Incoptdepth_Pol / DT and put
            ! into DE_DT.

            dAlpha_dT_polarized_path_c(:,1:npc) = 0.0
            dAlpha_dT_polarized_path_f(:,1:ngl) = 0.0
            do j = 1, no_mol
              do l = -1, 1
                dAlpha_dT_polarized_path_c(l,1:npc) = &
              & dAlpha_dT_polarized_path_c(l,1:npc) + &
                  & sps_path(c_inds,j) * dBeta_dT_polarized_path_c(l,1:npc,j)
                dAlpha_dT_polarized_path_f(l,1:ngl) = &
              & dAlpha_dT_polarized_path_f(l,1:ngl) + &
                  & sps_path(gl_inds,j) * dBeta_dT_polarized_path_f(l,1:ngl,j)
              end do ! l
            end do ! j
d2387 16
a2402 7
              dAlpha_dT_polarized_path_c(l,1:npc) =               &
                & dAlpha_dT_polarized_path_c(l,1:npc) * tanh1_c + &
                & alpha_path_polarized(l,:npc) * dTanh_dT_c(:npc)
              dAlpha_dT_polarized_path_f(l,1:ngl) =                     &
                & dAlpha_dT_polarized_path_f(l,1:ngl) * tanh1_f(:ngl) + &
                & alpha_path_polarized_f(l,:ngl) * dTanh_dT_f(:ngl)
            end do
d2404 22
a2425 28
            call get_d_deltau_pol_dT ( ct, stcp, stsp, tan_pt_c,            &
              & t_path_f(:ngl), alpha_path_polarized(:,1:p_stop),           &
              & alpha_path_polarized_f(:,1:ngl),                            &
              & dAlpha_dT_path_c(:npc), dAlpha_dT_path_f(:ngl),             &
              & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f,     &
              & eta_zxp_t_c(1:p_stop,:), eta_zxp_t_f(:ngl,:), del_s,        &
              & gl_inds, del_zeta, do_calc_t_c(1:p_stop,:),                 &
              & do_calc_t_f(:ngl,:), do_gl(1:p_stop), dsdh_path,            &
              & dhdz_gw_path, dsdz_gw_path, incoptdepth_pol(:,:,1:p_stop),  &
              & ref_corr(1:p_stop), h_path_c, h_path_f(:ngl),               &
              & dh_dt_path_c(1:p_stop,:),dh_dt_path_f(:ngl,:),              &
              & tan_ht, dh_dt_path(tan_pt_f,:),                             &
              & do_calc_hyd_c(1:p_stop,:), grids_tmp%deriv_flags,           &
              & de_dt(:,:,1:p_stop,:) )

            ! Compute D radiance / DT from Tau, Prod, T_Script, D_T_Scr_dT
            ! and DE / DT.

            call mcrt_der ( t_script(:,frq_i), sqrt(e_rflty),    &      
              & deltau_pol(:,:,1:npc), de_dt(:,:,1:npc,:),       &      
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &      
              & tan_pt_c, d_rad_pol_dt, d_t_scr_dt(1:npc,:) )

            if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
              k_temp_frq(frq_i,:) = real(d_rad_pol_dt(1,1,:))
            else
              k_temp_frq(frq_i,:) = real(d_rad_pol_dt(2,2,:))
            end if
d2427 4
d2435 1
a2435 1
        if ( spect_der ) then
d2437 11
a2447 7
          if ( fwdModelConf%polarized ) then
            call Announce_Error ( &
              & "Spectroscopic derivatives for Polarized species not implemented yet." )
          else if ( pfa ) then
            call Announce_Error ( &
              & "Spectroscopic derivatives for PFA not implemented yet." )
          else
d2449 15
a2463 1
            ! Spectroscopic derivative  wrt: W
d2465 1
a2465 24
            if ( spect_der_width ) &
              & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_w,      &
                &  eta_zxp_w, sps_path, fwdModelConf%lineWidth%beta(sx),     &
                &  do_calc_w, dbeta_dw_path_c, dbeta_dw_path_f, do_gl, del_s,&
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, tan_pt_c,     &
                &  i_stop, k_spect_dw_frq(frq_i,:) )

            ! Spectroscopic derivative  wrt: N

            if ( spect_der_width_TDep ) &
              & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_n,      &
                &  eta_zxp_n, sps_path, fwdModelConf%lineWidth_tDep%beta(sx),&
                &  do_calc_n, dbeta_dn_path_c, dbeta_dn_path_f, do_gl, del_s,&
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, tan_pt_c,     &
                &  i_stop, k_spect_dn_frq(frq_i,:) )

            ! Spectroscopic derivative  wrt: Nu0

            if ( spect_der_center ) &
              & call drad_tran_dx ( c_inds, gl_inds, del_zeta, grids_v,      &
                &  eta_zxp_v, sps_path, fwdModelConf%lineCenter%beta(sx),    &
                &  do_calc_v, dbeta_dv_path_c, dbeta_dv_path_f, do_gl, del_s,&
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, tan_pt_c,     &
                &  i_stop, k_spect_dv_frq(frq_i,:) )
d2467 6
a2472 1
          end if
d2476 1
a2476 1
        ! End of frequency loop ----------------------------------------------
d2478 1
a2478 2
        if ( toggle(emit) .and. levels(emit) > 5 ) &
          & call Trace_End ( 'ForwardModel.Frequency ', index=frq_i )
d2480 2
a2481 1
      end do            ! End freq. loop
d2485 1
d2570 5
d3905 13
a3917 7
        call frequency_loop ( ptg_i, alpha_path_c(:npc), beta_path_c(:npc,:),   &
          & c_inds(:npc), del_s(:npc), del_zeta(:npc), do_calc_fzp(:npf,:),     &
          & do_calc_zp(:npf,:), do_GL(:npc), frequencies, h_path_c, tan_ht,     &
          & incoptdepth(:npc), p_path(:npf), pfaFalse, ref_corr(:npc),          &
          & sps_path(:npf,:), tau_lbl, t_path_c(:npc), t_script_lbl(:npc,:),    &
          & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc),            &
          & z_path(:npf), i_start, i_end )
d3935 3
a3937 3
          ! and every point along the path.  Multiply by Tau_PFA to combine
          ! PFA contribution in Frequency_Loop.
          call frequency_avg_rad_path
d3940 13
a3952 7
        call frequency_loop ( ptg_i, alpha_path_c(:npc), beta_path_c(:npc,:),  &
          & c_inds(:npc), del_s(:npc), del_zeta(:npc), do_calc_fzp(:npf,:),    &
          & do_calc_zp(:npf,:), do_GL(:npc), channelCenters, h_path_c, tan_ht, &
          & incoptdepth(:npc), p_path(:npf), pfaTrue, ref_corr(:npc),          &
          & sps_path(:npf,:), tau_pfa, t_path_c(:npc), t_script_pfa(:npc,:),   &
          & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc),           &
          & z_path(:npf), i_start, i_end )
d4200 1
a4200 1
       "$Id: FullForwardModel_m.f90,v 2.303 2010/05/18 18:13:35 honghanh Exp $"
d4210 4
@


2.303
log
@Change both_sidebands_setup to get GPH quantity with GetQuantityForForwardModel as the rest of the quantity
@
text
@d54 1
a54 1
    use Molecules, only: L_CLOUD_A
d83 1
a83 1
    integer :: H2O_IND          ! Index of h2o inside f array, else zero
d106 1
d142 1
a142 1
      & h2o_ind )
d172 1
a172 1
    if ( FwdModelConf%incl_cld ) then
d232 1
d242 1
a242 1
                              & max_c, maxVert, max_f, H2O_ind, ptan_der,      &
d244 1
a244 1
                              & s_tg,                                          &
d273 1
a273 1
                              & max_c, maxVert, max_f, H2O_ind, ptan_der,      &
d275 1
a275 1
                              & s_tg,                                          &
d300 1
d310 2
a311 1
    use Molecules, only: L_CLOUD_A, L_H2O, L_N2O, L_O3
d361 1
a361 1
    integer, intent(in) :: H2O_IND          ! Index of h2o inside f array, else zero
d372 1
d384 1
d389 1
d477 2
d511 1
a511 1
    real(rp) :: W0_PATH_C(s_i*max_c)  ! w0 on path coarse
d550 1
a550 1
    real(rp) :: IWC_PATH(max_f,s_i)                ! IWC on path
d682 3
d709 3
d790 2
a791 1
      & k_spect_dv_frq, k_spect_dw_frq, k_temp_frq, RadV, t_script_lbl )
d828 2
d945 1
a945 1
        & call deallocate_test ( frequencies, 'frequencies', moduleName )
d947 1
a948 2

      ! Deallocate maxNoPtgFreqs-sized stuff
d951 1
a951 1
        call deallocate_test ( t_script_LBL, 'T_Script_LBL', moduleName )
d954 1
d1803 1
a1803 1
      use Get_Eta_Matrix_m, only: Select_NZ_List
d1806 2
d1813 1
d1848 1
d1850 1
a1850 1
      integer :: I_STOP                   ! Stop path integration before I_End
d1926 6
a1931 6
            call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),    & 
               & 10.0**(-temp%template%surfs), vmrArray, nspec,            &
               & fwdModelConf%num_scattering_angles,                       &
               & fwdModelConf%num_azimuth_angles,                          &
               & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,    &
               & fwdModelConf%no_cloud_species,                            &
d1941 1
a1941 1
          call comp_eta_docalc_no_frq ( Grids_Tscat, z_path(1:npf), &
d1945 1
a1945 1
          call comp_sps_path_frq ( Grids_tscat,                &
d2044 23
a2203 2
          ! Get incremental radiance and radiance from Tau and T_Script
          ! Don't clobber them if doing PFA and already did LBL.
d2205 5
d2218 5
a2222 2
            ! Multiply Rad_Avg_Path by Tau to combine LBL and PFA.  Then
            ! sum to give RadV.  Remember, if PFA, Frq_I is a channel number.
d2569 3
d2733 1
a2733 1
        if ( abs(channelCenters(f_i)-f_s(freq_ix(f_i))) > fwdModelConf%phaseFrqTol ) then
d3652 1
a3652 7
      if ( fwdModelConf%Incl_Cld ) then ! s_i == 1 here

        !set cloud parameters to zero
        iwc_path(1:npf,1) = 0.
        WC(1,1:npf)=iwc_path(1:npf,1)
        WC(2,1:npf)=0.
        IPSD(1:npf)=1000
d3660 6
a3665 1
        WC(1,1:npf)=iwc_path(1:npf,1)
d4000 17
d4019 1
a4019 1
      ! Get ready for TScat computation
d4179 1
a4179 1
       "$Id: FullForwardModel_m.f90,v 2.302 2010/03/24 20:50:02 vsnyder Exp $"
d4189 3
@


2.302
log
@Add more checks to TScat generation code
@
text
@d1094 1
a1094 1
      gph => GetVectorQuantityByType ( fwdModelExtra, quantityType=l_gph )
d4109 1
a4109 1
       "$Id: FullForwardModel_m.f90,v 2.301 2010/02/05 03:29:19 vsnyder Exp $"
d4119 3
@


2.301
log
@Remove unused stuff
@
text
@d2724 8
a2731 1
          if ( iwc%values(zeta_i,phi_i) <= 0.0 ) cycle ! no IWC, no scattering
d2743 10
a2752 1
          if ( scat_ht < r_eq ) cycle
d4109 1
a4109 1
       "$Id: FullForwardModel_m.f90,v 2.300 2010/02/02 01:39:06 vsnyder Exp $"
d4119 3
@


2.300
log
@Move USEs closer to where the used stuff is referenced.  Don't compute
theta if it trying to do so will cause an exception.  Finish applying the
product rule correctly for TScat derivatives.
@
text
@a319 4
    ! Extra space in the ..._R variables:  Replacement for tangent Zeta,
    ! new space for minimum Zeta, plus GL points around them.
    integer, parameter :: NXG = ( max_new + 1 ) * ngp1 - 1

d504 1
a504 2
    real(rp), target :: Z_GLGRID_O(maxvert) ! Zeta on initial glGrid surfs, original
    real(rp), target :: Z_GLGRID_R(maxvert+nxg) ! Zeta on initial glGrid surfs, revised
d528 1
a528 2
    real(rp), target :: DHDZ_GLGRID_O(maxVert,no_sv_p_t) ! dH/dZ on glGrid surfs, original
    real(rp), target :: DHDZ_GLGRID_R(maxVert+nxg,no_sv_p_t) ! dH/dZ on glGrid surfs, revised
d540 1
a540 2
    real(rp), target :: H_GLGRID_O(maxVert,no_sv_p_t) ! H on glGrid surfs, original
    real(rp), target :: H_GLGRID_R(maxVert+nxg,no_sv_p_t) ! H on glGrid surfs, revised
d550 1
a550 2
    real(rp), target :: T_GLGRID_O(maxVert,no_sv_p_t) ! Temp on glGrid surfs, original
    real(rp), target :: T_GLGRID_R(maxVert+nxg,no_sv_p_t) ! Temp on glGrid surfs, revised
d567 1
a567 2
    real(rp), target :: DH_DT_GLGRID_O(maxVert,n_t_zeta,s_t*no_sv_p_t)
    real(rp), target :: DH_DT_GLGRID_R(maxVert+nxg,n_t_zeta,s_t*no_sv_p_t)
d594 1
a594 2
    real(rp), target :: DDHIDHIDTL0_O(maxVert,n_t_zeta,s_t*no_sv_p_t) ! Original
    real(rp), target :: DDHIDHIDTL0_R(maxVert+nxg,n_t_zeta,s_t*no_sv_p_t) ! Revised
a661 8
    ! GL Grid quantities to/from Hydrostatic
    real(rp), pointer :: DDHIDHIDTL0(:,:,:) ! Either DDHIDHIDTL0_O or DDHIDHIDTL0_R
    real(rp), pointer :: DH_DT_GLGRID(:,:,:) ! Either DH_DT_GLgrid_O or DH_DT_GLgrid_R
    real(rp), pointer :: DHDZ_GLGRID(:,:) ! Either DHDZ_GLgrid_O or DHDZ_GLgrid_R
    real(rp), pointer :: H_GLGRID(:,:)   ! Either H_GLgrid_O or H_GLgrid_R
    real(rp), pointer :: T_GLGRID(:,:)   ! Either T_GLgrid_O or T_GLgrid_R
    real(rp), pointer :: Z_GLGRID(:)     ! Either Z_GLgrid_O or Z_GLgrid_R

a725 1
    type (VectorValue_T), pointer :: TScat         ! Computed TScat, Jacobian row label
a1137 9
      ! Fill the "original" GL-grid arrays.  These depend only upon the
      ! original Zetas (Z_PSIG) derived from the L2CF using make_z_grid.
      ddhidhidtl0 => ddhidhidtl0_o
      dh_dt_glgrid => dh_dt_glgrid_o
      dhdz_glgrid => dhdz_glgrid_o
      h_glgrid => h_glgrid_o
      t_glgrid => t_glgrid_o
      z_glgrid => z_glgrid_o

d1827 1
a1827 1
      integer :: I, J, L                  ! Loop inductor and subscript
d1981 2
a1982 3
            call get_beta_path_cloud ( Frq, p_path, t_path(1:npf),      &
              &  tt_path(1:npf,:), c_inds,                              &
              &  beta_path_cloud_c(1:npc), w0_path_c,  tt_path_c,       &
d2031 2
a2032 3
          call get_beta_path_polarized ( frq, firstSignal%lo, h,         &
            & beta_group%lbl(sx), gl_slabs, c_inds, beta_path_polarized, &
            & dBeta_dT_polarized_path_c )
d2201 2
a2202 3
          call get_beta_path_polarized ( frq, firstSignal%lo, h,            &
            & beta_group%lbl(sx), gl_slabs, gl_inds, beta_path_polarized_f, &
            & dBeta_dT_polarized_path_f )
d2572 1
a2572 1
        & InterpolateValues, InterpolateArrayTeardown
a2583 4
      real(rp) :: P_On_Theta_e(2*size(theta_s)+1) ! P * sin(abs(theta))
                               ! interpolated to scattering point IWC and T for
                               ! each theta, intermediary to getting P_On_Xi
      real(rp) :: P_T_IWC(size(theta_s)) ! P interpolated to T, IWC
a2618 1
      integer :: Col           ! Column number of Jacobian block
d2793 4
a2796 5
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi, &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, rev=.true. )
d2799 4
a2802 5
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi, &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, rev=.false. )
d2806 4
a2809 5
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi, &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, rev=.false. )
d2812 4
a2815 5
            call one_tscat_pointing ( ptg_i, vel_rel, scat_tan_phi, &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, rev=.true. )
d2871 5
a2875 5
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,     &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, scat_tan_ht, forward )
d2878 5
a2882 5
            call one_tscat_pointing ( 1, vel_rel, scat_tan_phi,     &
              &                       scat_zeta, scat_phi, scat_ht, &
              &                       r_eq, xi, zeta_i, phi_i,      &
              &                       xis, rads, k_atmos_TScat, k_temp_TScat, &
              &                       i_r, scat_index, scat_tan_ht, forward )
d3142 4
a3145 1
      real(rp) :: P_on_Theta_e(2*size(p_t_iwc)+1-beg_pos_theta) ! onto negative theta
a3224 9
      ! Use the "original" GL-grid arrays -- the ones filled before the
      ! sideband loop.  These depend only upon the original Zetas
      ! (Z_PSIG) derived from the L2CF using make_z_grid.
      ddhidhidtl0 => ddhidhidtl0_o
      dh_dt_glgrid => dh_dt_glgrid_o
      dhdz_glgrid => dhdz_glgrid_o
      h_glgrid => h_glgrid_o
      t_glgrid => t_glgrid_o
      z_glgrid => z_glgrid_o
d3397 1
a3397 1
          n_more = 0
d3887 2
a3888 3
      &                             Zeta_i, Phi_i, Xis, Rads, K_Atmos_TScat,  &
      &                             K_Temp_TScat, I_R, Scat_Index,            &
      &                             Scat_Tan_Ht, Forward, Rev)
a3891 2
      use Get_Eta_Matrix_m, only: Get_Eta_Sparse

a3899 4
      integer, intent(in) :: Zeta_i         ! Index of Scat_Zeta in
                                            ! TScat%template%surfs
      integer, intent(in) :: Phi_i          ! Index of Scat_Phi in
                                            ! TScat%template%phi
d4093 1
a4093 1
       "$Id: FullForwardModel_m.f90,v 2.299 2010/01/23 01:30:49 vsnyder Exp $"
d4103 5
@


2.299
log
@Move USEs into closer proximity to references.  Get cloudIce as vmr if it
isn't available as a quantityType.  Create TScat stuff with zero size if
not doing TScat table generation.  Get index of Cloud_A if there is one.
Provide that betas for Cloud_A and Cloud_S depend upon IWC mixing ratio.
Calculate TScat derivatives (still not complete).  Don't compute TScat
or derivatives where there's no IWC.  Don't use the logIWC quantity type.
During TScat table computation, interpolate P to pointing angles rather
than interpolating incident radiance to angles where T is tabluated.
@
text
@a311 4
    use Read_Mie_m, only: Beta_c_a, Beta_c_e, Beta_c_s, &
      & dBeta_dIWC_c_a, dBeta_dIWC_c_e, dBeta_dIWC_c_s, &
      & dBeta_dT_c_a, dBeta_dT_c_e, dBeta_dT_c_s, dP_dIWC, dP_dT, &
      & F_s, IWC_s, P, T_s, Theta_s
d2606 1
d2672 1
d2833 1
a2833 1
              &                       i_r, rev=.true. )
d2840 1
a2840 1
              &                       i_r, rev=.false. )
d2848 1
a2848 1
              &                       i_r, rev=.false. )
d2855 1
a2855 1
              &                       i_r, rev=.true. )
a2878 3
            scat_tan_ht = scat_ht * abs(cos(dPhi - xi)) ! xi < 0 here
            theta = 2.0 * acos(scat_tan_ht/r_eq)

d2886 4
a2890 1
            if ( scat_tan_ht > 0.0 ) cycle
d2915 1
a2915 1
              &                       i_r, scat_tan_ht, forward )
d2922 1
a2922 1
              &                       i_r, scat_tan_ht, forward )
a3037 17
!             ! Interpolate P to scattering point IWC and temperature and
!             ! multiply that by sin(theta)
!             do ptg_i = 1, size(p_t_iwc)
!               p_t_iwc(ptg_i) = &
!                 & sum(eta_t_iwc * &
!                 &     p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,ptg_i,freq_ix(f_i)) ) * &
!                 & abs(sin(theta_e(ptg_i)))
!             end do
!             ! The phase function is symmetric in theta, but the radiances
!             ! are not.  Unfold p_t_iwc to negative theta.
!             p_on_theta_e(1:size(p_t_iwc)) = p_t_iwc(size(p_t_iwc):1:-1)
!             p_on_theta_e(size(p_t_iwc)+1:2*size(p_t_iwc)+1-beg_pos_theta) = &
!               & p_t_iwc(beg_pos_theta:)
!             ! Now interpolate P_On_Theta_e to P_On_Xi using a periodic spline
!             call interpolateValues ( coeffs_Theta_e_Xi, &
!               & theta_e(:n_theta_e), p_on_theta_e(:n_theta_e), &
!               & xis(sort_xi(:i_r)), p_on_xi(:i_r), method='S', extrapolate='P' )
d3042 10
d3061 20
a3080 8
            if ( atmos_der ) k_atmos_p =  &
              & 0.25 * ( p_on_xi(i_r)*k_atmos_TScat(f_i,sort_xi(i_r),:) + &
              &          p_on_xi(  1  )*k_atmos_TScat(f_i,sort_xi(  1  ),:) ) * &
              &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
            if ( temp_der ) k_temp_p =  &
              & 0.25 * ( p_on_xi(i_r)*k_temp_TScat(f_i,sort_xi(i_r),:) + &
              &          p_on_xi(  1  )*k_temp_TScat(f_i,sort_xi(  1  ),:) ) * &
              &        ( xis(sort_xi(  1)) + pix2 - xis(sort_xi(i_r)) )
d3086 20
a3105 8
              if ( atmos_der ) k_atmos_p = k_atmos_p + &
                & 0.25 * ( p_on_xi(ptg_i-1)*k_atmos_TScat(f_i,sort_xi(ptg_i-1),:) + &
                &          p_on_xi(ptg_i  )*k_atmos_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
              if ( temp_der ) k_temp_p = k_temp_p + &
                & 0.25 * ( p_on_xi(ptg_i-1)*k_temp_TScat(f_i,sort_xi(ptg_i-1),:) + &
                &          p_on_xi(ptg_i  )*k_temp_TScat(f_i,sort_xi(ptg_i  ),:) ) * &
                &        ( xis(sort_xi(ptg_i)) - xis(sort_xi(ptg_i-1)) )
d3934 1
a3934 1
      &                             K_Temp_TScat, I_R, &
a3939 1
      use Read_Mie_m, only: F_s, IWC_s, T_s, Theta_s, P
d3957 2
a3958 1
      integer, intent(inout) :: I_R         ! Update if OK
d3966 1
a3966 1
      integer :: Scat_Index   ! In coarse grid, used by one_pointing
d3971 1
a3971 1
        &                 scat_ht=scat_ht, xi=xi, scat_index=scat_index,   &
d3974 1
a3974 1
      if ( scat_index <= 1 ) return ! No ray to trace
d3977 1
d3988 1
a3988 1
      use Read_Mie_m, only: P
d3992 3
a3994 2
      if ( .not. associated(p) ) call announce_error ( &
        & "TScat computation needs the Mie phase function." )
a4004 2
      if ( .not. associated(F_s) .or. .not. associated(dP_dT) ) &
        & call announce_error ( 'TScat table computation requires Mie tables.' )
d4146 1
a4146 1
       "$Id: FullForwardModel_m.f90,v 2.298 2009/12/15 03:30:04 vsnyder Exp $"
d4156 10
@


2.298
log
@TScat radiance calculation working again -- P interpreted to xi instead
of radiance interpolated to theta.
Exchange order of subscripts of "radiances" to be consistent with k_...
and to get better locality in frequency loop
@
text
@d49 1
a49 1
      & L_PHITAN, L_PTAN, L_TEMPERATURE, L_TSCAT
d54 1
d74 1
d103 1
d105 1
a105 1
    integer :: S_T  ! Multiplier for temp derivative sizes, 0 or 1
d170 1
d172 10
a181 4
      call load_one_item_grid ( grids_iwc, &
        & GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_cloudIce, noError=.true., config=fwdModelConf ), &
        & phitan, fmStat%maf, fwdModelConf, .false., .false. )
d216 1
d228 1
d230 1
a230 1
    s_t = merge(1,0,temp_der)
d242 1
d273 1
a281 1
    use Add_Points_m, only: Add_Points
a282 1
    use AntennaPatterns_m, only: ANTENNAPATTERNS
a289 1
    use D_T_SCRIPT_DTNP_M, only: DT_SCRIPT_DT
d297 4
a300 14
    use Freq_Avg_m, only: Freq_Avg, Freq_Avg_DACS
    use Geometry, only: Earth_Axis_Ratio_Squared_m1, EarthRadA, Get_R_Eq, &
      & MaxRefraction
    use Get_Eta_Matrix_m, only: Select_NZ_List
    use Get_Chi_Angles_m, only: Get_Chi_Angles
    use GLnp, only: GW, GX, NG, NGP1
    use Intrinsic, only: L_A, L_BOUNDARYPRESSURE, L_CLEAR, &
      & L_EARTHREFL, L_ECRtoFOV, &
      & L_ELEVOFFSET, L_GPH, L_IWC, L_LogIWC, &
      & L_LOSVEL, L_LIMBSIDEBANDFRACTION, &
      & L_ORBITINCLINATION, L_RADIANCE, L_REFGPH, L_ScatteringAngle, &
      & L_SCGEOCALT, L_SPACERADIANCE, L_SurfaceHeight, L_TScat, L_VMR
    use Load_Sps_Data_m, only: DestroyGrids_t, Dump, Grids_T, &
      & Load_One_Item_Grid
a301 3
    use Metrics_m, only: More_Metrics, More_Points, Height_Metrics, &
      & Tangent_Metrics
    use Min_Zeta_m, only: Get_Min_Zeta
d307 1
a307 1
    use Molecules, only: L_H2O, L_N2O, L_O3
d310 1
a310 2
    use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction
    use Physics, only: H_OVER_K, SpeedOfLight
d316 1
a316 3
    use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR
    use SLABS_SW_M, only: ALLOCATESLABS, DESTROYCOMPLETESLABS, &
      & GET_GL_SLABS_ARRAYS, SLABS_STRUCT
d318 1
a318 1
    use Tau_M, only: Destroy_Tau, Dump, Get_Tau, Tau_T
d375 1
d390 1
d524 2
d739 1
a739 1
    type (VectorValue_T), pointer :: IWC           ! IWC field, for TScat gen.
d844 14
d1076 4
d1204 1
d1263 2
d1563 1
a1563 1
      use Freq_Avg_m, only: Freq_Avg
d1652 2
d1812 1
d1817 2
d1822 1
d1826 1
d1908 4
a1911 3
          call get_beta_path_PFA ( frq, frq_i, z_path, c_inds, t_path_c,  &
            & beta_group, sx, vel_rel, beta_path_c, t_der_path_flags,     &
            & dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c, dbeta_dv_path_c )
d2144 4
a2147 3
          call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds, t_path_f(:ngl),   &
            & beta_group, sx, vel_rel, beta_path_f(:ngl,:), t_der_path_flags,     &
            & dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f, dbeta_dv_path_f )
d2287 5
a2291 6
            &  beta_path_c, eta_fzp, sps_path, do_calc_fzp,       &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path, &
            &  inc_rad_path_slice, i_start, tan_pt_c, i_stop,     &
            &  size(d_delta_df,1), d_delta_df, nz_d_delta_df,     &
            &  nnz_d_delta_df, k_atmos_frq(frq_i,:) )
!            &  d_delta_df(1:npc,:), k_atmos_frq(frq_i,:) )
d2602 1
d2605 3
a2607 1
      use MLSNumerics, only: InterpolateValues
d2621 1
a2621 1
      real(rp) :: P_T_IWC_F(size(theta_s)) ! P interpolated to T, IWC
d2623 5
d2630 4
d2657 1
d2674 1
d2684 2
a2685 1
      type (QtyStuff_T) :: Qtys(noUsedChannels)
d2704 1
a2704 1
        qtys(f_i)%qty => GetQuantityForForwardModel ( &
d2708 1
a2708 1
        qtys(f_i)%qty%values = 0.0
d2728 1
a2728 1
      TScat => qtys(1)%qty
d2755 1
a2755 1
            & 'Scattering point Zeta ! & to be in Zeta grid' )
d2762 3
d2834 2
a2835 1
              &                       xis, rads, i_r, rev=.true. )
d2841 2
a2842 1
              &                       xis, rads, i_r, rev=.false. )
d2849 2
a2850 1
              &                       xis, rads, i_r, rev=.false. )
d2856 2
a2857 1
              &                       xis, rads, i_r, rev=.true. )
d2916 2
a2917 1
              &                       xis, rads, i_r, scat_tan_ht, forward )
d2923 2
a2924 1
              &                       xis, rads, i_r, scat_tan_ht, forward )
d2955 3
a2957 3
          ! IWC_s(iwc_ix) <= iwc%values(zeta_i,phi_i) < IWC_s(iwc_ix+1_).
          call hunt ( IWC_s, iwc%values(zeta_i,phi_i), iwc_ix )
          if ( iwc%values(zeta_i,phi_i) < IWC_s(1) ) then
d2959 1
a2959 1
          else if ( iwc%values(zeta_i,phi_i) > IWC_s(size(IWC_s)) ) then
d2962 1
a2962 1
            eta_iwc(1) = (iwc%values(zeta_i,phi_i) - iwc_s(iwc_ix)) / &
d3029 2
d3032 4
a3035 1
            TScat => qtys(f_i)%qty
d3038 41
a3078 22
            ! Interpolate P to scattering point IWC and temperature and
            ! multiply that by sin(theta)
            do ptg_i = 1, size(theta_s)
              p_t_iwc_f(ptg_i) = &
                & sum(eta_t_iwc * &
                &     p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,ptg_i,freq_ix(f_i)) ) * &
                & abs(sin(theta_e(ptg_i)))
            end do
            ! The phase function is symmetric in theta, but the radiances
            ! are not.  Unfold p_t_iwc_f to negative theta.
            p_on_theta_e(1:size(theta_s)) = p_t_iwc_f(size(theta_s):1:-1)
            p_on_theta_e(size(theta_s)+1:2*size(theta_s)+1-beg_pos_theta) = &
              & p_t_iwc_f(beg_pos_theta:)
            ! Now interpolate P_On_Theta_e to P_On_Xi using a periodic spline
            call interpolateValues ( theta_e(:n_theta_e), p_on_theta_e(:n_theta_e), &
              & xis(sort_xi(:i_r)), p_on_xi(:i_r), method='S', extrapolate='P' )

            TScat%values(surf_i,phi_i) = 0.0
            do ptg_i = 2, i_r
              ! Trapezoidal quadrature, without assuming equal abscissa spacing
              ! and the factor of 0.5 in Equation 4.50 in the 4 June 2004
              ! cloud forward model ATBD
d3083 8
d3092 3
a3094 2
            ! It isn't necessary to divide by \int p(\theta) \sin\theta d\theta
            ! because that normalization was done when the P tables were
d3096 8
d3105 1
d3112 1
a3112 1
          call dump ( qtys(f_i)%qty%values, name = 'TScat' )
d3148 42
d3195 1
d3197 9
d3918 2
a3919 1
      &                             Zeta_i, Phi_i, Xis, Rads, I_R, &
d3941 2
d3964 2
d3971 1
d3991 2
a3992 2
      iwc => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_LogIWC, config=fwdModelConf ) ! Log10(IWC)
d4022 1
a4022 1
      ! Make sure IWC and temperature have same grids as TScat
d4131 1
a4131 1
       "$Id: FullForwardModel_m.f90,v 2.297 2009/11/17 23:45:32 vsnyder Exp $"
d4141 6
@


2.297
log
@Add R_eq, R_sc arguments to FOV_Convolve_Setup, incomplete TScat stuff
@
text
@d557 1
a557 1
    real(rp) :: RADIANCES(no_tan_hts,noUsedChannels) ! (Nptg,noChans)
d1369 1
a1369 1
              & radiances(:,i), thisFraction, update, ptan, thisRadiance, &
d1373 1
a1373 1
              & radiances(:,i), rad_fft, thisFraction, update, thisRadiance, &
d1379 1
a1379 1
              & radiances(:,i), thisFraction, update, ptan, thisRadiance, &
d1416 1
a1416 1
            & radiances(:,i), thisFraction, update, ptan, tan_chi_out-thisElev, &
d1584 1
a1584 1
        radiances(ptg_i,:) = radV(:noFreqs)
d1599 1
a1599 1
              &   radV(:noFreqs), radiances(ptg_i,c) )
d1601 1
a1601 1
            radiances(ptg_i,c) = DACsStaging(channels(c)%used,channels(c)%dacs)
d1611 1
a1611 1
            radiances(ptg_i,c) = radV(c) ! Computed in Frequency_Loop
d1613 1
a1613 1
            radiances(ptg_i,c) = DACsStaging(channels(c)%used,channels(c)%dacs)
d2576 1
a2576 3
      use MLSNumerics, only: Coefficients => Coefficients_R8, & ! R8 == RP
        & InterpolateArraySetup, InterpolateArrayTeardown, &
        & InterpolateValues
d2587 6
a2592 6
      real(rp) :: Rads(4*nlvl+2*scatteringAngles%template%noSurfs,noUsedChannels)
      real(rp) :: Theta_e(2*size(theta_s)-merge(1,0,theta_s(1)==0.0)) ! Extended to -theta_s
      real(rp) :: P_On_Theta(size(theta_e)) ! P * sin(abs(theta)) interpolated
                               ! to scattering point IWC and T for each theta,
                               ! intermediary to getting P_On_Xi
      real(rp) :: P_On_Xi(size(rads,1)) ! P * sin(abs(theta)) interpolated
a2593 3
      real(rp) :: P_Rad(size(theta_e)) ! P interpolated to scattering point
                               ! IWC and T * Rads_On_Theta
      real(rp) :: Rads_On_Theta_e(size(theta_e), noUsedChannels) ! Rads on Theta_e
d2603 1
d2609 1
a2609 1
      real(rp) :: Xis(size(rads,1))
a2614 1
      type(coefficients) :: Xi_Coeffs   ! From Xi's to phase function's thetas
d2616 1
d2626 1
a2626 1
      integer :: I_R           ! Index in Rad, Xis
d2628 2
d2849 5
d2884 1
a2884 1
                call output ( rads(ptg_i,f_i), format="(f9.3)" )
d2896 1
a2896 1
                  & rad2deg*xis(ptg_i), rads(ptg_i,f_i), trim(sig)
d2935 10
a2944 1
          theta_e(size(theta_e)-size(theta_s)+1:) = theta_s
a2948 10
          ! Interpolate the radiances from Xis to the angular basis for the
          ! phase function (Theta_e) using a spline.

          call interpolateArraySetup ( xis(sort_xi(:i_r)), theta_e, &
            & method='S', coeffs=xi_coeffs, extrapolate='A' )

          call interpolateValues ( xi_coeffs, &
            & xis(sort_xi(:i_r)), rads(sort_xi(:i_r),:), &
            & theta_e, rads_on_theta_e(:,:), method='S', extrapolate='A' )

d2981 2
a2982 2
            ! The phase function is symmetric in theta, but the radiances
            ! are not.  First do the ones for negative theta.
d2984 1
a2984 3
              ! theta_e(ptg_i) == -theta_s(size(theta_s)-ptg_i+1) here
              p_on_theta(ptg_i) = &
                ! dot_product(eta_t,matmul(p(...),eta_iwc))
d2989 9
a2997 14
            ! Now the ones for positive theta.
            do ptg_j = size(theta_e)-size(theta_s)+1, size(theta_e)
              ! theta_e(ptg_j) == theta_s(size(theta_e)-size(theta_s)+ptg_j)
              ptg_i = size(theta_e) - ptg_j + 1
              p_on_theta(ptg_j) = &
                ! dot_product(eta_t,matmul(p(...),eta_iwc))
                & sum(eta_t_iwc * &
                &     p(t_ix+0:t_ix+1,iwc_ix+0:iwc_ix+1,ptg_i,freq_ix(f_i)) ) * &
                & abs(sin(theta_e(ptg_j)))
            end do
            ! Now interpolate P_On_Theta to P_On_Xi.  Ideally, this would
            ! be done with a periodic spline, but we don't have that yet, so
            ! just use linear interpolation.
            
d2999 1
a2999 1
            do ptg_i = 2, size(theta_e)
d3004 3
a3006 2
                & 0.25 * ( p_rad(ptg_i-1) + p_rad(ptg_i) ) *             &
                &        ( theta_e(ptg_i) - theta_e(ptg_i-1) )
d3008 3
a3010 3
            ! It isn't necessary to divide TScat%values(surf_i,phi_i) by
            ! \int p(\theta) \sin\theta d\theta because that normalization
            ! was done when the tables were constructed.
a3015 2
      call interpolateArrayTeardown ( xi_coeffs )

d3793 1
a3793 1
      real(rp), intent(inout) :: Rads(:,:)  ! Store radiance in Rads(I_R,:)
d3814 1
a3814 1
      rads(i_r,1:noUsedChannels) = radiances(ptg_i,1:noUsedChannels)
d3979 1
a3979 1
       "$Id: FullForwardModel_m.f90,v 2.296 2009/09/25 02:45:06 vsnyder Exp $"
d3989 3
@


2.296
log
@TScat computation appears to be working
@
text
@d293 1
a293 1
      & L_CLOUDICE, L_EARTHREFL, L_ECRtoFOV, &
d1363 2
d2591 5
d2983 1
a2983 1
              p_rad(ptg_i) = &
d2987 1
a2987 2
                & abs(sin(theta_e(ptg_i))) * &
                & rads_on_theta_e(ptg_i,f_i)
d2990 1
a2990 1
            do ptg_j = size(theta_e)-size(theta_s), size(theta_e)
d2993 1
a2993 1
              p_rad(ptg_j) = &
d2997 1
a2997 2
                & abs(sin(theta_e(ptg_j))) * &
                & rads_on_theta_e(ptg_j,f_i)
d2999 4
d3985 1
a3985 1
       "$Id: FullForwardModel_m.f90,v 2.295 2009/06/23 18:26:10 pwagner Exp $"
d3995 3
@


2.295
log
@Prevent Intel from optimizing ident string away
@
text
@d294 1
a294 1
      & L_ELEVOFFSET, L_GPH, L_IWC, &
d433 1
d777 1
d2574 3
d2578 3
a2580 1
      use output_m, only: NewLine
d2588 4
d2609 7
a2615 7
      real(rp) :: Eta_IWC(size(IWC_s))  ! for current IWC
      real(rp) :: Eta_T(size(T_s))      ! for current temperature
      real(rp) :: Eta_Xi(size(Theta_s)) ! for current pointing

      integer :: IWC_1, IWC_n ! Which eta_IWC are nonzero
      integer :: T_1, T_n     ! Which eta_T are nonzero
      integer :: Xi_1, Xi_n   ! Which eta_xi are nonzero
d2621 1
a2624 1
      integer :: Phases(noUsedChannels) ! Indices for phase tables
d2628 3
d2660 1
d2668 3
a2670 3
        phases(f_i) = minloc(abs(channelCenters(f_i)-f_s),1)
        if ( abs(channelCenters(f_i)-f_s(phases(f_i))) > fwdModelConf%phaseFrqTol ) then
          call output ( phases(f_i), before="phases(f_i) = ", after=", " )
d2680 1
a2680 4
      TScat => GetQuantityForForwardModel ( &
          & fwdModelOut, quantityType=l_TScat, &
          & signal=fwdModelConf%signals(channels(1)%signal)%index, &
          & sideband=sideband )
d2843 1
a2843 2
            if ( scat_tan_phi > pix2 ) scat_tan_phi = scat_tan_phi - pix2
            if ( scat_tan_phi < -pix2 ) scat_tan_phi = scat_tan_phi + pix2
d2868 1
a2868 1
            ! ptg_i, ptg_j and sig are just conveniently otherwise unused variables here
d2873 3
a2875 3
              do ptg_j = 1, noUsedChannels
                call output ( rads(ptg_i,ptg_j), format="(f9.3)" )
              end do ! ptg_j
a2876 9
              if ( switch42 ) then
                do ptg_j = 1, noUsedChannels
                  call GetNameOfSignal ( fwdModelConf%signals(channels(ptg_j)%signal), &
                    & sig, channel=channels(ptg_j)%used, sideband=thisSideband )
                  write ( 42, "(f7.2,f9.2,f12.4,f8.3,f11.2,f9.3,2x,a)" ) &
                    & rad2deg*phi_ref, rad2deg*scat_phi, scat_ht, scat_zeta, &
                    & rad2deg*xis(ptg_i), rads(ptg_i,ptg_j), trim(sig)
                end do
              end if
d2879 38
d2918 2
a2919 5
          ! Get interpolating factors for scattering-point IWC.
          call get_eta_sparse ( IWC_s, iwc%values(zeta_i,phi_i), &
            & eta_IWC, IWC_1, IWC_n )
          ! Get interpolating factors for scattering-point temperature.
          call get_eta_sparse ( T_s, temp%values(zeta_i,phi_i), eta_T, T_1, T_n )
d2921 86
a3006 2
          ! Interpolate the radiances from the Xis to the angular basis
          ! for the phase function and convolve the phase function with them.
d3011 8
d3078 1
a3078 1
                                                    ! and generateTScat
d3228 1
a3228 1
            call dump ( z_coarse, name="Z_Coarse" )
d3837 1
a3837 1
        & quantityType=l_iwc, config=fwdModelConf )
d3976 1
a3976 1
       "$Id: read_apriori.f90 is it here $"
d3986 3
@


2.294
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d3844 2
a3845 2
  logical function NOT_USED_HERE()
!------------------------------ RCS Ident Info -------------------------------
d3847 2
a3848 3
    & "$Id: FullForwardModel_m.f90,v 2.293 2009/06/13 01:15:03 vsnyder Exp $"
  character (len=len(idParm)) :: Id = IdParm
!------------------------------------------------------------------------------
d3850 3
a3852 2
    print *, not_used_here ! .mod files sometimes change if PRINT is added
  end function NOT_USED_HERE
d3857 3
@


2.293
log
@Intermediate commit of extensive changes for TScat calculation
@
text
@d429 2
a430 1
    logical :: Clean              ! Used for dumping
d768 2
a769 1
    clean = index(switches, 'clean') /= 0
d2230 1
a2230 1
            call dump ( incoptdepth_pol(:,:,-p_stop), clean=.true. )
d3392 4
a3395 4
          call dump ( h, 'H', clean=clean )
          call dump ( ct, 'Cos(theta)', clean=clean )
          call dump ( stcp, 'Sin(theta) Cos(phi)', clean=clean )
          call dump ( stsp, 'Sin(theta) Sin(phi)', clean=clean )
d3847 1
a3847 1
    & "$Id: FullForwardModel_m.f90,v 2.292 2009/05/14 00:46:02 pwagner Exp $"
d3857 3
@


2.292
log
@Gets Deg2Rad from Constants now
@
text
@d49 1
a49 1
      & L_PHITAN, L_PTAN, L_TEMPERATURE
a94 1
    integer :: S_T  ! Multiplier for temp derivative sizes, 0 or 1
d96 1
d99 2
d102 1
a102 3
    integer :: S_P  ! Multiplier for polarized sizes, 0 or 1
    integer :: S_PFA ! Multiplier for PFA sizes, 0 or 1
    integer :: S_I  ! Multiplier for ice/cloud sizes, 0 or 1
d179 7
a185 5
      ! Make sure the observer zeta is in the preselected grid.
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, &
        &                   no_tan_hts, surfaceTangentIndex, z_psig, tan_press, &
        &                   GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        &                     quantityType=l_cloudIce, config=fwdModelConf ) )
d187 2
a188 2
      call compute_Z_PSIG ( fwdModelConf, temp, nlvl, &
        &                   no_tan_hts, surfaceTangentIndex, z_psig, tan_press )
d205 1
a205 1
      call dump ( grids_f )
a210 1
    s_t = merge(1,0,temp_der)
d212 1
d215 2
d218 1
a218 3
    s_p = merge(1,0,FwdModelConf%polarized)
    s_pfa = merge(1,0,FwdModelConf%anyPFA(1) .or. FwdModelConf%anyPFA(2))
    s_i = merge(1,0,FwdModelConf%incl_cld)
d223 2
a224 1
                              & grids_n, grids_v, grids_w, ptan, phitan, temp, &
d241 1
d276 1
a276 1
    use Constants, only: Deg2Rad
d287 2
a288 1
    use Geometry, only: Earth_Axis_Ratio_Squared_m1, EarthRadA, MaxRefraction
d293 2
a294 2
      & L_CLOUDICE, L_CLOUDTEMPERATURE, L_EARTHREFL, L_ECRtoFOV, &
      & L_ELEVOFFSET, L_GPH, &
d314 1
a314 1
    use PointingGrid_m, only: POINTINGGRIDS
d410 1
a410 1
    integer :: NZ_IG              ! Effective size of Z_IG, size(z_psig) <=
d417 2
a418 2
    integer :: TAN_IND_C          ! Index of tangent point in coarse zeta grid
    integer :: TAN_IND_F          ! Index of tangent point in fine grid
a421 1
    integer :: WHICHPOINTINGGRID  ! Index into the pointing grids
d434 11
a444 7
    logical :: Print_Mag          ! For debugging
    logical :: Print_More_Points  ! Print if Do_More_Points finds more
    logical :: Print_Ptg          ! For debugging
    logical :: Print_Rad          ! For debugging
    logical :: Print_Seez         ! For debugging
    logical :: Print_TauL         ! For debugging
    logical :: Print_TauP         ! For debugging
d454 1
a454 1
    integer :: GRIDS(no_tan_hts)  ! Heights in ptgGrid for each tangent
d462 9
a470 6
    logical, pointer :: DO_CALC_Tscat(:,:)    ! 'Avoid zeros' indicator
    logical, pointer :: DO_CALC_Salb(:,:)     ! 'Avoid zeros' indicator
    logical, pointer :: DO_CALC_cext(:,:)     ! 'Avoid zeros' indicator
    logical, pointer :: DO_CALC_Tscat_ZP(:,:) ! 'Avoid zeros' indicator
    logical, pointer :: DO_CALC_Salb_ZP(:,:)  ! 'Avoid zeros' indicator
    logical, pointer :: DO_CALC_Cext_ZP(:,:)  ! 'Avoid zeros' indicator
d475 2
a476 2
    real(rp) :: ALPHA_PATH_C(max_c)   ! coarse grid abs coeff.
    real(rp) :: ALPHA_PATH_F(max_f)   ! fine grid abs coeff.
d512 1
a512 1
    real(rp) :: Z_COARSE(max_c)       ! Z_PSIG & Z_min & surface zeta
a514 1
    real(rp) :: Z_IG(size(Z_PSIG)+2)  ! Z_PSIG + min Zeta + Earth intersection
d540 1
a540 1
    real(rp) :: ETA_IWC_ZP(max_f,grids_iwc%p_len)
d630 1
a630 1
    logical :: DO_CALC_ZP(size(eta_zp,1),size(eta_zp,2))
d652 2
a653 1
    real(rp) :: H_Surf        ! Height at surface above reference (zeta=-3)
a656 1
    real(rp) :: R_EQ          ! Equivalent Earth Radius
a657 2
    real(rp) :: TAN_HT        ! Height at the tangent, from equivalent Earth center
    real(rp) :: TAN_HT_R      ! Tan_Ht - R_eq
a672 1
    real(rp), pointer :: Cext_PATH(:,:)  ! Cloud extinction on path
d683 11
a694 6
    real(rp), pointer :: ETA_Tscat(:,:)    !
    real(rp), pointer :: ETA_Tscat_ZP(:,:) !
    real(rp), pointer :: ETA_Salb(:,:)     !
    real(rp), pointer :: ETA_Salb_ZP(:,:)  !
    real(rp), pointer :: ETA_Cext(:,:)     !
    real(rp), pointer :: ETA_Cext_ZP(:,:)  !
a700 1
    real(rp), pointer :: Salb_PATH(:,:)    ! Single Scattering Albedo on path
a701 1
    real(rp), pointer :: Tscat_PATH(:,:)   ! TScat on path
d707 1
a707 1
    real(rp) :: DXDT_TAN(ptan%template%nosurfs,sv_t_len)
d713 19
a731 2
    real(rp) :: earthradc ! minor axis of orbit plane projected Earth ellipse
    real(rp) :: earthradc_sq ! earthradc**2
a733 2
    type (VectorValue_T), pointer :: CloudIce      ! IWC on cloud grid
    type (VectorValue_T), pointer :: CloudTemp     ! Temperature on cloud grid
d738 1
a748 8
    type (Signal_T), pointer :: FIRSTSIGNAL        ! The first signal we're dealing with

    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS ! Freq. indep. stuff

    type (Grids_T) :: Grids_Tscat ! All the coordinates for scaterring source function
    type (Grids_T) :: Grids_Salb ! All the coordinates for single scaterring albedo
    type (Grids_T) :: Grids_Cext ! All the coordinates for cloud extinction

a753 8
! *** Beta & Molecules grouping variables:
    type(beta_group_t), pointer :: Beta_Group(:) ! from FwdModelConf%Beta_Group

    type(tau_t) :: Tau_LBL, Tau_PFA

! Channel information from the signals database as specified by fwdModelConf
    type(channels_T), pointer, dimension(:) :: Channels 

d774 1
d776 2
a777 1
    print_Ptg = index(switches,'ptg') /= 0
d782 4
d794 2
a795 8
    nullify ( cext_path, eta_cext_zp, eta_salb_zp, eta_tscat_zp,       &
      & frequencies, inc_rad_path, k_atmos_frq, k_spect_dn_frq,        &
      & k_spect_dv_frq, k_spect_dw_frq, k_temp_frq, RadV, salb_path,   &
      & tscat_path, t_script_lbl )

    nullify ( do_calc_Cext, do_calc_Cext_zp, do_calc_Salb, &
      &       do_calc_Salb_zp, do_calc_tscat, do_calc_tscat_zp, &
      &       eta_cext, eta_salb, eta_tscat )
d898 1
a898 1
      call frequency_setup_1
d904 2
a905 1
      do ptg_i = 1, no_tan_hts
d907 1
a907 1
        Vel_Rel = est_los_vel(ptg_i) / speedOfLight
d909 2
a910 2
        ! If we're doing frequency averaging, get the frequencies we need for
        ! this pointing.
d912 3
a914 3
        if ( FwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) &
          & call frequency_setup_2 ( (1.0_rp - Vel_Rel) * &
          & PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies )
d916 3
a918 2
        call one_pointing ( vel_rel, tan_phi(ptg_i), &
          &                 tan_press(ptg_i), est_scGeocAlt(ptg_i) )
d920 5
a924 4
      end do ! ptg_i

      ! Do ray tracing at specified scattering angles?
      if ( FwdModelConf%generateTScat ) call generate_TScat
d929 1
a929 1
      call convolution ! or interpolation to ptan
d1001 9
a1009 3
        thisRadiance =>  &
          GetQuantityForForwardModel (fwdModelOut, quantityType=l_radiance, &
          & signal=fwdModelConf%signals(channels(i)%signal)%index, sideband=sideband )
d1122 10
a1131 8
      ! Check that we have radiances for the channels that are used
      do sigInd = 1, size(fwdModelConf%signals)
        ! This just emits an error message and stops if we don't have a radiance.
        ! We don't use the vector quantity -- at least not right away.  We get
        ! it again later.
        thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
          & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband )
      end do
d1168 2
a1169 1
  !         \frac{a^2}{\left(\frac{a^2}{b^2}-1\right) \sin^2 \beta + 1}$
d1172 2
a1173 3
            &     (Earth_Axis_Ratio_Squared_m1 * &
                   &   SIN(orbIncline%values(1,maf)*Deg2Rad)**2 + 1)
      earthradc = sqrt(earthradc_sq)
d1462 2
a1463 2
      real(rp) :: D2XDXDT_SURFACE(1,sv_t_len) ! Would s_t*sv_t_len work?
      real(rp) :: D2XDXDT_TAN(ptan%template%nosurfs,sv_t_len) ! Would s_t*sv_t_len work?
d1472 6
a1477 12
      !{ Compute equivalent earth radius (\tt r\_eq})
      ! \begin{equation*}\begin{split}
      ! R_{eq} =\;& \sqrt \frac{R_a^4 \sin^2 \phi + R_c^4 \cos^2 \phi}
      !                       {R_a^2 \cos^2 \phi + R_c^2 \sin^2 \phi}\\
      !        =\;& \sqrt \frac{R_a^4 - (R_a^2+R_c^2)(R_a^2-R_c^2) \cos^2 \phi}
      !                       {R_c^2 +              (R_a^2-R_c^2) \cos^2 \phi}
      ! \end{split}\end{equation*}
      !
      ! Although this is the same mathematical formula as used in {\tt metrics},
      ! the $\phi$ used here is different: These are on MIFs, not hypothetical
      ! pointings to the desired tangent $\zeta$s.  Therefore, we can't use
      ! these values in {\tt metrics}, or where its output {\tt r\_eq} value is
d1480 1
a1480 6
      req_out = (earthrada-earthradc)*(earthrada+earthradc) * &
        & COS(phitan%values(:,maf)*Deg2Rad)**2
      ! Earthrad[abc] are in meters, but Req_Out needs to be in km.
      req_out = 0.001_rp * SQRT( &
        & ( earthrada**4 -(earthrada**2+earthradc_sq) * req_out ) / &
        & ( earthradc_sq + req_out ) )
d1532 1
a1532 1
    subroutine Frequency_Average
d1540 2
d1590 4
a1593 4
              call freq_Avg ( frequencies, &
                &   filterShapes(shapeInd)%filterGrid,  &
                &   filterShapes(shapeInd)%filterShape, &
                &   radV(:noFreqs), radiances(ptg_i,c) )
d1614 1
a1614 1
      if ( any_der ) call frequency_average_derivatives ( frq_avg_sel == 15 )
d1698 2
a1699 1
    subroutine Frequency_Average_Derivatives ( Combine )
d1772 5
a1776 4
    subroutine Frequency_Loop ( Alpha_Path_c, Beta_Path_c, C_Inds, Del_S,    &
      & Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL,                            &
      & Frequencies, H_Path_C, IncOptDepth, P_Path, PFA, Ref_Corr, Sps_Path, &
      & Tau, T_Path_c, T_Script, Tanh1_c, TT_Path_c, W0_Path_c, Z_Path )
a1781 1

d1784 1
d1795 2
a1796 1
      real(rp), intent(out) :: Alpha_Path_c(:) ! Beta_Path * mixing ratio
d1806 2
d1821 1
d1827 1
a1827 1
      integer :: I_STOP                   ! Upper index for radiance comp.
d1884 4
a1887 4
          call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_c, tanh1_c,                &
            &  beta_group, sx, fwdModelConf%polarized, gl_slabs, c_inds,      &
            &  beta_path_c, t_der_path_flags, dTanh_dT_c, vel_rel,            &
            &  dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c,             &
d1908 1
a1908 1
               & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang)
a1916 11
          call allocate_test ( do_calc_tscat, npf, size(grids_tscat%values),           &
                             & 'do_calc_tscat', moduleName )
          call allocate_test ( do_calc_tscat_zp, npf, grids_tscat%p_len,               &
                             & 'do_calc_tscat_zp', moduleName )
          call allocate_test ( eta_tscat,     npf, size(grids_tscat%values),           &
                             & 'eta_tscat',     moduleName )
          call allocate_test ( eta_tscat_zp,  npf, grids_tscat%p_len,                  &
                             & 'eta_tscat_zp',  moduleName )
          call allocate_test ( tscat_path,    npf, fwdModelConf%num_scattering_angles, &
                               & 'tscat_path',  moduleName )

a1920 1
        ! Frq=0.0
d1922 1
a1922 1
            & 0.0_r8, eta_tscat_zp(1:npf,:),                   &
d1942 2
a1943 22
            do i = 1, size(grids_salb%values)
               if ( abs(grids_salb%values(i)) < TOL) then
                       grids_salb%values(i) = 0.0
               end if
               if ( abs(grids_cext%values(i)) < TOL) then
                       grids_cext%values(i) = 0.0
               end if
            end do

            call allocate_test (do_calc_salb, npf, size(grids_salb%values),'do_calc_salb',moduleName)
            call allocate_test (do_calc_salb_zp, npf, grids_salb%p_len,               &
                              & 'do_calc_salb_zp', moduleName )
            call allocate_test (eta_salb,    npf, size(grids_salb%values), 'eta_salb', moduleName)
            call allocate_test (eta_salb_zp, npf, grids_salb%p_len, 'eta_salb_zp', moduleName)
            call allocate_test ( salb_path,  npf, 1, 'salb_path', moduleName )

            call allocate_test (do_calc_cext,npf,size(grids_cext%values),'do_calc_cext',moduleName)
            call allocate_test (do_calc_cext_zp, npf, grids_cext%p_len,               &
                              & 'do_calc_cext_zp', moduleName )
            call allocate_test (eta_cext,    npf, size(grids_cext%values), 'eta_cext', moduleName)
            call allocate_test (eta_cext_zp, npf, grids_cext%p_len,  'eta_cext_zp', moduleName)
            call allocate_test (cext_path,   npf, 1, 'cext_path', moduleName)
a1948 1
          ! Frq=0.0
d1950 1
a1950 1
              & 0.0_r8, eta_salb_zp(1:npf,:),                  &
a1961 1
          ! Frq=0.0
d1963 1
a1963 1
              & 0.0_r8, eta_cext_zp(1:npf,:),                  &
d1973 1
a1973 1
                              & beta_path_cloud_c(1:npc), w0_path_c,           & 
d1976 1
a1976 1
          else ! Not cld_fine              re-compute cext and w0 along the LOS
d1978 1
a1985 18
          call deallocate_test ( do_calc_tscat,    'do_calc_tscat',    moduleName )
          call deallocate_test ( do_calc_tscat_zp, 'do_calc_tscat_zp', moduleName )
          call deallocate_test ( eta_tscat,        'eta_tscat',        moduleName )
          call deallocate_test ( eta_tscat_zp,     'eta_tscat_zp',     moduleName )           
          call deallocate_test ( tscat_path,       'tscat_path',       moduleName )

          call deallocate_test ( do_calc_salb,     'do_calc_salb',     moduleName )
          call deallocate_test ( do_calc_salb_zp,  'do_calc_salb_zp',  moduleName )
          call deallocate_test ( eta_salb,         'eta_salb',         moduleName )
          call deallocate_test ( eta_salb_zp,      'eta_salb_zp',      moduleName )
          call deallocate_test ( salb_path,        'salb_path',        moduleName )

          call deallocate_test ( do_calc_cext,     'do_calc_cext',     moduleName )
          call deallocate_test ( do_calc_cext_zp,  'do_calc_cext_zp',  moduleName )
          call deallocate_test ( eta_cext,         'eta_cext',         moduleName )
          call deallocate_test ( eta_cext_zp,      'eta_cext_zp',      moduleName )
          call deallocate_test ( cext_path,        'cext_path',        moduleName )

d2006 1
a2006 1
          do j = 1, npc ! Don't trust compilers to fuse loops
d2011 1
d2013 5
a2017 3
          ! Needed to compute inc_rad_path_slice and by rad_tran_pol
          call two_d_t_script ( t_path_c, &  
            & spaceRadiance%values(1,1), frq, t_script(:,frq_i), B(:npc) )
d2024 2
a2025 2
          call path_contrib ( incoptdepth, tan_pt_c, e_rflty, fwdModelConf%tolerance, &
            &                 do_gl )
d2027 2
a2028 1
        else ! extra stuff for polarized case
d2030 3
a2032 2
          call get_beta_path_polarized ( frq, firstSignal%lo, h, beta_group%lbl(sx), gl_slabs, &
            & c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )
d2089 1
a2089 1
        ! {\tt del_zeta}, to compensate for the GL weights summing to 2.0.
d2091 1
a2091 1
        do j = 2, tan_pt_c
d2096 1
a2096 1
        do j = tan_pt_c+1, npc-1
d2127 4
a2130 4
          call get_beta_path ( Frq, firstSignal%lo, p_path, t_path_f(:ngl), tanh1_f(1:ngl),    &
            & beta_group, sx, fwdModelConf%polarized, gl_slabs, gl_inds,       &
            & beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f, vel_rel,      &
            & dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f,               &
d2141 8
d2153 4
a2156 4
          call get_tau ( frq_i, gl_inds, cg_inds, e_rflty, del_zeta, &
            & alpha_path_c, ref_corr, incoptdepth, tan_pt_c,         &
            & alpha_path_f(1:ngl), dsdz_gw_path, tau )
            i_stop = tau%i_stop(frq_i)
d2162 1
a2162 1
            do j = 1, i_stop
a2165 1
            inc_rad_path_slice(i_stop+1:) = 0
d2172 1
a2172 1
            do j = 1, i_stop
d2178 15
a2192 1
        else ! Polarized model; can't combine with PFA
d2200 3
a2202 2
          call get_beta_path_polarized ( frq, firstSignal%lo, h, beta_group%lbl(sx), gl_slabs, &
            & gl_inds, beta_path_polarized_f, dBeta_dT_polarized_path_f )
d2229 3
a2231 3
            call output ( 'thisSideband = ' ); call output ( thisSideband )
            call output ( ', ptg_i = ' ); call output ( ptg_i )
            call output ( ', frq_i = ' ); call output ( frq_i, advance='true' )
d2254 1
a2254 1
            &  inc_rad_path_slice, tan_pt_c, i_stop,              &
a2257 1
          if ( FwdModelConf%anyPFA(sx) ) then
d2259 1
a2259 1
          else if ( fwdModelConf%polarized ) then
d2283 1
a2283 1
          end if ! PFA
d2285 1
a2285 1
        end if
d2289 4
d2318 3
a2320 2
              & inc_rad_path_slice, tan_pt_c, i_stop, grids_tmp%deriv_flags, &
              & pfa .and. frq_avg_sel == 15, k_temp_frq(frq_i,:) )
d2435 1
a2435 1
    subroutine Frequency_Setup_1
d2442 3
d2451 2
a2454 1
        whichPointingGrid = -1
d2461 1
a2461 1
            whichPointingGrid = i
d2464 1
a2464 1
        if ( whichPointingGrid < 0 ) call Announce_Error ( &
d2469 1
a2469 1
        call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
d2474 2
a2475 3
          k = Size(pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))% &
                 & frequencies)
          maxNoPtgFreqs = max ( maxNoPtgFreqs, k )
d2563 227
a2789 5
      integer :: phi_i, ptg_i, zeta_i ! Loop inductors and subscripts
      ! Loop over observer positions and scattering angles
      do phi_i = 1, cloudIce%template%noInstances
        do zeta_i = 1, cloudIce%template%noSurfs
          do ptg_i = 1, scatteringAngles%template%noSurfs
d2791 99
a2889 2
        end do ! zeta_i
      end do ! phi_i
d2921 10
a2930 5
    subroutine One_Pointing ( Vel_Rel, Tan_Phi, Tan_Press, Est_SCGeocAlt )

      real(rp), intent(in) :: Vel_Rel ! Vel_z / speedOfLight
      real(rp), intent(in) :: Tan_Phi ! orbit geodetic angle at tangent, radians
      real(rp), intent(in), optional  :: Tan_Press    ! hPa, not zeta
d2934 27
d2980 1
a2980 3
      ! Compute where the tangent is, the equivalent Earth radius, tangent
      ! height and surface height, and determine whether the ray
      ! intersects the Earth surface
d2982 2
d2985 19
d3005 4
a3008 5
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis, z_psig, &
          &                    h_glgrid, earthradc_sq,       & ! in
          &                    tan_ind_c, nz_ig,             & ! inout
          &                    r_eq, h_surf, tan_ht_r, z_ig, & ! output
          &                    surf_height=surfaceHeight%values(1,:) ) ! opt
d3010 5
a3014 5
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis, z_psig, &
          &                    h_glgrid, earthradc_sq,       & ! in
          &                    tan_ind_c, nz_ig,             & ! inout
          &                    r_eq, h_surf, tan_ht_r, z_ig, & ! output
          &                    Tan_Press=tan_press,          & ! optional
d3017 3
a3019 4
        call tangent_metrics ( tan_phi, Grids_tmp%phi_basis, z_psig, &
          &                    h_glgrid, earthradc_sq,        & ! in
          &                    tan_ind_c, nz_ig,              & ! inout
          &                    r_eq, h_surf, tan_ht_r, z_ig )   ! output
a3020 6
      nz_if = (nz_ig-1) * ngp1 + 1                ! On Z_GLgrid
      tan_ind_f = (tan_ind_c-1) * ngp1 + 1        ! On Z_GLgrid
      tan_pt_f = nz_if + 1 - tan_ind_f            ! fine path tangent index
      tan_pt_c = (tan_pt_f + Ng) / Ngp1           ! coarse path tangent index
      npc = 2 * tan_pt_c
      npf = 2 * tan_pt_f
d3022 14
a3035 3
      if ( nz_ig == nlvl ) then
        z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
        z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)
d3038 37
a3074 13
      if ( tan_ht_r < 0.0 ) then ! Handle Earth-intersecting ray
        e_rflty = earthRefl%values(1,1)
        if ( nz_ig > nlvl ) then ! Added a new zeta
          z_coarse(:tan_pt_c) = z_ig(nz_ig:tan_ind_c:-1)
          z_coarse(tan_pt_c+1:npc) = z_ig(tan_ind_c:nz_ig)
          ! Use the "revised" GL-grid arrays, which depend upon the new zeta.
          ddhidhidtl0 => ddhidhidtl0_r(:nz_if,:,:)
          dh_dt_glgrid => dh_dt_glgrid_r(:nz_if,:,:)
          dhdz_glgrid => dhdz_glgrid_r(:nz_if,:)
          h_glgrid => h_glgrid_r(:nz_if,:)
          t_glgrid => t_glgrid_r(:nz_if,:)
          z_glgrid => z_glgrid_r(:nz_if)
          call compute_GL_grid ( z_ig(:nz_ig), z_glgrid )
d3076 26
a3101 6
          if ( temp_der ) then
            call two_d_hydrostatic ( Grids_tmp, &
              &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
              &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
              &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
d3103 10
a3112 5
            call two_d_hydrostatic ( Grids_tmp, &
              &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
              &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
              &  dhdz_glgrid )
d3115 3
a3117 7
      end if

      ! Get H_Path and Phi_Path on the fine grid.
      if ( nz_ig > nlvl ) then ! Added a new zeta
        call Height_Metrics ( tan_phi, tan_ind_f, Grids_tmp%phi_basis, &
          &  h_glgrid, r_eq, h_surf, tan_ht_r, z_ig, &          ! in
          &  vert_inds(1:npf), h_path(1:npf), phi_path(1:npf) ) ! out
d3119 2
a3120 3
        call Height_Metrics ( tan_phi, tan_ind_f, Grids_tmp%phi_basis, &
          &  h_glgrid, r_eq, h_surf, tan_ht_r, z_psig, &        ! in
          &  vert_inds(1:npf), h_path(1:npf), phi_path(1:npf) ) ! out
a3122 2
      tan_ht = h_path(tan_pt_f) ! Includes Earth radius

d3124 25
a3148 21
      ! These can only happen if the minimum zeta isn't at the tangent.
      call more_points ( tan_phi, tan_ind_f, Grids_tmp%phi_basis,   &
        & z_glgrid, h_glgrid, r_eq, h_surf, tan_ht_r, phi_path(1:npf), & ! in
        & more_z_path, more_h_path, more_phi_path, n_more )
      if ( n_more > 0 .and. .not. do_more_points ) then
        if ( print_more_points ) then
          call output ( n_more, before='Want to add ', after=' more points', advance='yes' )
          call dump ( more_h_path(:n_more), name='more_h_path', format='(f14.7)' )
          call dump ( more_phi_path(:n_more), name='more_phi_path', format='(f14.8)' )
          call dump ( more_z_path(:n_more), name='more_z_path' )
          call output ( ptg_i, before='tan_phi(' )
          call output ( tan_phi, before=') = ', format='(f12.6)' )
          call output ( tan_ind_f, before=', tan_ind_f = ' )
          call output ( tan_pt_f, before=', tan_pt_f = ' )
          call output ( r_eq, before=', r_eq = ', format='(f12.6)', advance='yes' )
          call output ( h_surf, before='h_surf = ', format='(f12.6)' )
          call output ( tan_ht_r, before=', tan_ht_r = ', format='(f12.6)', advance='yes' )
          call dump ( Grids_tmp%phi_basis, name='phi_basis', format='(f14.8)' )
          call dump ( h_glgrid, name='h_glgrid', format='(f14.7)' )
          call dump ( h_path(1:npf), name='h_path', format='(f14.7)' )
          call dump ( phi_path(1:npf), name='phi_path', format='(f14.8)' )
a3149 2
        n_more = 0
      end if
d3151 28
a3178 13
      ! Get minimum zeta on the path
      call Get_Min_Zeta ( Grids_tmp%phi_basis, h_glgrid(tan_ind_f,:), &
                        & t_glgrid(tan_ind_f,:), z_glgrid(tan_ind_f), &
                        & phi_path, tan_ind_f, tan_ht,                &
                        & min_zeta, min_phi, min_index )

      ! Add minimum zeta to the path
      if ( min_index > 0 ) then ! minimum zeta not at or near tangent point
        if ( do_zmin ) then
          n_more = n_more + 1
          more_z_path(n_more) = min_zeta
          more_phi_path(n_more) = min_phi
          more_h_path(n_more) = tan_ht/cos(min_phi)
d3180 1
a3180 13
          if ( index(switches,'zdet') /= 0 ) then
            call output ( min_index, before='Want to add minimum zeta at ' )
            call output ( tan_ind_f, before=' (tan_ind_f = ' )
            call output ( min_phi, before=') where phi = ' )
            call output ( min_zeta, before=' and zeta = ', advance='yes' )
            call dump ( Grids_tmp%phi_basis, name='phi_basis' )
            call dump ( h_glgrid(tan_ind_f,:), 'h_glgrid' )
            call dump ( t_glgrid(tan_ind_f,:), 't_glgrid' )
            call dump ( phi_path, name='phi_path' )
            call output ( z_glgrid(tan_ind_f), before='z_glgrid = ' )
            call output ( tan_ind_f, before=', tan_ind_f =' )
            call output ( tan_ht, before=', tan_ht = ', advance='yes' )
          end if
a3181 3
      else
        min_index = 0
      end if
d3183 10
a3192 9
      call add_points ( more_h_path(:n_more), more_phi_path(:n_more),     &
        &               more_z_path(:n_more), min_index, z_glgrid, nz_if, &
        &               z_coarse, h_path, phi_path, vert_inds,            &
        &               npc, npf, tan_pt_c, tan_pt_f )

      if ( print_more_points .and. n_more > 0 ) then
        call dump ( Grids_tmp%phi_basis, name='phi_basis' )
        call dump ( h_path(1:npf), name='h_path' )
        call dump ( phi_path(1:npf), name='phi_path' )
a3200 8
      ! This is not pretty but we need some coarse path extraction indices
      c_inds => c_inds_b(:npc)
      c_inds = (/(i*Ngp1-Ng,i=1,tan_pt_c),((i-1)*Ngp1-Ng+1,i=tan_pt_c+1,npc)/)
      ! And some fine path extraction indices
      do_gl(1:npc:npc-1) = .false.; do_gl(2:npc-1) = .true.
      call get_gl_inds ( do_gl(:npc), tan_pt_c, f_inds, cg_inds_b, nglMax, ncg )
      cg_inds => cg_inds_b(:ncg) ! Should be the whole thing here; probably not used

a3258 1
        call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds, 1, nz_zxp_t_c, nnz_zxp_t_c )
a3280 2

    ! Frq = 0.0_r8
d3282 1
a3282 1
        & 0.0_r8, eta_zp(1:npf,:),                &
d3289 1
a3289 1
!         & 0.0_r8, eta_zp, nz_zp, nnz_zp,                           &
d3380 1
a3380 1
            mag_path(j,3) = 1.0_rp !arbitrarily, theta=0 for zero field
d3398 1
a3398 1
      if ( present(est_scGeocAlt) ) then
d3401 2
a3402 2
        ! computations into the convolution code because they need tan_ht_r
        ! and R_eq, which are both gotten from Tangent_Metrics.
d3404 1
a3404 1
          ! Ext_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
d3406 1
a3406 1
             & tan_ht_r, tan_phi, R_eq, 0.0_rp, ptg_angles(ptg_i),       &
d3410 1
a3410 1
             & tan_ht_r, tan_phi, R_eq, 0.0_rp, ptg_angles(ptg_i) )
d3414 1
a3414 1
      ! Compute refractive correction
d3578 3
a3580 3
        call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:), c_inds,  &
          & del_s(:npc), del_zeta(:npc),do_calc_fzp(:npf,:),                    &
          & do_calc_zp(:npf,:), do_GL(:npc), frequencies, h_path_c,             &
d3583 2
a3584 1
          & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
d3588 6
a3593 2
          call dump ( tau_lbl, noFreqs, ' Tau_LBL:' )
          call dump ( t_script_lbl(:npc,:noFreqs), 'T_Script_LBL' )
d3605 1
a3605 1
          call frequency_average_derivatives ( .false. )
d3607 3
a3609 3
        call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:), c_inds, &
          & del_s(:npc), del_zeta(:npc), do_calc_fzp(:npf,:),                  &
          & do_calc_zp(:npf,:), do_GL(:npc), channelCenters, h_path_c,         &
d3612 2
a3613 1
          & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
d3618 1
a3618 1
          call dump ( t_script_pfa(:npc,:), 'T_Script_PFA' )
d3623 1
a3623 1
      call frequency_average ! or maybe just store
d3635 48
d3686 10
d3698 4
a3701 2
      if ( FwdModelConf%do_conv ) call announce_error ( &
        & 'Convolution and TScat computation are incompatible.' )
d3704 38
a3741 12
      if ( .not. present(jacobian) ) &
        & call announce_error ( 'TScat table computation requires a Jacobian.' )
      cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_cloudIce, config=fwdModelConf )
      cloudTemp => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_cloudTemperature, config=fwdModelConf )
      if ( cloudIce%template%vGridIndex /= cloudTemp%template%vGridIndex .or. &
         & cloudIce%template%hGridIndex /= cloudTemp%template%hGridIndex ) &
           & call announce_error ( &
           & 'Cloud Ice and Temperature grids unequal for TScat computation.' )
      ! These are primarily for subsurface angles, which are messy to specify
      ! otherwise.
d3743 1
a3743 1
        & quantityType=l_scatteringAngle, config=fwdModelConf, noError=.true. )
d3790 2
a3791 2
    tan_phi(1:sub) = phitan%values(1,MAF)
    est_scgeocalt(1:sub) = scGeocAlt%values(1,maf)
d3809 1
a3809 1
    do i = 2, k ! Invariant: z_mif(1:i-1) are sorted.
d3845 1
a3845 1
    & "$Id: FullForwardModel_m.f90,v 2.291 2009/01/21 01:00:39 pwagner Exp $"
d3849 1
d3855 3
@


2.291
log
@Compatible with hastily committed select_nz_list
@
text
@d3259 1
a3259 1
    use Units, only: Deg2Rad
d3345 1
a3345 1
    & "$Id: FullForwardModel_m.f90,v 2.290 2008/10/03 16:27:14 livesey Exp $"
d3354 3
@


2.290
log
@Pushed down LO to support EXTINCTIONV2
@
text
@d2848 1
a2848 1
        call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds, nz_zxp_t_c, nnz_zxp_t_c )
d3345 1
a3345 1
    & "$Id: FullForwardModel_m.f90,v 2.289 2008/06/26 00:28:03 vsnyder Exp $"
d3354 3
@


2.289
log
@Simplify call to Compute_Z_PSIG.  Simplify some stuff.  Correct a bug:
If H-PHI iteration doesn't converge and no new zeta is added, z_ig isn't
defined.  Sneak up a little bit on TScat computation.
@
text
@d1866 1
a1866 1
          call get_beta_path ( Frq, p_path, t_path_c, tanh1_c,                &
d2059 1
a2059 1
          call get_beta_path_polarized ( frq, h, beta_group%lbl(sx), gl_slabs, &
d2155 1
a2155 1
          call get_beta_path ( Frq, p_path, t_path_f(:ngl), tanh1_f(1:ngl),    &
d2207 1
a2207 1
          call get_beta_path_polarized ( frq, h, beta_group%lbl(sx), gl_slabs, &
d3345 1
a3345 1
    & "$Id: FullForwardModel_m.f90,v 2.288 2008/05/20 00:23:21 vsnyder Exp $"
d3354 5
@


2.288
log
@Much rearranging to prepare for TScat calculation.
Use pointing-interpolated LOS velocity instead of MIF(1) for Doppler
correction for pointing frequency grid.
Send vel/C instead of vel to slabs_prep.
@
text
@d48 2
a49 2
    use Intrinsic, only: L_CLOUDICE, L_MAGNETICFIELD, L_PHITAN, L_PTAN, &
      & L_TEMPERATURE
d178 10
a187 3

    call compute_Z_PSIG ( fwdModelConf, temp, fwdModelConf%beta_group%qty, nlvl, &
      &                   no_tan_hts, surfaceTangentIndex, z_psig, tan_press )
d288 1
a288 1
      & L_EARTHREFL, L_ECRtoFOV, &
d291 2
a292 2
      & L_ORBITINCLINATION, L_RADIANCE, L_REFGPH, L_SCGEOCALT, &
      & L_SPACERADIANCE, L_SurfaceHeight, L_VMR
d310 4
d642 1
a642 1
    real(rp) :: H_Surf, H_Tan ! Height at surface and tangent
d646 2
d649 1
a649 2
    real(rp) :: REQ           ! Equivalent Earth Radius
    real(rp) :: ROT(3,3)      ! ECR-to-FOV rotation matrix
d707 2
d716 1
d721 1
d824 6
a829 3
    if ( FwdModelConf%incl_cld ) call cloud_setup

    call convolution_setup
d890 1
a893 1
      ! Loop over pointings --------------------------------------------------
d905 2
a906 2
        call one_pointing ( est_scGeocAlt(ptg_i), vel_rel, &
          &                 tan_press(ptg_i), tan_phi(ptg_i) )
d910 3
d916 2
a923 2
      call convolution ! or interpolation to ptan

d1131 4
a1134 3
      call estimate_tan_phi ( nlvl, maf, phitan, ptan, &
                            & scgeocalt, losvel, tan_press, tan_phi, est_scgeocalt, &
                            & est_los_vel )
d1451 1
a1451 1
      !{ Compute equivalent earth radius (REQ)
d1462 1
a1462 1
      ! these values in {\tt metrics}, or where its output {\tt req} value is
d2560 12
d2601 1
a2601 1
    subroutine One_Pointing ( Est_SCGeocAlt, Vel_Rel, Tan_Press, Tan_Phi )
d2603 5
a2607 4
      real(rp), intent(in) :: Est_SCGeocAlt ! Est S/C geocentric altitude /m
      real(rp), intent(in) :: Vel_Rel       ! Vel_z / speedOfLight
      real(rp), intent(in) :: Tan_Press
      real(rp), intent(in) :: Tan_Phi
a2611 8
      ! Find the number of the MIF having ptan nearest to tan_press.
      if ( FwdModelConf%polarized ) &
        & mif = minloc(abs(tan_press - &
        &                  ptan%values(:ptan%template%nosurfs,maf)),1)

      if ( toggle(emit) .and. levels(emit) > 4 ) &
        & call Trace_Begin ( 'ForwardModel.MetricsEtc' )

d2625 3
d2635 3
a2637 3
          &                    h_glgrid, earthradc_sq,     & ! in
          &                    tan_ind_c, nz_ig,           & ! inout
          &                    req, h_surf, h_tan, z_ig,   & ! output
d2641 4
a2644 4
          &                    h_glgrid, earthradc_sq,     & ! in
          &                    tan_ind_c, nz_ig,           & ! inout
          &                    req, h_surf, h_tan, z_ig,   & ! output
          &                    Tan_Press=tan_press,        & ! optional
d2648 3
a2650 3
          &                    h_glgrid, earthradc_sq,     & ! in
          &                    tan_ind_c, nz_ig,           & ! inout
          &                    req, h_surf, h_tan, z_ig )    ! output
d2664 1
a2664 1
      if ( h_tan < 0.0 ) then ! Handle Earth-intersecting ray
d2695 9
a2703 3
      call Height_Metrics ( tan_phi, tan_ind_f, Grids_tmp%phi_basis, &
        &  h_glgrid, req, h_surf, h_tan, z_ig, &              ! in
        &  vert_inds(1:npf), h_path(1:npf), phi_path(1:npf) ) ! out
d2709 2
a2710 2
      call more_points ( tan_phi, tan_ind_f, Grids_tmp%phi_basis,  &
        & z_glgrid, h_glgrid, req, h_surf, h_tan, phi_path(1:npf), & ! in
d2722 1
a2722 1
          call output ( req, before=', req = ', format='(f12.6)', advance='yes' )
d2724 1
a2724 1
          call output ( h_tan, before=', h_tan = ', format='(f12.6)', advance='yes' )
d2745 1
a2745 1
          more_h_path(n_more) = (h_tan+req)/cos(min_phi)
d2952 5
d2990 14
a3003 11
      ! Compute the pointing angles.  These are needed for antenna
      ! convolution, not for ray tracing.  We can't easily move these
      ! computations into the convolution code because they need Tan_Ht.
      if ( temp_der ) then
        ! Ext_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
        call get_chi_angles ( 0.001*est_scGeocAlt, n_path_c(tan_pt_c), &
           & tan_ht-Req, tan_phi, Req, 0.0_rp, ptg_angles(ptg_i),      &
           & tan_dh_dt, tan_d2h_dhdt, dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
      else
        call get_chi_angles ( 0.001*est_scGeocAlt, n_path_c(tan_pt_c), &
           & tan_ht-Req, tan_phi, Req, 0.0_rp, ptg_angles(ptg_i) )
d3221 25
d3345 1
a3345 1
    & "$Id: FullForwardModel_m.f90,v 2.287 2008/02/29 01:59:39 vsnyder Exp $"
d3354 6
@


2.287
log
@Added a separate H2O continuum routine
@
text
@d119 3
d231 1
d265 1
d281 1
a281 1
      & L_CLOUDWATER, L_EARTHREFL, L_ECRtoFOV, &
d285 1
a285 1
      & L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_SurfaceHeight, L_VMR
a310 1
    use Units, only: Deg2Rad
d376 4
a379 4
    integer :: I                  ! Loop index and other uses .
    integer :: INST               ! Relevant instance for temperature
    integer :: J                  ! Loop index and other uses ..
    integer :: K                  ! Loop index and other uses ..
a409 2
    integer :: NoSurf             ! Number of pressure levels
    integer :: NovmrSurf          ! Number of vmr levels
a410 1
    integer :: Ispec              ! Species index in cloud model
a630 1
    real(rp), save :: E_Stop  = 1.0_rp ! X for which Exp(X) is too small to worry
a635 1
    real(rp) :: R             ! real variable for various uses
a637 1
    real(rp) :: Vel_Cor       ! Velocity correction due to Vel_z, 1 - Vel_z/c
d681 1
a681 1
    ! Used only to schlep from Both_Sidebands_Setup to Convolution
a694 1
    type (VectorValue_T), pointer :: CLOUDWATER    ! Profiles
a702 1
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really
a705 1
    type (VectorValue_T), pointer :: VMR           ! Quantity
d765 1
a765 1
      & tscat_path, t_script_lbl, vmr )
d808 4
d876 13
a888 1
        call one_pointing
d1005 1
a1005 1
      call get_string ( fwdModelConf%name, work(c+1:c+l) )
d1015 2
a1016 6
    ! All of the setup stuff done for both sidebands.

      use Get_Chi_Out_m, only: Get_Chi_Out
      use Load_Sps_Data_m, only: Modify_values_for_supersat
      use Intrinsic, only: L_MIFDEADTIME, L_L1BMIF_TAI
      use ManipulateVectorQuantities, only: DoHGridsMatch, FindOneClosestInstance
d1018 1
a1018 5
      real(rp) :: D2XDXDT_SURFACE(1,sv_t_len) ! Would s_t*sv_t_len work?
      real(rp) :: D2XDXDT_TAN(ptan%template%nosurfs,sv_t_len) ! Would s_t*sv_t_len work?
      real(rp) :: One_dhdz(1), One_dxdh(1)
      real(rp) :: REQ_OUT(phitan%template%nosurfs)
      type (VectorValue_T), pointer :: WORK   ! Temporary stuff
a1022 2
      if ( e_stop > 0.0_rp ) e_stop = log(epsilon(0.0_rp)) ! only once

a1074 10
      if ( FwdModelConf%incl_cld ) then
        cloudWater => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_cloudWater, noError=.true., config=fwdModelConf )
        sizeDistribution => GetQuantityForForwardModel( fwdModelIn, fwdModelExtra, &
          & quantityType=l_sizeDistribution, noError=.true., config=fwdModelConf )
      end if
      if ( FwdModelConf%i_saturation /= l_clear ) then
        boundaryPressure => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_boundaryPressure, config=fwdModelConf )
      end if
a1091 3
      Vel_Rel = losvel%values(1,maf) / speedOfLight ! Needed for PFA
      Vel_Cor = 1.0_rp - Vel_Rel

a1094 85
      ! Stuff for clouds

      if ( FwdModelConf%incl_cld ) then  ! Do this block only if incl_cld is true

        !??? Is thisRadiance appropriate here ???
        inst = FindOneClosestInstance ( temp, thisRadiance, MAF )

        ! checking done in ForwardModelSupport%ConstructForwardModelConfig
        nspec = no_mol ! Will be at least 3 if l_n2o is included, because
                       ! l_h2o and l_o3 are required
        noSurf  = temp%template%noSurfs
        vmrarray = 0.0_r8

        do j = 1, nspec      ! Loop over species

          if ( fwdModelConf%molecules(j) == l_h2o ) then
            ispec = 1
          else if ( fwdModelConf%molecules(j) == l_o3 ) then
            ispec = 2
          else if ( fwdModelConf%molecules(j) == l_n2o ) then
            ispec = 3
          else
            cycle
          end if

          vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
            & quantityType=l_vmr, molecule=fwdModelConf%molecules(j) )

          novmrSurf = vmr%template%nosurfs

          call InterpolateValues ( &
          & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
          & reshape(vmr%values(:,inst),(/novmrSurf/)),      &    ! Old Y
          & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
          & vmrArray(ispec,:),                              &    ! New Y
          & 'Linear', extrapolate='Clamp' )

        end do ! End of Loop over species

        ! This can be put outside the mmaf loop

        call allocate_test ( scat_src%values, n_t_zeta, fwdModelConf%num_scattering_angles, &
                             &'scat_src', moduleName )
        call allocate_test ( scat_alb%values, n_t_zeta, 2, 'scat_alb', moduleName )
        call allocate_test (  cld_ext%values, n_t_zeta, 2, 'cld_ext', moduleName )

      end if

  ! Set up our temporary `state vector' like arrays ------------------------

  ! modify h2o mixing ratio if a special supersaturation is requested
      if ( fwdModelConf%i_saturation /= l_clear ) &
        & call modify_values_for_supersat ( fwdModelConf, grids_f, h2o_ind, &
          & grids_tmp, boundaryPressure )

  ! set up output pointing angles ------------------------------------------
  ! note we have to compute req !!!!!!!

  !{ Compute equivalent earth radius $c$ at phi_t(1), nearest surface, where
  !  $c^2 = \frac{a^2\,b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta} =
  !         \frac{a^2}{\left(\frac{a^2}{b^2}-1\right) \sin^2 \beta + 1}$

      earthradc_sq = earthRadA**2 / &
            &     (Earth_Axis_Ratio_Squared_m1 * &
                   &   SIN(orbIncline%values(1,maf)*Deg2Rad)**2 + 1)
      earthradc = sqrt(earthradc_sq)

  !{\begin{equation*}\begin{split}
  ! R_{eq} =\;& \sqrt \frac{R_a^4 \sin^2 \phi + R_c^4 \cos^2 \phi}
  !                       {R_a^2 \cos^2 \phi + R_c^2 \sin^2 \phi}\\
  !        =\;& \sqrt \frac{R_a^4 - (R_a^2+R_c^2)(R_a^2-R_c^2) \cos^2 \phi}
  !                       {R_c^2 +              (R_a^2-R_c^2) \cos^2 \phi}
  ! \end{split}\end{equation*}
  !
  ! Although this is the same mathematical formula as used in {\tt metrics},
  ! the $\phi$ used here is different.  Therefore, we can't use these
  ! values in {\tt metrics}, or where its output {\tt req} value is used.

      req_out = (earthrada-earthradc)*(earthrada+earthradc) * &
        & COS(phitan%values(:,maf)*Deg2Rad)**2
      ! Earthrad[abc] are in meters, but Req_Out needs to be in km.
      req_out = 0.001_rp * SQRT( &
        & ( earthrada**4 - (earthrada**2+earthradc_sq) * req_out ) / &
        & ( earthradc_sq + req_out ) )

d1108 2
a1109 2
      ! estimate tan_phi and scgeocalt
      call estimate_tan_phi ( no_tan_hts, nlvl, maf, phitan, ptan, &
d1113 1
a1113 1
   ! Now, allocate other variables we're going to need later ----------------
d1122 3
a1124 11
      ! This is only used for convolution, which is done for both sidebands.
      if ( fwdModelConf%scanAverage ) then
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_l1bMIF_TAI )
        l1bMIF_TAI => work%values
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_MIFDeadTime )
        MIFDeadTime => work%values ! Only the (1,1) element is used.
      else
        nullify ( l1bMIF_TAI, MIFDeadTime )
      end if
d1126 4
a1129 26
      ! Temperature's windowStart:windowFinish are correct here.
      ! RefGPH and Temperature have the same horizontal basis.
      ! Grids_F is only needed for H2O, for calculating refractive index.
      ! SCgeocAlt and RefGPH are in meters, but Get_Chi_Out wants them in km.
      ! This is only used for convolution, which is done for both sidebands.
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp,                    &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /),              &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish),             &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp,                       &
         & req_out, grids_f, h2o_ind, tan_chi_out, dh_dz_out, dx_dh_out,   &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )

      ! This is a lazy way to get the surface angle
      ! Temperature's windowStart:windowFinish are correct here.
      ! refGPH and temperature have the same horizontal basis.
      ! Grids_tmp is only needed for H2O, for calculating refractive index.
      ! Est_scgeocalt and RefGPH are in meters, but Get_Chi_Out wants them in km.
      ! This is only used for convolution, which is done for both sidebands.
      call get_chi_out ( tan_press(1:1), tan_phi(1:1),                     &
         & 0.001_rp*est_scgeocalt(1:1), Grids_tmp,                         &
         & (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish),             &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp,                       &
         & req_out(1:1), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh, &
         & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )
d1136 56
a1204 2
      logical, parameter :: OLDPATCHER = .false. ! Old one was buggy

d1209 1
a1209 1
      integer :: PTG_J, PTG_K      ! Loop counters for patching the pointings
d1242 1
a1242 1
        if ( ptg_angles(ptg_i) <= ptg_angles(ptg_i-1) .and. OLDPATCHER) then
d1245 7
a1251 16
          ptg_j = ptg_i + 2
          patchPtgInnerLoop: do 
            if ( ptg_j > no_tan_hts ) exit patchPtgInnerLoop
            if ( ptg_angles(ptg_j) > ptg_angles(ptg_i) ) exit patchPtgInnerLoop
            ptg_j = ptg_j + 1
          end do patchPtgInnerLoop
          ! Work out the spacing to fill in with
          if ( ptg_j > no_tan_hts ) then
            ! Fell off the end of the list, just use previous spacing
            ptg_j = no_tan_hts
          else
            ! Didn't fall off, so work out spacing
            deltaPtg = ( ptg_angles(ptg_j) - ptg_angles(ptg_i) ) / ( ptg_j - ptg_i )
          end if
          do ptg_k = ptg_i, ptg_j - 1
            ptg_angles(ptg_k) = ptg_angles(ptg_i-1) + ( ptg_k - ptg_i + 1 ) * deltaPtg
a1252 19
          ! Don't worry about missing the last one here, it will get caught by
          ! the next iteration of the outer loop
        else if ( ptg_angles(ptg_i) <= ptg_angles(ptg_i-1) ) then
          patchedAPtg = .true.
          ! This one is at or below its predecessor, find the next one above
          ptg_j = ptg_i + 1
          patchPtgInnerLoop2: do 
            if ( ptg_j > no_tan_hts ) exit patchPtgInnerLoop2
            if ( ptg_angles(ptg_j) > ptg_angles(ptg_i-1) ) exit patchPtgInnerLoop2
            ptg_j = ptg_j + 1
          end do patchPtgInnerLoop2
          ! Work out the spacing to fill in with
          if ( ptg_j > no_tan_hts ) then
            ! Fell off the end of the list, just use previous spacing
            ptg_j = no_tan_hts
          else
            ! Didn't fall off, so work out spacing
            deltaPtg = ( ptg_angles(ptg_j) - ptg_angles(ptg_i-1) ) / ( ptg_j - ptg_i + 1 )
          end if
d1255 1
a1255 1
          ! This value us above the previous one so compute a delta from it 
d1303 1
a1303 1
              & (/ fwdModelConf%signals(sigInd) /), sideband=thisSideband, &
d1411 82
d2566 7
a2572 1
    subroutine One_Pointing
d2576 1
d2578 1
a2578 1
        & mif = minloc(abs(tan_press(ptg_i) - &
d2603 1
a2603 1
        call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
d2609 1
a2609 1
        call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
d2613 1
a2613 1
          &                    Tan_Press=tan_press(ptg_i), & ! optional
d2616 1
a2616 1
        call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
d2664 1
a2664 1
      call Height_Metrics ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
d2672 1
a2672 1
      call more_points ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
d2682 1
a2682 1
          call output ( tan_phi(ptg_i), before=') = ', format='(f12.6)' )
d2948 3
d2953 3
a2955 4
        call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(tan_pt_c),&
           & tan_ht-Req, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
           & r, 1.0_rp, tan_dh_dt, tan_d2h_dhdt,       &
           & dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
d2957 2
a2958 3
        call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(tan_pt_c),&
           & tan_ht-Req, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
           & r, 1.0_rp )
d2961 1
d3008 1
a3008 1
          &  est_los_vel(ptg_i), gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
d3015 1
a3015 1
          &  est_los_vel(ptg_i), gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
a3020 7
      ! If we're doing frequency averaging, get the frequencies we need for
      ! this pointing.

      if ( FwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) &
        & call frequency_setup_2 ( vel_cor * &
        & PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies )

d3181 1
a3181 1
  subroutine Estimate_Tan_Phi ( no_tan_hts, nlvl, maf, phitan, ptan, &
d3185 1
a3185 1
  ! Estimate Tan_Phi and SC_geoc_alt.
d3187 1
a3187 1
    use MLSKinds, only: RP
a3194 1
    integer, intent(in) :: No_Tan_Hts              ! Number of tangent heights
d3201 1
a3201 1
    real(rp), dimension(:), intent(in) :: Tan_press
d3204 3
a3206 3
    real(rp), dimension(:), intent(out) :: Tan_phi
    real(rp), dimension(:), intent(out) :: Est_scgeocalt ! Est S/C geocentric altitude /m
    real(rp), dimension(:), intent(out) :: est_los_vel
d3210 7
a3216 6
    real(rp) :: R, R1, R2, r3       ! real variables for various uses
    real(rp), dimension(ptan%template%noSurfs) :: &
      & P_PATH, &               ! Pressure on path
      & T_PATH, &               ! Temperatures on path
      & mif_vel,&               ! LOS velocities
      & Z_PATH                  ! Zeta on path
d3218 1
a3218 1
    sub = no_tan_hts - nlvl ! # subsurface levels = SurfaceTangentIndex-1
d3230 6
a3235 4
    z_path = ptan%values(1:k,maf)
    p_path = phitan%values(1:k,maf)
    t_path = scgeocalt%values(1:k,maf)
    mif_vel = losvel%values(1:k,maf)
d3237 1
a3237 1
    ! Sort z_path.  Permute p_path, t_path and mif_vel the same way.
d3239 6
a3244 6
    do i = 2, k ! Invariant: z_path(1:i-1) are sorted.
      r = z_path(i)
      if ( r < z_path(i-1) ) then
        r1 = p_path(i)
        r2 = t_path(i)
        r3 = mif_vel(i)
d3246 5
a3250 5
        do ! Find where to insert R.  Make room as we go.
          z_path(jf) = z_path(jf-1)
          p_path(jf) = p_path(jf-1)
          t_path(jf) = t_path(jf-1)
          mif_vel(jf) = mif_vel(jf-1)
d3252 1
a3252 2
          if ( jf == 1 ) exit
          if ( r >= z_path(jf-1) ) exit
d3254 4
a3257 4
        z_path(jf) = r
        p_path(jf) = r1
        t_path(jf) = r2
        mif_vel(jf) = r3
d3261 6
a3266 6
    call interpolateValues ( z_path, p_path, tan_press(sub+1:no_tan_hts), &
      &  tan_phi(sub+1:no_tan_hts), METHOD = 'L', EXTRAPOLATE='C' )
    call interpolateValues ( z_path, t_path, tan_press(sub+1:no_tan_hts), &
       & est_scgeocalt(sub+1:no_tan_hts), METHOD='L', EXTRAPOLATE='C' )
    call interpolateValues ( z_path, mif_vel, tan_press(sub+1:no_tan_hts), &
       & est_los_vel(sub+1:no_tan_hts), METHOD='L', EXTRAPOLATE='C' )
d3275 1
a3275 1
    & "$Id: FullForwardModel_m.f90,v 2.286 2007/11/08 02:02:19 vsnyder Exp $"
d3284 3
@


2.286
log
@Change name of path_dsdh to dsdh_path for consistency with other names.
Add do_path_norm switch.  Rearrange printing if switches set to show
desires to add points but not to add them.
@
text
@d1865 2
a1866 1
            &  dbeta_dT_path_c, dbeta_dw_path_c, dbeta_dn_path_c, dbeta_dv_path_c )
d2152 4
a2155 4
            & beta_group, sx, fwdModelConf%polarized, gl_slabs,                &
            & gl_inds, beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,      &
            & vel_rel, &
            & dbeta_dT_path_f, dbeta_dw_path_f, dbeta_dn_path_f, dbeta_dv_path_f )
d3291 1
a3291 1
    & "$Id: FullForwardModel_m.f90,v 2.285 2007/07/31 23:49:21 vsnyder Exp $"
d3300 5
@


2.285
log
@Add an argument metrics needs for H/Phi failure recovery
@
text
@d431 1
a431 1
    integer :: CG_INDS(max_c)     ! Indices on coarse grid where GL needed
d459 2
a460 1
    real(rp) :: DEL_S(max_c)          ! Integration lengths along path
d462 5
a466 3
    real(rp) :: DHDZ_PATH(max_f)      ! dH/dZ on path
    real(rp) :: DHDZ_GW_PATH(max_f)   ! dH/dZ * GW on path
    real(rp) :: DSDZ_C(max_c)         ! ds/dH * dH/dZ on coarse path
a476 1
    real(rp) :: PATH_DSDH(max_f)      ! dS/dH on path
d621 1
d2111 2
a2112 1
        ! trapezoid rule (here).
d2117 1
a2117 1
              & 0.5 * ( alpha_path_c(j-1) - alpha_path_c(j) ) * dsdz_c(j-1)*del_zeta(j)
d2122 1
a2122 1
              & 0.5 * ( alpha_path_c(j+1) - alpha_path_c(j) ) * dsdz_c(j+1)*del_zeta(j)
d2125 2
a2126 1
        call get_GL_inds ( do_gl, tan_pt_c, gl_inds_b, cg_inds, ngl, ncg )
d2168 2
a2169 2
          call get_tau ( frq_i, gl_inds, cg_inds(1:ncg), e_rflty, del_zeta, &
            & alpha_path_c, ref_corr, incoptdepth, tan_pt_c,                &
d2219 1
a2219 1
          call rad_tran_pol ( tan_pt_c, gl_inds, cg_inds(1:ncg), e_rflty, del_zeta, &
d2266 4
a2269 4
            call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop),   &
              &  del_zeta, Grids_f, beta_path_polarized(:,1:p_stop,:),     &
              &  tanh1_c(:npc), eta_fzp(:npf,:), do_calc_fzp, sps_path, del_s,     &
              &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),        &
d2314 1
a2314 1
              & do_calc_t_f(:ngl,:), path_dsdh, dhdz_gw_path, dsdz_gw_path,  &
d2353 1
a2353 1
              & do_calc_t_f(:ngl,:), do_gl(1:p_stop), path_dsdh,            &
d2681 23
a2703 7
      if ( do_more_points ) then
        ! Look for path crossings at zetas below the tangent point.
        ! These can only happen if the minimum zeta isn't at the tangent.
        call more_points ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
          & z_glgrid, h_glgrid, req, h_surf, h_tan, phi_path(1:npf), & ! in
          & more_z_path, more_h_path, more_phi_path, n_more )
      else
d2707 9
a2715 9
      if ( do_zmin ) then
        ! Get minimum zeta on the path
        call Get_Min_Zeta ( Grids_tmp%phi_basis, h_glgrid(tan_ind_f,:), &
                          & t_glgrid(tan_ind_f,:), z_glgrid(tan_ind_f), &
                          & phi_path, tan_ind_f, tan_ht,                &
                          & min_zeta, min_phi, min_index )

        ! Add minimum zeta to the path
        if ( min_index > 0 ) then ! minimum zeta not at or near tangent point
d2720 14
a2744 11
        call output ( 'Found more intersections', advance='yes' )
        call output ( ptg_i, before='tan_phi(' )
        call output ( tan_phi(ptg_i), before =') = ' )
        call output ( tan_ind_f, before=', tan_ind_f = ' )
        call output ( req, before=', req = ', format = '(f7.2)' )
        call output ( h_surf, before=', h_surf = ', format = '(f7.2)' )
        call output ( h_tan, before=', h_tan = ', advance='yes' )
        call dump ( more_h_path(:n_more), name='more_h_path' )
        call dump ( more_phi_path(:n_more), name='more_phi_path' )
        call dump ( more_z_path(:n_more), name='more_z_path' )
        call dump ( h_glgrid+req-h_surf, name='h_glgrid' )
d2761 2
a2762 1
      call get_gl_inds ( do_gl(:npc), tan_pt_c, f_inds, cg_inds, nglMax, ncg )
d2764 1
a2829 4
!   dhdz_gw_path(f_inds) = dhdz_path(f_inds) * (/ ( gw, i = 1, nglMax/ng ) /)
      do i = 1, nglMax, ng ! Avoid a temp for (/ ( gw, i = 1, nglMax/ng ) /)
        dhdz_gw_path(f_inds(i:i+ng-1)) = dhdz_path(f_inds(i:i+ng-1)) * gw
      end do
d2977 1
a2977 1
      ! We need path_dsdh on the fine grid for Gauss-Legendre or Gauss-
d2984 1
a2984 1
      path_dsdh(:tan_pt_f-1) = h_path(:tan_pt_f-1) / &
d2986 1
a2986 1
      path_dsdh(tan_pt_f+2:npf) = h_path(tan_pt_f+2:npf) / &
d2988 1
a2988 1
      path_dsdh(tan_pt_f:tan_pt_f+1) = 0.0
d2990 4
a2993 2
      dsdz_gw_path(f_inds(:nglMax)) = path_dsdh(f_inds(:nglMax)) * &
        & dhdz_gw_path(f_inds(:nglMax))
d2995 17
a3011 3
      ! We need dsdz = ds/dh * dh/dz, not multiplied by GW, for
      ! trapezoidal quadrature on the coarse grid.
      dsdz_c(:npc) = path_dsdh(c_inds) * dhdz_path(c_inds)
d3290 1
a3290 1
    & "$Id: FullForwardModel_m.f90,v 2.284 2007/07/11 22:26:32 vsnyder Exp $"
d3299 3
d3369 1
a3369 1
! OOPS, out of bounds subscript possible in path_dsdh
@


2.284
log
@More dumps, change some error handling
@
text
@d2671 1
a2671 1
        &  h_glgrid, req, h_surf, h_tan, &                    ! in
d3252 1
a3252 1
    & "$Id: FullForwardModel_m.f90,v 2.283 2007/06/29 19:33:59 vsnyder Exp $"
d3261 3
@


2.283
log
@Put the pointing loop body into an internal subroutine
Make ForwardModelIntermediate_t private to ScanModelModule
@
text
@d367 1
d745 5
a749 2
    print_more_points = index(switches, 'ZMOR' ) /= 0
    do_more_points = index(switches, 'zmor') /= 0
d756 2
d980 19
d1084 2
a1085 2
      if ( .not. doHGridsMatch ( refGPH, temp ) ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, 'Different horizontal grids for refGPH and temperature' )
d1408 1
a1408 1
          if ( whichPattern < 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2217 1
a2217 1
            & ct, stcp, stsp, t_script(:,frq_i), prod_pol(:,:,1:npc),               &
d2228 5
a2232 2
            call MLSMessage ( MLSMSG_Error, moduleName, &
              & 'exp(incoptdepth_pol) failed' )
d2377 1
a2377 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d2380 1
a2380 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d2452 1
a2452 1
        if ( whichPointingGrid < 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d2561 1
a2561 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d2564 1
a2564 2
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Bad value of signal%sideband' )
d3252 1
a3252 1
    & "$Id: FullForwardModel_m.f90,v 2.282 2007/06/26 01:05:02 vsnyder Exp $"
d3261 4
@


2.282
log
@Use column-sparse eta
@
text
@d35 1
a35 1
                             &  FwdModelOut, oldIfm, FmStat, Jacobian )
d44 1
a44 2
    use ForwardModelIntermediate, only: ForwardModelIntermediate_t, &
                                        ForwardModelStatus_t
a59 1
    type(forwardModelIntermediate_T), intent(inout) :: oldIfm ! Workspace
d868 2
a869 570
        if ( toggle(emit) .and. levels(emit) > 3 ) &
          & call Trace_Begin ( 'ForwardModel.Pointing ', index=ptg_i )

        if ( FwdModelConf%polarized ) &
          & mif = minloc(abs(tan_press(ptg_i) - &
          &                  ptan%values(:ptan%template%nosurfs,maf)),1)

        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.MetricsEtc' )

        ! Assume it's not an earth-intersecting ray and min zeta is at
        ! the tangent point
        e_rflty = 1.0
        ! Use the "original" GL-grid arrays -- the ones filled before the
        ! sideband loop.  These depend only upon the original Zetas
        ! (Z_PSIG) derived from the L2CF using make_z_grid.
        ddhidhidtl0 => ddhidhidtl0_o
        dh_dt_glgrid => dh_dt_glgrid_o
        dhdz_glgrid => dhdz_glgrid_o
        h_glgrid => h_glgrid_o
        t_glgrid => t_glgrid_o
        z_glgrid => z_glgrid_o

        ! Compute where the tangent is, the equivalent Earth radius, tangent
        ! height and surface height, and determine whether the ray
        ! intersects the Earth surface
        tan_ind_c = max(1,ptg_i-surfaceTangentIndex+1) ! On coarse grid
        nz_ig = nlvl
        if ( associated(surfaceHeight) ) then
          call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
            &                    h_glgrid, earthradc_sq,     & ! in
            &                    tan_ind_c, nz_ig,           & ! inout
            &                    req, h_surf, h_tan, z_ig,   & ! output
            &                    surf_height=surfaceHeight%values(1,:) ) ! opt
        else if ( ptg_i < surfaceTangentIndex ) then
          call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
            &                    h_glgrid, earthradc_sq,     & ! in
            &                    tan_ind_c, nz_ig,           & ! inout
            &                    req, h_surf, h_tan, z_ig,   & ! output
            &                    Tan_Press=tan_press(ptg_i), & ! optional
            &                    Surf_Temp=temp%values(1,windowstart:windowfinish) )
        else
          call tangent_metrics ( tan_phi(ptg_i), Grids_tmp%phi_basis, z_psig, &
            &                    h_glgrid, earthradc_sq,     & ! in
            &                    tan_ind_c, nz_ig,           & ! inout
            &                    req, h_surf, h_tan, z_ig )    ! output
        end if
        nz_if = (nz_ig-1) * ngp1 + 1                ! On Z_GLgrid
        tan_ind_f = (tan_ind_c-1) * ngp1 + 1        ! On Z_GLgrid
        tan_pt_f = nz_if + 1 - tan_ind_f            ! fine path tangent index
        tan_pt_c = (tan_pt_f + Ng) / Ngp1           ! coarse path tangent index
        npc = 2 * tan_pt_c
        npf = 2 * tan_pt_f

        if ( nz_ig == nlvl ) then
          z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
          z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)
        end if

        if ( h_tan < 0.0 ) then ! Handle Earth-intersecting ray
          e_rflty = earthRefl%values(1,1)
          if ( nz_ig > nlvl ) then ! Added a new zeta
            z_coarse(:tan_pt_c) = z_ig(nz_ig:tan_ind_c:-1)
            z_coarse(tan_pt_c+1:npc) = z_ig(tan_ind_c:nz_ig)
            ! Use the "revised" GL-grid arrays, which depend upon the new zeta.
            ddhidhidtl0 => ddhidhidtl0_r(:nz_if,:,:)
            dh_dt_glgrid => dh_dt_glgrid_r(:nz_if,:,:)
            dhdz_glgrid => dhdz_glgrid_r(:nz_if,:)
            h_glgrid => h_glgrid_r(:nz_if,:)
            t_glgrid => t_glgrid_r(:nz_if,:)
            z_glgrid => z_glgrid_r(:nz_if)
            call compute_GL_grid ( z_ig(:nz_ig), z_glgrid )

            if ( temp_der ) then
              call two_d_hydrostatic ( Grids_tmp, &
                &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
                &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
                &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
                &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
            else
              call two_d_hydrostatic ( Grids_tmp, &
                &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
                &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
                &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
                &  dhdz_glgrid )
            end if
          end if
        end if

        ! Get H_Path and Phi_Path on the fine grid.
        call Height_Metrics ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
          &  h_glgrid, req, h_surf, h_tan, &                    ! in
          &  vert_inds(1:npf), h_path(1:npf), phi_path(1:npf) ) ! out

        tan_ht = h_path(tan_pt_f) ! Includes Earth radius

        if ( do_more_points ) then
          call more_points ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
            & z_glgrid, h_glgrid, req, h_surf, h_tan, phi_path(1:npf), & ! in
            & more_z_path, more_h_path, more_phi_path, n_more )
        else
          n_more = 0
        end if

        if ( do_zmin ) then
          ! Get minimum zeta on the path
          call Get_Min_Zeta ( Grids_tmp%phi_basis, h_glgrid(tan_ind_f,:), &
                            & t_glgrid(tan_ind_f,:), z_glgrid(tan_ind_f), &
                            & phi_path, tan_ind_f, tan_ht,                &
                            & min_zeta, min_phi, min_index )

          ! Add minimum zeta to the path
          if ( min_index > 0 ) then ! minimum zeta not at or near tangent point
            n_more = n_more + 1
            more_z_path(n_more) = min_zeta
            more_phi_path(n_more) = min_phi
            more_h_path(n_more) = (h_tan+req)/cos(min_phi)
          end if
        else
          min_index = 0
        end if

        call add_points ( more_h_path(:n_more), more_phi_path(:n_more),     &
          &               more_z_path(:n_more), min_index, z_glgrid, nz_if, &
          &               z_coarse, h_path, phi_path, vert_inds,            &
          &               npc, npf, tan_pt_c, tan_pt_f )

        if ( print_more_points .and. n_more > 0 ) then
          call output ( 'Found more intersections', advance='yes' )
          call output ( ptg_i, before='tan_phi(' )
          call output ( tan_phi(ptg_i), before =') = ' )
          call output ( tan_ind_f, before=', tan_ind_f = ' )
          call output ( req, before=', req = ', format = '(f7.2)' )
          call output ( h_surf, before=', h_surf = ', format = '(f7.2)' )
          call output ( h_tan, before=', h_tan = ', advance='yes' )
          call dump ( more_h_path(:n_more), name='more_h_path' )
          call dump ( more_phi_path(:n_more), name='more_phi_path' )
          call dump ( more_z_path(:n_more), name='more_z_path' )
          call dump ( h_glgrid+req-h_surf, name='h_glgrid' )
          call dump ( Grids_tmp%phi_basis, name='phi_basis' )
          call dump ( h_path(1:npf), name='h_path' )
          call dump ( phi_path(1:npf), name='phi_path' )
        end if

        ! Compute Gauss Legendre (GL) grid ----------------------------------
        call compute_GL_grid ( z_coarse(:tan_pt_c), z_path(:tan_pt_f), &
          &                    p_path(:tan_pt_f) )
        call compute_GL_grid ( z_coarse(tan_pt_c+1:npc), z_path(tan_pt_f+1:npf), &
          &                    p_path(tan_pt_f+1:npf) )

        ! This is not pretty but we need some coarse path extraction indices
        c_inds => c_inds_b(:npc)
        c_inds = (/(i*Ngp1-Ng,i=1,tan_pt_c),((i-1)*Ngp1-Ng+1,i=tan_pt_c+1,npc)/)
        ! And some fine path extraction indices
        do_gl(1:npc:npc-1) = .false.; do_gl(2:npc-1) = .true.
        call get_gl_inds ( do_gl(:npc), tan_pt_c, f_inds, cg_inds, nglMax, ncg )

        del_zeta(1:npc:npc-1) = 0.0_rp ! First and last ones
        del_zeta(2:tan_pt_c) = 0.5_rp * ( z_path(c_inds(1:tan_pt_c-1)) - &
          &                               z_path(c_inds(2:tan_pt_c)) )
        del_zeta(tan_pt_c+1:npc-1) = 0.5_rp * ( z_path(c_inds(tan_pt_c+2:npc)) - &
          &                                     z_path(c_inds(tan_pt_c+1:npc-1)) )

        ! Do phi refractive correction
        if ( FwdModelConf%refract ) then
          ! Get t_path (and dhdz_path, which we don't need yet) so we can
          ! calculate the refractive index
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,  &
            &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf), &
            &  t_path(1:npf), dhdz_path(1:npf) )
          ! Compute refractive index on the path.
          if ( h2o_ind > 0 ) then
            ! Compute eta_zp & do_calc_zp (Zeta & Phi only) for water.
            ! It is important to send all of eta_zp, do_calc_zp, nz_zp and
            ! nnz_zp so that nonzeros from previous invocations can be
            ! cleared without violating array bounds.
            call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
              &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
              &  nz_zp=nz_zp, nnz_zp=nnz_zp )
            call comp_1_sps_path_no_frq ( Grids_f, h2o_ind, eta_zp(1:npf,:), &
              & sps_path(1:npf,h2o_ind) )
            call refractive_index ( p_path(1:npf), t_path(1:npf), &
              &  n_path_f(1:npf),  &
              &  h2o_path=sps_path(1:npf, h2o_ind) )
          else
            call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf) )
            n_path_c(:npc) = n_path_f(c_inds)
          end if
          ! Do the refractive correction.  Use t_path to store the correction,
          ! since we're going to recompute t_path right away.
          n_path_f(1:npf) = min ( n_path_f(1:npf), MaxRefraction )
          call phi_refractive_correction ( tan_pt_f, n_path_f(1:npf), &
            & h_path(1:npf), t_path(1:npf) )
          phi_path(:tan_pt_f) = phi_path(:tan_pt_f) - t_path(:tan_pt_f)
          phi_path(tan_pt_f+1:npf) = phi_path(tan_pt_f+1:npf) + t_path(tan_pt_f+1:npf)
        end if

        ! Get other metrics-related quantities: t_path, dhdz_path, dh_dt_path...
        if ( temp_der ) then
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
            &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
            &  t_path(1:npf), dhdz_path(1:npf),                            &
            !  Stuff for temperature derivatives:
            &  DDHIDHIDTL0 = ddhidhidtl0, DHIDTLM = dh_dt_glgrid,          &
            &  T_DERIV_FLAG = Grids_tmp%deriv_flags,                       &
            &  Z_BASIS = Grids_tmp%zet_basis, Z_REF=z_glgrid,              &
            &  DDHTDHTDTL0 = tan_d2h_dhdt, DHITDTLM = dh_dt_path(1:npf,:), &
            &  DHTDTL0 = tan_dh_dt, DO_CALC_HYD = do_calc_hyd(1:npf,:),    &
            &  DO_CALC_T = do_calc_t, ETA_ZXP = eta_zxp_t,                 &
            &  NZ_ZXP = nz_zxp_t, NNZ_ZXP = nnz_zxp_t )
          dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds,:)
          do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds,:)
          do_calc_t_c(1:npc,:) = do_calc_t(c_inds,:)
          eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds,:)
          call select_nz_list ( nz_zxp_t, nnz_zxp_t, c_inds, nz_zxp_t_c, nnz_zxp_t_c )
          t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
        else
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis,    &
            &  vert_inds(1:npf), t_glgrid, dhdz_glgrid, phi_path(1:npf),   &
            &  t_path(1:npf), dhdz_path(1:npf) )
        end if

!       dhdz_gw_path(f_inds) = dhdz_path(f_inds) * (/ ( gw, i = 1, nglMax/ng ) /)
        do i = 1, nglMax, ng ! Avoid a temp for (/ ( gw, i = 1, nglMax/ng ) /)
          dhdz_gw_path(f_inds(i:i+ng-1)) = dhdz_path(f_inds(i:i+ng-1)) * gw
        end do
        h_path_c(1:npc) = h_path(c_inds)
        t_path_c(1:npc) = t_path(c_inds)

        ! Compute the eta_zp & do_calc_zp (for Zeta & Phi only)

        ! It is important to send all of eta_zp, do_calc_zp, nz_zp and
        ! nnz_zp so that nonzeros from previous invocations can be
        ! cleared without violating array bounds.
        call comp_eta_docalc_no_frq ( Grids_f, z_path(1:npf), &
          &  phi_path(1:npf), eta_zp, do_calc_zp, tan_pt=tan_pt_f, &
          &  nz_zp=nz_zp, nnz_zp=nnz_zp )

        ! Compute sps_path with a FAKE frequency, mainly to get the
        ! WATER (H2O) contribution for refraction calculations, but also
        ! to compute sps_path for all those with no frequency component

      ! Frq = 0.0_r8
        call comp_sps_path_frq ( Grids_f,           &
          & 0.0_r8, eta_zp(1:npf,:),                &
          & do_calc_zp(1:npf,:), sps_path(1:npf,:), &
          & do_calc_fzp(1:npf,:), eta_fzp(1:npf,:) )
!         ! Send all of eta_zp so comp_sps_path_frq_nz doesn't get an array
!         ! bounds error when it's clearing parts indexed by nz_zp.
! I don't know why this doesn't work
!         call comp_sps_path_frq_nz ( Grids_f,                         &
!           & 0.0_r8, eta_zp, nz_zp, nnz_zp,                           &
!           & do_calc_zp(1:npf,:), sps_path(1:npf,:),                  &
!           & do_calc_fzp(1:npf,:), eta_fzp(1:npf,:), nz_fzp, nnz_fzp )

        if ( h2o_ind > 0 ) then
          ! Even if we did the refractive correction we need to do this,
          ! because the refractive correction changes phi_path, which
          ! changes sps_path.
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path_c(1:npc),  &
            &  h2o_path=sps_path(c_inds, h2o_ind) )
        else if ( .not. FwdModelConf%refract ) then
          ! If we didn't do the refractive correction, we haven't yet
          ! computed the refractive index.
          call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf) )
          n_path_c(:npc) = n_path_f(c_inds)
        end if

        n_path_c(1:npc) = min ( n_path_c(1:npc), MaxRefraction )

        if ( size(fwdModelConf%lineCenter) > 0 ) then
          call comp_eta_docalc_no_frq ( grids_v, z_path(1:npf), &
            & phi_path(1:npf), eta_zxp_v(1:npf,:), do_calc_v(1:npf,:), tan_pt=tan_pt_f )
          call comp_sps_path_no_frq ( grids_v, eta_zxp_v(1:npf,:), &
            & spect_v_path(1:npf,:) )
          lineCenter_ix => beta_group%lbl(sx)%spect_der_ix(lineCenter)
        end if
        if ( size(fwdModelConf%lineWidth) > 0 ) then
          call comp_eta_docalc_no_frq ( grids_w, z_path(1:npf), &
            & phi_path(1:npf), eta_zxp_w(1:npf,:), do_calc_w(1:npf,:), tan_pt=tan_pt_f )
          call comp_sps_path_no_frq ( grids_w, eta_zxp_w(1:npf,:), &
            & spect_w_path(1:npf,:) )
          lineWidth_ix => beta_group%lbl(sx)%spect_der_ix(lineWidth)
        end if
        if ( size(fwdModelConf%lineWidth_TDep) > 0 ) then
          call comp_eta_docalc_no_frq ( grids_n, z_path(1:npf), &
            & phi_path(1:npf), eta_zxp_n(1:npf,:), do_calc_n(1:npf,:), tan_pt=tan_pt_f )
          call comp_sps_path_no_frq ( grids_n, eta_zxp_n(1:npf,:), &
            & spect_n_path(1:npf,:) )
          lineWidth_TDep_ix => beta_group%lbl(sx)%spect_der_ix(lineWidth_TDep)
        end if

        ! Special path quantities for cloud model
        if ( fwdModelConf%Incl_Cld ) then ! s_i == 1 here

          !set cloud parameters to zero
          iwc_path(1:npf,1) = 0.
          WC(1,1:npf)=iwc_path(1:npf,1)
          WC(2,1:npf)=0.
          IPSD(1:npf)=1000

          call comp_eta_docalc_no_frq ( Grids_Iwc, z_path(1:npf), &
            &  phi_path(1:npf), eta_iwc_zp(1:npf,:), tan_pt=tan_pt_f )

          ! Compute IWC_PATH
          call comp_sps_path_no_frq ( Grids_iwc, eta_iwc_zp(1:npf,:), &
            & iwc_path(1:npf,:) )
          WC(1,1:npf)=iwc_path(1:npf,1)
        end if

        ! Special path quantities for Polarized (magnetic) model
        if ( FwdModelConf%polarized ) then

          call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:npf), &
            &  phi_path(1:npf), eta_mag_zp(1:npf,:), tan_pt=tan_pt_f )

          ! Compute the first three components of MAG_PATH
          call comp_sps_path ( Grids_mag, 1, eta_mag_zp(1:npf,:), &
            & mag_path(1:npf,1:3) )

          rot = reshape(ECRtoFOV%values(9*mif-8:9*mif,maf), (/3,3/))

          do j = 1, npf
            ! Rotate mag_path from ECR to IFOVPP (R1A) coordinates.  Use
            ! the rotation matrix for the MIF nearest to the current
            ! pointing angle instead of interpolating.  They are nearly
            ! identical anyway.
            mag_path(j,1:3) = matmul ( rot, mag_path(j,1:3) )
            ! Put the magnitude of mag_path(j,1:3) in mag_path(j,4)
            mag_path(j,4) = sqrt(sum(mag_path(j,1:3)**2))
            ! Normalize mag_path(j,1:3).
            if ( mag_path(j,4) /= 0.0_rp ) then
              mag_path(j,1:3) = mag_path(j,1:3) / mag_path(j,4)
            else
              mag_path(j,1:3) = 0.0_rp
              mag_path(j,3) = 1.0_rp !arbitrarily, theta=0 for zero field
            end if
          end do

          ct => mag_path(1:npf,3)   ! cos(theta)
          stcp => mag_path(1:npf,1) ! sin(theta) cos(phi)
          stsp => mag_path(1:npf,2) ! sin(theta) sin(phi)
          h => mag_path(1:npf,4)    ! magnitude of magnetic field

          if ( print_Mag ) then
            call dump ( h, 'H', clean=clean )
            call dump ( ct, 'Cos(theta)', clean=clean )
            call dump ( stcp, 'Sin(theta) Cos(phi)', clean=clean )
            call dump ( stsp, 'Sin(theta) Sin(phi)', clean=clean )
          end if

        end if

        if ( temp_der ) then
         ! Ext_SCgeocAlt is in meters, but Get_Chi_Angles wants it in km.
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(tan_pt_c),&
             & tan_ht-Req, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
             & r, 1.0_rp, tan_dh_dt, tan_d2h_dhdt,       &
             & dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
        else
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(tan_pt_c),&
             & tan_ht-Req, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
             & r, 1.0_rp )
        end if

        n_path_c(1:npc) = n_path_c(1:npc) + 1.0_rp

        call comp_refcor ( tan_pt_c, h_path_c(:npc), n_path_c(:npc), &
                      &    tan_ht, del_s(:npc), ref_corr(:npc), ier )
        if ( ier /= 0 ) fmStat%flags = ior(fmStat%flags,b_refraction)

        ! We need path_dsdh on the fine grid for Gauss-Legendre or Gauss-
        ! Lobatto quadrature, and on the coarse grid except at the tangent
        ! point for trapezoidal quadrature and Gauss-Lobatto quadrature, so
        ! compute it everywhere except at the tangent point.  Besides, it's
        ! probably faster not to use a vector subscript to restrict it to
        ! the fine grid.

        path_dsdh(:tan_pt_f-1) = h_path(:tan_pt_f-1) / &
          & ( sqrt(h_path(:tan_pt_f-1)**2 - tan_ht**2 ) )
        path_dsdh(tan_pt_f+2:npf) = h_path(tan_pt_f+2:npf) / &
          & ( sqrt(h_path(tan_pt_f+2:npf)**2 - tan_ht**2 ) )
        path_dsdh(tan_pt_f:tan_pt_f+1) = 0.0

        dsdz_gw_path(f_inds(:nglMax)) = path_dsdh(f_inds(:nglMax)) * &
          & dhdz_gw_path(f_inds(:nglMax))

        ! We need dsdz = ds/dh * dh/dz, not multiplied by GW, for
        ! trapezoidal quadrature on the coarse grid.
        dsdz_c(:npc) = path_dsdh(c_inds) * dhdz_path(c_inds)

        ! Compute ALL the slabs_prep entities over the path's GL grid for this
        ! pointing & mmaf:
        if ( temp_der ) then
          call get_gl_slabs_arrays ( p_path(1:npf), t_path(1:npf), &
            &  est_los_vel(ptg_i), gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
            &  spect_v_path, lineCenter_ix, &
            &  spect_w_path, lineWidth_ix, &
            &  spect_n_path, lineWidth_TDep_ix, &
            &  t_der_path_flags(1:npf) )
        else
          call get_gl_slabs_arrays ( p_path(1:npf), t_path(1:npf), &
            &  est_los_vel(ptg_i), gl_slabs(1:npf,:), fwdModelConf%Do_1D, &
            &  spect_v_path, lineCenter_ix, &
            &  spect_w_path, lineWidth_ix, &
            &  spect_n_path, lineWidth_TDep_ix )
        end if

        ! If we're doing frequency averaging, get the frequencies we need for
        ! this pointing.

        if ( FwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) &
          & call frequency_setup_2 ( vel_cor * &
          & PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies )

        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_End ( 'ForwardModel.MetricsEtc' )

!{{\bfseries Notations}
! 
! $N_f$ is the number of points in the pointing frequency grid.\\
! $n$ is an index in the pointing frequency grid.\\
! $N_p$ is the number of points in the line-of-sight path.\\
! $i$ is an index in the line-of-sight path.  $c$ is a channel index.\\
! $s$ indicates a strong-line (LBL) result.
!   $w$ indicates a weak-line (PFA) result.\\
! $\delta I^\sigma_{iq} = \Delta B_{iq} \tau^\sigma_{iq}$ is the incremental
!  radiance contribution at the $i^{\text{th}}$ point along the line-of-sight
!  path, for $\sigma$ either $s$  or $w$ and $q$ either $c$ or $n$.
!
! There are four possible combinations of LBL, PFA and
! frequency-averaging.

!{{\bfseries Frequency averaged, LBL only}
!      \begin{equation*}\begin{split}
!       I^s_c = \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc}
!             \sum_{i=1}^{N_p} \delta I^s_{in}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I^s_n}{\partial x_k} =& 
!        \sum_{i=1}^{N_p}
!         \tau^s_{in} \frac{\partial \Delta B_{in}}{\partial x_k}
!         - \delta I^s_{in}
!          \sum_{j=1}^i \frac{\partial \delta^s_{jn}}{\partial x_k}\\
! %
!       \frac{\partial I_c}{\partial x_k} =&
!       \frac{\partial I^s_c}{\partial x_k} =
!        \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc}
!        \frac{\partial I^s_n}{\partial x_k}
!      \end{split}\end{equation*}

!{{\bfseries Monochromatic, LBL only}
!      \begin{equation*}
!       I^s_c = \sum_{i=1}^{N_p} \delta I^s_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I^s_c}{\partial x_k} =
!        \sum_{i=1}^{N_p}
!         \tau^s_{ic} \frac{\partial \Delta B_{ic}}{\partial x_k}
!         - \delta I^s_{ic}
!          \sum_{j=1}^i \frac{\partial \delta^s_{jc}}{\partial x_k}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!       \frac{\partial I^s_c}{\partial x_k}
!      \end{equation*}

!{{\bfseries Frequency averaged, PFA only}
!      \begin{equation*}
!       I_c = \sum_{i=1}^{N_p} \delta I^w_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!        \sum_{i=1}^{N_p}
!         \tau^w_{ic} \frac{\partial \Delta B_{ic}}{\partial x_k}
!           - \delta I^w_{ic}
!            \sum_{j=1}^i \frac{\partial \delta^w_{jc}}{\partial x_k}
!       \text{\phantom{xxxx}}
!      \end{equation*}

!{{\bfseries Frequency averaged, LBL and PFA}
!      \begin{equation*}
! %
!       \overline{\delta I^s_{ic}} =
!        \sum_{n=1}^{N_f} \phi_{nc} \Delta\nu_{nc} \delta I^s_{in}
!       \text{\phantom{xxxx}}
! %
!       I_{ic} = \overline{\delta I^s_{ic}} \tau^w_{ic}
!       \text{\phantom{xxxx}}
! %
!       I_c = \sum_{i=1}^{N_p} I_{ic}
!       \text{\phantom{xxxx}}
! %
!       \frac{\partial I_c}{\partial x_k} =
!       \frac{\partial I^s_c}{\partial x_k}
!        - \sum_{i=1}^{N_p} I_{ic}
!          \sum_{j=1}^i \frac{\partial \delta^w_{jc}}{\partial x_k}
!      \end{equation*}

!{{\bfseries Program variables}
! 
! \begin{tabular}{llll}
! $\Delta B_{in}$ is {\tt T\_Script\_LBL} &
! $\Delta B_{ic}$ is {\tt T\_Script\_PFA} &
! $\tau^s_{in}$ is {\tt Tau\_LBL} &
! $\tau^w_{ic}$ is {\tt Tau\_PFA}
! \\
! $\delta I^\sigma_{iq}$ is {\tt Inc\_Rad\_Path} &
! $\overline{\delta I^s_{ic}}$ is {\tt Rad\_Avg\_Path} & 
! $I_{ic}$ is also {\tt Rad\_Avg\_Path} &
! \\
! $\sum_{i=1}^{N_p} \delta I^\sigma_{iq}$ is {\tt RadV} & 
! $I_c$ or $I^s_c$ is {\tt Radiances} &
! $\frac{\partial I^\sigma_q}{\partial x_k}$ is {\tt K\_}$x${\tt\_FRQ} &
! $\frac{\partial I_c}{\partial x_k}$ is {\tt K\_}$x$
! \\
! \end{tabular}

        if ( FwdModelConf%anyLBL(sx) ) then
          call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:), c_inds,  &
            & del_s(:npc), del_zeta(:npc),do_calc_fzp(:npf,:),                    &
            & do_calc_zp(:npf,:), do_GL(:npc), frequencies, h_path_c,             &
            & incoptdepth(:npc), p_path(:npf), pfaFalse, ref_corr(:npc),          &
            & sps_path(:npf,:), tau_lbl, t_path_c(:npc), t_script_lbl(:npc,:),    &
            & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
          if ( print_TauL ) then
            call output ( thisSideband, before='Sideband ' )
            call output ( ptg_i, before=' Pointing ' )
            call dump ( tau_lbl, noFreqs, ' Tau_LBL:' )
            call dump ( t_script_lbl(:npc,:noFreqs), 'T_Script_LBL' )
          end if
        end if

        ! Handle PFA molecules
        if ( FwdModelConf%anyPFA(sx) ) then
          if ( frq_avg_sel == 15 ) then ! FRQ_avg + LBL + PFA + Derivs
            ! For every channel, frequency average the incremental radiance at
            ! every point along the path, giving Rad_Avg_Path for every channel
            ! and every point along the path.  Multiply by Tau_PFA to combine
            ! PFA contribution in Frequency_Loop.
            call frequency_avg_rad_path
            call frequency_average_derivatives ( .false. )
          end if
          call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:), c_inds, &
            & del_s(:npc), del_zeta(:npc), do_calc_fzp(:npf,:),                  &
            & do_calc_zp(:npf,:), do_GL(:npc), channelCenters, h_path_c,         &
            & incoptdepth(:npc), p_path(:npf), pfaTrue, ref_corr(:npc),          &
            & sps_path(:npf,:), tau_pfa, t_path_c(:npc), t_script_pfa(:npc,:),   &
            & tanh1_c(:npc), tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
          if ( print_TauP ) then
            call output ( thisSideband, before='Sideband ' )
            call output ( ptg_i, before=' Pointing ' )
            call dump ( tau_pfa, noUsedChannels, ' Tau_PFA:' )
            call dump ( t_script_pfa(:npc,:), 'T_Script_PFA' )
          end if

        end if

        call frequency_average ! or maybe just store

        ! If we're doing frequency averaging, there's a different frequency
        ! grid for each pointing, but we don't need to deallocate it here
        ! because the allocate_test in frequency_setup_2 will deallocate it.

        if ( toggle(emit) .and. levels(emit) > 3 ) &
          & call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )

        ! End of pointing loop -------------------------------------------------
      end do
d2551 576
d3225 1
a3225 1
    & "$Id: FullForwardModel_m.f90,v 2.281 2007/06/08 22:05:33 vsnyder Exp $"
d3234 3
@


2.281
log
@Faster d_delta_df = 0, metrics stuff
@
text
@d260 1
d274 1
a442 17
    logical :: DO_GL(max_c)       ! GL indicator
    logical :: T_der_path_flags(s_t*max_f) ! a flag that tells where an
      ! absorption coefficient is needed for a temperature derivative.
      ! Only useful when subsetting temperature derivatives.

    ! 'Avoid zeros' indicators
    logical :: DO_CALC_FZP(max_f, size(grids_f%values))
    logical :: DO_CALC_HYD(max_f, sv_t_len)
    logical :: DO_CALC_HYD_C(max_c, sv_t_len)  ! DO_CALC_HYD on coarse grid
    logical :: DO_CALC_N(max_f, size(grids_n%values) ) ! on entire grid
    logical :: DO_CALC_T(max_f, sv_t_len)
    logical :: DO_CALC_T_C(max_c, sv_t_len)    ! DO_CALC_T on coarse grid
    logical :: DO_CALC_T_F(max_f, sv_t_len)    ! DO_CALC_T on fine grid
    logical :: DO_CALC_V(max_f, size(grids_v%values) ) ! on entire grid
    logical :: DO_CALC_W(max_f, size(grids_w%values) ) ! on entire grid
    logical :: DO_CALC_ZP(max_f, grids_f%p_len)

d592 27
d745 1
a745 1
    do_zmin = index(switches, 'dozm') /= 0 ! Do minimum zeta unless told otherwise
d760 3
a762 5
    nullify ( cext_path, do_calc_Cext, do_calc_Cext_zp, do_calc_Salb, &
      & do_calc_Salb_zp, do_calc_tscat, do_calc_tscat_zp, eta_cext,   &
      & eta_cext_zp, eta_salb, eta_salb_zp, eta_tscat, eta_tscat_zp,  &
      & frequencies, inc_rad_path, k_atmos_frq, k_spect_dn_frq,       &
      & k_spect_dv_frq, k_spect_dw_frq, k_temp_frq, RadV, salb_path,  &
d765 4
d780 24
d1042 4
a1045 1
            ! Compute eta_zp & do_calc_zp (Zeta & Phi only) for water
d1047 2
a1048 1
              &  phi_path(1:npf), eta_zp(1:npf,:), do_calc_zp(1:npf,:), tan_pt=tan_pt_f )
d1078 2
a1079 1
            &  DO_CALC_T = do_calc_t(1:npf,:), ETA_ZXP = eta_zxp_t(1:npf,:) )
d1084 1
d1101 3
d1105 2
a1106 1
          &  phi_path(1:npf), eta_zp(1:npf,:), do_calc_zp(1:npf,:), tan_pt=tan_pt_f )
d1113 1
a1113 1
        call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
d1117 7
d1392 4
a1395 5
            & do_calc_zp(:npf,:), do_GL(:npc),                   &
            & eta_zp(:npf,:), frequencies, h_path_c, incoptdepth(:npc),           &
            & p_path(:npf), pfaFalse, ref_corr(:npc), sps_path(:npf,:),           &
            & tau_lbl, t_path_c(:npc), t_script_lbl(:npc,:), tanh1_c(:npc),       &
            & tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
d1416 4
a1419 5
            & do_calc_zp(:npf,:), do_GL(:npc),                  &
            & eta_zp(:npf,:), channelCenters, h_path_c, incoptdepth(:npc),       &
            & p_path(:npf), pfaTrue, ref_corr(:npc), sps_path(:npf,:),           &
            & tau_pfa, t_path_c(:npc), t_script_pfa(:npc,:), tanh1_c(:npc),      &
            & tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:npf) )
d2298 1
a2298 1
      & Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL, Eta_zp,           &
a2326 1
      real(rp), intent(in) :: Eta_zp(:,:) ! path x (Eta_z x Eta_p)
d2382 11
a2392 2
        call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
          & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp(:npf,:) )
d2452 3
a2454 3
          call comp_sps_path_frq ( Grids_tscat, firstSignal%lo, thisSideband, &
            & 0.0_r8, eta_tscat_zp(1:npf,:),                               &
            & do_calc_tscat_zp(1:npf,:), tscat_path(1:npf,:),              &
d2457 4
d2484 1
a2484 1
                               & 'do_calc_salb_zp', moduleName )
d2491 1
a2491 1
                               & 'do_calc_cext_zp', moduleName )
d2501 3
a2503 3
            call comp_sps_path_frq ( Grids_salb, firstSignal%lo, thisSideband, &
              & 0.0_r8, eta_salb_zp(1:npf,:),                                  &
              & do_calc_salb_zp(1:npf,:), salb_path(1:npf,:),                  &
d2506 4
d2515 3
a2517 3
            call comp_sps_path_frq ( Grids_cext, firstSignal%lo, thisSideband, &
              & 0.0_r8, eta_cext_zp(1:npf,:),                                  &
              & do_calc_cext_zp(1:npf,:), cext_path(1:npf,:),                  &
d2520 4
d2550 2
a2551 2
          call deallocate_test ( do_calc_cext,     'do_calc_salb',     moduleName )
          call deallocate_test ( do_calc_cext_zp,  'do_calc_salb_zp',  moduleName )
d2830 1
a2830 1
                            & frq, d_t_scr_dt(1:npc,:) )
d3219 1
a3219 1
    & "$Id: FullForwardModel_m.f90,v 2.280 2007/02/01 02:53:47 vsnyder Exp $"
d3228 3
@


2.280
log
@Stuff for min zeta and more intersections, plus cannonball polishing
@
text
@d25 4
a28 3
  integer, private, parameter :: Max_New = 10 ! Maximum new points in path
    ! in addition to ones derived from the preselected zeta grid, including
    ! the minimum zeta point.
d78 1
d139 18
a184 9
    temp_der = present ( jacobian ) .and. FwdModelConf%temp_der
    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der
    ptan_der = ptan_der .and. present ( jacobian )

    spect_der = present ( jacobian ) .and. FwdModelConf%spect_der
    spect_der_center = spect_der .and. size(fwdModelConf%lineCenter) > 0
    spect_der_width = spect_der .and. size(fwdModelConf%lineWidth) > 0
    spect_der_width_TDep = spect_der .and. size(fwdModelConf%lineWidth_TDep) > 0

d311 1
a311 1
    integer, parameter :: NXG = 2 + 4 * NG
d388 1
a388 1
    integer :: NZ_IF              ! Effective size of Z_GLgrid_o and cohorts
d427 1
a427 1
    character (len=32) :: SigName       ! Name of a Signal
d435 5
d733 3
a735 3
    do_zmin = index(switches, 'nozm') == 0 ! Do minimum zeta unless told otherwise
    print_more_points = index(switches, 'ZMOR' ) /= 1
    do_more_points = index(switches, 'zmor') /= 1
d758 8
d842 13
a878 1

d881 1
a881 1
        tan_pt_f = (nz_ig-1) * ngp1 + 2 - tan_ind_f ! fine path tangent index
d904 1
a918 11
        else ! Not an Earth-intersecting ray
          e_rflty = 1.0
          ! Use the "original" GL-grid arrays -- the ones filled before the
          ! sideband loop.  These depend only upon the original Zetas
          ! (Z_PSIG) derived from the L2CF using make_z_grid.
          ddhidhidtl0 => ddhidhidtl0_o
          dh_dt_glgrid => dh_dt_glgrid_o
          dhdz_glgrid => dhdz_glgrid_o
          h_glgrid => h_glgrid_o
          t_glgrid => t_glgrid_o
          z_glgrid => z_glgrid_o
d923 2
a924 2
          &  z_glgrid, h_glgrid, req, h_surf, h_tan, & ! in
          &  h_path(1:npf), phi_path(1:npf) )          ! out
a931 16
          if ( print_more_points .and. n_more > 0 ) then
            call output ( 'Found more intersections', advance='yes' )
            call output ( ptg_i, before='tan_phi(' )
            call output ( tan_phi(ptg_i), before =') = ' )
            call output ( tan_ind_f, before=', tan_ind_f = ' )
            call output ( req, before=', req = ', format = '(f7.2)' )
            call output ( h_surf, before=', h_surf = ', format = '(f7.2)' )
            call output ( h_tan, before=', h_tan = ', advance='yes' )
            call dump ( more_h_path(:n_more), name='more_h_path' )
            call dump ( more_phi_path(:n_more), name='more_phi_path' )
            call dump ( more_z_path(:n_more), name='more_z_path' )
            call dump ( h_glgrid+req-h_surf, name='h_glgrid' )
            call dump ( Grids_tmp%phi_basis, name='phi_basis' )
            call dump ( h_path(1:npf), name='h_path' )
            call dump ( phi_path(1:npf), name='phi_path' )
          end if
d954 21
a974 3
        call add_points ( more_h_path(:n_more), more_phi_path(:n_more), &
          &               more_z_path(:n_more), min_index, &
          &               z_coarse, h_path, phi_path, npc, npf, tan_pt_c, tan_pt_f )
d999 2
a1000 2
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis, &
            &  t_glgrid, dhdz_glgrid, phi_path(1:npf),        &
d1006 1
a1006 1
              &  phi_path(1:npf), eta_zp(1:npf,:), do_calc_zp(1:npf,:) )
d1028 1
a1028 1
            &  t_glgrid, dhdz_glgrid, phi_path(1:npf),                     &
d1043 2
a1044 2
          call more_metrics ( tan_ind_f, tan_pt_f, Grids_tmp%phi_basis, &
            &  t_glgrid, dhdz_glgrid, phi_path(1:npf),        &
d1058 1
a1058 1
          &  phi_path(1:npf), eta_zp(1:npf,:), do_calc_zp(1:npf,:) )
d1088 1
a1088 1
            & phi_path(1:npf), eta_zxp_v(1:npf,:), do_calc_v(1:npf,:) )
d1095 1
a1095 1
            & phi_path(1:npf), eta_zxp_w(1:npf,:), do_calc_w(1:npf,:) )
d1102 1
a1102 1
            & phi_path(1:npf), eta_zxp_n(1:npf,:), do_calc_n(1:npf,:) )
d1118 1
a1118 1
            &  phi_path(1:npf), eta_iwc_zp(1:npf,:) )
d1130 1
a1130 1
            &  phi_path(1:npf), eta_mag_zp(1:npf,:) )
d1337 1
a1337 1
            & do_calc_zp(:npf,:), do_GL(:npc), eta_fzp(:npf,:),                   &
d1362 1
a1362 1
            & do_calc_zp(:npf,:), do_GL(:npc), eta_fzp(:npf,:),                  &
d1692 1
a1692 1
      call compute_GL_grid ( z_psig(:nlvl), z_glgrid )
a1800 1
      ptg_i = 2
d1924 2
a1925 2
          if ( atmos_der ) &
            & call convolve_other_deriv ( convolve_support, maf, chanInd, &
d1929 1
d2100 2
a2101 2
      real(rp), intent(inout) :: K_FRQ(:,:) ! To be averaged  Frq X Grid
      real(r4), intent(out) :: K(:,:)       ! Averaged        Chan X Grid
d2177 1
a2187 1

d2190 2
a2191 2
          if ( fwdModelConf%moleculeDerivatives(k) ) &
            & call frequency_average_derivative ( grids_f, &
d2193 3
d2245 1
a2245 1
      & Del_Zeta, Do_Calc_fzp, Do_Calc_zp, Do_GL, Eta_fzp, Eta_zp,           &
a2273 1
      real(rp), intent(inout) :: Eta_fzp(:,:) ! path x (Eta_f x Eta_z x Eta_p)
d2331 1
a2331 1
          & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp )
d2388 1
a2388 1
            &  do_calc_tscat_zp(1:npf,:) )
d2433 1
a2433 1
              &  do_calc_salb_zp(1:npf,:) )
d2443 1
a2443 1
              &  do_calc_cext_zp(1:npf,:) )
d2716 1
a2716 1
          call drad_tran_df ( c_inds, gl_inds, del_zeta, Grids_f, &
d2720 3
a2722 1
            &  d_delta_df(1:npc,:), k_atmos_frq(frq_i,:) )
d2732 1
a2732 1
              &  tanh1_c(:npc), eta_fzp, do_calc_fzp, sps_path, del_s,     &
d3146 1
a3146 1
    & "$Id: FullForwardModel_m.f90,v 2.279 2007/01/20 01:08:08 vsnyder Exp $"
d3155 3
@


2.279
log
@Decrufting
@
text
@d25 4
d161 1
a161 1
    max_c = 2*nlvl + 3 ! Maximum coarse path length
d244 1
d273 2
a274 1
    use Metrics_m, only: More_Metrics, Height_Metrics, Tangent_Metrics
d369 1
a369 3
    integer :: Min_Index_c        ! If Min_Index > 0, P_Path(min_index_c) <=
                                  ! Min_Phi <= P_Path(min_index_c+ng+1) and
                                  ! min_index_c is a coarse path index.
d402 1
d407 1
a407 1
    logical :: Print_Min_Zeta     ! For debugging
d471 1
a475 2
    real(rp), target :: P_GLGRID_O(maxvert) ! Pressure on glGrid surfs, original
    real(rp), target :: P_GLGRID_R(maxvert+nxg) ! Pressure on glGrid surfs, revised
a631 1
    real(rp), pointer :: P_GLGRID(:)     ! Either P_GLgrid_O or P_GLgrid_R
d718 2
a720 1
    print_Min_Zeta = index(switches, 'zmin') /= 0
a864 1
            p_glgrid => p_glgrid_r(:nz_if)
d867 1
a867 1
            call compute_GL_grid ( z_ig(:nz_ig), p_glgrid, z_glgrid )
a890 1
          p_glgrid => p_glgrid_o
d902 24
d935 4
a938 39
            min_index_c = min_index - mod(min_index-1,ngp1)
            if ( min_index > tan_pt_f ) min_index_c = min_index_c + 1
            if ( min(abs(min_phi-phi_path(min_index)), &
              &      abs(min_phi-phi_path(min_index+1))) <= &
              &  min_phi_tol * (phi_path(min_index_c+ngp1)-phi_path(min_index_c)) ) then
              ! Min zeta very close to an existing point
              if ( abs(min_phi-phi_path(min_index)) > abs(min_phi-phi_path(min_index+1)) ) &
                & min_index = min_index+1
              ! Min_index is now the index of the point
              if ( min_index == min_index_c .or. min_index == min_index_c+ngp1 ) then
                ! Min_index is at a coarse grid point.
                ! All we need to do is change the zeta.
                min_index_c = min_index
                i = min_index / ngp1 + 1
                if ( print_Min_Zeta ) then
                  call output ( i, before='Replacing Z_Coarse(' )
                  call output ( z_coarse(i), before=') = ' )
                  call output ( min_zeta, before=' with minimum Zeta = ', advance='yes' )
                end if
                z_coarse(i) = min_zeta
                min_index_c = 0 ! Indicate nothing more to do
              end if
            end if
            if ( min_index_c > 0 ) then
              ! Min zeta not near an existing coarse point: add one to the path
              npc = npc + 1
              npf = npf + ngp1
              i = min_index_c / ngp1 + 1
              z_coarse(i+1:npc) = z_coarse(i:npc-1) ! Make room
              z_coarse(i) = min_zeta
              if ( print_Min_Zeta ) then
                call output ( min_zeta, before='Added minimum Zeta = ' )
                call output ( i, before=' after ', advance='yes' )
              end if
              if ( min_index_c < tan_pt_f ) then
                tan_pt_c = tan_pt_c + 1
                tan_pt_f = tan_pt_f + ngp1
              end if
            end if
d940 2
d944 4
d949 4
a952 4
        call compute_GL_grid ( z_coarse(:tan_pt_c), p_path(:tan_pt_f), &
          &                    z_path(:tan_pt_f) )
        call compute_GL_grid ( z_coarse(tan_pt_c+1:npc), p_path(tan_pt_f+1:npf), &
          &                    z_path(tan_pt_f+1:npf) )
a967 4
        if ( h2o_ind == 0 ) then
          call refractive_index ( p_path(1:npf), t_path(1:npf), n_path_f(1:npf) )
          n_path_c(:npc) = n_path_f(c_inds)
        end if
d969 2
a970 1
          ! Get t_path (and dhdz_path, which we don't need yet)
d984 3
d1049 5
a1660 1
      p_glgrid => p_glgrid_o
d1664 1
a1664 1
      call compute_GL_grid ( z_psig(:nlvl), p_glgrid, z_glgrid )
d3114 1
a3114 1
    & "$Id: FullForwardModel_m.f90,v 2.278 2007/01/19 02:38:53 vsnyder Exp $"
d3123 3
@


2.278
log
@Include water in phi refractive correction
@
text
@a76 1
    integer :: EXT_IND          ! Index of extinction inside f array
d131 1
a131 1
      & h2o_ind, ext_ind )
d195 9
a203 11
    call FullForwardModelAuto ( FwdModelConf, FwdModelIn, FwdModelExtra,     &
                              & FwdModelOut, oldIfm, FmStat, z_psig,         &
                              & tan_press, grids_tmp, grids_f, grids_mag,    &
                              & grids_iwc, grids_n, grids_v, grids_w,        &
                              & ptan, phitan, temp,                          &
                              & no_mol, noUsedChannels, no_sv_p_t, n_t_zeta, &
                              & sv_t_len, nlvl, no_tan_hts,                  &
                              & surfaceTangentIndex,                         &
                              & max_c, maxVert, max_f, EXT_ind, H2O_ind,     &
                              & ptan_der,                                    &
                              & s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i, &
d223 9
a231 11
  subroutine FullForwardModelAuto ( FwdModelConf, FwdModelIn, FwdModelExtra, &
                              & FwdModelOut, oldIfm, FmStat, z_psig,         &
                              & tan_press, grids_tmp,  grids_f, grids_mag,   &
                              & grids_iwc, grids_n, grids_v, grids_w,        &
                              & ptan, phitan, temp,                          &
                              & no_mol, noUsedChannels, no_sv_p_t, n_t_zeta, &
                              & sv_t_len, nlvl, no_tan_hts,                  &
                              & surfaceTangentIndex,                         &
                              & max_c, maxVert, max_f, EXT_ind, H2O_ind,     &
                              & ptan_der,                                    &
                              & s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i, &
d252 1
a252 2
    use ForwardModelIntermediate, only: ForwardModelIntermediate_t, &
                                    &   ForwardModelStatus_t, &
a290 1
use Get_Eta_Matrix_m, only: Get_Eta_Sparse
a298 1
    type(forwardModelIntermediate_T), intent(inout) :: oldIfm ! Workspace
a332 1
    integer, intent(in) :: EXT_IND          ! Index of extinction inside f array
a400 1
    logical :: Print_Grids        ! For debugging
a426 1
    logical :: DO_CALC_IWC(max_f, size(grids_iwc%values))
a434 1
    logical :: DO_CALC_W_C(max_c, size(grids_w%values) ) ! on coarse grid
a714 1
    print_Grids = index(switches, 'grids') /= 0
d977 2
a978 3
          call more_metrics ( tan_phi(ptg_i), tan_ind_f, tan_pt_f,          &
            &  Grids_tmp%phi_basis, z_glgrid, t_glgrid, h_path(1:npf),      &
            &  dhdz_glgrid, phi_path(1:npf),                                &
d1000 1
a1000 1
        ! Now get other metrics-related quantities, t_path, dhdz_path, dhdt_path
d1002 3
a1004 4
          call more_metrics ( tan_phi(ptg_i), tan_ind_f, tan_pt_f,          &
            &  Grids_tmp%phi_basis, z_glgrid, t_glgrid, h_path(1:npf),      &
            &  dhdz_glgrid, phi_path(1:npf),                                &
            &  t_path(1:npf), dhdz_path(1:npf),                             &
d1006 6
a1011 8
            &  DHTDTL0 = tan_dh_dt, DDHIDHIDTL0 = ddhidhidtl0,              &
            &  DDHTDHTDTL0 = tan_d2h_dhdt, DHIDTLM = dh_dt_glgrid,          &
            &  DHITDTLM = dh_dt_path(1:npf,:),                              &
            &  T_DERIV_FLAG = Grids_tmp%deriv_flags,                        &
            &  Z_BASIS = Grids_tmp%zet_basis,                               &
            &  ETA_ZXP = eta_zxp_t(1:npf,:),                                &
            &  DO_CALC_T = do_calc_t(1:npf,:),                              &
            &  DO_CALC_HYD = do_calc_hyd(1:npf,:) )
d1018 2
a1019 3
          call more_metrics ( tan_phi(ptg_i), tan_ind_f, tan_pt_f,          &
            &  Grids_tmp%phi_basis, z_glgrid, t_glgrid, h_path(1:npf),      &
            &  dhdz_glgrid, phi_path(1:npf),                                &
d1047 2
a1048 1
          ! because the refractive correction changes phi_path.
a1065 1
          do_calc_w_c(1:npc,:) = do_calc_w(c_inds,:)
d3113 1
a3113 1
    & "$Id: FullForwardModel_m.f90,v 2.277 2007/01/18 00:27:10 vsnyder Exp $"
d3122 3
@


2.277
log
@Split Pure_Metrics into Tangent_Metrics and Height_Metrics, insert Earth
intersection into Zeta grid.
@
text
@d249 1
a249 1
      & Comp_Sps_Path_No_Frq
d284 1
d297 1
a437 1
    logical :: DO_CALC_IWC_ZP(max_f, grids_iwc%p_len)
d478 2
a479 1
    real(rp) :: N_PATH_C(max_c)       ! Refractivity on coarse path
a523 1
    real(rp) :: ETA_IWC(max_f,size(grids_iwc%values))
a536 1
    real(rp) :: N_GLGRID(maxVert,no_sv_p_t)        ! N on glGrid surfs
a782 4
    !??? need to interpolate H2O from Grids_f basis to Grids_tmp basis
    ! Get index of refraction on the GL grid, not accounting for H2O
    call refractive_index ( p_glgrid, t_glgrid, n_glgrid )

a830 1
        z_glgrid => z_glgrid_o
d864 1
a864 2
        ! Handle Earth-intersecting ray
        if ( h_tan < 0.0 ) then
d892 1
a892 1
        else
d983 31
a1015 1
          ! Set up temperature representation basis stuff
d1017 2
a1018 3
            &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, t_glgrid,           &
            &  h_path(1:npf), dhdz_glgrid, FwdModelConf%refract,            &
            &  phi_path(1:npf),                                             &
d1036 2
a1037 3
            &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, t_glgrid,           &
            &  h_path(1:npf), dhdz_glgrid, FwdModelConf%refract,            &
            &  phi_path(1:npf),                                             &
d1048 1
a1048 3
        ! Now compute the eta_zp & do_calc_zp (for Zeta & Phi only)

        ! Things you do whether or not you are doing magnetic or cloud
d1053 1
a1053 1
        ! Now compute sps_path with a FAKE frequency, mainly to get the
d1064 2
a1068 3
        else
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path_c(1:npc) )
d1097 1
a1097 1
        if ( fwdModelConf%Incl_Cld ) then
d1106 1
a1106 2
            &  phi_path(1:npf), eta_iwc_zp(1:npf,:), &
            &  do_calc_iwc_zp(1:npf,:) )
d1109 2
a1110 5
        ! Frq = 0.0_r8
          call comp_sps_path_frq ( Grids_iwc, firstSignal%lo, thisSideband, &
            & 0.0_r8, eta_zp(1:npf,:), &
            & do_calc_iwc_zp(1:npf,:), iwc_path(1:npf,:),      &
            & do_calc_iwc(1:npf,:), eta_iwc(1:npf,:) )
d3131 1
a3131 1
    & "$Id: FullForwardModel_m.f90,v 2.276 2006/12/21 22:59:00 vsnyder Exp $"
d3140 4
@


2.276
log
@Get rid of some unused variables
@
text
@d88 2
a89 1
    integer :: MAX_C            ! Length of longest possible coarse path
d158 1
a158 1
    max_c = 2*nlvl + 1 ! Maximum coarse path length, Z_PSIG & minimum Zeta point
d270 1
a270 1
      & L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_VMR
d274 1
a274 1
    use Metrics_m, only: Pure_Metrics, More_Metrics
d297 4
d380 3
d388 1
a388 1
    integer :: TAN_IND_C          ! Index of tangent point in coarse grid
d480 2
a481 1
    real(rp) :: P_GLGRID(maxvert)     ! Pressure on glGrid surfs
d493 4
a496 2
    real(rp) :: Z_COARSE(max_c)       ! Z_PSIG & Z_min
    real(rp) :: Z_GLGRID(maxvert)     ! Zeta on initial glGrid surfs
d518 2
a519 1
    real(rp) :: DHDZ_GLGRID(maxVert,no_sv_p_t)     ! dH/dZ on glGrid surfs
d532 2
a533 1
    real(rp) :: H_GLGRID(maxVert,no_sv_p_t)        ! H on glGrid surfs
d544 2
a545 1
    real(rp) :: T_GLGRID(maxVert,no_sv_p_t)        ! Temp on glGrid surfs
d562 2
a563 1
    real(rp) :: DH_DT_GLGRID(maxVert,n_t_zeta,no_sv_p_t) ! Needed even if no temperature derivatives
d590 2
a591 1
    real(rp) :: DDHIDHIDTL0(maxVert,n_t_zeta,s_t*no_sv_p_t)
d609 1
a613 1
    real(rp) :: TAN_TEMP      ! Temperature at the tangent
d636 9
d687 1
d780 1
a780 1
        &  dhdz_glgrid, dh_dt_glgrid )
a823 3
        tan_ind_c = max(1,ptg_i-surfaceTangentIndex+1) ! On coarse grid
        tan_ind_f = (tan_ind_c-1) * ngp1 + 1           ! On fine GL grid

d828 33
a860 2
        tan_pt_f = MaxVert + 1 - tan_ind_f ! fine path tangent index
        tan_pt_c = (tan_pt_f + Ng) / Ngp1  ! coarse path tangent index
d864 4
a867 2
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.MetricsEtc' )
d869 2
a870 2
        ! Get H_Path and Phi_Path on the fine grid.
        if ( ptg_i < surfaceTangentIndex ) then
d872 26
a897 5
          call pure_metrics ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
            &  z_glgrid, h_glgrid, earthradc_sq,                              &
            &  h_path(1:npf), phi_path(1:npf), Req,                           &
            &  Tan_Press=tan_press(ptg_i),                                    &
            &  Surf_Temp=temp%values(1,windowstart:windowfinish) )
d899 11
a909 4
          e_rflty = 1.0_rp
          call pure_metrics ( tan_phi(ptg_i), tan_ind_f, Grids_tmp%phi_basis, &
            &  z_glgrid, h_glgrid, earthradc_sq,                              &
            &  h_path(1:npf), phi_path(1:npf), Req                   )
a910 1
        tan_ht = h_path(tan_pt_f)
d912 6
a917 2
        z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
        z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)
a996 1
            &  TAN_PHI_T=tan_temp,                                          &
d1016 1
a1016 2
            &  t_path(1:npf), dhdz_path(1:npf),                             &
            &  TAN_PHI_T=tan_temp )
a1516 4
      orbIncline => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_orbitInclination, config=fwdModelConf )
      spaceRadiance => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_spaceRadiance, config=fwdModelConf )
a1518 2
      refGPH => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_refGPH, config=fwdModelConf )
d1522 4
d1528 4
d1654 11
a1664 1
  ! Compute Gauss Legendre (GL) grid ---------------------------------------
d3078 1
d3116 1
a3116 1
    & "$Id: FullForwardModel_m.f90,v 2.275 2006/12/21 01:34:53 vsnyder Exp $"
d3125 3
@


2.275
log
@Finally implemented minimum Zeta
@
text
@d263 1
a263 1
    use GLnp, only: GW, GX, Lobatto, NG, NGP1
a507 1
    real(rp) :: DHDZ_PSIG(nlvl,no_sv_p_t)          ! dH/dZ on PSIG surfs
d3018 1
a3018 1
    & "$Id: FullForwardModel_m.f90,v 2.274 2006/12/20 21:22:16 vsnyder Exp $"
d3027 3
@


2.274
log
@Split metrics into pure H-Phi calculation, and everything else, in
preparation for inserting the minimum-Zeta point into the path.
@
text
@d263 1
a263 1
    use GLnp, only: GW, Lobatto, NG, NGP1
d274 1
d351 42
a392 36
    integer :: CHANNEL                  ! A Loop counter
    integer :: Frq_Avg_Sel              ! Summarizes combinations of PFA, LBL,
                                        ! Frequency averaging and derivatives.
                                        ! See Frequency_Average below.
    integer :: IER                      ! Status flag from allocates
    integer :: I                        ! Loop index and other uses .
    integer :: INST                     ! Relevant instance for temperature
    integer :: J                        ! Loop index and other uses ..
    integer :: K                        ! Loop index and other uses ..
    integer :: MAF                      ! MAF under consideration
    integer :: MIF                      ! MIF number for tan_press(ptg_i)
    integer :: NCG                      ! Number of panels needing GL = Size(cg_inds)
    integer :: NGLMAX                   ! NGL if all panels need GL
    integer :: NGL                      ! Total # of GL points = Size(gl_inds)
    integer :: NOFREQS                  ! Number of frequencies for a pointing
    integer :: NOUSEDDACS               ! Number of different DACS in this run.
    integer :: NPC                      ! Length of coarse path
    integer :: NPF                      ! Length of a gl path
    integer :: PTG_I                    ! Loop counter for the pointings
    integer :: SIDEBAND                 ! Either zero or from firstSignal
    integer :: SIGIND                   ! Signal index, loop counter
    integer :: SV_I                     ! Loop index and other uses .
    integer :: SX                       ! 1 = LSB, 2 = USB
    integer :: TAN_IND_C                ! Index of tangent point in coarse grid
    integer :: TAN_IND_F                ! Index of tangent point in fine grid
    integer :: TAN_PT_C                 ! Index of tangent point in coarse path
    integer :: TAN_PT_F                 ! Index of tangent point in fine path
    integer :: THISSIDEBAND             ! Loop counter for sidebands, -1 = LSB, +1 = USB
    integer :: WHICHPOINTINGGRID        ! Index into the pointing grids
    integer :: WINDOWFINISH             ! End of temperature `window'
    integer :: WINDOWSTART              ! Start of temperature `window'

    integer :: NoSurf                   ! Number of pressure levels
    integer :: NovmrSurf                ! Number of vmr levels
    integer :: Nspec                    ! No of species for cloud model
    integer :: Ispec                    ! Species index in cloud model
d394 1
a394 1
    logical :: Any_Der                  ! temp_der .or. atmos_der .or. spect_der
d396 2
a397 1
    logical :: Clean                    ! Used for dumping
d400 8
d440 7
d584 7
a590 14
    integer, dimension(:), pointer :: C_INDS   ! Indices on coarse grid
    integer, dimension(:), pointer :: GL_INDS  ! Index of GL points -- subset of f_inds
    integer, dimension(:), pointer :: LineCenter_IX ! Where are line center offsets?
    integer, dimension(:), pointer :: LineWidth_IX  ! Where are line width offsets?
    integer, dimension(:), pointer :: LineWidth_TDep_IX  ! Where are line width TDep offsets?
    integer, dimension(:), pointer :: USEDDACSSIGNALS ! Indices in FwdModelConf
                                               ! of signals for our dacs

    logical, dimension(:,:), pointer :: DO_CALC_Tscat ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_Salb  ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_cext  ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_Tscat_ZP ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_Salb_ZP  ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_Cext_ZP  ! 'Avoid zeros' indicator
d594 3
d605 1
a605 1
    real(rp), dimension(:), pointer :: CT           ! Cos(Theta), where theta
d607 6
a612 6
    real(r8), dimension(:), pointer :: FREQUENCIES  ! Frequencies to compute for
    real(rp), dimension(:), pointer :: H            ! Magnetic field on path, in
                                                    ! IFOVPP
    real(rp), dimension(:), pointer :: RADV         ! Radiances for 1 pointing on
                                                    ! Freq_Grid
    real(rp), dimension(:), pointer :: STCP         ! Sin(Theta) Cos(Phi) where
d617 3
a619 3
    real(rp), dimension(:), pointer :: STSP         ! Sin(Theta) Sin(Phi)
    real(rp), dimension(:,:), pointer :: Cext_PATH    ! Cloud extinction on path
    real(rp), dimension(:,:), pointer :: DACsStaging  ! Temporary space for DACS radiances
d622 15
a636 16
    real(rp), dimension(:,:), pointer :: ETA_Tscat    !
    real(rp), dimension(:,:), pointer :: ETA_Tscat_ZP !
    real(rp), dimension(:,:), pointer :: ETA_Salb     !
    real(rp), dimension(:,:), pointer :: ETA_Salb_ZP  !
    real(rp), dimension(:,:), pointer :: ETA_Cext     !
    real(rp), dimension(:,:), pointer :: ETA_Cext_ZP  !
    real(rp), dimension(:,:), pointer :: INC_RAD_PATH ! Incremental radiance
                                                      ! along the path
    real(rp), dimension(:,:), pointer :: K_ATMOS_FRQ  ! dI/dVMR, ptg.frq X vmr-SV
    real(rp), dimension(:,:), pointer :: K_SPECT_DN_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_SPECT_DV_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_SPECT_DW_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_TEMP_FRQ   ! dI/dT, ptg.frq X T-SV
    real(rp), dimension(:,:), pointer :: Salb_PATH    ! Single Scattering Albedo on path
    real(rp), dimension(:,:), pointer :: T_SCRIPT_LBL ! Delta_B in some notes
    real(rp), dimension(:,:), pointer :: Tscat_PATH   ! TScat on path
d643 2
a644 2
    real(rv), dimension(:,:), pointer :: L1BMIF_TAI   ! MIF Times
    real(rv), dimension(:,:), pointer :: MIFDEADTIME  ! Not collecting data
d699 12
a829 2
! This is where we need to insert the calculation of minimum Zeta.

d833 51
d885 4
a888 4
        call compute_GL_grid ( z_coarse(:npc), p_path, z_path )
        ! Assumes path is symmetric
        z_path(tan_pt_f+1:2*tan_pt_f) = z_path(tan_pt_f:1:-1)
        p_path(tan_pt_f+1:2*tan_pt_f) = p_path(tan_pt_f:1:-1)
d1049 1
a1049 2
          if ( index(switches,'mag') /= 0 ) then
            clean = index(switches,'clean') /= 0
d1231 1
a1231 1
          if ( index(switches,'taul') /= 0 ) then
d1256 1
a1256 1
          if ( index(switches,'taup') /= 0 ) then
d1323 1
a1323 1
    if ( index(switches, 'seez') /= 0 ) call dump_print_code
d1332 1
a1332 1
    if ( index(switches, 'rad') /= 0 ) then
d1674 2
a1675 3
      if ( index(switches,'ptg') /= 0 ) then
        call Dump ( ptg_angles, 'ptg_angles (before any patch)', format='(1PG22.17)' )
      end if
d1734 1
a1734 1
        if ( index(switches,'ptg') /= 0 ) &
d3019 1
a3019 1
    & "$Id: FullForwardModel_m.f90,v 2.273 2006/12/19 02:53:15 vsnyder Exp $"
d3028 4
@


2.273
log
@Change some names, send max coarse path from FullForwardModel to
FullForwardModelAuto instead of using 2*NLVL, get rid of STATUS
argument from Metrics, reference H_Path from Earth center instead
of surface.
@
text
@d273 1
a273 1
    use Metrics_m, only: Metrics
a372 1
    integer :: TAN_IND                  ! Index of tangent point in fine grid
d374 1
a498 1
    real(rp) :: H_PSIG(nlvl,no_sv_p_t)             ! H on PSIG surfs
a501 1
    real(rp) :: N_PSIG(nlvl,no_sv_p_t)             ! N on PSIG surfs
a509 1
    real(rp) :: T_PSIG(nlvl,no_sv_p_t)             ! Temp on PSIG surfs
a526 1
    real(rp) :: DH_DT_PSIG(nlvl,n_t_zeta,no_sv_p_t)
d578 1
a578 1
    real(rp) :: TAN_HT        ! Height at the tangent
a655 9
!   Extra DEBUG for Nathaniel and Bill
!   real(rp), dimension(:), pointer :: REQS         ! Accumulation of REQ
!   real(rp), dimension(:), pointer :: TAN_HTS      ! Accumulation of TAN_HT
!   real(rp), dimension(:), pointer :: TAN_TEMPS    ! Accumulation of TAN_TEMP

    ! ZVI's dumping ground for variables he's too busy to put in the right
    ! place, and doesn't want to write comments for


d713 1
a713 8
    ! On non-GL grids:
    call two_d_hydrostatic ( Grids_tmp, &
      &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
      &  0.001*refGPH%values(1,windowStart:windowFinish), z_psig, &
      &  orbIncline%values(1,maf)*Deg2Rad, t_psig, h_psig, &
      &  dhdz_psig, dh_dt_psig )
    call refractive_index ( 10.0**(-z_psig), t_psig, n_psig )
    ! On GL grids:
d770 1
a770 1
        tan_ind = (tan_ind_c-1) * ngp1 + 1             ! On fine GL grid
d776 2
a777 2
        tan_pt_f = MaxVert + 1 - tan_ind  ! fine path tangent index
        tan_pt_c = (tan_pt_f + Ng) / Ngp1 ! coarse path tangent index
d781 4
d787 4
a790 7
          call metrics ( tan_phi(ptg_i), tan_ind_c, Grids_tmp%phi_basis,   &
            &  z_psig, n_psig, h_psig, t_psig, dhdz_psig,                  &
            &  earthradc_sq, FwdModelConf%refract,                         &
            &  h_path(1:npc), phi_path(1:npc),                             &
            &  t_path(1:npc), dhdz_path(1:npc), Req,                       &
            &  TAN_PHI_H = tan_ht, TAN_PHI_T=tan_temp,                     &
            &  Tan_Press=tan_press(ptg_i),                                 &
d794 3
a796 7
          call metrics ( tan_phi(ptg_i), tan_ind_c, Grids_tmp%phi_basis,   &
            &  z_psig, n_psig, h_psig, t_psig, dhdz_psig,                  &
            &  earthradc_sq, FwdModelConf%refract,                         &
            &  h_path(1:npc), phi_path(1:npc),                             &
            &  t_path(1:npc), dhdz_path(1:npc), Req,                       &
            &  TAN_PHI_H = tan_ht, TAN_PHI_T = tan_temp                    &
            &  )
d798 1
a798 2

        tan_pt_c = npc / 2
d824 23
a846 41
        ! Compute h_path, t_path, dhdz_path, phi_path, dhdt_path

        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.MetricsEtc' )

        if ( ptg_i < surfaceTangentIndex ) then
          e_rflty = earthRefl%values(1,1)
          if ( temp_der ) then
            ! Set up temperature representation basis stuff
            call metrics ( tan_phi(ptg_i), tan_ind, Grids_tmp%phi_basis,     &
              &  z_glgrid, n_glgrid, h_glgrid, t_glgrid, dhdz_glgrid,        &
              &  earthradc_sq, FwdModelConf%refract,                         &
              &  h_path(1:npf), phi_path(1:npf),                             &
              &  t_path(1:npf), dhdz_path(1:npf), Req,                       &
              &  TAN_PHI_H=tan_ht, TAN_PHI_T=tan_temp,                       &
              &  Tan_Press=tan_press(ptg_i),                                 &
              &  Surf_Temp=temp%values(1,windowstart:windowfinish),          &
              !  Stuff for temperature derivatives:
              &  DHTDTL0 = tan_dh_dt, DDHIDHIDTL0 = ddhidhidtl0,             &
              &  DDHTDHTDTL0 = tan_d2h_dhdt, DHIDTLM = dh_dt_glgrid,         &
              &  DHITDTLM = dh_dt_path(1:npf,:),                             &
              &  T_DERIV_FLAG = Grids_tmp%deriv_flags,                       &
              &  Z_BASIS = Grids_tmp%zet_basis,                              &
              &  ETA_ZXP = eta_zxp_t(1:npf,:),                               &
              &  DO_CALC_T = do_calc_t(1:npf,:),                             &
              &  DO_CALC_HYD = do_calc_hyd(1:npf,:) )
            dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds,:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds,:)
            do_calc_t_c(1:npc,:) = do_calc_t(c_inds,:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds,:)
            t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
          else
            call metrics ( tan_phi(ptg_i), tan_ind, Grids_tmp%phi_basis,     &
              &  z_glgrid, n_glgrid, h_glgrid, t_glgrid, dhdz_glgrid,        &
              &  earthradc_sq, FwdModelConf%refract,                         &
              &  h_path(1:npf), phi_path(1:npf),                             &
              &  t_path(1:npf), dhdz_path(1:npf), Req,                       &
              &  TAN_PHI_H=tan_ht, TAN_PHI_T=tan_temp,                       &
              &  Tan_Press=tan_press(ptg_i),                                 &
              &  Surf_Temp=temp%values(1,windowstart:windowfinish) )
          end if
d848 6
a853 31
          e_rflty = 1.0_rp
          if ( temp_der ) then
            ! Set up temperature representation basis stuff
            call metrics ( tan_phi(ptg_i), tan_ind, Grids_tmp%phi_basis,     &
              &  z_glgrid, n_glgrid, h_glgrid, t_glgrid, dhdz_glgrid,        &
              &  earthradc_sq, FwdModelConf%refract,                         &
              &  h_path(1:npf), phi_path(1:npf),                             &
              &  t_path(1:npf), dhdz_path(1:npf), Req,                       &
              &  TAN_PHI_H = tan_ht, TAN_PHI_T = tan_temp,                   &
              !  Stuff for temperature derivatives:
              &  DHTDTL0 = tan_dh_dt, DDHIDHIDTL0 = ddhidhidtl0,             &
              &  DDHTDHTDTL0 = tan_d2h_dhdt, DHIDTLM = dh_dt_glgrid,         &
              &  DHITDTLM = dh_dt_path(1:npf,:),                             &
              &  T_DERIV_FLAG = Grids_tmp%deriv_flags,                       &
              &  Z_BASIS = Grids_tmp%zet_basis,                              &
              &  ETA_ZXP = eta_zxp_t(1:npf,:),                               &
              &  DO_CALC_T = do_calc_t(1:npf,:),                             &
              &  DO_CALC_HYD = do_calc_hyd(1:npf,:) )
            dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds,:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds,:)
            do_calc_t_c(1:npc,:) = do_calc_t(c_inds,:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds,:)
            t_der_path_flags(1:npf) = any(do_calc_t(1:npf,:),2)
          else
            call metrics ( tan_phi(ptg_i), tan_ind, Grids_tmp%phi_basis,     &
              &  z_glgrid, n_glgrid, h_glgrid, t_glgrid, dhdz_glgrid,        &
              &  earthradc_sq, FwdModelConf%refract,                         &
              &  h_path(1:npf), phi_path(1:npf),                             &
              &  t_path(1:npf), dhdz_path(1:npf), Req,                       &
              &  TAN_PHI_H = tan_ht, TAN_PHI_T = tan_temp )
          end if
a861 4
        ! Fill the diagnostic arrays for Nathaniel and Bill
!       tan_temps ( ptg_i ) = tan_temp
!       tan_hts ( ptg_i ) = tan_ht
!       reqs ( ptg_i ) = req
d983 1
a983 1
             & tan_ht, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
d988 1
a988 1
             & tan_ht, tan_phi(ptg_i), Req, 0.0_rp, ptg_angles(ptg_i),      &
d995 1
a995 1
                      &  Req+tan_ht, del_s(:npc), ref_corr(:npc), ier )
d1006 1
a1006 1
          & ( sqrt(h_path(:tan_pt_f-1)**2 - (Req+tan_ht)**2 ) )
d1008 1
a1008 1
          & ( sqrt(h_path(tan_pt_f+2:npf)**2 - (Req+tan_ht)**2 ) )
a1287 5
    ! Extra DEBUG for Nathaniel and Bill
!   call deallocate_test ( tan_hts,       'tan_hts',       moduleName )
!   call deallocate_test ( tan_temps,     'tan_temps',     moduleName )
!   call deallocate_test ( reqs,          'reqs',          moduleName )

a1335 3
      ! Extra DEBUG for Nathaniel and Bill
  !   nullify ( reqs, tan_hts, tan_temps )

a1493 5
      ! Extra DEBUG for Nathaniel and Bill
  !   call allocate_test ( tan_hts,       no_tan_hts, 'tan_hts',       moduleName )
  !   call allocate_test ( tan_temps,     no_tan_hts, 'tan_temps',     moduleName )
  !   call allocate_test ( reqs,          no_tan_hts, 'reqs',          moduleName )

d2571 1
a2571 1
              & ref_corr, Req + tan_ht, dh_dt_path(tan_pt_f,:),              &
d2618 1
a2618 1
              & Req + tan_ht, dh_dt_path(tan_pt_f,:),                       &
d2942 1
a2942 1
    & "$Id: FullForwardModel_m.f90,v 2.272 2006/12/13 02:32:02 vsnyder Exp $"
d2951 6
@


2.272
log
@Drag the tangent point around instead of assuming it's the middle one
@
text
@d80 1
a80 1
    integer :: Nlvl             ! Size of coarse integration grid
d84 1
a84 1
    integer :: MAXVERT          ! Total number of points in gl grid
d88 3
a90 1
    integer :: MAX_ELE          ! Length of longest possible path (all no_ele<max_ele)
d157 1
d159 1
a159 1
    max_ele = 2*(maxVert + size(Grids_tmp%phi_basis) + 1) ! maximum possible
d195 13
a207 12
    call FullForwardModelAuto ( FwdModelConf, FwdModelIn, FwdModelExtra, &
                             &  FwdModelOut, oldIfm, FmStat, z_psig, &
                             &  tan_press, grids_tmp, &
                             &  grids_f, grids_mag, grids_iwc, &
                             &  grids_n, grids_v, grids_w, &
                             &  ptan, phitan, temp, &
                             &  no_mol, noUsedChannels, no_sv_p_t, n_t_zeta, &
                             &  sv_t_len, nlvl, no_tan_hts, surfaceTangentIndex, &
                             &  maxVert, max_ele, EXT_ind, H2O_ind, ptan_der, &
                             &  s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i, &
                             !  Optional:
                             &  Jacobian )
d226 12
a237 11
                             &  FwdModelOut, oldIfm, FmStat, z_psig, &
                             &  tan_press, grids_tmp, &
                             &  grids_f, grids_mag, grids_iwc, &
                             &  grids_n, grids_v, grids_w, &
                             &  ptan, phitan, temp, &
                             &  no_mol, noUsedChannels, no_sv_p_t, n_t_zeta, &
                             &  sv_t_len, nlvl, no_tan_hts, surfaceTangentIndex, &
                             &  maxVert, max_ele, EXT_ind, H2O_ind, ptan_der, &
                             &  s_t, s_a, s_lc, s_lw, s_td, s_p, s_pfa, s_i, &
                             !  Optional:
                             &  Jacobian )
d258 1
a258 1
                                    &   B_Metrics, B_Ptg_Angles, B_Refraction
d323 1
a323 1
    integer, intent(in) :: Nlvl             ! Size of coarse integration grid
d327 2
a328 1
    integer, intent(in) :: MAXVERT          ! Total number of points in gl grid
d332 1
a332 1
    integer, intent(in) :: MAX_ELE          ! Length of longest possible path (all no_ele<max_ele)
a363 1
    integer :: NO_ELE                   ! Length of a gl path
d367 1
a367 1
    integer :: NPCMAX                   ! Max of NPC for all paths
d397 4
a400 4
    integer, target :: C_INDS_B(2*nlvl)   ! Base array for C_INDS
    integer :: CG_INDS(2*nlvl)    ! Indices on coarse grid where GL needed
    integer :: F_INDS(max_ele)    ! Indices on fine grid
    integer, target :: GL_INDS_B(max_ele) ! Base array for GL_INDS
d402 1
a402 1
    integer :: IPSD(s_i*max_ele)
d404 2
a405 2
    logical :: DO_GL(2*nlvl)      ! GL indicator
    logical :: T_der_path_flags(s_t*max_ele) ! a flag that tells where an
d410 13
a422 13
    logical :: DO_CALC_FZP(max_ele, size(grids_f%values))
    logical :: DO_CALC_IWC(max_ele, size(grids_iwc%values))
    logical :: DO_CALC_IWC_ZP(max_ele, grids_iwc%p_len)
    logical :: DO_CALC_HYD(max_ele, sv_t_len)
    logical :: DO_CALC_HYD_C(2*nlvl, sv_t_len) ! DO_CALC_HYD on coarse grid
    logical :: DO_CALC_N(max_ele, size(grids_n%values) ) ! on entire grid
    logical :: DO_CALC_T(max_ele, sv_t_len)
    logical :: DO_CALC_T_C(2*nlvl, sv_t_len)   ! DO_CALC_T on coarse grid
    logical :: DO_CALC_T_F(max_ele, sv_t_len)  ! DO_CALC_T on fine grid
    logical :: DO_CALC_V(max_ele, size(grids_v%values) ) ! on entire grid
    logical :: DO_CALC_W(max_ele, size(grids_w%values) ) ! on entire grid
    logical :: DO_CALC_W_C(2*nlvl, size(grids_w%values) ) ! on coarse grid
    logical :: DO_CALC_ZP(max_ele, grids_f%p_len)
d424 1
a424 1
    real(r8) :: WC(s_i*fwdModelConf%no_cloud_species, max_ele)
d427 4
a430 4
    real(rp) :: ALPHA_PATH_C(2*nlvl)  ! coarse grid abs coeff.
    real(rp) :: ALPHA_PATH_F(max_ele) ! fine grid abs coeff.
    real(rp) :: B(2*nlvl)             ! Planck radiation function
    real(rp) :: BETA_PATH_cloud_C(s_i*2*nlvl) ! Beta on path coarse
d432 17
a448 17
    real(rp) :: DALPHA_DT_PATH_C(2*nlvl)  ! dAlpha/dT on coarse grid
    real(rp) :: DALPHA_DT_PATH_F(max_ele) ! dAlpha/dT on fine grid
    real(rp) :: DEL_S(2*nlvl)         ! Integration lengths along path
    real(rp) :: DEL_ZETA(2*nlvl)      ! Integration lengths in Zeta coords
    real(rp) :: DHDZ_PATH(max_ele)    ! dH/dZ on path
    real(rp) :: DHDZ_GW_PATH(max_ele) ! dH/dZ * GW on path
    real(rp) :: DSDZ_C(2*nlvl)        ! ds/dH * dH/dZ on coarse path
    real(rp) :: DSDZ_GW_PATH(max_ele) ! ds/dH * dH/dZ * GW on path
    real(rp) :: DTanh_DT_C(2*nlvl)    ! 1/tanh1_c d/dT tanh1_c
    real(rp) :: DTanh_DT_F(max_ele)   ! 1/tanh1_f d/dT tanh1_f
    real(rp) :: H_PATH(max_ele)       ! Heights on path
    real(rp) :: H_PATH_C(2*nlvl)      ! H_PATH on coarse grid
    real(rp) :: H_PATH_F(max_ele)     ! H_PATH on fine grid
    real(rp) :: INCOPTDEPTH(2*nlvl)   ! Incremental Optical depth on coarse grid
    real(rp) :: N_PATH_C(2*nlvl)      ! Refractivity on coarse path
    real(rp) :: PATH_DSDH(max_ele)    ! dS/dH on path
    real(rp) :: PHI_PATH(max_ele)     ! Phi's on path, Radians
d450 1
a450 1
    real(rp) :: P_PATH(max_ele)       ! Pressure on path
d452 1
a452 1
    real(rp) :: REF_CORR(2*nlvl)      ! Refraction correction
d454 8
a461 8
    real(rp) :: TANH1_C(2*nlvl)       ! tanh(0.5 h nu / k T)
    real(rp) :: TANH1_F(max_ele)      ! tanh1 on fine grid
    real(rp) :: T_PATH(max_ele)       ! Temperatures on path
    real(rp) :: T_PATH_C(2*nlvl)      ! T_PATH on coarse grid
    real(rp) :: T_PATH_F(max_ele)     ! T_PATH on fine grid
    real(rp) :: TT_PATH_C(s_i*2*nlvl) ! tscat on path coarse
    real(rp) :: W0_PATH_C(s_i*2*nlvl) ! w0 on path coarse
    real(rp) :: Z_COARSE(2*(nlvl + size(grids_tmp%phi_basis) + 1)) ! Z_PSIG & Z(phi basis) & Z_min
d463 1
a463 1
    real(rp) :: Z_PATH(max_ele)       ! Zeta on fine grid path tangent grid and
d465 3
a467 3
    real(rp) :: BETA_PATH_C(2*nlvl,no_mol)  ! Beta on path coarse
    real(rp) :: BETA_PATH_F(max_ele,no_mol) ! Beta on path fine
    real(rp) :: D_DELTA_DF(s_a*2*nlvl,size(grids_f%values)) ! Incremental 
d470 1
a470 1
    real(rp) :: D_T_SCR_dT(2*nlvl,s_t*sv_t_len)  ! D Delta_B in some notes
d473 11
a483 11
    real(rp) :: DBETA_DN_PATH_C(2*nlvl,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on coarse grid
    real(rp) :: DBETA_DN_PATH_F(max_ele,s_td*size(fwdModelConf%lineWidth_TDep)) ! dBeta_dn on fine grid
    real(rp) :: DBETA_DT_PATH_C(2*nlvl,s_t*no_mol)  ! dBeta_dT on coarse grid
    real(rp) :: DBETA_DT_PATH_F(max_ele,s_t*no_mol) ! dBeta_dT on fine grid
    real(rp) :: DBETA_DV_PATH_C(2*nlvl,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on coarse grid
    real(rp) :: DBETA_DV_PATH_F(max_ele,s_lc*size(fwdModelConf%lineCenter)) ! dBeta_dv on fine grid
    real(rp) :: DBETA_DW_PATH_C(2*nlvl,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on coarse grid
    real(rp) :: DBETA_DW_PATH_F(max_ele,s_lw*size(fwdModelConf%lineWidth)) ! dBeta_dw on fine grid
    real(rp) :: DH_DT_PATH(max_ele,s_t*sv_t_len)   ! dH/dT on path
    real(rp) :: DH_DT_PATH_C(2*nlvl,s_t*sv_t_len)  ! DH_DT_PATH on coarse grid
    real(rp) :: DH_DT_PATH_F(max_ele,s_t*sv_t_len) ! DH_DT_PATH on fine grid
d487 11
a497 11
    real(rp) :: ETA_FZP(max_ele,size(grids_f%values)) ! Eta_z x Eta_p * Eta_f
    real(rp) :: ETA_IWC(max_ele,size(grids_iwc%values))
    real(rp) :: ETA_IWC_ZP(max_ele,grids_iwc%p_len)
    real(rp) :: ETA_Mag_ZP(max_ele,grids_mag%p_len) ! Eta_z x Eta_p
    real(rp) :: ETA_ZP(max_ele,grids_f%p_len)      ! Eta_z x Eta_p
    real(rp) :: ETA_ZXP_N(max_ele,size(grids_n%values)) ! Eta_z x Eta_p for N
    real(rp) :: ETA_ZXP_T(max_ele,s_t*sv_t_len)    ! Eta_t_z x Eta_t_p
    real(rp) :: ETA_ZXP_T_C(2*nlvl,s_t*sv_t_len)   ! ETA_ZXP_T on coarse grid
    real(rp) :: ETA_ZXP_T_F(max_ele,s_t*sv_t_len)  ! ETA_ZXP_T on fine grid
    real(rp) :: ETA_ZXP_V(max_ele,size(grids_v%values)) ! Eta_z x Eta_p for V
    real(rp) :: ETA_ZXP_W(max_ele,size(grids_w%values)) ! Eta_z x Eta_p for W
d500 2
a501 2
    real(rp) :: IWC_PATH(max_ele,s_i)              ! IWC on path
    real(rp), target :: MAG_PATH(s_p*max_ele,4)    ! Magnetic field on path
d504 1
a504 1
    real(rp), target :: RAD_AVG_PATH(2*nlvl,s_pfa*noUsedChannels) ! Freq. Avgd.
d507 4
a510 4
    real(rp) :: SPECT_N_PATH(max_ele,size(fwdModelConf%lineWidth_TDep)) ! Line Width Temperature Dependence
    real(rp) :: SPECT_V_PATH(max_ele,size(fwdModelConf%lineCenter)) ! Line Center
    real(rp) :: SPECT_W_PATH(max_ele,size(fwdModelConf%lineWidth)) ! Line Width
    real(rp) :: SPS_PATH(max_ele,no_mol)           ! species on path
d513 2
a514 2
    real(rp) :: T_SCRIPT_PFA(2*nlvl,s_pfa*noUsedChannels) ! Delta_B in some notes
    real(rp) :: TT_PATH(max_ele,s_i)               ! TScat on path along the LOS
d536 16
a551 16
    complex(rp) :: ALPHA_PATH_POLARIZED(-1:1,s_p*2*nlvl)
    complex(rp) :: ALPHA_PATH_POLARIZED_F(-1:1,s_p*max_ele)
    complex(rp) :: dALPHA_dT_POLARIZED_PATH_C(-1:1,s_p*s_t*2*nlvl)
    complex(rp) :: dALPHA_dT_POLARIZED_PATH_F(-1:1,s_p*s_t*max_ele)
    complex(rp) :: BETA_PATH_POLARIZED(-1:1,s_p*2*nlvl,no_mol)
    complex(rp) :: BETA_PATH_POLARIZED_F(-1:1,s_p*max_ele,no_mol)
    complex(rp) :: dBETA_dT_POLARIZED_PATH_C(-1:1,s_p*s_t*2*nlvl,no_mol)
    complex(rp) :: dBETA_dT_POLARIZED_PATH_F(-1:1,s_p*s_t*2*max_ele,no_mol)
    complex(rp) :: DE_DF(2,2,s_p*s_a*2*nlvl,size(grids_f%values)) ! DE/Df in Michael's notes
    complex(rp) :: DE_DT(2,2,s_p*s_t*2*nlvl,sv_t_len) ! DE/DT in Michael's notes
    complex(rp) :: DELTAU_POL(2,2,s_p*2*nlvl) ! E in Michael's notes
!   complex(rp) :: DINCOPTDEPTH_POL_DT(2,2,s_p*s_t*2*nlvl) ! D Incoptdepth_Pol / DT
!   complex(rp) :: GL_DELTA_POLARIZED(-1:1,s_p*max_ele)
    complex(rp) :: INCOPTDEPTH_POL(2,2,s_p*2*nlvl)
    complex(rp) :: PROD_POL(2,2,s_p*2*nlvl)   ! P in Michael's notes
    complex(rp) :: TAU_POL(2,2,s_p*2*nlvl)    ! Tau in Michael's notes
d775 1
a775 1
      call allocateSlabs ( gl_slabs, max_ele, &
d799 1
a799 1
        no_ele = 2 * tan_pt_f
d807 1
a807 1
            &  t_path(1:npc), dhdz_path(1:npc), Req, ier,                  &
d817 1
a817 1
            &  t_path(1:npc), dhdz_path(1:npc), Req, ier,                  &
d860 2
a861 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req, ier,            &
d868 1
a868 1
              &  DHITDTLM = dh_dt_path(1:no_ele,:),                          &
d871 3
a873 3
              &  ETA_ZXP = eta_zxp_t(1:no_ele,:),                            &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:) )
d878 1
a878 1
            t_der_path_flags(1:no_ele) = any(do_calc_t(1:no_ele,:),2)
d883 2
a884 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req, ier,            &
d896 2
a897 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req, ier,            &
d902 1
a902 1
              &  DHITDTLM = dh_dt_path(1:no_ele,:),                          &
d905 3
a907 3
              &  ETA_ZXP = eta_zxp_t(1:no_ele,:),                            &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:) )
d912 1
a912 1
            t_der_path_flags(1:no_ele) = any(do_calc_t(1:no_ele,:),2)
d917 2
a918 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req, ier,            &
a922 1
        if ( ier /= 0 ) fmStat%flags = ior(fmStat%flags,b_metrics)
a926 1
        h_path(1:no_ele) = req + h_path(1:no_ele)
d938 2
a939 2
        call comp_eta_docalc_no_frq ( Grids_f, z_path(1:no_ele), &
          &  phi_path(1:no_ele), eta_zp(1:no_ele,:), do_calc_zp(1:no_ele,:) )
d947 3
a949 3
          & 0.0_r8, eta_zp(1:no_ele,:),                   &
          & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:), &
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d963 4
a966 4
          call comp_eta_docalc_no_frq ( grids_v, z_path(1:no_ele), &
            & phi_path(1:no_ele), eta_zxp_v(1:no_ele,:), do_calc_v(1:no_ele,:) )
          call comp_sps_path_no_frq ( grids_v, eta_zxp_v(1:no_ele,:), &
            & spect_v_path(1:no_ele,:) )
d970 2
a971 2
          call comp_eta_docalc_no_frq ( grids_w, z_path(1:no_ele), &
            & phi_path(1:no_ele), eta_zxp_w(1:no_ele,:), do_calc_w(1:no_ele,:) )
d973 2
a974 2
          call comp_sps_path_no_frq ( grids_w, eta_zxp_w(1:no_ele,:), &
            & spect_w_path(1:no_ele,:) )
d978 4
a981 4
          call comp_eta_docalc_no_frq ( grids_n, z_path(1:no_ele), &
            & phi_path(1:no_ele), eta_zxp_n(1:no_ele,:), do_calc_n(1:no_ele,:) )
          call comp_sps_path_no_frq ( grids_n, eta_zxp_n(1:no_ele,:), &
            & spect_n_path(1:no_ele,:) )
d989 8
a996 8
          iwc_path(1:no_ele,1) = 0.
          WC(1,1:no_ele)=iwc_path(1:no_ele,1)
          WC(2,1:no_ele)=0.
          IPSD(1:no_ele)=1000

          call comp_eta_docalc_no_frq ( Grids_Iwc, z_path(1:no_ele), &
            &  phi_path(1:no_ele), eta_iwc_zp(1:no_ele,:), &
            &  do_calc_iwc_zp(1:no_ele,:) )
d1001 4
a1004 4
            & 0.0_r8, eta_zp(1:no_ele,:), &
            & do_calc_iwc_zp(1:no_ele,:), iwc_path(1:no_ele,:),      &
            & do_calc_iwc(1:no_ele,:), eta_iwc(1:no_ele,:) )
          WC(1,1:no_ele)=iwc_path(1:no_ele,1)
d1010 2
a1011 2
          call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:no_ele), &
            &  phi_path(1:no_ele), eta_mag_zp(1:no_ele,:) )
d1014 2
a1015 2
          call comp_sps_path ( Grids_mag, 1, eta_mag_zp(1:no_ele,:), &
            & mag_path(1:no_ele,1:3) )
d1019 1
a1019 1
          do j = 1, no_ele
d1036 4
a1039 4
          ct => mag_path(1:no_ele,3)   ! cos(theta)
          stcp => mag_path(1:no_ele,1) ! sin(theta) cos(phi)
          stsp => mag_path(1:no_ele,2) ! sin(theta) sin(phi)
          h => mag_path(1:no_ele,4)    ! magnitude of magnetic field
a1075 4
if ( any(h_path(:tan_pt_f-1)**2 - (Req+tan_ht)**2 <= 0.0) ) then
call dump ( h_path(:tan_pt_f-1), name='h_path(:tan_pt_f-1)' )
call output ( Req+tan_ht, before='Req+tan_ht = ', advance='yes' )
end if
d1078 2
a1079 6
if ( any(h_path(tan_pt_f+2:no_ele)**2 - (Req+tan_ht)**2 <= 0.0) ) then
call dump ( h_path(tan_pt_f+2:no_ele), name='h_path(tan_pt_f+2:no_ele)' )
call output ( Req+tan_ht, before='Req+tan_ht = ', advance='yes' )
end if
        path_dsdh(tan_pt_f+2:no_ele) = h_path(tan_pt_f+2:no_ele) / &
          & ( sqrt(h_path(tan_pt_f+2:no_ele)**2 - (Req+tan_ht)**2 ) )
d1092 2
a1093 2
          call get_gl_slabs_arrays ( p_path(1:no_ele), t_path(1:no_ele), &
            &  est_los_vel(ptg_i), gl_slabs(1:no_ele,:), fwdModelConf%Do_1D, &
d1097 1
a1097 1
            &  t_der_path_flags(1:no_ele) )
d1099 2
a1100 2
          call get_gl_slabs_arrays ( p_path(1:no_ele), t_path(1:no_ele), &
            &  est_los_vel(ptg_i), gl_slabs(1:no_ele,:), fwdModelConf%Do_1D, &
d1218 4
a1221 4
            & del_s(:npc), del_zeta(:npc),do_calc_fzp(:no_ele,:),                 &
            & do_calc_zp(:no_ele,:), do_GL(:npc), eta_fzp(:no_ele,:),             &
            & eta_zp(:no_ele,:), frequencies, h_path_c, incoptdepth(:npc),        &
            & p_path(:no_ele), pfaFalse, ref_corr(:npc), sps_path(:no_ele,:),     &
d1223 1
a1223 1
            & tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:no_ele) )
d1243 4
a1246 4
            & del_s(:npc), del_zeta(:npc), do_calc_fzp(:no_ele,:),               &
            & do_calc_zp(:no_ele,:), do_GL(:npc), eta_fzp(:no_ele,:),            &
            & eta_zp(:no_ele,:), channelCenters, h_path_c, incoptdepth(:npc),    &
            & p_path(:no_ele), pfaTrue, ref_corr(:npc), sps_path(:no_ele,:),     &
d1248 1
a1248 1
            & tt_path_c(:s_i*npc), w0_path_c(:s_i*npc), z_path(:no_ele) )
a1584 14
      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call Trace_Begin ( 'ForwardModel.Allocate' )
      end if

      tan_pt_f = maxVert
      npc = 2 * (tan_pt_f + Ng) / Ngp1
      ! MJS says that this is the same as npc = 2 * Nlvl

      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call Trace_End ( 'ForwardModel.Allocate' )
      end if

      npcmax = npc

d1586 1
a1586 1
        call allocate_test ( tau_PFA%tau, npcmax, noUsedChannels, 'Tau_PFA%Tau', &
d1610 5
a1614 5
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp, &
         & req_out, grids_f, h2o_ind, tan_chi_out, dh_dz_out, dx_dh_out, &
d1623 2
a1624 2
      call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
         & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
d1626 3
a1628 3
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp, &
         & req_out(1:1), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh,  &
d2258 1
a2258 1
          call allocate_test ( do_calc_tscat, no_ele, size(grids_tscat%values),           &
d2260 1
a2260 1
          call allocate_test ( do_calc_tscat_zp, no_ele, grids_tscat%p_len,               &
d2262 1
a2262 1
          call allocate_test ( eta_tscat,     no_ele, size(grids_tscat%values),           &
d2264 1
a2264 1
          call allocate_test ( eta_tscat_zp,  no_ele, grids_tscat%p_len,                  &
d2266 1
a2266 1
          call allocate_test ( tscat_path,    no_ele, fwdModelConf%num_scattering_angles, &
d2269 3
a2271 3
          call comp_eta_docalc_no_frq ( Grids_Tscat, z_path(1:no_ele), &
            &  phi_path(1:no_ele), eta_tscat_zp(1:no_ele,:),           &
            &  do_calc_tscat_zp(1:no_ele,:) )
d2275 3
a2277 3
            & 0.0_r8, eta_tscat_zp(1:no_ele,:),                               &
            & do_calc_tscat_zp(1:no_ele,:), tscat_path(1:no_ele,:),           &
            & do_calc_tscat(1:no_ele,:), eta_tscat(1:no_ele,:) )
d2280 2
a2281 2
          call interp_tscat ( tscat_path(1:no_ele,:), Scat_ang(:), &
            & phi_path(1:no_ele), tt_path(1:no_ele,:) )
d2300 2
a2301 2
            call allocate_test (do_calc_salb, no_ele, size(grids_salb%values),'do_calc_salb',moduleName)
            call allocate_test (do_calc_salb_zp, no_ele, grids_salb%p_len,               &
d2303 3
a2305 3
            call allocate_test (eta_salb,    no_ele, size(grids_salb%values), 'eta_salb', moduleName)
            call allocate_test (eta_salb_zp, no_ele, grids_salb%p_len, 'eta_salb_zp', moduleName)
            call allocate_test ( salb_path,  no_ele, 1, 'salb_path', moduleName )
d2307 2
a2308 2
            call allocate_test (do_calc_cext,no_ele,size(grids_cext%values),'do_calc_cext',moduleName)
            call allocate_test (do_calc_cext_zp, no_ele, grids_cext%p_len,               &
d2310 7
a2316 7
            call allocate_test (eta_cext,    no_ele, size(grids_cext%values), 'eta_cext', moduleName)
            call allocate_test (eta_cext_zp, no_ele, grids_cext%p_len,  'eta_cext_zp', moduleName)
            call allocate_test (cext_path,   no_ele, 1, 'cext_path', moduleName)

            call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:no_ele), &
              &  phi_path(1:no_ele), eta_salb_zp(1:no_ele,:),           &
              &  do_calc_salb_zp(1:no_ele,:) )
d2320 7
a2326 7
              & 0.0_r8, eta_salb_zp(1:no_ele,:),                               &
              & do_calc_salb_zp(1:no_ele,:), salb_path(1:no_ele,:),            &
              & do_calc_salb(1:no_ele,:), eta_salb(1:no_ele,:) )

            call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:no_ele), &
              &  phi_path(1:no_ele), eta_cext_zp(1:no_ele,:),           &
              &  do_calc_cext_zp(1:no_ele,:) )
d2330 3
a2332 3
              & 0.0_r8, eta_cext_zp(1:no_ele,:),                               &
              & do_calc_cext_zp(1:no_ele,:), cext_path(1:no_ele,:),            &
              & do_calc_cext(1:no_ele,:), eta_cext(1:no_ele,:) )
d2334 2
a2335 2
            call convert_grid ( salb_path(1:no_ele,:), cext_path(1:no_ele,:),  & 
                              & tt_path(1:no_ele,:), c_inds,                   & 
d2341 4
a2344 4
            call get_beta_path_cloud ( Frq, p_path, t_path(1:no_ele),      &
              &  tt_path(1:no_ele,:), c_inds,                              &
              &  beta_path_cloud_c(1:npc), w0_path_c,  tt_path_c,          &
              &  IPSD(1:no_ele),  WC(:,1:no_ele), fwdModelConf )
d2848 2
a2849 2
        call allocate_test ( T_Script_LBL, npcmax, maxNoPtgFreqs, 'T_Script_LBL', moduleName )
        call allocate_test ( tau_LBL%tau, npcmax, maxNoPtgFreqs, 'Tau_LBL%Tau', &
d2855 1
a2855 1
      call allocate_test ( inc_rad_path, npcmax, maxNoPtgFreqs, 'Inc_Rad_path', &
d3026 1
a3026 1
    & "$Id: FullForwardModel_m.f90,v 2.271 2006/12/08 23:57:08 vsnyder Exp $"
d3035 3
@


2.271
log
@Revise earth-intersecting metrics
@
text
@d819 5
a824 3
z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)

d835 1
a835 1
        call get_gl_inds ( do_gl(:npc), f_inds, cg_inds, nglMax, ncg )
d1050 1
a1050 1
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(npc/2),&
d1055 1
a1055 1
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path_c(npc/2),&
d1062 1
a1062 1
        call comp_refcor ( h_path_c(:npc), n_path_c(:npc), &
d1073 2
a1074 2
if ( any(h_path(:no_ele/2-1)**2 - (Req+tan_ht)**2 <= 0.0) ) then
call dump ( h_path(:no_ele/2-1), name='h_path(:no_ele/2-1)' )
d1077 4
a1080 4
        path_dsdh(:no_ele/2-1) = h_path(:no_ele/2-1) / &
          & ( sqrt(h_path(:no_ele/2-1)**2 - (Req+tan_ht)**2 ) )
if ( any(h_path(no_ele/2+2:no_ele)**2 - (Req+tan_ht)**2 <= 0.0) ) then
call dump ( h_path(no_ele/2+2:no_ele), name='h_path(no_ele/2+2:no_ele)' )
d1083 3
a1085 3
        path_dsdh(no_ele/2+2:no_ele) = h_path(no_ele/2+2:no_ele) / &
          & ( sqrt(h_path(no_ele/2+2:no_ele)**2 - (Req+tan_ht)**2 ) )
        path_dsdh(no_ele/2:no_ele/2+1) = 0.0
d2420 1
a2420 1
          call path_contrib ( incoptdepth, e_rflty, fwdModelConf%tolerance, &
d2465 1
a2465 1
          call path_contrib ( deltau_pol(:,:,1:npc), e_rflty, &
d2484 1
a2484 1
        do j = 2, npc/2
d2489 1
a2489 1
        do j = npc/2+1, npc-1
d2495 1
a2495 1
        call get_GL_inds ( do_gl, gl_inds_b, cg_inds, ngl, ncg )
d2538 2
a2539 2
            & alpha_path_c, ref_corr, incoptdepth, alpha_path_f(1:ngl),     &
            & dsdz_gw_path, tau )
d2588 1
a2588 1
          call rad_tran_pol ( gl_inds, cg_inds(1:ncg), e_rflty, del_zeta,    &
d2621 1
a2621 1
            &  inc_rad_path_slice, i_stop,                        &
d2641 1
a2641 1
              & d_rad_pol_df )
d2670 11
a2680 11
            call drad_tran_dt ( del_zeta, h_path_c,                         &
              & dh_dt_path_c(1:npc,:), alpha_path_c,                        &
              & dAlpha_dT_path_c(:npc), eta_zxp_t_c(1:npc,:),               &
              & do_calc_t_c(1:npc,:), do_calc_hyd_c(1:npc,:), del_s,        &
              & ref_corr, Req + tan_ht, dh_dt_path(tan_pt_f,:),             &
              & do_gl, gl_inds, h_path_f(:ngl), t_path_f(:ngl),             &
              & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),                  &
              & dAlpha_dT_path_f(:ngl), eta_zxp_t_f(:ngl,:),                &
              & do_calc_t_f(:ngl,:), path_dsdh, dhdz_gw_path, dsdz_gw_path, &
              & d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i),                   &
              & inc_rad_path_slice, i_stop, grids_tmp%deriv_flags,          &
d2710 2
a2711 2
            call get_d_deltau_pol_dT ( ct, stcp, stsp, t_path_f(:ngl),      &
              & alpha_path_polarized(:,1:p_stop),                           &
d2731 1
a2731 1
              & d_rad_pol_dt, d_t_scr_dt(1:npc,:) )
d2759 2
a2760 2
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, i_stop,       &
                &  k_spect_dw_frq(frq_i,:) )
d2768 2
a2769 2
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, i_stop,       &
                &  k_spect_dn_frq(frq_i,:) )
d2777 2
a2778 2
                &  ref_corr, dhdz_gw_path, inc_rad_path_slice, i_stop,       &
                &  k_spect_dv_frq(frq_i,:) )
d3045 1
a3045 1
    & "$Id: FullForwardModel_m.f90,v 2.270 2006/12/04 21:17:28 vsnyder Exp $"
d3054 3
@


2.270
log
@Reorganize FullForwardModel to use automatic arrays instead of allocating
pointer arrays.  Requires testing for zero size instead of testing for
associated in several subsidiary procedures.
@
text
@a576 2
    real(rp) :: NEG_TAN_HT    ! GP Height (in KM.) of tan. press.
                              ! below surface
a790 1
        ! allocate the path stuff
d794 1
a794 1
        no_ele = 2*tan_pt_f
a795 1
        ! Add temperature phi basis and minimum zeta to coarse grid
a796 2
          neg_tan_ht = temp%values(1,(windowstart+windowfinish)/2) *       &
            &  (tan_press(ptg_i) - z_psig(1)) / 14.8_rp
d804 2
a805 2
!           &  Z_Grid = z_coarse, N_Path_Out = npc,                        &
            &  NEG_H_TAN=neg_tan_ht )
a813 1
!           &, Z_Grid = z_coarse, N_Path_Out = npc                         &
a846 2
          neg_tan_ht = temp%values(1,(windowstart+windowfinish)/2) * &
            &  (tan_press(ptg_i) - z_glgrid(1)) / 14.8_rp
a847 1

d855 3
a857 1
              &  TAN_PHI_H=tan_ht, TAN_PHI_T=tan_temp, NEG_H_TAN=neg_tan_ht, &
d878 3
a880 1
              &  TAN_PHI_H=tan_ht, TAN_PHI_T=tan_temp, NEG_H_TAN=neg_tan_ht )
a881 3

! Tan heights for negative tan height from metrics is not correctly working.

d3043 1
a3043 1
    & "$Id: FullForwardModel_m.f90,v 2.267 2006/08/25 19:42:31 vsnyder Exp $"
d3052 5
@


2.269
log
@Clean up some surds of ASSOCIATED->SIZE transition
@
text
@d27 2
a28 1
!---------------------------------------------  FullForwardModel  -------------
d32 2
a33 1
  ! This is the full radiative transfer forward model, the workhorse code
d35 205
a239 2
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST, E_RP=>E_DP, &
      & Test_Allocate, Test_Deallocate
a244 4
    use Compute_Z_PSIG_m, only: Compute_Z_PSIG
    use Convolve_All_m, only: Convolve_Radiance, Convolve_Temperature_Deriv, &
      & Convolve_Other_Deriv, Interpolate_Radiance, &
      & Interpolate_Temperature_Deriv, Interpolate_Other_Deriv
a249 1
      & DeriveFromForwardModelConfig, DestroyForwardModelDerived, &
a254 2
    use FOV_Convolve_m, only: Convolve_Support_T, FOV_Convolve_Setup, &
      & FOV_Convolve_Teardown, No_FFT
a257 2
    use Get_Chi_Out_m, only: Get_Chi_Out
    use Get_Species_Data_M, only:  Get_Species_Data
d259 1
a259 1
    use Intrinsic, only: L_A, L_BOUNDARYPRESSURE, L_CLEAR, L_CLOUDICE, &
d261 4
a264 4
      & L_ELEVOFFSET, L_GPH, L_L1BMIF_TAI, &
      & L_LOSVEL, L_LIMBSIDEBANDFRACTION, L_MAGNETICFIELD, L_MIFDEADTIME, &
      & L_ORBITINCLINATION, L_PHITAN, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, &
      & L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_TEMPERATURE, L_VMR
d266 1
a266 2
      & Load_One_Item_Grid, Load_Sps_Data, Modify_values_for_supersat
    use ManipulateVectorQuantities, only: DoHGridsMatch, FindOneClosestInstance
d269 1
a269 1
    use MLSKinds, only: R4, R8, RP, RV, IP
d271 1
a271 2
    use MLSNumerics, only: Coefficients => Coefficients_r8, Hunt, &
      & InterpolateArraySetup, InterpolateArrayTeardown, InterpolateValues
d295 44
a340 7
    !--------------------------------------------
    real(r8), dimension(:,:), pointer :: WC
    real(r8), dimension(:), pointer :: Scat_ang
    real(r8), dimension(:), pointer :: gph_prof
    integer, dimension(:), pointer :: IPSD
    !--------------------------------------------

a344 4
    integer :: EXT_IND                  ! Index of extinction inside f array
    integer :: F_LEN_N                  ! Length of N in vector
    integer :: F_LEN_V                  ! Length of V in vector
    integer :: F_LEN_W                  ! Length of W in vector
a347 1
    integer :: H2O_IND                  ! Index of h2o inside f array, else zero
a353 8
    integer :: MAX_ELE                  ! Length of longest possible path (all no_ele<max_ele)
    integer :: MAXCOARSE                ! Max. no. of points in coarse Z grid
    integer :: MAXNOFREQS               ! Max. no. frequencies for any molecule
    integer :: MAXNOSURFS               ! Max. no. surfaces for any molecule
    integer :: MAXVERT                  ! Total number of points in gl grid
                                        ! NLVL * (NG+1) - NG, i.e., 1 + NG
                                        ! per level, except the last, where
                                        ! there's no GL space.
a357 1
    integer :: Nlvl                     ! Size of coarse integration grid
a359 3
    integer :: NO_MOL                   ! Number of molecules' beta groups
    integer :: NO_TAN_HTS               ! Number of tangent heights
    integer :: NOUSEDCHANNELS           ! How many channels are we considering
a362 1
    integer :: N_T_ZETA                 ! Number of zetas for temperature
a363 2
    integer :: PTG_J                    ! Loop counter for patching the pointings
    integer :: PTG_K                    ! Loop counter for patching the pointings
a365 2
    integer :: SURFACETANGENTINDEX      ! Index in tangent grid of earth's
                                        ! surface
a366 1
    integer :: SV_T_LEN                 ! Number of t_phi*t_zeta in the window
d384 1
a384 1
    logical :: do_cld = .false.
d387 1
a387 1
    logical :: temp_der, atmos_der, spect_der, ptan_der ! Flags for various derivatives
a388 1
    logical :: PATCHEDAPTG              ! Used in patching the pointings
d392 167
a558 1
    logical :: Clean                    ! Used for dumping
a560 3
    integer, dimension(:), pointer :: C_INDS_B ! Base array for C_INDS
    integer, dimension(:), pointer :: CG_INDS  ! Indices on coarse grid where GL needed
    integer, dimension(:), pointer :: F_INDS   ! Indices on fine grid
a561 2
    integer, dimension(:), pointer :: GL_INDS_B ! Base array for GL_INDS
    integer, dimension(:), pointer :: GRIDS ! Heights in ptgGrid for each tangent
d566 1
a566 3
                                         ! of signals for our dacs

    logical, dimension(:), pointer :: DO_GL ! GL indicator
a567 6
    logical, dimension(:,:), pointer :: DO_CALC_N     ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_V     ! 'Avoid zeros'             
    logical, dimension(:,:), pointer :: DO_CALC_W     ! 'Avoid zeros'             
    logical, dimension(:,:), pointer :: DO_CALC_W_C   ! DO_CALC_W  on coarse grid 
    logical, dimension(:,:), pointer :: DO_CALC_FZP   ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_IWC   ! 'Avoid zeros' indicator
a570 7
    logical, dimension(:,:), pointer :: DO_CALC_HYD   ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_HYD_C ! DO_CALC_HYD on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_T     ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_T_C   ! DO_CALC_T on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_T_F   ! DO_CALC_T on fine grid
    logical, dimension(:,:), pointer :: DO_CALC_ZP    ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP   ! 'Avoid zeros' indicator
a573 3
    logical, dimension(:), pointer :: t_der_path_flags! a flag that tells the
! where an absorption coefficient is needed for a temperature derivative.
! Only useful when subsetting temperature derivatives.
a574 3
! Array of Flags indicating  which Temp. coefficient to process

    real(rp) :: DELTAPTG      ! Used for patching the pointings
a586 5
    real(rp), dimension(:), pointer :: ALPHA_PATH_C ! coarse grid abs coeff.
    real(rp), dimension(:), pointer :: ALPHA_PATH_F ! fine grid abs coeff.
    real(rp), dimension(:), pointer :: B            ! Planck radiation function
    real(rp), dimension(:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse
    real(r8), dimension(:), pointer :: ChannelCenters ! for PFA
a588 10
    real(rp), dimension(:), pointer :: DALPHA_DT_PATH_C ! dAlpha/dT on coarse grid
    real(rp), dimension(:), pointer :: DALPHA_DT_PATH_F ! dAlpha/dT on fine grid
    real(rp), dimension(:), pointer :: DEL_S        ! Integration lengths along path
    real(rp), dimension(:), pointer :: DEL_ZETA     ! Integration lengths in Zeta coords
    real(rp), dimension(:), pointer :: DHDZ_PATH    ! dH/dZ on path
    real(rp), dimension(:), pointer :: DHDZ_GW_PATH ! dH/dZ * GW on path
    real(rp), dimension(:), pointer :: DSDZ_C       ! ds/dH * dH/dZ on coarse path
    real(rp), dimension(:), pointer :: DSDZ_GW_PATH ! ds/dH * dH/dZ * GW on path
    real(rp), dimension(:), pointer :: DTanh_DT_C   ! 1/tanh1_c d/dT tanh1_c
    real(rp), dimension(:), pointer :: DTanh_DT_F   ! 1/tanh1_f d/dT tanh1_f
a591 11
    real(rp), dimension(:), pointer :: H_PATH       ! Heights on path
    real(rp), dimension(:), pointer :: H_PATH_C     ! H_PATH on coarse grid
    real(rp), dimension(:), pointer :: H_PATH_F     ! H_PATH on fine grid
    real(rp), dimension(:), pointer :: INCOPTDEPTH  ! Incremental Optical depth
    real(rp), dimension(:), pointer :: N_PATH_C     ! Refractivity on coarse path
    real(rp), dimension(:), pointer :: PATH_DSDH    ! dS/dH on path
    real(rp), dimension(:), pointer :: P_GLGRID     ! Pressure on glGrid surfs
    real(rp), dimension(:), pointer :: PHI_PATH     ! Phi's on path, Radians
    real(rp), dimension(:), pointer :: P_PATH       ! Pressure on path
    real(rp), dimension(:), pointer :: PTG_ANGLES   ! (no_tan_hts)
    real(r8), dimension(:), pointer :: RAD_FFT      ! Convolved radiance on FFT grid
a593 1
    real(rp), dimension(:), pointer :: REF_CORR     ! Refraction correction
d600 2
a601 13
    real(rp), dimension(:), pointer :: TAN_DH_DT    ! dH/dT at Tangent
    real(rp), dimension(:), pointer :: TANH1_C      ! tanh(0.5 h nu / k T)
    real(rp), dimension(:), pointer :: TANH1_F      ! tanh1 on fine grid
    real(rp), dimension(:), pointer :: T_PATH       ! Temperatures on path
    real(rp), dimension(:), pointer :: T_PATH_C     ! T_PATH on coarse grid
    real(rp), dimension(:), pointer :: T_PATH_F     ! T_PATH on fine grid
    real(rp), dimension(:), pointer :: TT_PATH_C    ! tscat on path coarse
    real(rp), dimension(:), pointer :: W0_PATH_C    ! w0 on path coarse
    real(rp), dimension(:), pointer :: Z_COARSE     ! Z_PSIG & Z(phi basis) & Z_min
    real(rp), dimension(:), pointer :: Z_GLGRID     ! Zeta on initial glGrid surfs
    real(rp), dimension(:), pointer :: Z_PATH       ! Zeta on fine grid path
    real(rp), dimension(:), pointer :: Z_PSIG       ! Surfs from Temperature,
    ! tangent grid and species grids, sans duplicates.
a602 3
    real(rp), dimension(:,:), pointer :: BETA_PATH_C  ! Beta on path coarse
    real(rp), dimension(:,:), pointer :: BETA_PATH_F  ! Beta on path fine
    real(rp), dimension(:,:), pointer :: Cext_PATH    ! Cloud extinction on path
a603 24
    real(rp), dimension(:,:), pointer :: D_DELTA_DF   ! Incremental opacity derivative
                                           ! schlep from drad_tran_dt to
                                           ! get_d_deltau_pol_df.  Path x SVE.
    real(rp), dimension(:,:), pointer :: D_T_SCR_dT   ! D Delta_B in some notes
                                           ! path x state-vector-components
    real(rp), dimension(:,:), pointer :: D2X_DXDT     ! (No_tan_hts, nz*np)
    real(rp), dimension(:,:), pointer :: DACsStaging  ! Temporary space for DACS radiances
    real(rp), dimension(:,:), pointer :: DBETA_DN_PATH_C ! dBeta_dn on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DN_PATH_F ! dBeta_dn on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_C ! dBeta_dT on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_F ! dBeta_dT on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DV_PATH_C ! dBeta_dv on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DV_PATH_F ! dBeta_dv on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DW_PATH_C ! dBeta_dw on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DW_PATH_F ! dBeta_dw on fine grid
    real(rp), dimension(:,:), pointer :: DH_DT_PATH_C ! DH_DT_PATH on coarse grid
    real(rp), dimension(:,:), pointer :: DH_DT_PATH   ! dH/dT on path
    real(rp), dimension(:,:), pointer :: DH_DT_PATH_F ! DH_DT_PATH on fine grid
    real(rp), dimension(:,:), pointer :: DHDZ_GLGRID  ! dH/dZ on glGrid surfs
    real(rp), dimension(:,:), pointer :: DHDZ_PSIG    ! dH/dZ on PSIG surfs
    real(rp), dimension(:,:), pointer :: DX_DT        ! (No_tan_hts, nz*np)
    real(rp), dimension(:,:), pointer :: ETA_FZP      ! Eta_z x Eta_p * Eta_f
    real(rp), dimension(:,:), pointer :: ETA_IWC      !
    real(rp), dimension(:,:), pointer :: ETA_Iwc_ZP   !
a609 10
    real(rp), dimension(:,:), pointer :: ETA_Mag_ZP   ! Eta_z x Eta_p
    real(rp), dimension(:,:), pointer :: ETA_ZP       ! Eta_z x Eta_p
    real(rp), dimension(:,:), pointer :: ETA_ZXP_N    ! Eta_z x Eta_p for N
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T_C  ! ETA_ZXP_T on coarse grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T    ! Eta_t_z x Eta_t_p
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T_F  ! ETA_ZXP_T on fine grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_V    ! Eta_z x Eta_p for V
    real(rp), dimension(:,:), pointer :: ETA_ZXP_W    ! Eta_z x Eta_p for W
    real(rp), dimension(:,:), pointer :: H_GLGRID     ! H on glGrid surfs
    real(rp), dimension(:,:), pointer :: H_PSIG       ! H on PSIG surfs
a611 1
    real(rp), dimension(:,:), pointer :: IWC_PATH     ! IWC on path
a616 8
    real(rv), dimension(:,:), pointer :: L1BMIF_TAI   ! MIF Times
    real(rp), dimension(:,:), pointer :: MAG_PATH     ! Magnetic field on path
    real(rv), dimension(:,:), pointer :: MIFDEADTIME  ! Not collecting data
    real(rp), dimension(:,:), pointer :: N_GLGRID     ! N on glGrid surfs
    real(rp), dimension(:,:), pointer :: N_PSIG       ! N on PSIG surfs
    real(rp), dimension(:,:), pointer :: RAD_AVG_PATH ! Freq. Avgd. LBL radiance
                                                      ! along the path
    real(rp), dimension(:,:), pointer :: RADIANCES    ! (Nptg,noChans)
a617 6
    real(rp), dimension(:,:), pointer :: SPECT_N_PATH ! Line Width Temperature Dependence
    real(rp), dimension(:,:), pointer :: SPECT_V_PATH ! Line Center
    real(rp), dimension(:,:), pointer :: SPECT_W_PATH ! Line Width
    real(rp), dimension(:,:), pointer :: SPS_PATH     ! species on path
    real(rp), dimension(:,:), pointer :: T_GLGRID     ! Temp on glGrid surfs
    real(rp), dimension(:,:), pointer :: T_PSIG       ! Temp on PSIG surfs
a618 1
    real(rp), dimension(:,:), pointer :: T_SCRIPT_PFA ! Delta_B in some notes
a619 2
    real(rp), dimension(:,:), pointer :: TT_PATH      ! TScat on path along the LOS
    real(r8), dimension(:,:), pointer :: VMRARRAY     ! The VMRs
d621 9
a629 32
    real(rp), dimension(:,:,:), pointer :: DH_DT_GLGRID ! *****
    real(rp), dimension(:,:,:), pointer :: DH_DT_PSIG   ! *****

    real(rp), dimension(:,:,:), pointer :: DACsStaging2 ! Temporary space for DACS radiances


    complex(rp), pointer :: D_RAD_POL_DF(:,:,:) ! From mcrt_der
    complex(rp), pointer :: D_RAD_POL_DT(:,:,:) ! From mcrt_der
    complex(rp) :: RAD_POL(2,2)  ! polarized radiance output of mcrt for one freq and pointing

    complex(rp), dimension(:,:), pointer :: ALPHA_PATH_POLARIZED
    complex(rp), dimension(:,:), pointer :: ALPHA_PATH_POLARIZED_F
    complex(rp), dimension(:,:), pointer :: dALPHA_dT_POLARIZED_PATH_C
    complex(rp), dimension(:,:), pointer :: dALPHA_dT_POLARIZED_PATH_F
      ! (-1,:,:) are Sigma_-, (0,:,:) are Pi, (+1,:,:) are Sigma_+
    complex(rp), dimension(:,:,:), pointer :: BETA_PATH_POLARIZED
    complex(rp), dimension(:,:,:), pointer :: BETA_PATH_POLARIZED_F
    complex(rp), dimension(:,:,:), pointer :: dBETA_dT_POLARIZED_PATH_C
    complex(rp), dimension(:,:,:), pointer :: dBETA_dT_POLARIZED_PATH_F
    complex(rp), dimension(:,:,:,:), pointer :: DE_DF    ! DE/Df in Michael's notes
    complex(rp), dimension(:,:,:,:), pointer :: DE_DT    ! DE/DT in Michael's notes
    complex(rp), dimension(:,:,:), pointer :: DELTAU_POL ! E in Michael's notes
    complex(rp), dimension(:,:,:), pointer :: DINCOPTDEPTH_POL_DT ! D Incoptdepth_Pol / DT
    complex(rp), dimension(:,:),   pointer :: GL_DELTA_POLARIZED
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL ! 2 x 2 x path
    complex(rp), dimension(:,:,:), pointer :: PROD_POL ! P in Michael's notes
    complex(rp), dimension(:,:,:), pointer :: TAU_POL  ! Tau in Michael's notes

! Some declarations by bill

    integer(ip) :: no_sv_p_t ! number of phi basis for temperature
    integer(ip) :: sps_i  ! a species counter
a632 16
    real(rp) :: surf_angle(1), one_dhdz(1), one_dxdh(1)

    real(rp), dimension(:), pointer :: dh_dz_out
    real(rp), dimension(:), pointer :: dx_dh_out
    real(rp), dimension(:), pointer :: est_scgeocalt ! Est S/C geocentric altitude /m
    real(rp), dimension(:), pointer :: est_los_vel
    real(rp), dimension(:), pointer :: req_out
    real(rp), dimension(:), pointer :: tan_chi_out
    real(rp), dimension(:), pointer :: tan_d2h_dhdt
    real(rp), dimension(:), pointer :: tan_phi
    real(rp), dimension(:), pointer :: tan_press
    real(rp), dimension(:,:), pointer :: d2xdxdt_surface
    real(rp), dimension(:,:), pointer :: d2xdxdt_tan
    real(rp), dimension(:,:), pointer :: dxdt_surface
    real(rp), dimension(:,:), pointer :: dxdt_tan
    real(rp), dimension(:,:,:), pointer :: ddhidhidtl0
a634 1
    type (VectorValue_T), pointer :: CLOUDICE      ! Profiles
a640 1
    type (VectorValue_T), pointer :: MAGFIELD      ! Profiles
a641 2
    type (VectorValue_T), pointer :: PHITAN        ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTAN          ! Tangent pressure component of state vector
a645 1
    type (VectorValue_T), pointer :: TEMP          ! Temperature component of state vector
a647 1
    type (VectorValue_T), pointer :: WORK          ! Temporary stuff
a652 7
    type (Grids_T) :: Grids_n   ! All the spectroscopy(N) coordinates
    type (Grids_T) :: Grids_v   ! All the spectroscopy(V) coordinates
    type (Grids_T) :: Grids_w   ! All the spectroscopy(W) coordinates
    type (Grids_T) :: Grids_f   ! All the coordinates for VMR
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC
    type (Grids_T) :: Grids_mag ! All the coordinates for Magnetic field
    type (Grids_T) :: Grids_tmp ! All the coordinates for TEMP
a656 3
    type (Coefficients) :: Coeffs ! For interpolation
    type (Convolve_Support_T) :: Convolve_Support

a664 9
    ! Local storage places for derivatives..(Temporary..)
    ! Channels x pointings x grid values (== x surfaces x instances )
    real(r4), dimension(:,:,:), pointer :: K_TEMP
    ! Channels x pointings x grid values
    real(r4), dimension(:,:,:), pointer :: K_ATMOS
    ! Channels x pointings x grid values == frequencies x surfaces x instances x molecules:
    real(r4), dimension(:,:,:), pointer :: K_SPECT_DN
    real(r4), dimension(:,:,:), pointer :: K_SPECT_DV
    real(r4), dimension(:,:,:), pointer :: K_SPECT_DW
d696 9
a704 42
    nullify ( alpha_path_c, alpha_path_f, alpha_path_polarized, &
      & alpha_path_polarized_f, b, beta_path_c, &
      & beta_path_cloud_c, beta_path_f, beta_path_polarized, &
      & beta_path_polarized_f, c_inds_b, cext_path, cg_inds, &
      & channelCenters, cld_ext%values, d2x_dxdt, &
      & d2xdxdt_surface, d2xdxdt_tan, DACsStaging, DACsStaging2, &
      & dalpha_dT_path_c, dalpha_dT_path_f, &
      & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f, &
      & dbeta_dn_path_c, dbeta_dn_path_f, dbeta_dT_path_c, dbeta_dT_path_f, &
      & dbeta_dv_path_c, dbeta_dv_path_f, dbeta_dw_path_c, dbeta_dw_path_f, &
      & dBeta_dT_polarized_path_c, dBeta_dT_polarized_path_f, &
      & d_delta_df, ddhidhidtl0, de_df, de_dt, del_s, deltau_pol, del_zeta, &
      & dh_dt_glgrid, dh_dt_path, dh_dt_path_c, dh_dt_path_f, dh_dt_psig, &
      & dhdz_glgrid, dhdz_psig, dhdz_gw_path, dh_dz_out, dhdz_path, &
      & dincoptdepth_pol_dt, do_calc_Cext, do_calc_Cext_zp, do_calc_n, &
      & do_calc_v, do_calc_w, do_calc_w_c, do_calc_fzp, do_calc_hyd, do_calc_hyd_c, &
      & do_calc_hyd, do_calc_hyd_c, &
      & do_calc_iwc, do_calc_iwc_zp, do_calc_Salb, do_calc_Salb_zp, &
      & do_calc_t, do_calc_t_c, do_calc_t_f, do_calc_tscat, &
      & do_calc_tscat_zp, do_calc_zp, do_gl, &
      & d_rad_pol_df, d_rad_pol_dt, dsdz_c, dsdz_gw_path, dTanh_dT_c, &
      & dTanh_dT_f, d_t_scr_dt )
    nullify ( dx_dh_out, dx_dt, dxdt_surface, dxdt_tan, eta_cext, eta_cext_zp, &
      & eta_fzp, eta_iwc, eta_iwc_zp, eta_mag_zp, eta_salb, eta_salb_zp, &
      & eta_tscat, eta_tscat_zp, eta_zp, eta_zxp_n, &
      & eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, eta_zxp_v, eta_zxp_w, &
      & f_inds, frequencies, gph_prof, gl_delta_polarized, gl_inds_b, gph, grids, &
      & h_glgrid, h_path, h_path_c, h_path_f, h_psig, incoptdepth, &
      & incoptdepth_pol, inc_rad_path, ipsd, iwc_path, k_atmos, k_atmos_frq, &
      & k_spect_dn, k_spect_dn_frq, k_spect_dv, k_spect_dv_frq, k_spect_dw, &
      & k_spect_dw_frq, k_temp, k_temp_frq, l1bMIF_TAI, &
      & lineCenter_ix, lineWidth_ix, lineWidth_TDep_ix, &
      & mag_path, MIFDeadTime, n_glgrid, n_path_c, n_psig, &
      & path_dsdh, phi_path, p_path, prod_pol, ptg_angles, &
      & rad_avg_path, rad_FFT, radiances, RadV, ref_corr, req_out, &
      & salb_path, scat_alb%values, scat_ang, scat_src%values, &
      & spect_n_path, spect_v_path, spect_w_path, sps_path,  &
      & tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tanh1_c, tanh1_f, &
      & tan_phi, tau_pol, t_der_path_flags, t_glgrid, &
      & t_path, t_path_c, t_path_f, t_psig, tscat_path, &
      & t_script_lbl, t_script_pfa, tt_path, tt_path_c, &
      & usedDacsSignals, vmr, vmrarray, w0_path_c, wc, z_coarse, z_path, z_psig )
d797 1
d827 2
a828 2
        z_coarse(:tan_pt_c) = z_psig(nlvl:tan_ind_c:-1)
        z_coarse(tan_pt_c+1:npc) = z_psig(tan_ind_c:nlvl)
d830 1
a830 2
        call compute_GL_grid ( z_coarse, tan_pt_c, no_ele, p_path, z_path, &
          & allocate=.false. )
d832 2
a833 3
        z_path(no_ele+1:2*no_ele) = z_path(no_ele:1:-1)
        p_path(no_ele+1:2*no_ele) = p_path(no_ele:1:-1)
        no_ele = 2*no_ele
d1017 1
a1017 1
          ! Compute the three components of MAG_PATH
d1080 4
d1086 4
d1235 1
a1235 1
            & tt_path_c(:npc), w0_path_c(:npc), z_path(:no_ele) )
d1260 1
a1260 1
            & tt_path_c(:npc), w0_path_c(:npc), z_path(:no_ele) )
d1265 1
a1265 1
            call dump ( t_script_pfa(:npc,:noUsedChannels), 'T_Script_PFA' )
d1285 4
a1288 6
      if ( associated(channelCenters,frequencies) ) then
        nullify ( channelCenters )
      else
        call deallocate_test ( channelCenters, 'channelCenters', moduleName )
      end if
      call deallocate_test ( frequencies, 'frequencies', moduleName )
a1292 2
      call deallocate_test ( grids, "Grids", moduleName )

d1301 2
a1302 3
      if ( temp_der ) then
        call deallocate_test ( k_temp_frq,     'k_temp_frq',     moduleName )
      end if
a1312 3
      if ( any_der ) &
        & call deallocate_test ( DACsStaging2, 'DACsStaging2',   moduleName )

d1321 2
a1322 5
    if ( FwdModelConf%anyPFA(1) .or. FwdModelConf%anyPFA(2) ) then
      call deallocate_test ( t_script_PFA, 'T_Script_PFA', moduleName )
      call destroy_tau ( tau_PFA, "Tau_PFA", moduleName )
      call deallocate_test ( rad_avg_path, 'Rad_Avg_Path', moduleName )
    end if
d1344 1
a1344 1
      if ( FwdModelConf%do_freq_avg .and. fwdModelConf%anyLBL(sx) ) then
a1370 32
    ! Now deallocate lots of stuff

    call Deallocate_Test ( WC,       'WC',       moduleName )
    call Deallocate_Test ( Scat_ang, 'Scat_ang', moduleName )
    call Deallocate_Test ( IPSD,     'IPSD',     moduleName )

    call destroyForwardModelDerived ( fwdModelConf )

    ! DESTROY THE SPS DATA STUFF

    ! Non GL stuff
    call deallocate_test ( dh_dt_psig,   'dh_dt_psig',   moduleName )
    call deallocate_test ( dhdz_psig,    'dhdz_psig',    moduleName )
    call deallocate_test ( h_psig,       'h_psig',       moduleName )
    call deallocate_test ( n_psig,       'n_psig',       moduleName )
    call deallocate_test ( t_psig,       't_psig',       moduleName )
    call deallocate_test ( z_psig,       'z_psig',       moduleName )

    ! GL Grid stuff
    call deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', moduleName )
    call deallocate_test ( dhdz_glgrid,  'dhdz_glgrid',  moduleName )
    call deallocate_test ( h_glgrid,     'h_glgrid',     moduleName )
    call deallocate_test ( n_glGrid,     'n_glGrid',     moduleName )
    call deallocate_test ( p_glGrid,     'p_glGrid',     moduleName )
    call deallocate_test ( t_glgrid,     't_glgrid',     moduleName )
    call deallocate_test ( z_glGrid,     'z_glGrid',     moduleName )

    call deallocate_test ( tan_press,     'tan_press',     moduleName )
    call deallocate_test ( tan_phi,       'tan_phi',       moduleName )
    call deallocate_test ( est_scgeocalt, 'est_scgeocalt', moduleName )
    call deallocate_test ( est_los_vel,   'est_los_vel',   moduleName )

a1375 4
    call destroygrids_t ( grids_f )
    call destroygrids_t ( grids_iwc )
    call destroygrids_t ( grids_mag )
    call destroygrids_t ( grids_tmp )
a1378 54
    call deallocate_test ( vmrArray,'vmrArray',ModuleName )

    call deallocate_test ( alpha_path_c,     'alpha_path_c',     moduleName )
    call deallocate_test ( alpha_path_f,     'alpha_path_f',     moduleName )
    call deallocate_test ( b,                'b',                moduleName )
    call deallocate_test ( beta_path_c,      'beta_path_c',      moduleName )
    call deallocate_test ( beta_path_cloud_c,'beta_path_cloud_c',moduleName )
    call deallocate_test ( cg_inds,          'cg_inds',          moduleName )
    call deallocate_test ( c_inds_b,         'c_inds_b',         moduleName )
    call deallocate_test ( del_s,            'del_s',            moduleName )
    call deallocate_test ( del_zeta,         'del_zeta',         moduleName )
    call deallocate_test ( dhdz_gw_path,     'dhdz_gw_path',     moduleName )
    call deallocate_test ( dhdz_path,        'dhdz_path',        moduleName )
    call deallocate_test ( do_gl,            'do_gl',            moduleName )
    call deallocate_test ( dsdz_c,           'dsdz_c',           moduleName )
    call deallocate_test ( dsdz_gw_path,     'dsdz_gw_path',     moduleName )
    call deallocate_test ( f_inds,           'f_inds',           moduleName )
    call deallocate_test ( gl_inds_b,        'gl_inds_b',        moduleName )
    call deallocate_test ( h_path_c,         'h_path_c',         moduleName )
    call deallocate_test ( h_path_f,         'h_path_f',         moduleName )
    call deallocate_test ( h_path,           'h_path',           moduleName )
    call deallocate_test ( incoptdepth,      'incoptdepth',      moduleName )
    call deallocate_test ( n_path_c,         'n_path_c',         moduleName )
    call deallocate_test ( path_dsdh,        'path_dsdh',        moduleName )
    call deallocate_test ( phi_path,         'phi_path',         moduleName )
    call deallocate_test ( p_path,           'p_path',           moduleName )
    call deallocate_test ( ref_corr,         'ref_corr',         moduleName )
    call deallocate_test ( tanh1_c,          'tanh1_c',          moduleName )
    call deallocate_test ( tanh1_f,          'tanh1_f',          moduleName )
    call deallocate_test ( t_path_c,         't_path_c',         moduleName )
    call deallocate_test ( t_path_f,         't_path_f',         moduleName )
    call deallocate_test ( t_path,           't_path',           moduleName )
    call deallocate_test ( tt_path_c,        'tt_path_c',        moduleName )
    call deallocate_test ( w0_path_c,        'w0_path_c',        moduleName )
    call deallocate_test ( z_coarse,         'z_coarse',         moduleName )
    call deallocate_test ( z_path,           'z_path',           moduleName )

    call deallocate_test ( beta_path_f,      'beta_path_f',      moduleName )
    call deallocate_test ( do_calc_fzp,      'do_calc_fzp',      moduleName )
    call deallocate_test ( do_calc_iwc,      'do_calc_iwc',      moduleName )
    call deallocate_test ( do_calc_iwc_zp,   'do_calc_iwc_zp',   moduleName )
    call deallocate_test ( do_calc_zp,       'do_calc_zp',       moduleName )
    call deallocate_test ( eta_fzp,          'eta_fzp',          moduleName )
    call deallocate_test ( eta_iwc,          'eta_iwc',          moduleName )
    call deallocate_test ( eta_iwc_zp,       'eta_iwc_zp',       moduleName )
    call deallocate_test ( eta_mag_zp,       'eta_mag_zp',       moduleName )
    call deallocate_test ( eta_zp,           'eta_zp',           moduleName )
    call deallocate_test ( iwc_path,         'iwc_path',         moduleName )
    call deallocate_test ( mag_path,         'mag_path',         moduleName )
    call deallocate_test ( sps_path,         'sps_path',         moduleName )

    call deallocate_test ( tan_chi_out,      'tan_chi_out',      moduleName )
    call deallocate_test ( dx_dh_out,        'dx_dh_out',        moduleName )
    call deallocate_test ( dh_dz_out,        'dh_dz_out',        moduleName )
d1381 3
a1383 102
      call deallocate_test ( scat_src%values, 'scat_src%values', &
        &                      moduleName )
      call deallocate_test ( scat_alb%values, 'scat_alb%values', &
        &                      moduleName )
      call deallocate_test ( cld_ext%values, 'cld_ext%values', &
        &                      moduleName )
    end if

    if ( temp_der ) then
      call deallocate_test ( ddhidhidtl0,     'ddhidhidtl0',     moduleName )
      call deallocate_test ( k_temp,          'k_temp',          moduleName )
      call deallocate_test ( dAlpha_dT_path_c,'dAlpha_dT_path_c',moduleName )
      call deallocate_test ( dAlpha_dT_path_f,'dAlpha_dT_path_f',moduleName )
      call deallocate_test ( dBeta_dT_Path_c, 'dBeta_dT_Path_c', moduleName )
      call deallocate_test ( dBeta_dT_Path_f, 'dBeta_dT_Path_f', moduleName )
      call deallocate_test ( dh_dt_path_c,    'dh_dt_path_c',    moduleName )
      call deallocate_test ( dh_dt_path,      'dh_dt_path',      moduleName )
      call deallocate_test ( dh_dt_path_f,    'dh_dt_path_f',    moduleName )
      call deallocate_test ( do_calc_hyd_c,   'do_calc_hyd_c',   moduleName )
      call deallocate_test ( do_calc_hyd,     'do_calc_hyd',     moduleName )
      call deallocate_test ( do_calc_t_c,     'do_calc_t_c',     moduleName )
      call deallocate_test ( do_calc_t,       'do_calc_t',       moduleName )
      call deallocate_test ( do_calc_t_f,     'do_calc_t_f',     moduleName )
      call deallocate_test ( dTanh_dT_c,      'dTanh_dT_c',      moduleName )
      call deallocate_test ( dTanh_dT_f,      'dTanh_dT_f',      moduleName )
      call deallocate_test ( d_t_scr_dt,      'd_t_scr_dt',      moduleName )
      call deallocate_test ( eta_zxp_t_c,     'eta_zxp_t_c',     moduleName )
      call deallocate_test ( eta_zxp_t,       'eta_zxp_t',       moduleName )
      call deallocate_test ( eta_zxp_t_f,     'eta_zxp_t_f',     moduleName )
      call deallocate_test ( rad_fft,         'Rad_FFT',         moduleName )
      call deallocate_test ( tan_d2h_dhdt,    'tan_d2h_dhdt',    moduleName )
      call deallocate_test ( tan_dh_dt,       'tan_dh_dt',       moduleName )
      call deallocate_test ( t_der_path_flags,'t_der_path_flags',moduleName )
    end if
    ! Nonzero size if temp_der set, zero size if temp_der not set
    call deallocate_test ( dxdt_surface,    'dxdt_surface',    moduleName )
    call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface', moduleName )
    call deallocate_test ( d2xdxdt_tan,     'd2xdxdt_tan',     moduleName )
    call deallocate_test ( dxdt_tan,        'dxdt_tan',        moduleName )

    if ( atmos_der ) then
      call deallocate_test ( d_delta_df,      'd_delta_df',      moduleName )
      call deallocate_test ( k_atmos,         'k_atmos',         moduleName )
    end if

    call deallocate_test ( do_calc_n,       'do_calc_n',       moduleName )
    call deallocate_test ( do_calc_v,       'do_calc_v',       moduleName )
    call deallocate_test ( do_calc_w_c,     'do_calc_w_c',     moduleName )
    call deallocate_test ( do_calc_w,       'do_calc_w',       moduleName )

    call deallocate_test ( eta_zxp_n,       'eta_zxp_n',       moduleName )
    call deallocate_test ( eta_zxp_v,       'eta_zxp_v',       moduleName )
    call deallocate_test ( eta_zxp_w,       'eta_zxp_w',       moduleName )

    call deallocate_test ( spect_n_path,    'spect_n_path',    moduleName )
    call deallocate_test ( spect_v_path,    'spect_v_path',    moduleName )
    call deallocate_test ( spect_w_path,    'spect_w_path',    moduleName )

    if ( spect_der ) then
      call deallocate_test ( dbeta_dn_path_c, 'dbeta_dn_path_c', moduleName )
      call deallocate_test ( dbeta_dn_path_f, 'dbeta_dn_path_f', moduleName )
      call deallocate_test ( dbeta_dv_path_c, 'dbeta_dv_path_c', moduleName )
      call deallocate_test ( dbeta_dv_path_f, 'dbeta_dv_path_f', moduleName )
      call deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', moduleName )
      call deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f', moduleName )
      call deallocate_test ( k_spect_dn,      'k_spect_dn',      moduleName )
      call deallocate_test ( k_spect_dv,      'k_spect_dv',      moduleName )
      call deallocate_test ( k_spect_dw,      'k_spect_dw',      moduleName )
      call destroygrids_t ( grids_n )
      call destroygrids_t ( grids_w )
      call destroygrids_t ( grids_v )
    end if

    if ( FwdModelConf%polarized ) then
      call deallocate_test ( alpha_path_polarized,   'alpha_path_polarized',   moduleName )
      call deallocate_test ( beta_path_polarized,    'beta_path_polarized',    moduleName )
      call deallocate_test ( alpha_path_polarized_f, 'alpha_path_polarized_f', moduleName )
      call deallocate_test ( beta_path_polarized_f,  'beta_path_polarized_f',  moduleName )
      call deallocate_test ( gl_delta_polarized,     'gl_delta_polarized',     moduleName )
      call deallocate_test ( incoptdepth_pol,        'incoptdepth_pol',        moduleName )
      if ( atmos_der ) then
        call deallocate_test ( d_rad_pol_df,         'd_rad_pol_df',           moduleName )
        k = size(de_df)
        deallocate ( de_df, stat=ier )
        call test_deallocate ( ier, ModuleName, 'de_df', 2*k*e_rp )
      end if
      if ( temp_der ) then
        call deallocate_test ( d_rad_pol_dt,         'd_rad_pol_dt',           moduleName )
        call deallocate_test ( dAlpha_dT_polarized_path_c, &
          & 'dAlpha_dT_polarized_path_c', moduleName )
        call deallocate_test ( dAlpha_dT_polarized_path_f, &
          & 'dAlpha_dT_polarized_path_f', moduleName )
        call deallocate_test ( dBeta_dT_polarized_path_c, 'dBeta_dT_polarized_path_c', moduleName )
        call deallocate_test ( dBeta_dT_polarized_path_f, 'dBeta_dT_polarized_path_f', moduleName )
        k = size(de_dt)
        deallocate ( de_dt, stat=ier )
        call test_deallocate ( ier, ModuleName, 'de_dt', 2*k*e_rp )
        call deallocate_test ( dincoptdepth_pol_dt,  'dincoptdepth_pol_dt',    moduleName )
      end if
      call deallocate_test ( deltau_pol,             'deltau_pol',             moduleName )
      call deallocate_test ( prod_pol,               'prod_pol',               moduleName )
      call deallocate_test ( tau_pol,                'tau_pol',                moduleName )
a1385 5
    call deallocate_test ( ptg_angles,       'ptg_angles',     moduleName )
    call deallocate_test ( radiances,        'radiances',      moduleName )
    call deallocate_test ( dx_dt,            'dx_dt',          moduleName )
    call deallocate_test ( d2x_dxdt,         'd2x_dxdt',       moduleName )

d1394 11
d1419 2
a1429 2
      no_mol = size(fwdModelConf%beta_group)
      call deriveFromForwardModelConfig ( fwdModelConf )
a1432 1
      noUsedChannels = size(channels)
a1440 6
      ! Create the data structures for the species.  Get the
      ! spectroscopy parameters from the state vector.
      ! This has to be done AFTER deriveFromForwardModelConfig.

      call get_species_data ( fwdModelConf, fwdModelIn, fwdModelExtra )

a1445 8
      temp => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_temperature, config=fwdModelConf )
      ptan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule, &
        & foundInFirst=ptan_der, config=fwdModelConf )
      phitan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_phitan, instrumentModule=firstSignal%instrumentModule, &
        & config=fwdModelConf )
a1459 2
        magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_magneticField, config=fwdModelConf )
a1462 8
      if ( fwdModelConf%scanAverage ) then
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_l1bMIF_TAI )
        l1bMIF_TAI => work%values
        work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_MIFDeadTime )
        MIFDeadTime => work%values ! Only the (1,1) element is used.
      end if
a1463 2
        cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
          & quantityType=l_cloudIce, noError=.true., config=fwdModelConf )
a1487 8
      ! ??? What is this for?  They're never used!
      maxNoFreqs = 0
      maxNoSurfs = 0
      do sps_i = 1, no_mol
        maxNoFreqs = max(maxNoFreqs, beta_group(sps_i)%qty%qty%template%noChans)
        maxNoSurfs = max(maxNoSurfs, beta_group(sps_i)%qty%qty%template%noSurfs)
      end do

a1492 8
  ! Sort out a remaining flag
      ptan_der = ptan_der .and. present ( jacobian )

  ! Create the Grids_tmp structure:

      !??? Should .true. be temp_der ???
      call load_one_item_grid ( grids_tmp, temp, phitan, maf, fwdModelConf, .true. )

a1494 13
      no_sv_p_t = grids_tmp%l_p(1) ! phi == windowFinish - windowStart + 1
      n_t_zeta = grids_tmp%l_z(1)  ! zeta
      sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t

      if ( FwdModelConf%incl_cld ) &
        & call load_one_item_grid ( grids_iwc, cloudIce, phitan, maf, &
          & fwdModelConf, .false., .false. )

      if ( FwdModelConf%polarized ) &
        & call load_one_item_grid ( grids_mag, magfield, phitan, maf, &
          & fwdModelConf, .false. )

  ! Now, allocate other variables we're going to need later ----------------
a1496 2
      do_cld = .true. !JJ !for Jonathan use Only
  !    if ( do_cld ) then !JJ
a1506 1
        call allocate_test ( vmrArray, nspec, n_t_zeta, 'vmrArray', ModuleName )
d1535 1
a1535 1
      end if ! end of cloud block
d1537 4
a1540 1
  ! Set up our temporary `state vector' like arrays ------------------------
a1541 17
      call load_sps_data ( FwdModelConf, phitan, maf, grids_f, &
        & h2o_ind, ext_ind )
      if ( size(fwdModelConf%lineCenter) > 0 ) call load_sps_data ( &
        & FwdModelConf, phitan, maf, grids_v, &
        & qtyStuffIn=fwdModelConf%lineCenter%qty )
      if ( size(fwdModelConf%lineWidth) > 0 ) call load_sps_data ( &
        & FwdModelConf, phitan, maf, grids_w, &
        & qtyStuffIn=fwdModelConf%lineWidth%qty )
      if ( size(fwdModelConf%lineWidth_TDep) > 0 ) call load_sps_data ( &
        & FwdModelConf, phitan, maf, grids_n, &
        & qtyStuffIn=fwdModelConf%lineWidth_TDep%qty )

      if ( index(switches,'grids') /= 0 ) then ! dump the grids
        call dump ( grids_f )
        if ( size(fwdModelConf%lineCenter) > 0 ) call dump ( grids_v )
        if ( size(fwdModelConf%lineWidth) > 0 ) call dump ( grids_w )
        if ( size(fwdModelConf%lineWidth_TDep) > 0 ) call dump ( grids_n )
d1544 2
a1557 2
      call allocate_test ( req_out, ptan%template%nosurfs, 'req_out', &
                         & moduleName )
a1580 50
      call allocate_test ( tan_chi_out, ptan%template%nosurfs, 'tan_chi_out', &
                         & moduleName )
      call allocate_test ( dx_dh_out, ptan%template%nosurfs, 'dx_dh_out', &
                         & moduleName )
      call allocate_test ( dh_dz_out, ptan%template%nosurfs, 'dh_dz_out', &
                         & moduleName )

      if ( temp_der ) then
        call allocate_test ( dxdt_tan, ptan%template%nosurfs, sv_t_len, &
                           & 'dxdt_tan', moduleName )
        call allocate_test ( d2xdxdt_tan, ptan%template%nosurfs, sv_t_len, &
                           & 'd2xdxdt_tan', moduleName )
        call allocate_test ( rad_fft, no_fft, 'Rad_FFT', moduleName )
      else
        call allocate_test ( dxdt_tan, 0, 0, 'dxdt_tan', moduleName )
        call allocate_test ( d2xdxdt_tan, 0, 0, 'd2xdxdt_tan', moduleName )
      end if

      ! Temperature's windowStart:windowFinish are correct here.
      ! RefGPH and Temperature have the same horizontal basis.
      ! Grids_F is only needed for H2O, for calculating refractive index.
      ! SCgeocAlt and RefGPH are in meters, but Get_Chi_Out wants them in km.
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp, &
         & req_out, grids_f, h2o_ind, tan_chi_out, dh_dz_out, dx_dh_out, &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )

  ! Compute the preselected integration grid (all surfs from temperature,
  ! tangent grid and species).  Tan_Press is thrown in for free.

      call compute_Z_PSIG ( fwdModelConf, temp, beta_group%qty, nlvl, &
        &                   no_tan_hts, surfaceTangentIndex, z_psig, tan_press )

      maxCoarse = nlvl

      call allocate_test ( z_coarse, &
        & 2*(maxCoarse + size(grids_tmp%phi_basis) + 1), &
        & 'Z_Coarse', moduleName )

  ! Allocate non-GL grids needed by metrics
      call allocate_test ( h_psig,    maxCoarse, no_sv_p_t, 'h_psig', moduleName )
      call allocate_test ( n_psig,    maxCoarse, no_sv_p_t, 'n_psig', moduleName )
      call allocate_test ( t_psig,    maxCoarse, no_sv_p_t, 't_psig', moduleName )
      call allocate_test ( dhdz_psig, maxCoarse, no_sv_p_t, 'dhdz_psig', &
                        &  moduleName )
      call allocate_test ( dh_dt_psig, maxCoarse,  n_t_zeta, no_sv_p_t, &
                        &  'dh_dt_psig', moduleName )
d1583 1
a1583 11
      call compute_GL_grid ( z_psig, nlvl, maxVert, p_glgrid, z_glgrid )

  ! Allocate more GL grid stuff

      call allocate_test ( h_glgrid,    maxVert, no_sv_p_t, 'h_glgrid', moduleName )
      call allocate_test ( n_glgrid,    maxVert, no_sv_p_t, 'n_glgrid', moduleName )
      call allocate_test ( t_glgrid,    maxVert, no_sv_p_t, 't_glgrid', moduleName )
      call allocate_test ( dhdz_glgrid, maxVert, no_sv_p_t, 'dhdz_glgrid', &
                        &  moduleName )
      call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                        &  'dh_dt_glgrid', moduleName )
a1600 6
      ! Allocate path quantities -----------------------------------------------

      max_ele = 2*(maxVert + size(Grids_tmp%phi_basis) + 1) ! maximum possible

      ! Now allocate all path related... with maximum length..

a1604 237
      ! This can be put outside the mmaf loop

      call allocate_test ( alpha_path_c,        npc, 'alpha_path_c',     moduleName )
      call allocate_test ( alpha_path_f,    max_ele, 'alpha_path_f',     moduleName )
      call allocate_test ( b,                   npc, 'b',                moduleName )
      call allocate_test ( beta_path_cloud_c,   npc, 'beta_path_cloud_c',moduleName )
      call allocate_test ( cg_inds,             npc, 'cg_inds',          moduleName )
      call allocate_test ( c_inds_b,            npc, 'c_inds_b',         moduleName )
      call allocate_test ( del_s,               npc, 'del_s',            moduleName )
      call allocate_test ( del_zeta,            npc, 'del_zeta',         moduleName )
      call allocate_test ( dhdz_gw_path,    max_ele, 'dhdz_gw_path',     moduleName )
      call allocate_test ( dhdz_path,       max_ele, 'dhdz_path',        moduleName )
      call allocate_test ( do_gl,               npc, 'do_gl',            moduleName )
      call allocate_test ( dsdz_c,              npc, 'dsdz_c',           moduleName )
      call allocate_test ( dsdz_gw_path,    max_ele, 'dsdz_gw_path',     moduleName )
      call allocate_test ( f_inds,          max_ele, 'f_inds',           moduleName )
      call allocate_test ( gl_inds_b,       max_ele, 'gl_inds_b',        moduleName )
      call allocate_test ( h_path_c,            npc, 'h_path_c',         moduleName )
      call allocate_test ( h_path_f,        max_ele, 'h_path_f',         moduleName )
      call allocate_test ( h_path,          max_ele, 'h_path',           moduleName )
      call allocate_test ( incoptdepth,         npc, 'incoptdepth',      moduleName )
      call allocate_test ( n_path_c,            npc, 'n_path_c',         moduleName )
      call allocate_test ( path_dsdh,       max_ele, 'path_dsdh',        moduleName )
      call allocate_test ( phi_path,        max_ele, 'phi_path',         moduleName )
      call allocate_test ( p_path,          max_ele, 'p_path',           moduleName )
      call allocate_test ( ref_corr,            npc, 'ref_corr',         moduleName )
      call allocate_test ( tanh1_c,             npc, 'tanh1_c',          moduleName )
      call allocate_test ( tanh1_f,         max_ele, 'tanh1_f',          moduleName )
      call allocate_test ( t_path_c,            npc, 't_path_c',         moduleName )
      call allocate_test ( t_path_f,        max_ele, 't_path_f',         moduleName )
      call allocate_test ( t_path,          max_ele, 't_path',           moduleName )
      call allocate_test ( tt_path_c,           npc, 'tt_path_c',        moduleName )
      call allocate_test ( w0_path_c,           npc, 'w0_path_c',        moduleName )
      call allocate_test ( z_path,          max_ele, 'z_path',           moduleName )

      call allocate_test ( beta_path_c,       npc, no_mol, 'beta_path_c',   moduleName )
      call allocate_test ( beta_path_f,   max_ele, no_mol, 'beta_path_f',   moduleName )
      call allocate_test ( do_calc_fzp,   max_ele, size(grids_f%values),  'do_calc_fzp',   moduleName )
      call allocate_test ( do_calc_zp,    max_ele, grids_f%p_len,  'do_calc_zp',     moduleName )
      call allocate_test ( eta_fzp,       max_ele, size(grids_f%values),  'eta_fzp', moduleName )
      call allocate_test ( eta_zp,        max_ele, grids_f%p_len,  'eta_zp', moduleName )
      call allocate_test ( sps_path,      max_ele, no_mol, 'sps_path',       moduleName )

      if ( fwdModelConf%Incl_Cld ) then
  !    if ( do_cld ) then !JJ
        call allocate_test ( do_calc_iwc,    max_ele, size(grids_iwc%values),  'do_calc_iwc',  moduleName )
        call allocate_test ( do_calc_iwc_zp, max_ele, grids_iwc%p_len,  'do_calc_iwc_zp',  moduleName )
        call allocate_test ( eta_iwc,        max_ele, size(grids_iwc%values),  'eta_iwc',      moduleName )
        call allocate_test ( eta_iwc_zp,     max_ele, grids_iwc%p_len,  'eta_iwc_zp',    moduleName )
        call allocate_test ( iwc_path,       max_ele, 1, 'iwc_path',           moduleName )
        call allocate_test ( ipsd,           max_ele, 'IPSD', moduleName )
        call allocate_test ( wc,         fwdModelConf%no_cloud_species, max_ele, 'WC', moduleName )

        call allocate_test ( Scat_ang, fwdModelConf%num_scattering_angles, 'Scat_ang', moduleName )
        call allocate_test ( scat_src%values, n_t_zeta, fwdModelConf%num_scattering_angles, &
                             &'scat_src', moduleName )
        call allocate_test ( scat_alb%values, n_t_zeta, 2, 'scat_alb', moduleName )
        call allocate_test (  cld_ext%values, n_t_zeta, 2, 'cld_ext', moduleName )

      end if

      if ( temp_der ) then ! Temperature derivatives
        ! GL grid stuff
        call allocate_test ( ddhidhidtl0, maxVert, n_t_zeta, no_sv_p_t, &
                          &  'ddhidhidtl0', moduleName )

        ! Path stuff
        call allocate_test ( dAlpha_dT_path_c,     npc, 'dAlpha_dT_path_c', moduleName )
        call allocate_test ( dAlpha_dT_path_f, max_ele, 'dAlpha_dT_path_f', moduleName )

        call allocate_test ( k_temp, noUsedChannels, no_tan_hts, sv_t_len, &
                           & 'k_temp', moduleName )

        call allocate_test ( d_t_scr_dt,         npc, sv_t_len, 'd_t_scr_dt', &
                                                                & moduleName )
        call allocate_test ( dBeta_dT_path_c,    npc, no_mol,   'dBeta_dT_path_c', &
                                                                & moduleName )
        call allocate_test ( dBeta_dT_path_f, max_ele, no_mol,   'dBeta_dT_path_f', &
                                                                & moduleName )
        call allocate_test ( dh_dt_path,      max_ele, sv_t_len, 'dh_dt_path', &
                                                                & moduleName )
        call allocate_test ( dh_dt_path_c,       npc, sv_t_len, 'dh_dt_path_c', &
                                                                & moduleName )
        call allocate_test ( dh_dt_path_f,    max_ele, sv_t_len, 'dh_dt_path_f', &
                                                                & moduleName )
        call allocate_test ( do_calc_hyd,     max_ele, sv_t_len, 'do_calc_hyd', &
                                                                & moduleName )
        call allocate_test ( do_calc_hyd_c,      npc, sv_t_len, 'do_calc_hyd_c', &
                                                                & moduleName )
        call allocate_test ( do_calc_t,       max_ele, sv_t_len, 'do_calc_t', &
                                                                & moduleName )
        call allocate_test ( do_calc_t_c,        npc, sv_t_len, 'do_calc_t_c', &
                                                                & moduleName )
        call allocate_test ( do_calc_t_f,     max_ele, sv_t_len, 'do_calc_t_f', &
                                                                & moduleName )
        call allocate_test ( dTanh_dT_c,          npc, 'dTanh_dT_c', moduleName )
        call allocate_test ( dTanh_dT_f,      max_ele, 'dTanh_dT_f', moduleName )
        call allocate_test ( eta_zxp_t,       max_ele, sv_t_len, 'eta_zxp_t', &
                                                                & moduleName )
        call allocate_test ( eta_zxp_t_c,         npc, sv_t_len, 'eta_zxp_t_c', &
                                                                & moduleName )
        call allocate_test ( eta_zxp_t_f,     max_ele, sv_t_len, 'eta_zxp_t_f', &
                                                                & moduleName )
        call allocate_test ( tan_dh_dt,      sv_t_len, 'tan_dh_dt',    moduleName )
        call allocate_test ( tan_d2h_dhdt,   sv_t_len, 'tan_d2h_dhdt', moduleName )
        call allocate_test ( t_der_path_flags, max_ele,          't_der_path_flags', &
                                                                & moduleName )
        call allocate_test ( dxdt_surface, 1, sv_t_len,  'dxdt_surface', moduleName )
        call allocate_test ( d2xdxdt_surface, 1, sv_t_len,  'd2xdxdt_surface', &
                           & moduleName )
      else
        call allocate_test ( dxdt_surface, 0, 0, 'dxdt_surface', moduleName )
        call allocate_test ( d2xdxdt_surface, 0, 0, 'd2xdxdt_surface', moduleName )
      end if ! temp_der

      if ( atmos_der ) then
        call allocate_test ( d_delta_df, npc, size(grids_f%values), 'd_delta_df', &
                                                                & moduleName )
        call allocate_test ( k_atmos, noUsedChannels, no_tan_hts, &
          & size(grids_f%values), 'k_atmos', moduleName, fill=0.0_r4 )
      end if ! atmos_der

      if ( size(fwdModelConf%lineCenter) > 0 ) then
        call allocate_test ( spect_v_path, max_ele, size(fwdModelConf%lineCenter), &
          & 'spect_v_path', moduleName )
        f_len_v = size(grids_v%values)
        call allocate_test ( do_calc_v, max_ele, f_len_v, 'do_calc_v', &
                          &  moduleName )
        call allocate_test ( eta_zxp_v, max_ele, f_len_v, 'eta_zxp_v', &
                          &  moduleName )
        if ( spect_der ) then
          call allocate_test ( k_spect_dv, noUsedChannels, no_tan_hts, f_len_v, &
            & 'k_spect_dv', moduleName )
          call allocate_test ( dbeta_dv_path_c,     npc, size(fwdModelConf%lineCenter), &
            & 'dbeta_dv_path_c', moduleName )
          call allocate_test ( dbeta_dv_path_f, max_ele, size(fwdModelConf%lineCenter), &
            & 'dbeta_dv_path_f', moduleName )
        end if
      else
        f_len_v = 0
      end if

      if ( size(fwdModelConf%lineWidth) > 0 ) then
        call allocate_test ( spect_w_path, max_ele, size(fwdModelConf%lineWidth), &
          & 'spect_w_path', moduleName )
        f_len_w = size(grids_w%values)
        call allocate_test ( do_calc_w, max_ele, f_len_w, 'do_calc_w', &
                          &  moduleName )
        call allocate_test ( do_calc_w_c,   npc, f_len_w, 'do_calc_w_c', &
                          &  moduleName )
        call allocate_test ( eta_zxp_w, max_ele, f_len_w, 'eta_zxp_w', &
                          &  moduleName )
        if ( spect_der ) then
          call allocate_test ( k_spect_dw, noUsedChannels, no_tan_hts, f_len_w, &
            & 'k_spect_dw', moduleName )
          call allocate_test ( dbeta_dw_path_c,     npc, size(fwdModelConf%lineWidth), &
            & 'dbeta_dw_path_c', moduleName )
          call allocate_test ( dbeta_dw_path_f, max_ele, size(fwdModelConf%lineWidth), &
            & 'dbeta_dw_path_f', moduleName )
        end if
      else
        f_len_w = 0
      end if

      if ( size(fwdModelConf%lineWidth_TDep) > 0 ) then
        f_len_n = size(grids_n%values)
        call allocate_test ( do_calc_n, max_ele, f_len_n, 'do_calc_n', &
                          &  moduleName )
        call allocate_test ( eta_zxp_n, max_ele, f_len_n, 'eta_zxp_n', &
                          &  moduleName )
        call allocate_test ( spect_n_path, max_ele, size(fwdModelConf%lineWidth_TDep), &
          & 'spect_n_path', moduleName )
        if ( spect_der ) then
          call allocate_test ( k_spect_dn, noUsedChannels, no_tan_hts, f_len_n, &
            & 'k_spect_dn', moduleName )
          call allocate_test ( dbeta_dn_path_c,     npc, size(fwdModelConf%lineWidth_TDep), &
            & 'dbeta_dn_path_c', moduleName )
          call allocate_test ( dbeta_dn_path_f, max_ele, size(fwdModelConf%lineWidth_TDep), &
            & 'dbeta_dn_path_f', moduleName )
        end if
      else
        f_len_n = 0
      end if

      if ( FwdModelConf%polarized ) then
        call allocate_test ( eta_mag_zp,     max_ele, grids_mag%p_len, &
          & 'eta_mag_zp', moduleName )
        call allocate_test ( mag_path,       max_ele, magfield%template%noChans+1, &
          & 'mag_path', moduleName )
        call allocate_test ( alpha_path_polarized, 1, npc, &
          & 'alpha_path_polarized', moduleName, low1=-1 )
        call allocate_test ( beta_path_polarized, 1, npc, no_mol, &
          & 'beta_path_polarized', moduleName, low1=-1 )
        call allocate_test ( alpha_path_polarized_f, 1, max_ele, &
          & 'alpha_path_polarized_f', moduleName, low1=-1 )
        call allocate_test ( beta_path_polarized_f, 1, max_ele, no_mol, &
          & 'beta_path_polarized_f', moduleName, low1=-1 )
        call allocate_test ( gl_delta_polarized, 1, max_ele, &
          & 'gl_delta_polarized', moduleName, low1=-1 )
        call allocate_test ( incoptdepth_pol, 2, 2, npc, &
          & 'incoptdepth_pol', moduleName )
        call allocate_test ( prod_pol, 2, 2, npc, 'prod_pol', moduleName )
        call allocate_test ( tau_pol, 2, 2, npc, 'tau_pol', moduleName )
        call allocate_test ( deltau_pol, 2, 2, npc, 'deltau_pol', moduleName )
        if ( atmos_der ) then
          call allocate_test ( d_rad_pol_df, 2, 2, size(grids_f%values), &
            & 'd_rad_pol_df', moduleName )
          allocate ( de_df(2,2,npc,size(grids_f%values)), stat=ier )
          call test_allocate ( ier, moduleName, 'de_df', &
            & (/1,1,1,1/), (/2,2,npc,size(grids_f%values)/), e_rp )
        end if
        if ( temp_der ) then
          call allocate_test ( d_rad_pol_dt, 2, 2, sv_t_len, &
            & 'd_rad_pol_dt', moduleName )
          call allocate_test ( dAlpha_dT_polarized_path_c, 1, npc, &
            & 'dAlpha_dT_polarized_path_c', moduleName, low1=-1 )
          call allocate_test ( dAlpha_dT_polarized_path_f, 1, max_ele, &
            & 'dAlpha_dT_polarized_path_f', moduleName, low1=-1 )
          call allocate_test ( dBeta_dT_polarized_path_c, 1, npc, no_mol, &
            & 'dBeta_dT_polarized_path_c', moduleName, low1=-1 )
          call allocate_test ( dBeta_dT_polarized_path_f, 1, max_ele, no_mol, &
            & 'dBeta_dT_polarized_path_f', moduleName, low1=-1 )
          allocate ( de_dt(2,2,npc,sv_t_len), stat=ier )
          call test_allocate ( ier, moduleName, 'de_dt', &
            & (/1,1,1,1/), (/2,2,npc,sv_t_len/), e_rp )
          call allocate_test ( dincoptdepth_pol_dt, 2, 2, npc, &
            & 'dincoptdepth_pol_dt', moduleName )
        end if
      end if

      call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', moduleName )
      call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
                         & 'radiances', moduleName )

      call allocate_test ( dx_dt, no_tan_hts,sv_t_len, 'dx_dt',moduleName )
      call allocate_test ( d2x_dxdt,no_tan_hts,sv_t_len, 'd2x_dxdt',moduleName )

a1611 1
        call allocate_test ( T_Script_PFA, npcmax, noUsedChannels, 'T_Script_PFA', moduleName )
a1615 2
        call allocate_test ( rad_avg_path, npcmax, noUsedChannels, 'Rad_Avg_Path', &
          & moduleName )
d1618 25
d1648 1
a1656 3
      call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface',moduleName )
      call deallocate_test ( req_out, 'req_out', moduleName )

d1665 10
a1675 1
      ! Convolution if needed, or interpolation to ptan ----------------------
d1678 1
d1680 3
d1688 2
d1697 1
a1697 1
      ! Now check that the angles are in the correct order.  If they
d1710 2
a1711 1
      ! This code is needed to ensure that the ptg_angles are monotonic (and not flat even)
d1736 2
a1737 2
          ! Don't worry about missing the last one here, it will get caught by the
          ! next iteration of the outer loop
d2110 15
a2124 21
      if ( spect_der_center ) then
        do k = 1, size(fwdModelConf%lineCenter)
          call frequency_average_derivative &
            & ( grids_v, k_spect_dv_frq(:ub,:), k_spect_dv(:,ptg_i,:), k, &
            & combine )
        end do
      end if
      if ( spect_der_width ) then
        do k = 1, size(fwdModelConf%lineWidth)
          call frequency_average_derivative &
            & ( grids_w, k_spect_dw_frq(:ub,:), k_spect_dw(:,ptg_i,:), k, &
            & combine )
        end do
      end if
      if ( spect_der_width_TDep ) then
        do k = 1, size(fwdModelConf%lineWidth_TDep)
          call frequency_average_derivative &
            & ( grids_n, k_spect_dn_frq(:ub,:), k_spect_dn(:,ptg_i,:), k, &
            & combine )
        end do
      end if
a2258 1
!           if ( do_cld ) then !JJ
a2304 2
          call allocate_test ( tt_path, no_ele, 1, 'tt_path', moduleName )

d2306 2
a2307 1
          call interp_tscat ( tscat_path(1:no_ele,:), Scat_ang(:), phi_path(1:no_ele), tt_path )
a2378 1
          call deallocate_test ( tt_path,          'tt_path',          moduleName )
a2832 1
        call allocate_test ( grids, no_tan_hts, "Grids", moduleName )
d2866 2
a2867 2
        call get_channel_centers ( frequencies )
        channelCenters => frequencies
d2894 1
a2894 1
                             & f_len_w, 'k_spect_dw_frq', moduleName )
d2897 1
a2897 1
                             & f_len_n, 'k_spect_dn_frq', moduleName )
d2900 1
a2900 9
                             & f_len_v, 'k_spect_dv_frq', moduleName )

      if ( any_der ) &
        & call allocate_test ( DACsStaging2, ubound(DACsStaging,1), &
                             &               max(sv_t_len,size(grids_f%values), &
                                             &   f_len_w, f_len_n, f_len_v), &
                             &               noUsedDACs, &
                             & 'DACsStaging2', moduleName, &
                             & low1=lbound(DACsStaging,1) )
d2927 2
a2928 2
    subroutine Get_Channel_Centers ( Frequencies )
      real(r8), pointer :: Frequencies(:)
a2944 1
      call allocate_test ( frequencies, noUsedChannels, "frequencies", moduleName )
d2947 1
a2947 1
        frequencies(channel) = firstSignal%lo + dir * &
d2955 1
a2955 1
  end subroutine FullForwardModel
a2965 1
    use Allocate_Deallocate, only: Allocate_Test
d2983 4
a2986 7
  ! Outputs -- would be intent(out) if we could say so.
  ! These are nullified here, so don't expect them to be deallocated if
  ! they were previously allocated.

    real(rp), dimension(:), pointer :: Tan_phi
    real(rp), dimension(:), pointer :: Est_scgeocalt ! Est S/C geocentric altitude /m
    real(rp), dimension(:), pointer :: est_los_vel
a2996 4
    NULLIFY ( tan_phi, est_scgeocalt, est_los_vel )
    call allocate_test ( tan_phi,       no_tan_hts, 'tan_phi',       moduleName )
    call allocate_test ( est_scgeocalt, no_tan_hts, 'est_scgeocalt', moduleName )
    call allocate_test ( est_los_vel,   no_tan_hts, 'est_los_vel',   moduleName )
d3052 1
a3052 1
    & "$Id: FullForwardModel_m.f90,v 2.268 2006/11/29 01:09:40 vsnyder Exp $"
a3060 3
! Revision 2.268  2006/11/29 01:09:40  vsnyder
! Use SIZE()==0 instead of ASSOCIATED to decide whether to compute spectroscopy derivatives
!
@


2.268
log
@Use SIZE()==0 instead of ASSOCIATED to decide whether to compute spectroscopy derivatives
@
text
@a1328 1
      call deallocate_test ( d2xdxdt_tan,     'd2xdxdt_tan',     moduleName )
a1343 2
      call deallocate_test ( dxdt_surface,    'dxdt_surface',    moduleName )
      call deallocate_test ( dxdt_tan,        'dxdt_tan',        moduleName )
d1352 5
d1697 3
d1884 3
d3449 1
a3449 1
    & "$Id: FullForwardModel_m.f90,v 2.267 2006/08/25 19:42:31 vsnyder Exp $"
d3458 3
@


2.267
log
@Recommited to get correct comment into the log: Compute earthradc_sq for
metrics, since we both need it, more accurate tracing, cannonball polishing.
@
text
@d58 1
a58 1
    use Geometry, only: EarthRadA, EarthRadB, MaxRefraction
d71 1
a71 1
    use ManipulateVectorQuantities, only: DoHGridsMatch, FindClosestInstances
a112 1
    integer :: BRKPT                    ! Index of midpoint of path
d129 1
a135 1
    integer :: MID                      ! NPC / 2
d160 4
a163 3
    integer :: TAN_IND                  ! Index of tangent point in coarse or
                                        ! fine grid; which one depends on when
                                        ! you look
a172 1
    integer, dimension(:), pointer :: ClosestInstances
d282 1
a282 1
    real(rp), dimension(:), pointer :: TANH1_F      ! tanh1_c on fine grid
d288 3
a290 2
    real(rp), dimension(:), pointer :: Z_GLGRID     ! Zeta on glGrid surfs
    real(rp), dimension(:), pointer :: Z_PATH       ! Zeta on path
d317 1
d337 1
d350 1
d360 1
d368 1
d510 1
a510 1
      & channelCenters, cld_ext%values, closestInstances, d2x_dxdt, &
d518 5
a522 5
      & dh_dt_glgrid, dh_dt_path, dh_dt_path_c, dh_dt_path_f, dhdz_glgrid, &
      & dhdz_gw_path, dh_dz_out, dhdz_path, dincoptdepth_pol_dt, &
      & do_calc_Cext, do_calc_Cext_zp, do_calc_n, &
      & do_calc_v, do_calc_w, &
      & do_calc_w_c, do_calc_fzp, do_calc_hyd, do_calc_hyd_c, &
d533 2
a534 2
      & h_glgrid, h_path, h_path_c, h_path_f, incoptdepth, incoptdepth_pol, &
      & inc_rad_path, ipsd, iwc_path, k_atmos, k_atmos_frq, &
d538 1
a538 1
      & mag_path, MIFDeadTime, n_glgrid, n_path_c, &
d545 1
a545 1
      & t_path, t_path_c, t_path_f, tscat_path, &
d547 1
a547 1
      & usedDacsSignals, vmr, vmrarray, w0_path_c, wc, z_path, z_psig )
d566 8
a579 3
      call allocate_test ( dxdt_surface, 1, sv_t_len,  'dxdt_surface', moduleName )
      call allocate_test ( d2xdxdt_surface, 1, sv_t_len,  'd2xdxdt_surface', &
                       & moduleName )
a591 16
    ! This is a lazy way to get the surface angle
    ! Temperature's windowStart:windowFinish are correct here.
    ! refGPH and temperature have the same horizontal basis.
    ! Grids_F is only needed for H2O, for calculating refractive index.
    ! Est_scgeocalt and RefGPH are in meters, but Get_Chi_Out wants them in km.
    call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
       & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
       & (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
       & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
       & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp, &
       & req_out(1:1), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh,  &
       & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )

    call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface',moduleName )
    call deallocate_test ( req_out, 'req_out', moduleName )

d629 2
a630 2
        tan_ind = max(1,ptg_i-surfaceTangentIndex+1) ! On coarse grid
        tan_ind = (tan_ind-1) * ngp1 + 1             ! On fine GL grid
d637 41
a677 4
        brkpt = MaxVert + 1 - tan_ind ! fine path tangent index
        no_ele = 2 * brkpt
        mid = (brkpt + Ng) / Ngp1
        npc = 2 * mid
d681 1
a681 1
        c_inds = (/(i*Ngp1-Ng,i=1,mid),((i-1)*Ngp1-Ng+1,i=mid+1,npc)/)
d686 5
a690 12
        ! Compute z_path & p_path
        z_path(1:no_ele) = (/z_glgrid(MaxVert:tan_ind:-1), &
                           & z_glgrid(tan_ind:MaxVert)/)
        del_zeta(2:mid) = 0.5_rp * ( z_path(c_inds(1:mid-1)) - &
          &                          z_path(c_inds(2:mid)) )
        del_zeta(mid+1:npc-1) = 0.5_rp * ( z_path(c_inds(mid+2:npc)) - &
          &                                z_path(c_inds(mid+1:npc-1)) )
        del_zeta((/1,npc/)) = 0.0_rp

        ! p_path = 10.0 ** z_path
        p_path(1:no_ele) = (/p_glgrid(MaxVert:tan_ind:-1), &
                           & p_glgrid(tan_ind:MaxVert)/)
d768 1
d810 1
a810 1
        if ( associated(fwdModelConf%lineCenter) ) then
d817 1
a817 1
        if ( associated(fwdModelConf%lineWidth) ) then
d825 1
a825 1
        if ( associated(fwdModelConf%lineWidth_TDep) ) then
d1228 12
d1242 1
a1244 4
    call deallocate_test ( h_glgrid,     'h_glgrid',     moduleName )
    call deallocate_test ( t_glgrid,     't_glgrid',     moduleName )
    call deallocate_test ( dhdz_glgrid,  'dhdz_glgrid',  moduleName )

a1272 1
    call deallocate_test ( dh_dt_glgrid,     'dh_dt_glgrid',     moduleName )
d1296 1
a1297 1
    call deallocate_test ( z_psig,           'z_psig',           moduleName )
d1444 3
a1446 3
      spect_der_center = spect_der .and. associated(fwdModelConf%lineCenter)
      spect_der_width = spect_der .and. associated(fwdModelConf%lineWidth)
      spect_der_width_TDep = spect_der .and. associated(fwdModelConf%lineWidth_TDep)
d1543 1
d1587 1
a1587 5
        call Allocate_test ( closestInstances, thisRadiance%template%noInstances,    &
        & 'closestInstances', ModuleName )
        call FindClosestInstances ( temp, thisRadiance, closestInstances )
        inst = closestInstances(MAF)
        call deallocate_test ( closestInstances, 'closestInstances', ModuleName )
d1628 1
a1628 1
      if ( associated(fwdModelConf%lineCenter) ) call load_sps_data ( &
d1631 1
a1631 1
      if ( associated(fwdModelConf%lineWidth) ) call load_sps_data ( &
d1634 1
a1634 1
      if ( associated(fwdModelConf%lineWidth_TDep) ) call load_sps_data ( &
d1640 3
a1642 3
        if ( associated(fwdModelConf%lineCenter) ) call dump ( grids_v )
        if ( associated(fwdModelConf%lineWidth) ) call dump ( grids_w )
        if ( associated(fwdModelConf%lineWidth_TDep) ) call dump ( grids_n )
d1653 3
a1655 1
  ! compute equivalent earth radius at phi_t(1), nearest surface
d1659 3
a1661 4
      earthradc_sq = (earthRadA*earthRadB)**2 / &
            &     ((earthRadA**2-earthRadB**2) * &
                   &   SIN(orbIncline%values(1,maf)*Deg2Rad)**2 + &
                   & earthRadB**2)
d1715 14
d1740 2
d1761 1
a1761 1
      max_ele = 2*maxVert     ! maximum possible
d1765 2
a1766 2
      brkpt = maxVert
      npc = 2 * (brkpt + Ng) / Ngp1
d1784 1
a1784 1
      call allocate_test ( f_inds,         ng * npc, 'f_inds',           moduleName )
a1811 3
      call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                        &  'dh_dt_glgrid', moduleName )

d1876 3
d1888 1
a1888 1
      if ( associated(fwdModelConf%lineCenter) ) then
d1908 1
a1908 1
      if ( associated(fwdModelConf%lineWidth) ) then
d1930 1
a1930 1
      if ( associated(fwdModelConf%lineWidth_TDep) ) then
d2019 16
d3052 1
a3052 1
              & ref_corr, Req + tan_ht, dh_dt_path(brkpt,:),                &
d3099 1
a3099 1
              & Req + tan_ht, dh_dt_path(brkpt,:),                          &
a3432 1

d3441 1
a3441 1
    & "$Id: FullForwardModel_m.f90,v 2.266 2006/08/25 19:37:07 vsnyder Exp $"
d3450 4
@


2.266
log
@metrics_m.f90
@
text
@d3379 1
a3379 1
    & "$Id: FullForwardModel_m.f90,v 2.265 2006/07/06 23:16:19 vsnyder Exp $"
d3388 3
@


2.265
log
@Need to allocate dh_dt_glgrid even if no temperature derivatives
@
text
@d396 1
d494 1
a494 1
      & call trace_begin ( 'ForwardModel, MAF=', index=fmstat%maf )
d598 4
a601 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_End ( 'ForwardModel.Hydrostatic' )
d682 1
a682 1
              &  orbIncline%values(1,maf)*Deg2Rad, FwdModelConf%refract,     &
d703 1
a703 1
              &  orbIncline%values(1,maf)*Deg2Rad, FwdModelConf%refract,     &
d717 1
a717 1
              &  orbIncline%values(1,maf)*Deg2Rad, FwdModelConf%refract,     &
d738 1
a738 1
              &  orbIncline%values(1,maf)*Deg2Rad, FwdModelConf%refract,     &
d1392 1
a1392 1
    if ( toggle(emit) ) call trace_end ( 'ForwardModel MAF=', fmStat%maf )
d1627 2
a1628 2
      earthradc = earthRadA*earthRadB / &
            & SQRT((earthRadA**2-earthRadB**2) * &
d1631 1
d1639 4
d1648 2
a1649 2
        & ( earthrada**4 - (earthrada**2+earthradc**2) * req_out ) / &
        & ( earthradc**2 + req_out ) )
d1924 1
a1924 1
          call allocate_test ( d_rad_pol_df, 2, 2, grids_f%l_v(ubound(grids_f%l_v,1)), &
d1926 1
a1926 1
          allocate ( de_df(2,2,npc,grids_f%l_v(ubound(grids_f%l_v,1))), stat=ier )
d1928 1
a1928 1
            & (/1,1,1,1/), (/2,2,npc,grids_f%l_v(ubound(grids_f%l_v,1))/), e_rp )
a1957 1
        call Trace_Begin ( 'ForwardModel.SidebandLoop' )
a2937 1

d3379 1
a3379 1
    & "$Id: FullForwardModel_m.f90,v 2.264 2006/06/29 19:34:43 vsnyder Exp $"
d3388 3
@


2.264
log
@Changes due to metrics handling only one tangent
@
text
@d40 1
d161 3
a197 1
    integer, dimension(:), pointer :: TAN_INDS ! Index of tangent grid into gl grid
d291 2
d541 1
a541 1
      & usedDacsSignals, vmr, vmrarray, w0_path_c, wc, z_path )
d632 3
d640 1
a640 1
        brkpt = MaxVert + 1 - tan_inds(ptg_i) ! path tangent index
d645 1
a645 1
        ! This is not pretty but we need some coarse grid extraction indices
d648 2
a649 2
        ! And some fine grid extraction indices
        do_gl(:npc) = (/ .false., (.true., i=2,npc-1), .false. /)
d653 2
a654 2
        z_path(1:no_ele) = (/z_glgrid(MaxVert:tan_inds(ptg_i):-1), &
                           & z_glgrid(tan_inds(ptg_i):MaxVert)/)
d662 2
a663 2
        p_path(1:no_ele) = (/p_glgrid(MaxVert:tan_inds(ptg_i):-1), &
                           & p_glgrid(tan_inds(ptg_i):MaxVert)/)
d665 1
a665 1
        ! Compute the h_path, t_path, dhdz_path, phi_path, dhdt_path
d677 3
a679 4
            call metrics ( tan_phi(ptg_i), tan_inds(ptg_i),                  &
              &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, h_glgrid,          &
              &  t_glgrid, dhdz_glgrid, orbIncline%values(1,maf)*Deg2Rad,    &
              &  FwdModelConf%refract,                                       &
d682 2
a683 2
              &  TAN_PHI_H=tan_ht, TAN_PHI_T=tan_temp,                       &
              &  NEG_H_TAN = neg_tan_ht,                                     &
d698 3
a700 4
            call metrics ( tan_phi(ptg_i), tan_inds(ptg_i),                  &
              &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, h_glgrid,          &
              &  t_glgrid, dhdz_glgrid, orbIncline%values(1,maf)*Deg2Rad,    &
              &  FwdModelConf%refract,                                       &
d703 1
a703 2
              &  TAN_PHI_H = tan_ht, TAN_PHI_T = tan_temp,                   &
              &  NEG_H_TAN = neg_tan_ht )
d712 3
a714 4
            call metrics ( tan_phi(ptg_i), tan_inds(ptg_i),                  &
              &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, h_glgrid,          &
              &  t_glgrid, dhdz_glgrid, orbIncline%values(1,maf)*Deg2Rad,    &
              &  FwdModelConf%refract,                                       &
d718 1
d733 3
a735 4
            call metrics ( tan_phi(ptg_i), tan_inds(ptg_i),                  &
              &  Grids_tmp%phi_basis, z_glgrid, n_glgrid, h_glgrid,          &
              &  t_glgrid, dhdz_glgrid, orbIncline%values(1,maf)*Deg2Rad,    &
              &  FwdModelConf%refract,                                       &
a1207 1
    call deallocate_test ( tan_inds,      'tan_inds',      moduleName )
d1236 1
d1261 1
a1290 1
      call deallocate_test ( dh_dt_glgrid,    'dh_dt_glgrid',    moduleName )
d1670 6
d1678 1
a1678 2
      call compute_GL_grid ( fwdModelConf, temp, beta_group%qty, nlvl, maxVert, &
        &                    p_glgrid, z_glgrid, tan_inds, tan_press )
a1687 4
      surfaceTangentIndex = COUNT(tan_inds == 1)

      no_tan_hts = size(tan_inds)

d1757 3
a1781 2
        call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                          &  'dh_dt_glgrid', moduleName )
d3305 2
a3306 2
    integer :: I, J, JF, K
    REAL(rp) :: R, R1, R2, r3       ! real variables for various uses
d3316 2
a3317 2
    call allocate_test ( est_los_vel, no_tan_hts, 'est_los_vel', moduleName )
    j = no_tan_hts - nlvl
d3319 3
a3321 3
    tan_phi(1:j) = phitan%values(1,MAF)
    est_scgeocalt(1:j) = scGeocAlt%values(1,maf)
    est_los_vel(1:j) = losvel%values(1,maf)
d3324 2
a3325 1
! we have to sort ptan%values and re-arrange phitan%values & scgeocalt%values
d3358 6
a3363 6
    call interpolateValues ( z_path, p_path, tan_press(j+1:no_tan_hts), &
      &  tan_phi(j+1:no_tan_hts), METHOD = 'L', EXTRAPOLATE='C' )
    call interpolateValues ( z_path, t_path, tan_press(j+1:no_tan_hts), &
       & est_scgeocalt(j+1:no_tan_hts), METHOD='L', EXTRAPOLATE='C' )
    call interpolateValues ( z_path, mif_vel, tan_press(j+1:no_tan_hts), &
       & est_los_vel(j+1:no_tan_hts), METHOD='L', EXTRAPOLATE='C' )
d3373 1
a3373 1
    & "$Id: FullForwardModel_m.f90,v 2.263 2006/06/19 19:26:56 vsnyder Exp $"
d3382 3
@


2.263
log
@OOPS, out of bounds subscript possible in path_dsdh
@
text
@a182 1
    logical, parameter :: dummy(2) = (/.FALSE.,.FALSE./)  ! dummy Flag array for Metrics
d230 2
a237 2
    real(rp), dimension(1) :: ONE_TAN_HT ! ***
    real(rp), dimension(1) :: ONE_TAN_TEMP ! ***
d278 1
a278 1
    real(rp), dimension(:), pointer :: TAN_TEMP     ! ***
a350 1
    real(rp), dimension(:,:), pointer :: TAN_DH_DT    ! dH/dT at Tangent
d399 1
a405 1
    real(rp), dimension(:,:), pointer :: tan_d2h_dhdt
d449 2
a450 2
!   real(rp), dimension(:), pointer :: TAN_HTS      ! Accumulation of ONE_TAN_HT
!   real(rp), dimension(:), pointer :: TAN_TEMPS    ! Accumulation of ONE_TAN_TEMP
d533 1
a533 1
      & tan_phi, tan_temp, tau_pol, t_der_path_flags, t_glgrid, &
d555 16
a570 5
    call two_d_hydrostatic ( Grids_tmp, &
      &  (/ (refGPH%template%surfs(1,1), j=windowStart,windowFinish) /), &
      &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
      &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
      &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )
a576 7

    if ( temp_der ) then
      call allocate_test ( dxdt_surface, 1, sv_t_len,  'dxdt_surface', moduleName )
      call allocate_test ( d2xdxdt_surface, 1, sv_t_len,  'd2xdxdt_surface', &
                       & moduleName )
    end if

d653 1
d669 1
a669 1
            call metrics ( tan_phi(ptg_i:ptg_i), tan_inds(ptg_i:ptg_i),      &
d672 1
a672 1
              &  Grids_tmp%deriv_flags, FwdModelConf%refract,                &
d675 2
a676 2
              &  TAN_PHI_H_GRID=one_tan_ht, TAN_PHI_T_GRID=one_tan_temp,     &
              &  NEG_H_TAN = (/neg_tan_ht/),                                 &
d680 1
d691 1
a691 1
            call metrics ( tan_phi(ptg_i:ptg_i), tan_inds(ptg_i:ptg_i),      &
d694 1
a694 1
              &  dummy, FwdModelConf%refract,                                &
d697 2
a698 2
              &  TAN_PHI_H_GRID = one_tan_ht, TAN_PHI_T_GRID = one_tan_temp, &
              &  NEG_H_TAN = (/neg_tan_ht/) )
d707 1
a707 1
            call metrics ( tan_phi(ptg_i:ptg_i), tan_inds(ptg_i:ptg_i),      &
d710 1
a710 1
              &  Grids_tmp%deriv_flags, FwdModelConf%refract,                &
d713 1
a713 1
              &  TAN_PHI_H_GRID = one_tan_ht, TAN_PHI_T_GRID = one_tan_temp, &
d717 1
d728 1
a728 1
            call metrics ( tan_phi(ptg_i:ptg_i), tan_inds(ptg_i:ptg_i),      &
d731 1
a731 1
              &  dummy, FwdModelConf%refract,                                &
d734 1
a734 1
              &  TAN_PHI_H_GRID = one_tan_ht, TAN_PHI_T_GRID = one_tan_temp )
d746 2
a747 2
!       tan_temps ( ptg_i ) = one_tan_temp ( 1 )
!       tan_hts ( ptg_i ) = one_tan_ht ( 1 )
a749 3
        !??? This is never used for anything ???
!       tan_temp(ptg_i) = one_tan_temp(1)

d870 3
a872 3
             & one_tan_ht(1), tan_phi(ptg_i), Req, 0.0_rp,                  &
             & ptg_angles(ptg_i), r, 1.0_rp, tan_dh_dt(1,:),                &
             & tan_d2h_dhdt(1,:), dx_dt(ptg_i,:), d2x_dxdt(ptg_i,:) )
d875 2
a876 2
             & one_tan_ht(1), tan_phi(ptg_i), Req, 0.0_rp,                  &
             & ptg_angles(ptg_i), r, 1.0_rp )
d882 1
a882 1
                      &  Req+one_tan_ht(1), del_s(:npc), ref_corr(:npc), ier )
d893 1
a893 1
          & ( sqrt(h_path(:no_ele/2-1)**2 - (Req+one_tan_ht(1))**2 ) )
d895 1
a895 1
          & ( sqrt(h_path(no_ele/2+2:no_ele)**2 - (Req+one_tan_ht(1))**2 ) )
a1202 2
    call deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', moduleName )
    call deallocate_test ( ddhidhidtl0,  'ddhidhidtl0',  moduleName )
a1208 1
    call deallocate_test ( tan_temp,      'tan_temp',      moduleName )
d1286 2
a1677 4
      call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                        &  'dh_dt_glgrid', moduleName )
      call allocate_test ( ddhidhidtl0, maxVert, n_t_zeta, no_sv_p_t, &
                        &  'ddhidhidtl0', moduleName )
a1698 2
      call allocate_test ( tan_temp, no_tan_hts, 'tan_temp', moduleName )

d1771 5
d1777 1
d1814 2
a1815 2
        call allocate_test ( tan_dh_dt,    1, sv_t_len, 'tan_dh_dt',    moduleName )
        call allocate_test ( tan_d2h_dhdt, 1, sv_t_len, 'tan_d2h_dhdt', moduleName )
d2977 1
a2977 1
              & ref_corr, Req + one_tan_ht(1), dh_dt_path(brkpt,:),         &
d3024 1
a3024 1
              & Req + one_tan_ht(1), dh_dt_path(brkpt,:),                   &
d3366 1
a3366 1
    & "$Id: FullForwardModel_m.f90,v 2.262 2006/06/16 20:32:30 vsnyder Exp $"
d3375 3
@


2.262
log
@Define NGP1 in glnp
@
text
@d651 2
a652 2
        p_path(1:no_ele) = (/(p_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                           & (p_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
d883 7
a889 4
        ! We need path_dsdh on the entire grid except at the tangent point
        ! for trapezoidal quadrature on the coarse grid, or for Lobatto
        ! quadrature on the fine grid.  Besides, it's probably faster not
        ! to use a vector subscript to restrict it to the fine grid.
d892 2
a893 2
        path_dsdh(no_ele/2+2:) = h_path(no_ele/2+2:) / &
          & ( sqrt(h_path(no_ele/2+2:)**2 - (Req+one_tan_ht(1))**2 ) )
a895 2
!         path_dsdh(f_inds(:nglMax)) = h_path(f_inds(:nglMax)) / &
!           & ( sqrt( h_path(f_inds(:nglMax))**2 - (Req+one_tan_ht(1))**2 ) )
d3365 1
a3365 1
    & "$Id: FullForwardModel_m.f90,v 2.261 2006/06/16 00:49:10 vsnyder Exp $"
d3374 3
@


2.261
log
@Improved non-GL correction, add TeXnicalities
@
text
@d61 1
a61 1
    use GLnp, only: GW, NG, Lobatto
a108 3
    ! Define local parameters
    integer, parameter :: Ngp1 = Ng+1         ! NG + 1

d3364 1
a3364 1
    & "$Id: FullForwardModel_m.f90,v 2.260 2006/04/25 23:25:36 vsnyder Exp $"
d3373 3
@


2.260
log
@Revise DACS filter shape data structure
@
text
@d61 1
a61 1
    use GLnp, only: GW, NG
d255 1
d520 1
a520 1
      & d_rad_pol_df, d_rad_pol_dt, dsdz_gw_path, dTanh_dT_c, &
d886 12
a897 2
        path_dsdh(f_inds(:nglMax)) = h_path(f_inds(:nglMax)) / &
          & ( sqrt( h_path(f_inds(:nglMax))**2 - (Req+one_tan_ht(1))**2 ) )
d901 4
d1239 1
d1729 1
d2688 1
a2688 1
          do j = 1, npc
a2691 1

d2701 7
d2713 1
a2713 1
  
d2736 1
d2757 1
a2757 1
          do j = 1, npc
d2773 15
a2787 3
        ! Where we don't do GL, replace the rectangle rule by the trapezoid
        ! rule.
        do j = 1, npc - 1
d2789 7
a2795 2
            & incoptdepth(j) = &
              & 0.5 * ( alpha_path_c(j) + alpha_path_c(j+1) ) * del_s(j)
d3367 1
a3367 1
    & "$Id: FullForwardModel_m.f90,v 2.259 2006/04/21 22:25:20 vsnyder Exp $"
d3376 3
@


2.259
log
@Cannonball polishing
@
text
@d2223 1
a2223 1
          shapeInd = MatchSignal ( dacsFilterShapes%signal, &
d2311 1
a2311 1
          shapeInd = MatchSignal ( dacsFilterShapes%signal, &
d3109 3
a3111 3
            k = Size(dacsFilterShapes(shapeInd)%FilterGrid)
            r1 = dacsFilterShapes(shapeInd)%FilterGrid(1)
            r2 = dacsFilterShapes(shapeInd)%FilterGrid(k)
d3326 1
a3326 1
    & "$Id: FullForwardModel_m.f90,v 2.258 2006/04/11 18:34:37 vsnyder Exp $"
d3335 3
@


2.258
log
@Add tanh(h nu / k T) to Get_D_Deltau_Pol.  Use DACS frequencies in
Frequency_Setup_1.
@
text
@d2901 4
a2904 4

            call mcrt_der ( t_script(:,frq_i), sqrt(e_rflty), deltau_pol(:,:,1:npc), &
              & de_df(:,:,1:npc,:), prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), &
              & p_stop, d_rad_pol_df )
d3326 1
a3326 1
    & "$Id: FullForwardModel_m.f90,v 2.257 2006/03/06 20:44:06 vsnyder Exp $"
d3335 4
@


2.257
log
@Avoid appearance of out-of-bounds subscript during frequency averaging
@
text
@d2895 1
a2895 1
              &  eta_fzp, do_calc_fzp, sps_path, del_s,                    &
d3103 1
a3104 1
            shapeInd = channels(i)%shapeInds(sx)
d3108 4
a3111 2
            min_ch_freq_grid = MIN(r1, r2, min_ch_freq_grid)
            max_ch_freq_grid = MAX(r1, r2, max_ch_freq_grid)
d3113 2
d3326 1
a3326 1
    & "$Id: FullForwardModel_m.f90,v 2.256 2006/02/08 21:38:18 vsnyder Exp $"
d3335 3
@


2.256
log
@Add relative humidity (RHi) calculation
@
text
@d2358 5
d2364 1
a2364 1
        &               k_temp_frq(:noFreqs,:), k_temp(:,ptg_i,:), 1, combine )
d2373 1
a2373 1
              & k_atmos_frq(:noFreqs,:), k_atmos(:,ptg_i,:), k, combine )
d2383 1
a2383 1
            & ( grids_v, k_spect_dv_frq(:noFreqs,:), k_spect_dv(:,ptg_i,:), k, &
d2390 1
a2390 1
            & ( grids_w, k_spect_dw_frq(:noFreqs,:), k_spect_dw(:,ptg_i,:), k, &
d2397 1
a2397 1
            & ( grids_n, k_spect_dn_frq(:noFreqs,:), k_spect_dn(:,ptg_i,:), k, &
d3322 1
a3322 1
    & "$Id: FullForwardModel_m.f90,v 2.255 2006/02/08 01:02:01 vsnyder Exp $"
d3331 3
@


2.255
log
@More stuff for spectroscopy derivatives
@
text
@d2515 1
a2515 1
            & beta_group%PFA(sx), vel_rel, beta_path_c, t_der_path_flags, &
d2524 1
a2524 1
            &  beta_group%lbl(sx), fwdModelConf%polarized, gl_slabs, c_inds,  &
d2760 1
a2760 1
            & beta_group%PFA(sx), vel_rel, beta_path_f(:ngl,:), t_der_path_flags, &
d2777 1
a2777 1
            & beta_group%lbl(sx), fwdModelConf%polarized, gl_slabs,            &
d3317 1
a3317 1
    & "$Id: FullForwardModel_m.f90,v 2.254 2006/01/05 00:03:52 vsnyder Exp $"
d3326 3
@


2.254
log
@Implement refractive correction for Phi
@
text
@d49 1
a49 1
      & ForwardModelConfig_t
d783 1
a783 2
          if ( associated(FwdModelConf%lineCenter_ix) ) &
            & lineCenter_ix => FwdModelConf%lineCenter_ix(sx,:FwdModelConf%cat_Size(sx))
d791 1
a791 2
          if ( associated(FwdModelConf%lineWidth_ix) ) &
            & lineWidth_ix => FwdModelConf%lineWidth_ix(sx,:FwdModelConf%cat_Size(sx))
d798 1
a798 2
          if ( associated(FwdModelConf%lineWidth_TDep_ix) ) &
            & lineWidth_TDep_ix => FwdModelConf%lineWidth_TDep_ix(sx,:FwdModelConf%cat_Size(sx))
d1822 1
a1822 1
          call allocate_test ( dbeta_dv_path_c,     npc, no_mol, &
d1824 1
a1824 1
          call allocate_test ( dbeta_dv_path_f, max_ele, no_mol, &
d1844 1
a1844 1
          call allocate_test ( dbeta_dw_path_c,     npc, no_mol, &
d1846 1
a1846 1
          call allocate_test ( dbeta_dw_path_f, max_ele, no_mol, &
d1864 1
a1864 1
          call allocate_test ( dbeta_dn_path_c,     npc, no_mol, &
d1866 1
a1866 1
          call allocate_test ( dbeta_dn_path_f, max_ele, no_mol, &
a1964 2
if ( spect_der_center ) call dump ( k_spect_dv(1:noUsedChannels,:,:) )

d2268 1
a2268 1
      call frequency_average_derivatives ( frq_avg_sel == 15 )
a2375 1
call dump ( k_spect_dv_frq, name='k_spect_dv_frq' )
a2396 2
        !??? So now we have k_spect_d?.  What do we do with them ???

d3015 4
a3018 3
                &  eta_zxp_w, sps_path, do_calc_w, dbeta_dw_path_c,          &
                &  dbeta_dw_path_f, do_gl,  del_s, ref_corr, dhdz_gw_path,   &
                &  inc_rad_path_slice, i_stop, k_spect_dw_frq(frq_i,:) )
d3024 4
a3027 3
                &  eta_zxp_n, sps_path, do_calc_n, dbeta_dn_path_c,          &
                &  dbeta_dn_path_f, do_gl, del_s, ref_corr, dhdz_gw_path,    &
                &  inc_rad_path_slice, i_stop, k_spect_dn_frq(frq_i,:) )
a3030 1
if ( spect_der_center ) call dump ( dbeta_dv_path_c, name='dbeta_dv_path_c' )
d3033 4
a3036 3
                &  eta_zxp_v, sps_path, do_calc_v, dbeta_dv_path_c,          &
                &  dbeta_dv_path_f, do_gl, del_s, ref_corr, dhdz_gw_path,    &
                &  inc_rad_path_slice, i_stop, k_spect_dv_frq(frq_i,:) )
d3317 1
a3317 1
    & "$Id: FullForwardModel_m.f90,v 2.253 2005/12/10 01:51:54 vsnyder Exp $"
d3326 3
@


2.253
log
@Cannonball polishing
@
text
@a264 1
    real(rp), dimension(:), pointer :: N_PATH       ! Refractivity on path
d345 1
d399 1
a399 1
    real(rp), dimension(:), pointer :: est_scgeocalt
d531 1
a531 1
      & mag_path, MIFDeadTime, n_path, n_path_c, &
d551 1
a551 1
    ! the tangent phi's which may be somewhat different.
d558 1
d560 1
a560 1
      &  (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
d565 5
a569 1
! This is a lazy way to get the surface angle
d580 1
d583 1
a583 1
       & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
d669 3
a671 2
              &  Grids_tmp%phi_basis, z_glgrid, h_glgrid, t_glgrid, dhdz_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad, Grids_tmp%deriv_flags,    &
d690 4
a693 3
              &  Grids_tmp%phi_basis, z_glgrid, h_glgrid, t_glgrid, dhdz_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad,                           &
              &  dummy, h_path(1:no_ele), phi_path(1:no_ele),                &
d706 3
a708 2
              &  Grids_tmp%phi_basis, z_glgrid, h_glgrid, t_glgrid, dhdz_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad, Grids_tmp%deriv_flags,    &
d726 4
a729 3
              &  Grids_tmp%phi_basis, z_glgrid, h_glgrid, t_glgrid, dhdz_glgrid, &
              &  orbIncline%values(1,maf)*Deg2Rad,                           &
              &  dummy, h_path(1:no_ele), phi_path(1:no_ele),                &
a766 9
!         if ( h2o_ind > 0 ) then
!           call refractive_index ( p_path(c_inds), &
!             &  t_path_c(1:npc), n_path_c(1:npc),  &
!             &  h2o_path=sps_path(c_inds, h2o_ind) )
!         else
!           call refractive_index ( p_path(c_inds), &
!             &  t_path_c(1:npc), n_path_c(1:npc) )
!         end if

d768 3
a770 3
          call refractive_index ( p_path(:no_ele), &
            &  t_path(:no_ele), n_path(:no_ele),  &
            &  h2o_path=sps_path(:no_ele, h2o_ind) )
d772 2
a773 2
          call refractive_index ( p_path(:no_ele), &
            &  t_path(:no_ele), n_path(:no_ele) )
d776 1
a776 1
        n_path_c(1:npc) = min ( n_path(c_inds), MaxRefraction )
d871 1
d1184 2
a1186 1
    call deallocate_test ( p_glGrid,     'z_glGrid',     moduleName )
a1233 1
    call deallocate_test ( n_path,           'n_path',           moduleName )
d1622 1
d1645 1
d1662 1
a1722 1
      call allocate_test ( n_path,          max_ele, 'n_path',           moduleName )
d3252 1
a3252 1
    real(rp), dimension(:), pointer :: Est_scgeocalt
d3323 1
a3323 1
    & "$Id: FullForwardModel_m.f90,v 2.251 2005/12/07 01:30:04 vsnyder Exp $"
d3332 3
@


2.252
log
@Mistakenly committed needing Phi_Refractive_Correction
@
text
@d2197 1
a2197 1
      integer :: C, K, P, ShapeInd
d2411 1
a2411 1
      integer :: C, K, P, Sel, ShapeInd
d2445 1
a2445 1
      use RAD_TRAN_M, only: RAD_TRAN, RAD_TRAN_POL, DRAD_TRAN_DF, &
d2678 1
a2678 1
          ! Needed by both rad_tran and rad_tran_pol
d2690 1
a2690 1
          ! Needed by both rad_tran and rad_tran_pol
d3328 3
@


2.251
log
@More on getting correct size for RadV
@
text
@a81 1
use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction
d266 1
a269 1
real(rp), dimension(:), pointer :: PHI_CORR_PATH
d531 2
a532 2
      & mag_path, MIFDeadTime, &
      & n_path, path_dsdh, phi_path, p_path, prod_pol, ptg_angles, &
a541 2
nullify ( phi_corr_path )

d757 9
d767 3
a769 3
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path(1:npc),     &
            &  h2o_path=sps_path(c_inds, h2o_ind) )
d771 2
a772 2
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path(1:npc) )
d775 1
a775 1
        n_path(1:npc) = min ( n_path(1:npc), MaxRefraction )
a776 7
call allocate_test ( phi_corr_path, npc, 'phi_corr_path', moduleName )
call phi_refractive_correction ( n_path(:npc), h_path_c(:npc), phi_corr_path )
call dump ( n_path(:npc), name='n_path', clean=.true. )
call dump ( h_path_c(:npc), name='h_path_c', clean=.true. )
call dump ( phi_corr_path, name='phi_corr_path', clean=.true. )
call deallocate_test ( phi_corr_path, 'phi_corr_path', moduleName )
stop
d870 3
a872 3
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path(npc/2),&
             & one_tan_ht(1), tan_phi(ptg_i), Req, 0.0_rp,                &
             & ptg_angles(ptg_i), r, 1.0_rp, tan_dh_dt(1,:),              &
d875 2
a876 2
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i), n_path(npc/2),&
             & one_tan_ht(1), tan_phi(ptg_i), Req, 0.0_rp,                &
d880 1
a880 1
        n_path(1:npc) = n_path(1:npc) + 1.0_rp
d882 1
a882 1
        call comp_refcor ( h_path_c(:npc), n_path(:npc), &
d1232 1
d1718 2
a1719 1
      call allocate_test ( n_path,              npc, 'n_path',           moduleName )
d3319 1
a3319 1
    & "$Id: FullForwardModel_m.f90,v 2.249 2005/11/21 22:57:41 vsnyder Exp $"
d3328 3
@


2.250
log
@Allocate RadV with correct size for PFA and no LBL
@
text
@d82 1
d270 1
d543 2
d602 6
a607 4
      if ( fwdModelConf%do_freq_avg ) frq_avg_sel = frq_avg_sel + 8
      if ( fwdModelConf%anyPFA(sx) )  frq_avg_sel = frq_avg_sel + 4
      if ( fwdModelConf%anyLBL(sx) )  frq_avg_sel = frq_avg_sel + 2
      if ( any_der )                  frq_avg_sel = frq_avg_sel + 1
d771 7
d2201 1
a2201 1
!          8 Frequency averaging?  N N Y Y Y Y Y Y - N
d2203 1
a2203 1
!          2 LBL?                  Y Y Y Y N N Y Y N -
d3327 3
@


2.249
log
@PFA derivatives stuff, plug some memory leaks
@
text
@d268 1
a268 1
    real(rp), dimension(:), pointer :: PHI_PATH     ! Phi's on path
d740 1
d754 11
a856 11
        if ( h2o_ind > 0 ) then
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path(1:npc),     &
            &  h2o_path=sps_path(c_inds, h2o_ind) )
        else
          call refractive_index ( p_path(c_inds), &
            &  t_path_c(1:npc), n_path(1:npc) )
        end if

        n_path(1:npc) = min ( n_path(1:npc), MaxRefraction )

d899 2
a900 1
        if ( FwdModelConf%do_freq_avg ) call frequency_setup_2 ( vel_cor * &
d1133 1
a1133 1
      if ( FwdModelConf%do_freq_avg ) then
d2219 1
a2219 1
        radiances(ptg_i,:) = radV
d3055 1
a3055 1
      if ( fwdModelConf%do_freq_avg ) then ! ---- Doing freq. avg. -----
d3305 1
a3305 1
    & "$Id: FullForwardModel_m.f90,v 2.248 2005/11/05 03:38:13 vsnyder Exp $"
d3314 3
@


2.248
log
@Frequency_Average_Derivative doesn't need Tau, cannonball polishing
@
text
@a222 1
    logical, dimension(:), pointer :: true_path_flags ! array of trues
d537 1
a537 1
      & t_path, t_path_c, t_path_f, true_path_flags, tscat_path, &
d904 99
a1002 5
        if ( atmos_der ) k_atmos_frq = 0.0
        if ( temp_der ) k_temp_frq = 0.0
        if ( associated(k_spect_dv_frq) ) k_spect_dv_frq = 0.0
        if ( associated(k_spect_dn_frq) ) k_spect_dn_frq = 0.0
        if ( associated(k_spect_dw_frq) ) k_spect_dw_frq = 0.0
d1022 1
a1022 1
          if ( frq_avg_sel == 15 ) then ! See Frequency_Average for values
d1028 1
d1043 1
d1062 1
a1062 2
        call deallocate_test ( channelCenters, 'channelCenters', moduleName )
        nullify ( frequencies )
a1064 1
        call deallocate_test ( frequencies, 'frequencies', moduleName )
d1066 1
d1071 2
d1206 1
d1225 1
a1243 1
    call deallocate_test ( true_path_flags,  'true_path_flags',  moduleName )
a1284 1
      call deallocate_test ( true_path_flags, 'true_path_flags', moduleName )
d1335 4
d1521 1
a1723 2
      call allocate_test ( true_path_flags, max_ele, 'true_path_flags',moduleName)
      true_path_flags = .true.
d1728 1
d2253 1
a2253 41
      ! Frequency Average the temperature derivatives with the appropriate
      ! filter shapes

      if ( temp_der ) call frequency_average_derivative ( grids_tmp, &
        &               k_temp_frq(:noFreqs,:), k_temp(:,ptg_i,:), 1 )

      ! Frequency Average the atmospheric derivatives with the appropriate
      ! filter shapes

      if ( atmos_der ) then
        do k = 1, no_mol
          if ( fwdModelConf%moleculeDerivatives(k) ) &
            & call frequency_average_derivative ( grids_f, &
              & k_atmos_frq(:noFreqs,:), k_atmos(:,ptg_i,:), k )
        end do                        ! Loop over major molecules
      end if                          ! Want derivatives for atmos

      ! Frequency Average the spectroscopic derivatives with the appropriate
      ! filter shapes

      if ( spect_der_center ) then
call dump ( k_spect_dv_frq, name='k_spect_dv_frq' )
        do k = 1, size(fwdModelConf%lineCenter)
          call frequency_average_derivative &
            & ( grids_v, k_spect_dv_frq(:noFreqs,:), k_spect_dv(:,ptg_i,:), k )
        end do
      end if
      if ( spect_der_width ) then
        do k = 1, size(fwdModelConf%lineWidth)
          call frequency_average_derivative &
            & ( grids_w, k_spect_dw_frq(:noFreqs,:), k_spect_dw(:,ptg_i,:), k )
        end do
      end if
      if ( spect_der_width_TDep ) then
        do k = 1, size(fwdModelConf%lineWidth_TDep)
          call frequency_average_derivative &
            & ( grids_n, k_spect_dn_frq(:noFreqs,:), k_spect_dn(:,ptg_i,:), k )
        end do
      end if

        !??? So now we have k_spect_d?.  What do we do with them ???
d2260 1
a2260 1
    subroutine Frequency_Average_Derivative ( Grids, K_Frq, K, Mol )
d2269 1
d2275 14
d2336 51
d2806 1
d3119 2
a3120 2
        & call allocate_test ( k_temp_frq, maxNoPtgFreqs, sv_t_len, 'k_temp_frq', &
                             & moduleName )
d3123 2
a3124 2
        & call allocate_test ( k_atmos_frq, maxNoPtgFreqs, size(grids_f%values), 'k_atmos_frq',&
                             & moduleName )
d3127 2
a3128 2
        & call allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_w, &
                            & 'k_spect_dw_frq', moduleName )
d3130 2
a3131 2
        & call allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_n, &
                            & 'k_spect_dn_frq', moduleName )
d3133 2
a3134 2
        & call allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_v, &
                            & 'k_spect_dv_frq', moduleName )
d3303 1
a3303 1
    & "$Id: FullForwardModel_m.f90,v 2.247 2005/11/03 03:57:45 vsnyder Exp $"
d3312 3
@


2.247
log
@Don't try to look at filter shapes for DACS
@
text
@d929 1
a929 2
          if ( FwdModelConf%anyLBL(sx) .and. FwdModelConf%do_freq_avg .and. &
            & any_der ) then
d932 2
a933 2
            ! and every point along the path.  Then multiply by Tau_PFA to
            ! combine PFA contribution.
d2123 1
a2123 1
            if ( fwdModelConf%anyPFA(sx) ) then ! sel = 14
d2157 1
a2157 2
        &               Tau_LBL, Tau_PFA,  k_temp_frq(:noFreqs,:), &
        &               k_temp(:,ptg_i,:), 1 )
d2165 2
a2166 3
            & call frequency_average_derivative ( grids_f, Tau_LBL, Tau_PFA, &
              & k_atmos_frq(:noFreqs,:), &
              & k_atmos(:,ptg_i,:), k )
d2177 1
a2177 2
            & ( grids_v, Tau_LBL, Tau_PFA, k_spect_dv_frq(:noFreqs,:), &
            &   k_spect_dv(:,ptg_i,:), k )
d2183 1
a2183 2
            & ( grids_w, Tau_LBL, Tau_PFA, k_spect_dw_frq(:noFreqs,:), &
            &   k_spect_dw(:,ptg_i,:), k )
d2189 1
a2189 2
            & ( grids_n, Tau_LBL, Tau_PFA, k_spect_dn_frq(:noFreqs,:), &
            &   k_spect_dn(:,ptg_i,:), k )
d2200 1
a2200 2
    subroutine Frequency_Average_Derivative ( Grids, Tau_LBL, Tau_PFA, &
      & K_Frq, K, Mol )
a2205 1
      type(tau_t), intent(in) :: Tau_LBL, Tau_PFA ! Tau structures
d2265 1
a2265 2
      ! and every point along the path.  Then multiply by Tau_PFA to
      ! combine PFA contribution.
d3176 1
a3176 1
    & "$Id: FullForwardModel_m.f90,v 2.246 2005/11/02 21:38:48 vsnyder Exp $"
d3185 3
@


2.246
log
@Repair a broken tracing message
@
text
@d2966 8
a2973 6
          shapeInd = channels(i)%shapeInds(sx)
          k = Size(FilterShapes(shapeInd)%FilterGrid)
          r1 = FilterShapes(shapeInd)%FilterGrid(1)
          r2 = FilterShapes(shapeInd)%FilterGrid(k)
          min_ch_freq_grid = MIN(r1, r2, min_ch_freq_grid)
          max_ch_freq_grid = MAX(r1, r2, max_ch_freq_grid)
d3185 1
a3185 1
    & "$Id: FullForwardModel_m.f90,v 2.245 2005/11/01 23:02:08 vsnyder Exp $"
d3194 3
@


2.245
log
@PFA Derivatives, use precomputed ShapeInds
@
text
@d586 3
a1567 1
        call Trace_End ( 'ForwardModel.Hydrostatic' )
d3183 1
a3183 1
    & "$Id: FullForwardModel_m.f90,v 2.244 2005/09/17 01:02:38 vsnyder Exp $"
d3192 3
@


2.244
log
@Out of bounds subscript
@
text
@d73 1
a73 1
    use MLSCommon, only: R4, R8, RP, RV, IP
d121 3
d143 1
a143 1
    integer :: Nlvl                     ! Size of integration grid
d245 1
d296 1
d335 2
d338 1
a338 1
    real(rp), dimension(:,:), pointer :: K_ATMOS_FRQ  ! dI/dVMR, frq X vmr
d342 1
a342 1
    real(rp), dimension(:,:), pointer :: K_TEMP_FRQ   ! Storage for Temp. deriv.
d346 2
a355 1
    real(rp), dimension(:,:), pointer :: Tscat_PATH   ! TScat on path
d358 1
a364 2
    real(rp), dimension(:,:,:), pointer :: Sum_DDel_LBL ! Sum d_delta_dT along path
    real(rp), dimension(:,:,:), pointer :: Sum_DDel_PFA ! Sum d_delta_dT along path
a490 14
    if ( e_stop > 0.0_rp ) e_stop = log(epsilon(0.0_rp)) ! only once

    fmStat%flags = 0 ! Assume no errors

    temp_der = present ( jacobian ) .and. FwdModelConf%temp_der
    atmos_der = present ( jacobian ) .and. FwdModelConf%atmos_der

    spect_der = present ( jacobian ) .and. FwdModelConf%spect_der
    spect_der_center = spect_der .and. associated(fwdModelConf%lineCenter)
    spect_der_width = spect_der .and. associated(fwdModelConf%lineWidth)
    spect_der_width_TDep = spect_der .and. associated(fwdModelConf%lineWidth_TDep)

    any_der = temp_der .or. atmos_der .or. spect_der

d494 4
a497 1
    ! Nullify all our pointers that are allocated!
d500 1
a500 1
      & alpha_path_polarized_f, beta_path_c, &
d524 1
a524 2
      & eta_zxp_v, eta_zxp_w, &
      & eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, &
d527 1
a527 1
      & ipsd, iwc_path, k_atmos, k_atmos_frq, &
d532 2
a533 2
      & n_path, path_dsdh, phi_path, p_path, &
      & prod_pol, ptg_angles, rad_FFT, radiances, RadV, ref_corr, req_out, &
d535 1
a535 2
      & spect_n_path, spect_v_path, spect_w_path, &
      & sps_path, sum_ddel_lbl, sum_ddel_pfa, &
d538 2
a539 2
      & t_path, t_path_c, t_path_f, true_path_flags, &
      & tscat_path, t_script_lbl, t_script_pfa, tt_path, tt_path_c, &
d542 1
a542 283
    ! Extra DEBUG for Nathaniel and Bill
!   nullify ( reqs, tan_hts, tan_temps )

    ! Work out what we've been asked to do -----------------------------------

    beta_group => fwdModelConf%beta_group
    no_mol = size(fwdModelConf%beta_group)
    call deriveFromForwardModelConfig ( fwdModelConf )
    channels => fwdModelConf%channels
    DACsStaging => fwdModelConf%DACsStaging
    usedDACSSignals => fwdModelConf%usedDACSSignals
    noUsedChannels = size(channels)
    noUsedDacs = size(usedDACSSignals)

    ! Identify the vector quantities we're going to need.
    ! The key is to identify the signal we'll be working with first
    firstSignal => fwdModelConf%signals(1) ! Config has verified that signals
      ! are all for same radiometer (actually LO), module and sideband
    sideband = merge ( 0, firstSignal%sideband, fwdModelConf%forceFoldedOutput )

    ! Create the data structures for the species.  Get the
    ! spectroscopy parameters from the state vector.
    ! This has to be done AFTER deriveFromForwardModelConfig.

    call get_species_data ( fwdModelConf, fwdModelIn, fwdModelExtra )

    ! Start sorting out stuff from state vector ------------------------------

    ! Identify the appropriate state vector components
    ! VMRS are in beta_group%qty, gotten by get_species_data
    gph => GetVectorQuantityByType ( fwdModelExtra, quantityType=l_gph )
    temp => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature, config=fwdModelConf )
    ptan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule, &
      & foundInFirst=ptan_der, config=fwdModelConf )
    phitan => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, instrumentModule=firstSignal%instrumentModule, &
      & config=fwdModelConf )
    orbIncline => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_orbitInclination, config=fwdModelConf )
    spaceRadiance => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_spaceRadiance, config=fwdModelConf )
    earthRefl => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_earthRefl, config=fwdModelConf )
    refGPH => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_refGPH, config=fwdModelConf )
    losVel => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule, &
      & config=fwdModelConf )
    scGeocAlt => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_scGeocAlt )
    if ( FwdModelConf%polarized ) then
      magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_magneticField, config=fwdModelConf )
      ECRtoFOV => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_ECRtoFOV, config=fwdModelConf )
    end if
    if ( fwdModelConf%scanAverage ) then
      work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_l1bMIF_TAI )
      l1bMIF_TAI => work%values
      work => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_MIFDeadTime )
      MIFDeadTime => work%values ! Only the (1,1) element is used.
    end if
    if ( FwdModelConf%incl_cld ) then
      cloudIce => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_cloudIce, noError=.true., config=fwdModelConf )
      cloudWater => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_cloudWater, noError=.true., config=fwdModelConf )
      sizeDistribution => GetQuantityForForwardModel( fwdModelIn, fwdModelExtra, &
        & quantityType=l_sizeDistribution, noError=.true., config=fwdModelConf )
    end if
    if ( FwdModelConf%i_saturation /= l_clear ) then
      boundaryPressure => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_boundaryPressure, config=fwdModelConf )
    end if

    ! Check that RefGPH and Temp have the same hGrid.  This is not checked in
    ! Construct or when the config is created.
    if ( .not. doHGridsMatch ( refGPH, temp ) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, 'Different horizontal grids for refGPH and temperature' )

    ! Check that we have radiances for the channels that are used
    do sigInd = 1, size(fwdModelConf%signals)
      ! This just emits an error message and stops if we don't have a radiance.
      ! We don't use the vector quantity -- at least not right away.  We get
      ! it again later.
      thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
        & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband )
    end do

    maxNoFreqs = 0
    maxNoSurfs = 0
    do sps_i = 1, no_mol
      maxNoFreqs = max(maxNoFreqs, beta_group(sps_i)%qty%qty%template%noChans)
      maxNoSurfs = max(maxNoSurfs, beta_group(sps_i)%qty%qty%template%noSurfs)
    end do

    MAF = fmStat%maf

    Vel_Rel = losvel%values(1,maf) / speedOfLight ! Needed for PFA
    Vel_Cor = 1.0_rp - Vel_Rel

! Sort out a remaining flag
    ptan_der = ptan_der .and. present ( jacobian )

! Create the Grids_tmp structure:

    !??? Should .true. be temp_der ???
    call load_one_item_grid ( grids_tmp, temp, phitan, maf, fwdModelConf, .true. )

    windowStart = grids_tmp%windowStart(1)
    windowFinish = grids_tmp%windowFinish(1)
    no_sv_p_t = grids_tmp%l_p(1) ! phi == windowFinish - windowStart + 1
    n_t_zeta = grids_tmp%l_z(1)  ! zeta
    sv_t_len = grids_tmp%p_len   ! zeta X phi == n_t_zeta * no_sv_p_t

    if ( FwdModelConf%incl_cld ) &
      & call load_one_item_grid ( grids_iwc, cloudIce, phitan, maf, &
        & fwdModelConf, .false., .false. )

    if ( FwdModelConf%polarized ) &
      & call load_one_item_grid ( grids_mag, magfield, phitan, maf, &
        & fwdModelConf, .false. )

! Now, allocate other variables we're going to need later ----------------

    ! Stuff for clouds
    do_cld = .true. !JJ !for Jonathan use Only
!    if ( do_cld ) then !JJ

    if ( FwdModelConf%incl_cld ) then  ! Do this block only if incl_cld is true

      !??? Is thisRadiance appropriate here ???
      call Allocate_test ( closestInstances, thisRadiance%template%noInstances,    &
      & 'closestInstances', ModuleName )
      call FindClosestInstances ( temp, thisRadiance, closestInstances )
      inst = closestInstances(MAF)

      ! checking done in ForwardModelSupport%ConstructForwardModelConfig
      nspec = no_mol ! Will be at least 3 if l_n2o is included, because
                     ! l_h2o and l_o3 are required
      noSurf  = temp%template%noSurfs
      call allocate_test ( vmrArray, nspec, n_t_zeta, 'vmrArray', ModuleName )
      vmrarray = 0.0_r8

      do j = 1, nspec      ! Loop over species

        if ( fwdModelConf%molecules(j) == l_h2o ) then
          ispec = 1
        else if ( fwdModelConf%molecules(j) == l_o3 ) then
          ispec = 2
        else if ( fwdModelConf%molecules(j) == l_n2o ) then
          ispec = 3
        else
          cycle
        end if

        vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
          & quantityType=l_vmr, molecule=fwdModelConf%molecules(j) )

        novmrSurf = vmr%template%nosurfs

        call InterpolateValues ( &
        & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
        & reshape(vmr%values(:,inst),(/novmrSurf/)),      &    ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
        & vmrArray(ispec,:),                              &    ! New Y
        & 'Linear', extrapolate='Clamp' )

      end do ! End of Loop over species

    end if ! end of cloud block

! Set up our temporary `state vector' like arrays ------------------------

    call load_sps_data ( FwdModelConf, phitan, maf, grids_f, &
      & h2o_ind, ext_ind )
    if ( associated(fwdModelConf%lineCenter) ) call load_sps_data ( &
      & FwdModelConf, phitan, maf, grids_v, &
      & qtyStuffIn=fwdModelConf%lineCenter%qty )
    if ( associated(fwdModelConf%lineWidth) ) call load_sps_data ( &
      & FwdModelConf, phitan, maf, grids_w, &
      & qtyStuffIn=fwdModelConf%lineWidth%qty )
    if ( associated(fwdModelConf%lineWidth_TDep) ) call load_sps_data ( &
      & FwdModelConf, phitan, maf, grids_n, &
      & qtyStuffIn=fwdModelConf%lineWidth_TDep%qty )

    if ( index(switches,'grids') /= 0 ) then ! dump the grids
      call dump ( grids_f )
      if ( associated(fwdModelConf%lineCenter) ) call dump ( grids_v )
      if ( associated(fwdModelConf%lineWidth) ) call dump ( grids_w )
      if ( associated(fwdModelConf%lineWidth_TDep) ) call dump ( grids_n )
    end if

! modify h2o mixing ratio if a special supersaturation is requested
    if ( fwdModelConf%i_saturation /= l_clear ) &
      & call modify_values_for_supersat ( fwdModelConf, grids_f, h2o_ind, &
        & grids_tmp, boundaryPressure )

! set up output pointing angles ------------------------------------------
! note we have to compute req !!!!!!!

! compute equivalent earth radius at phi_t(1), nearest surface

    call allocate_test ( req_out, ptan%template%nosurfs, 'req_out', &
                       & moduleName )
    earthradc = earthRadA*earthRadB / &
          & SQRT((earthRadA**2-earthRadB**2) * &
                 &   SIN(orbIncline%values(1,maf)*Deg2Rad)**2 + &
                 & earthRadB**2)

!{\begin{equation*}\begin{split}
! R_{eq} =\;& \sqrt \frac{R_a^4 \sin^2 \phi + R_c^4 \cos^2 \phi}
!                       {R_a^2 \cos^2 \phi + R_c^2 \sin^2 \phi}\\
!        =\;& \sqrt \frac{R_a^4 - (R_a^2+R_c^2)(R_a^2-R_c^2) \cos^2 \phi}
!                       {R_c^2 +              (R_a^2-R_c^2) \cos^2 \phi}
! \end{split}\end{equation*}

    req_out = (earthrada-earthradc)*(earthrada+earthradc) * &
      & COS(phitan%values(:,maf)*Deg2Rad)**2
    req_out = 0.001_rp * SQRT( &
      & ( earthrada**4 - (earthrada**2+earthradc**2) * req_out ) / &
      & ( earthradc**2 + req_out ) )

    call allocate_test ( tan_chi_out, ptan%template%nosurfs, 'tan_chi_out', &
                       & moduleName )
    call allocate_test ( dx_dh_out, ptan%template%nosurfs, 'dx_dh_out', &
                       & moduleName )
    call allocate_test ( dh_dz_out, ptan%template%nosurfs, 'dh_dz_out', &
                       & moduleName )

    if ( temp_der ) then
      call allocate_test ( dxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'dxdt_tan', moduleName )
      call allocate_test ( d2xdxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'd2xdxdt_tan', moduleName )
      call allocate_test ( rad_fft, no_fft, 'Rad_FFT', moduleName )
    end if

    ! Temperature's windowStart:windowFinish are correct here.
    ! RefGPH and Temperature have the same horizontal basis.
    ! Grids_F is only needed for H2O, for calculating refractive index.
    call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
       & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
       & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
       & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
       & orbIncline%values(1,maf)*Deg2Rad, 0.0_rp, &
       & req_out, grids_f, h2o_ind, tan_chi_out, dh_dz_out, dx_dh_out, &
       & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )

! Compute Gauss Legendre (GL) grid ---------------------------------------

    call compute_GL_grid ( fwdModelConf, temp, beta_group%qty, nlvl, maxVert, &
      &                    p_glgrid, z_glgrid, tan_inds, tan_press )

! Allocate more GL grid stuff

    call allocate_test ( h_glgrid,    maxVert, no_sv_p_t, 'h_glgrid', moduleName )
    call allocate_test ( t_glgrid,    maxVert, no_sv_p_t, 't_glgrid', moduleName )
    call allocate_test ( dhdz_glgrid, maxVert, no_sv_p_t, 'dhdz_glgrid', &
                      &  moduleName )
    call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                      &  'dh_dt_glgrid', moduleName )
    call allocate_test ( ddhidhidtl0, maxVert, n_t_zeta, no_sv_p_t, &
                      &  'ddhidhidtl0', moduleName )

    surfaceTangentIndex = COUNT(tan_inds == 1)

    no_tan_hts = size(tan_inds)

    ! Extra DEBUG for Nathaniel and Bill
!   call allocate_test ( tan_hts,       no_tan_hts, 'tan_hts',       moduleName )
!   call allocate_test ( tan_temps,     no_tan_hts, 'tan_temps',     moduleName )
!   call allocate_test ( reqs,          no_tan_hts, 'reqs',          moduleName )

    ! estimate tan_phi and scgeocalt
    call estimate_tan_phi ( no_tan_hts, nlvl, maf, phitan, ptan, &
                          & scgeocalt, losvel, tan_press, tan_phi, est_scgeocalt, &
                          & est_los_vel )

d545 2
a585 252
 ! Now, allocate other variables we're going to need later ----------------

    if ( toggle(emit) .and. levels(emit) > 0 ) then
      call Trace_End ( 'ForwardModel.Hydrostatic' )
      call Trace_Begin ( 'ForwardModel.Allocate' )
    end if

    call allocate_test ( tan_temp, no_tan_hts, 'tan_temp', moduleName )

    ! Allocate path quantities -----------------------------------------------

    max_ele = 2*maxVert     ! maximum possible

    ! Now allocate all path related... with maximum length..

    brkpt = maxVert
    npc = 2 * (brkpt + Ng) / Ngp1
    ! MJS says that this is the same as npc = 2 * Nlvl

    ! This can be put outside the mmaf loop

    call allocate_test ( alpha_path_c,        npc, 'alpha_path_c',     moduleName )
    call allocate_test ( alpha_path_f,    max_ele, 'alpha_path_f',     moduleName )
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path_cloud_c',moduleName )
    call allocate_test ( cg_inds,             npc, 'cg_inds',          moduleName )
    call allocate_test ( c_inds_b,            npc, 'c_inds_b',         moduleName )
    call allocate_test ( del_s,               npc, 'del_s',            moduleName )
    call allocate_test ( del_zeta,            npc, 'del_zeta',         moduleName )
    call allocate_test ( dhdz_gw_path,    max_ele, 'dhdz_gw_path',     moduleName )
    call allocate_test ( dhdz_path,       max_ele, 'dhdz_path',        moduleName )
    call allocate_test ( do_gl,               npc, 'do_gl',            moduleName )
    call allocate_test ( dsdz_gw_path,    max_ele, 'dsdz_gw_path',     moduleName )
    call allocate_test ( f_inds,         ng * npc, 'f_inds',           moduleName )
    call allocate_test ( gl_inds_b,       max_ele, 'gl_inds_b',        moduleName )
    call allocate_test ( h_path_c,            npc, 'h_path_c',         moduleName )
    call allocate_test ( h_path_f,        max_ele, 'h_path_f',         moduleName )
    call allocate_test ( h_path,          max_ele, 'h_path',           moduleName )
    call allocate_test ( incoptdepth,         npc, 'incoptdept',       moduleName )
    call allocate_test ( n_path,              npc, 'n_path',           moduleName )
    call allocate_test ( path_dsdh,       max_ele, 'path_dsdh',        moduleName )
    call allocate_test ( phi_path,        max_ele, 'phi_path',         moduleName )
    call allocate_test ( p_path,          max_ele, 'p_path',           moduleName )
    call allocate_test ( ref_corr,            npc, 'ref_corr',         moduleName )
    call allocate_test ( tanh1_c,             npc, 'tanh1_c',          moduleName )
    call allocate_test ( tanh1_f,         max_ele, 'tanh1_f',          moduleName )
    call allocate_test ( t_path_c,            npc, 't_path_c',         moduleName )
    call allocate_test ( t_path_f,        max_ele, 't_path_f',         moduleName )
    call allocate_test ( t_path,          max_ele, 't_path',           moduleName )
    call allocate_test ( tt_path_c,           npc, 'tt_path_c',        moduleName )
    call allocate_test ( w0_path_c,           npc, 'w0_path_c',        moduleName )
    call allocate_test ( z_path,          max_ele, 'z_path',           moduleName )

    call allocate_test ( beta_path_c,       npc, no_mol, 'beta_path_c',   moduleName )
    call allocate_test ( beta_path_f,   max_ele, no_mol, 'beta_path_f',   moduleName )
    call allocate_test ( do_calc_fzp,   max_ele, size(grids_f%values),  'do_calc_fzp',   moduleName )
    call allocate_test ( do_calc_zp,    max_ele, grids_f%p_len,  'do_calc_zp',     moduleName )
    call allocate_test ( eta_fzp,       max_ele, size(grids_f%values),  'eta_fzp', moduleName )
    call allocate_test ( eta_zp,        max_ele, grids_f%p_len,  'eta_zp', moduleName )
    call allocate_test ( sps_path,      max_ele, no_mol, 'sps_path',       moduleName )
    call allocate_test ( true_path_flags, max_ele, 'true_path_flags',moduleName)
    true_path_flags = .true.

    if ( fwdModelConf%Incl_Cld ) then
!    if ( do_cld ) then !JJ
      call allocate_test ( do_calc_iwc,    max_ele, size(grids_iwc%values),  'do_calc_iwc',  moduleName )
      call allocate_test ( eta_iwc,        max_ele, size(grids_iwc%values),  'eta_iwc',      moduleName )
      call allocate_test ( eta_iwc_zp,     max_ele, grids_iwc%p_len,  'eta_iwc_zp',    moduleName )
      call allocate_test ( iwc_path,       max_ele, 1, 'iwc_path',           moduleName )
      call allocate_test ( ipsd,           max_ele, 'IPSD', moduleName )
      call allocate_test ( wc,         fwdModelConf%no_cloud_species, max_ele, 'WC', moduleName )

      call allocate_test ( Scat_ang, fwdModelConf%num_scattering_angles, 'Scat_ang', moduleName )
      call allocate_test ( scat_src%values, n_t_zeta, fwdModelConf%num_scattering_angles, &
                           &'scat_src', moduleName )
      call allocate_test ( scat_alb%values, n_t_zeta, 2, 'scat_alb', moduleName )
      call allocate_test (  cld_ext%values, n_t_zeta, 2, 'cld_ext', moduleName )

    end if

    if ( temp_der ) then ! Temperature derivatives

      call allocate_test ( dAlpha_dT_path_c,     npc, 'dAlpha_dT_path_c', moduleName )
      call allocate_test ( dAlpha_dT_path_f, max_ele, 'dAlpha_dT_path_f', moduleName )

      call allocate_test ( k_temp, noUsedChannels, no_tan_hts, sv_t_len, &
                         & 'k_temp', moduleName )

      call allocate_test ( d_t_scr_dt,         npc, sv_t_len, 'd_t_scr_dt', &
                                                              & moduleName )
      call allocate_test ( dBeta_dT_path_c,    npc, no_mol,   'dBeta_dT_path_c', &
                                                              & moduleName )
      call allocate_test ( dBeta_dT_path_f, max_ele, no_mol,   'dBeta_dT_path_f', &
                                                              & moduleName )
      call allocate_test ( dh_dt_path,      max_ele, sv_t_len, 'dh_dt_path', &
                                                              & moduleName )
      call allocate_test ( dh_dt_path_c,       npc, sv_t_len, 'dh_dt_path_c', &
                                                              & moduleName )
      call allocate_test ( dh_dt_path_f,    max_ele, sv_t_len, 'dh_dt_path_f', &
                                                              & moduleName )
      call allocate_test ( do_calc_hyd,     max_ele, sv_t_len, 'do_calc_hyd', &
                                                              & moduleName )
      call allocate_test ( do_calc_hyd_c,      npc, sv_t_len, 'do_calc_hyd_c', &
                                                              & moduleName )
      call allocate_test ( do_calc_t,       max_ele, sv_t_len, 'do_calc_t', &
                                                              & moduleName )
      call allocate_test ( do_calc_t_c,        npc, sv_t_len, 'do_calc_t_c', &
                                                              & moduleName )
      call allocate_test ( do_calc_t_f,     max_ele, sv_t_len, 'do_calc_t_f', &
                                                              & moduleName )
      call allocate_test ( dTanh_dT_c,          npc, 'dTanh_dT_c', moduleName )
      call allocate_test ( dTanh_dT_f,      max_ele, 'dTanh_dT_f', moduleName )
      call allocate_test ( eta_zxp_t,       max_ele, sv_t_len, 'eta_zxp_t', &
                                                              & moduleName )
      call allocate_test ( eta_zxp_t_c,         npc, sv_t_len, 'eta_zxp_t_c', &
                                                              & moduleName )
      call allocate_test ( eta_zxp_t_f,     max_ele, sv_t_len, 'eta_zxp_t_f', &
                                                              & moduleName )
      call allocate_test ( tan_dh_dt,    1, sv_t_len, 'tan_dh_dt',    moduleName )
      call allocate_test ( tan_d2h_dhdt, 1, sv_t_len, 'tan_d2h_dhdt', moduleName )
      call allocate_test ( t_der_path_flags, max_ele,          't_der_path_flags', &
                                                              & moduleName )

    end if ! temp_der

    if ( atmos_der ) then
      call allocate_test ( d_delta_df, npc, size(grids_f%values), 'd_delta_df', &
                                                              & moduleName )
      call allocate_test ( k_atmos, noUsedChannels, no_tan_hts, &
        & size(grids_f%values), 'k_atmos', moduleName )
      k_atmos = 0.0
    end if ! atmos_der

    if ( associated(fwdModelConf%lineCenter) ) then
      call allocate_test ( spect_v_path, max_ele, size(fwdModelConf%lineCenter), &
        & 'spect_v_path', moduleName )
      f_len_v = grids_v%l_v(ubound(grids_v%l_v,1))
      call allocate_test ( do_calc_v, max_ele, f_len_v, 'do_calc_v', &
                        &  moduleName )
      call allocate_test ( eta_zxp_v, max_ele, f_len_v, 'eta_zxp_v', &
                        &  moduleName )
      if ( spect_der ) then
        call allocate_test ( k_spect_dv, noUsedChannels, no_tan_hts, f_len_v, &
          & 'k_spect_dv', moduleName )
        call allocate_test ( dbeta_dv_path_c,     npc, no_mol, &
          & 'dbeta_dv_path_c', moduleName )
        call allocate_test ( dbeta_dv_path_f, max_ele, no_mol, &
          & 'dbeta_dv_path_f', moduleName )
      end if
    else
      f_len_v = 0
    end if
    if ( associated(fwdModelConf%lineWidth) ) then
      call allocate_test ( spect_w_path, max_ele, size(fwdModelConf%lineWidth), &
        & 'spect_w_path', moduleName )
      f_len_w = grids_w%l_v(ubound(grids_w%l_v,1))
      call allocate_test ( do_calc_w, max_ele, f_len_w, 'do_calc_w', &
                        &  moduleName )
      call allocate_test ( do_calc_w_c,   npc, f_len_w, 'do_calc_w_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_w, max_ele, f_len_w, 'eta_zxp_w', &
                        &  moduleName )
      if ( spect_der ) then
        call allocate_test ( k_spect_dw, noUsedChannels, no_tan_hts, f_len_w, &
          & 'k_spect_dw', moduleName )
        call allocate_test ( dbeta_dw_path_c,     npc, no_mol, &
          & 'dbeta_dw_path_c', moduleName )
        call allocate_test ( dbeta_dw_path_f, max_ele, no_mol, &
          & 'dbeta_dw_path_f', moduleName )
      end if
    else
      f_len_w = 0
    end if
    if ( associated(fwdModelConf%lineWidth_TDep) ) then
      f_len_n = grids_n%l_v(ubound(grids_n%l_v,1))
      call allocate_test ( do_calc_n, max_ele, f_len_n, 'do_calc_n', &
                        &  moduleName )
      call allocate_test ( eta_zxp_n, max_ele, f_len_n, 'eta_zxp_n', &
                        &  moduleName )
      call allocate_test ( spect_n_path, max_ele, size(fwdModelConf%lineWidth_TDep), &
        & 'spect_n_path', moduleName )
      if ( spect_der ) then
        call allocate_test ( k_spect_dn, noUsedChannels, no_tan_hts, f_len_n, &
          & 'k_spect_dn', moduleName )
        call allocate_test ( dbeta_dn_path_c,     npc, no_mol, &
          & 'dbeta_dn_path_c', moduleName )
        call allocate_test ( dbeta_dn_path_f, max_ele, no_mol, &
          & 'dbeta_dn_path_f', moduleName )
      end if
    else
      f_len_n = 0
    end if

    if ( FwdModelConf%polarized ) then
      call allocate_test ( eta_mag_zp,     max_ele, grids_mag%p_len, &
        & 'eta_mag_zp', moduleName )
      call allocate_test ( mag_path,       max_ele, magfield%template%noChans+1, &
        & 'mag_path', moduleName )
      call allocate_test ( alpha_path_polarized, 1, npc, &
        & 'alpha_path_polarized', moduleName, low1=-1 )
      call allocate_test ( beta_path_polarized, 1, npc, no_mol, &
        & 'beta_path_polarized', moduleName, low1=-1 )
      call allocate_test ( alpha_path_polarized_f, 1, max_ele, &
        & 'alpha_path_polarized_f', moduleName, low1=-1 )
      call allocate_test ( beta_path_polarized_f, 1, max_ele, no_mol, &
        & 'beta_path_polarized_f', moduleName, low1=-1 )
      call allocate_test ( gl_delta_polarized, 1, max_ele, &
        & 'gl_delta_polarized', moduleName, low1=-1 )
      call allocate_test ( incoptdepth_pol, 2, 2, npc, &
        & 'incoptdepth_pol', moduleName )
      call allocate_test ( prod_pol, 2, 2, npc, 'prod_pol', moduleName )
      call allocate_test ( tau_pol, 2, 2, npc, 'tau_pol', moduleName )
      call allocate_test ( deltau_pol, 2, 2, npc, 'deltau_pol', moduleName )
      if ( atmos_der ) then
        call allocate_test ( d_rad_pol_df, 2, 2, grids_f%l_v(ubound(grids_f%l_v,1)), &
          & 'd_rad_pol_df', moduleName )
        allocate ( de_df(2,2,npc,grids_f%l_v(ubound(grids_f%l_v,1))), stat=ier )
        call test_allocate ( ier, moduleName, 'de_df', &
          & (/1,1,1,1/), (/2,2,npc,grids_f%l_v(ubound(grids_f%l_v,1))/), e_rp )
      end if
      if ( temp_der ) then
        call allocate_test ( d_rad_pol_dt, 2, 2, sv_t_len, &
          & 'd_rad_pol_dt', moduleName )
        call allocate_test ( dAlpha_dT_polarized_path_c, 1, npc, &
          & 'dAlpha_dT_polarized_path_c', moduleName, low1=-1 )
        call allocate_test ( dAlpha_dT_polarized_path_f, 1, max_ele, &
          & 'dAlpha_dT_polarized_path_f', moduleName, low1=-1 )
        call allocate_test ( dBeta_dT_polarized_path_c, 1, npc, no_mol, &
          & 'dBeta_dT_polarized_path_c', moduleName, low1=-1 )
        call allocate_test ( dBeta_dT_polarized_path_f, 1, max_ele, no_mol, &
          & 'dBeta_dT_polarized_path_f', moduleName, low1=-1 )
        allocate ( de_dt(2,2,npc,sv_t_len), stat=ier )
        call test_allocate ( ier, moduleName, 'de_dt', &
          & (/1,1,1,1/), (/2,2,npc,sv_t_len/), e_rp )
        call allocate_test ( dincoptdepth_pol_dt, 2, 2, npc, &
          & 'dincoptdepth_pol_dt', moduleName )
      end if
    end if

    call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', moduleName )
    call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
                       & 'radiances', moduleName )

    call allocate_test ( dx_dt, no_tan_hts,sv_t_len, 'dx_dt',moduleName )
    call allocate_test ( d2x_dxdt,no_tan_hts,sv_t_len, 'd2x_dxdt',moduleName )

    if ( toggle(emit) .and. levels(emit) > 0 ) then
      call Trace_End ( 'ForwardModel.Allocate' )
      call Trace_Begin ( 'ForwardModel.SidebandLoop' )
    end if

    npcmax = npc

d588 1
d594 7
d902 6
a923 6
        if ( FwdModelConf%do_freq_avg ) then
          call get_channel_centers ( channelCenters )
        else
          channelCenters => frequencies
        end if

d926 8
d944 2
a945 2
            call dump ( tau_pfa, size(channelCenters), ' Tau_PFA:' )
            call dump ( t_script_pfa(:npc,:size(channelCenters)), 'T_Script_PFA' )
d949 1
a949 3
        call frequency_average ! or not
        if ( FwdModelConf%do_freq_avg ) &
          & call deallocate_test ( channelCenters, 'channelCenters', moduleName )
d964 8
a971 1
      call deallocate_test ( frequencies, 'frequencies', moduleName )
a980 8
      if ( FwdModelConf%anyPFA(sx) ) then
        call deallocate_test ( t_script_PFA, 'T_Script_PFA', moduleName )
        call destroy_tau ( tau_PFA, "Tau_PFA", moduleName )
        if ( temp_der ) then
          call deallocate_test ( sum_ddel_LBL, 'Sum_dDel_LBL', moduleName )
          call deallocate_test ( sum_ddel_PFA, 'Sum_dDel_PFA', moduleName )
        end if
      end if
d1007 6
d1102 1
d1117 1
a1117 1
    call deallocate_test ( incoptdepth,      'incoptdept',       moduleName )
a1126 2
    call deallocate_test ( t_script_lbl,     't_script_lbl',     moduleName )
    call deallocate_test ( t_script_pfa,     't_script_pfa',     moduleName )
a1207 1

a1219 1

d1258 572
d1847 2
d2036 18
d2077 2
a2078 2
      use Freq_Avg_m, only: Freq_Avg_Avg, Freq_Avg_Setup
      use Rad_Tran_M, only: Rad_Tran_PFA
d2080 1
a2080 3
      integer :: Channel
      real(r8) :: dF
      integer :: I, K, KHi, KLo, ShapeInd, SigInd
d2085 22
a2106 3
      if ( FwdModelConf%anyLBL(sx) .and. fwdModelConf%do_freq_avg ) then
        ! Do DACs stuff for all DACs channels first
        do i = 1, noUsedDACS
d2108 1
a2108 1
            & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
d2110 1
a2110 1
            & RadV(:noFreqs), DACsStaging(:,i) )
d2112 6
d2119 8
a2126 17
        do i = 1, noUsedChannels
          sigInd = channels(i)%signal
          channel = channels(i)%used
          if ( channels(i)%dacs == 0 ) then
            shapeInd = MatchSignal ( filterShapes%signal, &
              & fwdModelConf%signals(sigInd), sideband = thisSideband, &
              & channel=channel )
            if ( shapeInd == 0 ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              &    "No matching channel shape information" )
            call freq_avg_setup ( frequencies, &
              &   FilterShapes(shapeInd)%FilterGrid, klo, khi, dF )
            if ( fwdModelConf%anyPFA(sx) ) then
            ! Combine LBL and PFA Tau's to get radiances.  We have to do
            ! Rad_Tran_PFA for _all_ of RadV(:noFreqs), not just for
            ! RadV(klo:khi), so as not to screw up the spline in Freq_Avg_Avg.
              call rad_tran_PFA (i, tau_LBL, tau_PFA, t_script_pfa, radV(:noFreqs) )
d2128 4
a2131 4
            call freq_Avg_Avg ( frequencies, &
              &   filterShapes(shapeInd)%filterGrid,  &
              &   filterShapes(shapeInd)%filterShape, &
              &   radV(:noFreqs), klo, khi, dF, radiances(ptg_i,i) )
d2133 1
a2133 1
            radiances(ptg_i,i) = DACsStaging(channel,channels(i)%dacs)
d2136 11
a2146 5
      else if ( FwdModelConf%anyPFA(sx) ) then
        ! Get radiances from PFA Tau's alone
        do i = 1, noUsedChannels
          radiances(ptg_i,i) = dot_product(tau_pfa%tau(:tau_pfa%i_stop(i),i), &
            &                              t_script_pfa(:tau_pfa%i_stop(i),i))
d2148 3
a2150 3
      else
        radiances(ptg_i,1:noUsedChannels) = radV(1:)
      end if
d2155 3
a2157 2
      if ( temp_der ) call frequency_average_derivative &
        &                  ( grids_tmp, k_temp_frq, k_temp(:,ptg_i,:), 1 )
d2165 3
a2167 2
            & call frequency_average_derivative &
              & ( grids_f, k_atmos_frq, k_atmos(:,ptg_i,:), k )
d2175 1
d2178 2
a2179 1
            & ( grids_v, k_spect_dv_frq, k_spect_dv(:,ptg_i,:), k )
d2185 2
a2186 1
            & ( grids_w, k_spect_dw_frq, k_spect_dw(:,ptg_i,:), k )
d2192 2
a2193 1
            & ( grids_n, k_spect_dn_frq, k_spect_dn(:,ptg_i,:), k )
d2204 2
a2205 1
    subroutine Frequency_Average_Derivative ( Grids, K_Frq, K, Mol )
d2211 4
a2214 3
      real(rp), intent(in) :: K_FRQ(:,:) ! To be averaged  Frq X Grid
      real(r4), intent(out) :: K(:,:)    ! Averaged        Chan X Grid
      integer, intent(in) :: Mol         ! Which molecule
d2216 1
a2216 1
      integer :: Channel, I, ShapeInd, SigInd
d2220 5
a2224 1
      if ( fwdModelConf%do_freq_avg ) then
d2226 1
a2226 1
        do i = 1, noUsedDACS
d2228 1
a2228 1
            & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
d2231 1
a2231 1
              & k_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
d2235 2
a2236 6
        do i = 1, noUsedChannels
          sigInd = channels(i)%signal
          channel = channels(i)%used
          shapeInd = MatchSignal ( filterShapes%signal, &
            & fwdModelConf%signals(sigInd),             &
            & sideband = thisSideband, channel=channel )
d2239 1
a2239 1
              if ( channels(i)%dacs == 0 ) then
d2243 1
a2243 1
                  & k_frq(1:noFreqs,sv_i), r )
d2245 1
a2245 1
                r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
d2250 1
a2250 1
            k(i,sv_i) = r
d2253 1
a2253 1
      else                      ! Else not frequency averaging, just copy it
d2263 2
a2264 1
      end if                    ! Frequency averaging or not
d2267 24
d2303 1
a2303 1
      use DO_T_SCRIPT_M, only: TWO_D_T_SCRIPT
d2348 6
d2370 6
d2543 4
a2552 2
            tt_path_c(j) =0.0
            w0_path_c(j) =0.0
d2555 4
d2659 1
a2659 3
        ! Needed by both rad_tran and rad_tran_pol
        call two_d_t_script ( t_path_c, tt_path_c, w0_path_c, &  
          & spaceRadiance%values(1,1), frq, t_script(:,frq_i) )
d2661 1
a2661 1
        ! Compute SCALAR radiative transfer --------------------------------
a2662 2
        if ( FwdModelConf%anyPFA(sx) ) then
          ! Doing PFA, or doing LBL but will be doing PFA
d2667 22
a2688 8
        else if ( .not. fwdModelConf%polarized ) then
          ! Not doing PFA, and not going to do it
          call rad_tran ( gl_inds, cg_inds(1:ncg), e_rflty, del_zeta,       &
            & alpha_path_c, ref_corr,incoptdepth, alpha_path_f(1:ngl),      &
            & dsdz_gw_path, t_script(:,frq_i), tau%tau(:npc,frq_i),         &
            & radV(frq_i), i_stop )
            tau%i_stop(frq_i) = i_stop
        else ! Polarized model
a2742 3
          ! Same code works for PFA and non-PFA (it knows which one it's
          ! working on).  Results of PFA and non-PFA don't need to be combined
          ! because we never process the same molecule both ways.
d2746 1
a2746 1
            &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop,    &
d2749 3
a2751 1
          if ( .not. pfa_or_not_pol ) then
d2775 1
a2775 1
          end if
d2782 2
a2783 2
          call dt_script_dt ( t_path_c, eta_zxp_t_c(1:npc,:), frq, &
                            & d_t_scr_dt(1:npc,:) )
d2805 3
a2807 2
              & t_script(:,frq_i), d_t_scr_dt(1:npc,:), tau%tau(:npc,frq_i),&
              & i_stop, grids_tmp%deriv_flags, k_temp_frq(frq_i,:) )
d2883 1
a2883 1
                &  sps_path, eta_zxp_w, do_calc_w, dbeta_dw_path_c,          &
d2885 1
a2885 2
                &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop,           &
                &  k_spect_dw_frq(frq_i,:) )
d2891 1
a2891 1
                &  sps_path, eta_zxp_n, do_calc_n, dbeta_dn_path_c,          &
d2893 1
a2893 2
                &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop,           &
                &  k_spect_dn_frq(frq_i,:) )
d2897 1
d2900 1
a2900 1
                &  sps_path, eta_zxp_v, do_calc_v, dbeta_dv_path_c,          &
d2902 1
a2902 2
                &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop,           &
                &  k_spect_dv_frq(frq_i,:) )
d2927 1
a2927 1
      integer :: Channel, I, K, PTG_I, ShapeInd, SigInd
d2933 1
a2933 1
      if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
d2964 1
a2964 7
          sigInd = channels(i)%signal
          channel = channels(i)%used
          shapeInd = MatchSignal ( filterShapes%signal, &
            & fwdModelConf%signals(sigInd), sideband = thisSideband, &
            & channel=channel )
          if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                               & "No matching channel shape information" )
d2972 3
a2974 1
      else ! ------------------------- Not frequency averaging ---------
d2979 1
d2981 1
a2981 1
      end if
d2993 2
a2994 13
      if ( FwdModelConf%anyPFA(sx) ) then
        call allocate_test ( T_Script_PFA, npcmax, noUsedChannels, 'T_Script_PFA', moduleName )
        call allocate_test ( tau_PFA%tau, npcmax, noUsedChannels, 'Tau_PFA%Tau', &
          & moduleName )
        call allocate_test ( tau_PFA%i_stop, noUsedChannels, 'Tau_PFA%I_Stop', &
          & moduleName )
        if ( temp_der ) then
          call allocate_test ( sum_ddel_LBL, npcmax, sv_t_len, maxNoPtgFreqs, &
            &                  'sum_ddel_LBL', moduleName )
          call allocate_test ( sum_ddel_PFA, npcmax, sv_t_len, noUsedChannels, &
            &                  'sum_ddel_PFA', moduleName )
        end if
      end if
d3088 1
a3088 1
    use MLSCommon, only: RP
d3181 1
a3181 1
    & "$Id: FullForwardModel_m.f90,v 2.243 2005/09/17 00:49:53 vsnyder Exp $"
d3190 3
@


2.243
log
@Revise arrays for spectroscopic derivatives, plus some cannonball polishing
@
text
@d1013 1
a1013 1
        call allocate_test ( k_spect_dv, noUsedChannels, no_tan_hts, grids_v%l_v(f_len_v), &
d1015 1
a1015 1
        call allocate_test ( dbeta_dv_path_c,    npc, no_mol, &
d1034 1
a1034 1
        call allocate_test ( k_spect_dw, noUsedChannels, no_tan_hts, grids_w%l_v(f_len_v), &
d1036 1
a1036 1
        call allocate_test ( dbeta_dw_path_c,    npc, no_mol, &
d1053 1
a1053 1
        call allocate_test ( k_spect_dn, noUsedChannels, no_tan_hts, grids_n%l_v(f_len_v), &
d1055 1
a1055 1
        call allocate_test ( dbeta_dn_path_c,    npc, no_mol, &
d3046 1
a3046 1
    & "$Id: FullForwardModel_m.f90,v 2.242 2005/09/03 01:21:33 vsnyder Exp $"
d3055 3
@


2.242
log
@Spectral parameter offsets stuff
@
text
@d33 1
a33 1
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST, E_Def, E_DP, &
d49 1
a49 1
      & ForwardModelConfig_t, QtyStuff_t
d68 2
a69 2
    use Load_Sps_Data_m, only: DestroyGrids_t, Grids_T, Load_One_Item_Grid, &
      & Load_Sps_Data, Modify_values_for_supersat
d74 1
a74 2
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate,&
      & MLSMSG_Error, MLSMSG_Warning
d177 1
d185 6
a190 4
    integer, dimension(:), pointer :: C_INDS  ! Indices on coarse grid
    integer, dimension(:), pointer :: CG_INDS ! Indices on coarse grid where GL needed
    integer, dimension(:), pointer :: F_INDS  ! Indices on fine grid
    integer, dimension(:), pointer :: GL_INDS ! Index of GL points -- subset of f_inds
a201 2
    logical, dimension(:,:), pointer :: DO_CALC_N_C   ! DO_CALC_N on coarse grid  
    logical, dimension(:,:), pointer :: DO_CALC_N_F   ! DO_CALC_N on fine grid    
a202 2
    logical, dimension(:,:), pointer :: DO_CALC_V_C   ! DO_CALC_V on coarse grid  
    logical, dimension(:,:), pointer :: DO_CALC_V_F   ! DO_CALC_V on fine grid    
a204 1
    logical, dimension(:,:), pointer :: DO_CALC_W_F   ! DO_CALC_W  on fine grid   
a251 4
    real(rp), dimension(:), pointer :: DRAD_DN      ! dI/dN
    real(rp), dimension(:), pointer :: DRAD_DT      ! dI/dT
    real(rp), dimension(:), pointer :: DRAD_DV      ! dI/dV
    real(rp), dimension(:), pointer :: DRAD_DW      ! dI/dW
a266 1
    real(rp), dimension(:), pointer :: P_PATH_C     ! P_PATH on coarse grid
a322 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_N_C  ! ETA_ZXP_N on coarse grid
a323 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_N_F  ! ETA_ZXP_N on fine grid
a326 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_V_C  ! ETA_ZXP_V on coarse grid
a327 2
    real(rp), dimension(:,:), pointer :: ETA_ZXP_V_F  ! ETA_ZXP_V on fine grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_W_C  ! ETA_ZXP_W on coarse grid
a328 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_W_F  ! ETA_ZXP_W on fine grid
a378 1
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL_GL ! Corrections to INCOPTDEPTH_POL
d453 2
a454 2
    ! Channels x pointings x surfaces x instances
    real(r4), dimension(:,:,:,:)  , pointer :: K_TEMP
d457 4
a460 4
    ! Channels x pointings x frequencies x surfaces x instances x molecules:
    real(r4), dimension(:,:,:,:,:,:), pointer :: K_SPECT_DN
    real(r4), dimension(:,:,:,:,:,:), pointer :: K_SPECT_DV
    real(r4), dimension(:,:,:,:,:,:), pointer :: K_SPECT_DW
d492 3
d506 1
a506 1
      & beta_path_polarized_f, c_inds, cext_path, cg_inds, &
d517 3
a519 3
      & do_calc_Cext, do_calc_Cext_zp, do_calc_n, do_calc_n_c, &
      & do_calc_n_F, do_calc_v, do_calc_v_c, do_calc_v_f, do_calc_w, &
      & do_calc_w_c, do_calc_w_f, do_calc_fzp, do_calc_hyd, do_calc_hyd_c, &
d522 2
a523 2
      & do_calc_tscat_zp, do_calc_zp, do_gl, drad_dn, drad_dt, drad_dv, &
      & drad_dw, d_rad_pol_df, d_rad_pol_dt, dsdz_gw_path, dTanh_dT_c, &
d527 4
a530 4
      & eta_tscat, eta_tscat_zp, eta_zp, eta_zxp_n, eta_zxp_n_c, &
      & eta_zxp_n_f, eta_zxp_v, eta_zxp_v_c, eta_zxp_v_f, eta_zxp_w, &
      & eta_zxp_w_c, eta_zxp_w_f, eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, &
      & f_inds, frequencies, gph_prof, gl_delta_polarized, gl_inds, gph, grids, &
d532 1
a532 1
      & incoptdepth_pol_gl, ipsd, iwc_path, k_atmos, k_atmos_frq, &
d537 1
a537 1
      & n_path, path_dsdh, phi_path, p_path, p_path_c, &
d663 3
a665 3
    no_sv_p_t = windowFinish - windowStart + 1
    n_t_zeta = grids_tmp%l_z(1)
    sv_t_len = grids_tmp%p_len ! zeta X phi
d738 7
d897 1
a897 1
    call allocate_test ( c_inds,              npc, 'c_inds',           moduleName )
d905 1
a905 1
    call allocate_test ( gl_inds,         max_ele, 'gl_inds',          moduleName )
a912 1
    call allocate_test ( p_path_c,            npc, 'p_path_c',         moduleName )
d951 1
a951 1
    if ( temp_der ) then
d956 2
a957 1
! Allocation for metrics routine when Temp. derivative is needed:
a958 5
!      call allocate_test ( k_temp, noUsedChannels, no_tan_hts, n_t_zeta, &
!                         & no_sv_p_t, 'k_temp', moduleName )
      allocate ( k_temp(noUsedChannels, no_tan_hts, n_t_zeta, no_sv_p_t) )

      call allocate_test ( dRad_dt, sv_t_len, 'dRad_dt', moduleName )
d999 2
a1000 2
      call allocate_test ( k_atmos, noUsedChannels, no_tan_hts, size(grids_f%values), &
        & 'k_atmos', moduleName )
a1009 4
      call allocate_test ( do_calc_v_c,   npc, f_len_v, 'do_calc_v_c', &
                        &  moduleName )
      call allocate_test ( do_calc_v_f, max_ele, f_len_v, 'do_calc_v_f', &
                        &  moduleName )
a1011 4
      call allocate_test ( eta_zxp_v_c,   npc, f_len_v, 'eta_zxp_v_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_v_f, max_ele, f_len_v, 'eta_zxp_v_f', &
                        &  moduleName )
d1013 2
a1014 6
        !??? Are temperature's windowStart:windowFinish correct here.  Should ???
        !??? we use minval(grids_d?%windowStart):maxval(grids_d?%windowFinish) ???
        allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFreqs, &
          & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
        call test_allocate ( ier, ModuleName, 'k_spect_dv', lbound(k_spect_dv), &
          & ubound(k_spect_dv), e_def )
a1018 1
        call allocate_test ( drad_dv, f_len_v, 'drad_dv', moduleName )
d1020 2
a1030 2
      call allocate_test ( do_calc_w_f, max_ele, f_len_w, 'do_calc_w_f', &
                        &  moduleName )
a1032 4
      call allocate_test ( eta_zxp_w_c,   npc, f_len_w, 'eta_zxp_w_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_w_f, max_ele, f_len_w, 'eta_zxp_w_f', &
                        &  moduleName )
d1034 2
a1035 6
        !??? Are temperature's windowStart:windowFinish correct here.  Should ???
        !??? we use minval(grids_d?%windowStart):maxval(grids_d?%windowFinish) ???
        allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFreqs, &
          & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
        call test_allocate ( ier, ModuleName, 'k_spect_dw', lbound(k_spect_dw), &
          & ubound(k_spect_dw), e_def )
a1039 1
        call allocate_test ( drad_dw, f_len_w, 'drad_dw', moduleName )
d1041 2
a1047 4
      call allocate_test ( do_calc_n_c,   npc, f_len_n, 'do_calc_n_c', &
                        &  moduleName )
      call allocate_test ( do_calc_n_f, max_ele, f_len_n, 'do_calc_n_f', &
                        &  moduleName )
a1049 4
      call allocate_test ( eta_zxp_n_c,   npc, f_len_n, 'eta_zxp_n_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_n_f, max_ele, f_len_n, 'eta_zxp_n_f', &
                        &  moduleName )
d1053 2
a1054 6
        !??? Are temperature's windowStart:windowFinish correct here.  Should ???
        !??? we use minval(grids_d?%windowStart):maxval(grids_d?%windowFinish) ???
        allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFreqs, &
          & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
        call test_allocate ( ier, ModuleName, 'k_spect_dn', lbound(k_spect_dn), &
          & ubound(k_spect_dn), e_def )
a1058 1
        call allocate_test ( drad_dn, f_len_n, 'drad_dn', moduleName )
d1060 2
d1065 19
a1083 32
      call allocate_test ( eta_mag_zp,     max_ele, grids_mag%p_len,        'eta_mag_zp',     moduleName )
      call allocate_test ( mag_path,       max_ele, magfield%template%noChans+1, 'mag_path', &
        & moduleName )
      allocate ( alpha_path_polarized(-1:1,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'alpha_path_polarized', &
        & lbound(alpha_path_polarized), ubound(alpha_path_polarized), e_dp )
      allocate ( beta_path_polarized(-1:1,npc,no_mol), stat=ier )
      call test_allocate ( ier, moduleName, 'beta_path_polarized', &
        & lbound(beta_path_polarized), ubound(beta_path_polarized), e_dp )
      allocate ( alpha_path_polarized_f(-1:1,max_ele), stat=ier )
      call test_allocate ( ier, moduleName, 'alpha_path_polarized_f', &
        & lbound(alpha_path_polarized_f), ubound(alpha_path_polarized_f), e_dp )
      allocate ( beta_path_polarized_f(-1:1,max_ele,no_mol), stat=ier )
      call test_allocate ( ier, moduleName, 'beta_path_polarized_f', &
        & lbound(beta_path_polarized_f), ubound(beta_path_polarized_f), e_dp )
      allocate ( gl_delta_polarized(-1:1,max_ele), stat=ier )
      call test_allocate ( ier, moduleName, 'gl_delta_polarized', &
        & lbound(gl_delta_polarized), ubound(gl_delta_polarized), e_dp )
      allocate ( incoptdepth_pol(2,2,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'incoptdepth_pol', &
        & lbound(incoptdepth_pol), ubound(incoptdepth_pol), e_dp )
      allocate ( incoptdepth_pol_gl(2,2,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'incoptdepth_pol_gl', &
        & lbound(incoptdepth_pol_gl), ubound(incoptdepth_pol_gl), e_dp )
      allocate ( prod_pol(2,2,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'prod_pol', &
        & lbound(prod_pol), ubound(prod_pol), e_dp )
      allocate ( tau_pol(2,2,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'tau_pol', lbound(tau_pol), ubound(tau_pol), e_dp )
      allocate ( deltau_pol(2,2,npc), stat=ier )
      call test_allocate ( ier, moduleName, 'deltau_pol', &
        & lbound(deltau_pol), ubound(deltau_pol), e_dp )
d1085 2
a1086 3
        allocate ( d_rad_pol_df(2,2,grids_f%l_v(ubound(grids_f%l_v,1))), stat=ier )
        call test_allocate ( ier, moduleName, 'd_rad_pol_df', &
          & lbound(d_rad_pol_df), ubound(d_rad_pol_df), e_dp )
d1088 2
a1089 1
        call test_allocate ( ier, moduleName, 'de_df', lbound(de_df), ubound(de_df), e_dp )
d1092 10
a1101 15
        allocate ( d_rad_pol_dt(2,2,sv_t_len), stat=ier )
        call test_allocate ( ier, moduleName, 'd_rad_pol_dt', &
          & lbound(d_rad_pol_dt), ubound(d_rad_pol_dt), e_dp )
        allocate ( dAlpha_dT_polarized_path_c(-1:1,npc), stat=ier )
        call test_allocate ( ier, moduleName, 'dAlpha_dT_polarized_path_c', &
          & lbound(dAlpha_dT_polarized_path_c), ubound(dAlpha_dT_polarized_path_c), e_dp )
        allocate ( dAlpha_dT_polarized_path_f(-1:1,max_ele), stat=ier )
        call test_allocate ( ier, moduleName, 'dAlpha_dT_polarized_path_f', &
          & lbound(dAlpha_dT_polarized_path_f), ubound(dAlpha_dT_polarized_path_f), e_dp )
        allocate ( dBeta_dT_polarized_path_c(-1:1,npc,no_mol), stat=ier )
        call test_allocate ( ier, moduleName, 'dBeta_dT_polarized_path_c', &
          & lbound(dBeta_dT_polarized_path_c), ubound(dBeta_dT_polarized_path_c), e_dp )
        allocate ( dBeta_dT_polarized_path_f(-1:1,max_ele,no_mol), stat=ier )
        call test_allocate ( ier, moduleName, 'dBeta_dT_polarized_path_f', &
          & lbound(dBeta_dT_polarized_path_f), ubound(dBeta_dT_polarized_path_f), e_dp )
d1103 4
a1106 4
        call test_allocate ( ier, moduleName, 'de_dt', lbound(de_dt), ubound(de_dt), e_dp )
        allocate ( dincoptdepth_pol_dt(2,2,npc), stat=ier )
        call test_allocate ( ier, moduleName, 'dincoptdepth_pol_dt', &
          & lbound(dincoptdepth_pol_dt), ubound(dincoptdepth_pol_dt), e_dp )
d1157 2
a1158 2
        c_inds(1:npc) = (/(i*Ngp1-Ng,i=1,mid),((i-1)*Ngp1-Ng+1,i=mid+1,npc)/)
        c_inds(npc+1:) = 0
a1173 1
        p_path_c(1:npc) = p_path(c_inds(1:npc))
d1201 4
a1204 4
            dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds(1:npc),:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds(1:npc),:)
            do_calc_t_c(1:npc,:) = do_calc_t(c_inds(1:npc),:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds(1:npc),:)
d1235 4
a1238 4
            dh_dt_path_c(1:npc,:) = dh_dt_path(c_inds(1:npc),:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(c_inds(1:npc),:)
            do_calc_t_c(1:npc,:) = do_calc_t(c_inds(1:npc),:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(c_inds(1:npc),:)
d1255 2
a1256 2
        h_path_c(1:npc) = h_path(c_inds(1:npc))
        t_path_c(1:npc) = t_path(c_inds(1:npc))
a1283 2
          do_calc_v_c(1:npc,:) = do_calc_v(c_inds(1:npc),:)
          eta_zxp_v_c(1:npc,:) = eta_zxp_v(c_inds(1:npc),:)
d1292 1
a1292 2
          do_calc_w_c(1:npc,:) = do_calc_w(c_inds(1:npc),:)
          eta_zxp_w_c(1:npc,:) = eta_zxp_w(c_inds(1:npc),:)
a1300 2
          do_calc_n_c(1:npc,:) = do_calc_n(c_inds(1:npc),:)
          eta_zxp_n_c(1:npc,:) = eta_zxp_n(c_inds(1:npc),:)
d1374 1
a1374 1
          call refractive_index ( p_path_c(1:npc), &
d1376 1
a1376 1
            &  h2o_path=sps_path(c_inds(1:npc), h2o_ind) )
d1378 1
a1378 1
          call refractive_index ( p_path_c(1:npc), &
d1397 2
a1398 2
        call comp_refcor ( h_path_c(1:npc), n_path(1:npc), &
                      &  Req+one_tan_ht(1), del_s(1:npc), ref_corr(1:npc), ier )
d1433 7
a1439 7
          call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:),          &
            & c_inds(:npc), del_s(:npc), del_zeta(:npc),                          &
            & do_calc_fzp(:no_ele,:), do_calc_zp(:no_ele,:), do_GL(:npc),         &
            & eta_fzp(:no_ele,:), eta_zp(:no_ele,:), frequencies, h_path_c,       &
            & incoptdepth(:npc), p_path(:no_ele), pfaFalse, ref_corr(:npc),       &
            & sps_path(:no_ele,:), tau_lbl, t_path_c(:npc), t_script_lbl(:npc,:), &
            & tanh1_c(:npc), tt_path_c(:npc), w0_path_c(:npc), z_path(:no_ele) )
d1456 7
a1462 7
          call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:),          &
            & c_inds(:npc), del_s(:npc), del_zeta(:npc),                          &
            & do_calc_fzp(:no_ele,:), do_calc_zp(:no_ele,:), do_GL(:npc),         &
            & eta_fzp(:no_ele,:), eta_zp(:no_ele,:), channelCenters, h_path_c,    &
            & incoptdepth(:npc), p_path(:no_ele), pfaTrue, ref_corr(:npc),        &
            & sps_path(:no_ele,:), tau_pfa, t_path_c(:npc), t_script_pfa(:npc,:), &
            & tanh1_c(:npc), tt_path_c(:npc), w0_path_c(:npc), z_path(:no_ele) )
d1581 1
a1581 1
    call Deallocate_Test ( WC, 'WC', moduleName )
d1583 1
a1583 1
    call Deallocate_Test ( IPSD, 'IPSD', moduleName )
d1602 1
a1602 1
    call deallocate_test ( est_los_vel, 'est_los_vel', moduleName )
d1624 1
a1624 1
    call deallocate_test ( c_inds,           'c_inds',           moduleName )
d1631 1
a1631 1
    call deallocate_test ( gl_inds,          'gl_inds',          moduleName )
a1638 1
    call deallocate_test ( p_path_c,         'p_path_c',         moduleName )
d1680 1
a1680 1
      deallocate ( k_temp, STAT=i )
a1693 1
      call deallocate_test ( dRad_dt,         'dRad_dt',         moduleName )
a1713 1
    call deallocate_test ( do_calc_n_c,     'do_calc_n_c',     moduleName )
a1714 2
    call deallocate_test ( do_calc_n_f,     'do_calc_n_f',     moduleName )
    call deallocate_test ( do_calc_v_c,     'do_calc_v_c',     moduleName )
a1715 1
    call deallocate_test ( do_calc_v_f,     'do_calc_v_f',     moduleName )
a1717 1
    call deallocate_test ( do_calc_w_f,     'do_calc_w_f',     moduleName )
a1718 1
    call deallocate_test ( eta_zxp_n_c,     'eta_zxp_n_c',     moduleName )
a1719 2
    call deallocate_test ( eta_zxp_n_f,     'eta_zxp_n_f',     moduleName )
    call deallocate_test ( eta_zxp_v_c,     'eta_zxp_v_c',     moduleName )
a1720 2
    call deallocate_test ( eta_zxp_v_f,     'eta_zxp_v_f',     moduleName )
    call deallocate_test ( eta_zxp_w_c,     'eta_zxp_w_c',     moduleName )
a1721 1
    call deallocate_test ( eta_zxp_w_f,     'eta_zxp_w_f',     moduleName )
d1735 6
a1740 20

      call deallocate_test ( drad_dn,         'drad_dn',         moduleName )
      call deallocate_test ( drad_dv,         'drad_dv',         moduleName )
      call deallocate_test ( drad_dw,         'drad_dw',         moduleName )

      if ( associated(k_spect_dv) ) then
        i = size(k_spect_dv) * E_def
        deallocate ( k_spect_dv, stat=ier )
        call test_deallocate ( ier, ModuleName, 'k_spect_dv', i )
      end if
      if ( associated(k_spect_dw) ) then
        i = size(k_spect_dw) * E_def
        deallocate ( k_spect_dw, stat=ier )
        call test_deallocate ( ier, ModuleName, 'k_spect_dw', i )
      end if
      if ( associated(k_spect_dn) ) then
        i = size(k_spect_dn) * E_def
        deallocate ( k_spect_dn, stat=ier )
        call test_deallocate ( ier, ModuleName, 'k_spect_dn', i )
      end if
d1745 6
a1750 21
      deallocate ( alpha_path_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'alpha_path_polarized' )
      deallocate ( beta_path_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'beta_path_polarized' )
      deallocate ( alpha_path_polarized_f, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'alpha_path_polarized_f' )
      deallocate ( beta_path_polarized_f, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'beta_path_polarized_f' )
      deallocate ( gl_delta_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'gl_delta_polarized' )
      deallocate ( incoptdepth_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol' )
      deallocate ( incoptdepth_pol_gl, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol_gl' )
d1752 2
a1753 3
        deallocate ( d_rad_pol_df, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'d_rad_pol_df' )
d1755 1
a1755 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'de_df' )
d1758 4
a1761 9
        deallocate ( d_rad_pol_dt, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'d_rad_pol_dt' )
        deallocate ( dBeta_dT_polarized_path_c, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dBeta_dT_polarized_path_c' )
        deallocate ( dBeta_dT_polarized_path_f, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dBeta_dT_polarized_path_f' )
d1763 2
a1764 5
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'de_dt' )
        deallocate ( dincoptdepth_pol_dt, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dincoptdepth_pol_dt' )
d1766 3
a1768 9
      deallocate ( deltau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'deltau_pol' )
      deallocate ( prod_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'prod_pol' )
      deallocate ( tau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'tau_pol' )
d1776 1
a1776 3
    if ( toggle(emit) ) then
      call trace_end ( 'ForwardModel MAF=', fmStat%maf )
    end if
d1867 1
a1867 1
          & 'Had to patch some out of order ptg_angles' )
d1929 1
a1929 1
              & real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,sv_t_len/)),kind=rp), &
d1944 15
a1958 20
          if ( spect_der ) then
            if ( associated(fwdModelConf%lineCenter) ) &
              & call convolve_other_deriv ( convolve_support, maf, chanInd, &
                & thisFraction, update, thisRadiance, &
                & fwdModelConf%lineCenter%qty, grids_v, L1BMIF_TAI, MIFDeadTime, &
                & real(RESHAPE(k_spect_dv(i,:,:,:,:,:),(/no_tan_hts,sv_t_len/)),kind=rp), &
                & Jacobian, fmStat%rows )
            if ( associated(fwdModelConf%lineWidth) ) &
              & call convolve_other_deriv ( convolve_support, maf, chanInd, &
                & thisFraction, update, thisRadiance, &
                & fwdModelConf%lineWidth%qty, grids_w, L1BMIF_TAI, MIFDeadTime, &
                & real(RESHAPE(k_spect_dw(i,:,:,:,:,:),(/no_tan_hts,sv_t_len/)),kind=rp), &
                & Jacobian, fmStat%rows )
            if ( associated(fwdModelConf%lineWidth_TDep) ) &
              & call convolve_other_deriv ( convolve_support, maf, chanInd, &
                & thisFraction, update, thisRadiance, &
                & fwdModelConf%lineWidth_TDep%qty, grids_n, L1BMIF_TAI, MIFDeadTime, &
                & real(RESHAPE(k_spect_dn(i,:,:,:,:,:),(/no_tan_hts,sv_t_len/)),kind=rp), &
                & Jacobian, fmStat%rows )
          end if
d1977 1
a1977 2
              & real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,sv_t_len/)),kind=rp), &
              & Jacobian, fmStat%rows )
a1995 66
  ! ..............................................  dI_dSomething  .....
    subroutine dI_dSomething ( grids_dS, k_spect_dS_frq, k_spect_dS, K )

    ! Do or don't do frequency averaging, to finish up derivative of I w.r.t. S

      type(grids_T), intent(in) :: grids_dS
      real(rp), dimension(:,:), intent(in) :: K_SPECT_DS_FRQ ! ****
      real(r4), dimension(:,:,:,:,:,:), intent(out) :: K_SPECT_DS
      integer, intent(in) :: K ! Which molecule

      integer :: Channel, I, Instance, JF, ShapeInd, SigInd, Surface, SV_I
      real(rp) :: R

      if ( fwdModelConf%do_freq_avg ) then
        ! Do DACs stuff for all DACs channels first
        do i = 1, noUsedDACS
          shapeInd = MatchSignal ( dacsFilterShapes%signal, &
            & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
          sv_i = Grids_dS%l_v(k-1)
          do instance = Grids_dS%WindowStart(k), Grids_dS%WindowFinish(k)
            do surface = 1, Grids_dS%l_z(k) - Grids_dS%l_z(k-1)
              do jf = 1, Grids_dS%l_f(k) - Grids_dS%l_f(k-1)
                sv_i = sv_i + 1
                call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                  & k_spect_dS_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
              end do   ! jf -- Frequencies loop
            end do     ! Surface loop
          end do       ! Instance loop
        end do         ! i -- DACS loop
        do i = 1, noUsedChannels
          sigInd = channels(i)%signal
          channel = channels(i)%used
          shapeInd = MatchSignal ( filterShapes%signal, &
            & fwdModelConf%signals(sigInd),             &
            & sideband = thisSideband, channel=channel )
          sv_i = Grids_dS%l_v(k-1)
          do instance = Grids_dS%WindowStart(k), Grids_dS%WindowFinish(k)
            do surface = 1, Grids_dS%l_z(k) - Grids_dS%l_z(k-1)
              do jf = 1, Grids_dS%l_f(k) - Grids_dS%l_f(k-1)
                sv_i = sv_i + 1
                if ( channels(i)%dacs == 0 ) then
                  call Freq_Avg ( frequencies,           &
                    & FilterShapes(shapeInd)%FilterGrid, &
                    & FilterShapes(shapeInd)%FilterShape,&
                    & k_spect_dS_frq(:,sv_i), r )
                else
                  r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                end if
                k_spect_dS(i,ptg_i,jf,surface,instance,k) = r
              end do              ! Frequencies loop
            end do                ! Surface loop
          end do                  ! Instance loop
        end do                    ! Channel loop
      else                        ! else not frequency averaging
        k_spect_dS( 1:noUsedChannels, ptg_i, &
          &         1:Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
          &         1:Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &
          &         Grids_dS%WindowStart(k):Grids_dS%WindowFinish(k), k ) = &
          & reshape(k_spect_dS_frq( 1:noUsedChannels, &
          &                         Grids_dS%l_v(k-1) + 1: Grids_dS%l_v(k) ), &
            &       (/ noUsedChannels, Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
            &          Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &
            &          Grids_dS%WindowFinish(k) - Grids_dS%WindowStart(k) + 1 /) )
      end if                      ! Frequency averaging or not
    end subroutine dI_dSomething

d2012 1
a2012 1
      integer :: I, Instance, K, KHi, KLo, ShapeInd, SigInd, Surface, SV_I
a2061 2
      ! Frequency averaging of derivatives if needed -----------------------

d2065 2
a2066 44
      if ( temp_der ) then
        if ( fwdModelConf%do_freq_avg ) then
          ! Do DACs stuff for all DACs channels first
          do i = 1, noUsedDACS
            shapeInd = MatchSignal ( dacsFilterShapes%signal, &
              & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
            sv_i = 1
            do instance = 1, no_sv_p_t
              do surface = 1, n_t_zeta
                call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                  & k_temp_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
                sv_i = sv_i + 1
              end do                  ! Surface loop
            end do                    ! Instance loop
          end do                      ! i -- DACs loop
          ! Now go through channel by channel
          do i = 1, noUsedChannels
            sigInd = channels(i)%signal
            channel = channels(i)%used
            shapeInd = MatchSignal ( filterShapes%signal, &
              & fwdModelConf%signals(sigInd), &
              & sideband = thisSideband, channel=channel )
            sv_i = 1
            do instance = 1, no_sv_p_t
              do surface = 1, n_t_zeta
                if ( channels(i)%dacs == 0 ) then
                  call Freq_Avg ( frequencies, &
                    & FilterShapes(shapeInd)%FilterGrid, &
                    & FilterShapes(shapeInd)%FilterShape, &
                    & k_temp_frq(:,sv_i), r )
                else
                  r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                end if
                k_temp(i,ptg_i,surface,instance) = r
                sv_i = sv_i + 1
              end do                  ! Surface loop
            end do                    ! Instance loop
          end do                      ! Channel loop
        else
          k_temp(1:noUsedChannels,ptg_i,1:n_t_zeta,1:no_sv_p_t) = &
            & reshape( k_temp_frq(1:noUsedChannels,1:no_sv_p_t*n_t_zeta), &
              &        (/ noUsedChannels, n_t_zeta, no_sv_p_t /) )
        end if
      end if
a2071 1

d2073 3
a2075 47
          if ( fwdModelConf%moleculeDerivatives(k) ) then
            if ( fwdModelConf%do_freq_avg ) then
              ! Do DACs stuff for all DACs channels first
              do i = 1, noUsedDACS
                shapeInd = MatchSignal ( dacsFilterShapes%signal, &
                  & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
                do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                  call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                    & k_atmos_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
                end do                  ! Surface loop X Instance loop
              end do
              ! Now go through channel by channel
              do i = 1, noUsedChannels
                sigInd = channels(i)%signal
                channel = channels(i)%used
                shapeInd = MatchSignal ( filterShapes%signal, &
                  & fwdModelConf%signals(sigInd),             &
                  & sideband = thisSideband, channel=channel )
                do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                  if ( grids_f%deriv_flags(sv_i) ) then
                    if ( channels(i)%dacs == 0 ) then
                      call Freq_Avg ( frequencies,            &
                        & FilterShapes(shapeInd)%FilterGrid,  &
                        & FilterShapes(shapeInd)%FilterShape, &
                        & k_atmos_frq(1:noFreqs,sv_i), r )
                    else
                      r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                    end if
                  else
                    r = 0.0
                  end if
                  k_atmos(i,ptg_i,sv_i) = r
                end do                ! Surface loop X Instance loop
              end do                  ! Channel loop
            else                      ! Else not frequency averaging
              do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                if ( grids_f%deriv_flags(sv_i) ) then
                  k_atmos(1:noUsedChannels,ptg_i,sv_i) = &
                    & min ( max ( k_atmos_frq(1:noUsedChannels,sv_i), &
                    &   real(-huge(0.0_r4), rp ) ), &
                    &   real( huge(0.0_r4), rp ) )
                else
                  k_atmos(1:noUsedChannels,ptg_i,sv_i) = 0.0
                end if
              end do
            end if                    ! Frequency averaging or not
          end if                      ! Want derivatives for this specie?
a2076 1
        !
d2082 18
a2099 12
      if ( spect_der ) then

        do k = 1, no_mol
          if ( fwdModelConf%moleculeDerivatives(k) ) then
            !  *** dI/dW
            call dI_dSomething ( grids_w, k_spect_dw_frq, k_spect_dw, k )
            !  *** dI/dN
            call dI_dSomething ( grids_n, k_spect_dn_frq, k_spect_dn, k )
            !  *** dI/dV
            call dI_dSomething ( grids_v, k_spect_dv_frq, k_spect_dv, k )
          end if                        ! Want derivatives for this
        end do                          ! Loop over major molecules
a2102 2
      end if                        ! Want derivatives for spect

d2107 61
d2480 2
a2481 1
        call get_GL_inds ( do_gl, gl_inds, cg_inds, ngl, ncg )
d2483 1
a2483 1
        t_path_f(:ngl) = t_path(gl_inds(:ngl))
d2487 1
a2487 1
          call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds(:ngl), t_path_f(:ngl),  &
d2506 1
a2506 1
            & gl_inds(:ngl), beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,&
d2526 2
a2527 2
          call get_tau ( frq_i, gl_inds(1:ngl), cg_inds(1:ncg), e_rflty, &
            & del_zeta, alpha_path_c, ref_corr, incoptdepth, alpha_path_f(1:ngl), &
d2532 3
a2534 3
          call rad_tran ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty, del_zeta, &
            & alpha_path_c, ref_corr,incoptdepth, alpha_path_f(1:ngl),       &
            & dsdz_gw_path, t_script(:,frq_i), tau%tau(:npc,frq_i),          &
d2546 1
a2546 1
            & gl_inds(:ngl), beta_path_polarized_f, dBeta_dT_polarized_path_f )
d2562 1
a2562 1
          call rad_tran_pol ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty, del_zeta,    &
d2595 4
a2598 4
          call drad_tran_df ( c_inds, gl_inds(1:ngl), del_zeta,      &
            &  Grids_f, beta_path_c, eta_fzp, sps_path, do_calc_fzp, &
            &  beta_path_f, do_gl, del_s, ref_corr, dsdz_gw_path,    &
            &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop,       &
d2635 5
a2639 5
          dh_dt_path_f(:ngl,:) = dh_dt_path(gl_inds(:ngl),:)
          do_calc_t_f(:ngl,:) = do_calc_t(gl_inds(:ngl),:)
          eta_zxp_t_f(:ngl,:) = eta_zxp_t(gl_inds(:ngl),:)
          h_path_f(:ngl) = h_path(gl_inds(:ngl))
          dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds,:) *         &
d2641 1
a2641 1
          dAlpha_dT_path_f(:ngl) = sum( sps_path(gl_inds(1:ngl),:) * &
d2647 1
a2647 1
              & dh_dt_path_c(1:npc,:),alpha_path_c,                         &
d2651 2
a2652 2
              & do_gl, gl_inds(1:ngl), h_path_f(:ngl),                      &
              & t_path_f(:ngl), dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),  &
d2656 1
a2656 2
              & i_stop, grids_tmp%deriv_flags, drad_dt )
            k_temp_frq(frq_i,:) = drad_dt
d2670 1
a2670 2
                  & sps_path(c_inds,j) *              &
                  & dBeta_dT_polarized_path_c(l,1:npc,j)
d2673 1
a2673 2
                  & sps_path(gl_inds(1:ngl),j) *      &
                  & dBeta_dT_polarized_path_f(l,1:ngl,j)
d2691 1
a2691 1
              & gl_inds(:ngl), del_zeta, do_calc_t_c(1:p_stop,:),           &
d2720 4
a2723 1
          if ( pfa ) then
d2726 2
a2727 1
          else if ( .not. fwdModelConf%polarized ) then
d2730 6
a2735 11
            do_calc_w_f(:ngl,:) = do_calc_w(gl_inds(:ngl),:)
            eta_zxp_w_f(:ngl,:) = eta_zxp_w(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, grids_w,                     &
              &  dbeta_dw_path_c(1:npc,:), eta_zxp_w_c(1:npc,:),       &
              &  sps_path(c_inds,:), do_calc_w_c(1:npc,:),             &
              &  dbeta_dw_path_f(:ngl,:), eta_zxp_w_f(:ngl,:),         &
              &  sps_path(gl_inds(1:ngl),:), do_calc_w_f(:ngl,:),      &
              &  do_gl, gl_inds(:ngl), del_s,  ref_corr, dhdz_gw_path, &
              &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop, drad_dw )

            k_spect_dw_frq(frq_i,1:f_len_w) = drad_dw(1:f_len_w)
d2739 6
a2744 11
            do_calc_n_f(:ngl,:) = do_calc_n(gl_inds(:ngl),:)
            eta_zxp_n_f(:ngl,:) = eta_zxp_n(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, grids_n,                     &
              &  dbeta_dn_path_c(1:npc,:), eta_zxp_n_c(1:npc,:),       &
              &  sps_path(c_inds,:), do_calc_n_c(1:npc,:),             &
              &  dbeta_dn_path_f(:ngl,:), eta_zxp_n_f(:ngl,:),         &
              &  sps_path(gl_inds(1:ngl),:), do_calc_n_f(:ngl,:),      &
              &  do_gl, gl_inds(:ngl), del_s, ref_corr, dhdz_gw_path,  &
              &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop, drad_dn )

            k_spect_dn_frq(frq_i,1:f_len_n) = drad_dn(1:f_len_n)
d2748 6
a2753 9
            do_calc_v_f(:ngl,:) = do_calc_v(gl_inds(:ngl),:)
            eta_zxp_v_f(:ngl,:) = eta_zxp_v(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, grids_v,                     &
              &  dbeta_dv_path_c(1:npc,:), eta_zxp_v_c(1:npc,:),       &
              &  sps_path(c_inds,:), do_calc_v_c(1:npc,:),             &
              &  dbeta_dv_path_f(:ngl,:), eta_zxp_v_f(:ngl,:),         &
              &  sps_path(gl_inds(1:ngl),:), do_calc_v_f(:ngl,:),      &
              &  do_gl, gl_inds(:ngl), del_s, ref_corr, dhdz_gw_path,  &
              &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop, drad_dv )
a2754 1
            k_spect_dv_frq(frq_i,1:f_len_v) = drad_dv(1:f_len_v)
d2869 9
a2877 8
      if ( spect_der ) then
        call allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_w, &
                           & 'k_spect_dw_frq', moduleName )
        call allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_n, &
                           & 'k_spect_dn_frq', moduleName )
        call allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_v, &
                           & 'k_spect_dv_frq', moduleName )
      end if
d3046 1
a3046 1
    & "$Id: FullForwardModel_m.f90,v 2.241 2005/08/03 18:03:42 vsnyder Exp $"
d3055 3
@


2.241
log
@Scan averaging, some spectroscopy derivative stuff
@
text
@d190 3
d506 1
a506 3
! ** Re-instate when appropriate code is done
!   spect_der = present ( jacobian ) .and. FwdModelConf%spect_der
    spect_der = present ( jacobian ) .and. .false.    ! ** ZEBUG
d546 3
a548 1
      & k_spect_dw_frq, k_temp, k_temp_frq, l1bMIF_TAI, mag_path, MIFDeadTime, &
d1014 17
a1030 5
    if ( spect_der ) then

      if ( associated(fwdModelConf%lineCenter) ) then
        call allocate_test ( spect_v_path, max_ele, size(fwdModelConf%lineCenter), &
          & 'spect_v_path', moduleName )
a1040 13
        f_len_v = grids_v%l_v(ubound(grids_v%l_v,1))
        call allocate_test ( do_calc_v, max_ele, f_len_v, 'do_calc_v', &
                          &  moduleName )
        call allocate_test ( do_calc_v_c,   npc, f_len_v, 'do_calc_v_c', &
                          &  moduleName )
        call allocate_test ( do_calc_v_f, max_ele, f_len_v, 'do_calc_v_f', &
                          &  moduleName )
        call allocate_test ( eta_zxp_v, max_ele, f_len_v, 'eta_zxp_v', &
                          &  moduleName )
        call allocate_test ( eta_zxp_v_c,   npc, f_len_v, 'eta_zxp_v_c', &
                          &  moduleName )
        call allocate_test ( eta_zxp_v_f, max_ele, f_len_v, 'eta_zxp_v_f', &
                          &  moduleName )
d1043 18
a1060 3
      if ( associated(fwdModelConf%lineWidth) ) then
        call allocate_test ( spect_w_path, max_ele, size(fwdModelConf%lineWidth), &
          & 'spect_w_path', moduleName )
a1070 13
        f_len_w = grids_w%l_v(ubound(grids_w%l_v,1))
        call allocate_test ( do_calc_w, max_ele, f_len_w, 'do_calc_w', &
                          &  moduleName )
        call allocate_test ( do_calc_w_c,   npc, f_len_w, 'do_calc_w_c', &
                          &  moduleName )
        call allocate_test ( do_calc_w_f, max_ele, f_len_w, 'do_calc_w_f', &
                          &  moduleName )
        call allocate_test ( eta_zxp_w, max_ele, f_len_w, 'eta_zxp_w', &
                          &  moduleName )
        call allocate_test ( eta_zxp_w_c,   npc, f_len_w, 'eta_zxp_w_c', &
                          &  moduleName )
        call allocate_test ( eta_zxp_w_f, max_ele, f_len_w, 'eta_zxp_w_f', &
                          &  moduleName )
d1073 18
a1090 3
      if ( associated(fwdModelConf%lineWidth_TDep) ) then
        call allocate_test ( spect_n_path, max_ele, size(fwdModelConf%lineWidth_TDep), &
          & 'spect_n_path', moduleName )
d1100 1
a1100 14
        & 'dbeta_dn_path_f', moduleName )
        f_len_n = grids_n%l_v(ubound(grids_n%l_v,1))
        call allocate_test ( do_calc_n, max_ele, f_len_n, 'do_calc_n', &
                          &  moduleName )
        call allocate_test ( do_calc_n_c,   npc, f_len_n, 'do_calc_n_c', &
                          &  moduleName )
        call allocate_test ( do_calc_n_f, max_ele, f_len_n, 'do_calc_n_f', &
                          &  moduleName )
        call allocate_test ( eta_zxp_n, max_ele, f_len_n, 'eta_zxp_n', &
                          &  moduleName )
        call allocate_test ( eta_zxp_n_c,   npc, f_len_n, 'eta_zxp_n_c', &
                          &  moduleName )
        call allocate_test ( eta_zxp_n_f, max_ele, f_len_n, 'eta_zxp_n_f', &
                          &  moduleName )
a1102 7

    else

      f_len_w = 0
      f_len_n = 0
      f_len_v = 0

d1341 29
a1369 25
        if ( spect_der ) then
          if ( associated(fwdModelConf%lineCenter) ) then
            call comp_eta_docalc_no_frq ( grids_v, z_path(1:no_ele), &
              & phi_path(1:no_ele), eta_zxp_v(1:no_ele,:), do_calc_v(1:no_ele,:) )
            do_calc_v_c(1:npc,:) = do_calc_v(c_inds(1:npc),:)
            eta_zxp_v_c(1:npc,:) = eta_zxp_v(c_inds(1:npc),:)
            call comp_sps_path_no_frq ( grids_v, eta_zxp_v(1:no_ele,:), &
              & spect_v_path(1:no_ele,:) )
          end if
          if ( associated(fwdModelConf%lineWidth) ) then
            call comp_eta_docalc_no_frq ( grids_w, z_path(1:no_ele), &
              & phi_path(1:no_ele), eta_zxp_w(1:no_ele,:), do_calc_w(1:no_ele,:) )
            do_calc_w_c(1:npc,:) = do_calc_w(c_inds(1:npc),:)
            eta_zxp_w_c(1:npc,:) = eta_zxp_w(c_inds(1:npc),:)
            call comp_sps_path_no_frq ( grids_w, eta_zxp_w(1:no_ele,:), &
              & spect_w_path(1:no_ele,:) )
          end if
          if ( associated(fwdModelConf%lineWidth_TDep) ) then
            call comp_eta_docalc_no_frq ( grids_n, z_path(1:no_ele), &
              & phi_path(1:no_ele), eta_zxp_n(1:no_ele,:), do_calc_n(1:no_ele,:) )
            do_calc_n_c(1:npc,:) = do_calc_n(c_inds(1:npc),:)
            eta_zxp_n_c(1:npc,:) = eta_zxp_n(c_inds(1:npc),:)
            call comp_sps_path_no_frq ( grids_n, eta_zxp_n(1:no_ele,:), &
              & spect_n_path(1:no_ele,:) )
          end if
d1476 3
d1482 4
a1485 1
            &  est_los_vel(ptg_i), gl_slabs(1:no_ele,:), fwdModelConf%Do_1D )
d1781 24
a1813 10
      call deallocate_test ( do_calc_n_c,     'do_calc_n_c',     moduleName )
      call deallocate_test ( do_calc_n,       'do_calc_n',       moduleName )
      call deallocate_test ( do_calc_n_f,     'do_calc_n_f',     moduleName )
      call deallocate_test ( do_calc_v_c,     'do_calc_v_c',     moduleName )
      call deallocate_test ( do_calc_v,       'do_calc_v',       moduleName )
      call deallocate_test ( do_calc_v_f,     'do_calc_v_f',     moduleName )
      call deallocate_test ( do_calc_w_c,     'do_calc_w_c',     moduleName )
      call deallocate_test ( do_calc_w,       'do_calc_w',       moduleName )
      call deallocate_test ( do_calc_w_f,     'do_calc_w_f',     moduleName )

a1817 10
      call deallocate_test ( eta_zxp_n_c,     'eta_zxp_n_c',     moduleName )
      call deallocate_test ( eta_zxp_n,       'eta_zxp_n',       moduleName )
      call deallocate_test ( eta_zxp_n_f,     'eta_zxp_n_f',     moduleName )
      call deallocate_test ( eta_zxp_v_c,     'eta_zxp_v_c',     moduleName )
      call deallocate_test ( eta_zxp_v,       'eta_zxp_v',       moduleName )
      call deallocate_test ( eta_zxp_v_f,     'eta_zxp_v_f',     moduleName )
      call deallocate_test ( eta_zxp_w_c,     'eta_zxp_w_c',     moduleName )
      call deallocate_test ( eta_zxp_w,       'eta_zxp_w',       moduleName )
      call deallocate_test ( eta_zxp_w_f,     'eta_zxp_w_f',     moduleName )

a1833 4
      call deallocate_test ( spect_n_path,    'spect_n_path',    moduleName )
      call deallocate_test ( spect_v_path,    'spect_v_path',    moduleName )
      call deallocate_test ( spect_w_path,    'spect_w_path',    moduleName )

d3279 1
a3279 1
    & "$Id: FullForwardModel_m.f90,v 2.240 2005/07/08 19:40:51 vsnyder Exp $"
d3288 3
@


2.240
log
@OOPS, forgot to nullify Rad_FFT
@
text
@d33 2
a34 1
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
d37 2
a38 1
    use Comp_Sps_Path_Frq_m, only: Comp_Sps_Path, Comp_Sps_Path_Frq
a45 1
    use Eval_Spect_Path_m, only: Eval_Spect_Path
d49 1
a49 1
      & ForwardModelConfig_t
d63 3
a65 3
      & L_CLOUDWATER, L_DN, L_DV, L_DW, L_EARTHREFL, L_ECRtoFOV, &
      & L_ELEVOFFSET, L_GPH, L_LINECENTER, L_LINEWIDTH, L_LINEWIDTH_TDEP, &
      & L_LOSVEL, L_LIMBSIDEBANDFRACTION, L_MAGNETICFIELD, &
d73 1
a73 1
    use MLSCommon, only: R4, R8, RP, IP
d94 1
a94 1
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, GETVECTORQUANTITYBYTYPE
a96 1
      ! Only fwdModelConf derived stuff are changed here.
d119 3
a121 3
    integer :: F_LEN_DN                 ! Length of DN in vector
    integer :: F_LEN_DV                 ! Length of DV in vector
    integer :: F_LEN_DW                 ! Length of DW in vector
d196 9
a204 9
    logical, dimension(:,:), pointer :: DO_CALC_DN    ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DN_C  ! DO_CALC_DN on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_DN_F  ! DO_CALC_DN on fine grid
    logical, dimension(:,:), pointer :: DO_CALC_DV    ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DV_C  ! DO_CALC_DV on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_DV_F  ! DO_CALC_DV on fine grid
    logical, dimension(:,:), pointer :: DO_CALC_DW    ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DW_C  ! DO_CALC_DW  on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_DW_F  ! DO_CALC_DW  on fine grid
d328 3
a330 9
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN_C ! ETA_ZXP_DN on coarse grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN   ! Eta_z x Eta_p for N
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN_F ! ETA_ZXP_DN on fine grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV_C ! ETA_ZXP_DV on coarse grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV   ! Eta_z x Eta_p for V
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV_F ! ETA_ZXP_DV on fine grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW_C ! ETA_ZXP_DW on coarse grid
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW   ! Eta_z x Eta_p for W
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW_F ! ETA_ZXP_DW on fine grid
d334 6
d347 1
d349 1
d352 3
a416 2
! THIS VARIABLE REPLACES fwdModelConf%tangentGrid%surfs

a423 3
    type (VectorValue_T), pointer :: LineCenter    ! Avg. delta line centers for molecule
    type (VectorValue_T), pointer :: LineWidth     ! Avg. delta line widths for molecule
    type (VectorValue_T), pointer :: LineWidth_TDep ! Avg. delta line width temp. dep
d436 1
d442 3
a444 3
    type (Grids_T) :: Grids_dn  ! All the spectroscopy(N) coordinates
    type (Grids_T) :: Grids_dv  ! All the spectroscopy(V) coordinates
    type (Grids_T) :: Grids_dw  ! All the spectroscopy(W) coordinates
d465 1
d467 1
d469 1
d528 3
a530 3
      & do_calc_Cext, do_calc_Cext_zp, do_calc_dn, do_calc_dn_c, &
      & do_calc_dn_F, do_calc_dv, do_calc_dv_c, do_calc_dv_f, do_calc_dw, &
      & do_calc_dw_c, do_calc_dw_f, do_calc_fzp, do_calc_hyd, do_calc_hyd_c, &
d538 3
a540 3
      & eta_tscat, eta_tscat_zp, eta_zp, eta_zxp_dn, eta_zxp_dn_c, &
      & eta_zxp_dn_f, eta_zxp_dv, eta_zxp_dv_c, eta_zxp_dv_f, eta_zxp_dw, &
      & eta_zxp_dw_c, eta_zxp_dw_f, eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, &
d545 1
a545 1
      & k_spect_dw_frq, k_temp, k_temp_frq, mag_path, &
d549 1
d577 3
a579 2
    ! Create the data structures for the species.  This has to be done
    ! AFTER deriveFromForwardModelConfig.
d615 8
a634 11
    if ( spect_der ) then
      lineCenter => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_lineCenter, instrumentModule=firstSignal%instrumentModule, &
      & config=fwdModelConf )
      lineWidth => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_lineWidth, instrumentModule=firstSignal%instrumentModule, &
      & config=fwdModelConf )
      lineWidth_Tdep => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_lineWidth_Tdep, instrumentModule=firstSignal%instrumentModule, &
      & config=fwdModelConf )
    end if
d735 11
a745 10
    call load_sps_data ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,   &
      & firstSignal%radiometer, l_vmr, grids_f, h2o_ind, ext_ind )
    if ( spect_der ) then
      call load_sps_data ( FwdModelConf, FwdModelIn, FwdModelExtra, maf, &
        & firstSignal%radiometer, l_dn, grids_dn )
      call load_sps_data ( FwdModelConf, FwdModelIn, FwdModelExtra, maf, &
        & firstSignal%radiometer, l_dv, grids_dv )
      call load_sps_data ( FwdModelConf, FwdModelIn, FwdModelExtra, maf, &
        & firstSignal%radiometer, l_dw, grids_dw )
    end if
d962 1
a962 1
!                         & no_sv_p_t, 'k_temp',moduleName )
d1013 68
a1080 22
      !??? Are temperature's windowStart:windowFinish correct here.  Should ???
      !??? we use minval(grids_d?%windowStart):maxval(grids_d?%windowFinish) ???
      allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFreqs, &
        & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dw' )
      allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFreqs, &
        & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dn' )
      allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFreqs, &
        & maxNoSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dv' )

      call allocate_test ( dbeta_dw_path_c,    npc, no_mol, &
        & 'dbeta_dw_path_c', moduleName )
      call allocate_test ( dbeta_dw_path_f, max_ele, no_mol, &
        & 'dbeta_dw_path_f', moduleName )
      call allocate_test ( dbeta_dn_path_c,    npc, no_mol, &
        & 'dbeta_dn_path_c', moduleName )
      call allocate_test ( dbeta_dn_path_f, max_ele, no_mol, &
d1082 15
a1096 50
      call allocate_test ( dbeta_dv_path_c,    npc, no_mol, &
        & 'dbeta_dv_path_c', moduleName )
      call allocate_test ( dbeta_dv_path_f, max_ele, no_mol, &
        & 'dbeta_dv_path_f', moduleName )

      f_len_dw = grids_dw%l_v(ubound(grids_dw%l_v,1))
      f_len_dn = grids_dn%l_v(ubound(grids_dn%l_v,1))
      f_len_dv = grids_dv%l_v(ubound(grids_dv%l_v,1))

      call allocate_test ( do_calc_dw, max_ele, f_len_dw, 'do_calc_dw', &
                        &  moduleName )
      call allocate_test ( do_calc_dw_c, max_ele, f_len_dw, 'do_calc_dw_c', &
                        &  moduleName )
      call allocate_test ( do_calc_dw_f, max_ele, f_len_dw, 'do_calc_dw_f', &
                        &  moduleName )
      call allocate_test ( do_calc_dn, max_ele, f_len_dn, 'do_calc_dn', &
                        &  moduleName )
      call allocate_test ( do_calc_dn_c, max_ele, f_len_dn, 'do_calc_dn_c', &
                        &  moduleName )
      call allocate_test ( do_calc_dn_f, max_ele, f_len_dn, 'do_calc_dn_f', &
                        &  moduleName )
      call allocate_test ( do_calc_dv, max_ele, f_len_dv, 'do_calc_dv', &
                        &  moduleName )
      call allocate_test ( do_calc_dv_c, max_ele, f_len_dv, 'do_calc_dv_c', &
                        &  moduleName )
      call allocate_test ( do_calc_dv_f, max_ele, f_len_dv, 'do_calc_dv_f', &
                        &  moduleName )

      call allocate_test ( eta_zxp_dw, max_ele, f_len_dw, 'eta_zxp_dw', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dw_c, max_ele, f_len_dw, 'eta_zxp_dw_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dw_f, max_ele, f_len_dw, 'eta_zxp_dw_f', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dn, max_ele, f_len_dn, 'eta_zxp_dn', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dn_c, max_ele, f_len_dn, 'eta_zxp_dn_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dn_f, max_ele, f_len_dn, 'eta_zxp_dn_f', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dv, max_ele, f_len_dv, 'eta_zxp_dv', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dv_c, max_ele, f_len_dv, 'eta_zxp_dv_c', &
                        &  moduleName )
      call allocate_test ( eta_zxp_dv_f, max_ele, f_len_dv, 'eta_zxp_dv_f', &
                        &  moduleName )

      call allocate_test ( drad_dw, f_len_dw, 'drad_dw', moduleName )
      call allocate_test ( drad_dn, f_len_dn, 'drad_dn', moduleName )
      call allocate_test ( drad_dv, f_len_dv, 'drad_dv', moduleName )
d1100 3
a1102 3
      f_len_dw = 0
      f_len_dn = 0
      f_len_dv = 0
d1111 2
a1112 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'alpha_path_polarized' )
d1114 2
a1115 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'beta_path_polarized' )
d1117 2
a1118 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'alpha_path_polarized_f' )
d1120 2
a1121 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'beta_path_polarized_f' )
d1123 2
a1124 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'gl_delta_polarized' )
d1126 2
a1127 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'incoptdepth_pol' )
d1129 2
a1130 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'incoptdepth_pol_gl' )
d1132 2
a1133 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'prod_pol' )
d1135 1
a1135 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'tau_pol' )
d1137 2
a1138 2
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'deltau_pol' )
d1141 2
a1142 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'d_rad_pol_df' )
d1144 1
a1144 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'de_df' )
d1148 2
a1149 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'d_rad_pol_dt' )
d1151 2
a1152 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'dAlpha_dT_polarized_path_c' )
d1154 2
a1155 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'dAlpha_dT_polarized_path_f' )
d1157 2
a1158 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'dBeta_dT_polarized_path_c' )
d1160 2
a1161 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'dBeta_dT_polarized_path_f' )
d1163 1
a1163 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'de_dt' )
d1165 2
a1166 2
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'dincoptdepth_pol_dt' )
d1170 1
a1170 1
    call allocate_test ( ptg_angles,no_tan_hts, 'ptg_angles',moduleName )
a1321 18
        !  ** Determine the eta_zxp_dw, eta_zxp_dn, eta_zxp_dv
        if ( spect_der ) then
          call eval_spect_path ( Grids_dw, firstSignal%lo, thisSideband, &
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dw(1:no_ele,:), eta_zxp_dw(1:no_ele,:) )
          do_calc_dw_c(1:npc,:) = do_calc_dw(c_inds(1:npc),:)
          eta_zxp_dw_c(1:npc,:) = eta_zxp_dw(c_inds(1:npc),:)
          call eval_spect_path ( Grids_dn, firstSignal%lo, thisSideband, &
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dn(1:no_ele,:), eta_zxp_dn(1:no_ele,:) )
          do_calc_dn_c(1:npc,:) = do_calc_dn(c_inds(1:npc),:)
          eta_zxp_dn_c(1:npc,:) = eta_zxp_dn(c_inds(1:npc),:)
          call eval_spect_path ( Grids_dv, firstSignal%lo, thisSideband, &
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dv(1:no_ele,:), eta_zxp_dv(1:no_ele,:) )
          do_calc_dv_c(1:npc,:) = do_calc_dv(c_inds(1:npc),:)
          eta_zxp_dv_c(1:npc,:) = eta_zxp_dv(c_inds(1:npc),:)
        end if
d1340 28
a1367 2
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:), &
          & DoPFA=FwdModelConf%anyPFA(sx) )
a1773 2
      call deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', moduleName )
      call deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f', moduleName )
d1778 2
d1781 9
a1789 19
      call deallocate_test ( do_calc_dw,      'do_calc_dw',      moduleName )
      call deallocate_test ( do_calc_dw_c,    'do_calc_dw_c',    moduleName )
      call deallocate_test ( do_calc_dw_f,    'do_calc_dw_f',    moduleName )
      call deallocate_test ( do_calc_dn,      'do_calc_dn',      moduleName )
      call deallocate_test ( do_calc_dn_c,    'do_calc_dn_c',    moduleName )
      call deallocate_test ( do_calc_dn_f,    'do_calc_dn_f',    moduleName )
      call deallocate_test ( do_calc_dv,      'do_calc_dv',      moduleName )
      call deallocate_test ( do_calc_dv_c,    'do_calc_dv_c',    moduleName )
      call deallocate_test ( do_calc_dv_f,    'do_calc_dv_f',    moduleName )

      call deallocate_test ( eta_zxp_dw,      'eta_zxp_dw',      moduleName )
      call deallocate_test ( eta_zxp_dw_c,    'eta_zxp_dw_c',    moduleName )
      call deallocate_test ( eta_zxp_dw_f,    'eta_zxp_dw_f',    moduleName )
      call deallocate_test ( eta_zxp_dn,      'eta_zxp_dn',      moduleName )
      call deallocate_test ( eta_zxp_dn_c,    'eta_zxp_dn_c',    moduleName )
      call deallocate_test ( eta_zxp_dn_f,    'eta_zxp_dn_f',    moduleName )
      call deallocate_test ( eta_zxp_dv,      'eta_zxp_dv',      moduleName )
      call deallocate_test ( eta_zxp_dv_c,    'eta_zxp_dv_c',    moduleName )
      call deallocate_test ( eta_zxp_dv_f,    'eta_zxp_dv_f',    moduleName )
a1790 1
      call deallocate_test ( drad_dw,         'drad_dw',         moduleName )
d1793 1
d1795 29
a1823 9
      deallocate ( k_spect_dw, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dw' )
      deallocate ( k_spect_dn, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dn' )
      deallocate ( k_spect_dv, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dv' )
d2034 2
a2035 1
            & tan_chi_out-thisElev, convolve_support, do_dRad_dx=ptan_der )
d2040 1
d2044 1
a2044 1
              & temp, grids_tmp, surf_angle(1), &
d2050 1
d2056 2
a2057 2
              & thisFraction, update, thisRadiance, &
              & beta_group%qty, Grids_f, real(k_atmos(i,:,:),kind=rp), &
d2060 21
d2086 2
a2087 1
            & method='S', extrapolate='C', coeffs=coeffs, dyByDx=ptan_der )
d2091 2
a2092 2
            & thisRadiance, Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, &
            & ptan_der )
d2097 1
a2097 1
              & thisRadiance, temp, grids_tmp, &
d2104 2
a2105 2
              & beta_group%qty, grids_f, real(k_atmos(i,:,:),kind=rp), &
              & Jacobian, fmStat%rows, linear=.true. )
d2365 1
a2365 1
            call dI_dSomething ( grids_dw, k_spect_dw_frq, k_spect_dw, k )
d2367 1
a2367 1
            call dI_dSomething ( grids_dn, k_spect_dn_frq, k_spect_dn, k )
d2369 1
a2369 1
            call dI_dSomething ( grids_dv, k_spect_dv_frq, k_spect_dv, k )
d2458 1
a2458 1
          & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp, pfa )
d2941 7
a2947 7
            do_calc_dw_f(:ngl,:) = do_calc_dw(gl_inds(:ngl),:)
            eta_zxp_dw_f(:ngl,:) = eta_zxp_dw(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, Grids_dw,                    &
              &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw_c(1:npc,:),      &
              &  sps_path(c_inds,:), do_calc_dw_c(1:npc,:),            &
              &  dbeta_dw_path_f(:ngl,:), eta_zxp_dw_f(:ngl,:),        &
              &  sps_path(gl_inds(1:ngl),:), do_calc_dw_f(:ngl,:),     &
d2951 1
a2951 1
            k_spect_dw_frq(frq_i,1:f_len_dw) = drad_dw(1:f_len_dw)
d2955 7
a2961 7
            do_calc_dn_f(:ngl,:) = do_calc_dn(gl_inds(:ngl),:)
            eta_zxp_dn_f(:ngl,:) = eta_zxp_dn(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, Grids_dn,                    &
              &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn_c(1:npc,:),      &
              &  sps_path(c_inds,:), do_calc_dn_c(1:npc,:),            &
              &  dbeta_dn_path_f(:ngl,:), eta_zxp_dn_f(:ngl,:),        &
              &  sps_path(gl_inds(1:ngl),:), do_calc_dn_f(:ngl,:),     &
d2965 1
a2965 1
            k_spect_dn_frq(frq_i,1:f_len_dn) = drad_dn(1:f_len_dn)
d2969 7
a2975 7
            do_calc_dv_f(:ngl,:) = do_calc_dv(gl_inds(:ngl),:)
            eta_zxp_dv_f(:ngl,:) = eta_zxp_dv(gl_inds(:ngl),:)
            call drad_tran_dx ( del_zeta, Grids_dv,                    &
              &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv_c(1:npc,:),      &
              &  sps_path(c_inds,:), do_calc_dv_c(1:npc,:),            &
              &  dbeta_dv_path_f(:ngl,:), eta_zxp_dv_f(:ngl,:),        &
              &  sps_path(gl_inds(1:ngl),:), do_calc_dv_f(:ngl,:),     &
d2979 1
a2979 1
            k_spect_dv_frq(frq_i,1:f_len_dv) = drad_dv(1:f_len_dv)
d3095 1
a3095 1
        call allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_dw, &
d3097 1
a3097 1
        call allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_dn, &
d3099 1
a3099 1
        call allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_dv, &
d3106 1
a3106 1
                                             &   f_len_dw, f_len_dn, f_len_dv), &
d3270 1
a3270 1
    & "$Id: FullForwardModel_m.f90,v 2.239 2005/07/08 00:12:11 vsnyder Exp $"
d3279 3
@


2.239
log
@Get Rad_FFT from Convolve_Radiance to Convolve_Temperature_Deriv
@
text
@d543 2
a544 2
      & prod_pol, ptg_angles, radiances, RadV, ref_corr, req_out, salb_path, &
      & scat_alb%values, scat_ang, scat_src%values, &
d3215 1
a3215 1
    & "$Id: FullForwardModel_m.f90,v 2.238 2005/07/06 02:17:20 vsnyder Exp $"
d3224 3
@


2.238
log
@Revisions for spectral parameter derivatives
@
text
@d54 1
a54 1
      & FOV_Convolve_Teardown
d273 1
d782 1
a782 1
                         & 'dxdt_tan',moduleName )
d784 2
a785 1
                         & 'd2xdxdt_tan',moduleName )
d1740 1
d2006 6
a2011 7
          call convolve_radiance ( convolve_support, maf, chanInd, &
            & radiances(:,i), thisFraction, update, ptan, thisRadiance, &
            & Jacobian, fmStat%rows, dh_dz_out, dx_dh_out, ptan_der )

          if ( temp_der ) &
            & call convolve_temperature_deriv ( convolve_support, maf, chanInd, &
              & radiances(:,i), thisFraction, update, thisRadiance, &
d2015 5
d3215 1
a3215 1
    & "$Id: FullForwardModel_m.f90,v 2.237 2005/06/09 02:34:16 vsnyder Exp $"
d3224 3
@


2.237
log
@Move stuff from l2pc_pfa_structures to slabs_sw_m
@
text
@d38 3
a40 1
    use Convolve_All_m, only: Convolve_All
d53 2
d63 2
a64 1
      & L_ELEVOFFSET, L_GPH, L_LOSVEL, L_LIMBSIDEBANDFRACTION, L_MAGNETICFIELD, &
d75 2
a76 1
    use MLSNumerics, only: Hunt, InterpolateValues
a79 1
    use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
d396 1
a396 1
    real(rp), dimension(:), pointer :: dhdz_out
d420 3
d451 3
d522 1
a522 1
      & dhdz_gw_path, dhdz_out, dhdz_path, dincoptdepth_pol_dt, &
d620 11
d776 1
a776 1
    call allocate_test ( dhdz_out, ptan%template%nosurfs, 'dhdz_out', &
d794 1
a794 1
       & req_out, grids_f, h2o_ind, tan_chi_out, dhdz_out, dx_dh_out, &
d1703 1
a1703 1
    call deallocate_test ( dhdz_out,         'dhdz_out',         moduleName )
d1864 1
a1864 1
    subroutine Convolution
d1923 1
a1923 1
        elseif ( ptg_angles(ptg_i) <= ptg_angles(ptg_i-1) ) then
d1981 1
a1981 1
        ! Here comes the Convolution codes
d2000 6
a2005 1
          ! Now change channel from starting at 0 or 1 to definitely 1
d2007 14
a2020 42
          j = sv_t_len
          !??? Which grids_... should give the windowStart:windowFinish to use here ???
          if ( .not. temp_der .AND. .not. atmos_der ) then
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,  &
               & chanInd, windowStart, windowFinish, beta_group%qty, temp,     &
               & ptan, thisRadiance, update, ptg_angles, Radiances(:,i),       &
               & tan_chi_out-thisElev, dhdz_out, dx_dh_out, thisFraction,      &
               & antennaPatterns(whichPattern), Grids_tmp%deriv_flags,         &
               & Grids_f, Jacobian, fmStat%rows, SURF_ANGLE=surf_angle(1),     &
               & PTAN_DER=ptan_der )
          else if ( temp_der .AND. .not. atmos_der ) then
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,  &
               & chanInd, windowStart, windowFinish, beta_group%qty, temp,     &
               & ptan, thisRadiance, update, ptg_angles, Radiances(:,i),       &
               & tan_chi_out-thisElev, dhdz_out, dx_dh_out, thisFraction,      &
               & antennaPatterns(whichPattern), Grids_tmp%deriv_flags,         &
               & Grids_f, Jacobian, fmStat%rows, SURF_ANGLE=surf_angle(1),     &
               & DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp),&
               & DX_DT=dx_dt, D2X_DXDT=d2x_dxdt, DXDT_TAN=dxdt_tan,            &
               & DXDT_SURFACE=dxdt_surface, PTAN_DER=ptan_der )
          else if ( atmos_der .AND. .not. temp_der ) then
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,  &
               & chanInd, windowStart, windowFinish, beta_group%qty, temp,     &
               & ptan, thisRadiance, update, ptg_angles, Radiances(:,i),       &
               & tan_chi_out-thisElev, dhdz_out, dx_dh_out, thisFraction,      &
               & antennaPatterns(whichPattern), Grids_tmp%deriv_flags,         &
               & Grids_f, Jacobian, fmStat%rows, SURF_ANGLE=surf_angle(1),     &
               & DI_DF=real(k_atmos(i,:,:),kind=rp), PTAN_DER=ptan_der )
!              & DI_DF=real(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/)),kind=rp)) )
          else
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,  &
               & chanInd, windowStart, windowFinish, beta_group%qty, temp,     &
               & ptan, thisRadiance, update, ptg_angles, Radiances(:,i),       &
               & tan_chi_out-thisElev, dhdz_out, dx_dh_out, thisFraction,      &
               & antennaPatterns(whichPattern), Grids_tmp%deriv_flags,         &
               & Grids_f, Jacobian, fmStat%rows, SURF_ANGLE=surf_angle(1),     &
               & DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp),&
               & DX_DT=dx_dt, D2X_DXDT=d2x_dxdt, DXDT_TAN=dxdt_tan,            &
               & DXDT_SURFACE=dxdt_surface,                                    &
               & DI_DF=real(k_atmos(i,:,:),kind=rp), PTAN_DER=ptan_der )
!              & DI_DF=real(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/)),kind=rp)) )
          end if
d2024 22
a2045 35
          !??? Which grids_... should give the windowStart:windowFinish to use here ???
          j = sv_t_len
          if ( .not. temp_der .AND. .not. atmos_der ) then
            call no_conv_at_all ( fwdModelConf, fwdModelIn, fwdModelExtra, maf, chanInd, &
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update,   &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev,       &
              &  dhdz_out, dx_dh_out, Grids_f,                                  &
              &  Radiances(:,i), thisFraction, beta_group%qty, fmStat%rows,     &
              &  Jacobian,  PTAN_DER=ptan_der)
          else if ( temp_der .AND. .not. atmos_der ) then
            call no_conv_at_all ( fwdModelConf, fwdModelIn, fwdModelExtra, maf, chanInd, &
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update,   &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev,       &
              &  dhdz_out, dx_dh_out, Grids_f,                                  &
              &  Radiances(:,i), thisFraction, beta_group%qty, fmStat%rows,     &
              &  Jacobian, DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp), &
              &  PTAN_DER=ptan_der )
          else if ( atmos_der .AND. .not. temp_der ) then
            call no_conv_at_all ( fwdModelConf, fwdModelIn, fwdModelExtra, maf, chanInd, &
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update,   &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev,       &
              &  dhdz_out, dx_dh_out, Grids_f,                                  &
              &  Radiances(:,i), thisFraction, beta_group%qty, fmStat%rows,     &
              &  Jacobian, DI_DF=real(k_atmos(i,:,:),kind=rp), PTAN_DER=ptan_der )
!             &  DI_DF=real(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/)),kind=rp) )
          else
            call no_conv_at_all ( fwdModelConf, fwdModelIn, fwdModelExtra, maf, chanInd, &
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update,   &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev,       &
              &  dhdz_out, dx_dh_out, Grids_f,                                  &
              &  Radiances(:,i), thisFraction, beta_group%qty, fmStat%rows,     &
              &  Jacobian, DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp), &
              &  DI_DF=real(k_atmos(i,:,:),kind=rp), PTAN_DER=ptan_der )
!             &  DI_DF=real(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/)),kind=rp) )
          end if
d2047 1
a2047 1
        end if
d2410 1
a2410 1
            &  beta_path_c, t_der_path_flags, dTanh_dT_c,                     &
d2657 1
d3208 1
a3208 1
    & "$Id: FullForwardModel_m.f90,v 2.236 2005/06/03 01:59:25 vsnyder Exp $"
d3217 3
@


2.236
log
@New copyright notice, move Id to not_used_here to avoid cascades
@
text
@a63 2
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATESLABS, &
                                &  DESTROYCOMPLETESLABS
d80 2
a81 1
    use SLABS_SW_M, only: GET_GL_SLABS_ARRAYS
d3221 1
a3221 1
    & "$Id: FullForwardModel_m.f90,v 2.235 2005/04/19 20:16:45 livesey Exp $"
d3230 3
@


2.235
log
@Added a couple of nullifys
@
text
@d1 10
a10 2
! Copyright (c) 2005, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contracts NAS7-1407/NAS7-03001 is acknowledged.
a20 3
  character (len=*), parameter, private :: IdParm = &
    & "$Id: FullForwardModel_m.f90,v 2.234 2005/03/28 20:26:25 vsnyder Exp $"
  character (len=len(idParm)) :: Id = IdParm
d24 1
d3220 5
d3231 3
@


2.234
log
@Lots of PFA stuff
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.233 2005/03/10 00:28:09 pwagner Exp $"
d514 2
a515 2
      & dTanh_dT_f, d_t_scr_dt, &
      & dx_dh_out, dx_dt, dxdt_surface, dxdt_tan, eta_cext, eta_cext_zp, &
d528 2
a529 1
      & sps_path, tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tanh1_c, tanh1_f, &
d3220 3
@


2.233
log
@Better patching of ptg_angles avoids list-out-of-order in Hunt
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.232 2005/02/17 02:35:29 vsnyder Exp $"
d78 1
a78 1
    use Tau_M, only: Get_Tau, Tau_T
d1150 2
a1151 1
      call allocateSlabs ( gl_slabs, max_ele, fwdModelConf%catalog(thisSideband,:), &
d1313 5
a1317 11
        if ( .not. FwdModelConf%anyPFA ) &
          & call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
            & 0.0_r8, eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
            & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:), DoPFA=.false. )

        if ( FwdModelConf%anyPFA ) &
          & call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
            & 0.0_r8, eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
            & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:), DoPFA=.true. )
d1438 1
a1438 1
!       if ( FwdModelConf%firstPFA > 1 ) then
d1446 7
a1452 3
!       else
!         tau_lbl%i_stop(:noFreqs) = 0
!       end if
d1461 1
a1461 2
        if ( FwdModelConf%anyPFA ) then

d1469 6
a1474 1

d1499 8
a1506 8
      call deallocate_test ( Radv, 'RadV', moduleName )
      call deallocate_test ( T_Script_LBL, 'T_Script_LBL', moduleName )
      call deallocate_test ( tau_LBL%tau, 'Tau_LBL%Tau', moduleName )
      call deallocate_test ( tau_LBL%i_stop, 'Tau_LBL%I_Stop', moduleName )
      if ( FwdModelConf%anyPFA ) then
        call deallocate_test ( T_Script_PFA, 'T_Script_PFA', moduleName )
        call deallocate_test ( tau_PFA%tau, 'Tau_PFA%Tau', moduleName )
        call deallocate_test ( tau_PFA%i_stop, 'Tau_PFA%I_Stop', moduleName )
d2151 1
a2151 1
      if ( fwdModelConf%do_freq_avg ) then
d2157 1
a2157 1
            & RadV, DACsStaging(:,i) )
d2172 5
a2176 4
            if ( fwdModelConf%anyPFA) then
            ! Combine LBL and PFA Tau's to get radiances
              call rad_tran_PFA ( klo, khi, i, &
                & tau_LBL, tau_PFA, t_script_lbl, t_script_pfa, radV )
d2178 1
a2178 1
            call Freq_Avg_Avg ( frequencies, &
d2181 1
a2181 1
              &   radV, klo, khi, dF, radiances(ptg_i,i) )
d2186 2
a2187 1
      else if ( FwdModelConf%anyPFA ) then
d2189 2
a2190 4
          ! Combine LBL and PFA Tau's to get radiances
          call rad_tran_PFA ( i, i, i, &
            & tau_LBL, tau_PFA, t_script_lbl, t_script_pfa, &
            & radiances(ptg_i,1:noUsedChannels) )
d2411 1
a2411 1
          frqhk = 0.5_r8 * frq * h_over_k ! h nu / 2 k
d2631 2
a2632 2
        ! Where we don't do GL (everywhere if pfa), replace the rectangle
        ! rule by the trapezoid rule.
d2645 1
a2645 1
          call get_beta_path_PFA ( frq, frq_i, z_path, gl_inds, t_path_f(:ngl),  &
d2681 1
a2681 1
        if ( FwdModelConf%anyPFA ) then
a3007 5
      call allocate_test ( T_Script_LBL, npcmax, maxNoPtgFreqs, 'T_Script_LBL', moduleName )
      call allocate_test ( tau_LBL%tau, npcmax, maxNoPtgFreqs, 'Tau_LBL%Tau', &
        & moduleName )
      call allocate_test ( tau_LBL%i_stop, maxNoPtgFreqs, 'Tau_LBL%I_Stop', &
        & moduleName )
d3009 9
a3017 1
      if ( FwdModelConf%anyPFA ) then
d3219 3
@


2.232
log
@Do PFA on fine path if necessary
@
text
@d1 2
a2 2
! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.231 2005/02/16 23:16:49 vsnyder Exp $"
d1835 1
d1870 1
a1870 1
        if ( ptg_angles(ptg_i) <= ptg_angles(ptg_i-1) ) then
d1892 18
d3213 3
@


2.231
log
@Revise data structures for split-sideband PFA
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.230 2004/12/28 00:28:02 vsnyder Exp $"
d2385 2
a2386 3
          call get_beta_path_PFA ( frq, z_path, c_inds, t_path_c,                &
            & channels(frq_i)%PFAIndex(thisSideband,:), channels(frq_i)%betaIndex, &
            & vel_rel, beta_path_c, t_der_path_flags,                            &
d2554 1
d2557 1
a2557 2
        if ( pfa ) then ! do nothing -- we can't do GL or polarized
        else if ( .not. fwdModelConf%polarized ) then
d2617 11
a2627 3
        if ( .not. pfa ) then
          call get_GL_inds ( do_gl, gl_inds, cg_inds, ngl, ncg )
          ! ngl is ng * count(do_gl)
a2628 1
          t_path_f(:ngl) = t_path(gl_inds(:ngl))
a2644 5
          do j = 1, ngl ! loop around dot_product instead of doing sum(a*b,2)
                        ! to avoid path-length array temps
            alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                         & beta_path_f(j,:) )
          end do
d2647 6
d3194 3
@


2.230
log
@Remove unreferenced use name
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.229 2004/12/13 20:37:23 vsnyder Exp $"
d150 2
a151 1
    integer :: THISSIDEBAND             ! Loop counter for sidebands
d1147 2
d2395 3
a2397 3
          call get_beta_path ( Frq, p_path, t_path_c, tanh1_c, beta_group,  &
            &  fwdModelConf%polarized, gl_slabs, c_inds, beta_path_c,       &
            &  t_der_path_flags, dTanh_dT_c, &
d2566 1
a2566 1
          call get_beta_path_polarized ( frq, h, beta_group, gl_slabs, &
d2635 2
a2636 2
            & beta_group, fwdModelConf%polarized, gl_slabs, gl_inds(:ngl),     &
            & beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,  &
d2673 1
a2673 1
          call get_beta_path_polarized ( frq, h, beta_group, gl_slabs, &
d3187 3
@


2.229
log
@Moved stuff from get_species_data to ForwardModelConfig, some cannonball polishing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.228 2004/11/05 19:38:39 vsnyder Exp $"
d49 1
a49 1
    use Get_Species_Data_M, only:  Destroy_Species_Data, Get_Species_Data
d3184 3
@


2.228
log
@Got rid of DerivedFromForwardModel component of config
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.227 2004/11/01 20:26:35 vsnyder Exp $"
d37 1
a37 1
    use FilterShapes_m, only: FilterShapes, DACSFilterShapes
a1421 1

d1577 1
a1577 1
    !  **** End of Printing cycle ...
a1580 2
    call destroy_species_data ( fwdModelConf )

d1589 2
a1590 2
    call deallocate_test ( z_glGrid, 'z_glGrid', moduleName )
    call deallocate_test ( p_glGrid, 'z_glGrid', moduleName )
d2387 2
a2388 2
          frqhk = 0.5_r8 * frq * h_over_k ! h nu / 2 k T
          tanh1_c = tanh( frqhk / t_path_c )
d3184 3
@


2.227
log
@Reorganization of representation for molecules and beta groups; PFA may be broken for now
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.226 2004/10/13 01:08:27 vsnyder Exp $"
d86 1
a86 2
      ! Only fwdModelConf%ForwardModelDerived and some
      ! components of fwdModelConf%beta_group are changed here.
d541 3
a543 3
    channels => fwdModelConf%forwardModelDerived%channels
    DACsStaging => fwdModelConf%forwardModelDerived%DACsStaging
    usedDACSSignals => fwdModelConf%forwardModelDerived%usedDACSSignals
d3187 3
@


2.226
log
@Moved some checking to ForwardModelSupport
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.225 2004/10/07 23:26:09 vsnyder Exp $"
d38 3
a40 2
    use ForwardModelConfig, only: Channels_T, DeriveFromForwardModelConfig, &
      & DestroyForwardModelDerived, ForwardModelConfig_t
d49 1
a49 1
    use Get_Species_Data_M, only:  Destroy_Species_Data, Get_Species_Data, SPS_T
d86 2
a87 1
      ! Only the ForwardModelDerived component of FwdModelConf is changed here.
d135 1
a135 4
    integer :: NO_LBL                   ! Number of major line-by-line molecules
                                        ! (NO iso/vib)
    integer :: NO_MOL                   ! Number of major molecules (NO iso/vib)
                                        ! Includes PFA molecules
a274 1
    real(rp), dimension(:), pointer :: TAU          ! Optical depth
d459 1
a459 2

    type (sps_t) :: SPS ! Species stuff
d539 2
d555 1
a555 2
    ! AFTER deriveFromForwardModelConfig to get the indices for the
    ! PFA calculations.
d557 1
a557 4
    call get_species_data ( fwdModelConf, fwdModelIn, fwdModelExtra, &
      & firstSignal%radiometer, sps )
    no_mol = sps%no_mol
    no_lbl = sps%no_lbl
d562 1
a562 1
    ! VMRS are in sps%beta_group%qty, gotten by get_species_data
d620 3
a622 3
    do sps_i = 1, no_lbl
      maxNoFreqs = max(maxNoFreqs, sps%beta_group(sps_i)%qty%qty%template%noChans)
      maxNoSurfs = max(maxNoSurfs, sps%beta_group(sps_i)%qty%qty%template%noSurfs)
d667 1
a667 1
      nspec = no_lbl ! Will be at least 3 if l_n2o is included, because
d704 1
a704 2
      & firstSignal%radiometer, sps%beta_group%mol_cat_index, l_vmr, grids_f, &
      & sps%beta_group%qty, h2o_ind, ext_ind )
d707 1
a707 1
        & firstSignal%radiometer, sps%beta_group%mol_cat_index, l_dn, grids_dn )
d709 1
a709 1
        & firstSignal%radiometer, sps%beta_group%mol_cat_index, l_dv, grids_dv )
d711 1
a711 1
        & firstSignal%radiometer, sps%beta_group%mol_cat_index, l_dw, grids_dw )
d771 1
a771 1
    call compute_GL_grid ( fwdModelConf, temp, sps%beta_group%qty, nlvl, maxVert, &
d894 1
a894 1
    call allocate_test ( beta_path_f,   max_ele, no_lbl, 'beta_path_f',   moduleName )
d936 1
a936 1
      call allocate_test ( dBeta_dT_path_f, max_ele, no_lbl,   'dBeta_dT_path_f', &
d996 1
a996 1
      call allocate_test ( dbeta_dw_path_f, max_ele, no_lbl, &
d1000 1
a1000 1
      call allocate_test ( dbeta_dn_path_f, max_ele, no_lbl, &
d1004 1
a1004 1
      call allocate_test ( dbeta_dv_path_f, max_ele, no_lbl, &
d1068 1
a1068 1
      allocate ( beta_path_polarized(-1:1,npc,no_lbl), stat=ier )
d1074 1
a1074 1
      allocate ( beta_path_polarized_f(-1:1,max_ele,no_lbl), stat=ier )
d1096 1
a1096 1
        allocate ( d_rad_pol_df(2,2,grids_f%l_v(grids_f%lastNonPFA)), stat=ier )
d1099 1
a1099 1
        allocate ( de_df(2,2,npc,grids_f%l_v(grids_f%lastNonPFA)), stat=ier )
d1113 1
a1113 1
        allocate ( dBeta_dT_polarized_path_c(-1:1,npc,no_lbl), stat=ier )
d1116 1
a1116 1
        allocate ( dBeta_dT_polarized_path_f(-1:1,max_ele,no_lbl), stat=ier )
d1148 1
a1148 1
      call allocateSlabs ( gl_slabs, max_ele, sps%catalog(thisSideband,:), &
d1310 1
a1310 1
        if ( FwdModelConf%firstPFA > 1 ) &
d1316 1
a1316 1
        if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) &
d1442 1
a1442 1
        if ( FwdModelConf%firstPFA > 1 ) then
d1450 3
a1452 3
        else
          tau_lbl%i_stop(:noFreqs) = 0
        end if
d1461 1
a1461 1
        if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) then
d1499 1
a1499 1
      if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) then
d1563 1
a1563 1
      Print "( 4(3x, f11.7) )", Ptan%values(1:k,maf)
d1575 1
a1575 1
      Print *
d1583 1
a1583 1
    call destroy_species_data ( sps )
d1957 1
a1957 1
               & chanInd, windowStart, windowFinish, sps%beta_group%qty, temp, &
d1965 1
a1965 1
               & chanInd, windowStart, windowFinish, sps%beta_group%qty, temp, &
d1975 1
a1975 1
               & chanInd, windowStart, windowFinish, sps%beta_group%qty, temp, &
d1984 1
a1984 1
               & chanInd, windowStart, windowFinish, sps%beta_group%qty, temp, &
d2005 1
a2005 1
              &  Radiances(:,i), thisFraction, sps%beta_group%qty, fmStat%rows, &
d2012 1
a2012 1
              &  Radiances(:,i), thisFraction, sps%beta_group%qty, fmStat%rows, &
d2020 1
a2020 1
              &  Radiances(:,i), thisFraction, sps%beta_group%qty, fmStat%rows, &
d2028 1
a2028 1
              &  Radiances(:,i), thisFraction, sps%beta_group%qty, fmStat%rows, &
d2151 1
a2151 1
            if ( fwdModelConf%firstPFA < size(fwdModelConf%molecules) ) then
d2164 1
a2164 1
      else if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) then
d2230 2
a2231 2
        do k = 1, no_lbl
          if ( fwdModelConf%moleculeDerivatives(sps%beta_group(k)%mol_cat_index) ) then
d2287 2
a2288 2
        do k = 1, no_lbl
          if ( fwdModelConf%moleculeDerivatives(sps%beta_group(k)%mol_cat_index) ) then
a2361 1
      integer :: SPS_1, SPS_N             ! Which species to do
a2367 8
      if ( pfa ) then ! Doing PFA, which come after nonPFA in grids_f
        sps_1 = Grids_f%lastNonPFA + 1
        sps_n = ubound(Grids_f%l_z,1)
      else
        sps_1 = 1
        sps_n = Grids_f%lastNonPFA
      end if

d2396 3
a2398 3
          call get_beta_path ( Frq, p_path, t_path_c, tanh1_c,                   &
            &  sps%beta_group(sps_1:sps_n), fwdModelConf%polarized, gl_slabs,    &
            &  c_inds, beta_path_c(:,sps_1:sps_n), t_der_path_flags, dTanh_dT_c, &
d2514 1
a2514 1
              &  tt_path(1:no_ele,:), sps%beta_group(sps_1:sps_n), c_inds, &
d2540 2
a2541 2
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),sps_1:sps_n), &
                                  &        beta_path_c(j,sps_1:sps_n) )     &
d2550 2
a2551 2
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),sps_1:sps_n), &
                                         & beta_path_c(j,sps_1:sps_n) )
d2567 2
a2568 2
          call get_beta_path_polarized ( frq, h, sps%beta_group(sps_1:sps_n), &
            & gl_slabs, c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )
d2577 2
a2578 2
              & matmul( beta_path_polarized(-1:1,j,sps_1:sps_n),       &
              &         sps_path(c_inds(j),sps_1:sps_n) ) * tanh1_c(j) &
d2636 2
a2637 3
            & sps%beta_group(sps_1:sps_n), fwdModelConf%polarized, gl_slabs,   &
            & gl_inds(:ngl), beta_path_f(:ngl,sps_1:sps_n), t_der_path_flags,  &
            & dTanh_dT_f, &
d2642 2
a2643 2
            alpha_path_f(j) = dot_product( sps_path(gl_inds(j),sps_1:sps_n),  &
                                         & beta_path_f(j,sps_1:sps_n) )
d2653 1
a2653 1
        if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) then
d2674 2
a2675 3
          call get_beta_path_polarized ( frq, h, sps%beta_group(sps_1:sps_n), &
            & gl_slabs, gl_inds(:ngl), beta_path_polarized_f,    &
            & dBeta_dT_polarized_path_f )
d2684 2
a2685 2
              & matmul( beta_path_polarized_f(-1:1,j,sps_1:sps_n), &
              &         sps_path(gl_inds(j),sps_1:sps_n) ) * tanh1_f(j) &
d2727 1
a2727 1
            &  t_script(:,frq_i), tau%tau(:npc,frq_i), i_stop, pfa,  &
d2749 1
a2749 1
              k_atmos_frq(frq_i,sps_1:sps_n) = real(d_rad_pol_df(1,1,sps_1:sps_n))
d2751 1
a2751 1
              k_atmos_frq(frq_i,sps_1:sps_n) = real(d_rad_pol_df(2,2,sps_1:sps_n))
d2796 1
a2796 1
            do j = 1, no_lbl
d2986 1
a2986 1
      if ( FwdModelConf%firstPFA < size(FwdModelConf%molecules) ) then
d3188 3
@


2.225
log
@Changes in Beta_Group structure
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.224 2004/10/06 21:27:41 vsnyder Exp $"
d54 1
a54 2
      & L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_TEMPERATURE, L_VMR, &
      & LIT_INDICES
d68 1
a68 2
    use Molecules, only: FIRST_MOLECULE, LAST_MOLECULE,                      &
                       & L_H2O, L_H2O_18, L_N2, L_N2O, L_O_18_O, L_O2, L_O3
a75 1
    use String_table, only: GET_STRING
a171 1
    character (len=32) :: molName       ! Name of a molecule
a210 1
    logical :: Got( FIRST_MOLECULE : LAST_MOLECULE )  !
d671 3
a673 3
      ! now checking spectroscopy
      got = .false.
      nspec = no_lbl
a678 1
        call get_string ( lit_indices( abs(fwdModelConf%molecules(j)) ), molName )
d680 22
a701 28
        select case (fwdModelConf%molecules(j))
        case ( L_H2O, L_O3, L_N2O )
          ispec = 0
          if(fwdModelConf%molecules(j) == l_h2o) ispec = 1
          if(fwdModelConf%molecules(j) == l_o3) ispec = 2
          if(fwdModelConf%molecules(j) == l_n2o) ispec = 3
          if(fwdModelConf%molecules(j) == l_h2o) got(L_H2O) = .true.
          if(fwdModelConf%molecules(j) == l_o3) got(L_O3) = .true.

          vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
            & quantityType=l_vmr, molecule=fwdModelConf%molecules(j) )

          novmrSurf = vmr%template%nosurfs

          call InterpolateValues ( &
          & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
          & reshape(vmr%values(:,inst),(/novmrSurf/)),      &    ! Old Y
          & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
          & vmrArray(ispec,:),                              &    ! New Y
          & 'Linear', extrapolate='Clamp' )

        case ( L_N2, L_O2, L_H2O_18, L_O_18_O)
          call MLSMessage(MLSMSG_Warning, ModuleName, &
          &'cloud fwd model internally has this molecule: '//trim(molName))
        case default
          call MLSMessage(MLSMSG_Error, ModuleName, &
          &'cloud fwd model currently cannot accept this molecule: '//trim(molName))
        end select
a703 4
      ! make sure we have at least two molecules h2o and o3.
      if ( .not. got(l_h2o) .or. .not. got(l_o3) ) &
        & call MLSMessage(MLSMSG_Error, ModuleName, 'Missing molecules H2O or O3 in cloud FM' )

d3205 3
@


2.224
log
@More work on PFA -- seems to work now
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.223 2004/09/14 17:20:45 bill Exp $"
d572 1
a572 1
    ! VMRS are in sps%qtys, gotten by get_species_data
d631 2
a632 2
      maxNoFreqs = max(maxNoFreqs, sps%qtys(sps_i)%qty%template%noChans)
      maxNoSurfs = max(maxNoSurfs, sps%qtys(sps_i)%qty%template%noSurfs)
d725 2
a726 2
      & firstSignal%radiometer, sps%mol_cat_index, l_vmr, grids_f, sps%qtys, &
      & h2o_ind, ext_ind )
d729 1
a729 1
        & firstSignal%radiometer, sps%mol_cat_index, l_dn, grids_dn )
d731 1
a731 1
        & firstSignal%radiometer, sps%mol_cat_index, l_dv, grids_dv )
d733 1
a733 1
        & firstSignal%radiometer, sps%mol_cat_index, l_dw, grids_dw )
d793 1
a793 1
    call compute_GL_grid ( fwdModelConf, temp, sps%qtys, nlvl, maxVert, &
d1979 2
a1980 2
               & chanInd, windowStart, windowFinish, sps%qtys, temp,ptan,      &
               & thisRadiance, update, ptg_angles, Radiances(:,i),             &
d1987 2
a1988 2
               & chanInd, windowStart, windowFinish, sps%qtys, temp, ptan,     &
               & thisRadiance, update, ptg_angles, Radiances(:,i),             &
d1997 2
a1998 2
               & chanInd, windowStart, windowFinish, sps%qtys, temp, ptan,     &
               & thisRadiance, update, ptg_angles, Radiances(:,i),             &
d2006 2
a2007 2
               & chanInd, windowStart, windowFinish, sps%qtys, temp, ptan,     &
               & thisRadiance, update, ptg_angles, Radiances(:,i),             &
d2027 2
a2028 2
              &  Radiances(:,i), thisFraction, sps%qtys, fmStat%rows, Jacobian, &
              &  PTAN_DER=ptan_der)
d2034 2
a2035 2
              &  Radiances(:,i), thisFraction, sps%qtys, fmStat%rows, Jacobian, &
              &  DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp), &
d2042 2
a2043 2
              &  Radiances(:,i), thisFraction, sps%qtys, fmStat%rows, Jacobian, &
              &  DI_DF=real(k_atmos(i,:,:),kind=rp), PTAN_DER=ptan_der )
d2050 2
a2051 2
              &  Radiances(:,i), thisFraction, sps%qtys, fmStat%rows, Jacobian, &
              &  DI_DT=real(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/)),kind=rp), &
d2253 1
a2253 1
          if ( fwdModelConf%moleculeDerivatives(sps%mol_cat_index(k)) ) then
d2310 1
a2310 1
          if ( fwdModelConf%moleculeDerivatives(sps%mol_cat_index(k)) ) then
d3221 3
@


2.223
log
@add mif dependent los vel correction-wgr
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.222 2004/09/04 01:50:30 vsnyder Exp $"
d80 1
a110 1
    integer :: FRQ_I                    ! Loop counter for adding PFA
d144 1
a284 1
    real(rp), dimension(:), pointer :: T_SCRIPT     ! Delta_B in some notes
d350 2
d358 3
d469 2
d537 1
a537 1
      & tan_phi, tan_temp, tau, tau_pol, t_der_path_flags, t_glgrid, &
d539 1
a539 1
      & tscat_path, t_script, tt_path, tt_path_c, &
d619 16
a661 16
    ! Check that we have radiances for the channels that are used
    do sigInd = 1, size(fwdModelConf%signals)
      ! This just emits an error message and stops if we don't have a radiance.
      ! We don't use the vector quantity -- at least not right away.  We get
      ! it again later.
      thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
        & signal=fwdModelConf%signals(sigInd)%index, sideband=sideband )
    end do

    maxNoFreqs = 0
    maxNoSurfs = 0
    do sps_i = 1, no_lbl
      maxNoFreqs = max(maxNoFreqs, sps%qtys(sps_i)%qty%template%noChans)
      maxNoSurfs = max(maxNoSurfs, sps%qtys(sps_i)%qty%template%noSurfs)
    end do

a907 1
    call allocate_test ( tau,                 npc, 'tau',              moduleName )
a910 1
    call allocate_test ( t_script,            npc, 't_script',         moduleName )
d980 1
a980 1
      call allocate_test ( eta_zxp_t_c,        npc, sv_t_len, 'eta_zxp_t_c', &
d1162 2
d1332 11
a1342 4
        call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
          & 0.0_r8, eta_zp(1:no_ele,:), &
          & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d1464 11
a1474 7
        call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:),      &
          & c_inds(:npc), del_s(:npc), del_zeta(:npc),                      &
          & do_calc_fzp(:no_ele,:), do_calc_zp(:no_ele,:), do_GL(:npc),     &
          & eta_fzp(:no_ele,:), eta_zp(:no_ele,:), frequencies, h_path_c,   &
          & incoptdepth(:npc), p_path(:no_ele), pfaFalse, ref_corr(:npc),   &
          & sps_path(:no_ele,:), tau(:npc), t_path_c(:npc), t_script(:npc), &
          & tanh1_c(:npc), tt_path_c(:npc), w0_path_c(:npc) )
d1476 5
a1480 1
        call frequency_average ! or not
d1484 9
a1492 17
          if ( .not. FwdModelConf%do_freq_avg ) then
            channelCenters => frequencies
          else
            call get_channel_centers ( channelCenters )
          end if
          call frequency_loop ( alpha_path_c(:npc), beta_path_c(:npc,:),      &
            & c_inds(:npc), del_s(:npc), del_zeta(:npc),                      &
            & do_calc_fzp(:no_ele,:), do_calc_zp(:no_ele,:), do_GL(:npc),     &
            & eta_fzp(:no_ele,:), eta_zp(:no_ele,:), channelCenters, h_path_c,&
            & incoptdepth(:npc), p_path(:no_ele), pfaTrue, ref_corr(:npc),    &
            & sps_path(:no_ele,:), tau(:npc), t_path_c(:npc), t_script(:npc), &
            & tanh1_c(:npc), tt_path_c(:npc), w0_path_c(:npc) )
            do frq_i = 1, noUsedChannels
            ! radiances(ptg_i,frq_i) =
            end do
          if ( FwdModelConf%do_freq_avg ) &
            & call deallocate_test ( channelCenters, 'channelCenters', moduleName )
d1495 4
d1512 1
a1512 1
      call deallocate_test ( frequencies, 'frequencies',moduleName )
d1516 1
a1516 1
      ! Deallocate maxNoPtgFreqs stuff
d1518 12
d1580 1
a1580 1
        print '(a,f12.4,a)', ' (All computations done at Frq =',Frequencies(1), ')'
a1669 1
    call deallocate_test ( tau,              'tau',              moduleName )
d1672 2
a1673 1
    call deallocate_test ( t_script,         't_script',         moduleName )
d1963 1
a1963 1
              & fwdModelConf%signals( (/sigInd/) ), sideband=thisSideband, &
d2142 6
a2147 1
      integer :: Channel, I, Instance, K, ShapeInd, SigInd, Surface, SV_I
d2171 11
a2181 4
            call Freq_Avg ( frequencies, &
              &   FilterShapes(shapeInd)%FilterGrid,  &
              &   FilterShapes(shapeInd)%FilterShape, &
              &   RadV, Radiances(ptg_i,i) )
d2186 7
d2332 1
a2332 1
      & Tau, T_Path_c, T_Script, Tanh1_c, TT_Path_c, W0_Path_c )
d2359 1
a2360 1
      real(rp), intent(inout) :: Eta_fzp(:,:) ! path x (Eta_f x Eta_z x Eta_p)
a2363 1
      real(rp), intent(inout) :: Sps_Path(:,:) ! Species on path
d2367 3
a2369 1
      real(rp), intent(out) :: Tau(:)     ! Optical depth
d2371 2
a2372 2
      real(rp), intent(out) :: T_Script(:)  ! Delta_B in some notes
      real(rp), intent(out) :: TT_Path_c(:) ! tscat on path coarse
d2374 2
a2375 1
      real(rp), intent(out) :: W0_Path_c(:) ! w0 on path coarse
d2414 1
a2414 1
          & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp )
d2417 2
a2418 2
          call get_beta_path_PFA ( frq, p_path, c_inds, t_path,                  &
            & channels(frq_i)%PFAData(thisSideband,:), channels(frq_i)%PFAIndex, &
a2586 1

d2669 1
a2669 1
            & dTanh_dT_f,&
d2681 1
a2681 4
          & spaceRadiance%values(1,1), frq, t_script )

        if ( pfa_or_not_pol ) then

d2685 8
d2694 4
a2697 3
            & alpha_path_c, ref_corr, incoptdepth, alpha_path_f(1:ngl),      &
            & dsdz_gw_path, t_script, tau, RadV(frq_i), i_stop )

d2727 2
a2728 2
            & ct, stcp, stsp, t_script, prod_pol(:,:,1:npc), tau_pol(:,:,1:npc),    &
            & rad_pol, p_stop )
d2754 3
d2760 1
a2760 1
            &  t_script, tau, i_stop, pfa,                           &
d2777 1
a2777 1
            call mcrt_der ( t_script, sqrt(e_rflty), deltau_pol(:,:,1:npc),  &
d2817 2
a2818 2
              & t_script, d_t_scr_dt(1:npc,:), tau, i_stop,                 &
              & grids_tmp%deriv_flags, drad_dt )
d2868 1
a2868 1
            call mcrt_der ( t_script, sqrt(e_rflty),             &      
d2886 2
d2899 1
a2899 1
              &  t_script, tau, i_stop, drad_dw )
d2913 1
a2913 1
              &  t_script, tau, i_stop, drad_dn )
d2927 1
a2927 1
              &  t_script, tau, i_stop, drad_dv )
d3013 19
d3033 1
a3033 1
      if ( temp_der) &
d3178 1
a3178 1
    ! Sort z_path.  Permute p_path and t_path the same way.
d3221 3
@


2.222
log
@get_beta_path_m.f90
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.221 2004/09/01 01:48:27 vsnyder Exp $"
d391 1
d811 2
a812 1
                          & scgeocalt, tan_press, tan_phi, est_scgeocalt )
d1434 1
a1434 1
            &  losVel%values(1,maf), gl_slabs(1:no_ele,:), fwdModelConf%Do_1D, &
d1438 1
a1438 1
            &  losVel%values(1,maf), gl_slabs(1:no_ele,:), fwdModelConf%Do_1D )
d1598 1
d3038 2
a3039 2
                              & scgeocalt, tan_press, &
                              & tan_phi, est_scgeocalt )
d3058 1
d3067 1
d3071 1
a3071 1
    real(rp) :: R, R1, R2       ! real variables for various uses
d3075 1
d3078 1
a3078 1
    nullify ( tan_phi, est_scgeocalt )
d3081 1
d3086 1
d3096 1
d3104 1
d3110 1
d3118 1
d3126 2
d3141 3
@


2.221
log
@Status flags, more work on PFA
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.220 2004/08/06 22:40:17 livesey Exp $"
d110 1
d230 2
a231 1
    real(rp) :: Vel_Cor       ! Velocity correction due to Vel_z
d613 2
a614 1
    Vel_Cor = 1.0_rp - losvel%values(1,maf) / speedOfLight
d1472 3
d2353 2
a2354 1
        frqhk = 0.5_r8 * frq * h_over_k ! h nu / 2 k T
a2357 5
        tanh1_c = tanh( frqhk / t_path_c )
        ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
        if ( temp_der ) dTanh_dT_c(:npc) = &
            & frqhk / t_path_c**2 * ( tanh1_c - 1.0_rp / tanh1_c )

d2365 1
a2365 1
            & vel_cor, beta_path_c, t_der_path_flags,                            &
d2368 5
d2379 1
a2379 3
        do_gl = .false.

        if ( FwdModelConf%incl_cld ) then
d2636 1
a2636 1
            & alpha_path_c, ref_corr,incoptdepth, alpha_path_f(1:ngl),       &
d3127 3
@


2.220
log
@Better patch for ptg_angles
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.219 2004/08/06 01:40:39 livesey Exp $"
d41 2
a42 1
                                    &   ForwardModelStatus_t
d475 2
d537 7
d550 3
a552 1
    ! Create the data structures for the species
a634 6
    call deriveFromForwardModelConfig ( fwdModelConf )
    channels => fwdModelConf%forwardModelDerived%channels
    DACsStaging => fwdModelConf%forwardModelDerived%DACsStaging
    usedDACSSignals => fwdModelConf%forwardModelDerived%usedDACSSignals
    noUsedChannels = size(channels)
    noUsedDacs = size(usedDACSSignals)
d1217 1
a1217 1
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1237 1
a1237 1
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1252 1
a1252 1
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1271 1
a1271 1
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1275 1
d1416 2
a1417 1
                      &  Req+one_tan_ht(1), del_s(1:npc), ref_corr(1:npc) )
d1885 1
d2284 1
a2284 1
        & Get_Beta_Path_Polarized
d2361 4
d2366 2
a2367 2
          call get_beta_path ( Frq, p_path, t_path_c, tanh1_c,                 &
            &  sps%beta_group(sps_1:sps_n), fwdModelConf%polarized, gl_slabs,  &
d3122 3
@


2.219
log
@Upgraded the precision of the ptg dump.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.218 2004/08/06 01:24:55 livesey Exp $"
d144 2
d169 1
d220 1
d1839 32
a1870 6
      do ptg_i = 2, no_tan_hts - 1
        ! this is a temporary fix
        if ( ptg_angles(ptg_i) < ptg_angles(ptg_i-1) ) then
          ptg_angles(ptg_i) = (ptg_angles(ptg_i-1) + ptg_angles(ptg_i+1))/2
          if ( index(switches,'ptg') /= 0 ) &
            & call Dump ( ptg_angles, 'ptg_angles (after a patch)', format='(1PG22.17)' )
d1872 8
a1879 13
!        if ( ptg_angles(ptg_i) < ptg_angles(ptg_i-1) )  &
!          & call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & 'Pointing angles in wrong order, too much refraction?' )
      end do ! pointing loop

!       ! EXTRA DEBUG FOR NATHANIEL/BILL ********************
!       call dump ( tan_temps, 'tan_temps' )
!       call dump ( tan_press, 'tan_press' )
!       call dump ( ptg_angles, 'ptg_angles' )
!       call dump ( tan_hts, 'tan_hts' )
!       call dump ( reqs, 'reqs' )
!       call dump ( est_scgeocalt, 'est_scgeocalt' )
!       call dump ( grids_f%values, 'grids_f' )
a1881 1

d3109 3
@


2.218
log
@Typo!
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.217 2004/08/06 01:24:22 livesey Exp $"
d1833 1
a1833 1
        call Dump ( ptg_angles, 'ptg_angles (before any patch)' )
d1840 1
a1840 1
            & call Dump ( ptg_angles, 'ptg_angles (after a patch)' )
d3085 3
@


2.217
log
@Minor bug fix in ptg_angles dump
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.216 2004/08/05 20:53:50 vsnyder Exp $"
d1838 1
a1838 1
          & ptg_angles(ptg_i) = (ptg_angles(ptg_i-1) + ptg_angles(ptg_i+1))/2
d3085 3
@


2.216
log
@More PFA preparations, some cannonball polishing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.215 2004/08/05 20:24:00 livesey Exp $"
d1837 1
a1837 1
        if ( ptg_angles(ptg_i) < ptg_angles(ptg_i-1) )  &
d1839 2
a1840 2
        if ( index(switches,'ptg') /= 0 ) then
          call Dump ( ptg_angles, 'ptg_angles (after a patch)' )
d3085 3
@


2.215
log
@Added ptg switch to dump ptg_angles
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.214 2004/08/03 22:07:10 vsnyder Exp $"
a654 4
      !??? Shouldn't size(FwdModelConf%molecules) be no_lbl ???
      if ( size(FwdModelConf%molecules) < 2 ) & ! do we have enough molecules?
        & call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )

d657 1
a657 1
      nspec = size(FwdModelConf%molecules)
d695 3
a697 4
      if ( .not. got(l_h2o) .or. .not. got(l_o3) ) then
      !make sure we have at least two molecules h2o and o3.
        call MLSMessage(MLSMSG_Error, ModuleName,'Missing molecules H2O or O3 in cloud FM')
      end if
d1444 1
a1444 1
        if ( FwdModelConf%firstPFA <= size(FwdModelConf%molecules) ) then
d1646 2
a1647 2
    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( scat_src%values, 'scat_src%values', &
d1649 1
a1649 3

    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( scat_alb%values, 'scat_alb%values', &
d1651 1
a1651 3

    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( cld_ext%values, 'cld_ext%values', &
d1653 1
d2343 1
a2343 1
          if (ptg_i == 1) then
d3085 3
@


2.214
log
@Inching further toward PFA
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.213 2004/07/30 19:53:18 livesey Exp $"
d1840 3
d1846 4
a1849 1
           & ptg_angles(ptg_i) = (ptg_angles(ptg_i-1) + ptg_angles(ptg_i+1))/2
d3093 3
@


2.213
log
@Bug fix, forbid extrapolation in Estimate_tan_phi
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.212 2004/07/08 21:00:23 vsnyder Exp $"
d120 2
a121 2
    integer :: MAXNOFFREQS              ! Max. no. frequencies for any molecule
    integer :: MAXNOFSURFS              ! Max. no. surfaces for any molecule
d134 2
a135 1
    integer :: NO_LBL                   ! Number of line-by-line molecules
d137 1
d541 1
d634 5
a638 5
    maxNoFFreqs = 0
    maxNoFSurfs = 0
    do sps_i = 1 , no_mol
      maxNoFFreqs = max(maxNoFFreqs, sps%qtys(sps_i)%qty%template%noChans)
      maxNoFSurfs = max(maxNoFSurfs, sps%qtys(sps_i)%qty%template%noSurfs)
d649 1
d655 3
a657 4
      if ( size(FwdModelConf%molecules) .lt. 2 ) then
         !   make sure we have enough molecules
         call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
      end if
d708 1
a708 1
    call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, maf,   &
d712 1
a712 1
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, maf, &
d714 1
a714 1
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, maf, &
d716 1
a716 1
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, maf, &
d721 2
a722 2
    if ( fwdModelConf%i_saturation /= l_clear ) then
      call modify_values_for_supersat ( fwdModelConf, grids_f, h2o_ind, &
a723 1
    end if
d900 2
a901 2
    call allocate_test ( beta_path_c,      npc, no_mol, 'beta_path_c',   moduleName )
    call allocate_test ( beta_path_f,   max_ele, no_mol, 'beta_path_f',   moduleName )
d943 1
a943 1
      call allocate_test ( dBeta_dT_path_f, max_ele, no_mol,   'dBeta_dT_path_f', &
d988 2
a989 2
      allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
d992 2
a993 2
      allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
d996 2
a997 2
      allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
d1003 1
a1003 1
      call allocate_test ( dbeta_dw_path_f, max_ele, no_mol, &
d1007 1
a1007 1
      call allocate_test ( dbeta_dn_path_f, max_ele, no_mol, &
d1011 1
a1011 1
      call allocate_test ( dbeta_dv_path_f, max_ele, no_mol, &
d1075 1
a1075 1
      allocate ( beta_path_polarized(-1:1,npc,no_mol), stat=ier )
d1081 1
a1081 1
      allocate ( beta_path_polarized_f(-1:1,max_ele,no_mol), stat=ier )
d1103 1
a1103 1
        allocate ( d_rad_pol_df(2,2,size(grids_f%values)), stat=ier )
d1106 1
a1106 1
        allocate ( de_df(2,2,npc,size(grids_f%values)), stat=ier )
d1120 1
a1120 1
        allocate ( dBeta_dT_polarized_path_c(-1:1,npc,no_mol), stat=ier )
d1123 1
a1123 1
        allocate ( dBeta_dT_polarized_path_f(-1:1,max_ele,no_mol), stat=ier )
d1455 7
d1911 1
a1911 2
               & tan_chi_out-thisElev,                                         &
               & dhdz_out, dx_dh_out, thisFraction,                            &
d1919 1
a1919 2
               & tan_chi_out-thisElev,                                         &
               & dhdz_out, dx_dh_out, thisFraction,                            &
d1929 1
a1929 2
               & tan_chi_out-thisElev,                                         &
               & dhdz_out, dx_dh_out, thisFraction,                            &
d1938 1
a1938 2
               & tan_chi_out-thisElev,                                         &
               & dhdz_out, dx_dh_out, thisFraction,                            &
d2163 1
a2163 1
        do k = 1, no_mol
d2220 1
a2220 1
        do k = 1, no_mol
d2293 1
d2300 9
a2308 1
      pfa_or_not_pol = pfa .or. .not. FwdModelConf%polarized
d2331 4
a2334 4
          call get_beta_path ( Frq, p_path, t_path_c, tanh1_c, sps%beta_group, &
            &  FwdModelConf%polarized, gl_slabs, c_inds, beta_path_c,          &
            &  t_der_path_flags, dTanh_dT_c, dbeta_dT_path_c,                  &
            &  dbeta_dw_path_c, dbeta_dn_path_c, dbeta_dv_path_c )
d2450 3
a2452 3
            call get_beta_path_cloud ( Frq, p_path, t_path(1:no_ele), &
              &  tt_path(1:no_ele,:), sps%beta_group, c_inds,         &
              &  beta_path_cloud_c(1:npc), w0_path_c,  tt_path_c,     &
d2477 2
a2478 1
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), beta_path_c(j,:) ) &
d2487 2
a2488 2
            alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                         & beta_path_c(j,:) )
d2497 1
a2497 1
        else if ( .not. FwdModelConf%polarized ) then
d2500 2
a2501 2
          call path_contrib ( incoptdepth, e_rflty, &
                & fwdModelConf%tolerance, do_gl )
d2505 2
a2506 2
          call get_beta_path_polarized ( frq, h, sps%beta_group, gl_slabs, &
            & c_inds, beta_path_polarized, dBeta_dT_polarized_path_c )
d2514 4
a2517 3
            alpha_path_polarized(-1:1,j) = matmul( beta_path_polarized(-1:1,j,:), &
              & sps_path(c_inds(j),:) ) * tanh1_c(j) + &
              & 0.25 * alpha_path_c(j)
d2574 3
a2576 2
            & sps%beta_group, FwdModelConf%polarized, gl_slabs, gl_inds(:ngl), &
            & beta_path_f(:ngl,:), t_der_path_flags, dTanh_dT_f,               &
d2581 2
a2582 2
            alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                  & beta_path_f(j,:) )
d2607 1
a2607 1
          call get_beta_path_polarized ( frq, h, sps%beta_group, &
d2617 4
a2620 2
            alpha_path_polarized_f(-1:1,j) = matmul( beta_path_polarized_f(-1:1,j,:), &
              & sps_path(gl_inds(j),:) ) * tanh1_f(j) + 0.25 * alpha_path_f(j)
d2658 2
a2659 1
            &  t_script, tau, i_stop, d_delta_df(1:npc,:), k_atmos_frq(frq_i,:) )
d2680 1
a2680 1
              k_atmos_frq(frq_i,:) = real(d_rad_pol_df(1,1,:))
d2682 1
a2682 1
              k_atmos_frq(frq_i,:) = real(d_rad_pol_df(2,2,:))
d2727 1
a2727 1
            do j = 1, no_mol
d2783 2
a2784 1
          if ( pfa_or_not_pol ) then
d2797 1
a2797 1
            k_spect_dw_frq(frq_i,1:1:f_len_dw) = drad_dw(1:1:f_len_dw)
d2825 1
a2825 1
            k_spect_dv_frq(frq_i,1:1:f_len_dv) = drad_dv(1:1:f_len_dv)
d3087 3
@


2.212
log
@Inching toward PFA
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.211 2004/06/10 00:59:56 vsnyder Exp $"
d3050 1
a3050 1
      &  tan_phi(j+1:no_tan_hts), METHOD = 'L' )
d3052 1
a3052 1
       & est_scgeocalt(j+1:no_tan_hts), METHOD='L' )
d3066 3
@


2.211
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.210 2004/05/27 23:23:50 pwagner Exp $"
a32 1
    use CS_Expmat_m, only: CS_Expmat
a34 1
    use DO_T_SCRIPT_M, ONLY: TWO_D_T_SCRIPT
d42 1
a42 1
    use ForwardModelVectorTools, only: GetQuantityForForwardModel, QtyStuff_T
a44 2
    use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, &
      & Get_Beta_Path_Polarized
d47 1
a47 3
    use Get_d_Deltau_pol_m, only: Get_d_Deltau_pol_df, Get_d_Deltau_pol_dT
    use Get_Species_Data_M, only: Beta_Group_T, Get_Species_Data, &
      Destroy_Species_Data, Destroy_Beta_Group
a60 1
    use Mcrt_m, only: Mcrt_der
a68 1
                       & L_Extinction, & ! Used in include dump_print_code.f9h
a70 1
    use Opacity_m, only: Opacity
d72 1
a72 1
    use Path_Contrib_M, only: Get_GL_Inds, Path_Contrib
a74 2
    use RAD_TRAN_M, only: RAD_TRAN, RAD_TRAN_POL, DRAD_TRAN_DF, DRAD_TRAN_DT, &
      & DRAD_TRAN_DX
a75 2
    use ScatSourceFunc, only: T_SCAT,  Interp_Tscat,  Convert_Grid
    use SpectroscopyCatalog_m, only: CATALOG_T
d77 1
a77 1
    use String_table, only: GET_STRING ! Used in include dump_print_code.f9h
a106 1
    integer :: CHANIND                  ! A 1 based channel index
a107 1
    integer :: DIRECTION                ! Direction of channel numbering
a111 1
    integer :: FRQ_I                    ! Frequency loop index
a114 1
    integer :: INSTANCE                 ! Loop counter
a115 1
    integer :: I_STOP                   ! Upper index for radiance comp.
a117 2
    integer :: L                        ! Loop index and other uses ..
    integer :: M                        ! Loop index and other uses ..
a121 1
    integer :: MAXNOPTGFREQS            ! Used for sizing arrays
a127 1
    integer :: MINSUPERSET              ! Min. value of superset > 0
d129 1
a130 1
    integer :: NGLMAX                   ! NGL if all panels need GL
d134 1
a135 1
    integer :: NOSPECIES                ! No. of molecules under consideration
d137 1
a138 1
    integer :: NOUSEDCHANNELS           ! How many channels are we considering
a140 1
    integer :: P_Stop                   ! Where to stop in polarized case
d142 1
a142 1
    integer :: SHAPEIND                 ! Index into filter shapes
a143 3
    integer :: SPECIE                   ! Loop counter
    integer :: SUPERSET                 ! Output from AreSignalsSuperset
    integer :: SURFACE                  ! Loop counter
a148 1
    integer :: WHICHPATTERN             ! Index of antenna pattern
d153 5
a157 5
    integer :: noSurf                   ! Number of pressure levels
    integer :: novmrSurf                ! Number of vmr levels
    integer :: nspec                    ! No of species for cloud model
    integer :: ispec                    ! Species index in cloud model
    integer, dimension(:), pointer :: closestInstances
d162 2
a164 1
    logical :: Update                   ! Just update radiances etc.
d170 1
a170 1
    logical :: dummy(2) = (/.FALSE.,.FALSE./)  ! dummy Flag array
d208 2
a209 2
    LOGICAL, DIMENSION(:), pointer :: true_path_flags ! array of trues
    LOGICAL, DIMENSION(:), pointer :: t_der_path_flags! a flag that tells the
a216 2
    real(r8) :: FRQ           ! Frequency
    real(r8) :: FRQHK         ! 0.5 * Frq * H_Over_K
d219 1
a219 1
    real(rp) :: R,R1,R2       ! real variables for various uses
a221 2
    real(rp) :: THISFRACTION     ! A sideband fraction
    real(rp) :: THISELEV      ! An elevation offset
d229 1
a392 2
    type (qtyStuff_t), pointer :: Qtys(:)      ! Array of pointers to Qty's.

a399 1
    type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset
a408 1
    type (VectorValue_T), pointer :: SIDEBANDFRACTION ! The sideband fraction to use
a418 2
    type (catalog_T), dimension(:,:), pointer :: MY_CATALOG ! ***

a450 1
    integer, dimension(:), pointer :: mol_cat_index
d452 1
a452 1
    type (beta_group_T), dimension(:), pointer :: beta_group
d485 2
a486 2
      & beta_path_polarized_f, cext_path, &
      & cg_inds, c_inds, cld_ext%values, closestInstances, d2x_dxdt, &
d513 4
a516 4
      & k_spect_dw_frq, k_temp, k_temp_frq, mag_path, mol_cat_index, n_path, &
      & path_dsdh, phi_path, p_path, p_path_c, prod_pol, ptg_angles, &
      & radiances, RadV, ref_corr, req_out, salb_path, scat_alb%values, &
      & scat_ang, scat_src%values, &
d531 2
a532 1
      ! are all for same radiometer, module and sideband
d537 2
a538 16
      & noSpecies, no_mol, beta_group, my_catalog )

    call allocate_test ( mol_cat_index, no_mol, 'mol_cat_index', moduleName )

    mol_cat_index = PACK((/(i,i=1,noSpecies)/), fwdModelConf%molecules > 0)

    allocate ( qtys(no_mol), stat = ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'QTYS' )

    ! Get state vector quantities for species
    do sps_i = 1 , no_mol
      qtys(sps_i)%qty => GetQuantityForForwardModel(fwdmodelin, fwdmodelextra, &
        &  quantitytype=l_vmr, molIndex=mol_cat_index(sps_i), config=fwdModelConf, &
        &  radiometer=firstsignal%radiometer, foundInFirst=qtys(sps_i)%foundInFirst )
    end do
d542 2
a543 1
    ! Identify the appropriate state vector components, save vmrs for later
d628 1
a628 2
        & signal=fwdModelConf%signals(sigInd)%index, &
        & sideband=merge ( 0, firstSignal%sideband, fwdModelConf%forceFoldedOutput ) )
d634 2
a635 2
      maxNoFFreqs = max(maxNoFFreqs, qtys(sps_i)%qty%template%noChans)
      maxNoFSurfs = max(maxNoFSurfs, qtys(sps_i)%qty%template%noSurfs)
d705 3
a707 3
    call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
      & firstSignal%radiometer, mol_cat_index, l_vmr, &
      & grids_f, h2o_ind, ext_ind )
d709 6
a714 6
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
        & firstSignal%radiometer, mol_cat_index, l_dn, grids_dn )
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
        & firstSignal%radiometer, mol_cat_index, l_dv, grids_dv )
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
        & firstSignal%radiometer, mol_cat_index, l_dw, grids_dw )
d764 1
d775 1
a775 1
    call compute_GL_grid ( fwdModelConf, temp, qtys, nlvl, maxVert, &
d800 1
a800 2
                          & scgeocalt, tan_press, &
                          & tan_phi, est_scgeocalt )
d807 1
a807 1
    ! geodetic locations of the temperature phi basis--not necessarily
d831 1
d837 1
a837 1
       & (/req_out(1)/), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh,  &
d867 1
a867 2
    call allocate_test ( w0_path_c,           npc, 'w0_path_c',        moduleName )
    call allocate_test ( tt_path_c,           npc, 'tt_path_c',        moduleName )
a868 1
    call allocate_test ( cg_inds,             npc, 'cg_inds',          moduleName )
d871 1
a872 1
    call allocate_test ( dhdz_gw_path,    max_ele, 'dhdz_gw_path',     moduleName )
d894 2
d1151 1
a1151 1
      call allocateSlabs ( gl_slabs, max_ele, my_catalog(thisSideband,:), &
d1154 1
a1154 103
      ! Work out which pointing frequency grid we're going to need if ----------
      ! frequency averaging

      ! Code splits into two sections, one for when we're doing frequency
      ! averaging, and one when we're not.
      if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---

        whichPointingGrid = -1
        minSuperset = huge(0)
        do i = 1, size(pointingGrids)
          superset = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals, sideband=thisSideband )
          if ( superset >= 0 .and. superset <= minSuperset ) then
            minSuperset = superset
            whichPointingGrid = i
          end if
        end do
        if ( whichPointingGrid < 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
               & "No matching pointing frequency grids." )

        ! Now we've identified the pointing grids.  Locate the tangent grid
        ! within it.
        call allocate_test ( grids, no_tan_hts, "Grids", moduleName )
        call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
                 &  tan_press, grids, allowTopValue=.TRUE., nearest=.TRUE. )
        ! Work out the maximum number of frequencies
        maxNoPtgFreqs = 0
        do ptg_i = 1, no_tan_hts
          k = Size(pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))% &
                 & frequencies)
          maxNoPtgFreqs = max ( maxNoPtgFreqs, k )
        end do

        min_ch_freq_grid =  huge(min_ch_freq_grid)
        max_ch_freq_grid = -huge(min_ch_freq_grid)
        do i = 1, noUsedChannels
          sigInd = channels(i)%signal
          channel = channels(i)%used
          shapeInd = MatchSignal ( filterShapes%signal, &
            & fwdModelConf%signals(sigInd), sideband = thisSideband, &
            & channel=channel )
          if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                               & "No matching channel shape information" )
          k = Size(FilterShapes(shapeInd)%FilterGrid(:))
          r1 = FilterShapes(shapeInd)%FilterGrid(1)
          r2 = FilterShapes(shapeInd)%FilterGrid(k)
          min_ch_freq_grid = MIN(r1, r2, min_ch_freq_grid)
          max_ch_freq_grid = MAX(r1, r2, max_ch_freq_grid)
        end do

      else ! ------------------------- Not frequency averaging ---------

        call allocate_test ( frequencies, noUsedChannels, "frequencies", &
                           & moduleName )
        do channel = 1, noUsedchannels
          direction = fwdModelConf%signals(channels(channel)%signal)%direction
          frequencies(channel) = &
            & fwdModelConf%signals(channels(channel)%signal)%centerFrequency + &
            & direction * fwdModelConf%signals(channels(channel)%signal)% &
            & frequencies(channels(channel)%used)
        end do
        select case ( thisSideband )
        case ( -1 )
          frequencies = firstSignal%lo - frequencies
        case ( +1 )
          frequencies = firstSignal%lo + frequencies
        case ( 0 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Folded signal requested in forward model' )
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Bad value of signal%sideband' )
        end select
        noFreqs = noUsedChannels
        maxNoPtgFreqs = noUsedChannels
      end if

      call allocate_test ( RadV, maxNoPtgFreqs, 'RadV', moduleName )

      if ( temp_der) &
        & call allocate_test ( k_temp_frq, maxNoPtgFreqs, sv_t_len, 'k_temp_frq', &
                             & moduleName )

      if ( atmos_der ) &
        & call allocate_test ( k_atmos_frq, maxNoPtgFreqs, size(grids_f%values), 'k_atmos_frq',&
                             & moduleName )

      if ( spect_der ) then
        call allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_dw, &
                           & 'k_spect_dw_frq', moduleName )
        call allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_dn, &
                           & 'k_spect_dn_frq', moduleName )
        call allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_dv, &
                           & 'k_spect_dv_frq', moduleName )
      end if

      if ( any_der ) &
        & call allocate_test ( DACsStaging2, ubound(DACsStaging,1), &
                             &               max(sv_t_len,size(grids_f%values), &
                                             &   f_len_dw, f_len_dn, f_len_dv), &
                             &               noUsedDACs, &
                             & 'DACsStaging2', moduleName, &
                             & low1=lbound(DACsStaging,1) )
d1212 3
a1214 3
              &  NEG_H_TAN = (/neg_tan_ht/), DHTDTL0 = tan_dh_dt,            &
              &  DDHIDHIDTL0 = ddhidhidtl0, DDHTDHTDTL0 = tan_d2h_dhdt,      &
              &  DHIDTLM = dh_dt_glgrid,                                     &
d1307 3
a1309 3
       ! Now compute sps_path with a FAKE frequency, mainly to get the
       ! WATER (H2O) contribution for refraction calculations, but also
       ! to compute sps_path for all those with no frequency component
d1311 1
a1311 1
        Frq = 0.0
d1313 1
a1313 1
          & Frq, eta_zp(1:no_ele,:), &
d1331 1
a1331 1
          Frq = 0.0
d1333 2
a1334 2
            & Frq, eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), iwc_path(1:no_ele,:),      &
a1426 3
        ! Work out what frequencies we're using for --------------------------
        ! frequency averaging case for this pointing

d1430 2
a1431 20
        if ( FwdModelConf%do_freq_avg ) then
          j = -1
          k = SIZE(PointingGrids(whichPointingGrid)% &
                       & oneGrid(grids(ptg_i))%frequencies)
          call Hunt ( min_ch_freq_grid, vel_cor &
                       & * PointingGrids(whichPointingGrid)% &
                       & oneGrid(grids(ptg_i))%frequencies, k, j, frq_i )
          call Hunt ( max_ch_freq_grid,vel_cor &
                       & * PointingGrids(whichPointingGrid)% &
                       & oneGrid(grids(ptg_i))%frequencies, k, frq_i, m )
          noFreqs = m - j + 1
          call allocate_test ( frequencies, noFreqs, "frequencies", moduleName )
          frequencies = PointingGrids(whichPointingGrid)% &
                      & oneGrid(grids(ptg_i))%frequencies(j:m)

          ! VELOCITY shift correction to frequency grid

          frequencies =  Vel_Cor * frequencies

        end if
d1436 20
a1455 1
        ! Loop over frequencies ----------------------------------------------
d1457 3
a1459 2
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.FrequencyLoop' )
d1461 2
a1462 1
        do frq_i = 1, noFreqs
d1464 2
a1465 2
          if ( toggle(emit) .and. levels(emit) > 5 ) &
            & call Trace_Begin ('ForwardModel.Frequency ',index=frq_i)
d1467 2
a1468 2
          Frq = frequencies(frq_i)
          frqhk = 0.5_r8 * frq * h_over_k ! h nu / 2 k T
d1470 1
a1470 1
          ! Set up path quantities --------------------------------------
d1472 1
a1472 5
          tanh1_c(1:npc) = tanh( frqhk / t_path_c(1:npc) )
          ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
          if ( temp_der ) &
            & dTanh_dT_c(1:npc) = frqhk / t_path_c(1:npc)**2 * &
              & ( tanh1_c(1:npc) - 1.0_rp / tanh1_c(1:npc) )
d1474 2
a1475 12
          ! Compute the sps_path for this Frequency
          call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
            & Frq, eta_zp(1:no_ele,:),                            &
            & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),       &
            & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )

          call get_beta_path ( Frq,                               &
            &  p_path(1:no_ele), t_path_c(1:npc), tanh1_c(1:npc), &
            &  beta_group, FwdModelConf%polarized,                &
            &  gl_slabs, c_inds(1:npc), beta_path_c(1:npc,:),     &
            &  t_der_path_flags, dTanh_dT_c, dbeta_dT_path_c,     &
            &  dbeta_dw_path_c, dbeta_dn_path_c, dbeta_dv_path_c )
d1477 4
a1480 1
         do_gl = .false.
d1482 2
a1483 112
         if ( FwdModelConf%incl_cld ) then
!          if ( do_cld ) then !JJ
            ! Compute Scattering source function based on temp prof at all
            ! angles U for each temperature layer assuming a plane parallel
            ! atmosphere.

            if (ptg_i .eq. 1) then      

              call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst),    & 
                 & 10.0**(-temp%template%surfs), vmrArray, nspec,            &
                 & fwdModelConf%num_scattering_angles,                       &
                 & fwdModelConf%num_azimuth_angles,                          &
                 & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,    &
                 & fwdModelConf%no_cloud_species,                            &
                 & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang)

            endif

            scat_src%template = temp%template

            call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, &
              & fwdModelConf, .false., .true. )

            call allocate_test ( do_calc_tscat, no_ele, size(grids_tscat%values),           &
                               & 'do_calc_tscat', moduleName )
            call allocate_test ( do_calc_tscat_zp, no_ele, grids_tscat%p_len,               &
                               & 'do_calc_tscat_zp', moduleName )
            call allocate_test ( eta_tscat,     no_ele, size(grids_tscat%values),           &
                               & 'eta_tscat',     moduleName )
            call allocate_test ( eta_tscat_zp,  no_ele, grids_tscat%p_len,                  &
                               & 'eta_tscat_zp',  moduleName )
            call allocate_test ( tscat_path,    no_ele, fwdModelConf%num_scattering_angles, &
                                 & 'tscat_path',  moduleName )

            call comp_eta_docalc_no_frq ( Grids_Tscat, z_path(1:no_ele), &
              &  phi_path(1:no_ele), eta_tscat_zp(1:no_ele,:), &
              &  do_calc_tscat_zp(1:no_ele,:) )

            Frq=0.0
            call comp_sps_path_frq ( Grids_tscat, firstSignal%lo, thisSideband, &
              & Frq, eta_tscat_zp(1:no_ele,:), &
              & do_calc_tscat_zp(1:no_ele,:), tscat_path(1:no_ele,:),      &
              & do_calc_tscat(1:no_ele,:), eta_tscat(1:no_ele,:) )

            call allocate_test ( tt_path, no_ele, 1, 'tt_path', moduleName )

            ! project Tscat onto LOS
            call interp_tscat ( tscat_path(1:no_ele,:), Scat_ang(:), phi_path(1:no_ele), tt_path )

            if ( .not. cld_fine ) then                 ! interpolate onto gl grids along the LOS

              scat_alb%template = temp%template
              cld_ext%template  = temp%template
                            
              call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false.)
              call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false.)             

              do i=1, size(grids_salb%values)
                 if ( abs(grids_salb%values(i)) < TOL) then
                         grids_salb%values(i) = 0.0
                 end if
                 if ( abs(grids_cext%values(i)) < TOL) then
                         grids_cext%values(i) = 0.0
                 end if
              enddo

              call allocate_test (do_calc_salb, no_ele, size(grids_salb%values),'do_calc_salb',moduleName)
              call allocate_test (do_calc_salb_zp, no_ele, grids_salb%p_len,               &
                                 & 'do_calc_salb_zp', moduleName )
              call allocate_test (eta_salb,    no_ele, size(grids_salb%values), 'eta_salb', moduleName)
              call allocate_test (eta_salb_zp, no_ele, grids_salb%p_len, 'eta_salb_zp', moduleName)
              call allocate_test ( salb_path,  no_ele, 1, 'salb_path', moduleName )

              call allocate_test (do_calc_cext,no_ele,size(grids_cext%values),'do_calc_cext',moduleName)
              call allocate_test (do_calc_cext_zp, no_ele, grids_cext%p_len,               &
                                 & 'do_calc_cext_zp', moduleName )
              call allocate_test (eta_cext,    no_ele, size(grids_cext%values), 'eta_cext', moduleName)
              call allocate_test (eta_cext_zp, no_ele, grids_cext%p_len,  'eta_cext_zp', moduleName)
              call allocate_test (cext_path,   no_ele, 1, 'cext_path', moduleName)

              call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:no_ele), &
                &  phi_path(1:no_ele), eta_salb_zp(1:no_ele,:), &
                &  do_calc_salb_zp(1:no_ele,:) )

              Frq=0.0
              call comp_sps_path_frq ( Grids_salb, firstSignal%lo, thisSideband, &
                & Frq, eta_salb_zp(1:no_ele,:), &
                & do_calc_salb_zp(1:no_ele,:), salb_path(1:no_ele,:),          &
                & do_calc_salb(1:no_ele,:), eta_salb(1:no_ele,:) )

              call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:no_ele), &
                &  phi_path(1:no_ele), eta_cext_zp(1:no_ele,:), &
                &  do_calc_cext_zp(1:no_ele,:) )

              Frq=0.0
              call comp_sps_path_frq ( Grids_cext, firstSignal%lo, thisSideband, &
                & Frq, eta_cext_zp(1:no_ele,:), &
                & do_calc_cext_zp(1:no_ele,:), cext_path(1:no_ele,:),      &
                & do_calc_cext(1:no_ele,:), eta_cext(1:no_ele,:) )
              
              call convert_grid ( salb_path(1:no_ele,:), cext_path(1:no_ele,:),   &
                                & tt_path(1:no_ele,:), c_inds(1:npc),             &
                                & beta_path_cloud_c(1:npc), w0_path_c(1:npc),     &
                                & tt_path_c(1:npc) )

            else                           ! re-compute cext and w0 along the LOS

              call get_beta_path_cloud ( Frq,                               &
                &  p_path(1:no_ele), t_path(1:no_ele), tt_path(1:no_ele,:), &
                &  beta_group, c_inds(1:npc), beta_path_cloud_c(1:npc),     &
                &  w0_path_c(1:npc),  tt_path_c(1:npc),      &
                &  IPSD(1:no_ele),  WC(:,1:no_ele), fwdModelConf )
d1485 5
a1489 25
            end if
            
            call deallocate_test ( do_calc_tscat,    'do_calc_tscat',    moduleName )
            call deallocate_test ( do_calc_tscat_zp, 'do_calc_tscat_zp', moduleName )
            call deallocate_test ( eta_tscat,        'eta_tscat',        moduleName )
            call deallocate_test ( eta_tscat_zp,     'eta_tscat_zp',     moduleName )           
            call deallocate_test ( tscat_path,       'tscat_path',       moduleName )
            call deallocate_test ( tt_path,          'tt_path',          moduleName )

            call deallocate_test ( do_calc_salb,     'do_calc_salb',     moduleName )
            call deallocate_test ( do_calc_salb_zp,  'do_calc_salb_zp',  moduleName )
            call deallocate_test ( eta_salb,         'eta_salb',         moduleName )
            call deallocate_test ( eta_salb_zp,      'eta_salb_zp',      moduleName )
            call deallocate_test ( salb_path,        'salb_path',        moduleName )

            call deallocate_test ( do_calc_cext,     'do_calc_salb',     moduleName )
            call deallocate_test ( do_calc_cext_zp,  'do_calc_salb_zp',  moduleName )
            call deallocate_test ( eta_cext,         'eta_cext',         moduleName )
            call deallocate_test ( eta_cext_zp,      'eta_cext_zp',      moduleName )
            call deallocate_test ( cext_path,        'cext_path',        moduleName )

            do j = 1, npc
              alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                    & beta_path_c(j,:) ) + &
                                    & beta_path_cloud_c(j)
d1491 2
a1492 2
              incoptdepth(j) = alpha_path_c(j) * del_s(j)
            end do
d1494 2
a1495 1
         else ! Not cloud model
d1497 1
a1497 7
            do j = 1, npc ! Don't trust compilers to fuse loops
              alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                           & beta_path_c(j,:) )
              incoptdepth(j) = alpha_path_c(j) * del_s(j)
              tt_path_c(j) =0.0
              w0_path_c(j) =0.0
            end do
d1499 2
a1500 1
         end if ! end of check cld 
d1502 1
a1502 2
            if ( .not. FwdModelConf%polarized ) then
              ! Determine where to use Gauss-Legendre for scalar instead of a trapezoid.
d1504 1
a1504 2
              call path_contrib ( incoptdepth(1:npc), e_rflty, &
                    & fwdModelConf%tolerance, do_gl(1:npc) )
d1506 1
a1506 18
            else ! extra stuff for polarized case

              call get_beta_path_polarized ( frq, h, beta_group, &
                & gl_slabs, c_inds(1:npc), beta_path_polarized,  &
                & dBeta_dT_polarized_path_c )

              ! We put an explicit extent of -1:1 for the first dimension in
              ! the hope a clever compiler will do better optimization with
              ! a constant extent.
              ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
              ! to alpha here
              do j = 1, npc
                alpha_path_polarized(-1:1,j) = matmul( beta_path_polarized(-1:1,j,:), &
                  & sps_path(c_inds(j),:) ) * tanh1_c(j) + &
                  & 0.25 * alpha_path_c(j)
                alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
                  & 0.25 * alpha_path_c(j)
              end do
d1508 1
a1508 17
              ! Turn sigma-, pi, sigma+ into 2X2 matrix incoptdepth_pol
              call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
                & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )

              ! We don't add unpolarized incremental optical depth to diagonal
              ! of polarized incremental optical depth because we added the
              ! scalar alpha_path to the sigma-, pi and sigma+ parts of
              ! alpha_path_polarized above.  If we did add it here, we would
              ! need 0.5 factors to scale unpolarized "power absorption" to
              ! get "field absorption"

              ! Do not trust the compiler to fuse loops
              do j = 1, npc
                incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j)
                incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j) * del_s(j)
                incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j) * del_s(j)
                incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j)
d1510 4
a1513 3
                ! deltau_pol = exp(incoptdepth_pol)
                call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
              end do
d1515 6
a1520 3
              ! Determine where to do GL
              call path_contrib ( deltau_pol(:,:,1:npc), e_rflty, &
                 & fwdModelConf%tolerance, do_gl(1:npc) )
d1522 6
a1527 1
            end if
d1529 3
a1531 7
          ! Where we don't do GL, replace the rectangle rule by the
          ! trapezoid rule.
          do j = 1, npc - 1
            if ( .not. do_gl(j) ) &
              & incoptdepth(j) = &
                & 0.5 * ( alpha_path_c(j) + alpha_path_c(j+1) ) * del_s(j)
          end do
d1533 11
a1543 2
          call get_GL_inds ( do_gl(1:npc), gl_inds, cg_inds, ngl, ncg )
          ! ngl is ng * count(do_gl)
d1545 1
a1545 6
          t_path_f(:ngl) = t_path(gl_inds(:ngl))
          tanh1_f(1:ngl) = tanh( frqhk / t_path_f(:ngl) )
          ! dTanh_dT = -h nu / (2 k T**2) 1/tanh1 d(tanh1)/dT
          if ( temp_der ) &
            & dTanh_dT_f(1:ngl) = frqhk / t_path_f(1:ngl)**2 * &
              & ( tanh1_f(1:ngl) - 1.0_rp / tanh1_f(1:ngl) )
d1547 1
a1547 4
          ! The derivatives that get_beta_path computes depend on which
          ! derivative arrays are allocated, not which ones are present.
          ! This avoids having four paths through the code, each with a
          ! different set of optional arguments.
d1549 1
a1549 6
          call get_beta_path ( Frq,                                   &
            & p_path(1:no_ele), t_path_f(:ngl), tanh1_f(1:ngl),       &
            & beta_group, FwdModelConf%polarized,                     &
            & gl_slabs, gl_inds(:ngl), beta_path_f(:ngl,:),           &
            & t_der_path_flags, dTanh_dT_f, dbeta_dT_path_f,          &
            & dbeta_dw_path_f, dbeta_dn_path_f, dbeta_dv_path_f )
d1551 1
a1551 5
          do j = 1, ngl ! loop around dot_product instead of doing sum(a*b,2)
                        ! to avoid path-length array temps
            alpha_path_f(j) = dot_product( sps_path(gl_inds(j),:),  &
                                  & beta_path_f(j,:) )
          end do
d1553 3
a1555 38
          ! Needed by both rad_tran and rad_tran_pol
          call two_d_t_script ( t_path_c(1:npc), tt_path_c(1:npc),  &  
            & w0_path_c(1:npc), spaceRadiance%values(1,1), frq,     &
            & t_script(1:npc) )

          if ( .not. FwdModelConf%polarized ) then


          ! Compute SCALAR radiative transfer ---------------------------------------

          ! Compute radiative transfer ---------------------------------------

              call rad_tran ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty,     &
                & del_zeta(1:npc), alpha_path_c(1:npc), ref_corr(1:npc),   &
                & incoptdepth(1:npc), alpha_path_f(1:ngl), dsdz_gw_path,   &
                & t_script(1:npc), tau(1:npc), RadV(frq_i), i_stop )

          else ! Polarized model

            i_stop = npc ! needed by drad_tran_df

            ! Get the corrections to integrals for layers that need GL for
            ! the polarized species.
            call get_beta_path_polarized ( frq, h, beta_group,   &
              & gl_slabs, gl_inds(:ngl), beta_path_polarized_f,  &
              & dBeta_dT_polarized_path_f )

            ! We put an explicit extent of -1:1 for the first dimension in
            ! the hope a clever compiler will do better optimization with
            ! a constant extent.
            ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
            ! to alpha here.
            do j = 1, ngl
              alpha_path_polarized_f(-1:1,j) = matmul( beta_path_polarized_f(-1:1,j,:), &
                & sps_path(gl_inds(j),:) ) * tanh1_f(j) + 0.25 * alpha_path_f(j)
              alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) + &
                & 0.25 * alpha_path_f(j)
            end do
d1557 1
a1557 18
            call rad_tran_pol ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty,   &
              & del_zeta(1:npc), alpha_path_polarized(:,1:npc),            &
              & ref_corr(1:npc), incoptdepth_pol(:,:,1:npc),               &
              & deltau_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl),    &
              & dsdz_gw_path, ct, stcp, stsp, t_script(1:npc),             &
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), rad_pol, p_stop )

            if ( p_stop < 0 ) then ! exp(incoptdepth_pol(:,:,-p_stop)) failed
              call output ( 'Exp(incoptdepth_pol(:,:,' )
              call output ( -p_stop )
              call output ( ') failed.  Value is', advance='yes' )
              call dump ( incoptdepth_pol(:,:,-p_stop), clean=.true. )
              call output ( 'thisSideband = ' ); call output ( thisSideband )
              call output ( ', ptg_i = ' ); call output ( ptg_i )
              call output ( ', frq_i = ' ); call output ( frq_i, advance='true' )
              call MLSMessage ( MLSMSG_Error, moduleName, &
                & 'exp(incoptdepth_pol) failed' )
            end if
d1559 1
a1559 5
            if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
              RadV(frq_i) = real(rad_pol(1,1))
            else
              RadV(frq_i) = real(rad_pol(2,2))
            end if
d1561 2
a1562 1
          end if
d1564 5
a1568 1
          ! Compute derivatives if needed ----------------------------------
d1570 5
a1574 1
          if ( atmos_der ) then
d1576 4
a1579 30
            call drad_tran_df ( c_inds(1:npc), gl_inds(1:ngl), del_zeta,       &
              &  Grids_f, beta_path_c(1:npc,:), eta_fzp, sps_path,             &
              &  do_calc_fzp(1:no_ele,:), beta_path_f, do_gl(1:npc),           &
              &  del_s(1:npc), ref_corr(1:npc), dsdz_gw_path, t_script(1:npc), &
              &  tau(1:npc), i_stop, d_delta_df(1:npc,:), k_atmos_frq(frq_i,:) )

            if ( FwdModelConf%polarized ) then

              ! VMR derivatives for polarized radiance.
              ! Compute DE / Df from D Incoptdepth_pol / Df and put
              ! into DE_DF.
              call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop),   &
                &  del_zeta, Grids_f, beta_path_polarized(:,1:p_stop,:),     &
                &  eta_fzp, do_calc_fzp(1:no_ele,:), sps_path, del_s(1:npc), &
                &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),        &
                &  d_delta_df(1:npc,:), de_df(:,:,1:p_stop,:) )

              ! Compute D radiance / Df from Tau, Prod, T_Script
              ! and DE / Df.

              call mcrt_der ( t_script(1:npc), sqrt(e_rflty),      &
                & deltau_pol(:,:,1:npc), de_df(:,:,1:npc,:),       &
                & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop, &
                & d_rad_pol_df )

              if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
                k_atmos_frq(frq_i,:) = real(d_rad_pol_df(1,1,:))
              else
                k_atmos_frq(frq_i,:) = real(d_rad_pol_df(2,2,:))
              end if
d1581 8
a1588 1
            end if
d1590 32
a1621 1
          end if
d1623 14
a1636 1
          if ( temp_der ) then
d1638 3
a1640 56
            ! get d Delta B / d T * d T / eta
            call dt_script_dt ( t_path_c(1:npc), eta_zxp_t_c(1:npc,:), frq, &
                              & d_t_scr_dt(1:npc,:) )

            dh_dt_path_f(:ngl,:) = dh_dt_path(gl_inds(:ngl),:)
            do_calc_t_f(:ngl,:) = do_calc_t(gl_inds(:ngl),:)
            eta_zxp_t_f(:ngl,:) = eta_zxp_t(gl_inds(:ngl),:)
            h_path_f(:ngl) = h_path(gl_inds(:ngl))
            dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds(1:npc),:) *  &
                                          dBeta_dT_path_c(1:npc,:),dim=2 )
            dAlpha_dT_path_f(:ngl) = sum( sps_path(gl_inds(1:ngl),:) * &
                                          dBeta_dT_path_f(1:ngl,:),dim=2 )

            if ( .not. FwdModelConf%polarized ) then

              call drad_tran_dt ( del_zeta(1:npc ), h_path_c(1:npc),          &
                & dh_dt_path_c(1:npc,:),alpha_path_c(1:npc),                  &
                & dAlpha_dT_path_c(:npc), eta_zxp_t_c(1:npc,:),               &
                & do_calc_t_c(1:npc,:), do_calc_hyd_c(1:npc,:), del_s(1:npc), &
                & ref_corr(1:npc), Req + one_tan_ht(1), dh_dt_path(brkpt,:),  &
                & do_gl(1:npc), gl_inds(1:ngl), h_path_f(:ngl),               &
                & t_path_f(:ngl), dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),  &
                & dAlpha_dT_path_f(:ngl), eta_zxp_t_f(:ngl,:),                &
                & do_calc_t_f(:ngl,:), path_dsdh, dhdz_gw_path, dsdz_gw_path, &
                & t_script(1:npc), d_t_scr_dt(1:npc,:), tau(1:npc), i_stop,   &
                & grids_tmp%deriv_flags, drad_dt )
              k_temp_frq(frq_i,:) = drad_dt

            else ! FwdModelConf%polarized

              ! Temperature derivatives for polarized radiance
              ! Compute DE / DT from D Incoptdepth_Pol / DT and put
              ! into DE_DT.

              dAlpha_dT_polarized_path_c(:,1:npc) = 0.0
              dAlpha_dT_polarized_path_f(:,1:ngl) = 0.0
              do j = 1, no_mol
                do l = -1, 1
                  dAlpha_dT_polarized_path_c(l,1:npc) = &
                & dAlpha_dT_polarized_path_c(l,1:npc) + &
                    & sps_path(c_inds(1:npc),j) *       &
                    & dBeta_dT_polarized_path_c(l,1:npc,j)
                  dAlpha_dT_polarized_path_f(l,1:ngl) = &
                & dAlpha_dT_polarized_path_f(l,1:ngl) + &
                    & sps_path(gl_inds(1:ngl),j) *      &
                    & dBeta_dT_polarized_path_f(l,1:ngl,j)
                end do ! l
              end do ! j
              do l = -1, 1
                dAlpha_dT_polarized_path_c(l,1:npc) = &
                  & dAlpha_dT_polarized_path_c(l,1:npc) * tanh1_c(:npc) + &
                  & alpha_path_polarized(l,:npc) * dTanh_dT_c(:npc)
                dAlpha_dT_polarized_path_f(l,1:ngl) = &
                  & dAlpha_dT_polarized_path_f(l,1:ngl) * tanh1_f(:ngl) + &
                  & alpha_path_polarized_f(l,:ngl) * dTanh_dT_f(:ngl)
              end do
d1642 3
a1644 28
              call get_d_deltau_pol_dT ( ct, stcp, stsp, t_path_f(:ngl),      &
                & alpha_path_polarized(:,1:p_stop),                           &
                & alpha_path_polarized_f(:,1:ngl),                            &
                & dAlpha_dT_path_c(:npc), dAlpha_dT_path_f(:ngl),             &
                & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f,     &
                & eta_zxp_t_c(1:p_stop,:), eta_zxp_t_f(:ngl,:), del_s(1:npc), &
                & gl_inds(:ngl), del_zeta(1:npc), do_calc_t_c(1:p_stop,:),    &
                & do_calc_t_f(:ngl,:), do_gl(1:p_stop), path_dsdh,            &
                & dhdz_gw_path, dsdz_gw_path, incoptdepth_pol(:,:,1:p_stop),  &
                & ref_corr(1:p_stop), h_path_c(1:npc), h_path_f(:ngl),        &
                & dh_dt_path_c(1:p_stop,:),dh_dt_path_f(:ngl,:),              &
                & Req + one_tan_ht(1), dh_dt_path(brkpt,:),                   &
                & do_calc_hyd_c(1:p_stop,:), grids_tmp%deriv_flags,           &
                & de_dt(:,:,1:p_stop,:) )

              ! Compute D radiance / DT from Tau, Prod, T_Script, D_T_Scr_dT
              ! and DE / DT.

              call mcrt_der ( t_script(1:npc), sqrt(e_rflty),            &
                & deltau_pol(:,:,1:npc), de_dt(:,:,1:npc,:),             &
                & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop,       &
                & d_rad_pol_dt, d_t_scr_dt(1:npc,:) )

              if ( radiometers(firstSignal%radiometer)%polarization == l_a ) then
                k_temp_frq(frq_i,:) = real(d_rad_pol_dt(1,1,:))
              else
                k_temp_frq(frq_i,:) = real(d_rad_pol_dt(2,2,:))
              end if
d1646 3
a1648 1
            end if
d1650 3
a1652 1
          end if
d1654 29
a1682 1
          if ( spect_der ) then
d1684 4
a1687 2
            if ( .not. FwdModelConf%polarized ) then
              ! Spectroscopic derivative  wrt: W
d1689 1
a1689 40
              do_calc_dw_f(:ngl,:) = do_calc_dw(gl_inds(:ngl),:)
              eta_zxp_dw_f(:ngl,:) = eta_zxp_dw(gl_inds(:ngl),:)
              call drad_tran_dx ( del_zeta(1:npc), Grids_dw,             &
                &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw_c(1:npc,:),      &
                &  sps_path(c_inds(1:npc),:), do_calc_dw_c(1:npc,:),     &
                &  dbeta_dw_path_f(:ngl,:), eta_zxp_dw_f(:ngl,:),        &
                &  sps_path(gl_inds(1:ngl),:), do_calc_dw_f(:ngl,:),     &
                &  do_gl(1:npc), gl_inds(:ngl), del_s(1:npc),            &
                &  ref_corr(1:npc), dhdz_gw_path,                        &
                &  t_script(1:npc), tau(1:npc), i_stop, drad_dw )

              k_spect_dw_frq(frq_i,1:1:f_len_dw) = drad_dw(1:1:f_len_dw)

              ! Spectroscopic derivative  wrt: N

              do_calc_dn_f(:ngl,:) = do_calc_dn(gl_inds(:ngl),:)
              eta_zxp_dn_f(:ngl,:) = eta_zxp_dn(gl_inds(:ngl),:)
              call drad_tran_dx ( del_zeta(1:npc), Grids_dn,             &
                &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn_c(1:npc,:),      &
                &  sps_path(c_inds(1:npc),:), do_calc_dn_c(1:npc,:),     &
                &  dbeta_dn_path_f(:ngl,:), eta_zxp_dn_f(:ngl,:),        &
                &  sps_path(gl_inds(1:ngl),:), do_calc_dn_f(:ngl,:),     &
                &  do_gl(1:npc), gl_inds(:ngl), del_s(1:npc),            &
                &  ref_corr(1:npc), dhdz_gw_path,                        &
                &  t_script(1:npc), tau(1:npc), i_stop, drad_dn )

              k_spect_dn_frq(frq_i,1:f_len_dn) = drad_dn(1:f_len_dn)

              ! Spectroscopic derivative  wrt: Nu0

              do_calc_dv_f(:ngl,:) = do_calc_dv(gl_inds(:ngl),:)
              eta_zxp_dv_f(:ngl,:) = eta_zxp_dv(gl_inds(:ngl),:)
              call drad_tran_dx ( del_zeta(1:npc), Grids_dv,             &
                &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv_c(1:npc,:),      &
                &  sps_path(c_inds(1:npc),:), do_calc_dv_c(1:npc,:),     &
                &  dbeta_dv_path_f(:ngl,:), eta_zxp_dv_f(:ngl,:),        &
                &  sps_path(gl_inds(1:ngl),:), do_calc_dv_f(:ngl,:),     &
                &  do_gl(1:npc), gl_inds(:ngl), del_s(1:npc),            &
                &  ref_corr(1:npc), dhdz_gw_path,                        &
                &  t_script(1:npc), tau(1:npc), i_stop, drad_dv )
d1691 6
a1696 2
              k_spect_dv_frq(frq_i,1:1:f_len_dv) = drad_dv(1:1:f_len_dv)
            end if
d1698 9
a1706 1
          end if
d1708 9
a1716 1
          ! End of frequency loop ----------------------------------------------
d1718 3
a1720 2
          if ( toggle(emit) .and. levels(emit) > 5 ) &
            & call Trace_End ('ForwardModel.Frequency ',index=frq_i)
d1722 9
a1730 1
        end do            ! End freq. loop
d1732 1
a1732 2
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_End ( 'ForwardModel.FrequencyLoop' )
d1734 57
a1790 1
        ! Work out which channel shape information we're going to need -------
d1792 4
a1795 1
        ! Frequency averaging if needed --------------------------------------
d1797 3
a1799 2
        ! Here we either frequency average to get the unconvolved radiances, or
        ! we just store what we have as we're using monochromatic channels
d1801 1
a1801 33
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call trace_begin ( 'ForwardModel.FrequencyAvg' )

        if ( fwdModelConf%do_freq_avg ) then
          ! Do DACs stuff for all DACs channels first
          do i = 1, noUsedDACS
            shapeInd = MatchSignal ( dacsFilterShapes%signal, &
              & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
            call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
              & RadV, DACsStaging(:,i) )
          end do
          ! Now go through channel by channel
          do i = 1, noUsedChannels
            sigInd = channels(i)%signal
            channel = channels(i)%used
            if ( channels(i)%dacs == 0 ) then
              shapeInd = MatchSignal ( filterShapes%signal, &
                & fwdModelConf%signals(sigInd), sideband = thisSideband, &
                & channel=channel )
              if ( shapeInd == 0 ) &
                & call MLSMessage ( MLSMSG_Error, ModuleName, &
                &    "No matching channel shape information" )
              call Freq_Avg ( frequencies, &
                &   FilterShapes(shapeInd)%FilterGrid,  &
                &   FilterShapes(shapeInd)%FilterShape, &
                &   RadV, Radiances(ptg_i,i) )
            else
              radiances(ptg_i,i) = DACsStaging(channel,channels(i)%dacs)
            end if
          end do
        else
          Radiances(ptg_i,1:noUsedChannels) = RadV(1:)
        end if
d1803 2
a1804 1
        ! Frequency averaging of derivatives if needed -----------------------
d1806 1
a1806 122
        ! Frequency Average the temperature derivatives with the appropriate
        ! filter shapes

        if ( temp_der ) then
          if ( fwdModelConf%do_freq_avg ) then
            ! Do DACs stuff for all DACs channels first
            do i = 1, noUsedDACS
              shapeInd = MatchSignal ( dacsFilterShapes%signal, &
                & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
              sv_i = 1
              do instance = 1, no_sv_p_t
                do surface = 1, n_t_zeta
                  call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                    & k_temp_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
                  sv_i = sv_i + 1
                end do                  ! Surface loop
              end do                    ! Instance loop
            end do                      ! i -- DACs loop
            ! Now go through channel by channel
            do i = 1, noUsedChannels
              sigInd = channels(i)%signal
              channel = channels(i)%used
              shapeInd = MatchSignal ( filterShapes%signal, &
                & fwdModelConf%signals(sigInd), &
                & sideband = thisSideband, channel=channel )
              sv_i = 1
              do instance = 1, no_sv_p_t
                do surface = 1, n_t_zeta
                  if ( channels(i)%dacs == 0 ) then
                    call Freq_Avg ( frequencies, &
                      & FilterShapes(shapeInd)%FilterGrid, &
                      & FilterShapes(shapeInd)%FilterShape, &
                      & k_temp_frq(:,sv_i), r )
                  else
                    r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                  end if
                  k_temp(i,ptg_i,surface,instance) = r
                  sv_i = sv_i + 1
                end do                  ! Surface loop
              end do                    ! Instance loop
            end do                      ! Channel loop
          else
            k_temp(1:noUsedChannels,ptg_i,1:n_t_zeta,1:no_sv_p_t) = &
              & reshape( k_temp_frq(1:noUsedChannels,1:no_sv_p_t*n_t_zeta), &
                &        (/ noUsedChannels, n_t_zeta, no_sv_p_t /) )
          end if
        end if

        ! Frequency Average the atmospheric derivatives with the appropriate
        ! filter shapes

        if ( atmos_der ) then

          do k = 1, no_mol
            if ( fwdModelConf%moleculeDerivatives(mol_cat_index(k)) ) then
              if ( fwdModelConf%do_freq_avg ) then
                ! Do DACs stuff for all DACs channels first
                do i = 1, noUsedDACS
                  shapeInd = MatchSignal ( dacsFilterShapes%signal, &
                    & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
                  do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                    call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                      & k_atmos_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
                  end do                  ! Surface loop X Instance loop
                end do
                ! Now go through channel by channel
                do i = 1, noUsedChannels
                  sigInd = channels(i)%signal
                  channel = channels(i)%used
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd),             &
                    & sideband = thisSideband, channel=channel )
                  do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                    if ( grids_f%deriv_flags(sv_i) ) then
                      if ( channels(i)%dacs == 0 ) then
                        call Freq_Avg ( frequencies,            &
                          & FilterShapes(shapeInd)%FilterGrid,  &
                          & FilterShapes(shapeInd)%FilterShape, &
                          & k_atmos_frq(1:noFreqs,sv_i), r )
                      else
                        r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                      end if
                    else
                      r = 0.0
                    end if
                    k_atmos(i,ptg_i,sv_i) = r
                  end do                ! Surface loop X Instance loop
                end do                  ! Channel loop
              else                      ! Else not frequency averaging
                do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                  if ( grids_f%deriv_flags(sv_i) ) then
                    k_atmos(1:noUsedChannels,ptg_i,sv_i) = &
                      & min ( max ( k_atmos_frq(1:noUsedChannels,sv_i), &
                      &   real(-huge(0.0_r4), rp ) ), &
                      &   real( huge(0.0_r4), rp ) )
                  else
                    k_atmos(1:noUsedChannels,ptg_i,sv_i) = 0.0
                  end if
                end do
              end if                    ! Frequency averaging or not
            end if                      ! Want derivatives for this specie?
          end do                        ! Loop over major molecules
          !
        end if                          ! Want derivatives for atmos

        ! Frequency Average the spectroscopic derivatives with the appropriate
        ! filter shapes

        if ( spect_der ) then

          do k = 1, no_mol
            if ( fwdModelConf%moleculeDerivatives(mol_cat_index(k)) ) then
              !  *** dI/dW
              call dI_dSomething ( grids_dw, k_spect_dw_frq, k_spect_dw, k )
              !  *** dI/dN
              call dI_dSomething ( grids_dn, k_spect_dn_frq, k_spect_dn, k )
              !  *** dI/dV
              call dI_dSomething ( grids_dv, k_spect_dv_frq, k_spect_dv, k )
            end if                        ! Want derivatives for this
          end do                          ! Loop over major molecules

          !??? So now we have k_spect_d?.  What do we do with them ???
d1808 10
a1817 13
        end if                        ! Want derivatives for spect

        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call trace_end ( 'ForwardModel.FrequencyAvg' )

        if ( toggle(emit) .and. levels(emit) > 3 ) &
          & call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )

        if ( FwdModelConf%do_freq_avg ) &
           & call deallocate_test ( frequencies, 'frequencies',moduleName )

        ! End of pointing loop -------------------------------------------------
      end do
d1820 1
a1820 1
        & call Trace_End ( 'ForwardModel.PointingLoop' )
d1831 1
a1831 1
      do ptg_i = 2, no_tan_hts-1
d1838 1
a1838 1
      end do
a1848 5
      ! Convolution if needed, or interpolation to ptan ----------------------

      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call trace_begin ( 'ForwardModel.Convolution' )

d1858 1
a1858 2
          & signal=fwdModelConf%signals(sigInd)%index, &
          & sideband=merge ( 0, fwdModelConf%signals(sigInd)%sideband, fwdModelConf%forceFoldedOutput ) )
d1900 4
a1903 4
               & chanInd, windowStart, windowFinish, qtys, temp,ptan, &
               & thisRadiance, update, ptg_angles, Radiances(:,i), &
               & tan_chi_out-thisElev, &
               & dhdz_out, dx_dh_out, thisFraction,                               &
d1909 4
a1912 4
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), &
               & tan_chi_out-thisElev, &
               & dhdz_out, dx_dh_out, thisFraction,                               &
d1915 1
a1915 1
               & DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),        &
d1920 4
a1923 4
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), &
               & tan_chi_out-thisElev, &
               & dhdz_out, dx_dh_out, thisFraction,                               &
d1926 2
a1927 2
               & DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d1930 4
a1933 4
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), &
               & tan_chi_out-thisElev, &
               & dhdz_out, dx_dh_out, thisFraction,                               &
d1936 1
a1936 1
               & DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),        &
d1939 2
a1940 2
               & DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d1949 4
a1952 4
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update, &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev, &
              &  dhdz_out, dx_dh_out, Grids_f,                            &
              &  Radiances(:,i), thisFraction, qtys, fmStat%rows, Jacobian,  &
d1956 5
a1960 5
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update, &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev, &
              &  dhdz_out, dx_dh_out, Grids_f,                            &
              &  Radiances(:,i), thisFraction, qtys, fmStat%rows, Jacobian,  &
              &  DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),   &
d1964 6
a1969 6
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update, &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev, &
              &  dhdz_out, dx_dh_out, Grids_f,                            &
              &  Radiances(:,i), thisFraction, qtys, fmStat%rows, Jacobian,  &
              &  DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d1972 7
a1978 7
              &  windowStart, windowFinish, temp, ptan, thisRadiance, update, &
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out-thisElev, &
              &  dhdz_out, dx_dh_out, Grids_f,                            &
              &  Radiances(:,i), thisFraction, qtys, fmStat%rows, Jacobian,  &
              &  DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),   &
              &  DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d1988 4
a1991 2
      ! Deallocate maxNoPtgFreqs stuff
      call deallocate_test ( Radv, 'RadV', moduleName )
d1993 1
a1993 4
      call DestroyCompleteSlabs ( gl_slabs )
      if ( temp_der ) then
        call deallocate_test ( k_temp_frq,     'k_temp_frq',     moduleName )
      end if
d1995 4
a1998 2
      if ( atmos_der ) &
        & call deallocate_test ( k_atmos_frq,  'k_atmos_frq',    moduleName )
d2000 2
a2001 5
      if ( spect_der ) then
        call deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq', moduleName )
        call deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq', moduleName )
        call deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq', moduleName )
      end if
d2003 52
a2054 2
      if ( any_der ) &
        & call deallocate_test ( DACsStaging2, 'DACsStaging2',   moduleName )
d2056 4
a2059 2
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call trace_end ( 'ForwardModel.Sideband ',index=thisSideband )
d2061 2
a2062 1
    end do            ! End of loop over sidebands -------------------------
d2064 2
a2065 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_End ( 'ForwardModel.SidebandLoop' )
d2067 1
a2067 1
    !  **** DEBUG Printing cycle ...
d2069 2
a2070 1
! *** Create *seez* file for "nasty" purposes:
d2072 30
a2101 3
    if ( index(switches, 'seez') /= 0 ) then
      include 'dump_print_code.f9h'
    end if
d2103 1
a2103 1
! *** End of include
d2105 2
a2106 4
    call GetNameOfSignal ( firstSignal, sigName )
    i = index(sigName, '.B')
    j = index(sigName(i+2:), '.' )
    if ( j /= 0 ) sigName(i+j+1:) = ''
d2108 43
a2150 5
    if ( index(switches, 'rad') /= 0 ) then
      if ( FwdModelConf%do_conv ) then
        print *, 'Convolution: ON'
      else
        print *, 'Convolution: OFF'
d2153 157
a2309 7
      if ( FwdModelConf%do_freq_avg ) then
        print *, 'Frequency Averaging: ON'
      else
        Frq = Frequencies(1)
        print *, 'Frequency Averaging: OFF'
        print '(a,f12.4,a)', ' (All computations done at Frq =',Frq, ')'
      end if
d2311 3
a2313 3
      k = ptan%template%noSurfs
      print "( /'ptan\ ',i3.3)", k
      Print "( 4(3x, f11.7) )", Ptan%values(1:k,maf)
d2315 7
a2321 8
      do i = 1, noUsedChannels
        channel = channels(i)%used - channels(i)%origin + 1
        print "(/, 'ch', i3.3, '_pfa_rad\ ', i3.3 )", channels(i)%used, k
        j = thisRadiance%template%noChans
        print "( 4(2x, 1pg15.8) )", &
          & thisRadiance%values(channel:channel+j*(k-1):j, maf)
      end do
      Print *
d2323 1
a2323 1
    end if
d2325 19
a2343 1
    !  **** End of Printing cycle ...
d2345 1
a2345 1
    ! Now deallocate lots of stuff
d2347 1
a2347 2
    call destroy_species_data ( my_catalog )
    call destroy_beta_group ( beta_group )
d2349 2
a2350 1
    deallocate ( mol_cat_index, stat=j )
d2352 42
a2393 3
    call Deallocate_Test ( WC, 'WC', moduleName )
    call Deallocate_Test ( Scat_ang, 'Scat_ang', moduleName )
    call Deallocate_Test ( IPSD, 'IPSD', moduleName )
d2395 45
a2439 1
    call destroyForwardModelDerived ( fwdModelConf )
d2441 1
a2441 1
    ! DESTROY THE SPS DATA STUFF
d2443 22
a2464 2
    call deallocate_test ( z_glGrid, 'z_glGrid', moduleName )
    call deallocate_test ( p_glGrid, 'z_glGrid', moduleName )
d2466 2
a2467 5
    call deallocate_test ( h_glgrid,     'h_glgrid',     moduleName )
    call deallocate_test ( t_glgrid,     't_glgrid',     moduleName )
    call deallocate_test ( dhdz_glgrid,  'dhdz_glgrid',  moduleName )
    call deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', moduleName )
    call deallocate_test ( ddhidhidtl0,  'ddhidhidtl0',  moduleName )
d2469 1
a2469 5
    call deallocate_test ( tan_inds,      'tan_inds',      moduleName )
    call deallocate_test ( tan_press,     'tan_press',     moduleName )
    call deallocate_test ( tan_phi,       'tan_phi',       moduleName )
    call deallocate_test ( est_scgeocalt, 'est_scgeocalt', moduleName )
    call deallocate_test ( tan_temp,      'tan_temp',      moduleName )
d2471 7
a2477 4
    ! Extra DEBUG for Nathaniel and Bill
!   call deallocate_test ( tan_hts,       'tan_hts',       moduleName )
!   call deallocate_test ( tan_temps,     'tan_temps',     moduleName )
!   call deallocate_test ( reqs,          'reqs',          moduleName )
d2479 1
a2479 8
    call destroygrids_t ( grids_f )
    call destroygrids_t ( grids_iwc )
    call destroygrids_t ( grids_mag )
    call destroygrids_t ( grids_tmp )
    call destroygrids_t ( grids_tscat )
    call destroygrids_t ( grids_salb )
    call destroygrids_t ( grids_cext )
    call Deallocate_test ( vmrArray,'vmrArray',ModuleName )
d2481 24
a2504 13
    call deallocate_test ( dhdz_path,        'dhdz_path',        moduleName )
    call deallocate_test ( dhdz_gw_path,     'dhdz_gw_path',     moduleName )
    call deallocate_test ( dsdz_gw_path,     'dsdz_gw_path',     moduleName )
    call deallocate_test ( h_path,           'h_path',           moduleName )
    call deallocate_test ( h_path_c,         'h_path_c',         moduleName )
    call deallocate_test ( h_path_f,         'h_path_f',         moduleName )
    call deallocate_test ( p_path,           'p_path',           moduleName )
    call deallocate_test ( p_path_c,         'p_path_c',         moduleName )
    call deallocate_test ( path_dsdh,        'path_dsdh',        moduleName )
    call deallocate_test ( phi_path,         'phi_path',         moduleName )
    call deallocate_test ( t_path,           't_path',           moduleName )
    call deallocate_test ( t_path_c,         't_path_c',         moduleName )
    call deallocate_test ( z_path,           'z_path',           moduleName )
d2506 16
a2521 19
    call deallocate_test ( alpha_path_c,     'alpha_path_c',     moduleName )
    call deallocate_test ( alpha_path_f,     'alpha_path_f',     moduleName )
    call deallocate_test ( beta_path_c,      'beta_path_c',      moduleName )
    call deallocate_test ( beta_path_cloud_c,'beta_path_cloud_c',moduleName )
    call deallocate_test ( w0_path_c,        'w0_path_c',        moduleName )
    call deallocate_test ( tt_path_c,        'tt_path_c',        moduleName )
    call deallocate_test ( c_inds,           'c_inds',           moduleName )
    call deallocate_test ( cg_inds,          'cg_inds',          moduleName )
    call deallocate_test ( del_s,            'del_s',            moduleName )
    call deallocate_test ( do_gl,            'do_gl',            moduleName )
    call deallocate_test ( f_inds,           'f_inds',           moduleName )
    call deallocate_test ( gl_inds,          'gl_inds',          moduleName )
    call deallocate_test ( incoptdepth,      'incoptdept',       moduleName )
    call deallocate_test ( n_path,           'n_path',           moduleName )
    call deallocate_test ( ref_corr,         'ref_corr',         moduleName )
    call deallocate_test ( tau,              'tau',              moduleName )
    call deallocate_test ( tanh1_c,          'tanh1_c',          moduleName )
    call deallocate_test ( tanh1_f,          'tanh1_f',          moduleName )
    call deallocate_test ( t_script,         't_script',         moduleName )
d2523 3
a2525 14
    call deallocate_test ( beta_path_f,      'beta_path_f',      moduleName )
    call deallocate_test ( do_calc_fzp,      'do_calc_fzp',      moduleName )
    call deallocate_test ( do_calc_iwc,      'do_calc_iwc',      moduleName )
    call deallocate_test ( do_calc_iwc_zp,   'do_calc_iwc_zp',   moduleName )
    call deallocate_test ( do_calc_zp,       'do_calc_zp',       moduleName )
    call deallocate_test ( eta_fzp,          'eta_fzp',          moduleName )
    call deallocate_test ( eta_iwc,          'eta_iwc',          moduleName )
    call deallocate_test ( eta_iwc_zp,       'eta_iwc_zp',       moduleName )
    call deallocate_test ( eta_mag_zp,       'eta_mag_zp',       moduleName )
    call deallocate_test ( eta_zp,           'eta_zp',           moduleName )
    call deallocate_test ( iwc_path,         'iwc_path',         moduleName )
    call deallocate_test ( mag_path,         'mag_path',         moduleName )
    call deallocate_test ( sps_path,         'sps_path',         moduleName )
    call deallocate_test ( true_path_flags,  'true_path_flags',  moduleName )
d2527 3
a2529 3
    call deallocate_test ( tan_chi_out,      'tan_chi_out',      moduleName )
    call deallocate_test ( dx_dh_out,        'dx_dh_out',        moduleName )
    call deallocate_test ( dhdz_out,         'dhdz_out',         moduleName )
d2531 1
a2531 3
    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( scat_src%values, 'scat_src%values', &
        &                      moduleName )
d2533 7
a2539 3
    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( scat_alb%values, 'scat_alb%values', &
        &                      moduleName )
d2541 3
a2543 3
    if ( FwdModelConf%incl_cld ) &
      & call deallocate_test ( cld_ext%values, 'cld_ext%values', &
        &                      moduleName )
d2545 213
a2757 29
    if ( temp_der ) then
      deallocate ( k_temp, STAT=i )
      call deallocate_test ( d2xdxdt_tan,     'd2xdxdt_tan',     moduleName )
      call deallocate_test ( dAlpha_dT_path_c,'dAlpha_dT_path_c',moduleName )
      call deallocate_test ( dAlpha_dT_path_f,'dAlpha_dT_path_f',moduleName )
      call deallocate_test ( dBeta_dT_Path_c, 'dBeta_dT_Path_c', moduleName )
      call deallocate_test ( dBeta_dT_Path_f, 'dBeta_dT_Path_f', moduleName )
      call deallocate_test ( dh_dt_path_c,    'dh_dt_path_c',    moduleName )
      call deallocate_test ( dh_dt_path,      'dh_dt_path',      moduleName )
      call deallocate_test ( dh_dt_path_f,    'dh_dt_path_f',    moduleName )
      call deallocate_test ( do_calc_hyd_c,   'do_calc_hyd_c',   moduleName )
      call deallocate_test ( do_calc_hyd,     'do_calc_hyd',     moduleName )
      call deallocate_test ( do_calc_t_c,     'do_calc_t_c',     moduleName )
      call deallocate_test ( do_calc_t,       'do_calc_t',       moduleName )
      call deallocate_test ( do_calc_t_f,     'do_calc_t_f',     moduleName )
      call deallocate_test ( dRad_dt,         'dRad_dt',         moduleName )
      call deallocate_test ( dTanh_dT_c,      'dTanh_dT_c',      moduleName )
      call deallocate_test ( dTanh_dT_f,      'dTanh_dT_f',      moduleName )
      call deallocate_test ( d_t_scr_dt,      'd_t_scr_dt',      moduleName )
      call deallocate_test ( dxdt_surface,    'dxdt_surface',    moduleName )
      call deallocate_test ( dxdt_tan,        'dxdt_tan',        moduleName )
      call deallocate_test ( eta_zxp_t_c,     'eta_zxp_t_c',     moduleName )
      call deallocate_test ( eta_zxp_t,       'eta_zxp_t',       moduleName )
      call deallocate_test ( eta_zxp_t_f,     'eta_zxp_t_f',     moduleName )
      call deallocate_test ( tan_d2h_dhdt,    'tan_d2h_dhdt',    moduleName )
      call deallocate_test ( tan_dh_dt,       'tan_dh_dt',       moduleName )
      call deallocate_test ( t_der_path_flags,'t_der_path_flags',moduleName )
      call deallocate_test ( true_path_flags, 'true_path_flags', moduleName )
    end if
d2759 1
a2759 4
    if ( atmos_der ) then
      call deallocate_test ( d_delta_df,      'd_delta_df',      moduleName )
      call deallocate_test ( k_atmos,         'k_atmos',         moduleName )
    end if
d2761 1
a2761 1
    if ( spect_der ) then
d2763 2
a2764 6
      call deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', moduleName )
      call deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f', moduleName )
      call deallocate_test ( dbeta_dn_path_c, 'dbeta_dn_path_c', moduleName )
      call deallocate_test ( dbeta_dn_path_f, 'dbeta_dn_path_f', moduleName )
      call deallocate_test ( dbeta_dv_path_c, 'dbeta_dv_path_c', moduleName )
      call deallocate_test ( dbeta_dv_path_f, 'dbeta_dv_path_f', moduleName )
d2766 37
a2802 9
      call deallocate_test ( do_calc_dw,      'do_calc_dw',      moduleName )
      call deallocate_test ( do_calc_dw_c,    'do_calc_dw_c',    moduleName )
      call deallocate_test ( do_calc_dw_f,    'do_calc_dw_f',    moduleName )
      call deallocate_test ( do_calc_dn,      'do_calc_dn',      moduleName )
      call deallocate_test ( do_calc_dn_c,    'do_calc_dn_c',    moduleName )
      call deallocate_test ( do_calc_dn_f,    'do_calc_dn_f',    moduleName )
      call deallocate_test ( do_calc_dv,      'do_calc_dv',      moduleName )
      call deallocate_test ( do_calc_dv_c,    'do_calc_dv_c',    moduleName )
      call deallocate_test ( do_calc_dv_f,    'do_calc_dv_f',    moduleName )
d2804 2
a2805 9
      call deallocate_test ( eta_zxp_dw,      'eta_zxp_dw',      moduleName )
      call deallocate_test ( eta_zxp_dw_c,    'eta_zxp_dw_c',    moduleName )
      call deallocate_test ( eta_zxp_dw_f,    'eta_zxp_dw_f',    moduleName )
      call deallocate_test ( eta_zxp_dn,      'eta_zxp_dn',      moduleName )
      call deallocate_test ( eta_zxp_dn_c,    'eta_zxp_dn_c',    moduleName )
      call deallocate_test ( eta_zxp_dn_f,    'eta_zxp_dn_f',    moduleName )
      call deallocate_test ( eta_zxp_dv,      'eta_zxp_dv',      moduleName )
      call deallocate_test ( eta_zxp_dv_c,    'eta_zxp_dv_c',    moduleName )
      call deallocate_test ( eta_zxp_dv_f,    'eta_zxp_dv_f',    moduleName )
d2807 1
a2807 3
      call deallocate_test ( drad_dw,         'drad_dw',         moduleName )
      call deallocate_test ( drad_dn,         'drad_dn',         moduleName )
      call deallocate_test ( drad_dv,         'drad_dv',         moduleName )
d2809 1
a2809 9
      deallocate ( k_spect_dw, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dw' )
      deallocate ( k_spect_dn, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dn' )
      deallocate ( k_spect_dv, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dv' )
d2811 2
a2812 1
    end if
d2814 1
a2814 57
    if ( FwdModelConf%polarized ) then
      deallocate ( alpha_path_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'alpha_path_polarized' )
      deallocate ( beta_path_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'beta_path_polarized' )
      deallocate ( alpha_path_polarized_f, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'alpha_path_polarized_f' )
      deallocate ( beta_path_polarized_f, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'beta_path_polarized_f' )
      deallocate ( gl_delta_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'gl_delta_polarized' )
      deallocate ( incoptdepth_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol' )
      deallocate ( incoptdepth_pol_gl, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol_gl' )
      if ( atmos_der ) then
        deallocate ( d_rad_pol_df, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'d_rad_pol_df' )
        deallocate ( de_df, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'de_df' )
      end if
      if ( temp_der ) then
        deallocate ( d_rad_pol_dt, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'d_rad_pol_dt' )
        deallocate ( dBeta_dT_polarized_path_c, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dBeta_dT_polarized_path_c' )
        deallocate ( dBeta_dT_polarized_path_f, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dBeta_dT_polarized_path_f' )
        deallocate ( de_dt, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'de_dt' )
        deallocate ( dincoptdepth_pol_dt, stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_DeAllocate//'dincoptdepth_pol_dt' )
      end if
      deallocate ( deltau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'deltau_pol' )
      deallocate ( prod_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'prod_pol' )
      deallocate ( tau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'tau_pol' )
    end if
d2816 3
a2818 4
    call deallocate_test ( ptg_angles,       'ptg_angles',     moduleName )
    call deallocate_test ( radiances,        'radiances',      moduleName )
    call deallocate_test ( dx_dt,            'dx_dt',          moduleName )
    call deallocate_test ( d2x_dxdt,         'd2x_dxdt',       moduleName )
d2820 2
a2821 3
    deallocate ( qtys, stat = ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_DeAllocate // 'QTYS' )
d2823 1
a2823 3
    if ( toggle(emit) ) then
      call trace_end ( 'ForwardModel MAF=', fmStat%maf )
    end if
d2825 2
a2826 1
  contains
d2828 5
a2832 1
    subroutine dI_dSomething ( grids_dS, k_spect_dS_frq, k_spect_dS, K )
d2834 1
a2834 1
    ! Do or don't do frequency averaging, to finish up derivative of I w.r.t. S
d2836 12
a2847 4
      type(grids_T), intent(in) :: grids_dS
      real(rp), dimension(:,:), intent(in) :: K_SPECT_DS_FRQ ! ****
      real(r4), dimension(:,:,:,:,:,:), intent(out) :: K_SPECT_DS
      integer, intent(in) :: K ! Which molecule
d2849 12
a2860 1
      integer :: I, Instance, JF, Surface, SV_I
d2862 2
a2863 16
      if ( fwdModelConf%do_freq_avg ) then
        ! Do DACs stuff for all DACs channels first
        do i = 1, noUsedDACS
          shapeInd = MatchSignal ( dacsFilterShapes%signal, &
            & fwdModelConf%signals(usedDacsSignals(i)), sideband = thisSideband )
          sv_i = Grids_dS%l_v(k-1)
          do instance = Grids_dS%WindowStart(k), Grids_dS%WindowFinish(k)
            do surface = 1, Grids_dS%l_z(k) - Grids_dS%l_z(k-1)
              do jf = 1, Grids_dS%l_f(k) - Grids_dS%l_f(k-1)
                sv_i = sv_i + 1
                call Freq_Avg_DACS ( frequencies, DACSFilterShapes(shapeInd), &
                  & k_spect_dS_frq(:,sv_i), DACsStaging2(:,sv_i,i) )
              end do   ! jf -- Frequencies loop
            end do     ! Surface loop
          end do       ! Instance loop
        end do         ! i -- DACS loop
d2868 99
a2966 32
            & fwdModelConf%signals(sigInd),             &
            & sideband = thisSideband, channel=channel )
          sv_i = Grids_dS%l_v(k-1)
          do instance = Grids_dS%WindowStart(k), Grids_dS%WindowFinish(k)
            do surface = 1, Grids_dS%l_z(k) - Grids_dS%l_z(k-1)
              do jf = 1, Grids_dS%l_f(k) - Grids_dS%l_f(k-1)
                sv_i = sv_i + 1
                if ( channels(i)%dacs == 0 ) then
                  call Freq_Avg ( frequencies,           &
                    & FilterShapes(shapeInd)%FilterGrid, &
                    & FilterShapes(shapeInd)%FilterShape,&
                    & k_spect_dS_frq(:,sv_i), r )
                else
                  r = DACsStaging2 ( channel, sv_i, channels(i)%dacs )
                end if
                k_spect_dS(i,ptg_i,jf,surface,instance,k) = r
              end do              ! Frequencies loop
            end do                ! Surface loop
          end do                  ! Instance loop
        end do                    ! Channel loop
      else                        ! else not frequency averaging
        k_spect_dS( 1:noUsedChannels, ptg_i, &
          &         1:Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
          &         1:Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &
          &         Grids_dS%WindowStart(k):Grids_dS%WindowFinish(k), k ) = &
          & reshape(k_spect_dS_frq( 1:noUsedChannels, &
          &                         Grids_dS%l_v(k-1) + 1: Grids_dS%l_v(k) ), &
            &       (/ noUsedChannels, Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
            &          Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &
            &          Grids_dS%WindowFinish(k) - Grids_dS%WindowStart(k) + 1 /) )
      end if                      ! Frequency averaging or not
    end subroutine dI_dSomething
d3066 3
@


2.210
log
@named parameter clean= to dump procedures
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.209 2004/05/17 22:05:11 livesey Exp $"
d40 2
a41 1
    use ForwardModelConfig, only: ForwardModelConfig_t
d69 1
a69 1
    use MLSCommon, only: R4, R8, RP, IP, FindFirst
d98 2
a99 1
    type(forwardModelConfig_T), intent(in) :: fwdModelConf
d490 4
a493 1
! scatering source function for each temperature surface
a497 10
! Channel information from the signals database
    type :: Channels_T
      integer :: Used       ! Which channel is this?
      integer :: Origin     ! Index of first channel (zero or one)
      integer :: Signal     ! Signal index for the channel
      integer :: DACS       ! DACS index if any, else zero
    end type Channels_T

    type(channels_T), allocatable, dimension(:) :: Channels 
     
d664 7
a670 5
    ! Identify which of our signals are DACS and how many unique DACS are involved
    call identifyDACS

    ! Work out which channels are used; also check we have radiances for them.
    noUsedChannels = 0
a677 20
      noUsedChannels = noUsedChannels + &
        & count( fwdModelConf%signals(sigInd)%channels )
    end do
    allocate ( channels(noUsedChannels), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'channels' )

    ! Collect channel information from signals database.
    channel = 1
    do sigInd = 1, size(fwdModelConf%signals)
      do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
        if ( fwdModelConf%signals(sigInd)%channels(i) ) then
          channels(channel)%origin = &
            & lbound ( fwdModelConf%signals(sigInd)%frequencies, 1 )
          channels(channel)%used = i + channels(channel)%origin - 1
          channels(channel)%signal = sigInd
          channels(channel)%dacs = FindFirst ( sigind == usedDACSSignals )
          channel = channel + 1
        end if
      end do
d2585 1
a2585 5
    deallocate ( channels, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_DeAllocate//'dincoptdepth_pol_dt' )

    call deallocate_test ( usedDACSSignals, 'usedDACSSignals', moduleName )
a2670 2
    call deallocate_test ( DACsStaging,      'DACsStaging',      moduleName )

a2899 35
    subroutine IdentifyDACS
      ! Compute NoUsedDACs
      ! Allocate and compute UsedDACSSignals and allocate DACsStaging.
      integer :: LBoundDACs, UBoundDACs    ! How many channels in a DAC
      logical :: signalFlag(size(fwdModelConf%signals))

      signalFlag = .false.
      lBoundDACs = 0; uBoundDACs = 0
      noUsedDACs = 0
      do sigInd = 1, size(fwdModelConf%signals)
        if ( fwdModelConf%signals(sigInd)%dacs .and. &
          & .not. signalFlag(sigind) ) then
          signalFlag(sigind) = .true.
          noUsedDACs = noUsedDACs + 1
          if ( noUsedDACs == 1 ) then
            lBoundDACs = lbound(fwdModelConf%signals(sigInd)%frequencies,1 )
            uBoundDACs = ubound(fwdModelConf%signals(sigInd)%frequencies,1 )
          else
            if ( lBoundDACs /= lbound ( fwdModelConf%signals(sigInd)%frequencies,1 ) .or. &
              &  uBoundDACs /= ubound ( fwdModelConf%signals(sigInd)%frequencies,1 ) ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Two DACS have different number of channels' )
          end if
        end if
      end do
      if ( noUsedDACs > 0 .and. .not. associated(DACsFilterShapes) ) &
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'DACS in use but no filter shapes provided.' )
      call allocate_test ( usedDACSSignals, noUsedDACs, 'usedDACSSignals', ModuleName )
      usedDACSSignals = pack ( (/ (i, i=1, size(signalFlag)) /), signalFlag )
      call allocate_test ( DACsStaging, uBoundDACs, noUsedDACs, &
        & 'DACsStaging', moduleName, low1 = lBoundDACs )

    end subroutine IdentifyDACS

d2998 3
@


2.209
log
@A change to refraction and to k_atmos handling to avoid explosions.
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.208 2004/04/24 02:27:05 vsnyder Exp $"
d1548 4
a1551 4
            call dump ( h, 'H', clean )
            call dump ( ct, 'Cos(theta)', clean )
            call dump ( stcp, 'Sin(theta) Cos(phi)', clean )
            call dump ( stsp, 'Sin(theta) Sin(phi)', clean )
d3062 3
@


2.208
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.207 2004/04/19 21:01:37 vsnyder Exp $"
d1565 2
d1578 1
a1578 1
        n_path(1:npc) = min ( n_path(1:npc), MaxRefraction ) + 1.0_rp
d2301 4
a2304 1
                    k_atmos(1:noUsedChannels,ptg_i,sv_i) = k_atmos_frq(1:noUsedChannels,sv_i)
d3062 3
@


2.207
log
@Put size of gl_slabs in call to get_gl_slabs_arrays
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.206 2004/04/17 00:37:00 vsnyder Exp $"
d1930 1
a1930 1
            call get_beta_path_polarized ( frq, h, beta_group, &
d1977 5
a1981 5
            call drad_tran_df ( c_inds(1:npc), gl_inds(1:ngl), del_zeta, Grids_f, &
              &  beta_path_c(1:npc,:), eta_fzp, sps_path, do_calc_fzp(1:no_ele,:), &
              &  beta_path_f, do_gl(1:npc), del_s(1:npc), ref_corr(1:npc), &
              &  dsdz_gw_path, t_script(1:npc), tau(1:npc), &
              &  i_stop, d_delta_df(1:npc,:), k_atmos_frq(frq_i,:) )
d1988 4
a1991 4
              call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, c_inds(1:p_stop), &
                &  del_zeta, Grids_f, beta_path_polarized(:,1:p_stop,:),      &
                &  eta_fzp, do_calc_fzp(1:no_ele,:), sps_path, del_s(1:npc),  &
                &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),         &
d1997 3
a1999 3
              call mcrt_der ( t_script(1:npc), sqrt(e_rflty),            &
                & deltau_pol(:,:,1:npc), de_df(:,:,1:npc,:),             &
                & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), p_stop,       &
d2022 1
a2022 1
            dAlpha_dT_path_c(:npc) = sum( sps_path(c_inds(1:npc),:) * &
d2031 5
a2035 6
                & dAlpha_dT_path_c(:npc), &
                & eta_zxp_t_c(1:npc,:), do_calc_t_c(1:npc,:),                 &
                & do_calc_hyd_c(1:npc,:), del_s(1:npc), ref_corr(1:npc),      &
                & Req + one_tan_ht(1), dh_dt_path(brkpt,:), do_gl(1:npc),     &
                & gl_inds(1:ngl), h_path_f(:ngl), t_path_f(:ngl),             &
                & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl),                  &
d2054 1
a2054 1
                    & sps_path(c_inds(1:npc),j) * &
d2058 1
a2058 1
                    & sps_path(gl_inds(1:ngl),j) * &
d2071 5
a2075 6
              call get_d_deltau_pol_dT ( ct, stcp, stsp,              &
                & t_path_f(:ngl),                 &
                & alpha_path_polarized(:,1:p_stop), &
                & alpha_path_polarized_f(:,1:ngl), &
                & dAlpha_dT_path_c(:npc), dAlpha_dT_path_f(:ngl), &
                & dAlpha_dT_polarized_path_c, dAlpha_dT_polarized_path_f, &
d2077 6
a2082 6
                & gl_inds(:ngl), del_zeta(1:npc),           &
                & do_calc_t_c(1:p_stop,:), do_calc_t_f(:ngl,:), do_gl(1:p_stop), &
                & path_dsdh, dhdz_gw_path, dsdz_gw_path,                      &
                & incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop),          &
                & h_path_c(1:npc), h_path_f(:ngl), dh_dt_path_c(1:p_stop,:),  &
                & dh_dt_path_f(:ngl,:), Req + one_tan_ht(1), dh_dt_path(brkpt,:), &
d3057 3
@


2.206
log
@Analytic temperature derivatives
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.205 2004/04/05 21:08:42 jonathan Exp $"
d1591 1
a1591 1
            &  losVel%values(1,maf), gl_slabs, fwdModelConf%Do_1D, &
d1595 1
a1595 1
            &  losVel%values(1,maf), gl_slabs, fwdModelConf%Do_1D )
d1634 1
d3059 3
@


2.205
log
@delet temp_prof
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.204 2004/04/02 00:59:24 vsnyder Exp $"
a111 1
    real(rp), parameter :: DEL_TEMP = 10.0_rp ! Temp. step size for derivatives
d259 2
d270 2
a271 2
    real(rp), dimension(:), pointer :: DTanh_DT_C   ! d/dT tanh1_c
    real(rp), dimension(:), pointer :: DTanh_DT_F   ! d/dT tanh1_f
a288 2
    real(rp), dimension(:), pointer :: SPS_BETA_DBETA_C ! SUM(sps*beta*dbeta)
    real(rp), dimension(:), pointer :: SPS_BETA_DBETA_F ! SUM(sps*beta*dbeta)
a301 2
    real(rp), dimension(:), pointer :: T_PATH_M     ! T_PATH - del_temp
    real(rp), dimension(:), pointer :: T_PATH_P     ! T_PATH + del_temp
a307 4
    real(rp), dimension(:,:), pointer :: BETA_N_PATH_C   ! n in beta = beta_0 (T/T_0)**n
                                           ! to compute dBeta_dt on coarse grid
    real(rp), dimension(:,:), pointer :: BETA_N_PATH_F ! n in beta = beta_0 (T/T_0)**n
                                           ! to compute dBeta_dt on fine grid
d381 2
d386 2
d448 1
a448 3
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS ! ***
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS_M ! ***
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS_P ! ***
d524 3
a526 2
      & alpha_path_polarized_f, beta_n_path_c, beta_n_path_f, beta_path_c, &
      & beta_path_cloud_c, beta_path_f, beta_path_polarized, cext_path, &
d529 2
d533 1
d557 1
a557 1
      & scat_ang, scat_src%values, sps_beta_dbeta_c, sps_beta_dbeta_f, &
d560 1
a560 1
      & t_path, t_path_c, t_path_f, t_path_m, t_path_p, true_path_flags, &
a959 2
    call allocate_test ( sps_beta_dbeta_c,    npc, 'sps_beta_dbeta_c', moduleName )
    call allocate_test ( sps_beta_dbeta_f, max_ele, 'sps_beta_dbeta_f', moduleName )
d979 1
a979 1
   if ( fwdModelConf%Incl_Cld ) then
d998 3
d1007 2
a1008 1
      call allocate_test ( beta_n_path_c,      npc, no_mol,   'beta_n_path_c', &
d1010 1
a1010 1
      call allocate_test ( beta_n_path_f,  max_ele, no_mol,   'beta_n_path_f', &
d1012 1
a1012 2
      call allocate_test ( dRad_dt, sv_t_len, 'dRad_dt', moduleName )
      call allocate_test ( d_t_scr_dt,         npc, sv_t_len, 'd_t_scr_dt', &
a1041 2
      call allocate_test ( t_path_m,        max_ele, 't_path_m',         moduleName )
      call allocate_test ( t_path_p,        max_ele, 't_path_p',         moduleName )
d1183 12
a1223 6
      if ( temp_der ) then
        call allocateSlabs ( gl_slabs_p, max_ele, my_catalog(thisSideband,:), &
          & moduleName, temp_der )
        call allocateSlabs ( gl_slabs_m, max_ele, my_catalog(thisSideband,:), &
          & moduleName, temp_der )
      end if
a1446 4
        if ( temp_der ) then
          t_path_m = t_path - del_temp ! for computing temperature derivatives
          t_path_p = t_path + del_temp ! for computing temperature derivatives
        end if
a1592 6
          call get_gl_slabs_arrays ( p_path(1:no_ele), t_path_p(1:no_ele), &
            &  losVel%values(1,maf), gl_slabs_p, fwdModelConf%Do_1D, &
            &  t_der_path_flags(1:no_ele) )
          call get_gl_slabs_arrays ( p_path(1:no_ele), t_path_m(1:no_ele), &
            &  losVel%values(1,maf), gl_slabs_m, fwdModelConf%Do_1D, &
            &  t_der_path_flags(1:no_ele) )
a1657 2
            &  gl_slabs_m, t_path_m,                              &
            &  gl_slabs_p, t_path_p,                              &
d1659 1
a1659 2
            &  beta_n_path_c, dbeta_dw_path_c,                    &
            &  dbeta_dn_path_c, dbeta_dv_path_c )
d1778 18
a1795 18
              call deallocate_test ( do_calc_tscat,    'do_calc_tscat',    moduleName )
              call deallocate_test ( do_calc_tscat_zp, 'do_calc_tscat_zp', moduleName )
              call deallocate_test ( eta_tscat,        'eta_tscat',        moduleName )
              call deallocate_test ( eta_tscat_zp,     'eta_tscat_zp',     moduleName )           
              call deallocate_test ( tscat_path,       'tscat_path',       moduleName )
              call deallocate_test ( tt_path,          'tt_path',          moduleName )

              call deallocate_test ( do_calc_salb,     'do_calc_salb',     moduleName )
              call deallocate_test ( do_calc_salb_zp,  'do_calc_salb_zp',  moduleName )
              call deallocate_test ( eta_salb,         'eta_salb',         moduleName )
              call deallocate_test ( eta_salb_zp,      'eta_salb_zp',      moduleName )
              call deallocate_test ( salb_path,        'salb_path',        moduleName )

              call deallocate_test ( do_calc_cext,     'do_calc_salb',     moduleName )
              call deallocate_test ( do_calc_cext_zp,  'do_calc_salb_zp',  moduleName )
              call deallocate_test ( eta_cext,         'eta_cext',         moduleName )
              call deallocate_test ( eta_cext_zp,      'eta_cext_zp',      moduleName )
              call deallocate_test ( cext_path,        'cext_path',        moduleName )
d1809 1
a1809 1
                                    & beta_path_c(j,:) )
d1815 1
a1815 1
         endif ! end of check cld 
d1826 2
a1827 1
                & gl_slabs, c_inds(1:npc), beta_path_polarized )
d1832 9
a1840 23
              if ( any_der ) then
                ! Will need beta_path_polarized * tanh1_c
                ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
                ! to alpha here
                do j = 1, npc
                  beta_path_polarized(-1:1,j,:) = beta_path_polarized(-1:1,j,:) * tanh1_c(j)
                  alpha_path_polarized(-1:1,j) = matmul( beta_path_polarized(-1:1,j,:), &
                    & sps_path(c_inds(j),:) ) + 0.25 * alpha_path_c(j)
                  alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
                    & 0.25 * alpha_path_c(j)
                end do
              else
                ! Won't need beta_path_polarized * tanh1_c
                ! Add contributions from nonpolarized molecules 1/4 1/2 1/4
                ! to alpha here
                do j = 1, npc
                  alpha_path_polarized(-1:1,j) = matmul( beta_path_polarized(-1:1,j,:), &
                    & sps_path(c_inds(j),:) ) * tanh1_c(j) + &
                    & 0.25 * alpha_path_c(j)
                  alpha_path_polarized(0,j) = alpha_path_polarized(0,j) + &
                    & 0.25 * alpha_path_c(j)
                end do
              end if
a1896 2
            & gl_slabs_m, t_path_m,                                   &
            & gl_slabs_p, t_path_p,                                   &
d1898 1
a1898 2
            & beta_n_path_f, dbeta_dw_path_f,                         &
            & dbeta_dn_path_f, dbeta_dv_path_f )
d1920 2
a1921 3
                & do_gl(1:npc), incoptdepth(1:npc), alpha_path_f(1:ngl),   &
                & dsdz_gw_path, t_script(1:npc),  &
                & tau(1:npc), RadV(frq_i), i_stop )
d1927 2
a1928 2
            ! get the corrections to integrals for layers that need gl for
            ! the polarized species
d1930 2
a1931 1
              & gl_slabs, gl_inds(:ngl), beta_path_polarized_f )
d1933 11
a1943 20
            ! The explicit -1:1 is written in the hope that a clever compiler
            ! can exploit it to optimize.
            if ( any_der ) then
              ! Will need beta_path_polarized_f * tanh1_f
              do j = 1, ngl
                beta_path_polarized_f(-1:1,j,:) = beta_path_polarized_f(-1:1,j,:) * tanh1_f(j)
                alpha_path_polarized_f(-1:1,j) = matmul( beta_path_polarized_f(-1:1,j,:), &
                  & sps_path(gl_inds(j),:) ) + 0.25 * alpha_path_f(j)
                alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) + &
                  & 0.25 * alpha_path_f(j)
              end do
            else
              ! Won't need beta_path_polarized_f * tanh1_f
              do j = 1, ngl
                alpha_path_polarized_f(-1:1,j) = matmul( beta_path_polarized_f(-1:1,j,:), &
                  & sps_path(gl_inds(j),:) ) * tanh1_f(j) + 0.25 * alpha_path_f(j)
                alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) + &
                  & 0.25 * alpha_path_f(j)
              end do
            end if
d1945 6
a1950 6
            call rad_tran_pol ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty,         &
              & del_zeta(1:npc), alpha_path_polarized(:,1:npc), ref_corr(1:npc), &
              & do_gl(1:npc), incoptdepth_pol(:,:,1:npc), deltau_pol(:,:,1:npc), &
              & alpha_path_polarized_f(:,1:ngl), dsdz_gw_path,                   &
              & ct, stcp, stsp, t_script(1:npc),  prod_pol(:,:,1:npc),           &
              & tau_pol(:,:,1:npc), rad_pol, p_stop )
d2021 4
a2024 6
            sps_beta_dbeta_c(:npc) = SUM(sps_path(c_inds(1:npc),:) * &
              &                          beta_path_c(1:npc,:) * &
              &                          beta_n_path_c(1:npc,:),DIM=2)
            sps_beta_dbeta_f(:ngl) = SUM(sps_path(gl_inds(1:ngl),:) * &
              &                          beta_path_f(1:ngl,:) * &
              &                          beta_n_path_f(1:ngl,:),DIM=2)
d2029 2
a2030 2
                & t_path_c(1:npc), dh_dt_path_c(1:npc,:),                     &
                & alpha_path_c(1:npc), sps_beta_dbeta_c(:npc),                &
d2036 1
a2036 1
                & sps_beta_dbeta_f(:ngl), eta_zxp_t_f(:ngl,:),                &
d2048 25
a2072 5
              call get_d_deltau_pol_dT ( frq, h, ct, stcp, stsp,              &
                & beta_group, gl_slabs_m, gl_slabs_p,                         &
                & t_path_c(1:p_stop), t_path_m(1:no_ele), t_path_p(1:no_ele), &
                & t_path_f(:ngl), beta_path_polarized(:,1:p_stop,:),          &
                & beta_path_polarized_f(:,1:ngl,:), sps_path,                 &
d2075 2
a2076 1
                & sps_beta_dbeta_c(:npc), sps_beta_dbeta_f(:ngl), &
d2078 1
a2078 1
                & c_inds(1:p_stop), gl_inds(:ngl), del_zeta(1:npc),           &
a2522 2
        call DestroyCompleteSlabs ( gl_slabs_p )
        call DestroyCompleteSlabs ( gl_slabs_m )
a2669 2
    call deallocate_test ( sps_beta_dbeta_c, 'sps_beta_dbeta_c', moduleName )
    call deallocate_test ( sps_beta_dbeta_f, 'sps_beta_dbeta_f', moduleName )
d2710 6
a2715 4
      call deallocate_test ( beta_n_path_c,   'beta_n_path_c',   moduleName )
      call deallocate_test ( beta_n_path_f,   'beta_n_path_f',   moduleName )
      call deallocate_test ( d_t_scr_dt,      'd_t_scr_dt',      moduleName )
      call deallocate_test ( dRad_dt,         'dRad_dt',         moduleName )
a2716 1
      call deallocate_test ( dh_dt_path_c,    'dh_dt_path_c',    moduleName )
d2718 1
d2720 1
a2720 1
      call deallocate_test ( do_calc_hyd_c,   'do_calc_hyd_c',   moduleName )
a2721 1
      call deallocate_test ( do_calc_t_c,     'do_calc_t_c',     moduleName )
d2723 1
d2726 4
a2730 1
      call deallocate_test ( eta_zxp_t_c,     'eta_zxp_t_c',     moduleName )
d2732 1
a2733 4
      call deallocate_test ( tan_d2h_dhdt,    'tan_d2h_dhdt',    moduleName )
      call deallocate_test ( dxdt_tan,        'dxdt_tan',        moduleName )
      call deallocate_test ( d2xdxdt_tan,     'd2xdxdt_tan',     moduleName )
      call deallocate_test ( dxdt_surface,    'dxdt_surface',    moduleName )
d2822 6
a2850 3
    call deallocate_test ( sps_beta_dbeta_c, 'sps_beta_dbeta', moduleName )
    call deallocate_test ( sps_beta_dbeta_f, 'sps_beta_dbeta', moduleName )

d3058 3
@


2.204
log
@Get catalog from slabs structure
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.203 2004/03/31 20:35:26 jonathan Exp $"
a106 1
    real(r8), dimension(:), pointer :: temp_prof
d560 1
a560 1
      & tan_phi, tan_temp, tau, tau_pol, temp_prof, t_der_path_flags, t_glgrid, &
a773 8
      call allocate_test ( temp_prof, n_t_zeta, 'temp_prof', moduleName )
      call allocate_test ( gph_prof, n_t_zeta, 'gph_prof', moduleName )
     
      do i=1, n_t_zeta
        temp_prof(i) = temp%values(i,inst)
        gph_prof(i)  = GPH%values(i,inst)
      enddo

d1674 1
a1674 1
            ! Compute Scattering source function based on temp_prof at all
d1680 1
a1680 1
              call T_scat ( temp_prof, Frq, gph_prof,                        & 
d3072 3
@


2.203
log
@bug fix in handling clouds
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.202 2004/03/30 02:26:17 livesey Exp $"
d561 3
a563 3
      & tan_phi, tan_temp, tau, tau_pol, temp_prof,t_der_path_flags, t_glgrid, t_path, &
      & t_path_c, t_path_f, t_path_m, t_path_p, true_path_flags, tscat_path, &
      & t_script, tt_path, tt_path_c, &
d1843 1
a1843 1
              call get_beta_path_polarized ( frq, h, my_Catalog(thisSideband,:), beta_group, &
d1942 1
a1942 1
            & w0_path_c(1:npc), spaceRadiance%values(1,1), frq,            &
d1964 2
a1965 2
            call get_beta_path_polarized ( frq, h, my_Catalog(thisSideband,:), &
              & beta_group, gl_slabs, gl_inds(:ngl), beta_path_polarized_f )
d2094 1
a2094 1
                & my_catalog(thisSideband,:), beta_group, gl_slabs_m, gl_slabs_p, &
d3081 3
@


2.202
log
@Bug fix in Jonathan's w0 handling
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.201 2004/03/30 02:00:36 vsnyder Exp $"
d107 2
d552 1
a552 1
      & f_inds, frequencies, gl_delta_polarized, gl_inds, gph, grids, &
d561 1
a561 1
      & tan_phi, tan_temp, tau, tau_pol, t_der_path_flags, t_glgrid, t_path, &
d715 3
a724 6
      call allocate_test ( scat_src%values, n_t_zeta, &
      & fwdModelConf%num_scattering_angles, 'scat_src', moduleName )

      call allocate_test ( scat_alb%values, n_t_zeta, 2, 'scat_alb', moduleName )
      call allocate_test (  cld_ext%values, n_t_zeta, 2, 'cld_ext', moduleName )

d775 9
a783 1
    end if
d990 3
a992 1
    if ( fwdModelConf%Incl_Cld ) then
d999 7
d1007 1
d1679 1
a1679 1
          do_gl = .false.
d1681 1
a1681 3
          do_cld = .true. !JJ !for Jonathan use Only

          if ( FwdModelConf%incl_cld ) then
d1687 1
a1687 1
            call allocate_test ( Scat_ang, fwdModelConf%num_scattering_angles, 'Scat_ang', moduleName )
d1689 7
a1695 7
            call T_scat ( temp%values(:,inst), Frq, GPH%values(:,inst), &
            & 10.0**(-temp%template%surfs), vmrArray, nspec,            &
            & fwdModelConf%num_scattering_angles,                       &
            & fwdModelConf%num_azimuth_angles,                          &
            & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,    &
            & fwdModelConf%no_cloud_species,                            &
            & scat_src%values, scat_alb%values, cld_ext%values, Scat_ang)
d1697 1
a1697 1
            call Deallocate_test ( vmrArray,'vmrArray',ModuleName )
a1705 1

a1707 1

a1709 1
                        
a1747 1

a1749 1

a1750 1

a1751 1

d1780 1
a1780 1

d1795 19
d1823 1
a1823 6
            ! Determine where to use Gauss-Legendre instead of a trapezoid.

            call path_contrib ( incoptdepth(1:npc), e_rflty, &
              & fwdModelConf%tolerance, do_gl(1:npc) )
          
          else ! Not cloud model
a1827 1

a1828 1

d1831 1
d1833 1
a1833 1
            end do
a1900 2
          end if   ! end of check cld 

d2665 1
a2706 6
    call deallocate_test ( do_calc_tscat,    'do_calc_tscat',    moduleName )
    call deallocate_test ( do_calc_tscat_zp, 'do_calc_tscat_zp', moduleName )
    call deallocate_test ( do_calc_salb,     'do_calc_salb',     moduleName )
    call deallocate_test ( do_calc_salb_zp,  'do_calc_salb_zp',  moduleName )
    call deallocate_test ( do_calc_cext,     'do_calc_salb',     moduleName )
    call deallocate_test ( do_calc_cext_zp,  'do_calc_salb_zp',  moduleName )
a2710 6
    call deallocate_test ( eta_tscat,        'eta_tscat',        moduleName )
    call deallocate_test ( eta_tscat_zp,     'eta_tscat_zp',     moduleName )
    call deallocate_test ( eta_salb,         'eta_salb',         moduleName )
    call deallocate_test ( eta_salb_zp,      'eta_salb_zp',      moduleName )
    call deallocate_test ( eta_cext,         'eta_cext',         moduleName )
    call deallocate_test ( eta_cext_zp,      'eta_cext_zp',      moduleName )
a2713 4
    call deallocate_test ( tscat_path,       'tscat_path',       moduleName )
    call deallocate_test ( tt_path,          'tt_path',          moduleName )
    call deallocate_test ( salb_path,        'salb_path',        moduleName )
    call deallocate_test ( cext_path,        'cext_path',        moduleName )
d3081 3
@


2.201
log
@Remove USE for unreferenced symbol.  Don't try to fill tpath_m and
tpath_p if they're not allocated.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.200 2004/03/27 03:35:27 vsnyder Exp $"
d1923 1
a1923 1
            & w0_path_c, spaceRadiance%values(1,1), frq,            &
d3077 4
@


2.200
log
@Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
line centers and line widths around.  Write slabs_lines and slabswint_lines
to get sum of beta over all lines; put slabs_struct instead of its components
in the calling sequence.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.199 2004/03/20 04:05:50 vsnyder Exp $"
d61 1
a61 1
      & Load_Sps_Data, Modify_values_for_supersat, create_grids_1, fill_grids_1, create_grids_2, fill_grids_2
d1435 4
a1438 2
        t_path_m = t_path - del_temp ! for computing temperature derivatives
        t_path_p = t_path + del_temp ! for computing temperature derivatives
d3077 6
@


2.199
log
@Moved SpeedOfLight from units to physics
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.198 2004/03/20 01:15:16 jonathan Exp $"
d268 2
d305 2
d310 8
a317 6
    real(rp), dimension(:,:), pointer :: BETA_PATH_C ! Beta on path coarse
    real(rp), dimension(:),   pointer :: W0_PATH_C   ! w0 on path coarse
    real(rp), dimension(:),   pointer :: TT_PATH_C   ! tscat on path coarse
    real(r8), dimension(:,:), pointer :: VMRARRAY          ! The VMRs
    real(rp), dimension(:,:), pointer :: BETA_PATH_F ! Beta on path fine
    real(rp), dimension(:,:), pointer :: D_DELTA_DF ! Incremental opacity derivative
d320 1
a320 1
    real(rp), dimension(:,:), pointer :: D_T_SCR_dT  ! D Delta_B in some notes
d322 2
a323 2
    real(rp), dimension(:,:), pointer :: D2X_DXDT    ! (No_tan_hts, nz*np)
    real(rp), dimension(:,:), pointer :: DACsStaging ! Temporary space for DACS radiances
d326 2
a327 4
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_C ! n in beta = beta_0 (T/T_0)**n
                                           ! to compute dBeta_dt on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_F ! n in beta = beta_0 (T/T_0)**n
                                           ! to compute dBeta_dt on fine grid
a361 4
    real(rp), dimension(:,:), pointer :: Tscat_PATH   ! TScat on path
    real(rp), dimension(:,:), pointer :: TT_PATH      ! TScat on path along the LOS
    real(rp), dimension(:,:), pointer :: Salb_PATH    ! Single Scattering Albedo on path
    real(rp), dimension(:,:), pointer :: Cext_PATH    ! Cloud extinction on path
d369 1
d373 3
d528 7
a534 7
      & alpha_path_polarized_f, beta_path_c, beta_path_cloud_c, beta_path_f, &
      & beta_path_polarized, cext_path, cg_inds, c_inds, &
      & cld_ext%values, closestInstances, d2x_dxdt, d2xdxdt_surface, &
      & d2xdxdt_tan, DACsStaging, DACsStaging2, dbeta_dn_path_c, &
      & dbeta_dn_path_f, dbeta_dt_path_c, dbeta_dt_path_f, dbeta_dv_path_c, &
      & dbeta_dv_path_f, dbeta_dw_path_c, dbeta_dw_path_f, d_delta_df, &
      & ddhidhidtl0, de_df, de_dt, del_s, deltau_pol, del_zeta, &
d543 2
a544 1
      & drad_dw, d_rad_pol_df, d_rad_pol_dt, dsdz_gw_path, d_t_scr_dt, &
a969 2
    call allocate_test ( t_path_m,        max_ele, 't_path_m',         moduleName )
    call allocate_test ( t_path_p,        max_ele, 't_path_p',         moduleName )
d999 4
a1005 4
      call allocate_test ( dbeta_dt_path_c,    npc, no_mol,   'dbeta_dt_path_c', &
                                                              & moduleName )
      call allocate_test ( dbeta_dt_path_f, max_ele, no_mol,   'dbeta_dt_path_f', &
                                                              & moduleName )
d1022 2
d1034 2
d1204 2
a1205 1
      call allocateSlabs ( gl_slabs, max_ele, my_catalog(thisSideband,:), moduleName )
d1207 4
a1210 2
        call allocateSlabs ( gl_slabs_p, max_ele, my_catalog(thisSideband,:), moduleName )
        call allocateSlabs ( gl_slabs_m, max_ele, my_catalog(thisSideband,:), moduleName )
a1578 4
        call get_gl_slabs_arrays ( my_Catalog(thisSideband,:), p_path(1:no_ele), &
          &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs, &
          &  fwdModelConf%Do_1D, true_path_flags(1:no_ele) )

d1580 12
a1591 6
          call get_gl_slabs_arrays ( my_Catalog(thisSideband,:), p_path(1:no_ele), &
            &  t_path_p(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_p, &
            &  fwdModelConf%Do_1D, t_der_path_flags(1:no_ele) )
          call get_gl_slabs_arrays ( my_Catalog(thisSideband,:), p_path(1:no_ele), &
            &  t_path_m(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_m, &
            &  fwdModelConf%Do_1D, t_der_path_flags(1:no_ele) )
d1639 4
d1652 1
a1652 2
            &  my_Catalog(thisSideband,:), beta_group,            &
            &  FwdModelConf%polarized,                            &
d1654 4
a1657 4
            &  gl_slabs_m, t_path_m(1:no_ele),                    &
            &  gl_slabs_p, t_path_p(1:no_ele),                    &
            &  t_der_path_flags,                                  &
            &  dbeta_dt_path_c, dbeta_dw_path_c,                  &
d1893 4
d1905 1
a1905 2
            & my_Catalog(thisSideband,:), beta_group,                 &
            & FwdModelConf%polarized,                                 &
d1907 4
a1910 4
            & gl_slabs_m, t_path_m(1:no_ele),                         &
            & gl_slabs_p, t_path_p(1:no_ele),                         &
            & t_der_path_flags,                                       &
            & dbeta_dt_path_f, dbeta_dw_path_f,                       &
d2045 1
a2045 1
              &                          dbeta_dt_path_c(1:npc,:),DIM=2)
d2048 1
a2048 1
              &                          dbeta_dt_path_f(1:ngl,:),DIM=2)
d2732 2
a2735 2
      call deallocate_test ( dbeta_dt_path_c, 'dbeta_dt_path_c', moduleName )
      call deallocate_test ( dbeta_dt_path_f, 'dbeta_dt_path_f', moduleName )
d2744 2
d3075 3
@


2.198
log
@add in scattering correction term in two t_script
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.196 2004/03/01 19:22:14 jonathan Exp $"
d81 1
a81 1
    use Physics, only: H_OVER_K
d94 1
a94 1
    use Units, only: Deg2Rad, SpeedOfLight
a313 3
!    real(rp), dimension(:,:), pointer :: D_DELTA_DT ! Incremental opacity derivative
!                                           ! schlep from drad_tran_dt to
!                                           ! get_d_deltau_pol_dt.  Path x SVE.
d3055 3
@


2.197
log
@Remove D_Delta_DT, which was schlepped from drad_tran_dt to
Get_D_Delta_Pol_DT, but is no longer needed in the latter place.
@
text
@d84 1
a84 1
      & DRAD_TRAN_DX, RAD_TRAN_CLD
d186 1
d314 3
d484 1
d721 2
a722 2
      call allocate_test ( scat_alb%values, n_t_zeta, 1, 'scat_alb', moduleName )
      call allocate_test (  cld_ext%values, n_t_zeta, 1, 'cld_ext', moduleName )
d1650 2
d1653 1
d1675 1
a1675 1
            call allocate_test ( do_calc_tscat, max_ele, size(grids_tscat%values),              &
d1678 1
a1678 1
            call allocate_test ( do_calc_tscat_zp, max_ele, grids_tscat%p_len,                  &
d1681 1
a1681 1
            call allocate_test ( eta_tscat,     max_ele, size(grids_tscat%values),              &
d1684 1
a1684 1
            call allocate_test ( eta_tscat_zp,  max_ele, grids_tscat%p_len,                     &
d1686 1
a1686 1
            call allocate_test ( tscat_path,    max_ele, fwdModelConf%num_scattering_angles, &
d1699 1
a1699 1
            call allocate_test ( tt_path, max_ele, 1, 'tt_path', moduleName )
a1701 1

d1707 31
a1737 14
              cld_ext%template = temp%template

              call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false. )
              call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false. )

              call allocate_test (do_calc_salb,max_ele,size(grids_salb%values),'do_calc_salb',moduleName)
              call allocate_test (eta_salb, max_ele, size(grids_salb%values), 'eta_salb', moduleName)
              call allocate_test (eta_salb_zp,  max_ele, grids_salb%p_len, 'eta_salb_zp', moduleName)
              call allocate_test ( salb_path,    max_ele, 1, 'salb_path', moduleName )

              call allocate_test (do_calc_cext,max_ele,size(grids_cext%values),'do_calc_cext',moduleName)
              call allocate_test (eta_cext, max_ele, size(grids_cext%values), 'eta_cext', moduleName)
              call allocate_test (eta_cext_zp, max_ele, grids_cext%p_len,  'eta_cext_zp', moduleName)
              call allocate_test (cext_path,  max_ele, 1, 'cext_path', moduleName)
d1745 2
a1746 2
                & Frq, eta_zp(1:no_ele,:), &
                & do_calc_zp(1:no_ele,:), salb_path(1:no_ele,:),      &
d1755 2
a1756 2
                & Frq, eta_zp(1:no_ele,:), &
                & do_calc_zp(1:no_ele,:), cext_path(1:no_ele,:),      &
d1766 4
a1769 4
              call get_beta_path_cloud ( Frq,                              &
                &  p_path(1:no_ele), t_path(1:no_ele),                     &
                &  beta_group, c_inds(1:npc), beta_path_cloud_c(1:npc),    &
                &  w0_path_c(1:npc),        &
d1786 1
a1786 1

d1794 4
d1905 3
a1907 2
          call two_d_t_script ( t_path_c(1:npc), spaceRadiance%values(1,1), &
            & frq, t_script(1:npc) )
d1911 1
a1915 2
            if ( .not. FwdModelConf%incl_cld ) then        ! Clear Sky Rad

a1921 10
            else                                           ! Include scattering source

              call rad_tran_cld ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty, &
                & del_zeta(1:npc), alpha_path_c(1:npc), ref_corr(1:npc),   &
                & do_gl(1:npc), incoptdepth(1:npc), alpha_path_f(1:ngl),   &
                & dsdz_gw_path, t_script(1:npc),tau(1:npc), RadV(frq_i),   &
                & i_stop, tt_path_c(1:npc), w0_path_c(1:npc)  )

            end if

a1924 1

@


2.196
log
@following the changes made to load_one_item
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.195 2004/02/14 00:23:48 vsnyder Exp $"
a312 3
    real(rp), dimension(:,:), pointer :: D_DELTA_DT ! Incremental opacity derivative
                                           ! schlep from drad_tran_dt to
                                           ! get_d_deltau_pol_dt.  Path x SVE.
d528 1
a528 1
      & d_delta_dt, ddhidhidtl0, de_df, de_dt, del_s, deltau_pol, del_zeta, &
a996 2
      call allocate_test ( d_delta_dt,         npc, sv_t_len, 'd_delta_dt', &
                                                              & moduleName )
d2031 1
a2031 1
                & grids_tmp%deriv_flags, d_delta_dt(1:npc,:), drad_dt )
d2056 1
a2056 1
                & d_delta_dt(1:p_stop,:), de_dt(:,:,1:p_stop,:) )
a2699 1
      call deallocate_test ( d_delta_dt,      'd_delta_dt',      moduleName )
d3041 3
@


2.195
log
@New DACS convolution algorithm
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.194 2004/02/05 23:30:01 livesey Exp $"
d61 1
a61 1
      & Load_Sps_Data, Modify_values_for_supersat
d1654 1
d1674 4
d1680 1
d1692 2
a1693 2
              & Frq, eta_zp(1:no_ele,:), &
              & do_calc_zp(1:no_ele,:), tscat_path(1:no_ele,:),      &
d1699 1
d1843 1
a1843 1
          end if
d3047 3
@


2.194
log
@Finally implemented code to do correct handing of sideband fraction in
single sideband radiometers.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.193 2004/02/03 02:48:35 vsnyder Exp $"
d658 2
a659 1
      & call load_one_item_grid ( grids_iwc, cloudIce, phitan, maf, fwdModelConf, .false., .false. )
d662 2
a663 1
      & call load_one_item_grid ( grids_mag, magfield, phitan, maf, fwdModelConf, .false. )
d1668 2
a1669 1
            call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, fwdModelConf, .false., .true. )
d2000 1
d2150 1
a2150 5
            call Freq_Avg_DACS ( frequencies, &
              & DACSFilterShapes(shapeInd)%filterGrid, &
              & DACSFilterShapes(shapeInd)%filterShape, &
              & DACSFilterShapes(shapeInd)%LO_Apod, &
              & DACSFilterShapes(shapeInd)%CH_Norm, &
d2190 1
a2190 5
                  call Freq_Avg_DACS ( frequencies, &
                    & DACSFilterShapes(shapeInd)%filterGrid, &
                    & DACSFilterShapes(shapeInd)%filterShape, &
                    & DACSFilterShapes(shapeInd)%LO_Apod, &
                    & DACSFilterShapes(shapeInd)%CH_Norm, &
d2239 1
a2239 5
                    call Freq_Avg_DACS ( frequencies, &
                      & DACSFilterShapes(shapeInd)%filterGrid, &
                      & DACSFilterShapes(shapeInd)%filterShape, &
                      & DACSFilterShapes(shapeInd)%LO_Apod, &
                      & DACSFilterShapes(shapeInd)%CH_Norm, &
d2864 1
a2864 5
                call Freq_Avg_DACS ( frequencies, &
                  & DACSFilterShapes(shapeInd)%filterGrid, &
                  & DACSFilterShapes(shapeInd)%filterShape, &
                  & DACSFilterShapes(shapeInd)%LO_Apod, &
                  & DACSFilterShapes(shapeInd)%CH_Norm, &
d3040 4
@


2.193
log
@Progress (hopefully) on polarized temperature derivatives.
Implement DACs frequency convolution.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.188 2003/12/01 17:24:05 jonathan Exp $"
d2367 1
a2367 5
        if ( fwdModelConf%sidebandStart /= fwdModelConf%sidebandStop &
          & .or. fwdModelConf%forceSidebandFraction ) then   ! We're folding
          ! Here it is Van - NJL !????
          ! Change to this if statement at some later stage
          ! if ( firstSignal%sideband == 0 .or. fwdModelConf%forceSidebandFraction ) then
d3052 4
@


2.192
log
@add an extra-flag for tscat in load_one_item
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.191 2003/12/08 21:38:33 jonathan Exp $"
d39 1
a39 1
    use FilterShapes_m, only: FilterShapes
d44 1
a44 1
    use Freq_Avg_m, only: Freq_Avg
d46 1
a46 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, & 
d61 1
a61 1
      & Load_Sps_Data, Modify_values_for_supersat                    
d68 1
a68 1
    use MLSCommon, only: R4, R8, RP, IP
d74 3
a76 5
    use Molecules, only: L_H2O, L_O3, L_N2O, L_HNO3, L_N2, &
                       & L_O2, FIRST_MOLECULE,             &
                       & L_H2O_18, L_O_18_O,               &
                       & LAST_MOLECULE,                    &
                       & L_Extinction ! Used in include dump_print_code.f9h
d86 1
a86 1
    use ScatSourceFunc, only: T_SCAT,  Interp_Tscat,  Convert_Grid         
d94 1
a94 1
    use Units, only: Deg2Rad, SpeedOfLight, Pi
d105 2
a106 2
    real(r8), dimension(:,:), pointer :: WC       
    real(r8), dimension(:), pointer :: Scat_ang   
d157 1
d179 1
a179 1
    integer :: novmrSurf                ! Number of vmr levels  
d182 1
a182 1
    integer, dimension(:), pointer :: closestInstances 
d184 2
a187 1
    logical :: cld_fine = .false.
d190 1
a190 1
    character (len=32) :: molName       ! Name of a molecule  
a195 1
    integer, dimension(:), pointer :: CHANNELORIGINS ! Does this band start at 0 or 1
d201 2
a202 2
    integer, dimension(:), pointer :: USEDCHANNELS ! Which channel is this
    integer, dimension(:), pointer :: USEDSIGNALS ! Which signal is this channel from
d216 4
a219 4
    logical, dimension(:,:), pointer :: DO_CALC_IWC   ! 'Avoid zeros' indicator  
    logical, dimension(:,:), pointer :: DO_CALC_Tscat ! 'Avoid zeros' indicator  
    logical, dimension(:,:), pointer :: DO_CALC_Salb  ! 'Avoid zeros' indicator  
    logical, dimension(:,:), pointer :: DO_CALC_cext  ! 'Avoid zeros' indicator  
d226 5
a230 6
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP! 'Avoid zeros' indicator     
    logical, dimension(:,:), pointer :: DO_CALC_Tscat_ZP ! 'Avoid zeros' indicator  
    logical, dimension(:,:), pointer :: DO_CALC_Salb_ZP  ! 'Avoid zeros' indicator  
    logical, dimension(:,:), pointer :: DO_CALC_Cext_ZP  ! 'Avoid zeros' indicator  

    logical :: Got( FIRST_MOLECULE : LAST_MOLECULE )  !                             
d255 1
a255 1
    real(rp), dimension(:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse   
d308 1
a308 1
    real(r8), dimension(:,:), pointer :: VMRARRAY          ! The VMRs   
d319 1
d322 4
a325 2
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_C ! dBeta_dt on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_F ! dBeta_dt on fine grid
d340 4
a343 4
    real(rp), dimension(:,:), pointer :: ETA_Salb     ! 
    real(rp), dimension(:,:), pointer :: ETA_Salb_ZP  ! 
    real(rp), dimension(:,:), pointer :: ETA_Cext     ! 
    real(rp), dimension(:,:), pointer :: ETA_Cext_ZP  ! 
d359 5
a363 5
    real(rp), dimension(:,:), pointer :: IWC_PATH     ! IWC on path   
    real(rp), dimension(:,:), pointer :: Tscat_PATH   ! TScat on path   
    real(rp), dimension(:,:), pointer :: TT_PATH      ! TScat on path along the LOS   
    real(rp), dimension(:,:), pointer :: Salb_PATH    ! Single Scattering Albedo on path   
    real(rp), dimension(:,:), pointer :: Cext_PATH    ! Cloud extinction on path   
d377 2
d431 1
a431 1
    type (VectorValue_T), pointer :: GPH           ! Geopotential height 
d440 1
a440 1
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really   
d444 1
a444 1
    type (VectorValue_T), pointer :: VMR           ! Quantity  
d458 1
a458 1
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC     
d461 3
a463 3
    type (Grids_T) :: Grids_Tscat ! All the coordinates for scaterring source function 
    type (Grids_T) :: Grids_Salb ! All the coordinates for single scaterring albedo 
    type (Grids_T) :: Grids_Cext ! All the coordinates for cloud extinction 
d490 11
a500 3
    type (VectorValue_T) :: scat_src     
    type (VectorValue_T) :: scat_alb    
    type (VectorValue_T) :: cld_ext     
d502 2
d517 2
d524 35
a558 39
    nullify (alpha_path_c, alpha_path_f, alpha_path_polarized, &
      & alpha_path_polarized_f, beta_path_c, beta_path_cloud_c, &
      & w0_path_c, tt_path_c, beta_path_f, beta_path_polarized, &
      & c_inds, cg_inds, channelOrigins, closestInstances, &
      & d_rad_pol_df, d_rad_pol_dt, d_delta_df, d_delta_dt, d_t_scr_dt, &
      & d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
      & dbeta_dn_path_c, dbeta_dn_path_f, dbeta_dt_path_c, dbeta_dt_path_f, &
      & dbeta_dv_path_c, dbeta_dv_path_f, dbeta_dw_path_c, dbeta_dw_path_f, &
      & ddhidhidtl0, de_df, de_dt, del_s, del_zeta, deltau_pol, &
      & dh_dt_glgrid, dh_dt_path, dh_dt_path_f, dh_dt_path_c, &
      & dhdz_glgrid, dhdz_out, dhdz_path, dhdz_gw_path, dincoptdepth_pol_dt, &
      & do_calc_dn, do_calc_dn_c, do_calc_dn_F, &
      & do_calc_dv, do_calc_dv_c, do_calc_dv_f, &
      & do_calc_dw, do_calc_dw_c, do_calc_dw_f, &
      & do_calc_fzp, do_calc_iwc, do_calc_hyd, do_calc_hyd_c, &
      & do_calc_t, do_calc_t_c, do_calc_t_f, &
      & do_calc_tscat, do_calc_tscat_zp, do_calc_Salb, do_calc_Salb_zp,  do_calc_Cext, do_calc_Cext_zp, &
      & do_calc_zp, do_calc_iwc_zp, do_gl, &
      & drad_dn, drad_dt, drad_dv, drad_dw, dsdz_gw_path, dx_dh_out, dx_dt, &
      & dxdt_surface, dxdt_tan, eta_fzp, eta_iwc, &
      & eta_tscat, eta_tscat_zp, eta_salb, eta_salb_zp, eta_cext, eta_cext_zp,  &
      & eta_zp, eta_iwc_zp, eta_mag_zp, eta_zxp_dn, eta_zxp_dn_c, eta_zxp_dn_f, &
      & eta_zxp_dv, eta_zxp_dv_c, eta_zxp_dv_f, &
      & eta_zxp_dw, eta_zxp_dw_c, eta_zxp_dw_f, &
      & eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, f_inds, frequencies, &
      & gl_delta_polarized, gl_inds, gph, grids, &
      & h_glgrid, h_path, h_path_c, h_path_f, &
      & incoptdepth, incoptdepth_pol, incoptdepth_pol_gl, ipsd, iwc_path, &
      & k_atmos, k_atmos_frq, k_spect_dn, k_spect_dn_frq, &
      & k_spect_dv, k_spect_dv_frq, k_spect_dw, k_spect_dw_frq, k_temp, &
      & k_temp_frq, mag_path, mol_cat_index, n_path, path_dsdh, &
      & p_path, p_path_c, phi_path, prod_pol, ptg_angles, &
      & radiances, RadV, ref_corr, req_out, scat_src%values, scat_alb%values, cld_ext%values, &
      & scat_ang, sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, &
      & tan_chi_out, tan_d2h_dhdt, tan_dh_dt, &
      & tan_phi, tan_temp, tanh1_c, tanh1_f, tau, &
      & tau_pol, t_glgrid, t_path, t_path_c, t_path_f, t_path_m, t_path_p, &
      & tscat_path,  tt_path, salb_path, cext_path, t_script, t_der_path_flags, true_path_flags, &
      & usedchannels, usedsignals, vmr, vmrarray, wc, z_path )
d621 1
a621 1
    if ( FwdModelConf%incl_cld ) then          
d649 1
a649 1
    call load_one_item_grid ( grids_tmp, temp, phitan, maf, fwdModelConf, .true., .false. )
d657 1
a657 1
    if ( FwdModelConf%incl_cld ) & 
d661 1
a661 2
      & call load_one_item_grid ( grids_mag, magfield, phitan, maf, &
        & fwdModelConf, .false., .false. )
d663 2
a664 1
! Work out which channels are used; also check we have radiances for them.
d666 1
d678 5
a682 6
    call allocate_test ( usedChannels, noUsedChannels, &
      & 'usedChannels', moduleName )
    call allocate_test ( channelOrigins, noUsedChannels, &
      & 'channelOrigins', moduleName )
    call allocate_test ( usedSignals, noUsedChannels, &
      & 'usedSignals', moduleName )
d687 1
a687 1
          channelOrigins(channel) = &
d689 3
a691 2
          usedChannels(channel) = i + channelOrigins(channel) - 1
          usedSignals(channel) = sigInd
d710 1
a710 1
      & 'closestInstances', ModuleName )      
d728 1
a728 1
      noSurf  = temp%template%noSurfs     
d736 1
a736 1
        case ( L_H2O, L_O3, L_N2O ) 
d762 1
a762 1
        end select      
d766 1
a766 1
      !make sure we have at least two molecules h2o and o3. 
d785 1
a785 1
    
d934 3
a936 3
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path_cloud_c',moduleName ) 
    call allocate_test ( w0_path_c,           npc, 'w0_path_c',        moduleName ) 
    call allocate_test ( tt_path_c,           npc, 'tt_path_c',        moduleName ) 
d979 1
a979 1
    if ( fwdModelConf%Incl_Cld ) then 
d1043 2
a1044 1
      !??? Temperature's windowStart:windowFinish are probably not correct here ???
d1117 6
d1240 2
a1241 2
          sigInd = usedSignals(i)
          channel = usedChannels(i)
d1259 1
a1259 1
          direction = fwdModelConf%signals(usedSignals(channel))%direction
d1261 3
a1263 3
            & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
            & direction * fwdModelConf%signals(usedSignals(channel))% &
            & frequencies(usedChannels(channel))
d1285 1
a1285 1
                             &  moduleName )
d1292 1
a1292 1
        call allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_dw , &
d1294 1
a1294 1
        call allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_dn , &
d1296 1
a1296 1
        call allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_dv , &
d1300 8
d1477 1
a1477 1
          WC(2,1:no_ele)=0.  
a1609 1
        ! Loop over frequencies ----------------------------------------------
d1613 2
d1635 5
a1639 4
          call get_beta_path ( Frq,                               &    
            &  p_path(1:no_ele), t_path_c(1:npc), tanh1_c(1:npc), &    
            &  my_Catalog(thisSideband,:), beta_group, FwdModelConf%polarized,    &    
            &  gl_slabs, c_inds(1:npc), beta_path_c(1:npc,:),     &    
d1643 2
a1644 2
            &  dbeta_dt_path_c, dbeta_dw_path_c,                  &    
            &  dbeta_dn_path_c, dbeta_dv_path_c )                    
d1648 1
a1648 1
          if ( FwdModelConf%incl_cld ) then    
a1667 3
            print*, grids_tscat%values
            stop

d1675 1
a1675 1
                                 & 'tscat_path',  moduleName )            
d1687 1
a1687 3
            

            call allocate_test ( tt_path, max_ele, 1, 'tt_path', moduleName )            
d1694 2
a1695 2
            scat_alb%template = temp%template
            cld_ext%template = temp%template
d1697 2
a1698 2
            call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false., .false. )
            call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false., .false. )
d1700 34
a1733 13
            call allocate_test (do_calc_salb,max_ele,size(grids_salb%values),'do_calc_salb',moduleName)
            call allocate_test (eta_salb, max_ele, size(grids_salb%values), 'eta_salb', moduleName)
            call allocate_test (eta_salb_zp,  max_ele, grids_salb%p_len, 'eta_salb_zp', moduleName)
            call allocate_test ( salb_path,    max_ele, 1, 'salb_path', moduleName )            

            call allocate_test (do_calc_cext,max_ele,size(grids_cext%values),'do_calc_cext',moduleName)
            call allocate_test (eta_cext, max_ele, size(grids_cext%values), 'eta_cext', moduleName)
            call allocate_test (eta_cext_zp, max_ele, grids_cext%p_len,  'eta_cext_zp', moduleName)
            call allocate_test (cext_path,  max_ele, 1, 'cext_path', moduleName)            

            call comp_eta_docalc_no_frq ( Grids_salb, z_path(1:no_ele), &
              &  phi_path(1:no_ele), eta_salb_zp(1:no_ele,:), &
              &  do_calc_salb_zp(1:no_ele,:) )
d1735 1
a1735 5
            Frq=0.0
            call comp_sps_path_frq ( Grids_salb, firstSignal%lo, thisSideband, &
              & Frq, eta_zp(1:no_ele,:), &
              & do_calc_zp(1:no_ele,:), salb_path(1:no_ele,:),      &
              & do_calc_salb(1:no_ele,:), eta_salb(1:no_ele,:) )
d1737 5
a1741 3
            call comp_eta_docalc_no_frq ( Grids_cext, z_path(1:no_ele), &
              &  phi_path(1:no_ele), eta_cext_zp(1:no_ele,:), &
              &  do_calc_cext_zp(1:no_ele,:) )
d1743 1
a1743 20
            Frq=0.0
            call comp_sps_path_frq ( Grids_cext, firstSignal%lo, thisSideband, &
              & Frq, eta_zp(1:no_ele,:), &
              & do_calc_zp(1:no_ele,:), cext_path(1:no_ele,:),      &
              & do_calc_cext(1:no_ele,:), eta_cext(1:no_ele,:) )

            call convert_grid ( salb_path(1:no_ele,:), cext_path(1:no_ele,:),   &
                              & tt_path(1:no_ele,:), c_inds(1:npc),             &
                              & beta_path_cloud_c(1:npc), w0_path_c(1:npc),     &
                              & tt_path_c(1:npc) )
           
            else                           ! re-compute cext and w0 along the LOS
            
            call get_beta_path_cloud ( Frq,                              &
              &  p_path(1:no_ele), t_path(1:no_ele),                     &  
              &  beta_group, c_inds(1:npc), beta_path_cloud_c(1:npc),    &
              &  w0_path_c(1:npc),        &
              &  IPSD(1:no_ele),  WC(:,1:no_ele), fwdModelConf ) 

            endif
d1745 1
a1745 1
            do j = 1, npc 
d1781 1
a1781 1
              if ( temp_der .or. atmos_der ) then
d1783 1
a1783 1
                ! Add contributions from nonpolarized molecules 1/4 1/2 1/4 
d1794 1
a1794 1
                ! Add contributions from nonpolarized molecules 1/4 1/2 1/4 
d1818 1
a1818 1
                incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j) 
d1881 1
a1881 1
            if ( .not. FwdModelConf%incl_cld ) then        ! Clear Sky Rad 
d1888 1
a1888 1
              
d1897 1
a1897 1
            endif
d1911 1
a1911 1
            if ( temp_der .or. atmos_der ) then
d1977 1
a1977 1
         
a1996 1

a2010 14
            ! In the polarized case, drad_tran_dt calculates d_delta_dt for
            ! use in the polarized case, but the final derivative is not used.
            call drad_tran_dt ( del_zeta(1:npc ), h_path_c(1:npc),             &
              & t_path_c(1:npc), dh_dt_path_c(1:npc,:),                        &
              & alpha_path_c(1:npc), sps_beta_dbeta_c(:npc),                   &
              & eta_zxp_t_c(1:npc,:), do_calc_t_c(1:npc,:),                    &
              & do_calc_hyd_c(1:npc,:), del_s(1:npc), ref_corr(1:npc),         &
              & Req + one_tan_ht(1), dh_dt_path(brkpt,:), do_gl(1:npc),        &
              & gl_inds(1:ngl), h_path_f(:ngl), t_path_f(:ngl),                &
              & dh_dt_path_f(:ngl,:), alpha_path_f(1:ngl), sps_beta_dbeta_f(:ngl), &
              & eta_zxp_t_f(:ngl,:), do_calc_t_f(:ngl,:), path_dsdh,           &
              & dhdz_gw_path, dsdz_gw_path, t_script(1:npc), d_t_scr_dt(1:npc,:), &
              & tau(1:npc), i_stop, grids_tmp%deriv_flags,                     &
              & d_delta_dt(1:npc,:), drad_dt )
d2014 12
d2039 3
a2041 1
                & alpha_path_polarized(:,1:p_stop), alpha_path_polarized_f(:,1:ngl), &
d2120 1
a2120 1
          
d2127 1
a2127 1
        
d2142 12
d2155 16
a2170 12
            sigInd = usedSignals(i)
            channel = usedChannels(i)
            shapeInd = MatchSignal ( filterShapes%signal, &
              & fwdModelConf%signals(sigInd), sideband = thisSideband, &
              & channel=channel )
            if ( shapeInd == 0 ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              &    "No matching channel shape information" )
            call Freq_Avg ( frequencies, &
              &   FilterShapes(shapeInd)%FilterGrid,  &
              &   FilterShapes(shapeInd)%FilterShape, &
              &   RadV, Radiances(ptg_i,i) )
d2183 18
d2202 2
a2203 2
              sigInd = usedSignals(i)
              channel = usedChannels(i)
d2210 8
a2217 4
                  call Freq_Avg ( frequencies, &
                    & FilterShapes(shapeInd)%FilterGrid, &
                    & FilterShapes(shapeInd)%FilterShape, &
                    & k_temp_frq(:,sv_i), r )
d2238 14
d2253 2
a2254 2
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
d2260 8
a2267 4
                      call Freq_Avg ( frequencies,            &
                        & FilterShapes(shapeInd)%FilterGrid,  &
                        & FilterShapes(shapeInd)%FilterShape, &
                        & k_atmos_frq(1:noFreqs,sv_i), r )
d2304 2
d2325 1
a2325 1
      ! horizontal acording to Bill), that the rays crossed over
d2358 3
a2360 3
        channel = usedChannels(i)
        chanInd = channel + 1 - channelOrigins(i)
        sigInd = usedSignals(i)
d2502 6
a2507 2
      if ( temp_der ) &
        & call deallocate_test ( k_temp_frq, 'k_temp_frq', moduleName )
d2510 1
a2510 1
        & call deallocate_test ( k_atmos_frq, 'k_atmos_frq', moduleName )
d2517 3
a2519 6
      
      call DestroyCompleteSlabs ( gl_slabs )
      if ( temp_der ) then
        call DestroyCompleteSlabs ( gl_slabs_p )
        call DestroyCompleteSlabs ( gl_slabs_m )
      end if
d2564 2
a2565 2
        channel = usedChannels(i) - channelOrigins(i) + 1
        print "(/, 'ch', i3.3, '_pfa_rad\ ', i3.3 )", usedChannels(i), k
d2583 2
a2584 2
    call Deallocate_Test ( WC, 'WC', moduleName )        
    call Deallocate_Test ( Scat_ang, 'Scat_ang', moduleName )        
d2587 5
a2591 3
    call deallocate_test ( usedChannels, 'usedChannels', moduleName )
    call deallocate_test ( channelOrigins, 'channelOrigins', moduleName )
    call deallocate_test ( usedSignals, 'usedSignals', moduleName )
d2616 1
a2616 1
    call destroygrids_t ( grids_iwc )          
d2619 17
a2635 17
    call destroygrids_t ( grids_tscat )       
    call destroygrids_t ( grids_salb )        
    call destroygrids_t ( grids_cext )        

    call deallocate_test ( dhdz_path,    'dhdz_path',    moduleName )
    call deallocate_test ( dhdz_gw_path, 'dhdz_gw_path', moduleName )
    call deallocate_test ( dsdz_gw_path, 'dsdz_gw_path', moduleName )
    call deallocate_test ( h_path,       'h_path',       moduleName )
    call deallocate_test ( h_path_c,     'h_path_c',     moduleName )
    call deallocate_test ( h_path_f,     'h_path_f',     moduleName )
    call deallocate_test ( p_path,       'p_path',       moduleName )
    call deallocate_test ( p_path_c,     'p_path_c',     moduleName )
    call deallocate_test ( path_dsdh,    'path_dsdh',    moduleName )
    call deallocate_test ( phi_path,     'phi_path',     moduleName )
    call deallocate_test ( t_path,       't_path',       moduleName )
    call deallocate_test ( t_path_c,     't_path_c',     moduleName )
    call deallocate_test ( z_path,       'z_path',       moduleName )
d2640 2
a2641 2
    call deallocate_test ( beta_path_cloud_c,'beta_path_cloud_c',moduleName ) 
    call deallocate_test ( w0_path_c,        'w0_path_c',        moduleName )   
d2659 36
a2694 34
    call deallocate_test ( beta_path_f,   'beta_path_f',       moduleName )
    call deallocate_test ( do_calc_fzp,   'do_calc_fzp',       moduleName )
    call deallocate_test ( do_calc_iwc,   'do_calc_iwc',       moduleName ) 
    call deallocate_test ( do_calc_iwc_zp,'do_calc_iwc_zp',    moduleName )
    call deallocate_test ( do_calc_tscat,   'do_calc_tscat',   moduleName ) 
    call deallocate_test ( do_calc_tscat_zp,'do_calc_tscat_zp',moduleName )
    call deallocate_test ( do_calc_salb,   'do_calc_salb',     moduleName ) 
    call deallocate_test ( do_calc_salb_zp,'do_calc_salb_zp',  moduleName )
    call deallocate_test ( do_calc_cext,   'do_calc_salb',     moduleName ) 
    call deallocate_test ( do_calc_cext_zp,'do_calc_salb_zp',  moduleName )
    call deallocate_test ( do_calc_zp,    'do_calc_zp',        moduleName )
    call deallocate_test ( eta_fzp,       'eta_fzp',           moduleName )
    call deallocate_test ( eta_iwc,       'eta_iwc',           moduleName ) 
    call deallocate_test ( eta_iwc_zp,    'eta_iwc_zp',        moduleName ) 
    call deallocate_test ( eta_tscat,       'eta_tscat',       moduleName ) 
    call deallocate_test ( eta_tscat_zp,    'eta_tscat_zp',    moduleName )
    call deallocate_test ( eta_salb,       'eta_salb',         moduleName ) 
    call deallocate_test ( eta_salb_zp,    'eta_salb_zp',      moduleName )
     call deallocate_test ( eta_cext,       'eta_cext',        moduleName ) 
    call deallocate_test ( eta_cext_zp,    'eta_cext_zp',      moduleName )
    call deallocate_test ( eta_mag_zp,    'eta_mag_zp',        moduleName )
    call deallocate_test ( eta_zp,        'eta_zp',            moduleName )
    call deallocate_test ( iwc_path,      'iwc_path',          moduleName )     
    call deallocate_test ( tscat_path,    'tscat_path',        moduleName )
    call deallocate_test ( tt_path,       'tt_path',           moduleName )
    call deallocate_test ( salb_path,      'salb_path',        moduleName )
    call deallocate_test ( cext_path,      'cext_path',        moduleName )
    call deallocate_test ( mag_path,      'mag_path',          moduleName )
    call deallocate_test ( sps_path,      'sps_path',          moduleName )
    call deallocate_test ( true_path_flags,'true_path_flags',  moduleName )

    call deallocate_test ( tan_chi_out, 'tan_chi_out', moduleName )
    call deallocate_test ( dx_dh_out,   'dx_dh_out',   moduleName )
    call deallocate_test ( dhdz_out,    'dhdz_out',    moduleName )
d2749 23
a2771 23
      call deallocate_test ( do_calc_dw,   'do_calc_dw',   moduleName )
      call deallocate_test ( do_calc_dw_c, 'do_calc_dw_c', moduleName )
      call deallocate_test ( do_calc_dw_f, 'do_calc_dw_f', moduleName )
      call deallocate_test ( do_calc_dn,   'do_calc_dn',   moduleName )
      call deallocate_test ( do_calc_dn_c, 'do_calc_dn_c', moduleName )
      call deallocate_test ( do_calc_dn_f, 'do_calc_dn_f', moduleName )
      call deallocate_test ( do_calc_dv,   'do_calc_dv',   moduleName )
      call deallocate_test ( do_calc_dv_c, 'do_calc_dv_c', moduleName )
      call deallocate_test ( do_calc_dv_f, 'do_calc_dv_f', moduleName )

      call deallocate_test ( eta_zxp_dw,   'eta_zxp_dw',   moduleName )
      call deallocate_test ( eta_zxp_dw_c, 'eta_zxp_dw_c', moduleName )
      call deallocate_test ( eta_zxp_dw_f, 'eta_zxp_dw_f', moduleName )
      call deallocate_test ( eta_zxp_dn,   'eta_zxp_dn',   moduleName )
      call deallocate_test ( eta_zxp_dn_c, 'eta_zxp_dn_c', moduleName )
      call deallocate_test ( eta_zxp_dn_f, 'eta_zxp_dn_f', moduleName )
      call deallocate_test ( eta_zxp_dv,   'eta_zxp_dv',   moduleName )
      call deallocate_test ( eta_zxp_dv_c, 'eta_zxp_dv_c', moduleName )
      call deallocate_test ( eta_zxp_dv_f, 'eta_zxp_dv_f', moduleName )

      call deallocate_test ( drad_dw, 'drad_dw', moduleName )
      call deallocate_test ( drad_dn, 'drad_dn', moduleName )
      call deallocate_test ( drad_dv, 'drad_dv', moduleName )
d2837 4
a2840 4
    call deallocate_test ( ptg_angles, 'ptg_angles', moduleName )
    call deallocate_test ( radiances, 'radiances', moduleName )
    call deallocate_test ( dx_dt, 'dx_dt', moduleName )
    call deallocate_test ( d2x_dxdt, 'd2x_dxdt', moduleName )
d2867 19
d2887 2
a2888 2
          sigInd = usedSignals(i)
          channel = usedChannels(i)
d2897 8
a2904 4
                call Freq_Avg ( frequencies,           &
                  & FilterShapes(shapeInd)%FilterGrid, &
                  & FilterShapes(shapeInd)%FilterShape,&
                  & k_spect_dS_frq(:,sv_i), r )
d2918 2
a2919 2
            &          Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &                
            &          Grids_dS%WindowFinish(k) - Grids_dS%WindowStart(k) + 1 /) )                   
d2923 35
d2997 3
a2999 3
      & P_PATH, &               ! Pressure on path     
      & T_PATH, &               ! Temperatures on path 
      & Z_PATH                  ! Zeta on path         
d3056 3
@


2.191
log
@some minor changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.190 2003/12/08 17:52:02 jonathan Exp $"
d638 1
a638 1
    call load_one_item_grid ( grids_tmp, temp, phitan, maf, fwdModelConf, .true. )
d647 1
a647 1
      & call load_one_item_grid ( grids_iwc, cloudIce, phitan, maf, fwdModelConf, .false. )
d651 1
a651 1
        & fwdModelConf, .false. )
d1637 4
a1640 1
            call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, fwdModelConf, .false. )
d1661 2
d1673 2
a1674 2
            call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false. )
            call load_one_item_grid ( grids_cext,  cld_ext,  phitan, maf, fwdModelConf, .false. )
d2912 3
@


2.190
log
@update for 2d cldfwm
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.189 2003/12/07 19:45:46 jonathan Exp $"
d706 1
a706 1
      call allocate_test ( cld_ext%values, n_t_zeta, 1, 'cld_ext', moduleName )
a1635 2
            scat_alb%template = temp%template
            cld_ext%template = temp%template
d1660 1
d1663 4
a1666 1
            if ( .not. cld_fine ) then                 ! project onto LOS
d1706 1
a1706 1
            else                                  ! re-compute cext and w0 alone LOS
d2907 3
@


2.189
log
@update for 2D cloud FWM
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.188 2003/12/01 17:24:05 jonathan Exp $"
d46 1
a46 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, & ! JJ
d61 1
a61 1
      & Load_Sps_Data, Modify_values_for_supersat                    ! JJ
d86 1
a86 1
      & DRAD_TRAN_DX
d88 1
a88 1
    use ScatSourceFunc, only: T_SCAT,  Interp_Tscat,  Convert_Grid         !JJ
d107 2
a108 2
    real(r8), dimension(:,:), pointer :: WC       !JJ
    real(r8), dimension(:), pointer :: Scat_ang   !JJ
d180 1
a180 1
    integer :: novmrSurf                ! Number of vmr levels  !JJ
d190 1
a190 1
    character (len=32) :: molName       ! Name of a molecule  !JJ
d217 4
a220 4
    logical, dimension(:,:), pointer :: DO_CALC_IWC   ! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Tscat ! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Salb  ! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_cext  ! 'Avoid zeros' indicator  !JJ
d227 4
a230 4
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP! 'Avoid zeros' indicator     !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Tscat_ZP ! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Salb_ZP  ! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Cext_ZP  ! 'Avoid zeros' indicator  !JJ
d232 1
a232 1
    logical :: Got( FIRST_MOLECULE : LAST_MOLECULE )  !                             !JJ
d257 1
a257 1
    real(rp), dimension(:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse   !JJ
d308 3
a310 2
    real(rp), dimension(:),   pointer :: W0_PATH_C    ! Single scattering albedo
    real(r8), dimension(:,:), pointer :: VMRARRAY          ! The VMRs !JJ  
d335 8
a342 8
    real(rp), dimension(:,:), pointer :: ETA_IWC      ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Iwc_ZP   ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Tscat      ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Tscat_ZP   ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Salb      ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Salb_ZP   ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Cext      ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Cext_ZP   ! JJ
d358 5
a362 5
    real(rp), dimension(:,:), pointer :: IWC_PATH     ! IWC on path   !JJ
    real(rp), dimension(:,:), pointer :: Tscat_PATH   ! TScat on path   !JJ
    real(rp), dimension(:,:), pointer :: TT_PATH      ! TScat on path along the LOS   !JJ
    real(rp), dimension(:,:), pointer :: Salb_PATH    ! Single Scattering Albedo on path   !JJ
    real(rp), dimension(:,:), pointer :: Cext_PATH    ! Cloud extinction on path   !JJ
d428 1
a428 1
    type (VectorValue_T), pointer :: GPH           ! Geopotential height !JJ
d437 1
a437 1
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really   !JJ
d441 1
a441 1
    type (VectorValue_T), pointer :: VMR           ! Quantity  !JJ
d455 1
a455 1
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC     !JJ
d458 3
a460 3
    type (Grids_T) :: Grids_Tscat ! All the coordinates for scaterring source function !JJ
    type (Grids_T) :: Grids_Salb ! All the coordinates for single scaterring albedo !JJ
    type (Grids_T) :: Grids_Cext ! All the coordinates for cloud extinction !JJ
d487 3
a489 3
    type (VectorValue_T) :: scat_src     !JJ
    type (VectorValue_T) :: scat_alb     !JJ
    type (VectorValue_T) :: cld_ext     !JJ
d511 1
a511 1
      & w0_path_c, beta_path_f, beta_path_polarized, &
d610 1
a610 1
    if ( FwdModelConf%incl_cld ) then          !JJ
d922 3
a924 2
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path_cloud_c', moduleName ) !JJ
    call allocate_test ( w0_path_c,      npc, 'w0_path_c',   moduleName ) !JJ
d967 1
a967 1
    if ( fwdModelConf%Incl_Cld ) then !JJ
d1619 1
a1619 1
          if ( FwdModelConf%incl_cld ) then    !JJ
d1700 3
a1702 2
                              & c_inds(1:npc), beta_path_cloud_c(1:npc),        &
                              & w0_path_c(1:npc) )
d1850 17
a1866 5
            call rad_tran ( gl_inds(1:ngl), cg_inds(1:ncg), e_rflty,     &
              & del_zeta(1:npc), alpha_path_c(1:npc), ref_corr(1:npc),   &
              & do_gl(1:npc), incoptdepth(1:npc), alpha_path_f(1:ngl),   &
              & dsdz_gw_path, t_script(1:npc),  &
              & tau(1:npc), RadV(frq_i), i_stop )
d2494 2
a2495 2
    call Deallocate_Test ( WC, 'WC', moduleName )        !JJ
    call Deallocate_Test ( Scat_ang, 'Scat_ang', moduleName )        !JJ
d2525 1
a2525 1
    call destroygrids_t ( grids_iwc )          !JJ
d2528 3
a2530 3
    call destroygrids_t ( grids_tscat )        !JJ
    call destroygrids_t ( grids_salb )        !JJ
    call destroygrids_t ( grids_cext )        !JJ
d2549 3
a2551 2
    call deallocate_test ( beta_path_cloud_c,'beta_path_cloud_c',moduleName ) ! JJ
    call deallocate_test ( w0_path_c,   'w0_path_c',   moduleName )   
d2570 1
a2570 1
    call deallocate_test ( do_calc_iwc,   'do_calc_iwc',       moduleName ) ! JJ
d2572 1
a2572 1
    call deallocate_test ( do_calc_tscat,   'do_calc_tscat',   moduleName ) ! JJ
d2574 1
a2574 1
    call deallocate_test ( do_calc_salb,   'do_calc_salb',     moduleName ) ! JJ
d2576 1
a2576 1
    call deallocate_test ( do_calc_cext,   'do_calc_salb',     moduleName ) ! JJ
d2582 1
a2582 1
    call deallocate_test ( eta_tscat,       'eta_tscat',       moduleName ) !JJ
d2586 1
a2586 1
     call deallocate_test ( eta_cext,       'eta_cext',         moduleName ) 
d2590 1
a2590 1
    call deallocate_test ( iwc_path,      'iwc_path',          moduleName )     !JJ
d2905 3
@


2.188
log
@add scat_alb
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.187 2003/11/24 22:10:14 vsnyder Exp $"
d88 1
a88 1
    use ScatSourceFunc, only: T_SCAT             !JJ
d96 1
a96 1
    use Units, only: Deg2Rad, SpeedOfLight
d107 2
a108 1
    real(r8), dimension(:,:), pointer :: WC   !JJ
d114 1
a114 1
    integer, parameter :: Ngp1 = Ng+1     ! NG + 1
d187 1
d220 1
d227 6
a232 4
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Tscat_ZP! 'Avoid zeros' indicator  !JJ
    logical, dimension(:,:), pointer :: DO_CALC_Salb_ZP! 'Avoid zeros' indicator  !JJ
    logical :: Got( FIRST_MOLECULE : LAST_MOLECULE )  !                          !JJ
d308 1
a308 2
    real(rp), dimension(:,:), pointer :: BETA_PATH_PHH_C   ! Scattering phase function !JJ 
    real(rp), dimension(:),   pointer :: BETA_PATH_W0_C    ! Single scattering albedo
d340 2
d358 4
a361 2
    real(rp), dimension(:,:), pointer :: Tscat_PATH     ! TScat on path   !JJ
    real(rp), dimension(:,:), pointer :: Salb_PATH     ! Single Scattering Albedo on path   !JJ
d459 1
d488 1
d510 1
a510 1
      & beta_path_phh_c, beta_path_w0_c, beta_path_f, beta_path_polarized, &
d524 1
a524 1
      & do_calc_tscat, do_calc_tscat_zp, do_calc_Salb, do_calc_Salb_zp, &
d528 1
a528 1
      & eta_tscat, eta_tscat_zp, eta_salb, eta_salb_zp,  &
d540 2
a541 2
      & radiances, RadV, ref_corr, req_out, scat_src%values, scat_alb%values,  &
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, &
d545 1
a545 1
      & tscat_path,  salb_path, t_script, t_der_path_flags, true_path_flags, &
d705 1
d922 1
a922 1
    call allocate_test ( beta_path_w0_c,      npc, 'beta_path_w0_c',   moduleName ) !JJ
a956 1
    call allocate_test ( beta_path_phh_c,  npc, fwdModelConf%num_scattering_angles,     'beta_path_phh_c', moduleName ) !JJ
d1621 1
d1629 1
a1629 1
            & scat_src%values, scat_alb%values )
d1635 1
a1637 2
            call load_one_item_grid ( grids_salb,  scat_alb, phitan, maf, fwdModelConf, .false. )

d1639 6
a1644 3
            call allocate_test ( do_calc_tscat, max_ele, size(grids_tscat%values), 'do_calc_tscat', moduleName )
            call allocate_test ( eta_tscat,     max_ele, size(grids_tscat%values), 'eta_tscat',     moduleName )
            call allocate_test ( eta_tscat_zp,  max_ele, grids_tscat%p_len,  'eta_tscat_zp',    moduleName )
d1646 1
a1646 7
                                 & 'tscat_path', moduleName )            

            call allocate_test ( do_calc_salb, max_ele, size(grids_salb%values), 'do_calc_salb', moduleName )
            call allocate_test ( eta_salb,     max_ele, size(grids_salb%values), 'eta_salb',     moduleName )
            call allocate_test ( eta_salb_zp,  max_ele, grids_salb%p_len,  'eta_salb_zp',    moduleName )
            call allocate_test ( salb_path,    max_ele, fwdModelConf%num_scattering_angles, &
                                 & 'salb_path', moduleName )            
d1658 18
a1675 1
!            call interp_tscat (tscat_path(1:no_ele,:), phi_path(1:no_ele), tt_path )
d1687 31
a1717 14
            !! Jonathan's construction zone
!!            call get_beta_path_cloud ( Frq,                              &
!!              &  p_path(1:no_ele), t_path(1:no_ele),                     &  
!!              &  beta_group, c_inds(1:npc), beta_path_cloud_c(1:npc),    &
!!              &  beta_path_w0_c(1:npc), beta_path_phh_c(1:npc,:),        &
!!              &  IPSD(1:no_ele),  WC(:,1:no_ele), fwdModelConf ) 

!!            do j = 1, npc ! Don't trust compilers to fuse loops
!!              alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
!!                                    & beta_path_c(j,:) ) + &
!!                                    & beta_path_cloud_c(j)
!!
!!              incoptdepth(j) = alpha_path_c(j) * del_s(j)
!!            end do
d1721 2
a1722 2
!!            call path_contrib ( incoptdepth(1:npc), e_rflty, &
!!              & fwdModelConf%tolerance, do_gl(1:npc) )
d2480 1
d2515 1
d2534 2
a2535 3
    call deallocate_test ( beta_path_cloud_c, 'beta_path_cloud_c', moduleName ) ! JJ
    call deallocate_test ( beta_path_phh_c,  'beta_path_phh_c',  moduleName )   
    call deallocate_test ( beta_path_w0_c,   'beta_path_w0_c',   moduleName )   
d2552 4
a2555 4
    call deallocate_test ( beta_path_f,   'beta_path_f',   moduleName )
    call deallocate_test ( do_calc_fzp,   'do_calc_fzp',   moduleName )
    call deallocate_test ( do_calc_iwc,   'do_calc_iwc',   moduleName ) ! JJ
    call deallocate_test ( do_calc_iwc_zp,'do_calc_iwc_zp',moduleName )
d2558 8
a2565 6
    call deallocate_test ( do_calc_salb,   'do_calc_salb',   moduleName ) ! JJ
    call deallocate_test ( do_calc_salb_zp,'do_calc_salb_zp',moduleName )
    call deallocate_test ( do_calc_zp,    'do_calc_zp',    moduleName )
    call deallocate_test ( eta_fzp,       'eta_fzp',       moduleName )
    call deallocate_test ( eta_iwc,       'eta_iwc',       moduleName ) 
    call deallocate_test ( eta_iwc_zp,    'eta_iwc_zp',    moduleName ) 
d2568 14
a2581 10
    call deallocate_test ( eta_salb,       'eta_salb',       moduleName ) 
    call deallocate_test ( eta_salb_zp,    'eta_salb_zp',    moduleName ) 
    call deallocate_test ( eta_mag_zp,    'eta_mag_zp',    moduleName )
    call deallocate_test ( eta_zp,        'eta_zp',        moduleName )
    call deallocate_test ( iwc_path,      'iwc_path',      moduleName )     !JJ
    call deallocate_test ( tscat_path,      'tscat_path',      moduleName )
    call deallocate_test ( salb_path,      'salb_path',      moduleName )
    call deallocate_test ( mag_path,      'mag_path',      moduleName )
    call deallocate_test ( sps_path,      'sps_path',      moduleName )
    call deallocate_test ( true_path_flags,'true_path_flags',moduleName )
d2595 4
d2889 3
@


2.187
log
@Multiply beta_path_polarized_f by tanh1_f if derivatives needed
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.186 2003/11/20 17:33:50 pwagner Exp $"
d217 1
d226 1
d334 2
d351 3
a353 2
    real(rp), dimension(:,:), pointer :: IWC_PATH     ! species on path   !JJ
    real(rp), dimension(:,:), pointer :: Tscat_PATH     ! species on path   !JJ
d450 1
d478 1
d514 1
a514 1
      & do_calc_tscat, do_calc_tscat_zp, &
d518 1
a518 1
      & eta_tscat, eta_tscat_zp, &
d530 1
a530 1
      & radiances, RadV, ref_corr, req_out, scat_src%values, &
d535 1
a535 1
      & tscat_path, t_script, t_der_path_flags, true_path_flags, &
d694 2
d1617 4
a1620 1
            & fwdModelConf%no_cloud_species, scat_src%values )
d1623 2
a1624 1
            
d1626 2
d1635 6
d1645 1
d1651 11
a1661 1
            call Deallocate_test ( vmrArray,'vmrArray',ModuleName )
d2472 1
d2516 2
d2522 4
a2525 2
    call deallocate_test ( eta_tscat,       'eta_tscat',       moduleName ) 
    call deallocate_test ( eta_tscat_zp,    'eta_tscat_zp',    moduleName ) 
d2528 1
a2528 1
    call deallocate_test ( iwc_path,      'iwc_path',      moduleName )
d2530 1
d2543 4
d2837 3
@


2.186
log
@Nullify some things otherwise left unassociated
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.185 2003/11/19 22:21:34 jonathan Exp $"
d1545 1
a1545 1
          CALL Hunt ( min_ch_freq_grid, vel_cor &
d1548 1
a1548 1
          CALL Hunt ( max_ch_freq_grid,vel_cor &
d1681 3
a1683 2
                    & sps_path(c_inds(j),:) ) + &
                    & (/ 0.25, 0.50, 0.25 /) * alpha_path_c(j)
d1692 3
a1694 1
                    & (/ 0.25, 0.50, 0.25 /) * alpha_path_c(j)
d1792 18
a1809 6
            do j = 1, ngl
              alpha_path_polarized_f(-1:1,j) = matmul( beta_path_polarized_f(-1:1,j,:), &
                & sps_path(gl_inds(j),:) ) * tanh1_f(j) + 0.25 * alpha_path_f(j)
              alpha_path_polarized_f(0,j) = alpha_path_polarized_f(0,j) + &
                & 0.25 * alpha_path_f(j)
            end do
a2385 1
      Print *
d2795 3
@


2.185
log
@interpolate scat_src to tscat_path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.184 2003/11/17 18:04:15 jonathan Exp $"
d507 1
d511 1
d2781 3
@


2.184
log
@scat_src output from T_scat is correct
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.183 2003/11/12 00:10:55 jonathan Exp $"
d216 1
d224 1
d330 2
d348 1
d526 1
a526 1
      & t_script, t_der_path_flags, true_path_flags, &
d1609 1
d1611 16
d2465 2
d2471 2
d2476 1
d2779 3
@


2.183
log
@some changes due to cloud construction
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.182 2003/11/07 03:18:49 vsnyder Exp $"
d1595 6
a1600 5
            call T_scat ( temp%values(:,inst), Frq, GPH%values(:,windowstart), &
            & vmrArray, nspec,                                                 &
            & fwdModelConf%num_scattering_angles,                              &
            & fwdModelConf%num_azimuth_angles,                                 &
            & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,           &
d1606 1
d2752 3
@


2.182
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.181 2003/11/06 01:13:14 bill Exp $"
d1605 14
a1618 14

            call get_beta_path_cloud ( Frq,                              &
              &  p_path(1:no_ele), t_path(1:no_ele),                     &  
              &  beta_group, c_inds(1:npc), beta_path_cloud_c(1:npc),    &
              &  beta_path_w0_c(1:npc), beta_path_phh_c(1:npc,:),        &
              &  IPSD(1:no_ele),  WC(:,1:no_ele), fwdModelConf ) 

            do j = 1, npc ! Don't trust compilers to fuse loops
              alpha_path_c(j) = dot_product( sps_path(c_inds(j),:), &
                                    & beta_path_c(j,:) ) + &
                                    & beta_path_cloud_c(j)

              incoptdepth(j) = alpha_path_c(j) * del_s(j)
            end do
d1622 2
a1623 2
            call path_contrib ( incoptdepth(1:npc), e_rflty, &
              & fwdModelConf%tolerance, do_gl(1:npc) )
a1742 8
          ! Compute Scattering source function !JJ under construction

          ! if ( FwdModelConf%incl_cld ) then
          !  CALL Tscat (Frq,  beta_path_w0_c(1:npc),        &
          !    &  beta_path_phh_c(1:npc,:), ICON, NU,        &
          !    &  t_scat(1:npc) )
          ! END IF

d2750 3
@


2.181
log
@fixed DACS freq extrapolation problem
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.180 2003/11/05 19:26:01 jonathan Exp $"
d54 4
a57 4
    use Intrinsic, only: L_A, L_CLOUDICE, L_CLOUDWATER, &      ! JJ
      & L_DN, L_DV, L_DW, L_EARTHREFL, L_ECRtoFOV, &
      & L_ELEVOFFSET, L_LOSVEL, L_MAGNETICFIELD, L_ORBITINCLINATION,  &
      & L_PHITAN, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, L_LIMBSIDEBANDFRACTION, &
d59 1
a59 1
      & L_CLEAR, L_BOUNDARYPRESSURE, L_GPH, LIT_INDICES
a409 1
    type (VectorValue_T), pointer :: VMR           ! Quantity  !JJ
d422 1
d489 3
a491 2
      & c_inds, channelOrigins, cg_inds, d_rad_pol_df, d_rad_pol_dt, &
      & d_delta_df, d_delta_dt, d_t_scr_dt, d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
d504 1
a504 1
      & dxdt_surface, dxdt_tan, closestInstances, eta_fzp, eta_iwc, &
d670 21
a690 1
    IF ( FwdModelConf%incl_cld ) then  ! Do this block only if incl_cld is true
d692 2
a693 22
       call Allocate_test ( closestInstances, thisRadiance%template%noInstances,    &
       & 'closestInstances', ModuleName )      
       call FindClosestInstances ( temp, thisRadiance, closestInstances )
       inst = closestInstances(MAF)

       call allocate_test ( scat_src%values, n_t_zeta, &
       & fwdModelConf%num_scattering_angles, 'scat_src', moduleName )

       if ( size(FwdModelConf%molecules) .lt. 2 ) then
          !   make sure we have enough molecules
          call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
       endif

       ! now checking spectroscopy
       got = .false.
       nspec = size(FwdModelConf%molecules)
       noSurf  = temp%template%noSurfs     
       call allocate_test ( vmrArray, nspec, n_t_zeta, 'vmrArray', ModuleName )
       vmrarray = 0._r8
   
       do j = 1, nspec      ! Loop over species
       Call get_string ( lit_indices( abs(fwdModelConf%molecules(j)) ), molName )
d695 1
a695 1
       select case (fwdModelConf%molecules(j))
d697 18
a714 18
            ispec = 0
            if(fwdModelConf%molecules(j) == l_h2o) ispec = 1
            if(fwdModelConf%molecules(j) == l_o3) ispec = 2
            if(fwdModelConf%molecules(j) == l_n2o) ispec = 3
            if(fwdModelConf%molecules(j) == l_h2o) got(L_H2O) = .true.
            if(fwdModelConf%molecules(j) == l_o3) got(L_O3) = .true.

         vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
           & quantityType=l_vmr, molecule=fwdModelConf%molecules(j) )

            novmrSurf = vmr%template%nosurfs

            call InterpolateValues ( &
            & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
            & reshape(vmr%values(:,inst),(/novmrSurf/)),      &    ! Old Y
            & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
            & vmrArray(ispec,:),                              &    ! New Y
            & 'Linear', extrapolate='Clamp' )
d722 2
a723 2
       end select      
       enddo ! End of Loop over species
d725 4
a728 4
    if ( .not. got(l_h2o) .or. .not. got(l_o3) ) then
    !make sure we have at least two molecules h2o and o3. 
      call MLSMessage(MLSMSG_Error, ModuleName,'Missing molecules H2O or O3 in cloud FM')
    endif
d730 1
a730 1
    ENDIF
d1569 2
a1572 19
          If ( FwdModelConf%incl_cld ) then   !JJ
            ! Compute Scattering source function based on temp_prof at all
            ! angles U for each temperature layer assuming a plane parallel
            ! atmosphere.
            call T_scat ( temp%values(:,inst), Frq, GPH%values(:,windowstart), &
            & vmrArray, nspec,                                                 &
            & fwdModelConf%num_scattering_angles,                              &
            & fwdModelConf%num_azimuth_angles,                                 &
            & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins,           &
            & fwdModelConf%no_cloud_species, scat_src%values )

            scat_src%template = temp%template
            call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, fwdModelConf, .false. )
            call Deallocate_test ( vmrArray,'vmrArray',ModuleName )

          End if

          ! Set up path quantities --------------------------------------

d1592 13
d2758 3
@


2.180
log
@add stuff for use later in cld model
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.179 2003/11/04 02:49:13 vsnyder Exp $"
d1537 2
a1538 1
          call Hunt ( min_ch_freq_grid, PointingGrids(whichPointingGrid)% &
d1540 2
a1541 1
          call Hunt ( max_ch_freq_grid, PointingGrids(whichPointingGrid)% &
d1979 1
a1979 1

d2761 3
@


2.179
log
@Calculate coarse-path indices where GL is needed
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.178 2003/11/04 01:57:15 vsnyder Exp $"
d59 1
a59 1
      & L_CLEAR, L_BOUNDARYPRESSURE, L_GPH
d64 1
a64 1
    use ManipulateVectorQuantities, only: DoHGridsMatch
d70 2
a71 2
      & MLSMSG_Error
    use MLSNumerics, only: Hunt
d74 5
a78 1
    use Molecules, only: L_Extinction ! Used in include dump_print_code.f9h
d131 1
d178 6
d188 1
d223 1
d300 2
a301 1
    real(rp), dimension(:),   pointer :: BETA_PATH_W0_C    ! Single scattering albedo 
d409 2
a410 1
    type (VectorValue_T), pointer :: GPH           ! Geopotential height
a464 2
! temperature on surfaces where supersaturation may need to be calculated
    real(r8), dimension(:), pointer :: temp_prof      !JJ
d503 1
a503 1
      & dxdt_surface, dxdt_tan, eta_fzp, eta_iwc, &
d521 1
a521 1
      & usedchannels, usedsignals, wc, z_path )
d669 61
a729 4
    temp_prof => grids_tmp%values(1:n_t_zeta)
    if ( FwdModelConf%incl_cld ) &
      & call allocate_test ( scat_src%values, n_t_zeta, &
      & fwdModelConf%num_scattering_angles, 'scat_src', moduleName )
d1568 1
a1568 1
          if ( FwdModelConf%incl_cld ) then   !JJ
d1572 5
a1576 4
            call T_scat (temp_prof, Frq, GPH%values(:,windowstart),  &
            & fwdModelConf%num_scattering_angles,                    &
            & fwdModelConf%num_azimuth_angles,                       &
            & fwdModelConf%num_ab_terms, fwdModelConf%num_size_bins, &
a1579 1

d1581 1
d1583 1
a1583 1
          end if
d2759 3
@


2.178
log
@Move trapezoid correction to a better place, cosmetics
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.175 2003/10/30 20:37:00 vsnyder Exp $"
d144 1
d183 1
d476 2
a477 2
      & c_inds, channelOrigins, d_rad_pol_df, d_rad_pol_dt, d_delta_df, d_delta_dt, &
      & d_t_scr_dt, d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
d826 1
d1205 1
a1205 1
        call get_gl_inds ( do_gl(:npc), f_inds, nglMax )
d1637 1
a1637 1
          call get_GL_inds ( do_gl(1:npc), gl_inds, ngl )
d1683 3
a1685 3
            call rad_tran ( gl_inds(1:ngl), e_rflty, del_zeta(1:npc), &
              & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),   &
              & incoptdepth(1:npc), alpha_path_f(1:ngl),              &
d1708 5
a1712 5
            call rad_tran_pol ( gl_inds(1:ngl), e_rflty, del_zeta(1:npc),     &
              & alpha_path_polarized(:,1:npc), ref_corr(1:npc), do_gl(1:npc), &
              & incoptdepth_pol(:,:,1:npc), deltau_pol(:,:,1:npc),            &
              & alpha_path_polarized_f(:,1:ngl), dsdz_gw_path,                &
              & ct, stcp, stsp, t_script(1:npc),  prod_pol(:,:,1:npc),        &
d2360 1
d2688 3
@


2.177
log
@Get rid of path_ds_dh procedure -- a one-liner used in one place
@
text
@d145 1
d1202 1
a1202 1
        call get_gl_inds ( do_gl(:npc), f_inds, ngl )
d1291 2
a1292 2
if ( (npc-2)*ng /= ngl ) stop 'Unequal'
        do i = 1, (npc-2)*ng, ng
d1324 1
a1324 1
        tan_temp(ptg_i) = one_tan_temp(1)
d1433 4
a1436 5
        ngl = (npc-2)*ng ! temporarily
        path_dsdh(f_inds(:ngl)) = h_path(f_inds(:ngl)) / &
          & ( sqrt( h_path(f_inds(:ngl))**2 - (Req+one_tan_ht(1))**2 ) )
        dsdz_gw_path(f_inds(:ngl)) = path_dsdh(f_inds(:ngl)) * &
          & dhdz_gw_path(f_inds(:ngl))
d1511 1
a1511 1
          ! Setup path quantities --------------------------------------
d1547 1
a1547 1
            ! Determine where to use Gauss-Legendre instead of a rectangle.
a1551 8
            ! Where we don't do GL, replace the rectangle rule by the
            ! trapezoid rule.
            do j = 1, npc - 1
              if ( .not. do_gl(j) ) &
                & incoptdepth(j) = &
                  & 0.5 * ( alpha_path_c(j) + alpha_path_c(j+1) ) * del_s(j)
            end do

d1562 1
a1562 1
               ! Determine where to use Gauss-Legendre for scalar instead of a rectangle.
a1566 8
              ! Where we don't do GL, replace the rectangle rule by the
              ! trapezoid rule.
              do j = 1, npc - 1
                if ( .not. do_gl(j) ) &
                  & incoptdepth(j) = &
                    & 0.5 * ( alpha_path_c(j) + alpha_path_c(j+1) ) * del_s(j)
              end do

d1626 8
d1647 1
a1647 1
            & my_Catalog(thisSideband,:), beta_group, &
a1723 1
            ! Assume antenna is only sensitive to the first linear polarization
d2684 3
@


2.176
log
@Compute del_zeta, ds_dz_gw and dh_dz_gw for [d]rad_tran*; change
indices_c to c_inds for consistency with usage in rad_tran_m.
@
text
@d83 1
a83 1
    use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR, PATH_DS_DH
d1290 1
d1432 5
a1436 8
        ! This only needs to be computed on the gl (not coarse) grid thus
        ! there is some duplication here.
        path_dsdh(2:brkpt-1) = path_ds_dh(h_path(2:brkpt-1), &
              &                           Req+one_tan_ht(1))
        path_dsdh(brkpt+2:no_ele-1)=path_ds_dh(h_path(brkpt+2:no_ele-1), &
              &                                Req+one_tan_ht(1))
        dsdz_gw_path(f_inds(:(npc-2)*ng)) = path_dsdh(f_inds(:(npc-2)*ng)) * &
          & dhdz_gw_path(f_inds(:(npc-2)*ng))
d2693 4
@


2.175
log
@Compute del_zeta here for *rad_tran_*
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.172 2003/10/09 19:30:18 vsnyder Exp $"
d53 1
a53 1
    use GLnp, only: NG
d179 1
d181 2
a182 1
    integer, dimension(:), pointer :: GL_INDS ! Index of GL indices
a183 1
    integer, dimension(:), pointer :: INDICES_C ! Indices on coarse grid
d238 1
d243 1
d473 1
a473 1
      & channelOrigins, d_rad_pol_df, d_rad_pol_dt, d_delta_df, d_delta_dt, &
d479 1
a479 1
      & dhdz_glgrid, dhdz_out, dhdz_path, dincoptdepth_pol_dt, &
d486 1
a486 1
      & drad_dn, drad_dt, drad_dv, drad_dw, dx_dh_out, dx_dt, &
d491 1
a491 1
      & eta_zxp_t, eta_zxp_t_c, eta_zxp_t_f, frequencies, &
d494 1
a494 1
      & incoptdepth, incoptdepth_pol, incoptdepth_pol_gl, indices_c, ipsd, iwc_path, &
d822 1
d826 1
d828 2
a834 1
    call allocate_test ( indices_c,           npc, 'indices_c',        moduleName )
d1197 5
a1201 2
        indices_c(1:npc) = (/(i*Ngp1-Ng,i=1,mid),((i-1)*Ngp1-Ng+1,i=mid+1,npc)/)
        indices_c(npc+1:) = 0
d1206 4
a1209 2
        del_zeta(2:mid) = z_path(indices_c(1:mid-1)) - z_path(indices_c(2:mid))
        del_zeta(mid+1:npc-1) = z_path(indices_c(mid+2:npc)) - z_path(indices_c(mid+1:npc-1))
d1214 1
a1214 1
        p_path_c(1:npc) = p_path(indices_c(1:npc))
d1242 4
a1245 4
            dh_dt_path_c(1:npc,:) = dh_dt_path(indices_c(1:npc),:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(indices_c(1:npc),:)
            do_calc_t_c(1:npc,:) = do_calc_t(indices_c(1:npc),:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(indices_c(1:npc),:)
d1276 4
a1279 4
            dh_dt_path_c(1:npc,:) = dh_dt_path(indices_c(1:npc),:)
            do_calc_hyd_c(1:npc,:) = do_calc_hyd(indices_c(1:npc),:)
            do_calc_t_c(1:npc,:) = do_calc_t(indices_c(1:npc),:)
            eta_zxp_t_c(1:npc,:) = eta_zxp_t(indices_c(1:npc),:)
d1290 5
d1297 1
a1297 3
        h_path(1:no_ele) = req + h_path(1:no_ele)
        h_path_c(1:npc) = h_path(indices_c(1:npc))
        t_path_c(1:npc) = t_path(indices_c(1:npc))
d1307 2
a1308 2
          do_calc_dw_c(1:npc,:) = do_calc_dw(indices_c(1:npc),:)
          eta_zxp_dw_c(1:npc,:) = eta_zxp_dw(indices_c(1:npc),:)
d1312 2
a1313 2
          do_calc_dn_c(1:npc,:) = do_calc_dn(indices_c(1:npc),:)
          eta_zxp_dn_c(1:npc,:) = eta_zxp_dn(indices_c(1:npc),:)
d1317 2
a1318 2
          do_calc_dv_c(1:npc,:) = do_calc_dv(indices_c(1:npc),:)
          eta_zxp_dv_c(1:npc,:) = eta_zxp_dv(indices_c(1:npc),:)
d1409 1
a1409 1
            &  h2o_path=sps_path(indices_c(1:npc), h2o_ind) )
d1437 2
d1524 1
a1524 1
            &  gl_slabs, indices_c(1:npc), beta_path_c(1:npc,:),  &    
d1537 1
a1537 1
              &  beta_group, indices_c(1:npc), beta_path_cloud_c(1:npc), &
d1542 1
a1542 1
              alpha_path_c(j) = dot_product( sps_path(indices_c(j),:), &
d1565 1
a1565 1
              alpha_path_c(j) = dot_product( sps_path(indices_c(j),:), &
d1588 1
a1588 1
                & gl_slabs, indices_c(1:npc), beta_path_polarized )
d1600 1
a1600 1
                    & sps_path(indices_c(j),:) ) + &
d1609 1
a1609 1
                    & sps_path(indices_c(j),:) ) * tanh1_c(j) + &
d1685 1
a1685 1
          !    &  t_scat(1:npc) )  
d1693 2
a1694 2
              & path_dsdh, dhdz_path, t_script(1:npc), tau(1:npc),    &
              & RadV(frq_i), i_stop )
d1718 1
a1718 1
              & alpha_path_polarized_f(:,1:ngl), path_dsdh, dhdz_path,        &
d1747 1
a1747 1
            call drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), del_zeta, Grids_f, &
d1750 1
a1750 1
              &  path_dsdh, dhdz_path, t_script(1:npc), tau(1:npc), &
d1758 1
a1758 1
              call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, indices_c(1:p_stop), &
d1792 1
a1792 1
            sps_beta_dbeta_c(:npc) = SUM(sps_path(indices_c(1:npc),:) * &
d1806 4
a1809 4
              & h_path_f(:ngl), t_path_f(:ngl), dh_dt_path_f(:ngl,:),          &
              & alpha_path_f(1:ngl), sps_beta_dbeta_f(:ngl),                   &
              & eta_zxp_t_f(:ngl,:), do_calc_t_f(:ngl,:), path_dsdh(gl_inds(1:ngl)), &
              & dhdz_path(gl_inds(1:ngl)), t_script(1:npc), d_t_scr_dt(1:npc,:), &
d1823 1
a1823 1
              call get_d_deltau_pol_dT ( frq, h, ct, stcp, stsp,       &
d1827 1
a1827 1
                & beta_path_polarized_f(:,1:ngl,:), sps_path, &
d1830 1
a1830 1
                & indices_c(1:p_stop), gl_inds(:ngl), del_zeta(1:npc),    &
d1832 1
a1832 1
                & path_dsdh, dhdz_path,                                       &
d1866 1
a1866 1
                &  sps_path(indices_c(1:npc),:), do_calc_dw_c(1:npc,:),  &
d1869 2
a1870 2
                &  do_gl(1:npc), del_s(1:npc), ref_corr(1:npc),          &
                &  path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)), &
d1881 1
a1881 1
                &  sps_path(indices_c(1:npc),:), do_calc_dn_c(1:npc,:),  &
d1884 2
a1885 2
                &  do_gl(1:npc), del_s(1:npc), ref_corr(1:npc),          &
                &  path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)), &
d1896 1
a1896 1
                &  sps_path(indices_c(1:npc),:), do_calc_dv_c(1:npc,:),  &
d1899 2
a1900 2
                &  do_gl(1:npc), del_s(1:npc), ref_corr(1:npc),          &
                &  path_dsdh(gl_inds(1:ngl)),dhdz_path(gl_inds(1:ngl)),  &
d2347 13
a2359 11
    call deallocate_test ( dhdz_path,   'dhdz_path',   moduleName )
    call deallocate_test ( h_path,      'h_path',      moduleName )
    call deallocate_test ( h_path_c,    'h_path_c',    moduleName )
    call deallocate_test ( h_path_f,    'h_path_f',    moduleName )
    call deallocate_test ( p_path,      'p_path',      moduleName )
    call deallocate_test ( p_path_c,    'p_path_c',    moduleName )
    call deallocate_test ( path_dsdh,   'path_dsdh',   moduleName )
    call deallocate_test ( phi_path,    'phi_path',    moduleName )
    call deallocate_test ( t_path,      't_path',      moduleName )
    call deallocate_test ( t_path_c,    't_path_c',    moduleName )
    call deallocate_test ( z_path,      'z_path',      moduleName )
d2367 1
d2370 1
a2372 1
    call deallocate_test ( indices_c,        'indices_c',        moduleName )
d2695 3
@


2.174
log
@Added support for the forceFoldedOutput option
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.173 2003/10/28 22:05:53 jonathan Exp $"
d141 1
d235 1
a277 1
    real(rp), dimension(:), pointer :: Z_PATH_C     ! Z_PATH on coarse grid
d389 1
a395 1
    type (VectorValue_T), pointer :: GPH           ! Geopotential height
d474 1
a474 1
      & ddhidhidtl0, de_df, de_dt, del_s, deltau_pol, &
d489 1
a489 1
      & gl_delta_polarized, gl_inds, grids, &
d502 1
a502 1
      & usedchannels, usedsignals, wc, z_path, z_path_c, gph )
d537 1
a542 1
    gph => GetVectorQuantityByType ( fwdModelExtra, quantityType=l_gph )
d820 1
a845 1
    call allocate_test ( z_path_c,            npc, 'z_path_c',         moduleName )
d1187 2
a1188 1
        npc = 2 * (brkpt + Ng) / Ngp1
d1191 1
a1191 3
        k = Ngp1
        j = (npc+1)/2
        indices_c(1:npc) = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)
d1195 6
a1200 2
        z_path(1:no_ele) = (/(z_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                           & (z_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
a1202 1
        z_path_c(1:npc) = z_path(indices_c(1:npc))
d1674 1
a1674 1
            call rad_tran ( gl_inds(1:ngl), e_rflty, z_path_c(1:npc), &
d1699 1
a1699 1
            call rad_tran_pol ( gl_inds(1:ngl), e_rflty, z_path_c(1:npc),     &
d1731 1
a1731 1
            call drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path_c, Grids_f, &
d1743 1
a1743 1
                &  z_path_c, Grids_f, beta_path_polarized(:,1:p_stop,:),      &
d1784 1
a1784 2
            call drad_tran_dt ( z_path_c(1:npc ),                              &
              & h_path_c(1:npc),                                               &
d1786 1
a1786 2
              & alpha_path_c(1:npc), &
              & sps_beta_dbeta_c(:npc), &
d1791 2
a1792 3
              & alpha_path_f(1:ngl),                                           &
              & sps_beta_dbeta_f(:ngl),    &
              & eta_zxp_t_f(:ngl,:), do_calc_t_f(:ngl,:), path_dsdh(gl_inds(1:ngl)),   &
d1794 1
a1794 1
              & tau(1:npc), i_stop, grids_tmp%deriv_flags,       &
d1807 1
a1807 1
              call get_d_deltau_pol_dT ( frq, npc/2, h, ct, stcp, stsp,       &
d1810 7
a1816 3
                & beta_path_polarized(:,1:p_stop,:), sps_path,                &
                & alpha_path_polarized(:,1:p_stop), eta_zxp_t_c(1:p_stop,:),  &
                & del_s(1:npc), indices_c(1:p_stop),                          &
d1818 5
a1822 5
                & h_path_c(1:npc), dh_dt_path_c(1:p_stop,:),                  &
                & Req + one_tan_ht(1), dh_dt_path(brkpt,:),                   &
                & do_calc_hyd_c(1:p_stop,:), d_delta_dt(1:npc,:),             &
                & de_dt(:,:,1:p_stop,:) )
         
d1848 7
a1854 7
              call drad_tran_dx ( z_path_c(1:npc), Grids_dw,                    &
                &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw_c(1:npc,:),             &
                &  sps_path(indices_c(1:npc),:), do_calc_dw_c(1:npc,:),                  &
                &  dbeta_dw_path_f(:ngl,:), eta_zxp_dw_f(:ngl,:),  &
                &  sps_path(gl_inds(1:ngl),:), &
                &  do_calc_dw_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
                &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)),     &
d1863 7
a1869 7
              call drad_tran_dx ( z_path_c(1:npc), Grids_dn,                    &
                &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn_c(1:npc,:),             &
                &  sps_path(indices_c(1:npc),:), do_calc_dn_c(1:npc,:),                  &
                &  dbeta_dn_path_f(:ngl,:), eta_zxp_dn_f(:ngl,:), &
                &  sps_path(gl_inds(1:ngl),:), &
                &  do_calc_dn_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
                &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)),     &
d1878 7
a1884 7
              call drad_tran_dx ( z_path_c(1:npc), Grids_dv,                    &
                &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv_c(1:npc,:),             &
                &  sps_path(indices_c(1:npc),:), do_calc_dv_c(1:npc,:),                  &
                &  dbeta_dv_path_f(:ngl,:), eta_zxp_dv_f(:ngl,:), &
                &  sps_path(gl_inds(1:ngl),:), &
                &  do_calc_dv_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
                &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)),dhdz_path(gl_inds(1:ngl)),     &
d2046 1
a2046 1
	! this is a temporary fix
d2048 1
a2048 1
	   & ptg_angles(ptg_i) = (ptg_angles(ptg_i-1) + ptg_angles(ptg_i+1))/2
a2341 1
    call deallocate_test ( z_path_c,    'z_path_c',    moduleName )
d2676 3
d2683 3
@


2.173
log
@add l_gph for use in cloud model
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.172 2003/10/09 19:30:18 vsnyder Exp $"
d615 2
a616 1
        & signal=fwdModelConf%signals(sigInd)%index, sideband=firstSignal%sideband )
d2074 1
a2074 1
          & sideband=fwdModelConf%signals(sigInd)%sideband )
d2673 3
@


2.172
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.170 2003/09/09 00:04:27 vsnyder Exp $"
d59 1
a59 1
      & L_CLEAR, L_BOUNDARYPRESSURE
d394 1
d501 1
a501 1
      & usedchannels, usedsignals, wc, z_path, z_path_c )
d541 1
d1481 3
a1483 1
            call T_scat (temp_prof, Frq, fwdModelConf%num_azimuth_angles,&
d2672 3
@


2.171
log
@Cosmetic changes
@
text
@d186 1
a186 1
    logical, dimension(:), pointer :: DO_GL ! Indicator of where to do GL
d201 1
a201 1
    logical, dimension(:,:), pointer :: DO_CALC_T     ! eta_zxp_t /= 0.
d206 2
a207 2
    logical, dimension(:), pointer :: true_path_flags ! array of trues
    logical, dimension(:), pointer :: t_der_path_flags! a flag that tells
d209 3
a211 2
! Only useful when subsetting temperature derivatives.  For point I on the
! path, this is any(do_calc_t(I,1:sv_t_len)).
d1570 1
a1570 1
                ! Will need beta_path_polarized * tanh1_c later.
d1580 1
a1580 1
                ! Won't need beta_path_polarized * tanh1_c later.
d1777 4
a1780 2
              & h_path_c(1:npc), t_path_c(1:npc), dh_dt_path_c(1:npc,:),       &
              & alpha_path_c(1:npc), sps_beta_dbeta_c(:npc),                   &
d1785 2
a1786 1
              & alpha_path_f(1:ngl), sps_beta_dbeta_f(:ngl),                   &
d1789 1
a1789 1
              & tau(1:npc), i_stop, grids_tmp%deriv_flags,                     &
@


2.170
log
@Supply E and Sqrt_Earth_Rflty to mcrt_der
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.169 2003/08/16 01:14:58 vsnyder Exp $"
d186 1
a186 1
    logical, dimension(:), pointer :: DO_GL ! GL indicator
d201 1
a201 1
    logical, dimension(:,:), pointer :: DO_CALC_T     ! 'Avoid zeros'
d206 2
a207 2
    LOGICAL, DIMENSION(:), pointer :: true_path_flags ! array of trues
    LOGICAL, DIMENSION(:), pointer :: t_der_path_flags! a flag that tells the
d209 2
a210 3
! Only useful when subsetting temperature derivatives.

! Array of Flags indicating  which Temp. coefficient to process
d1569 1
a1569 1
                ! Will need beta_path_polarized * tanh1_c
d1579 1
a1579 1
                ! Won't need beta_path_polarized * tanh1_c
d1776 2
a1777 4
              & h_path_c(1:npc),                                               &
              & t_path_c(1:npc), dh_dt_path_c(1:npc,:),                        &
              & alpha_path_c(1:npc), &
              & sps_beta_dbeta_c(:npc), &
d1782 1
a1782 2
              & alpha_path_f(1:ngl),                                           &
              & sps_beta_dbeta_f(:ngl),    &
d1785 1
a1785 1
              & tau(1:npc), i_stop, grids_tmp%deriv_flags,       &
d2664 3
@


2.169
log
@Use radiometers%polarization to choose 1,1 or 2,2 element
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.168 2003/08/15 20:29:26 vsnyder Exp $"
d1693 4
a1696 3
              & incoptdepth_pol(:,:,1:npc), alpha_path_polarized_f(:,1:ngl),  &
              & path_dsdh, dhdz_path, ct, stcp, stsp, t_script(1:npc),        &
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), rad_pol, p_stop )
d1723 1
a1723 1
            call drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path_c, Grids_f,  &
d1734 4
a1737 4
              call Get_D_Deltau_Pol_DF ( ct, stcp, stsp, indices_c, z_path_c, &
                &  Grids_f, beta_path_polarized(:,1:p_stop,:), eta_fzp, &
                &  do_calc_zp(1:no_ele,:), sps_path, del_s(1:npc), &
                &  incoptdepth_pol(:,:,1:p_stop), ref_corr(1:p_stop), &
d1743 4
a1746 3
              call mcrt_der ( t_script(1:npc), de_dt(:,:,1:npc,:),      &
                & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc),               &
                & p_stop, d_rad_pol_df )
d1809 1
a1809 1
                & h_path_c(1:p_stop), dh_dt_path_c(1:p_stop,:),               &
d1817 4
a1820 3
              call mcrt_der ( t_script(1:npc), de_dt(:,:,1:npc,:),      &
                & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc),               &
                & p_stop, d_rad_pol_dt, d_t_scr_dt(1:npc,:) )
d2668 3
@


2.168
log
@Implement polarized VMR derivatives
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.167 2003/08/15 18:50:21 vsnyder Exp $"
d54 1
a54 1
    use Intrinsic, only: L_CLOUDICE, L_CLOUDWATER, &      ! JJ
d71 3
a73 3
    use MLSNumerics, ONLY: Hunt
    use MLSSignals_m, only: Signal_t, MatchSignal, AreSignalsSuperset, &
                          & GetNameOfSignal
d1710 1
a1710 1
            if ( index(switches,'crosspol') == 0 ) then
d1746 1
a1746 1
              if ( index(switches,'crosspol') == 0 ) then
d1819 1
a1819 1
              if ( index(switches,'crosspol') == 0 ) then
d2665 3
@


2.167
log
@Preparing the way for polarized vmr derivatives
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.166 2003/08/12 23:07:32 vsnyder Exp $"
d50 1
a50 1
    use Get_d_Deltau_pol_m, only: Get_d_Deltau_pol_dT
d336 1
d345 1
d468 2
a469 2
      & channelOrigins, d_rad_pol_dt, d_delta_df, d_delta_dt, d_t_scr_dt, &
      & d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
d472 1
a472 1
      & ddhidhidtl0, de_dt, del_s, deltau_pol, &
a796 16
    if ( spect_der ) then
      !??? Temperature's windowStart:windowFinish are probably not correct here ???
      allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dw' )
      allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dn' )
      allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dv' )
    end if

d852 1
a852 1
    CALL allocate_test ( true_path_flags, max_ele, 'true_path_flags',moduleName)
a861 10
    if ( FwdModelConf%polarized ) then
      call allocate_test ( eta_mag_zp,     max_ele, grids_mag%p_len,        'eta_mag_zp',     moduleName )
      call allocate_test ( mag_path,       max_ele, magfield%template%noChans+1, 'mag_path', &
        & moduleName )
      if ( temp_der ) then
        allocate ( d_rad_pol_dt(2,2,sv_t_len), stat=ier )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_Allocate//'d_rad_pol_dt' )
      end if
    end if
d914 1
a914 1
    end if
d918 13
a930 1
      ! Allocation when spectral derivative are needed:
d994 3
a996 1
      ! Allocate some necessary arrays
d1027 8
d1036 3
d1728 26
d1815 3
a1817 3
              call mcrt_der ( t_script(1:npc), d_t_scr_dt(1:npc,:),      &
                & de_dt(:,:,1:npc,:), prod_pol(:,:,1:npc),               &
                & tau_pol(:,:,1:npc), p_stop, d_rad_pol_dt )
d2474 8
d2483 3
d2665 3
@


2.166
log
@Futzing with comments
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.165 2003/08/12 21:58:37 vsnyder Exp $"
d282 3
d466 1
a466 1
      & channelOrigins, d_rad_pol_dt, d_delta_dt, d_t_scr_dt, &
d826 1
a826 1
    call allocate_test ( alpha_path_f,     max_ele, 'alpha_path_f',     moduleName )
d830 1
a830 1
    call allocate_test ( dhdz_path,        max_ele, 'dhdz_path',        moduleName )
d832 1
a832 1
    call allocate_test ( gl_inds,          max_ele, 'gl_inds',          moduleName )
d834 2
a835 2
    call allocate_test ( h_path_f,         max_ele, 'h_path_f',         moduleName )
    call allocate_test ( h_path,           max_ele, 'h_path',           moduleName )
d839 2
a840 2
    call allocate_test ( path_dsdh,        max_ele, 'path_dsdh',        moduleName )
    call allocate_test ( phi_path,         max_ele, 'phi_path',         moduleName )
d842 1
a842 1
    call allocate_test ( p_path,           max_ele, 'p_path',           moduleName )
d847 1
a847 1
    call allocate_test ( tanh1_f,          max_ele, 'tanh1_f',          moduleName )
d850 4
a853 4
    call allocate_test ( t_path_f,         max_ele, 't_path_f',         moduleName )
    call allocate_test ( t_path_m,         max_ele, 't_path_m',         moduleName )
    call allocate_test ( t_path_p,         max_ele, 't_path_p',         moduleName )
    call allocate_test ( t_path,           max_ele, 't_path',           moduleName )
d856 1
a856 1
    call allocate_test ( z_path,           max_ele, 'z_path',           moduleName )
d933 2
d1568 4
a1571 2
              if ( temp_der ) then
                ! will need beta_path_polarized * tanh1_c
d1575 2
a1576 1
                    & sps_path(indices_c(j),:) )
d1579 3
a1581 1
                ! won't need beta_path_polarized * tanh1_c
d1584 2
a1585 1
                    & sps_path(indices_c(j),:) ) * tanh1_c(j)
a1588 7
              !  Add contributions from nonpolarized molecules 1/4 1/2 1/4 here
              do j=1, npc
                alpha_path_polarized(-1,j) = alpha_path_polarized(-1,j) + 0.25 * alpha_path_c(j)
                alpha_path_polarized( 0,j) = alpha_path_polarized( 0,j) + 0.50 * alpha_path_c(j)
                alpha_path_polarized( 1,j) = alpha_path_polarized( 1,j) + 0.25 * alpha_path_c(j)
              end do

d1723 3
a1725 3
              &  beta_path_f, do_gl(1:npc), del_s(1:npc), &
              &  ref_corr(1:npc), path_dsdh, dhdz_path, &
              &  t_script(1:npc), tau(1:npc), i_stop, k_atmos_frq(frq_i,:) )
d2372 1
a2372 1
      call deallocate_test ( true_path_flags, 'true_path_flags',moduleName )
d2376 2
a2377 1
      call deallocate_test ( k_atmos, 'k_atmos', moduleName )
d2627 3
@


2.165
log
@Use trapezoid instead of rectangle to integrate non-GL panels
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.164 2003/08/12 18:22:10 michael Exp $"
d1571 1
a1571 1
                ! don't need beta_path_polarized * tanh1_c
d1578 1
a1578 1
              !  adding contributions from nonpolarized molecules 1/4 1/2 1/4 here
d1580 3
a1582 3
                  alpha_path_polarized(-1,j)=alpha_path_polarized(-1,j) + 0.25 * alpha_path_c(j)
                  alpha_path_polarized( 0,j)=alpha_path_polarized( 0,j) + 0.5 * alpha_path_c(j)
                  alpha_path_polarized( 1,j)=alpha_path_polarized( 1,j) + 0.25 * alpha_path_c(j)
a1584 2


d1589 6
a1594 3
              ! Add unpolarized incremental optical depth to diagonal of
              ! polarized incremental optical depth. 0.5 factors scalar
              ! unpolarized "power absorption" to get "field absorption"
d2622 3
@


2.164
log
@Contribution of scalar molecules to polarized absorption is now added to coarse grid alpha_path_polarized (1/4 1/2 1/4) instead of to diagonal of incoptdepth_pol.  This make alpha_path_polarized correct for later use in gl corrections.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.163 2003/07/15 23:07:21 vsnyder Exp $"
a1346 1
          
d1524 8
d1544 1
a1544 1
               call path_contrib ( incoptdepth(1:npc), e_rflty, &
d1547 8
d1587 1
a1587 1
              ! Turn sigma-, pi, sigma+ into 2X2 matrix
d2487 1
a2487 1
      integer :: I, Instance, J, JF, Surface, SV_I
d2621 6
@


2.163
log
@Simplify Freq_Avg
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.162 2003/07/15 22:10:09 livesey Exp $"
d1347 2
d1362 1
d1563 9
d1582 1
a1582 2
                incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j) - &
                     & 0.5*incoptdepth(j)
d1585 1
a1585 2
                incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j) - &
                     & 0.5*incoptdepth(j)
a1654 3
!????DEBUG  This makes agreement to 0.2K with scalar model.  I don't know why.
!we ought to need to add the scalar contribution 0.25 0.5 0.25 to the polarized
alpha_path_f = 0.0 
d2606 3
@


2.162
log
@Added support for hybridModel
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.161 2003/07/15 18:16:48 livesey Exp $"
a1855 1
            k = size(FilterShapes(shapeInd)%FilterGrid)
d1859 1
a1859 1
              &   RadV, noFreqs, k, Radiances(ptg_i,i) )
d1884 1
a1884 2
                    & k_temp_frq(:,sv_i), noFreqs, &
                    & size(FilterShapes(shapeInd)%FilterGrid), r )
a1907 1
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
d1916 1
a1916 1
                        & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
a2473 1
          j = Size(FilterShapes(shapeInd)%FilterGrid)
d2482 1
a2482 1
                  & k_spect_dS_frq(:,sv_i), noFreqs, j, r )
d2599 3
@


2.161
log
@Catalog now split by sideband, also changed no_ele to max_ele in
allocates
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.160 2003/07/09 23:40:13 vsnyder Exp $"
d2017 2
a2018 1
        if ( fwdModelConf%sidebandStart /= fwdModelConf%sidebandStop ) then   ! We're folding
d2021 1
a2021 1
          ! if ( firstSignal%sideband == 0 ) then
d2603 4
@


2.160
log
@Use new AllocateSlabs routine
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.159 2003/07/09 22:27:42 vsnyder Exp $"
d133 1
d402 1
a402 1
    type (catalog_T), dimension(:), pointer :: MY_CATALOG ! ***
d812 1
a812 10
    no_ele = 2*maxVert     ! maximum possible

    ! First, Allocate gl_slab arrays....

    call allocateSlabs ( gl_slabs, no_ele, my_catalog, moduleName )

    if ( temp_der ) then
      call allocateSlabs ( gl_slabs_p, no_ele, my_catalog, moduleName )
      call allocateSlabs ( gl_slabs_m, no_ele, my_catalog, moduleName )
    end if
d823 1
a823 1
    call allocate_test ( alpha_path_f,     no_ele, 'alpha_path_f',     moduleName )
d827 1
a827 1
    call allocate_test ( dhdz_path,        no_ele, 'dhdz_path',        moduleName )
d829 1
a829 1
    call allocate_test ( gl_inds,          no_ele, 'gl_inds',          moduleName )
d831 2
a832 2
    call allocate_test ( h_path_f,         no_ele, 'h_path_f',         moduleName )
    call allocate_test ( h_path,           no_ele, 'h_path',           moduleName )
d836 2
a837 2
    call allocate_test ( path_dsdh,        no_ele, 'path_dsdh',        moduleName )
    call allocate_test ( phi_path,         no_ele, 'phi_path',         moduleName )
d839 1
a839 1
    call allocate_test ( p_path,           no_ele, 'p_path',           moduleName )
d842 1
a842 1
    call allocate_test ( sps_beta_dbeta_f, no_ele, 'sps_beta_dbeta_f', moduleName )
d844 1
a844 1
    call allocate_test ( tanh1_f,          no_ele, 'tanh1_f',          moduleName )
d847 4
a850 4
    call allocate_test ( t_path_f,         no_ele, 't_path_f',         moduleName )
    call allocate_test ( t_path_m,         no_ele, 't_path_m',         moduleName )
    call allocate_test ( t_path_p,         no_ele, 't_path_p',         moduleName )
    call allocate_test ( t_path,           no_ele, 't_path',           moduleName )
d853 1
a853 1
    call allocate_test ( z_path,           no_ele, 'z_path',           moduleName )
d857 7
a863 7
    call allocate_test ( beta_path_f,   no_ele, no_mol, 'beta_path_f',   moduleName )
    call allocate_test ( do_calc_fzp,   no_ele, size(grids_f%values),  'do_calc_fzp',   moduleName )
    call allocate_test ( do_calc_zp,    no_ele, grids_f%p_len,  'do_calc_zp',     moduleName )
    call allocate_test ( eta_fzp,       no_ele, size(grids_f%values),  'eta_fzp', moduleName )
    call allocate_test ( eta_zp,        no_ele, grids_f%p_len,  'eta_zp', moduleName )
    call allocate_test ( sps_path,      no_ele, no_mol, 'sps_path',       moduleName )
    CALL allocate_test ( true_path_flags, no_ele, 'true_path_flags',moduleName)
d866 6
a871 6
      call allocate_test ( do_calc_iwc,    no_ele, size(grids_iwc%values),  'do_calc_iwc',  moduleName )
      call allocate_test ( eta_iwc,        no_ele, size(grids_iwc%values),  'eta_iwc',      moduleName )
      call allocate_test ( eta_iwc_zp,     no_ele, grids_iwc%p_len,  'eta_iwc_zp',    moduleName )
      call allocate_test ( iwc_path,       no_ele, 1, 'iwc_path',           moduleName )
      call allocate_test ( ipsd,           no_ele, 'IPSD', moduleName )
      call allocate_test ( wc,         fwdModelConf%no_cloud_species, no_ele, 'WC', moduleName )
d874 2
a875 2
      call allocate_test ( eta_mag_zp,     no_ele, grids_mag%p_len,        'eta_mag_zp',     moduleName )
      call allocate_test ( mag_path,       no_ele, magfield%template%noChans+1, 'mag_path', &
d898 1
a898 1
      call allocate_test ( dbeta_dt_path_f, no_ele, no_mol,   'dbeta_dt_path_f', &
d900 1
a900 1
      call allocate_test ( dh_dt_path,      no_ele, sv_t_len, 'dh_dt_path', &
d904 1
a904 1
      call allocate_test ( dh_dt_path_f,    no_ele, sv_t_len, 'dh_dt_path_f', &
d906 1
a906 1
      call allocate_test ( do_calc_hyd,     no_ele, sv_t_len, 'do_calc_hyd', &
d910 1
a910 1
      call allocate_test ( do_calc_t,       no_ele, sv_t_len, 'do_calc_t', &
d914 1
a914 1
      call allocate_test ( do_calc_t_f,     no_ele, sv_t_len, 'do_calc_t_f', &
d916 1
a916 1
      call allocate_test ( eta_zxp_t,       no_ele, sv_t_len, 'eta_zxp_t', &
d920 1
a920 1
      call allocate_test ( eta_zxp_t_f,     no_ele, sv_t_len, 'eta_zxp_t_f', &
d924 1
a924 1
      call allocate_test ( t_der_path_flags, no_ele,          't_der_path_flags', &
d941 1
a941 1
      call allocate_test ( dbeta_dw_path_f, no_ele, no_mol, &
d945 1
a945 1
      call allocate_test ( dbeta_dn_path_f, no_ele, no_mol, &
d949 1
a949 1
      call allocate_test ( dbeta_dv_path_f, no_ele, no_mol, &
d956 1
a956 1
      call allocate_test ( do_calc_dw, no_ele, f_len_dw, 'do_calc_dw', &
d958 1
a958 1
      call allocate_test ( do_calc_dw_c, no_ele, f_len_dw, 'do_calc_dw_c', &
d960 1
a960 1
      call allocate_test ( do_calc_dw_f, no_ele, f_len_dw, 'do_calc_dw_f', &
d962 1
a962 1
      call allocate_test ( do_calc_dn, no_ele, f_len_dn, 'do_calc_dn', &
d964 1
a964 1
      call allocate_test ( do_calc_dn_c, no_ele, f_len_dn, 'do_calc_dn_c', &
d966 1
a966 1
      call allocate_test ( do_calc_dn_f, no_ele, f_len_dn, 'do_calc_dn_f', &
d968 1
a968 1
      call allocate_test ( do_calc_dv, no_ele, f_len_dv, 'do_calc_dv', &
d970 1
a970 1
      call allocate_test ( do_calc_dv_c, no_ele, f_len_dv, 'do_calc_dv_c', &
d972 1
a972 1
      call allocate_test ( do_calc_dv_f, no_ele, f_len_dv, 'do_calc_dv_f', &
d975 1
a975 1
      call allocate_test ( eta_zxp_dw, no_ele, f_len_dw, 'eta_zxp_dw', &
d977 1
a977 1
      call allocate_test ( eta_zxp_dw_c, no_ele, f_len_dw, 'eta_zxp_dw_c', &
d979 1
a979 1
      call allocate_test ( eta_zxp_dw_f, no_ele, f_len_dw, 'eta_zxp_dw_f', &
d981 1
a981 1
      call allocate_test ( eta_zxp_dn, no_ele, f_len_dn, 'eta_zxp_dn', &
d983 1
a983 1
      call allocate_test ( eta_zxp_dn_c, no_ele, f_len_dn, 'eta_zxp_dn_c', &
d985 1
a985 1
      call allocate_test ( eta_zxp_dn_f, no_ele, f_len_dn, 'eta_zxp_dn_f', &
d987 1
a987 1
      call allocate_test ( eta_zxp_dv, no_ele, f_len_dv, 'eta_zxp_dv', &
d989 1
a989 1
      call allocate_test ( eta_zxp_dv_c, no_ele, f_len_dv, 'eta_zxp_dv_c', &
d991 1
a991 1
      call allocate_test ( eta_zxp_dv_f, no_ele, f_len_dv, 'eta_zxp_dv_f', &
d1008 1
a1008 1
      allocate ( alpha_path_polarized_f(-1:1,no_ele), stat=ier )
d1011 1
a1011 1
      allocate ( beta_path_polarized_f(-1:1,no_ele,no_mol), stat=ier )
d1014 1
a1014 1
      allocate ( gl_delta_polarized(-1:1,no_ele), stat=ier )
d1059 7
d1413 1
a1413 1
        call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
d1418 1
a1418 1
          call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
d1421 1
a1421 1
          call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
d1491 1
a1491 1
            &  my_Catalog, beta_group, FwdModelConf%polarized,    &    
d1539 1
a1539 1
              call get_beta_path_polarized ( frq, h, my_Catalog, beta_group, &
d1602 2
a1603 1
            & my_Catalog, beta_group, FwdModelConf%polarized,         &
d1651 2
a1652 2
            call get_beta_path_polarized ( frq, h, my_Catalog, beta_group, gl_slabs, &
              & gl_inds(:ngl), beta_path_polarized_f )
d1747 1
a1747 1
                & my_catalog, beta_group, gl_slabs_m, gl_slabs_p,             &
d2162 6
a2260 1
    call DestroyCompleteSlabs ( gl_slabs )
d2346 2
a2347 4
      CALL deallocate_test ( t_der_path_flags,'t_der_path_flags',moduleName )
      CALL deallocate_test ( true_path_flags, 'true_path_flags',moduleName )
      call DestroyCompleteSlabs ( gl_slabs_p )
      call DestroyCompleteSlabs ( gl_slabs_m )
d2602 3
@


2.159
log
@More futzing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.158 2003/07/09 20:23:50 vsnyder Exp $"
d62 1
a62 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS, &
a142 1
    integer :: NL                       ! Number of lines
d815 1
a815 9
    allocate ( gl_slabs(no_ele, noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//"gl_slabs" )

    do i = 1, noSpecies
      do j = 1, no_ele
        call AllocateOneSlabs ( gl_slabs(j,i), size(My_Catalog(i)%Lines) )
      end do
    end do
d818 2
a819 12
      allocate ( gl_slabs_p(no_ele, noSpecies), &
        &        gl_slabs_m(no_ele, noSpecies), STAT=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//"gl_slabs_[pm]" )

      do i = 1, noSpecies
        nl = size(My_Catalog(i)%Lines)
        do j = 1, no_ele
          call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
          call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
        end do
      end do
d2599 3
@


2.158
log
@Futzing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.157 2003/07/09 20:14:19 livesey Exp $"
d756 2
a757 2
    ! Temperature's windowStart:windowFinish are correct here.  There is an
    ! assumption that refGPH and temperature have the same horizontal basis.
d787 5
d951 1
a951 1
      CALL allocate_test ( t_der_path_flags, no_ele,          't_der_path_flags', &
d1076 4
a1079 5
    if ( toggle(emit) .and. levels(emit) > 0 ) &
                  & call Trace_End ( 'ForwardModel.Hydrostatic' )

    if ( toggle(emit) .and. levels(emit) > 0 ) &
                  & call Trace_Begin ( 'ForwardModel.SidebandLoop' )
d2183 1
a2183 1
        & call trace_end ( 'ForwardModel.sideband ',index=thisSideband )
d2618 3
@


2.157
log
@Anticipative bug fix commented out.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.156 2003/07/04 03:40:13 vsnyder Exp $"
d885 1
a885 1
    CALL allocate_test(true_path_flags,no_ele,'true_path_flags',moduleName)
d946 1
a946 1
      CALL allocate_test( t_der_path_flags,no_ele,    't_der_path_flags', &
d2036 1
d2614 3
@


2.156
log
@Simplify dump in case exp(incoptdepth_pol) fails
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.155 2003/07/04 02:50:15 vsnyder Exp $"
d2033 3
a2035 1
          sidebandFraction => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
d2613 3
@


2.155
log
@Simplify interface to Get_GL_Slabs_Arrays, correct a blunder introduced around July 17
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.154 2003/06/27 23:43:34 vsnyder Exp $"
d1431 1
a1431 1
          &  fwdModelConf%Do_1D,true_path_flags(1:no_ele))
d1436 1
a1436 1
            &  fwdModelConf%Do_1D,t_der_path_flags(1:no_ele) )
d1439 1
a1439 1
            &  fwdModelConf%Do_1D,t_der_path_flags(1:no_ele) )
d1688 4
a1691 16
              call output ( real(incoptdepth_pol(1,1,-p_stop)), &
                & format='("(",1pg15.7,",")' )
              call output ( aimag(incoptdepth_pol(1,1,-p_stop)), &
                & format='(1pg15.7,")")   ' )
              call output ( real(incoptdepth_pol(1,2,-p_stop)), &
                & format='("(",1pg15.7,",")' )
              call output ( aimag(incoptdepth_pol(1,2,-p_stop)), &
                & format='(1pg15.7,")")', advance='yes' )
              call output ( real(incoptdepth_pol(2,1,-p_stop)), &
                & format='("(",1pg15.7,",")' )
              call output ( aimag(incoptdepth_pol(2,1,-p_stop)), &
                & format='(1pg15.7,")")   ' )
              call output ( real(incoptdepth_pol(2,2,-p_stop)), &
                & format='("(",1pg15.7,",")' )
              call output ( aimag(incoptdepth_pol(2,2,-p_stop)), &
                & format='(1pg15.7,")")', advance='yes' )
d2611 3
@


2.154
log
@Remove unreferenced USE names
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.153 2003/06/27 22:09:48 vsnyder Exp $"
d1431 1
a1431 1
          &  no_ele, fwdModelConf%Do_1D,true_path_flags(1:no_ele))
d1436 1
a1436 1
            &  no_ele, fwdModelConf%Do_1D,t_der_path_flags(1:no_ele) )
d1439 1
a1439 1
            &  no_ele, fwdModelConf%Do_1D,t_der_path_flags(1:no_ele) )
d1572 1
a1572 1
                    & sps_path(indices_c(j),:) ) * tanh1_c(j) * del_s(j)
d1586 1
a1586 1
                incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) - &
d1588 3
a1590 3
                incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j)
                incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j)
                incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) - &
d2623 3
@


2.153
log
@Check status from rad_tran_pol and report an error if overflow occurred
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.152 2003/06/27 00:59:53 vsnyder Exp $"
d54 1
a54 1
    use Intrinsic, only: L_CHANNEL, L_CLOUDICE, L_CLOUDWATER, &      ! JJ
d56 1
a56 1
      & L_ELEVOFFSET, L_LOSVEL, L_MAGNETICFIELD, L_NONE, L_ORBITINCLINATION,  &
d66 1
a66 1
    use Mcrt_m, only: Mcrt, Mcrt_der
d2623 3
@


2.152
log
@Simplify interface to Get_Species_Data
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.151 2003/06/25 02:41:37 vsnyder Exp $"
d77 1
d345 1
a345 1
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL
a815 2
      nl = size(My_Catalog(i)%Lines)
      gl_slabs(:,i)%no_lines = nl
d817 1
a817 1
        call AllocateOneSlabs ( gl_slabs(j,i), nl )
a828 2
        gl_slabs_m(:,i)%no_lines = nl
        gl_slabs_p(:,i)%no_lines = nl
d1684 24
d2623 3
@


2.151
log
@Futzing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.150 2003/06/18 22:26:41 vsnyder Exp $"
d508 1
a508 3
    call get_species_data ( fwdModelConf%molecules, fwdModelConf, &
      & fwdModelIn, fwdModelExtra, &
      & fwdModelConf%sidebandStart, fwdModelConf%sidebandStop, &
d2602 3
@


2.150
log
@Restored the check to the wrong place at 2.149
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.149 2003/06/18 19:29:30 vsnyder Exp $"
d1244 1
a1244 4
!
            DO i = 1 , no_ele
              t_der_path_flags(i) = ANY(do_calc_t(i,:))
            ENDDO
d1278 1
a1278 3
            DO i = 1 , no_ele
              t_der_path_flags(i) = ANY(do_calc_t(i,:))
            ENDDO
d2604 3
@


2.149
log
@Replace a check inadvertently deleted in rev 2.146
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.148 2003/06/18 17:23:16 bill Exp $"
a505 5
    ! Check that RefGPH and Temp have the same hGrid.  This is not checked in
    ! Construct or when the config is created.
    if ( .not. doHGridsMatch ( refGPH, temp ) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, 'Different horizontal grids for refGPH and temperature' )

d571 5
d706 2
a707 2
    ! Temperature's windowStart:windowFinish are correct here.  There is an
    ! assumption that refGPH and temperature have the same horizontal basis.
d2609 3
@


2.148
log
@fixed NAG associated bug
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.147 2003/06/18 14:54:04 bill Exp $"
a107 1
    character(len=*), parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d506 5
d2609 3
@


2.147
log
@added subsetting feature for T-ders
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.146 2003/06/18 01:59:20 vsnyder Exp $"
d1517 1
a1517 1
            &  t_der_path_flags(1:no_ele),                        &
d1628 1
a1628 1
            & t_der_path_flags(1:no_ele),                             &
d2605 3
@


2.146
log
@Move checking that all signals in config are for same radiometer, module
and sideband, and computation of sidebandStart and sidebandStop, to
ForwardModelSupport.  Remove vector quantity validation, as that's now
done in Construct.  Futzing.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.145 2003/06/13 00:00:27 vsnyder Exp $"
d206 4
d494 1
a494 1
      & t_script, &
d886 2
d947 2
d1240 4
d1277 3
d1437 1
a1437 1
          &  no_ele, fwdModelConf%Do_1D )
d1442 1
a1442 1
            &  no_ele, fwdModelConf%Do_1D )
d1445 1
a1445 1
            &  no_ele, fwdModelConf%Do_1D )
d1517 1
d1628 1
d1742 1
a1742 1
              & tau(1:npc), i_stop,        &
d2314 1
d2347 2
d2605 6
@


2.145
log
@Move multiplication of beta_path by tanh into FullForwardModel
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.144 2003/06/10 15:06:54 bill Exp $"
d92 1
a92 2
    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
                         &   GETVECTORQUANTITYBYTYPE
d94 1
a94 1
    type(forwardModelConfig_T), intent(inout) :: fwdModelConf
d131 1
a135 1
    integer :: MAXSUPERSET              ! Max. value of superset
d141 1
a141 1
    integer :: M                        ! Loop index and other uses ..
a155 3
    integer :: SIDEBANDSTART            ! Loop limit
    integer :: SIDEBANDSTEP             ! Loop step
    integer :: SIDEBANDSTOP             ! Loop limit
d158 1
a181 1
    integer, dimension(:), pointer :: SUPERSET ! Used for matching signals
a230 1
    real(rp), dimension(:), pointer :: DRAD_DF      ! dI/dVmr
a251 1
    real(rp), dimension(:), pointer :: REQS         ! Accumulation of REQ
a259 1
    real(rp), dimension(:), pointer :: TAN_HTS      ! Accumulation of ONE_TAN_HT
a260 1
    real(rp), dimension(:), pointer :: TAN_TEMPS    ! Accumulation of ONE_TAN_TEMP
d316 1
a316 1
    real(rp), dimension(:,:), pointer :: K_ATMOS_FRQ  ! Storage for Atmos deriv.
a378 1
    type (VectorValue_T), pointer :: FIRSTRADIANCE ! Radiance qty for first signal
d392 1
a392 1
    type (Signal_T) :: FIRSTSIGNAL      ! The first signal we're dealing with
d409 5
d471 1
a471 1
      & do_calc_zp, do_calc_iwc_zp, do_gl, drad_df, &
d485 4
a488 4
      & radiances, RadV, ref_corr, req_out, reqs, scat_src%values, &
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, superset, &
      & tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tan_hts, &
      & tan_phi, tan_temp, tan_temps, tanh1_c, tanh1_f, tau, &
d493 3
d500 2
a501 41
    firstSignal = fwdModelConf%signals(1)

    ! Now make sure all the signals we're dealing with are same module,
    ! radiometer and sideband.
    if ( any( fwdModelConf%signals%sideband /= firstSignal%sideband ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config" )
    if ( any( fwdModelConf%signals%radiometer /= firstSignal%radiometer ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed radiometers in forward model config" )

    ! Think about sidebands
    if ( ( fwdModelConf%signals(1)%sideband == 0 ) .and.&
      &  ( fwdModelConf%signals(1)%singleSideband == 0 ) ) then
      ! Do a folded measurement
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      ! It's either a single sideband radiometer, or the user requested a
      ! specific sideband.
      ! Check sanity, if they are both non zero they should be the same.
      if ( ( fwdModelConf%signals(1)%singleSideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%sideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%singleSideband /= &
        &    fwdModelConf%signals(1)%sideband ) ) call MLSMessage ( &
        &      MLSMSG_Error, ModuleName, &
        &      "User requested a sideband that doesn't exist" )
      ! OK, use whichever one is given
      if ( fwdModelConf%signals(1)%singleSideband /= 0 ) then
        sidebandStart = fwdModelConf%signals(1)%singleSideband
      else
        sidebandStart = fwdModelConf%signals(1)%sideband
      end if
      sidebandStop = sidebandStart
      sidebandStep = 1
    end if

    ! Now from that we identify the radiance quantity we'll be outputting
    firstRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal=firstSignal%index, sideband=firstSignal%sideband )
d506 2
a507 1
      & fwdModelIn, fwdModelExtra, sidebandStart, sidebandStop, &
a567 19
    ! Now we're going to validate the quantities we've been given; don't
    ! forget we already know what their quantityType's are as that's how we
    ! found them, so we don't need to check that.
    if ( .not. ValidateVectorQuantity(temp, stacked=.TRUE., coherent=.TRUE., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(refGPH, stacked=.TRUE., coherent=.TRUE., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'refGPH' )
    if ( .not. doHGridsMatch ( refGPH, temp ) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, 'Different horizontal grids for refGPH and temperature' )
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.TRUE., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'ptan' )
    if ( .not. ValidateVectorQuantity(phitan, minorFrame=.TRUE., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'phitan' )
    ! There will be more to come here.

d597 3
a601 3
      if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.TRUE.,&
        & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, InvalidQuantity//'radiance' )
d728 4
a731 3
    call allocate_test ( tan_hts,       no_tan_hts, 'tan_hts',       moduleName )
    call allocate_test ( tan_temps,     no_tan_hts, 'tan_temps',     moduleName )
    call allocate_test ( reqs,          no_tan_hts, 'reqs',          moduleName )
a944 1
      call allocate_test ( dRad_df, size(grids_f%values), 'dRad_df', moduleName )
d1071 1
a1071 1
    do thisSideband = sidebandStart, sidebandStop, sidebandStep
d1082 2
a1083 2
        call allocate_test ( superset, size(pointingGrids), &
          & 'superset', moduleName )
d1085 1
a1085 1
          superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
d1087 4
d1092 1
a1092 1
        if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error,ModuleName, &
a1093 4
        maxSuperset = maxval ( superset )
        where ( superset < 0 ) superset = maxSuperset + 1
        whichPointingGrid = minloc ( superset, 1 )
        call deallocate_test ( superset, 'superset', moduleName )
d1279 4
a1282 5
        ! Fill the diagnostic arrays
        !??? tan_temps is only used in a commented-out call to dump ???
        tan_temps ( ptg_i ) = one_tan_temp ( 1 )
        tan_hts ( ptg_i ) = one_tan_ht ( 1 )
        reqs ( ptg_i ) = req
d1470 1
a1470 1
          frqhk = 0.5_r8 * frq * h_over_k
d1515 4
a1518 3
            alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                    & beta_path_c(1:npc,:), DIM=2) +  &
                                    & beta_path_cloud_c(1:npc)
d1520 2
a1521 1
            incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1530 3
a1532 2
            alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                    & beta_path_c(1:npc,:), DIM=2)
d1534 2
a1535 1
            incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1562 1
a1562 1
                    & sps_path(indices_c(j),:) ) * tanh1_c(j)
d1576 1
a1576 1
                incoptdepth_pol(1,1,j) = - incoptdepth_pol(1,1,j) * del_s(j) - &
d1578 3
a1580 3
                incoptdepth_pol(2,1,j) = - incoptdepth_pol(2,1,j) * del_s(j)
                incoptdepth_pol(1,2,j) = - incoptdepth_pol(1,2,j) * del_s(j)
                incoptdepth_pol(2,2,j) = - incoptdepth_pol(2,2,j) * del_s(j) - &
d1587 1
d1615 5
a1619 2
          alpha_path_f(1:ngl) = SUM(sps_path(gl_inds(1:ngl),:) *  &
                                  & beta_path_f(1:ngl,:), DIM=2)
d1629 1
a1629 1
          ! Compute Scatering source function !JJ under construction
d1640 3
a1642 3
              & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),         &
              & incoptdepth(1:npc), alpha_path_f(1:ngl),                    &
              & path_dsdh, dhdz_path, t_script(1:npc), tau(1:npc),          &
d1645 1
a1645 2
          else
          ! Polarized model
d1647 1
a1647 1
            i_stop = npc
a1652 1
            ! POLARIZED
d1658 8
a1665 9
            alpha_path_polarized_f(-1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f(-1,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.25 * alpha_path_f(1:ngl)
            alpha_path_polarized_f( 0,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f( 0,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.5 * alpha_path_f(1:ngl)
            alpha_path_polarized_f(+1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f(+1,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.25 * alpha_path_f(1:ngl)
d1690 1
a1690 3
              &  t_script(1:npc), tau(1:npc), i_stop, drad_df )

            k_atmos_frq(frq_i,1:size(grids_f%values)) = drad_df(1:size(grids_f%values))
a1998 3
      call allocate_test ( superset, size(antennaPatterns), &
        & 'superset', moduleName )

d2009 1
a2009 1
        if ( sidebandStart /= sidebandStop ) then   ! We're folding
d2025 1
a2025 1
        update = ( thisSideband /= sidebandStart )
d2029 2
d2032 1
a2032 1
            superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
d2035 4
d2040 1
a2040 3

          if ( all( superset < 0 ) ) &
            call MLSMessage ( MLSMSG_Error, ModuleName, &
a2042 4
          maxSuperset = maxval ( superset )
          where ( superset < 0 ) superset = maxSuperset + 1
          whichPattern = minloc ( superset, 1 )

a2133 1
      call deallocate_test ( superset, 'superset', moduleName )
a2235 3
    call deallocate_test ( tan_hts,       'tan_hts',       moduleName )
    call deallocate_test ( tan_temps,     'tan_temps',     moduleName )
    call deallocate_test ( reqs,          'reqs',          moduleName )
d2239 5
a2334 1
      call deallocate_test ( dRad_df, 'dRad_df', moduleName )
d2585 3
@


2.144
log
@fixed polarized t-derivs
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.143 2003/06/09 20:52:37 vsnyder Exp $"
a1411 1
          !??? Do we need to transpose the rotation matrix ???
d1419 1
a1419 2
            ! Put the magnitude of mag_path(j,1:3) in mag_path(j,4), then
            ! normalize mag_path(j,1:3).
d1421 6
a1427 9
          WHERE (mag_path(:,4) /= 0.0_rp) 
            mag_path(:,1) = mag_path(:,1) / mag_path(:,4)
            mag_path(:,2) = mag_path(:,2) / mag_path(:,4)
            mag_path(:,3) = mag_path(:,3) / mag_path(:,4)
          ELSEWHERE
            mag_path(:,1) = 0.0_rp
            mag_path(:,2) = 0.0_rp
            mag_path(:,3) = 0.0_rp
          ENDWHERE
a1428 1
          !??? The second subscript depends on the ordering of the rotation matrix ???
d1600 2
a1601 2
              call get_beta_path_polarized ( frq, h, my_Catalog, beta_group, gl_slabs, &
                & indices_c(1:npc), beta_path_polarized )
d1603 17
a1619 6
              alpha_path_polarized(-1,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized(-1,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
              alpha_path_polarized( 0,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized( 0,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
              alpha_path_polarized(+1,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized(+1,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
d1625 3
a1627 1
              ! 0.5 factors scalar unpolarized "power absorption" to get "field absorption" 
d1629 8
a1636 6
              incoptdepth_pol(1,1,1:npc) = - incoptdepth_pol(1,1,1:npc) * del_s(1:npc) - &
                   & 0.5*incoptdepth(1:npc)
              incoptdepth_pol(2,1,1:npc) = - incoptdepth_pol(2,1,1:npc) * del_s(1:npc)
              incoptdepth_pol(1,2,1:npc) = - incoptdepth_pol(1,2,1:npc) * del_s(1:npc)
              incoptdepth_pol(2,2,1:npc) = - incoptdepth_pol(2,2,1:npc) * del_s(1:npc) - &
                   & 0.5*incoptdepth(1:npc)
d1638 1
a1638 1
              do j = 1, npc
d1797 1
a1797 2
                & beta_path_polarized(:,1:p_stop,:), tanh1_c(1:p_stop),       &
                & sps_path,                                                   &
d2644 3
@


2.143
log
@More work on polarized derivatives
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.142 2003/06/09 17:38:47 livesey Exp $"
a1422 1
            mag_path(j,1:3) = mag_path(j,1:3) / mag_path(j,4)
d1424 9
d1788 2
a1789 1
                & beta_path_polarized(:,1:p_stop,:), sps_path,                &
d2636 3
@


2.142
log
@Use GetQuantityForForwardModel in more places
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.141 2003/05/29 16:37:38 livesey Exp $"
a50 1
    use Get_GL_delta_m, only: Get_GL_Delta
d80 2
a81 1
    use RAD_TRAN_M, only: RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, DRAD_TRAN_DX
d154 1
d214 1
a219 1
    real(rp) :: RAD           ! Radiance
d286 3
d446 2
d463 1
a463 1
      & channelOrigins, d_rad_pol_dt, d_t_scr_dt, &
a964 1
      call allocate_test ( d_t_scr_dt, npc, sv_t_len, 'd_t_scr_dt', moduleName )
d966 32
a997 28
      call allocate_test ( dbeta_dt_path_c,      npc, no_mol, 'dbeta_dt_path_c', &
                         & moduleName )
      call allocate_test ( dbeta_dt_path_f, no_ele, no_mol, 'dbeta_dt_path_f', &
                         & moduleName )
      call allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', &
                         & moduleName )
      call allocate_test ( dh_dt_path_c, no_ele, sv_t_len, 'dh_dt_path_c', &
                         & moduleName )
      call allocate_test ( dh_dt_path_f, no_ele, sv_t_len, 'dh_dt_path_f', &
                         & moduleName )
      call allocate_test ( do_calc_hyd, no_ele, sv_t_len, 'do_calc_hyd', &
                         & moduleName )
      call allocate_test ( do_calc_hyd_c, no_ele, sv_t_len, 'do_calc_hyd_c', &
                         & moduleName )
      call allocate_test ( do_calc_t, no_ele, sv_t_len, 'do_calc_t', &
                         & moduleName )
      call allocate_test ( do_calc_t_c, no_ele, sv_t_len, 'do_calc_t_c', &
                         & moduleName )
      call allocate_test ( do_calc_t_f, no_ele, sv_t_len, 'do_calc_t_f', &
                         & moduleName )
      call allocate_test ( eta_zxp_t, no_ele, sv_t_len, 'eta_zxp_t', &
                         & moduleName )
      call allocate_test ( eta_zxp_t_c, no_ele, sv_t_len, 'eta_zxp_t_c', &
                         & moduleName )
      call allocate_test ( eta_zxp_t_f, no_ele, sv_t_len, 'eta_zxp_t_f', &
                         & moduleName )
      call allocate_test ( tan_dh_dt,1,sv_t_len, 'tan_dh_dt', moduleName )
      call allocate_test ( tan_d2h_dhdt,1,sv_t_len, 'tan_d2h_dhdt', moduleName )
d1608 1
d1655 4
d1673 5
a1677 6
            call rad_tran ( indices_c(1:npc), gl_inds(1:ngl), Frq,  &
              & spaceRadiance%values(1,1), e_rflty, z_path_c, t_path_c(1:npc), &
              & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc), &
              & incoptdepth(1:npc), alpha_path_f(1:ngl),            &
              & path_dsdh, dhdz_path, t_script(1:npc),              &
              & tau(1:npc), Rad, i_stop )
a1678 1
            RadV(frq_i) = Rad
d1680 3
a1682 1
         !Polarized model
d1704 9
a1712 29
            ! polarized flavor of get_gl_delta
            call get_gl_delta ( indices_c(1:npc), gl_inds(1:ngl), do_gl(1:npc), z_path, &
              &  alpha_path_polarized(:, 1:npc), alpha_path_polarized_f(:,1:ngl), &
              &  path_dsdh, dhdz_path, gl_delta_polarized )

            ! get gl corrections to incoptdepth_pol
            call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
              & gl_delta_polarized(:,1:npc), incoptdepth_pol_gl(:,:,1:npc) )

            ! add GL corrections to incoptdepth_pol
            incoptdepth_pol(:,:,1:npc) = incoptdepth_pol(:,:,1:npc) - &
              &  incoptdepth_pol_gl(:,:,1:npc);

            ! At this point, incoptdepth_pol(:,:,1:npc/2) should be nearly
            ! identical to incoptdepth_pol(:,:,1:npc/2+1) (npc/2 is the
            ! zero-thickness tangent layer).

            do j = 1, npc
              call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
            end do

            call two_d_t_script ( t_path(indices_c(1:npc)), spaceRadiance%values(1,1), frq, &
              & t_script(1:npc) )
            call mcrt ( t_script(1:npc), sqrt(e_rflty), deltau_pol(:,:,1:npc), &
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), rad_pol )

            !Assume antenna is only sensitive to the first linear polarization
            if ( index(switches,'crosspol') /= 0 ) then
               RadV(frq_i) = real(rad_pol(2,2))
d1714 1
a1714 1
               RadV(frq_i) = real(rad_pol(1,1))
d1716 1
a1716 1
  
d1749 2
d1765 5
a1769 1
              & drad_dt )
d1771 1
a1771 1
            k_temp_frq(frq_i,:) = drad_dt
d1773 1
a1773 2
            ! Temperature derivatives for polarized radiance if needed
            if ( FwdModelConf%polarized ) then
a1775 7
              call get_d_deltau_pol_dT ( frq, h, ct, stcp, stsp, my_catalog, &
                & beta_group, gl_slabs_m, gl_slabs_p, &
                & t_path_c(1:npc), t_path_m(1:no_ele), t_path_p(1:no_ele), &
                & tanh1_c(1:npc), beta_path_polarized(:,1:npc,:), &
                & sps_path, eta_zxp_t_c(1:npc,:), &
                & del_s(1:npc), indices_c(1:npc), incoptdepth_pol(:,:,1:npc), &
                & de_dt(:,:,1:npc,:) )
d1777 12
d1792 9
a1800 5
              call mcrt_der ( t_script(1:npc), d_t_scr_dt(1:npc,:), &
                & de_dt(:,:,1:npc,:), prod_pol(:,:,1:npc), &
                & tau_pol(:,:,1:npc), do_calc_t_c(1:npc,:), d_rad_pol_dt )

              k_temp_frq(frq_i,:) = drad_dt + real(d_rad_pol_dt(1,1,:))
d1808 2
a1809 1
            ! Spectroscopic derivative  wrt: W
d1811 40
a1850 40
            do_calc_dw_f(:ngl,:) = do_calc_dw(gl_inds(:ngl),:)
            eta_zxp_dw_f(:ngl,:) = eta_zxp_dw(gl_inds(:ngl),:)
            call drad_tran_dx ( z_path_c(1:npc), Grids_dw,                    &
              &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw_c(1:npc,:),             &
              &  sps_path(indices_c(1:npc),:), do_calc_dw_c(1:npc,:),                  &
              &  dbeta_dw_path_f(:ngl,:), eta_zxp_dw_f(:ngl,:),  &
              &  sps_path(gl_inds(1:ngl),:), &
              &  do_calc_dw_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
              &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dw )

            k_spect_dw_frq(frq_i,1:1:f_len_dw) = drad_dw(1:1:f_len_dw)

            ! Spectroscopic derivative  wrt: N

            do_calc_dn_f(:ngl,:) = do_calc_dn(gl_inds(:ngl),:)
            eta_zxp_dn_f(:ngl,:) = eta_zxp_dn(gl_inds(:ngl),:)
            call drad_tran_dx ( z_path_c(1:npc), Grids_dn,                    &
              &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn_c(1:npc,:),             &
              &  sps_path(indices_c(1:npc),:), do_calc_dn_c(1:npc,:),                  &
              &  dbeta_dn_path_f(:ngl,:), eta_zxp_dn_f(:ngl,:), &
              &  sps_path(gl_inds(1:ngl),:), &
              &  do_calc_dn_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
              &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)), dhdz_path(gl_inds(1:ngl)),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dn )

            k_spect_dn_frq(frq_i,1:f_len_dn) = drad_dn(1:f_len_dn)

            ! Spectroscopic derivative  wrt: Nu0

            do_calc_dv_f(:ngl,:) = do_calc_dv(gl_inds(:ngl),:)
            eta_zxp_dv_f(:ngl,:) = eta_zxp_dv(gl_inds(:ngl),:)
            call drad_tran_dx ( z_path_c(1:npc), Grids_dv,                    &
              &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv_c(1:npc,:),             &
              &  sps_path(indices_c(1:npc),:), do_calc_dv_c(1:npc,:),                  &
              &  dbeta_dv_path_f(:ngl,:), eta_zxp_dv_f(:ngl,:), &
              &  sps_path(gl_inds(1:ngl),:), &
              &  do_calc_dv_f(:ngl,:), do_gl(1:npc), del_s(1:npc),            &
              &  ref_corr(1:npc), path_dsdh(gl_inds(1:ngl)),dhdz_path(gl_inds(1:ngl)),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dv )
d1852 2
a1853 1
            k_spect_dv_frq(frq_i,1:1:f_len_dv) = drad_dv(1:1:f_len_dv)
d2349 1
d2627 3
@


2.141
log
@Renamed sideband fraction
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.140 2003/05/26 01:42:50 michael Exp $"
d589 6
a594 6
      cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_cloudIce, noError=.true. )
      cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_cloudWater, noError=.true. )
      sizeDistribution => GetVectorQuantityByType( fwdModelIn, fwdModelExtra, &
        & quantityType=l_sizeDistribution, noError=.true. )
d597 2
a598 2
      boundaryPressure => GetVectorQuantityByType( fwdModelIn, fwdModelExtra, &
        & quantityType=l_boundaryPressure )
d2616 3
@


2.140
log
@Two temporary fixes only relevant to the polarized model.
Added a bug-fix removing scalar contribution to magnetic GL.
I don't know why this works but it makes agreement with scalar model
much better.  I also added an undocumented switch -Scrosspol to allow
the use of the (2,2) element of the radiance tensor rather than the (1,1).
This code should be removed when we set up the l2cf to do this properly.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.139 2003/05/22 20:01:17 vsnyder Exp $"
d58 1
a58 1
      & L_PHITAN, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, L_SIDEBANDRATIO, &
d221 1
a221 1
    real(rp) :: THISRATIO     ! A sideband ratio
d391 1
a391 1
    type (VectorValue_T), pointer :: SIDEBANDRATIO ! The sideband ratio to use
d2042 3
a2044 2
          sidebandRatio => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_sidebandRatio, signal=fwdModelConf%signals(sigInd)%index, &
d2046 1
a2046 1
          thisRatio = sidebandRatio%values(chanInd,1)
d2048 1
a2048 1
          thisRatio = 1.0
d2084 1
a2084 1
               & dhdz_out, dx_dh_out, thisRatio,                               &
d2093 1
a2093 1
               & dhdz_out, dx_dh_out, thisRatio,                               &
d2104 1
a2104 1
               & dhdz_out, dx_dh_out, thisRatio,                               &
d2114 1
a2114 1
               & dhdz_out, dx_dh_out, thisRatio,                               &
d2133 1
a2133 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
d2140 1
a2140 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
d2148 1
a2148 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
d2156 1
a2156 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
d2616 8
@


2.139
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.138 2003/05/22 04:03:41 livesey Exp $"
d1602 1
a1602 1
!???? Added 1/2 terms to scalar "power absorption" to get "field absorption" 
a1604 1
!                  & incoptdepth(1:npc)
a1608 1
!                  & incoptdepth(1:npc)
d1670 3
a1672 2
!??????  This seems not to do the job, though it makes agreement better
alpha_path_f = 0.5 * alpha_path_f
d1717 6
a1722 1
            RadV(frq_i) = real(rad_pol(1,1))
d2615 3
@


2.138
log
@Now handles elevation offset as a channel by channel quantity
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.137 2003/05/20 00:05:39 vsnyder Exp $"
d929 4
a932 4
    call allocate_test ( do_calc_zp,    no_ele, grids_f%p_len,  'do_calc_zp',    moduleName )
    call allocate_test ( eta_fzp,       no_ele, size(grids_f%values),  'eta_fzp',       moduleName )
    call allocate_test ( eta_zp,        no_ele, grids_f%p_len,  'eta_zp',        moduleName )
    call allocate_test ( sps_path,      no_ele, no_mol, 'sps_path',      moduleName )
d990 1
a990 1
    end if
d1274 1
a1274 1
              &  ETA_ZXP=eta_zxp_t(1:no_ele,:),                              &
d2611 3
@


2.137
log
@Move some stuff to subroutines
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.136 2003/05/15 03:29:44 vsnyder Exp $"
d222 1
a568 3
    elevOffset => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_elevOffset, radiometer=firstSignal%radiometer, &
      & config=fwdModelConf )
a617 4
    if ( .not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
      & frequencyCoordinate=(/l_none/), noInstances=(/1/)) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'elevOffset' )
d756 1
a756 1
       & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
d822 1
a822 1
       & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
a2027 1

d2031 1
d2036 1
d2045 5
d2077 2
a2078 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2086 2
a2087 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2097 2
a2098 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2107 2
a2108 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2126 1
a2126 1
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out,          &
d2133 1
a2133 1
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out,          &
d2141 1
a2141 1
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out,          &
d2149 1
a2149 1
              &  Grids_tmp%deriv_flags, ptg_angles, tan_chi_out,          &
d2611 3
@


2.136
log
@Implement polarized model's temperature derivatives
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.135 2003/05/09 19:26:36 vsnyder Exp $"
d72 1
a72 1
    use MLSNumerics, ONLY: Hunt, InterpolateValues
a128 1
    integer :: JF                       ! Loop index and other uses ..
d137 4
a140 1
    integer :: MAXVERT                  ! Number of points in gl grid
a143 1
    integer :: NLM1                     ! Nlvl - 1
d323 6
a328 6
    real(rp), dimension(:,:), pointer :: K_TEMP_FRQ ! Storage for Temp. deriv.
    real(rp), dimension(:,:), pointer :: MAG_PATH   ! Magnetic field on path
    real(rp), dimension(:,:), pointer :: RADIANCES  ! (Nptg,noChans)
    real(rp), dimension(:,:), pointer :: SPS_PATH   ! species on path
    real(rp), dimension(:,:), pointer :: TAN_DH_DT  ! dH/dT at Tangent
    real(rp), dimension(:,:), pointer :: T_GLGRID   ! Temp on glGrid surfs
d470 1
a470 1
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, eta_iwc, &
d553 2
a554 2
        &  quantitytype = l_vmr, molIndex=mol_cat_index(sps_i), config=fwdModelConf, &
        &  radiometer = firstsignal%radiometer, foundInFirst=qtys(sps_i)%foundInFirst )
d642 1
a642 1
    sv_t_len = grids_tmp%l_z(1) * grids_tmp%l_p(1)
d768 1
a768 1
    call compute_GL_grid ( fwdModelConf, temp, qtys, nlvl, nlm1, maxVert, &
a770 4
    surfaceTangentIndex = COUNT(tan_inds == 1)

    no_tan_hts = size(tan_inds)

d782 3
a784 1
! Compute tan_press from fwdModelConf%tangentGrid%surfs
a785 2
    call allocate_test ( tan_phi,       no_tan_hts, 'tan_phi',       moduleName )
    call allocate_test ( est_scgeocalt, no_tan_hts, 'est_scgeocalt', moduleName )
d790 4
a793 46
! estimate tan_phi

    j = no_tan_hts - nlvl

    tan_phi(1:j) = phitan%values(1,MAF)
    est_scgeocalt(1:j) = scGeocAlt%values(1,maf)

! Since the interpolateValues routine needs the OldX array to be sorted
! we have to sort ptan%values and re-arrange phitan%values & scgeocalt%values

    k = ptan%template%noSurfs
    call allocate_test ( z_path, k, 'z_path', moduleName )
    call allocate_test ( p_path, k, 'p_path', moduleName )
    call allocate_test ( t_path, k, 't_path', moduleName )

    z_path = ptan%values(1:k,maf)
    p_path = phitan%values(1:k,maf)
    t_path = scgeocalt%values(1:k,maf)

    ! Sort z_path.  Permute p_path and t_path the same way.
    do i = 2, k ! Invariant: z_path(1:i-1) are sorted.
      r = z_path(i)
      if ( r < z_path(i-1) ) then
        r1 = p_path(i)
        r2 = t_path(i)
        jf = i
        do ! Find where to insert R.  Make room as we go.
          z_path(jf) = z_path(jf-1)
          p_path(jf) = p_path(jf-1)
          t_path(jf) = t_path(jf-1)
          jf = jf - 1
          if ( jf == 1 ) exit
          if ( r >= z_path(jf-1) ) exit
        end do
        z_path(jf) = r
        p_path(jf) = r1
        t_path(jf) = r2
      end if
    end do

    call interpolateValues ( z_path, p_path, tan_press(j+1:no_tan_hts), &
      &  tan_phi(j+1:no_tan_hts), METHOD = 'L' )
    call interpolateValues ( z_path, t_path, tan_press(j+1:no_tan_hts), &
       & est_scgeocalt(j+1:no_tan_hts), METHOD='L' )

    tan_phi = tan_phi * deg2rad
a794 3
    call deallocate_test ( z_path, 'z_path', moduleName )
    call deallocate_test ( p_path, 'p_path', moduleName )
    call deallocate_test ( t_path, 't_path', moduleName )
a897 19
    call allocate_test ( dhdz_path,   no_ele, 'dhdz_path',   moduleName )
    call allocate_test ( gl_inds,     no_ele, 'gl_inds',     moduleName )
    call allocate_test ( h_path,      no_ele, 'h_path',      moduleName )
    call allocate_test ( h_path_c,    no_ele, 'h_path_c',    moduleName )
    call allocate_test ( h_path_f,    no_ele, 'h_path_f',    moduleName )
    call allocate_test ( path_dsdh,   no_ele, 'path_dsdh',   moduleName )
    call allocate_test ( phi_path,    no_ele, 'phi_path',    moduleName )
    call allocate_test ( p_path,      no_ele, 'p_path',      moduleName )
!???? WHY ARE COARSE GRID QUANTITIES BEING ALLOCATED LENGTH = no_ele ??  
!Is this not four times bigger than needed?
    call allocate_test ( p_path_c,    no_ele, 'p_path_c',    moduleName )
    call allocate_test ( t_path,      no_ele, 't_path',      moduleName )
    call allocate_test ( t_path_c,    no_ele, 't_path_c',    moduleName )
    call allocate_test ( t_path_f,    no_ele, 't_path_f',    moduleName )
    call allocate_test ( t_path_m,    no_ele, 't_path_m',    moduleName )
    call allocate_test ( t_path_p,    no_ele, 't_path_p',    moduleName )
    call allocate_test ( z_path,      no_ele, 'z_path',      moduleName )
    call allocate_test ( z_path_c,    no_ele, 'z_path_c',    moduleName )

d900 2
a901 2
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path__cloud_c', moduleName ) !JJ
    call allocate_test ( beta_path_w0_c, npc, 'beta_path_w0_c',          moduleName ) !JJ
d903 1
d905 4
d912 4
a918 1
    call allocate_test ( tau,                 npc, 'tau',              moduleName )
d921 6
d928 2
d1467 1
a1467 1
              & Req+one_tan_ht(1))
d1469 1
a1469 1
              & Req+one_tan_ht(1))
d1668 1
a1668 1
              & spaceRadiance%values(1,1), e_rflty, z_path, t_path, &
d1731 2
a1732 2
            call drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path, Grids_f,  &
              &  beta_path_c(1:npc,:), eta_fzp, sps_path, do_calc_fzp, &
d1735 1
a1735 1
              &  t_script(1:npc), tau(1:npc), i_stop, drad_df, ptg_i, frq_i)
d1771 1
a1771 1
              & drad_dt, ptg_i, frq_i )
d1781 1
a1781 1
                & t_path_c(1:npc), t_path_m(1:npc), t_path_p(1:npc), &
d1813 1
a1813 1
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dw, ptg_i, frq_i )
d1828 1
a1828 1
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dn, ptg_i, frq_i )
d1843 1
a1843 1
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dv, ptg_i, frq_i )
d2472 2
d2511 89
a2599 1
! --------------------------------------------------  not_used_here  -----
d2607 3
@


2.135
log
@Expect T+DT instead of T and DT separately in Get_GL_Slabs_Arrays,
initial stuff for temperature derivatives of polarized radiance.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.134 2003/05/05 23:00:24 livesey Exp $"
d31 1
d35 1
d50 1
d54 1
a54 1
    use GLnp, only: NG, GX
a64 1
    use Make_Z_Grid_M, only: Make_Z_Grid
a169 2
    integer :: Z_ALL_PREV               ! Z_ALL_SIZE before adding something
    integer :: Z_ALL_SIZE               ! Size of Z_ALL, q.v.
d213 1
a229 1
    real(rp), dimension(:), pointer :: D_T_SCRIPT   ! D Delta_B in some notes
d283 2
d331 1
a331 1
    complex(rp) :: D_RAD_POL_DT(2,2) ! From mcrt_der
d339 1
a355 8
    integer(ip), dimension(:), pointer :: rec_tan_inds ! recommended tangent
!                        point indices from make_z_grid
    real(rp), dimension(:), pointer :: z_all ! mass storage of representation
!                                      bases for z_grid determination
    real(rp), dimension(:), pointer :: z_psig(:) ! recommended PSIG for
!                                      radiative transfer calculations
! THIS VARIABLE REPLACES FwdModelConf%integrationGrid%surfs

d455 1
a455 1
      & channelOrigins, d_t_script, &
d459 1
a459 1
      & ddhidhidtl0, del_s, deltau_pol, &
d480 1
a480 1
      & p_glgrid, p_path, p_path_c, phi_path, prod_pol, ptg_angles, &
d483 2
a484 2
      & tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tan_hts, tan_inds, &
      & tan_phi, tan_press, tan_temp, tan_temps, tanh1_c, tanh1_f, tau, &
d487 1
a487 1
      & usedchannels, usedsignals, wc, z_all, z_glgrid, z_path, z_path_c )
d767 2
a768 2
! Insert automatic preselected integration gridder here. Need to make a
! large concatenated vector of bases and pointings.
d770 1
a770 10
! Calculate size of z_all and allocate it

    z_all_size = temp%template%nosurfs+2 + &
      & Size(FwdModelConf%integrationGrid%surfs)
    if ( associated(FwdModelConf%tangentGrid) ) &
      & z_all_size = z_all_size + FwdModelConf%tangentGrid%nosurfs
    do sps_i = 1 , no_mol
      z_all_size = z_all_size + qtys(sps_i)%qty%template%nosurfs
    end do
    call allocate_test ( z_all, z_all_size, 'z_all', moduleName )
d772 1
a772 2
! Fill in z_all
! the -3.000 is a designated "surface" value
d774 1
a774 37
    z_all_prev = temp%template%nosurfs+2
    z_all(1) = -3.000_rp
    z_all(2:z_all_prev-1) = temp%template%surfs(:,1)
    z_all(z_all_prev) = 4.000_rp

    ! Add the original Integration Grid:
    z_all_size = z_all_prev + Size(FwdModelConf%integrationGrid%surfs)
    z_all(z_all_prev+1:z_all_size) = FwdModelConf%integrationGrid%surfs
    z_all_prev = z_all_size

    if ( associated(FwdModelConf%tangentGrid) ) then
      ! if pointing grid is associated concatenate it to the state vector
      z_all_size = z_all_prev + FwdModelConf%tangentGrid%nosurfs
      z_all(z_all_prev+1:z_all_size) = FwdModelConf%tangentGrid%surfs
      z_all_prev = z_all_size
    end if

    do sps_i = 1 , no_mol
      z_all_size = z_all_size + qtys(sps_i)%qty%template%nosurfs
      z_all(z_all_prev+1:z_all_size) = qtys(sps_i)%qty%template%surfs(:,1)
      z_all_prev = z_all_size
    end do

! Now, create the final grid and discard the temporary array:

    call make_z_grid ( z_all, z_psig, rec_tan_inds )
    call deallocate_test ( z_all, 'z_all', moduleName )

! note that z_psig(1) is the designated surface
    Nlvl = SIZE(z_psig)
    NLm1 = Nlvl - 1
    maxVert = NLm1 * Ngp1 + 1

! Allocate GL grid stuff

    call allocate_test ( z_glGrid,    maxVert, 'z_glGrid', moduleName )
    call allocate_test ( p_glGrid,    maxVert, 'p_glGrid', moduleName )
a784 14
! From the selected integration grid pressures define the GL pressure grid:

    z_glgrid(1:maxVert-1) = reshape ( &
      ! Midpoint of integration grid intervals:
      & spread(0.5_rp * (z_psig(2:Nlvl) + z_psig(1:Nlm1)),1,Ngp1) + &
      ! Half length of integration grid intervals:
      & spread(0.5_rp * (z_psig(2:Nlvl) - z_psig(1:Nlm1)),1,Ngp1) * &
      ! Gauss points (with -1 at front):
      & spread((/-1.0_rp,Gx(1:Ng)/),2,NLm1), (/maxVert-1/))
    z_glgrid(maxVert) = z_psig(Nlvl)
    p_glgrid = 10.0_rp**(-z_glgrid)

    call deallocate_test ( z_psig, 'z_psig', moduleName )

a786 4
    j = COUNT(fwdModelConf%tangentGrid%surfs < (z_glgrid(1) - 0.0001_rp))
    no_tan_hts = Nlvl + j
    call allocate_test ( tan_inds,      no_tan_hts, 'tan_inds',      moduleName )
    call allocate_test ( tan_press,     no_tan_hts, 'tan_press',     moduleName )
a791 3
    tan_inds(1:j) = 1
    tan_inds(j+1:no_tan_hts) = (rec_tan_inds - 1) * Ngp1 + 1
    call deallocate_test ( rec_tan_inds, 'rec_tan_inds', moduleName )
d793 1
a793 4
    tan_press(1:j) = fwdModelConf%tangentGrid%surfs(1:j)
    tan_press(j+1:no_tan_hts) = z_glgrid(tan_inds(j+1:no_tan_hts))

    surfaceTangentIndex = COUNT(tan_inds == 1)
d795 1
a795 1
! estimate tan_phi
d1002 5
a1006 1
      if ( temp_der ) call allocate_test ( d_t_script, npc, 'd_t_script', moduleName )
d1016 1
d1154 3
d1575 3
d1597 2
a1598 2
            & Frq, eta_zp(1:no_ele,:),                           &
            & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
d1601 7
a1607 7
          call get_beta_path ( Frq,                              &     
            &  p_path(1:no_ele), t_path(1:no_ele),               &     
            &  my_Catalog, beta_group, FwdModelConf%polarized,   &     
            &  gl_slabs, indices_c(1:npc), beta_path_c(1:npc,:), &     
            &  gl_slabs_m, t_path_m(1:no_ele),                   &
            &  gl_slabs_p, t_path_p(1:no_ele),                   &
            &  dbeta_dt_path_c, dbeta_dw_path_c,                 &     
a1648 2
              tanh1_c(1:npc) = tanh( 0.5_rp * frq * h_over_k / t_path_c(1:npc) )

d1684 3
d1693 1
a1693 1
            & p_path(1:no_ele), t_path(1:no_ele),                     &
a1737 1
            tanh1_f(1:ngl) = tanh( 0.5_rp * frq * h_over_k / t_path(gl_inds(:ngl)) )
d1794 4
a1801 1
            t_path_f(:ngl) = t_path(gl_inds(:ngl))
d1815 1
a1815 1
              & Req + one_tan_ht(1), dh_dt_path(brkpt,:), frq, do_gl(1:npc),   &
d1820 2
a1821 1
              & dhdz_path(gl_inds(1:ngl)), t_script(1:npc), tau(1:npc), i_stop,        &
d1828 16
a1843 3
              ! Compute D Deltau_Pol / DT from D Incoptdepth_Pol / DT and put
              ! into Deltau_Pol.
              deltau_pol = 0.0
d1845 1
a1845 10
              ! Compute D radiance / DT from Tau, Prod, T_Script, D_T_Script
              ! and D Deltau_Pol / DT (which is in deltau_pol by now).

              d_t_script = 0.5 * h_over_k * frq * &
                         & t_script(1:npc) / t_path(indices_c(1:npc))**2

              call mcrt_der ( t_script(1:npc), d_t_script (1:npc), deltau_pol(:,:,1:npc), &
              & prod_pol(:,:,1:npc), tau_pol(:,:,1:npc), d_rad_pol_dt )

              k_temp_frq(frq_i,:) = drad_dt + real(d_rad_pol_dt(1,1))
d2381 1
d2478 3
d2568 4
@


2.134
log
@Merged in feb03 newfwm branch
@
text
@d14 1
a14 1
    & "$Id$"
d17 1
a17 1
    & "$RCSfile$"
d65 1
a65 1
    use Mcrt_m, only: Mcrt
d106 1
a210 1
    real(rp) :: DEL_TEMP      ! Temp. step-size in evaluation of Temp. power dep.
d229 1
d272 3
a274 1
    real(rp), dimension(:), pointer :: T_SCRIPT     ! ********
d329 1
d337 2
a338 1
    complex(rp), dimension(:,:,:), pointer :: DELTAU_POL
d342 2
a343 1
    complex(rp), dimension(:,:,:), pointer :: TAU_POL
d460 1
a460 1
      & channelOrigins, &
d466 1
a466 1
      & dhdz_glgrid, dhdz_out, dhdz_path, &
d485 1
a485 1
      & p_glgrid, p_path, p_path_c, phi_path, ptg_angles, &
d490 3
a492 3
      & tau_pol, t_glgrid, t_path, t_path_c, t_path_f, t_script, &
      & usedchannels, usedsignals, wc, z_all, &
      & z_glgrid, z_path, z_path_c )
d1035 2
d1077 1
d1214 3
d1223 5
d1447 2
a1591 1
        del_temp = 0.0_rp
d1594 1
a1594 1
          &  no_ele, del_temp, fwdModelConf%Do_1D )
a1596 1
          del_temp = 10.0_rp
d1598 2
a1599 2
            &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_p, &
            &  no_ele, del_temp, fwdModelConf%Do_1D )
d1601 2
a1602 2
            &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_m, &
            &  no_ele, -del_temp, fwdModelConf%Do_1D )
d1669 2
a1670 2
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,            &     
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,            &     
d1759 2
a1760 2
            & gl_slabs_m, t_path(1:no_ele)-del_temp,                  &
            & gl_slabs_p, t_path(1:no_ele)+del_temp,                  &
d1825 4
d1836 1
a1836 1
              & tau_pol(:,:,1:npc), rad_pol)
d1886 19
d2532 5
d2540 3
d2619 4
a2622 1
! $Log$
@


2.133
log
@define RHI as real (rp)
@
text
@d12 1
a12 1
  !---------------------------- RCS Ident Info -------------------------------
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.132 2003/04/22 00:14:45 dwu Exp $"
d17 2
a18 2
    & "$RCSfile: FullForwardModel_m.f90,v $"
!-----------------------------------------------------------------------
d21 1
a21 1
! ---------------------------------------------  FullForwardModel  -----
d25 1
a25 2
  ! This is the full radiative transfer forward model, the workhorse
  ! code
d30 1
a30 1
    use Comp_Sps_Path_Frq_m, only: Comp_Sps_Path_Frq
d32 1
d34 1
a34 1
    use D_Lintrp_m, only: Lintrp
d41 1
a41 1
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
d44 2
a45 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Beta_Group_T,  Get_Beta_Path_Cloud
d48 3
d52 8
a59 8
    use Intrinsic, only: L_TEMPERATURE, L_RADIANCE, L_PHITAN, L_PTAN, &
      & L_ELEVOFFSET, LIT_INDICES, L_ISOTOPERATIO, L_VMR, l_boundaryPressure,&
      & L_ORBITINCLINATION, L_SPACERADIANCE, L_EARTHREFL, L_LOSVEL, &
      & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_REFGPH, &
      & L_CLOUDICE, L_CLOUDWATER, L_SIZEDISTRIBUTION, &
      & l_clear, l_clear_110RH_below_top, l_clear_0RH,l_clear_110RH_below_tropopause

    use Load_sps_data_m, ONLY: LOAD_SPS_DATA, Grids_T, destroygrids_t
d63 3
a65 3
    use ManipulateVectorQuantities, only: FindInstanceWindow, FindClosestInstances
    use MatrixModule_0, only: M_ABSENT, M_BANDED, M_FULL
    use MatrixModule_1, only: CreateBlock, FindBlock, MATRIX_T
d67 1
a67 2
    use MLSCommon, only: I4, R4, R8, RP, IP, FINDFIRST
    use MLSFiles, only: get_free_lun
d69 1
a69 1
      & MLSMSG_Error, MLSMSG_Warning
d71 3
a73 3
    use MLSSignals_m, only: Signal_t, MatchSignal, AreSignalsSuperset, Dump, &
                          & GetNameOfSignal, GetRadiometerFromSignal
    use Molecules, only: L_EXTINCTION, spec_tags
a75 1
    use Output_m, only: OUTPUT
d77 1
d81 2
a82 1
    use SpectroscopyCatalog_m, only: CATALOG_T, LINE_T, LINES, CATALOG
d84 3
a86 2
    use String_table, only: GET_STRING
    use Toggles, only: Emit, Gen, Levels, Switches, Toggle
d91 1
a91 2
                         &   GETVECTORQUANTITYBYTYPE, &
                         &   M_FullDerivatives
d100 4
a103 4
    !-------------------------------------------
    real(r8), dimension(:,:), allocatable :: WC
    integer, dimension(:), allocatable :: IPSD
    !-------------------------------------------
a119 1
    integer :: F_LEN                    ! Total number of f's
d121 1
a121 1
    integer :: H2O_IND                  ! Index of h2o inside f array
d136 1
a149 1
    integer :: P_LEN                    ! Partial number of f's (No freq.)
a156 1
    integer :: SPECTAG                  ! A single spectag
a160 1
    integer :: SV_START                 ! Temporary sv_i
d167 2
a168 4
!-----------------------------------------------------------------------------
    integer :: NU, NUA, NAB, NR, N      ! cloud ext parameters
    integer :: status                   ! allocation status 
    integer, dimension(:), pointer :: closestInstances 
a169 1
    logical :: doThis                   ! Flag for lines
d173 1
a173 1
    character (len=32) :: molName       ! Name of a molecule
d175 1
d179 3
a181 3
    integer, dimension(:), pointer :: GL_INDS ! Index of GL indecies
    integer, dimension(:), pointer :: GRIDS !Heights in ptgGrid for each tangent
    integer, dimension(:), pointer :: INDICES_C ! Indecies on coarse grid
a187 1
    logical, dimension(:), pointer :: LINEFLAG ! Use this line (noLines per species)
d199 1
a199 1
    logical, dimension(:,:), pointer :: DO_CALC_IWC   ! 'Avoid zeros' indicator
d206 1
a206 1
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP    ! 'Avoid zeros' indicator
d218 1
d226 1
a245 4
    real(rp), dimension(:), pointer :: PHI_BASIS_DN ! phi basis per species
    real(rp), dimension(:), pointer :: PHI_BASIS_DV ! phi basis per species
    real(rp), dimension(:), pointer :: PHI_BASIS_DW ! phi basis per species
    real(rp), dimension(:), pointer :: PHI_BASIS    ! phi basis per species
d265 2
a271 4
    real(rp), dimension(:), pointer :: Z_BASIS_DN   ! zeta basis for dw (n_dn_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DV   ! zeta basis for dw (n_dv_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DW   ! zeta basis for dw (n_dw_z)
    real(rp), dimension(:), pointer :: Z_BASIS      ! zeta basis per specie (n_f_zeta)
a275 1
    real(rp), dimension(:,:), pointer :: BETA_PATH   ! Beta on path
d277 2
a278 1
    real(rp), dimension(:),   pointer :: BETA_PATH_cloud_C ! Beta on path coarse
d295 3
a297 1
    real(rp), dimension(:,:), pointer :: ETA_IWC      ! Eta_z x Eta_p * Eta_f
d299 1
a299 1
    real(rp), dimension(:,:), pointer :: ETA_Iwc_ZP       ! Eta_z x Eta_p
a300 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN_C ! ETA_ZXP_DN on coarse grid
d302 1
a303 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV_C ! ETA_ZXP_DV on coarse grid
d305 1
a306 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW_C ! ETA_ZXP_DW on coarse grid
d308 1
a309 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T_C  ! ETA_ZXP_T on coarse grid
d312 1
d318 1
d321 2
a322 3
    real(rp), dimension(:,:), pointer :: IWC_PATH   ! species on path
    real(rp), dimension(:,:), pointer :: TAN_DH_DT ! dH/dT at Tangent
    real(rp), dimension(:,:), pointer :: T_GLGRID ! Temp on glGrid surfs
d326 2
d329 1
d332 6
a337 1
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_P
a340 2
    integer(ip) :: beg_ind, end_ind, beg_ind_z, end_ind_z
    integer(ip) :: beg_ind_p, end_ind_p
d348 1
a348 2
!                        point indecies from make_z_grid
    real(rp), dimension(:), pointer :: z_tmp ! temporary zeta storage
d369 2
d373 6
a378 2
    type (VectorValue_T), pointer :: EARTHREFL ! Earth reflectivity
    type (VectorValue_T), pointer :: ELEVOFFSET ! Elevation offset
d381 7
a387 6
    type (VectorValue_T), pointer :: LOSVEL ! Line of sight velocity
    type (VectorValue_T), pointer :: ORBINCLINE ! Orbital inclination
    type (VectorValue_T), pointer :: PHITAN ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTAN ! Tangent pressure component of state vector
    type (VectorValue_T), pointer :: REFGPH ! Reference geopotential height
    type (VectorValue_T), pointer :: SCGEOCALT ! S/C geocentric altitude /m
d389 1
d391 2
a392 6
    type (VectorValue_T), pointer :: TEMP ! Temperature component of state vector
    type (VectorValue_T), pointer :: THISRADIANCE ! A radiance vector quantity
    type (VectorValue_T), pointer :: TpPressure ! tropopause pressure
    type (VectorValue_T), pointer :: CLOUDICE                   ! Profiles
    type (VectorValue_T), pointer :: CLOUDWATER                 ! Profiles
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION           ! Integer really
a400 2
    type (catalog_T), pointer :: thisCatalogEntry
    type (line_T), pointer :: thisLine
d406 2
d409 1
a409 1
    type (Grids_T) :: Grids_iwc  ! All the coordinates for WC   !JJ
a425 1
    real(rp) :: beta_ratio
d431 3
a433 4
    real(rp) :: RHi                     ! relative humidity
    real(r8) :: refP                    ! the top pressure where supersat is set
    real(r8), dimension(:), pointer :: tempProf

d449 1
a449 1
    ! Nullify all our pointers!
d452 4
a455 2
      & beta_path, beta_path_c, beta_path_cloud_c, beta_path_f, beta_path_polarized, &
      & channelOrigins, d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
d458 2
a459 1
      & ddhidhidtl0, del_s, dh_dt_glgrid, dh_dt_path, dh_dt_path_f, dh_dt_path_c, &
d469 1
a469 1
      & eta_zp, eta_iwc_zp, eta_zxp_dn, eta_zxp_dn_c, eta_zxp_dn_f, &
d473 4
a476 3
      & gl_inds, grids, h_glgrid, h_path, h_path_c, h_path_f, &
      & incoptdepth, incoptdepth_p, indices_c, k_atmos, k_atmos_frq, &
      & k_spect_dn, k_spect_dn_frq, &
d478 9
a486 10
      & k_temp_frq, lineFlag, n_path, path_dsdh, &
      & p_glgrid, p_path, p_path_c, &
      & phi_basis, phi_basis_dn, phi_basis_dv, phi_basis_dw, phi_path, &
      & ptg_angles, radiances, RadV, ref_corr, req_out, &
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, IWC_PATH, &
      & superset, tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tan_inds, &
      & tan_phi, tan_press, tan_temp, tau, t_glgrid, t_path, t_path_c, t_path_f, &
      & t_script, usedchannels, usedsignals, z_all, z_basis, z_basis_dn, &
      & z_basis_dv, z_basis_dw, z_glgrid, z_path, z_path_c, z_tmp, tan_temps, &
      & tan_hts, reqs, cloudIce, cloudWater, sizeDistribution)
d503 27
d534 21
d582 18
a599 20
    tpPressure => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,  &
      & quantityType=l_boundaryPressure, noError=.true. )
    !JJ
    cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,  &
      & quantityType=l_cloudIce, noError=.true. )    
    cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_cloudWater, noError=.true. )
    sizeDistribution=>GetVectorQuantityByType( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sizeDistribution, noError=.true. )

          NU  = fwdModelConf%NUM_SCATTERING_ANGLES
          NUA = fwdModelConf%NUM_AZIMUTH_ANGLES
          NAB = fwdModelConf%NUM_AB_TERMS
          NR  = fwdModelConf%NUM_SIZE_BINS
          N   = fwdModelConf%no_cloud_species

    ! We won't seek for molecules here as we can't have an array of pointers.
    ! When we do want molecule i we would do something like
    ! vmr => GetQuantityForForwardModel (fwdModelIn, fwdModelExtra, &
    !   quantityType=l_vmr, molecule=fwdModelConf.molecules(i))
d607 5
a623 32
    ! Think about sidebands
    if ( ( fwdModelConf%signals(1)%sideband == 0 ) .and.&
      &  ( fwdModelConf%signals(1)%singleSideband == 0 ) ) then
      ! Do a folded measurement
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      ! It's either a single sideband radiometer, or the user requested a
      ! specific sideband.
      ! Check sanity, if they are both non zero they should be the same.
      if ( ( fwdModelConf%signals(1)%singleSideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%sideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%singleSideband /= &
        &    fwdModelConf%signals(1)%sideband ) ) call MLSMessage ( &
        & MLSMSG_Error, ModuleName, &
        & "User requested a sideband that doesn't exist" )
      ! OK, use whichever one is given
      if ( fwdModelConf%signals(1)%singleSideband /= 0 ) then
        sidebandStart = fwdModelConf%signals(1)%singleSideband
      else
        sidebandStart = fwdModelConf%signals(1)%sideband
      end if
      sidebandStop = sidebandStart
      sidebandStep = 1
    end if

 ! Sort out some important dimensions
    noSpecies = size ( fwdModelConf%molecules )
    no_mol = count ( fwdModelConf%molecules > 0)
    n_t_zeta = temp%template%noSurfs

d631 1
a631 34
! Work out the `window' stuff for temperature. Create the Grids_tmp structure:

    call findInstanceWindow ( temp, phitan, maf, fwdModelConf%phiWindow, &
                            & fwdModelConf%windowUnits, windowStart, windowFinish )

    no_sv_p_t = windowFinish-windowStart+1
    sv_t_len = n_t_zeta * no_sv_p_t

    call allocate_test ( grids_tmp%no_z, 1, 'Grids_tmp%no_z', moduleName )
    call allocate_test ( grids_tmp%no_p, 1, 'Grids_tmp%no_p', moduleName )
    call allocate_test ( grids_tmp%no_f, 1, 'Grids_tmp%no_f', moduleName )
    call allocate_test ( grids_tmp%windowstart, 1, 'Grids_tmp%windowstart', &
                       & moduleName )
    call allocate_test ( grids_tmp%windowfinish, 1, 'Grids_tmp%windowfinish', &
                       & moduleName )
    call allocate_test ( grids_tmp%lin_log, 1, 'lin_log', moduleName )
    !JJ
    call allocate_test ( grids_iwc%no_z, 1, 'Grids_iwc%no_z', moduleName )
    call allocate_test ( grids_iwc%no_p, 1, 'Grids_iwc%no_p', moduleName )
    call allocate_test ( grids_iwc%no_f, 1, 'Grids_iwc%no_f', moduleName )
    call allocate_test ( grids_iwc%windowstart, 1, 'Grids_iwc%windowstart', &
                       & moduleName )
    call allocate_test ( grids_iwc%windowfinish, 1, 'Grids_iwc%windowfinish', &
                       & moduleName )
    call allocate_test ( grids_iwc%lin_log, 1, 'lin_log', moduleName )


    grids_tmp%no_f = 1
    grids_tmp%no_z = n_t_zeta
    grids_tmp%no_p = no_sv_p_t
    grids_tmp%lin_log = .false.
    grids_tmp%windowStart(1) = windowStart
    grids_tmp%windowFinish(1) = windowFinish

d633 2
a634 27
    grids_iwc%no_f = 1
    grids_iwc%no_z = n_t_zeta
    grids_iwc%no_p = no_sv_p_t
    grids_iwc%lin_log = .false.
    grids_iwc%windowStart(1) = windowStart
    grids_iwc%windowFinish(1) = windowFinish

! Allocate space for the zeta, phi & freq. basis componenets

    k = sv_t_len
    call allocate_test ( grids_tmp%zet_basis, n_t_zeta, 'Grids_tmp%zet_basis', &
                       & moduleName )
    call allocate_test ( grids_tmp%phi_basis, no_sv_p_t, 'Grids_tmp%phi_basis', &
                       & moduleName )
    call allocate_test ( grids_tmp%frq_basis, 1, 'Grids_tmp%frq_basis', moduleName )
    call allocate_test ( grids_tmp%values, k, 'Grids_tmp%values', moduleName )
    call allocate_test ( grids_tmp%deriv_flags, k, 'Grids_tmp%deriv_flags', &
                       & moduleName )
    !JJ
    call allocate_test ( grids_iwc%zet_basis, n_t_zeta, 'Grids_iwc%zet_basis', &
                       & moduleName )
    call allocate_test ( grids_iwc%phi_basis, no_sv_p_t, 'Grids_iwc%phi_basis', &
                       & moduleName )
    call allocate_test ( grids_iwc%frq_basis, 1, 'Grids_iwc%frq_basis', moduleName )
    call allocate_test ( grids_iwc%values, k, 'Grids_iwc%values', moduleName )
    call allocate_test ( grids_iwc%deriv_flags, k, 'Grids_iwc%deriv_flags', &
                       & moduleName )
d636 5
a640 17
    grids_tmp%frq_basis = 0.0
    grids_tmp%zet_basis = temp%template%surfs(1:n_t_zeta,1)
    grids_tmp%phi_basis = temp%template%phi(1,windowStart:windowFinish)*Deg2Rad
    grids_tmp%values = reshape(temp%values(:,windowStart:windowFinish),(/k/))

    !JJ
    if ( associated ( cloudIce ) ) then
      grids_iwc%frq_basis = 0.0
      grids_iwc%zet_basis = CloudIce%template%surfs(1:n_t_zeta,1)
      grids_iwc%phi_basis = CloudIce%template%phi(1,windowStart:windowFinish)*Deg2Rad
      grids_iwc%values = reshape(CloudIce%values(:,windowStart:windowFinish),(/k/))
    else
      grids_iwc%frq_basis = 0.0
      grids_iwc%zet_basis = 0.0
      grids_iwc%phi_basis = 0.0
      grids_iwc%values = 0.0
    end if
d642 2
a643 2
! ** Initialize to ALL derivatives flags to TRUE :
    grids_tmp%deriv_flags(1:k) = .TRUE.
d645 3
a647 1
! ** Now Load the Temp. derivative coeff. flag according to the L2CF
d649 1
a649 5
    if ( associated(temp%mask) ) Grids_tmp%deriv_flags = RESHAPE((IAND( &
       & M_FullDerivatives,ICHAR(temp%mask(:,WindowStart:WindowFinish)))==0), &
       & (/sv_t_len/))

! Work out which channels are used, also check we have radiances for them.
d682 3
a684 9
    do specie = 1, noSpecies
      l = fwdModelConf%molecules(specie)
      if ( l > 0 ) then
        f => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molIndex=specie, config=fwdModelConf, &
          & radiometer=firstSignal%radiometer )
        maxNoFFreqs = max(maxNoFFreqs, f%template%noChans)
        maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
      end if
a686 157
    allocate ( mol_cat_index(no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'mol_cat_index' )

    mol_cat_index = PACK((/(i,i=1,noSpecies)/),fwdModelConf%molecules > 0)

    allocate ( beta_group(no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'beta_group' )

    k = max(1,noSpecies-no_mol)
    do i = 1, no_mol
      allocate ( beta_group(i)%cat_index(k), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'beta_group%cat_index' )
      allocate ( beta_group(i)%ratio(k), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'beta_group%ratio' )
      beta_group(i)%n_elements = 0
      beta_group(i)%ratio = 0.0
      beta_group(i)%cat_index = 0
    end do

    if ( noSpecies == no_mol ) then ! No grouping

      sv_i = 0
      beta_ratio = 1.0_rp   ! Always, for single element (no grouping)
      do j = 1, noSpecies
        l = fwdModelConf%molecules(j)
!        if ( l == l_extinction ) CYCLE
        sv_i = sv_i + 1
        beta_group(sv_i)%n_elements   = 1
        beta_group(sv_i)%cat_index(1) = j
        beta_group(sv_i)%ratio(1)     = beta_ratio
      end do

    else

      k = noSpecies
      ! gl_inds is a convenient integer temporary array here.  Its use
      ! here has nothing to do with GL.
      call allocate_test ( gl_inds, k+1, 'gl_inds', moduleName )
      gl_inds(1:k) = fwdModelConf%molecules(1:k)
      gl_inds(k+1) = k

      sv_i = 0
      do j = 1, noSpecies
        k = gl_inds(j)
        l = abs(k)
!        if ( l == l_extinction ) CYCLE
        beta_ratio = 1.0_rp
        if ( k > 0 ) then
          if ( gl_inds(j+1) > 0 ) then
            sv_i = sv_i + 1
            beta_group(sv_i)%n_elements   = 1
            beta_group(sv_i)%cat_index(1) = j
            beta_group(sv_i)%ratio(1)     = beta_ratio
          end if
        else
          if ( gl_inds(j-1) > 0) sv_i = sv_i + 1
          f => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
              & quantityType=l_isotoperatio, molecule=l, noError=.TRUE., &
              & config=fwdModelConf )
          if ( associated ( f ) ) beta_ratio = f%values(1,1)
          i = beta_group(sv_i)%n_elements + 1
          beta_group(sv_i)%n_elements   = i
          beta_group(sv_i)%cat_index(i) = j
          beta_group(sv_i)%ratio(i)     = beta_ratio
        end if
      end do

      call deallocate_test ( gl_inds, 'gl_inds', moduleName )

    end if

! Work out which spectroscopy we're going to need ------------------------

    nullify ( my_catalog )
    allocate ( My_Catalog(noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog' )

    do j = 1, noSpecies
      ! Skip if the next molecule is negative (indicates that this one is a
      ! parent)
      if ( (j < noSpecies) .and. (fwdModelConf%molecules(j) > 0) ) then
        if ( fwdModelConf%molecules(j+1) < 0 ) then
          nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
          call allocate_test ( my_catalog(j)%lines, 0, &
                            & 'my_catalog(?)%lines(0)', moduleName )
          cycle
        end if
      end if
      l=abs(fwdModelConf%molecules(j))
      Spectag = spec_tags(l)
      thisCatalogEntry => Catalog(FindFirst(catalog%spec_tag == spectag ) )
      if ( associated ( thisCatalogEntry%lines ) ) then
        ! Now subset the lines according to the signal we're using
        call allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                         &  'lineFlag', moduleName )
        lineFlag = .FALSE.
        do k = 1, size ( thisCatalogEntry%lines )
          thisLine => lines(thisCatalogEntry%lines(k))
          if ( associated(thisLine%signals) ) then
            do sigInd = 1, size(fwdModelConf%signals)
              if ( fwdModelConf%allLinesForRadiometer ) then
                doThis = .false.
                do i = 1, size(thisLine%signals)
                  ! Tried to make GetRadiometerFromSignal elemental, but compile time
                  ! in LF95 (optimized) for Construct.f90 went nuts! :-(
                  doThis = doThis .or. GetRadiometerFromSignal ( thisLine%signals(i) ) == &
                    & fwdModelConf%signals(sigInd)%radiometer
                  if ( doThis ) exit
                end do
              else
                doThis = any ( thisLine%signals == &
                  & fwdModelConf%signals(sigInd)%index )
              end if

              ! If we're only doing one sideband, maybe we can remove some more lines
              if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                & any( ( thisLine%sidebands == sidebandStart ) .or. &
                & ( thisLine%sidebands == 0 ) )
              if ( doThis ) then
                lineFlag(k) = .true.
                exit
              end if
            end do ! End loop over signals requested in fwm
          end if
        end do               ! End loop over lines

        My_Catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake

! Check we have at least one line for this

        if ( count(lineFlag) == 0 .and. all ( my_catalog(j)%continuum == 0.0 ) ) then
          call get_string ( lit_indices(l), molName )
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No relevant lines or continuum for '//trim(molName) )
        end if
        call allocate_test ( my_catalog(j)%lines, count(lineFlag), &
          & 'my_catalog(?)%lines', moduleName )
        my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
        call deallocate_test ( lineFlag, 'lineFlag', moduleName )

      else

        ! No lines for this species
        my_catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
        call allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
          & moduleName )
      end if

    end do         ! Loop over species

d689 11
a699 21
    call allocate_test ( tempProf, temp%template%noSurfs, 'tempProf', moduleName )
    tempProf = temp%values(:,(windowStart+windowFinish)/2)

! Setup our temporary `state vector' like arrays -------------------------

         select case (FwdModelConf%i_saturation)
            case (l_clear)
               RHi = -1._r8
            case (l_clear_110RH_below_top)
               RHi = 110._r8              ! 110% supersaturation
               refP = 100._r8      ! 100 mb
            case (l_clear_0RH)
               RHi = 1.e-9_r8             ! 0% dry saturation
               refP = 100._r8      ! 100 mb
            case (l_clear_110RH_below_tropopause)
               RHi = 110._r8              ! 110% supersaturation
               refP = tpPressure%values(1,(windowStart+windowFinish)/2)
            case default
               call MLSMessage(MLSMSG_Error, ModuleName,'invalid i_saturation')
         end select

d702 3
a704 5
       &   firstSignal%radiometer, mol_cat_index, p_len, f_len, h2o_ind,     &
       &   ext_ind, Grids_f, f_len_dw, Grids_dw, f_len_dn, Grids_dn,         &
       &   f_len_dv, Grids_dv, RHi=RHi, temp_supersat=tempProf, &
       &   refPressure=refP )
    else
d706 7
a712 3
       &   firstSignal%radiometer, mol_cat_index, p_len, f_len, h2o_ind,     &
       &   ext_ind, Grids_f, RHi=RHi, temp_supersat=tempProf, &
       &   refPressure=refP )
d715 1
a715 4
! Deallocate our tempProf array
   call deallocate_test(tempProf, 'tempProf', moduleName )

! set up output pointing angles------------------------------------------
d726 15
a740 5
    req_out = COS(phitan%values(:,maf)*Deg2Rad)**2
    req_out = 0.001_rp*SQRT((earthrada**4*(1.0_rp-req_out) &
    & + earthradc**4*req_out) / (earthrada**2*req_out &
    & + earthradc**2*(1.0-req_out)))
    call allocate_test ( tan_chi_out,ptan%template%nosurfs, 'tan_chi_out', &
d742 1
a742 1
    call allocate_test ( dx_dh_out,ptan%template%nosurfs, 'dx_dh_out', &
d744 1
a744 1
    call allocate_test ( dhdz_out,ptan%template%nosurfs, 'dhdz_out', &
d746 3
a748 28
    if ( h2o_ind > 0 .and. .not. temp_der ) then
      end_ind_z = sum(grids_f%no_z(1:h2o_ind))
      beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
      end_ind_p = sum(grids_f%no_p(1:h2o_ind))
      beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
      end_ind = sum(grids_f%no_z(1:h2o_ind) * grids_f%no_p(1:h2o_ind) * &
                 &  grids_f%no_f(1:h2o_ind))
      beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
                       &  grids_f%no_f(h2o_ind) + 1
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*Deg2Rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & req_out, tan_chi_out, dhdz_out, dx_dh_out, &
         & h2o_zeta_basis=grids_f%zet_basis(beg_ind_z:end_ind_z), &
         & h2o_phi_basis=grids_f%phi_basis(beg_ind_p:end_ind_p), &
         & h2o_coeffs=grids_f%values(beg_ind:end_ind), &
         & lin_log=grids_f%lin_log(h2o_ind))
    else if ( h2o_ind == 0 .and. .not. temp_der ) then
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & req_out, tan_chi_out, dhdz_out, dx_dh_out )
    else if ( h2o_ind > 0 .and.  temp_der ) then
      call allocate_test ( dxdt_tan,ptan%template%nosurfs,sv_t_len, &
d750 1
a750 1
      call allocate_test ( d2xdxdt_tan,ptan%template%nosurfs,sv_t_len, &
a751 31
      end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
      beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
      end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
      beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
      end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
                  & grids_f%no_f(1:h2o_ind))
      beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
                     &  grids_f%no_f(h2o_ind) + 1
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & req_out, tan_chi_out, dhdz_out, dx_dh_out, &
         & h2o_zeta_basis=grids_f%zet_basis(beg_ind_z:end_ind_z), &
         & h2o_phi_basis=grids_f%phi_basis(beg_ind_p:end_ind_p), &
         & h2o_coeffs=grids_f%values(beg_ind:end_ind), &
         & lin_log=grids_f%lin_log(h2o_ind), &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )
    else
      call allocate_test ( dxdt_tan,ptan%template%nosurfs,sv_t_len, &
                        &  'dxdt_tan',moduleName )
      call allocate_test ( d2xdxdt_tan,ptan%template%nosurfs,sv_t_len, &
                         & 'd2xdxdt_tan',moduleName )
      call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
         & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
         & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & req_out, tan_chi_out, dhdz_out, dx_dh_out, &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )
d754 10
d769 1
a769 1
    call allocate_test ( z_all, temp%template%nosurfs+2, 'z_all', moduleName )
d771 10
a781 1
! initialize step
d783 10
a792 4
    z_all = (/-3.000_rp,RESHAPE(temp%template%surfs(:,1), &
         &  (/temp%template%nosurfs/)),4.0_rp/)
! see if pointing grid is associated, if so concatenate it to the
! state vector
d794 4
a797 10
      call allocate_test ( z_tmp,SIZE(z_ALL) + FwdModelConf%tangentGrid%nosurfs, &
      & 'z_tmp',moduleName )
      z_tmp = (/z_all,FwdModelConf%tangentGrid%surfs/)

! Move z_tmp to z_all

      call deallocate_test ( z_all, 'z_all',moduleName )
      call allocate_test ( z_all,SIZE(z_tmp), 'z_all',moduleName )
      z_all = z_tmp
      call deallocate_test ( z_tmp, 'z_tmp',moduleName )
d801 3
a803 17

      f => GetQuantityForForwardModel(fwdmodelin, fwdmodelextra, &
          &  quantitytype = l_vmr, molIndex=mol_cat_index(sps_i), config=fwdModelConf, &
          &  radiometer = firstsignal%radiometer )

! Concatenate vector

      j = SIZE(z_all) + f%template%nosurfs
      call allocate_test ( z_tmp, j, 'z_tmp', moduleName )
      z_tmp = (/z_all,f%template%surfs(:,1)/)

! Move z_tmp to z_all

      call allocate_test ( z_all,SIZE(z_tmp), 'z_all',moduleName )
      z_all = z_tmp
      call deallocate_test ( z_tmp, 'z_tmp',moduleName )

d806 1
a806 13
! On top of all of these, add the original Integration Grid:

    j = SIZE(z_all) + Size(FwdModelConf%integrationGrid%surfs)
    call allocate_test ( z_tmp, j, 'z_tmp', moduleName )
    z_tmp = (/z_all,FwdModelConf%integrationGrid%surfs/)

! Move z_tmp to z_all

    call allocate_test ( z_all, SIZE(z_tmp), 'z_all', moduleName )
    z_all = z_tmp
    call deallocate_test ( z_tmp, 'z_tmp', moduleName )

! Now, create the final grid:
a843 16
    ! Compute hydrostatic grid -----------------------------------------------

    ! Insert into bill's 2d hydrostatic equation.
    ! The phi input for this program are the orbit plane projected
    ! geodetic locations of the temperature phi basis--not necessarily
    ! the tangent phi's which may be somewhat different.

    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_Begin ( 'ForwardModel.Hydrostatic' )

    call two_d_hydrostatic ( Grids_tmp, &
      &  (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
      &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
      &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
      &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )

d881 19
a899 17
    do i = 2, k
      m = -1
      do jf = k, i, -1
        if ( z_path(jf) < z_path(jf-1) ) then
          m = jf - 1
          r = z_path(jf)
          z_path(jf) = z_path(m)
          z_path(m) = r
          r = p_path(jf)
          p_path(jf) = p_path(m)
          p_path(m) = r
          r = t_path(jf)
          t_path(jf) = t_path(m)
          t_path(m) = r
        end if
      end do
      if ( m < 1) exit
d913 18
d934 2
a935 2
      call allocate_test ( dxdt_surface,1,sv_t_len, 'dxdt_surface',moduleName )
      call allocate_test ( d2xdxdt_surface,1,sv_t_len, 'd2xdxdt_surface', &
a936 60
      if ( h2o_ind > 0 ) then
        end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
        beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
        end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
        beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
        end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
                & grids_f%no_f(1:h2o_ind))
        beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
                & grids_f%no_f(h2o_ind) + 1
        call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
           & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
           & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
           & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
           & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
           & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh, &
           & h2o_zeta_basis=grids_f%zet_basis(beg_ind_z:end_ind_z), &
           & h2o_phi_basis=grids_f%phi_basis(beg_ind_p:end_ind_p), &
           & h2o_coeffs=grids_f%values(beg_ind:end_ind), &
           & lin_log=grids_f%lin_log(h2o_ind), &
           & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )
      else if ( h2o_ind == 0 ) then
        call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
           & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
           & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
           & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
           & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
           & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh,  &
           & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )
      end if
      call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface',moduleName )
    else
! no temperature derivatives
      if ( h2o_ind > 0 ) then
        end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
        beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
        end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
        beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
        end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
                & grids_f%no_f(1:h2o_ind))
        beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
                & grids_f%no_f(h2o_ind) + 1
        call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
           & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
           & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
           & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
           & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
           & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh, &
           & h2o_zeta_basis=grids_f%zet_basis(beg_ind_z:end_ind_z), &
           & h2o_phi_basis=grids_f%phi_basis(beg_ind_p:end_ind_p), &
           & h2o_coeffs=grids_f%values(beg_ind:end_ind), &
           & lin_log=grids_f%lin_log(h2o_ind) )
      else if ( h2o_ind == 0 ) then
        call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
           & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
           & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
           & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
           & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad,&
           & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh )
      end if
      call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface', moduleName )
d938 12
d954 16
a969 12
    allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dw' )
    allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dn' )
    allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dv' )
a973 2
    ! First, Allocate gl_slab arrays....

d976 1
a976 2
    allocate ( WC(N,no_ele), STAT=status )
    allocate ( IPSD(no_ele), STAT=status )
d1011 1
d1023 2
d1034 2
d1045 2
d1050 1
a1050 1
    call allocate_test ( beta_path_cloud_c, npc, 'beta_path_cloud_c',    moduleName )
d1052 4
a1055 7
    call allocate_test ( do_calc_fzp,   no_ele, f_len,  'do_calc_fzp',   moduleName )
    call allocate_test ( do_calc_iwc,   no_ele, f_len,  'do_calc_iwc',   moduleName )
    call allocate_test ( do_calc_zp,    no_ele, p_len,  'do_calc_zp',    moduleName )
    call allocate_test ( eta_fzp,       no_ele, f_len,  'eta_fzp',       moduleName )
    call allocate_test ( eta_iwc,       no_ele, f_len,  'eta_iwc',       moduleName )
    call allocate_test ( eta_zp,        no_ele, p_len,  'eta_zp',        moduleName )
    call allocate_test ( eta_iwc_zp,    no_ele, p_len,  'eta_iwc_zp',    moduleName )
d1057 13
a1069 2
    call allocate_test ( iwc_path,      no_ele, 1, 'iwc_path',           moduleName )

d1111 3
a1113 3
      call allocate_test ( dRad_df, f_len, 'dRad_df', moduleName )
      call allocate_test ( k_atmos,noUsedChannels,no_tan_hts,f_len, 'k_atmos',&
                       & moduleName )
d1134 3
a1136 3
      f_len_dw = SUM(Grids_dw%no_z(:) * Grids_dw%no_p(:) * Grids_dw%no_f(:))
      f_len_dn = SUM(Grids_dn%no_z(:) * Grids_dn%no_p(:) * Grids_dn%no_f(:))
      f_len_dv = SUM(Grids_dv%no_z(:) * Grids_dv%no_p(:) * Grids_dv%no_f(:))
d1182 1
a1182 1
    if ( associated(FwdModelConf%moleculesPol) ) then
d1190 10
a1199 1
      allocate ( incoptdepth_p(2,2,npc), stat=ier )
d1201 10
a1210 16
        & MLSMSG_Allocate//'incoptdepth_p' )
      ! Dig up some necessary vectors
      ! h =>
      ! ct =>
      ! stcp =>
      ! stsp =>
      !??? For now, allocate them and fill them with zeros.  MAKE SURE
      !??? TO REMOVE THE DEALLOCATES WHEN THESE ARE REPLACED!
      call allocate_test ( h, npc, 'h', moduleName )
      call allocate_test ( ct, npc, 'ct', moduleName )
      call allocate_test ( stcp, npc, 'stcp', moduleName )
      call allocate_test ( stsp, npc, 'stsp', moduleName )
      h = 0.0
      ct = 0.0
      stcp = 0.0
      stsp = 0.0
d1315 1
a1315 1
        & call allocate_test ( k_atmos_frq, maxNoPtgFreqs, f_len, 'k_atmos_frq',&
d1335 4
a1387 3
            h_path(1:no_ele) = req + h_path(1:no_ele)
            h_path_c(1:npc) = h_path(indices_c(1:npc))
            t_path_c(1:npc) = t_path(indices_c(1:npc))
d1396 1
a1396 4
            h_path(1:no_ele) = req + h_path(1:no_ele)
            h_path_c(1:npc) = h_path(indices_c(1:npc))
            t_path_c(1:npc) = t_path(indices_c(1:npc))
           end if
d1421 1
a1421 4
            h_path(1:no_ele) = req + h_path(1:no_ele)
            h_path_c(1:npc) = h_path(indices_c(1:npc))
            t_path_c(1:npc) = t_path(indices_c(1:npc))
           else
d1428 1
a1428 4
            h_path(1:no_ele) = req + h_path(1:no_ele)
            h_path_c(1:npc) = h_path(indices_c(1:npc))
            t_path_c(1:npc) = t_path(indices_c(1:npc))
           end if
d1430 3
d1434 1
d1457 1
d1462 3
a1464 7
      IF ( fwdModelConf%Incl_Cld ) THEN

        call comp_eta_docalc_no_frq ( Grids_f,z_path(1:no_ele), &
          &  phi_path(1:no_ele), do_calc_zp(1:no_ele,:), eta_zp(1:no_ele,:) )

        call comp_eta_docalc_no_frq ( Grids_Iwc,z_path(1:no_ele), &
          &  phi_path(1:no_ele), do_calc_iwc_zp(1:no_ele,:), eta_iwc_zp(1:no_ele,:) )
d1476 2
a1477 6
       ! Compute IWC_PATH
        Frq = 0.0
        call comp_sps_path_frq ( Grids_iwc, firstSignal%lo, thisSideband, &
          & Frq, eta_zp(1:no_ele,:), &
          & do_calc_zp(1:no_ele,:), iwc_path(1:no_ele,:),      &
          & do_calc_iwc(1:no_ele,:), eta_iwc(1:no_ele,:) )
d1479 18
a1496 4
        ! Initialize the cloud parameters
        WC(1,1:no_ele)=iwc_path(1:no_ele,1)
        WC(2,1:no_ele)=0.      ! Zero now for water clouds
        IPSD(1:no_ele)=1000    ! using MH PSD
d1498 2
a1499 1
      ELSE
d1501 2
a1502 2
        call comp_eta_docalc_no_frq ( Grids_f,z_path(1:no_ele), &
          &  phi_path(1:no_ele), do_calc_zp(1:no_ele,:), eta_zp(1:no_ele,:) )
d1504 17
a1520 3
       ! Now compute sps_path with a FAKE frequency, mainly to get the
       ! WATER (H2O) contribution for refraction calculations, but also
       ! to compute sps_path for all those with no frequency component
d1522 13
a1534 5
        Frq = 0.0
        call comp_sps_path_frq ( Grids_f, firstSignal%lo, thisSideband, &
          & Frq, eta_zp(1:no_ele,:), &
          & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d1536 1
a1536 7
        !set cloud parameters to zero
        iwc_path(1:no_ele,1) = 0.
        WC(1,1:no_ele)=iwc_path(1:no_ele,1)
        WC(2,1:no_ele)=0.  
        IPSD(1:no_ele)=1000

      ENDIF
d1563 2
a1564 2
! This only needs to be computed on the gl (not coarse) grid thus there is
! some duplication here.
d1596 2
a1597 2
          k = SIZE(PointingGrids(whichPointingGrid)%oneGrid( &
                       & grids(ptg_i))%frequencies)
d1626 14
d1644 1
a1644 1
            & Frq, eta_zp(1:no_ele,:), &
d1648 12
a1659 11
          ! JJ VAN/MIKE
          if ( associated(FwdModelConf%moleculesPol) ) then
            call get_beta_path ( frq, h, my_Catalog, beta_group, gl_slabs, &
              & indices_c(1:npc), beta_path_polarized )

            alpha_path_polarized(-1,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized(-1,1:npc,:), DIM=2 )
            alpha_path_polarized( 0,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized( 0,1:npc,:), DIM=2 )
            alpha_path_polarized(+1,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized(+1,1:npc,:), DIM=2 )
d1661 13
a1673 6
            call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
              & alpha_path_polarized(:,1:npc), incoptdepth_p(:,:,1:npc) )
            incoptdepth_p(1,1,1:npc) = incoptdepth_p(1,1,1:npc) * del_s(1:npc)
            incoptdepth_p(2,1,1:npc) = incoptdepth_p(2,1,1:npc) * del_s(1:npc)
            incoptdepth_p(1,2,1:npc) = incoptdepth_p(1,2,1:npc) * del_s(1:npc)
            incoptdepth_p(2,2,1:npc) = incoptdepth_p(2,2,1:npc) * del_s(1:npc)
d1675 1
a1675 2
            do_gl = .false.
            call path_contrib ( incoptdepth_p(:,:,1:npc), e_rflty, &
a1676 1
          end if
d1678 9
a1686 2
          ! JHJ         
          IF ( associated(CloudIce) ) THEN
d1688 2
a1689 6
          call get_beta_path_cloud ( Frq,                             &
            &  p_path(1:no_ele), t_path(1:no_ele), z_path_c(1:npc),   &   
            &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),    &     
            &  beta_path_cloud_c(1:npc),  RHi,                       &
            &  fwdModelConf%Incl_Cld, IPSD(1:no_ele),                 &
            &  WC(:,1:no_ele), NU, NUA, NAB, NR, N )                    
d1691 1
a1691 13
          call get_beta_path ( Frq,                                   &
            &  p_path(1:no_ele), t_path(1:no_ele), z_path_c(1:npc),   &   
            &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),    &     
            &  beta_path_c(1:npc,:),                                  &     
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,                 &     
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,                 &     
            &  dbeta_dt_path_c, dbeta_dw_path_c,                      &     
            &  dbeta_dn_path_c, dbeta_dv_path_c,                      &
            &  fwdModelConf%Incl_Cld )                    

          alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                  &  beta_path_c(1:npc,:), DIM=2) +  &
                                  & SUM (beta_path_cloud_c(1:npc), DIM=1)
d1693 2
a1694 1
          incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1696 1
a1696 1
          ! Determine where to use Gauss-Legendre instead of a rectangle.
d1698 6
a1703 3
          do_gl = .false.
          call path_contrib ( incoptdepth(1:npc), e_rflty, &
            & fwdModelConf%tolerance, do_gl(1:npc) )
d1705 2
a1706 1
          call get_GL_inds ( do_gl(1:npc), gl_inds, ngl )
d1708 1
a1708 1
          ELSE
d1710 8
a1717 10
          !JJ BILL ORIGINAL
          call get_beta_path ( Frq,                                   &
            &  p_path(1:no_ele), t_path(1:no_ele), z_path_c(1:npc),   &   
            &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),    &     
            &  beta_path_c(1:npc,:),                                  &     
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,                 &     
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,                 &     
            &  dbeta_dt_path_c, dbeta_dw_path_c,                      &     
            &  dbeta_dn_path_c, dbeta_dv_path_c,                      &
            &  fwdModelConf%Incl_Cld )                    
d1719 3
a1721 2
          alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                  & beta_path_c(1:npc,:), DIM=2)
d1723 2
a1724 1
          incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1726 1
a1726 1
          ! Determine where to use Gauss-Legendre instead of a rectangle.
d1728 1
a1728 3
          do_gl = .false.
          call path_contrib ( incoptdepth(1:npc), e_rflty, &
            & fwdModelConf%tolerance, do_gl(1:npc) )
d1731 1
a1731 2

          ENDIF
d1734 1
a1734 1
          ! derivative arrays are allocated, not which ones are present. 
d1739 7
a1745 8
            & p_path(1:no_ele), t_path(1:no_ele), z_path_c(1:npc),    &
            & my_Catalog, beta_group, gl_slabs, gl_inds(:ngl),        &
            & beta_path_f(:ngl,:),                                    &
            & gl_slabs_m, t_path(1:no_ele)-del_temp,                  &  
            & gl_slabs_p, t_path(1:no_ele)+del_temp,                  &  
            & dbeta_dt_path_f, dbeta_dw_path_f,                       &  
            & dbeta_dn_path_f, dbeta_dv_path_f,                       &
            & fwdModelConf%Incl_Cld )
d1750 12
d1764 6
a1769 6
          CALL rad_tran ( indices_c(1:npc), gl_inds(1:ngl), Frq,             &
            & spaceRadiance%values(1,1), e_rflty, z_path, t_path,            &
            & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),            &
            & incoptdepth(1:npc), alpha_path_f(1:ngl), &
            & path_dsdh, dhdz_path, t_script(1:npc),       &
            & tau(1:npc),Rad,i_stop )
d1771 49
a1819 1
          RadV(frq_i) = Rad
d1825 3
a1827 3
            CALL drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path, &
              &  Grids_f, beta_path_c(1:npc,:), eta_fzp, sps_path, &
              &  do_calc_fzp, beta_path_f, do_gl(1:npc), del_s(1:npc), &
d1831 1
a1831 1
            k_atmos_frq(frq_i,1:f_len) = drad_df(1:f_len)
d1915 1
a1915 1

d1948 1
a1948 1
              &   FilterShapes(shapeInd)%FilterGrid, &
a1959 1
        !??? Do we need to do this if there's no Jacobian ???
d1983 3
a1985 9
            do i = 1, noUsedChannels
              sv_i = 1
              do instance = 1, no_sv_p_t
                do surface = 1, n_t_zeta
                  k_temp(i,ptg_i,surface,instance) = k_temp_frq(i,sv_i)
                  sv_i = sv_i + 1
                end do
              end do
            end do
a1990 1
        !??? Do we need to do this if there's no Jacobian ???
a1993 1
          sv_i = 1
d1995 10
a2004 17
            specie = mol_cat_index(k)
            ! Did have a test here for moleculeDerivatives(specie), however
            ! this didn't work as it screwed up sv_1 which is supposed to accumulate
            ! over all molecules.  However, deriv_flags conveys the same information
            ! so not much speed will be lost.  NJL.
            if ( fwdModelConf%do_freq_avg ) then
              sv_start = sv_i
              do i = 1, noUsedChannels
                sv_i = sv_start
                sigInd = usedSignals(i)
                channel = usedChannels(i)
                j = Size(FilterShapes(shapeInd)%FilterGrid)
                shapeInd = MatchSignal ( filterShapes%signal, &
                  & fwdModelConf%signals(sigInd),             &
                  & sideband = thisSideband, channel=channel )
                do instance = Grids_f%WindowStart(k), Grids_f%WindowFinish(k)
                  do surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
d2014 9
a2022 17
                    sv_i = sv_i + 1
                  end do                ! Surface loop
                end do                  ! Instance loop
              end do                    ! Channel loop
            else                        ! Else not frequency averaging
              sv_start = sv_i
              do i = 1, noUsedChannels
                sv_i = sv_start
                do instance = Grids_f%WindowStart(k), Grids_f%WindowFinish(k)
                  do surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
                    if ( grids_f%deriv_flags(sv_i) ) then
                      k_atmos(i,ptg_i,sv_i) = k_atmos_frq(i,sv_i)
                    else
                      k_atmos(i,ptg_i,sv_i) = 0.0
                    end if
                    sv_i = sv_i + 1
                  end do
d2024 3
a2026 3
              end do
            end if                      ! Frequency averaging or not
          end do                          ! Loop over major molecules
d2029 1
a2029 1
        
a2031 1
        !??? Do we need to do this if there's no Jacobian ???
a2034 2
          !  *** dI/dW

d2036 7
a2042 126
            specie = mol_cat_index(k)
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd),             &
                    & sideband = thisSideband, channel=channel )
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dw%no_z(k)
                      do jf = 1, Grids_dw%no_f(k)
                        call Freq_Avg ( frequencies,           &
                          & FilterShapes(shapeInd)%FilterGrid, &
                          & FilterShapes(shapeInd)%FilterShape,&
                          & k_spect_dw_frq(:,sv_i), noFreqs, j, r )
                        k_spect_dw(i,ptg_i,jf,surface,instance,k) = r
                        sv_i = sv_i + 1
                      end do              ! Frequencies loop
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! else not frequency averaging
                do i = 1, noUsedChannels
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dw%no_z(k)
                      do jf = 1, Grids_dw%no_f(k)
                        k_spect_dw(i,ptg_i,jf,surface,instance,k) = &
                          k_spect_dw_frq(i,sv_i)
                        sv_i = sv_i + 1
                      end do
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over major molecules

          !  *** dI/dN

          do k = 1, no_mol
            specie = mol_cat_index(k)
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd),             &
                    & sideband = thisSideband, channel=channel )
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dn%no_z(k)
                      do jf = 1, Grids_dn%no_f(k)
                        call Freq_Avg ( frequencies,           &
                          & FilterShapes(shapeInd)%FilterGrid, &
                          & FilterShapes(shapeInd)%FilterShape,&
                          & k_spect_dn_frq(:,sv_i), noFreqs, j, r )
                        k_spect_dn(i,ptg_i,jf,surface,instance,k) = r
                        sv_i = sv_i + 1
                      end do              ! Frequencies loop
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! else not frequency averaging
                do i = 1, noUsedChannels
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dn%no_z(k)
                      do jf = 1, Grids_dn%no_f(k)
                        k_spect_dn(i,ptg_i,jf,surface,instance,k) = &
                          k_spect_dn_frq(i,sv_i)
                        sv_i = sv_i + 1
                      end do
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over major molecules

          !  *** dI/dV

          do k = 1, no_mol
            specie = mol_cat_index(k)
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd),             &
                    & sideband = thisSideband, channel=channel )
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dv%no_z(k)
                      do jf = 1, Grids_dv%no_f(k)
                        call Freq_Avg ( frequencies,           &
                          & FilterShapes(shapeInd)%FilterGrid, &
                          & FilterShapes(shapeInd)%FilterShape,&
                          & k_spect_dv_frq(:,sv_i), noFreqs, j, r )
                        k_spect_dv(i,ptg_i,jf,surface,instance,k) = r
                        sv_i = sv_i + 1
                      end do              ! Frequencies loop
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! else not frequency averaging
                do i = 1, noUsedChannels
                  if ( k == 1) sv_i = 1
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_dv%no_z(k)
                      do jf = 1, Grids_dv%no_f(k)
                        k_spect_dv(i,ptg_i,jf,surface,instance,k) = &
                          k_spect_dv_frq(i,sv_i)
                        sv_i = sv_i + 1
                      end do
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
d2071 1
d2137 2
a2138 2
          ! Now change channel from starting at 0 or 1 to definately 1
          
d2140 1
d2143 2
a2144 2
               & chanInd, windowStart, windowFinish, mol_cat_index, temp,ptan, &
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2150 3
a2152 3
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra,maf,   &
               & chanInd, windowStart, windowFinish, mol_cat_index, temp,ptan, &
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2161 2
a2162 2
               & chanInd, windowStart, windowFinish, mol_cat_index, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2167 1
a2167 1
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2170 2
a2171 2
               & chanInd, windowStart, windowFinish, mol_cat_index, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2179 1
a2179 1
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2184 1
d2191 2
a2192 2
              &  Radiances(:,i), thisRatio, mol_cat_index, fmStat%rows,   &
              &  Jacobian, PTAN_DER=ptan_der)
d2198 1
a2198 2
              &  Radiances(:,i), thisRatio, mol_cat_index, fmStat%rows,   &
              &  Jacobian,                                                &
d2206 3
a2208 3
              &  Radiances(:,i), thisRatio, mol_cat_index, fmStat%rows,   &
              &  Jacobian, DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2214 1
a2214 2
              &  Radiances(:,i), thisRatio, mol_cat_index, fmStat%rows,   &
              &  Jacobian,                                                &
d2217 1
a2217 1
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2261 4
a2264 8
    call GetNameOfSignal ( firstSignal, molName )
    i = Index(molName, '.B')
    do j = i+1,32
      if ( molName(j:j) == '.' ) then
        molName(j:)=' '
        exit
      end if
    end do
a2266 1
      ! *** DEBUG Print
d2287 2
a2288 2
        channel = usedChannels(i) + channelOrigins(i) - 1
        print "(/, 'ch', i2.2, '_pfa_rad\ ', i3.3 )", channel, k
a2299 8
    do i = 1, size(my_catalog)
      if ( associated ( my_catalog(i)%lines ) ) &
        & call deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
        & moduleName )
    end do
    deallocate ( my_catalog, stat=ier )
    ! Note that we don't deallocate the signals/sidebands stuff for each line
    ! as these are shallow copies of the main spectroscopy catalog stuff
d2301 2
a2302 2
    Deallocate (WC, stat=ier )
    Deallocate (IPSD, stat=ier )
d2304 1
a2304 2
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'my_catalog' )
d2306 2
a2307 7
    do i = 1, no_mol
      deallocate ( beta_group(i)%cat_index, stat=j )
      deallocate ( beta_group(i)%ratio, stat=j )
    end do

    deallocate ( mol_cat_index, stat=j )
    deallocate ( beta_group, stat=j )
a2312 10
    deallocate ( k_spect_dw, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dw' )
    deallocate ( k_spect_dn, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dn' )
    deallocate ( k_spect_dv, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dv' )

d2318 3
a2320 3
    call deallocate_test ( h_glgrid, 'h_glgrid', moduleName )
    call deallocate_test ( t_glgrid, 't_glgrid', moduleName )
    call deallocate_test ( dhdz_glgrid, 'dhdz_glgrid', moduleName )
d2322 1
a2322 1
    call deallocate_test ( ddhidhidtl0, 'ddhidhidtl0', moduleName )
d2324 6
a2329 6
    call deallocate_test ( tan_inds, 'tan_inds', moduleName )
    call deallocate_test ( tan_press, 'tan_press', moduleName )
    call deallocate_test ( tan_phi, 'tan_phi', moduleName )
    call deallocate_test ( tan_hts, 'tan_hts', moduleName )
    call deallocate_test ( tan_temps, 'tan_temps', moduleName )
    call deallocate_test ( reqs, 'reqs', moduleName )
d2331 1
a2331 1
    call deallocate_test ( tan_temp, 'tan_temp', moduleName )
d2335 2
d2338 1
a2338 1
    call destroygrids_t ( grids_iwc )
d2355 4
d2369 2
a2372 2
    call deallocate_test ( beta_path_c,   'beta_path_c',   moduleName )
    call deallocate_test ( beta_path_cloud_c,   'beta_path_cloud_c',   moduleName )
d2374 3
d2378 4
a2381 3
    call deallocate_test ( do_calc_iwc_zp,'do_calc_iwc_zp',moduleName )
    call deallocate_test ( do_calc_fzp,   'do_calc_fzp',   moduleName )
    call deallocate_test ( do_calc_iwc,   'do_calc_iwc',   moduleName )
d2383 2
a2384 3
    call deallocate_test ( eta_iwc_zp,    'eta_iwc_zp',    moduleName )
    call deallocate_test ( eta_fzp,       'eta_fzp',       moduleName )
    call deallocate_test ( eta_iwc,       'eta_iwc',       moduleName )
a2385 1
    call deallocate_test ( iwc_path,      'iwc_path',      moduleName )
d2387 7
a2393 3
    call deallocate_test ( tan_chi_out, 'tan_chi_out',moduleName )
    call deallocate_test ( dx_dh_out, 'dx_dh_out',moduleName )
    call deallocate_test ( dhdz_out, 'dhdz_out',moduleName )
d2458 10
d2470 1
a2470 1
    if ( associated(FwdModelConf%moleculesPol) ) then
d2477 7
a2483 1
      deallocate ( incoptdepth_p, stat=ier )
d2485 13
a2497 7
        & MLSMSG_DeAllocate//'incoptdepth_p' )
      !??? Make sure to delete these deallocates when the real H, CT,
      !??? STCP and STSP are gotten from the state or extra vectors
      call deallocate_test ( h, 'h', moduleName )
      call deallocate_test ( ct, 'ct', moduleName )
      call deallocate_test ( stcp, 'stcp', moduleName )
      call deallocate_test ( stsp, 'stsp', moduleName )
d2508 3
a2510 1
    ! Deallocate all variables allocated earlier -----------------------------
d2513 1
a2513 1
      call trace_end ( 'ForwardModel MAF=',fmStat%maf )
d2516 46
d2571 24
a2594 3
! $Log: FullForwardModel_m.f90,v $
! Revision 2.132  2003/04/22 00:14:45  dwu
! add a new option (clear_110RH_below_tropopause) to i_saturation
d2596 2
a2597 2
! Revision 2.131  2003/04/11 00:49:02  dwu
! make i_saturation as a verbel input
d2599 44
a2642 1
! Revision 2.130  2003/03/04 20:22:40  dwu
d2645 39
a2683 2
! Revision 2.129  2003/02/20 23:29:54  livesey
! Bug fix in -Srad for DACS.
d2685 1
a2685 1
! Revision 2.128  2003/02/13 23:05:50  jonathan
d2688 2
a2689 2
! Revision 2.127  2003/02/13 17:25:07  bill
! subscripted gl_inds to call in drad_df per Vans suggestion
d2707 3
a2709 1
! add eta_iwc, eta_iwc_zp, do_calc_iwc, do_cala_iwc_zp and also not passing through comp_eta_docalc and comp_sps_path_frq if fwdModelConf%Incl_Cld is false
@


2.132
log
@add a new option (clear_110RH_below_tropopause) to i_saturation
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.131 2003/04/11 00:49:02 dwu Exp $"
d427 1
a427 1
    real(r8) :: RHi                     ! relative humidity
d906 1
a906 1
               RHi = -1
d2871 3
@


2.131
log
@make i_saturation as a verbel input
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.130 2003/03/04 20:22:40 dwu Exp $"
d49 1
a49 1
      & L_ELEVOFFSET, LIT_INDICES, L_ISOTOPERATIO, L_VMR, &
d53 1
a53 1
      & l_clear, l_clear_110RH_below_top, l_clear_0RH
d166 1
a166 1
    integer :: ICON                     ! i_saturation
d384 1
d427 3
a429 1
    real(r8), dimension(:), pointer :: temp_supersat
d480 1
a480 1
      & tan_hts, reqs, cloudIce, cloudWater, sizeDistribution, temp_supersat )
d528 2
a537 10
         select case (FwdModelConf%i_saturation)
            case (l_clear)
               icon = 0
            case (l_clear_110RH_below_top)
               icon = -1
            case (l_clear_0RH)
               icon = -2
            case default
               call MLSMessage(MLSMSG_Error, ModuleName,'invalid i_saturation')
         end select
d899 2
a900 4
    call allocate_test ( temp_supersat, n_t_zeta, 'temp_supersat', moduleName )
    do i=1, n_t_zeta
      temp_supersat(i) = grids_tmp%values(i)
    enddo
d904 16
a919 1
    !JJ
d924 2
a925 1
       &   f_len_dv, Grids_dv, i_supersat=ICON, temp_supersat=temp_supersat )
d929 2
a930 1
       &   ext_ind, Grids_f, i_supersat=ICON, temp_supersat=temp_supersat )
d933 2
a934 2
! Deallocate our temp_supersat array
   call deallocate_test(temp_supersat, 'temp_supersat', moduleName )
d1943 1
a1943 1
            &  beta_path_cloud_c(1:npc),  ICON,                       &
d2871 3
@


2.130
log
@add a temporay fix for the tangent height crossover problem
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.129 2003/02/20 23:29:54 livesey Exp $"
d52 2
a53 1
      & L_CLOUDICE, L_CLOUDWATER, L_SIZEDISTRIBUTION
d533 10
a542 1
          ICON = FwdModelConf%i_saturation
d2861 3
@


2.129
log
@Bug fix in -Srad for DACS.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.128 2003/02/13 23:05:50 jonathan Exp $"
d2404 2
a2405 1
      do ptg_i = 2, no_tan_hts
d2407 4
a2410 2
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Pointing angles in wrong order, too much refraction?' )
d2851 3
@


2.128
log
@changes dimension for beta_path_cloud also delocate it
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.127 2003/02/13 17:25:07 bill Exp $"
d2621 1
a2621 1
        channel = usedChannels(i)
d2848 3
@


2.127
log
@subscripted gl_inds to call in drad_df per Vans suggestion
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126 2003/02/11 00:48:18 jonathan Exp $"
d283 1
a283 1
    real(rp), dimension(:,:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse
d1340 1
a1340 1
    call allocate_test ( beta_path_cloud_c, npc, no_mol, 'beta_path__cloud_c',   moduleName )
d1920 1
a1920 1
          call get_beta_path_cloud ( Frq,                                   &
d1923 1
a1923 1
            &  beta_path_cloud_c(1:npc,:),  ICON,                           &
d1939 1
a1939 1
                                  & SUM (beta_path_cloud_c(1:npc,:), DIM=2)
d2724 1
d2848 3
@


2.126
log
@changes made after adding get_beta_path_cloud
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.125 2003/02/08 01:03:00 livesey Exp $"
d2012 3
a2014 3
            CALL drad_tran_df ( indices_c(1:npc), gl_inds, z_path, Grids_f,  &
              &  beta_path_c(1:npc,:), eta_fzp, sps_path, do_calc_fzp, &
              &  beta_path_f, do_gl(1:npc), del_s(1:npc), &
d2847 3
@


2.126.2.1
log
@fixes gl_ind bug and interfaces to get_beta
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126 2003/02/11 00:48:18 jonathan Exp $"
d1895 1
a1895 2
            call get_beta_path( frq, h, my_Catalog, beta_group, &
              & gl_slabs, &
d1934 2
a1935 1
            &  dbeta_dn_path_c, dbeta_dv_path_c)                    
d1954 1
a1954 1
          call get_beta_path ( Frq,                            &
d1961 2
a1962 1
            &  dbeta_dn_path_c, dbeta_dv_path_c)                    
d1984 1
a1984 1
          call get_beta_path ( Frq,                            &
d1991 2
a1992 1
            & dbeta_dn_path_f, dbeta_dv_path_f)
d2012 1
a2012 2
            CALL drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path, &
              &  Grids_f,  &
a2846 3
! Revision 2.126  2003/02/11 00:48:18  jonathan
! changes made after adding get_beta_path_cloud
!
@


2.126.2.2
log
@changes dimension for beta_path_cloud also delocate it
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.1 2003/02/13 17:35:01 bill Exp $"
d283 1
a283 1
    real(rp), dimension(:),   pointer :: BETA_PATH_cloud_C ! Beta on path coarse
d1340 1
a1340 1
    call allocate_test ( beta_path_cloud_c, npc, 'beta_path_cloud_c',    moduleName )
d1921 1
a1921 1
          call get_beta_path_cloud ( Frq,                             &
d1924 1
a1924 1
            &  beta_path_cloud_c(1:npc),  ICON,                       &
d1939 1
a1939 1
                                  & SUM (beta_path_cloud_c(1:npc), DIM=1)
a2722 1
    call deallocate_test ( beta_path_cloud_c,   'beta_path_cloud_c',   moduleName )
a2845 3
! Revision 2.126.2.1  2003/02/13 17:35:01  bill
! fixes gl_ind bug and interfaces to get_beta
!
@


2.126.2.3
log
@add singl. scat. albedo W0, ph funct PHH
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.2 2003/02/13 22:26:18 jonathan Exp $"
d283 1
a283 3
    real(rp), dimension(:),   pointer :: BETA_PATH_cloud_C ! Cloud extintionon on path coarse
    real(rp), dimension(:),   pointer :: BETA_PATH_W0_C    ! Single scattering albedo 
    real(rp), dimension(:,:), pointer :: BETA_PATH_PHH_C   ! Scattering phase function 
d445 1
a445 2
      & beta_path, beta_path_c, beta_path_cloud_c, beta_path_w0_c, beta_path_phh_c, &
      & beta_path_f, beta_path_polarized, &
a1340 2
    call allocate_test ( beta_path_w0_c, npc, 'beta_path_w0_c',          moduleName )
    call allocate_test ( beta_path_phh_c, npc, NU, 'beta_path_phh_c',    moduleName )
d1923 4
a1926 4
            &  beta_group, indices_c(1:npc), beta_path_cloud_c(1:npc),&
            &  beta_path_w0_c(1:npc), beta_path_phh_c(1:npc,:),       &
            &  ICON, fwdModelConf%Incl_Cld, IPSD(1:no_ele),           &
            &  WC(:,1:no_ele), NU, NUA, NAB, NR, N ) 
d1938 2
a1939 2
                                  & beta_path_c(1:npc,:), DIM=2) +  &
                                  & beta_path_cloud_c(1:npc)
a1994 8
          ! Compute Scatering source function !JJ under construction

          ! IF ( associated(CloudIce) ) THEN
          !  CALL Tscat (Frq,  beta_path_w0_c(1:npc),        &
          !    &  beta_path_phh_c(1:npc,:), ICON, NU,        &
          !    &  t_scat(1:npc) )  
          ! END IF

d2722 2
a2723 5
    call deallocate_test ( beta_path_c,   'beta_path_c',         moduleName )
    call deallocate_test ( beta_path_cloud_c,'beta_path_cloud_c',moduleName )
    call deallocate_test ( beta_path_w0_c, 'beta_path_w0_c',     moduleName )
    call deallocate_test ( beta_path_phh_c, 'beta_path_phh_c',   moduleName )

a2846 3
! Revision 2.126.2.2  2003/02/13 22:26:18  jonathan
! changes dimension for beta_path_cloud also delocate it
!
@


2.126.2.4
log
@Initial commit of polarized model
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.3 2003/02/14 00:21:42 jonathan Exp $"
a32 1
    use CS_Expmat_m, only: CS_Expmat
a34 1
    use DO_T_SCRIPT_M, ONLY: TWO_D_T_SCRIPT
a46 1
    use Get_GL_delta_m, only: Get_GL_Delta
a51 1
      & L_MAGNETICFIELD, &
a60 1
    use Mcrt_m, only: Mcrt
d96 2
a97 2
    real(r8), dimension(:,:), pointer :: WC
    integer, dimension(:), pointer :: IPSD
d167 2
d179 3
a181 3
    integer, dimension(:), pointer :: GL_INDS ! Index of GL indices
    integer, dimension(:), pointer :: GRIDS ! Heights in ptgGrid for each tangent
    integer, dimension(:), pointer :: INDICES_C ! Indices on coarse grid
a202 2
    logical, dimension(:,:), pointer :: DO_CALC_MAG   ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_MAG_ZP ! DO_CALC_MAG on zeta-phi grid
a225 1
    real(rp), dimension(:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse
d283 2
a285 1
    real(rp), dimension(:),   pointer :: BETA_PATH_W0_C    ! Single scattering albedo 
a302 1
    real(rp), dimension(:,:), pointer :: ETA_MAG      ! Eta_z x Eta_p * Eta_f
a304 1
    real(rp), dimension(:,:), pointer :: ETA_Mag_ZP       ! Eta_z x Eta_p
a325 1
    real(rp), dimension(:,:), pointer :: MAG_PATH   ! Magnetic field on path
a330 2
    complex(rp) :: RAD_POL(2,2)  ! polarized radiance output of mcrt for one freq and pointing

a331 1
    complex(rp), dimension(:,:), pointer :: ALPHA_PATH_POLARIZED_F
d334 1
a334 6
    complex(rp), dimension(:,:,:), pointer :: BETA_PATH_POLARIZED_F
    complex(rp), dimension(:,:,:), pointer :: DELTAU_POL
    complex(rp), dimension(:,:),   pointer :: GL_DELTA_POLARIZED
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL_GL
    complex(rp), dimension(:,:,:), pointer :: TAU_POL
d347 1
a347 1
!                        point indices from make_z_grid
a385 1
    type (VectorValue_T), pointer :: MAGFIELD                   ! Profiles
a402 2
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC
    type (Grids_T) :: Grids_mag ! All the coordinates for Magnetic field
d404 1
d447 2
a448 2
      & alpha_path_polarized_f, beta_path, beta_path_c, beta_path_cloud_c, &
      & beta_path_phh_c, beta_path_w0_c, beta_path_f, beta_path_polarized, &
a457 1
      & do_calc_mag, do_calc_mag_zp, &
d461 2
a462 2
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, eta_iwc, eta_mag, &
      & eta_zp, eta_iwc_zp, eta_mag_zp, eta_zxp_dn, eta_zxp_dn_c, eta_zxp_dn_f, &
d466 2
a467 3
      & gl_delta_polarized, gl_inds, grids, h_glgrid, h_path, h_path_c, h_path_f, &
      & incoptdepth, incoptdepth_pol, incoptdepth_pol_gl, deltau_pol, indices_c, &
      & k_atmos, k_atmos_frq, &
d470 1
a470 1
      & k_temp_frq, lineFlag, magField, mag_path, n_path, path_dsdh, &
d527 1
a527 2
    magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_magneticField, config=fwdModelConf, noError=.true. )
d529 1
a529 1
      & quantityType=l_cloudIce, noError=.true. )
d535 6
a540 6
    icon = fwdModelConf%i_saturation
    nu  = fwdModelConf%num_scattering_angles
    nua = fwdModelConf%num_azimuth_angles
    nab = fwdModelConf%num_ab_terms
    nr  = fwdModelConf%num_size_bins
    n   = fwdModelConf%no_cloud_species
d620 1
a620 1

a629 39
    if ( associated(FwdModelConf%moleculesPol) ) then

      call allocate_test ( grids_mag%no_z, 1, 'Grids_mag%no_z', moduleName )
      call allocate_test ( grids_mag%no_p, 1, 'Grids_mag%no_p', moduleName )
      call allocate_test ( grids_mag%no_f, 1, 'Grids_mag%no_f', moduleName )
      call allocate_test ( grids_mag%windowstart, 1, 'Grids_mag%windowstart', &
           & moduleName )
      call allocate_test ( grids_mag%windowfinish, 1, 'Grids_mag%windowfinish', &
           & moduleName )
      call allocate_test ( grids_mag%lin_log, 1, 'lin_log', moduleName )

      grids_mag%windowStart(1) = windowStart
      grids_mag%windowFinish(1) = windowFinish

      grids_mag%no_f = magfield%template%noChans
      grids_mag%no_z = magfield%template%noSurfs
      grids_mag%no_p = grids_mag%windowFinish(1)-grids_mag%windowStart(1)+1
      grids_mag%lin_log = .false.

!????? are we doing a specific species?
!???? Check dimensions of grids_mag%....  Do we want grids_mag%no_...(1) ???
      call allocate_test ( grids_mag%zet_basis, grids_mag%no_z(1), 'Grids_mag%zet_basis', &
           & moduleName )
      call allocate_test ( grids_mag%phi_basis, grids_mag%no_p(1), 'Grids_mag%phi_basis', &
           & moduleName )
      call allocate_test ( grids_mag%frq_basis, grids_mag%no_f(1), 'Grids_mag%frq_basis', moduleName )
      call allocate_test ( grids_mag%values, k, 'Grids_mag%values', moduleName )
      call allocate_test ( grids_mag%deriv_flags, k, 'Grids_mag%deriv_flags', &
           & moduleName )

!???? frq dimension has vector components?
      grids_mag%frq_basis = 0.0
      grids_mag%zet_basis = MagField%template%surfs(1:n_t_zeta,1)
      grids_mag%phi_basis = MagField%template%phi(1,windowStart:windowFinish)*Deg2Rad
      !three vector components are in the frequency dimension
      grids_mag%values = reshape(MagField%values(:,(windowStart-1)*magfield%template%noChans+1 : &
        & windowFinish*magfield%template%noChans), (/magfield%template%noChans*k/))

    end if
d657 1
a657 1

d672 1
d904 1
d1275 2
a1276 2
    call allocate_test ( wc, n, no_ele, 'WC', moduleName )
    call allocate_test ( ipsd, no_ele, 'IPSD', moduleName )
a1310 1
    ! MJS says that this is the same as npc = 2 * Nlvl
a1321 2
!???? WHY ARE COARSE GRID QUANTITIES BEING ALLOCATED LENGTH = no_ele ??  
!Is this not four times bigger than needed?
a1330 2
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path__cloud_c', moduleName )
    call allocate_test ( beta_path_w0_c, npc, 'beta_path_w0_c',          moduleName )
d1343 2
a1348 2
    call allocate_test ( do_calc_mag  , no_ele, f_len,  'do_calc_zp',    moduleName )
    call allocate_test ( do_calc_mag_zp, no_ele, p_len,  'do_calc_zp',    moduleName )
a1351 1
    call allocate_test ( eta_mag,       no_ele, f_len,  'eta_mag',       moduleName )
a1353 1
    call allocate_test ( eta_mag_zp,    no_ele, p_len,  'eta_iwc_zp',    moduleName )
a1355 2
    if ( associated(FwdModelConf%moleculesPol) ) &
      & call allocate_test ( mag_path,  no_ele, magfield%template%noChans, 'mag_path', moduleName )
d1477 1
a1477 7
      allocate ( alpha_path_polarized_f(-1:1,no_ele), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'alpha_path_polarized_f' )
      allocate ( beta_path_polarized_f(-1:1,no_ele,no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'beta_path_polarized_f' )
      allocate ( gl_delta_polarized(-1:1,no_ele), stat=ier )
d1479 1
a1479 10
        & MLSMSG_Allocate//'gl_delta_polarized' )
      allocate ( incoptdepth_pol(2,2,npc), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'incoptdepth_pol' )
      allocate ( incoptdepth_pol_gl(2,2,no_ele), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'incoptdepth_pol_gl' )
      allocate ( deltau_pol(2,2,npc), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'deltau_pol' )
d1487 4
a1490 6

      ! These are geomagnetic field IFOVPP path quantities
      call allocate_test ( h, no_ele, 'h', moduleName )
      call allocate_test ( ct, no_ele, 'ct', moduleName )
      call allocate_test ( stcp, no_ele, 'stcp', moduleName )
      call allocate_test ( stsp, no_ele, 'stsp', moduleName )
d1749 2
a1750 1
        ! Things you do whether or not you are doing magnetic or cloud
d1754 3
d1767 8
a1774 2
        !set cloud parameters to zero
        iwc_path(1:no_ele,1) = 0.
d1776 2
a1777 2
        WC(2,1:no_ele)=0.  
        IPSD(1:no_ele)=1000
d1779 1
a1779 2
        ! Special path quantities for cloud model
        if ( fwdModelConf%Incl_Cld ) then
d1781 2
a1782 12
          call comp_eta_docalc_no_frq ( Grids_Iwc,z_path(1:no_ele), &
            &  phi_path(1:no_ele), do_calc_iwc_zp(1:no_ele,:), &
            & eta_iwc_zp(1:no_ele,:) )

          ! Compute IWC_PATH
          Frq = 0.0
          call comp_sps_path_frq ( Grids_iwc, firstSignal%lo, thisSideband, &
            & Frq, eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), iwc_path(1:no_ele,:),      &
            & do_calc_iwc(1:no_ele,:), eta_iwc(1:no_ele,:) )
          WC(1,1:no_ele)=iwc_path(1:no_ele,1)
        end if
d1784 3
a1786 2
        ! Special path quantities for Polarized (magnetic) model
        if ( associated(FwdModelConf%moleculesPol) ) then
d1788 5
a1792 2
          call comp_eta_docalc_no_frq ( Grids_Mag,z_path(1:no_ele), &
            &  phi_path(1:no_ele), do_calc_mag_zp(1:no_ele,:), eta_mag_zp(1:no_ele,:) )
d1794 5
a1798 9
          ! Compute MAG_PATH
          Frq = 0.0
          call comp_sps_path_frq ( Grids_mag, firstSignal%lo, thisSideband, &
            & Frq, eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), mag_path(1:no_ele,:),      &
            & do_calc_mag(1:no_ele,:), eta_mag(1:no_ele,:) )

          !This is where we should rotate mag_path from ECR to IFOVPP (R1A) coordinates
          !????
d1800 1
a1800 2

        end if
d1898 35
d1940 1
a1940 1
            &  dbeta_dn_path_c, dbeta_dv_path_c )                    
d1942 3
a1944 1
          if ( associated(CloudIce) ) then    
d1946 1
a1946 6
            call get_beta_path_cloud ( Frq,                             &
              &  p_path(1:no_ele), t_path(1:no_ele), z_path_c(1:npc),   &   
              &  beta_group, indices_c(1:npc), beta_path_cloud_c(1:npc),&
              &  beta_path_w0_c(1:npc), beta_path_phh_c(1:npc,:),       &
              &  ICON, fwdModelConf%Incl_Cld, IPSD(1:no_ele),           &
              &  WC(:,1:no_ele), NU, NUA, NAB, NR, N ) 
d1948 1
d1950 3
a1952 3
            alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                    & beta_path_c(1:npc,:), DIM=2) +  &
                                    & beta_path_cloud_c(1:npc)
d1954 1
a1954 1
            incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1956 1
a1956 1
            ! Determine where to use Gauss-Legendre instead of a rectangle.
d1958 9
a1966 5
            do_gl = .false.
            call path_contrib ( incoptdepth(1:npc), e_rflty, &
              & fwdModelConf%tolerance, do_gl(1:npc) )

          else
d1968 2
a1969 3
            ! The derivatives that get_beta_path computes depend on which
            ! derivative arrays are allocated.  This avoids having four
            ! paths, each with a different set of optional arguments.
d1971 1
a1971 2
            alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                    & beta_path_c(1:npc,:), DIM=2)
d1973 1
a1973 1
            incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1975 3
a1977 3
            do_gl = .false.
            if ( .not. associated(FwdModelConf%moleculesPol) ) then
               ! Determine where to use Gauss-Legendre for scalar instead of a rectangle.
d1979 1
a1979 23
               call path_contrib ( incoptdepth(1:npc), e_rflty, &
                    & fwdModelConf%tolerance, do_gl(1:npc) )
            else ! extra stuff for polarized case

              !???? Call this only for polarized molecules (eg ^{16}O_2)
              call get_beta_path ( frq, h, my_Catalog, beta_group, gl_slabs, &
                & indices_c(1:npc), beta_path_polarized )

              alpha_path_polarized(-1,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized(-1,1:npc,:), DIM=2 )
              alpha_path_polarized( 0,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized( 0,1:npc,:), DIM=2 )
              alpha_path_polarized(+1,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized(+1,1:npc,:), DIM=2 )

              call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
                & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )
              incoptdepth_pol(1,1,1:npc) = incoptdepth_pol(1,1,1:npc) * del_s(1:npc) + &
                   & incoptdepth(1:npc)
              incoptdepth_pol(2,1,1:npc) = incoptdepth_pol(2,1,1:npc) * del_s(1:npc)
              incoptdepth_pol(1,2,1:npc) = incoptdepth_pol(1,2,1:npc) * del_s(1:npc)
              incoptdepth_pol(2,2,1:npc) = incoptdepth_pol(2,2,1:npc) * del_s(1:npc) + &
                   &incoptdepth(1:npc)
d1981 1
a1981 12
              do j = 1, npc
                call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
              end do
              call path_contrib(deltau_pol(:,:,1:npc), e_rflty, &
                 & fwdModelConf%tolerance, do_gl(1:npc) )

            end if

          end if

          call get_GL_inds ( do_gl(1:npc), gl_inds, ngl )
          ! ngl is ng * count(do_gl)
d1984 1
a1984 1
          ! derivative arrays are allocated, not which ones are present.
d1988 1
a1988 1
          call get_beta_path ( Frq,                                   &
d1992 4
a1995 4
            & gl_slabs_m, t_path(1:no_ele)-del_temp,                  &
            & gl_slabs_p, t_path(1:no_ele)+del_temp,                  &
            & dbeta_dt_path_f, dbeta_dw_path_f,                       &
            & dbeta_dn_path_f, dbeta_dv_path_f )
a1999 4
          if ( .not. associated(FwdModelConf%moleculesPol) ) then

          ! Compute SCALAR radiative transfer ---------------------------------------

d2010 6
a2015 6
            call rad_tran ( indices_c(1:npc), gl_inds(1:ngl), Frq, &
              & spaceRadiance%values(1,1), e_rflty, z_path, t_path,            &
              & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),            &
              & incoptdepth(1:npc), alpha_path_f(1:ngl), &
              & path_dsdh, dhdz_path, t_script(1:npc),       &
              & tau(1:npc),Rad,i_stop )
d2017 1
a2017 50
            RadV(frq_i) = Rad
          else
            !POLARIZED
            !get the corrections to integrals for layers that need gl for the polarized species
            call get_beta_path ( frq, h, my_Catalog, beta_group, gl_slabs, &
              & gl_inds(:ngl), beta_path_polarized_f )

!???? this needs to be fixed and uncommented
!            alpha_path_polarized_f(-1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),pol_sps) * &
!              & beta_path_polarized_f(-1,1:ngl,:), DIM=2 ) * 0.25 * alpha_path_f(1:ngl)
!            alpha_path_polarized_f( 0,1:ngl) = SUM( sps_path(gl_inds(1:ngl),pol_sps) * &
!              & beta_path_polarized_f( 0,1:ngl,:), DIM=2 ) * 0.5 * alpha_path_f(1:ngl)
!            alpha_path_polarized_f(+1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),pol_sps) * &
!              & beta_path_polarized_f(+1,1:ngl,:), DIM=2 ) * 0.25 * alpha_path_f(1:ngl)

            !polarized flavor of get_gl_delta
            call get_gl_delta( indices_c(1:npc), gl_inds(1:ngl), do_gl(1:npc), z_path, &
              &  alpha_path_polarized(:, 1:npc), alpha_path_polarized_f(:,1:ngl), &
              &  path_dsdh, dhdz_path, gl_delta_polarized)



            !we already have ct, stcp and stsp for the gl points, because we have done
            !interpolation to all of the coarse and fine gridpoints (what a waste!)

            !get gl corrections to incoptdepth_pol
            call opacity ( ct(gl_inds(1:ngl)), stcp(gl_inds(1:ngl)), stsp(gl_inds(1:ngl)), &
              & gl_delta_polarized(:,1:ngl), incoptdepth_pol_gl(:,:,1:ngl) )


            !correct inc_optdepth_pol by adding corrections
            incoptdepth_pol(:,:,gl_inds(1:ngl)) = incoptdepth_pol(:,:,gl_inds(1:ngl)) + &
              &  incoptdepth_pol_gl(:,:,1:ngl);

            !exponentiate only those layers that have been corrected
            do j = 1, ngl
                call cs_expmat ( incoptdepth_pol(:,:,gl_inds(j)), deltau_pol(:,:,gl_inds(j)) )
            end do

            call two_d_t_script ( t_path(indices_c(1:npc)), spaceRadiance%values(1,1), frq, &
              & t_script(1:npc) )

            !should actually use sqrt(e_rflty) in mcrt, but we never see the surface anyway!
            ! tau_pol is called P inside mcrt
!???? mcrt wants del_tau.  Where is that ????
!           call mcrt ( t_script(1:npc), e_rflty, incoptdepth_pol, tau_pol,  rad_pol)

            !Assume antenna is only sensitive to the first linear polarization
            RadV(frq_i) = real( rad_pol(1,1))
          end if
d2023 2
a2024 1
            call drad_tran_df ( indices_c(1:npc), gl_inds(1:ngl), z_path, Grids_f,  &
d2249 1
a2249 1
          end do                        ! Loop over major molecules
d2252 1
a2252 1

d2479 1
a2479 1

d2655 2
a2656 2
    call Deallocate_Test ( WC, 'WC', moduleName )
    call Deallocate_Test ( IPSD, 'IPSD', moduleName )
a2706 1
    call destroygrids_t ( grids_mag )
a2722 4
    call deallocate_test ( beta_path_c,      'beta_path_c',      moduleName )
    call deallocate_test ( beta_path_cloud_c, 'beta_path_cloud_c',  moduleName )
    call deallocate_test ( beta_path_phh_c,  'beta_path_phh_c',  moduleName )
    call deallocate_test ( beta_path_w0_c,   'beta_path_w0_c',   moduleName )
d2735 5
a2746 1
    call deallocate_test ( eta_mag_zp,    'eta_mag_zp',    moduleName )
a2748 1
    call deallocate_test ( eta_mag,       'eta_mag',       moduleName )
a2750 1
    call deallocate_test ( mag_path,      'mag_path',      moduleName )
d2828 1
a2828 4
      deallocate ( alpha_path_polarized_f, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'alpha_path_polarized_f' )
      deallocate ( beta_path_polarized_f, stat=ier )
d2830 1
a2830 13
        & MLSMSG_DeAllocate//'beta_path_polarized_f' )
      deallocate ( gl_delta_polarized, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'gl_delta_polarized' )
      deallocate ( incoptdepth_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol' )
      deallocate ( incoptdepth_pol_gl, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'incoptdepth_pol_gl' )
      deallocate ( deltau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'deltau_pol' )
d2847 2
a2862 3
! Revision 2.126.2.3  2003/02/14 00:21:42  jonathan
! add singl. scat. albedo W0, ph funct PHH
!
d2885 1
a2885 3
! add eta_iwc, eta_iwc_zp, do_calc_iwc, do_cala_iwc_zp and also not passing
! through comp_eta_docalc and comp_sps_path_frq if fwdModelConf%Incl_Cld is
! false
@


2.126.2.5
log
@Move stuff to Get_Species_Data
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.4 2003/02/14 03:53:41 vsnyder Exp $"
a49 1
    use Get_Species_Data_M, only: Get_Species_Data
a144 1
    integer :: NO_MOL_POL               ! Like NO_MOL, for polarized molecules
a145 1
    integer :: NOSPECIES_POL            ! No. of polarized molecules
d158 1
d173 1
d177 1
a177 1
    character (len=32) :: SigName       ! Name of a Signal
d191 1
d413 2
a414 1
    type (catalog_T), dimension(:), pointer :: MY_CATALOG_POL ! polarized
d439 2
a440 2
    integer, dimension(:), pointer :: mol_cat_index     ! unpolarized
    integer, dimension(:), pointer :: mol_cat_index_pol ! polarized
d442 1
a442 2
    type (beta_group_T), dimension(:), pointer :: beta_group     ! unpolarized
    type (beta_group_T), dimension(:), pointer :: beta_group_pol ! polarized
d490 1
a490 1
      & k_temp_frq, magField, mag_path, n_path, path_dsdh, &
d547 2
a548 3
    if ( associated(FwdModelConf%moleculesPol) ) &
      & magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_magneticField, config=fwdModelConf )
d614 2
a667 1
      k = grids_mag%no_f(1) * grids_mag%no_z(1) * grids_mag%no_p(1)
d670 2
d681 1
d687 1
a687 1
        & windowFinish*magfield%template%noChans), (/k/))
a752 12
! Create the data structures for the species

    call get_species_data ( fwdModelConf%molecules, fwdModelConf, &
      & fwdModelIn, fwdModelExtra, sidebandStart, sidebandStop, &
      & noSpecies, no_mol, mol_cat_index, beta_group, my_catalog )

    if ( associated(fwdModelConf%moleculesPol) ) &
      & call get_species_data ( fwdModelConf%moleculesPol, fwdModelConf, &
        & fwdModelIn, fwdModelExtra, sidebandStart, sidebandStop, &
        & noSpecies_pol, no_mol_pol, mol_cat_index_pol, beta_group_pol, &
        & my_catalog_pol )

d797 157
d1329 2
a1335 2
    ! First, Allocate gl_slab arrays....

d2738 8
a2745 4
    call GetNameOfSignal ( firstSignal, sigName )
    i = index(sigName, '.B')
    j = index(sigName(i+2:), '.' )
    if ( j /= 0 ) sigName(i+j+1:) = ''
a3014 3
! Revision 2.126.2.4  2003/02/14 03:53:41  vsnyder
! Initial commit of polarized model
!
@


2.126.2.6
log
@Delete unreferenced names
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.5 2003/02/14 23:27:31 vsnyder Exp $"
d53 1
a53 1
      & L_ELEVOFFSET, L_VMR, &
d68 1
a68 1
    use MLSCommon, only: I4, R4, R8, RP, IP
d71 1
a71 1
      & MLSMSG_Error
d74 2
a75 2
                          & GetNameOfSignal
    use Molecules, only: L_EXTINCTION
d83 1
a83 1
    use SpectroscopyCatalog_m, only: CATALOG_T
a2862 3
! Revision 2.126.2.5  2003/02/14 23:27:31  vsnyder
! Move stuff to Get_Species_Data
!
@


2.126.2.7
log
@Don't exp(incoptdepth) in mcrt -- it's done here
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.6 2003/02/14 23:31:14 vsnyder Exp $"
d439 1
d496 2
a497 3
      & tan_phi, tan_press, tan_temp, tau, tau_pol, &
      & t_glgrid, t_path, t_path_c, t_path_f, t_script, &
      & usedchannels, usedsignals, z_all, z_basis, z_basis_dn, &
d754 1
a754 5
      & noSpecies, no_mol, beta_group, my_catalog )

    call allocate_test ( mol_cat_index, no_mol, 'mol_cat_index', moduleName )

    mol_cat_index = PACK((/(i,i=1,noSpecies)/), fwdModelConf%molecules > 0)
d759 2
a760 1
        & noSpecies_pol, no_mol_pol, beta_group_pol, my_catalog_pol )
a1410 3
      allocate ( tau_pol(2,2,npc), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate//'tau_pol' )
a1844 2
          do_gl = .false.

d1863 1
d1878 1
d1950 6
a1955 6
            call rad_tran ( indices_c(1:npc), gl_inds(1:ngl), Frq,  &
              & spaceRadiance%values(1,1), e_rflty, z_path, t_path, &
              & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc), &
              & incoptdepth(1:npc), alpha_path_f(1:ngl),            &
              & path_dsdh, dhdz_path, t_script(1:npc),              &
              & tau(1:npc), Rad, i_stop )
d1959 2
a1960 3
            ! POLARIZED
            ! get the corrections to integrals for layers that need gl for
            ! the polarized species
d1972 2
a1973 2
            ! polarized flavor of get_gl_delta
            call get_gl_delta ( indices_c(1:npc), gl_inds(1:ngl), do_gl(1:npc), z_path, &
d1975 1
a1975 1
              &  path_dsdh, dhdz_path, gl_delta_polarized )
a1976 3
            ! we already have ct, stcp and stsp for the gl points, because we
            ! have done interpolation to all of the coarse and fine gridpoints
            ! (what a waste!)
d1978 5
a1982 1
            ! get gl corrections to incoptdepth_pol
d1987 1
a1987 1
            ! correct inc_optdepth_pol by adding corrections
d1991 1
a1991 1
            ! exponentiate only those layers that have been corrected
d1993 1
a1993 1
              call cs_expmat ( incoptdepth_pol(:,:,gl_inds(j)), deltau_pol(:,:,gl_inds(j)) )
d1999 4
a2002 2
            call mcrt ( t_script(1:npc), sqrt(e_rflty), deltau_pol(:,:,1:npc), &
              & tau_pol(:,:,1:npc), rad_pol)
d2005 1
a2005 1
            RadV(frq_i) = real(rad_pol(1,1))
d2631 2
a2632 1
      call deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
d2639 3
a2652 3
    call Deallocate_Test ( WC, 'WC', moduleName )
    call Deallocate_Test ( IPSD, 'IPSD', moduleName )

a2832 3
      deallocate ( tau_pol, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_DeAllocate//'tau_pol' )
a2862 3
! Revision 2.126.2.6  2003/02/14 23:31:14  vsnyder
! Delete unreferenced names
!
@


2.126.2.8
log
@Made index for dumping dacs radiances be 1:129 for dacs channels 0:128
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.7 2003/02/15 00:29:11 vsnyder Exp $"
d2621 1
a2621 1
        channel = usedChannels(i) - channelOrigins(i) + 1
a2868 3
! Revision 2.126.2.7  2003/02/15 00:29:11  vsnyder
! Don't exp(incoptdepth) in mcrt -- it's done here
!
@


2.126.2.9
log
@Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.8 2003/02/21 21:34:32 michael Exp $"
d547 1
a547 1
    if ( FwdModelConf%polarized ) &
d650 1
a650 1
    if ( FwdModelConf%polarized ) then
d760 2
a761 2
    if ( FwdModelConf%polarized ) &
      & call get_species_data ( fwdModelConf%molecules, fwdModelConf, &
d1276 1
a1276 1
    if ( FwdModelConf%polarized ) &
d1391 1
a1391 1
    if ( FwdModelConf%polarized ) then
d1728 1
a1728 1
        if ( FwdModelConf%polarized ) then
d1885 1
a1885 1
            if ( .not. FwdModelConf%polarized ) then
d1942 1
a1942 1
          if ( .not. FwdModelConf%polarized ) then
d2811 1
a2811 1
    if ( FwdModelConf%polarized ) then
a2868 3
! Revision 2.126.2.8  2003/02/21 21:34:32  michael
! Made index for dumping dacs radiances be 1:129 for dacs channels 0:128
!
@


2.126.2.10
log
@change temp_supersat to temp_prof
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.9 2003/02/22 00:49:26 vsnyder Exp $"
d444 1
a444 1
    real(r8), dimension(:), pointer :: temp_prof
d499 1
a499 1
      & tan_hts, reqs, cloudIce, cloudWater, sizeDistribution, temp_prof )
d811 1
a811 1
    call allocate_test ( temp_prof, n_t_zeta, 'temp_prof', moduleName )
d813 1
a813 1
      temp_prof(i) = grids_tmp%values(i)
d822 1
a822 1
       &   f_len_dv, Grids_dv, i_supersat=ICON, temp_supersat=temp_prof )
d826 1
a826 1
       &   ext_ind, Grids_f, i_supersat=ICON, temp_supersat=temp_prof )
d829 2
a830 2
! Deallocate our temp_prof array
   call deallocate_test(temp_prof, 'temp_prof', moduleName )
a2868 3
! Revision 2.126.2.9  2003/02/22 00:49:26  vsnyder
! Delete moleculesPol, moleculeDerivativesPol, add Polarized to ForwardModelConfig
!
@


2.126.2.11
log
@change input for get_beta_path_cloud
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.10 2003/02/24 23:26:43 jonathan Exp $"
d1855 2
a1856 1
            call get_beta_path_cloud ( Frq, t_path(1:no_ele),           &   
a2868 3
! Revision 2.126.2.10  2003/02/24 23:26:43  jonathan
! change temp_supersat to temp_prof
!
@


2.126.2.12
log
@add grids_tscat
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.11 2003/02/24 23:40:31 jonathan Exp $"
a421 1
    type (Grids_T) :: Grids_Tscat ! All the coordinates for TEMP
d639 1
a639 1
    call allocate_test ( grids_tmp%lin_log, 1, 'grids_tmp%lin_log', moduleName )
d641 8
a648 21
    if ( associated ( cloudIce ) ) then

      call allocate_test ( grids_iwc%no_z, 1, 'Grids_iwc%no_z', moduleName )
      call allocate_test ( grids_iwc%no_p, 1, 'Grids_iwc%no_p', moduleName )
      call allocate_test ( grids_iwc%no_f, 1, 'Grids_iwc%no_f', moduleName )
      call allocate_test ( grids_iwc%windowstart, 1, 'Grids_iwc%windowstart', &
                         & moduleName )
      call allocate_test ( grids_iwc%windowfinish, 1, 'Grids_iwc%windowfinish', &
                         & moduleName )
      call allocate_test ( grids_iwc%lin_log, 1, 'grids_iwc%lin_log', moduleName )

      call allocate_test ( grids_tscat%no_z, 1, 'Grids_tscat%no_z', moduleName )
      call allocate_test ( grids_tscat%no_p, 1, 'Grids_tscat%no_p', moduleName )
      call allocate_test ( grids_tscat%no_f, 1, 'Grids_tscat%no_f', moduleName )
      call allocate_test ( grids_tscat%windowstart, 1, 'Grids_tscat%windowstart', &
                         & moduleName )
      call allocate_test ( grids_tscat%windowfinish, 1, 'Grids_tscat%windowfinish', &
                         & moduleName )
      call allocate_test ( grids_tscat%lin_log, 1, 'grids_tscat%lin_log', moduleName )

    endif
a694 15
    if ( associated ( cloudIce ) ) then

      grids_iwc%no_f = 1
      grids_iwc%no_z = n_t_zeta
      grids_iwc%no_p = no_sv_p_t
      grids_iwc%lin_log = .false.
      grids_iwc%windowStart(1) = windowStart
      grids_iwc%windowFinish(1) = windowFinish

      grids_tscat%no_f = 1
      grids_tscat%no_z = n_t_zeta
      grids_tscat%no_p = no_sv_p_t
      grids_tscat%lin_log = .false.
      grids_tscat%windowStart(1) = windowStart
      grids_tscat%windowFinish(1) = windowFinish
d696 6
a701 1
    endif
d715 8
a722 21
    if ( associated ( cloudIce ) ) then

      call allocate_test ( grids_iwc%zet_basis, n_t_zeta, 'Grids_iwc%zet_basis', &
                         & moduleName )
      call allocate_test ( grids_iwc%phi_basis, no_sv_p_t, 'Grids_iwc%phi_basis', &
                         & moduleName )
      call allocate_test ( grids_iwc%frq_basis, 1, 'Grids_iwc%frq_basis', moduleName )
      call allocate_test ( grids_iwc%values, k, 'Grids_iwc%values', moduleName )
      call allocate_test ( grids_iwc%deriv_flags, k, 'Grids_iwc%deriv_flags', &
                         & moduleName )

      call allocate_test ( grids_tscat%zet_basis, n_t_zeta, 'Grids_tscat%zet_basis', &
                         & moduleName )
      call allocate_test ( grids_tscat%phi_basis, no_sv_p_t, 'Grids_tscat%phi_basis', &
                         & moduleName )
      call allocate_test ( grids_tscat%frq_basis, 1, 'Grids_tscat%frq_basis', moduleName )
      call allocate_test ( grids_tscat%values, k, 'Grids_tscat%values', moduleName )
      call allocate_test ( grids_tscat%deriv_flags, k, 'Grids_tscat%deriv_flags', &
                         & moduleName )

    endif
a733 5

      grids_tscat%frq_basis = 0.0  
      grids_tscat%zet_basis = 0.0 
      grids_tscat%phi_basis = 0.0
      grids_tscat%values =    0.0
a738 6

      grids_tscat%frq_basis = 0.0
      grids_tscat%zet_basis = 0.0
      grids_tscat%phi_basis = 0.0
      grids_tscat%values = 0.0

a811 2
    ! temp_prof: temperature profiles may also be needed as input to Tscat module 

d829 3
a2632 4

! Deallocate our temp_prof array
    call deallocate_test(temp_prof, 'temp_prof', moduleName )

a2693 1
    call destroygrids_t ( grids_tscat )
a2867 3
! Revision 2.126.2.11  2003/02/24 23:40:31  jonathan
! change input for get_beta_path_cloud
!
@


2.126.2.13
log
@Revise polarized processing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.12 2003/02/25 00:53:09 jonathan Exp $"
d50 1
a50 1
    use Get_Species_Data_M, only: Get_Species_Data, Destroy_Species_Data
d146 1
d148 1
d413 1
d442 1
d640 1
a640 1
    call allocate_test ( grids_tmp%lin_log, 1, 'Grids_tmp%lin_log', moduleName )
d662 1
a662 1
    end if
d725 1
a725 1
    end if
d759 1
a759 1
    end if
d776 11
d808 5
d864 1
a864 1
    end do
d1885 1
a1885 1
            & Frq, eta_zp(1:no_ele,:),                           &
d1888 8
a1895 7
          call get_beta_path ( Frq,                              &     
            &  p_path(1:no_ele), t_path(1:no_ele),               &     
            &  my_Catalog, beta_group, FwdModelConf%polarized,   &     
            &  gl_slabs, indices_c(1:npc), beta_path_c(1:npc,:), &     
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,            &     
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,            &     
            &  dbeta_dt_path_c, dbeta_dw_path_c,                 &     
d1902 4
a1905 5
            call get_beta_path_cloud ( Frq,                              &
              &  p_path(1:no_ele), t_path(1:no_ele),                     &  
              &  beta_group, indices_c(1:npc), beta_path_cloud_c(1:npc), &
              &  beta_path_w0_c(1:npc), beta_path_phh_c(1:npc,:),        &
              &  ICON, fwdModelConf%Incl_Cld, IPSD(1:no_ele),            &
d1908 1
a1956 22
              do j = 1, npc
                call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
              end do
              call path_contrib(deltau_pol(:,:,1:npc), e_rflty, &
                 & fwdModelConf%tolerance, do_gl(1:npc) )
            end if

            ! The derivatives that get_beta_path computes depend on which
            ! derivative arrays are allocated.  This avoids having four
            ! paths, each with a different set of optional arguments.

            alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                    & beta_path_c(1:npc,:), DIM=2)

            incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)

            if ( .not. FwdModelConf%polarized ) then
               ! Determine where to use Gauss-Legendre for scalar instead of a rectangle.

               call path_contrib ( incoptdepth(1:npc), e_rflty, &
                    & fwdModelConf%tolerance, do_gl(1:npc) )
            else ! extra stuff for polarized case
a1957 19
              !???? Call this only for polarized molecules (eg ^{16}O_2)
              call get_beta_path ( frq, h, my_Catalog, beta_group, gl_slabs, &
                & indices_c(1:npc), beta_path_polarized )

              alpha_path_polarized(-1,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized(-1,1:npc,:), DIM=2 )
              alpha_path_polarized( 0,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized( 0,1:npc,:), DIM=2 )
              alpha_path_polarized(+1,1:npc) = SUM( sps_path(indices_c,:) * &
                & beta_path_polarized(+1,1:npc,:), DIM=2 )

              call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
                & alpha_path_polarized(:,1:npc), incoptdepth_pol(:,:,1:npc) )
              incoptdepth_pol(1,1,1:npc) = incoptdepth_pol(1,1,1:npc) * del_s(1:npc) + &
                   & incoptdepth(1:npc)
              incoptdepth_pol(2,1,1:npc) = incoptdepth_pol(2,1,1:npc) * del_s(1:npc)
              incoptdepth_pol(1,2,1:npc) = incoptdepth_pol(1,2,1:npc) * del_s(1:npc)
              incoptdepth_pol(2,2,1:npc) = incoptdepth_pol(2,2,1:npc) * del_s(1:npc) + &
                   &incoptdepth(1:npc)
d1977 3
a1979 3
            & p_path(1:no_ele), t_path(1:no_ele),                     &
            & my_Catalog, beta_group, FwdModelConf%polarized,         &
            & gl_slabs, gl_inds(:ngl), beta_path_f(:ngl,:),           &
d1994 1
a1994 1
          ! if ( associated(CloudIce) ) then
d2050 1
d2681 2
a2682 1
    call destroy_species_data ( my_catalog )
d2684 7
a2690 1
    call deallocate_test ( temp_prof, 'temp_prof', moduleName )
a2919 3
! Revision 2.126.2.12  2003/02/25 00:53:09  jonathan
! add grids_tscat
!
@


2.126.2.14
log
@Print 3 digits in channel number in 'rad' diagnostic output
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.13 2003/02/27 23:35:01 vsnyder Exp $"
d2687 1
a2687 1
        print "(/, 'ch', i3.3, '_pfa_rad\ ', i3.3 )", usedChannels(i), k
a2931 3
! Revision 2.126.2.13  2003/02/27 23:35:01  vsnyder
! Revise polarized processing
!
@


2.126.2.15
log
@More work on polarized radiative transfer.  Still doesn't work, but at
least it doesn't break the nonpolarized case.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.14 2003/02/28 00:15:59 vsnyder Exp $"
d1461 1
a1461 1
      ct = 1.0
d1915 12
d1928 29
d1959 1
a1977 1

d1981 1
a1981 2

              call path_contrib ( deltau_pol(:,:,1:npc), e_rflty, &
d2037 7
a2043 6
            alpha_path_polarized_f(-1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f(-1,1:ngl,:), DIM=2 ) + 0.25 * alpha_path_f(1:ngl)
            alpha_path_polarized_f( 0,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f( 0,1:ngl,:), DIM=2 ) + 0.5 * alpha_path_f(1:ngl)
            alpha_path_polarized_f(+1,1:ngl) = SUM( sps_path(gl_inds(1:ngl),:) * &
              & beta_path_polarized_f(+1,1:ngl,:), DIM=2 ) + 0.25 * alpha_path_f(1:ngl)
a2931 3
! Revision 2.126.2.14  2003/02/28 00:15:59  vsnyder
! Print 3 digits in channel number in 'rad' diagnostic output
!
@


2.126.2.16
log
@add a temporay fix for the tangent height crossover problem
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.15 2003/03/01 03:19:28 vsnyder Exp $"
d2432 1
a2432 2
      do ptg_i = 2, no_tan_hts-1
	! this is a temporary fix
d2434 2
a2435 4
	   & ptg_angles(ptg_i) = (ptg_angles(ptg_i-1) + ptg_angles(ptg_i+1))/2
!        if ( ptg_angles(ptg_i) < ptg_angles(ptg_i-1) )  &
!          & call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & 'Pointing angles in wrong order, too much refraction?' )
d2437 1
a2437 1
      
a2890 4
! Revision 2.126.2.15  2003/03/01 03:19:28  vsnyder
! More work on polarized radiative transfer.  Still doesn't work, but at
! least it doesn't break the nonpolarized case.
!
@


2.126.2.17
log
@Do tanh correction for polarized, more polarized work, simplifications
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.16 2003/03/04 20:24:44 dwu Exp $"
a79 1
    use Physics, only: H_OVER_K
a271 2
    real(rp), dimension(:), pointer :: TANH1_C      ! tanh(0.5 h nu / k T)
    real(rp), dimension(:), pointer :: TANH1_F      ! tanh1_c on fine grid
d347 1
a347 1
    complex(rp), dimension(:,:,:), pointer :: INCOPTDEPTH_POL_GL ! Corrections to INCOPTDEPTH_POL
d492 1
a492 1
      & tan_phi, tan_press, tan_temp, tanh1_c, tanh1_f, tau, tau_pol, &
a1284 2
    call allocate_test ( tanh1_c,             npc, 'tanh1_c',          moduleName )
    call allocate_test ( tanh1_f,          no_ele, 'tanh1_f',          moduleName )
d1438 1
a1438 1
      allocate ( incoptdepth_pol_gl(2,2,npc), stat=ier )
d1460 1
a1460 1
      h = 0.5
d1637 3
d1648 4
a1651 1
          end if
d1676 4
a1679 1
          else
d1686 4
a1689 1
          end if
a1690 3
        h_path(1:no_ele) = req + h_path(1:no_ele)
        h_path_c(1:npc) = h_path(indices_c(1:npc))
        t_path_c(1:npc) = t_path(indices_c(1:npc))
d1770 1
d1798 2
a1799 2
        ! This only needs to be computed on the gl (not coarse) grid thus
        ! there is some duplication here.
d1921 6
a1926 7
              tanh1_c(1:npc) = tanh( 0.5_rp * frq * h_over_k / t_path_c(1:npc) )
              alpha_path_polarized(-1,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized(-1,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
              alpha_path_polarized( 0,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized( 0,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
              alpha_path_polarized(+1,1:npc) = SUM( sps_path(indices_c(1:npc),:) * &
                & beta_path_polarized(+1,1:npc,:), DIM=2 ) * tanh1_c(1:npc)
d1930 1
a1930 1
              incoptdepth_pol(1,1,1:npc) = - incoptdepth_pol(1,1,1:npc) * del_s(1:npc) - &
d1932 3
a1934 3
              incoptdepth_pol(2,1,1:npc) = - incoptdepth_pol(2,1,1:npc) * del_s(1:npc)
              incoptdepth_pol(1,2,1:npc) = - incoptdepth_pol(1,2,1:npc) * del_s(1:npc)
              incoptdepth_pol(2,2,1:npc) = - incoptdepth_pol(2,2,1:npc) * del_s(1:npc) - &
a1996 1
            tanh1_f(1:ngl) = tanh( 0.5_rp * frq * h_over_k / t_path(gl_inds(:ngl)) )
d1998 1
a1998 2
              & beta_path_polarized_f(-1,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.25 * alpha_path_f(1:ngl)
d2000 1
a2000 2
              & beta_path_polarized_f( 0,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.5 * alpha_path_f(1:ngl)
d2002 1
a2002 2
              & beta_path_polarized_f(+1,1:ngl,:), DIM=2 ) * tanh1_f(1:ngl) + &
              & 0.25 * alpha_path_f(1:ngl)
d2009 4
d2014 3
a2016 2
            call opacity ( ct(1:npc), stcp(1:npc), stsp(1:npc), &
              & gl_delta_polarized(:,1:npc), incoptdepth_pol_gl(:,:,1:npc) )
d2018 3
a2020 3
            ! add GL corrections to incoptdepth_pol
            incoptdepth_pol(:,:,1:npc) = incoptdepth_pol(:,:,1:npc) - &
              &  incoptdepth_pol_gl(:,:,1:npc);
d2022 3
a2024 2
            do j = 1, npc
              call cs_expmat ( incoptdepth_pol(:,:,j), deltau_pol(:,:,j) )
a2749 2
    call deallocate_test ( tanh1_c,          'tanh1_c',          moduleName )
    call deallocate_test ( tanh1_f,          'tanh1_f',          moduleName )
a2893 3
! Revision 2.126.2.16  2003/03/04 20:24:44  dwu
! add a temporay fix for the tangent height crossover problem
!
@


2.126.2.18
log
@Polarized radiative transfer sort-of works
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.17 2003/03/05 03:40:07 vsnyder Exp $"
d35 1
d63 3
a65 2
    use ManipulateVectorQuantities, only: FindInstanceWindow
    use MatrixModule_1, only: MATRIX_T
d68 2
a69 1
    use MLSCommon, only: R4, R8, RP, IP
d73 1
a73 1
    use MLSSignals_m, only: Signal_t, MatchSignal, AreSignalsSuperset, &
d78 1
d87 1
a87 1
    use Toggles, only: Emit, Levels, Switches, Toggle
d124 1
a124 1
    integer :: H2O_IND                  ! Index of h2o inside f array, else zero
d250 4
d280 4
d288 1
d464 1
a464 1
      & alpha_path_polarized_f, beta_path_c, beta_path_cloud_c, &
d466 1
a466 2
      & channelOrigins, cloudIce, cloudWater, ct, &
      & d2x_dxdt, d2xdxdt_surface, d2xdxdt_tan, &
d469 1
a469 2
      & ddhidhidtl0, del_s, deltau_pol, &
      & dh_dt_glgrid, dh_dt_path, dh_dt_path_f, dh_dt_path_c, &
d484 4
a487 4
      & gl_delta_polarized, gl_inds, grids, &
      & h, h_glgrid, h_path, h_path_c, h_path_f, &
      & incoptdepth, incoptdepth_pol, incoptdepth_pol_gl, indices_c, ipsd, iwc_path, &
      & k_atmos, k_atmos_frq, k_spect_dn, k_spect_dn_frq, &
d489 7
a495 7
      & k_temp_frq, magField, mag_path, mol_cat_index, n_path, path_dsdh, &
      & p_glgrid, p_path, p_path_c, phi_path, ptg_angles, &
      & radiances, RadV, ref_corr, req_out, reqs, sizeDistribution, &
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, superset, stcp, stsp, &
      & tan_chi_out, tan_d2h_dhdt, tan_dh_dt, tan_hts, tan_inds, &
      & tan_phi, tan_press, tan_temp, tan_temps, tanh1_c, tanh1_f, tau, &
      & tau_pol, temp_prof, &
d497 3
a499 2
      & usedchannels, usedsignals, wc, z_all, &
      & z_glgrid, z_path, z_path_c, z_tmp )
a551 1
    !??? cloudWater is never referenced ???
a553 1
    !??? sizeDistribution is never referenced ???
a640 24
    grids_tmp%no_f = 1
    grids_tmp%no_z = n_t_zeta
    grids_tmp%no_p = no_sv_p_t
    grids_tmp%lin_log = .false.
    grids_tmp%windowStart(1) = windowStart
    grids_tmp%windowFinish(1) = windowFinish

! Allocate space for the zeta, phi & freq. basis componenets

    k = sv_t_len
    call allocate_test ( grids_tmp%zet_basis, n_t_zeta, 'Grids_tmp%zet_basis', &
                       & moduleName )
    call allocate_test ( grids_tmp%phi_basis, no_sv_p_t, 'Grids_tmp%phi_basis', &
                       & moduleName )
    call allocate_test ( grids_tmp%frq_basis, 1, 'Grids_tmp%frq_basis', moduleName )
    call allocate_test ( grids_tmp%values, k, 'Grids_tmp%values', moduleName )
    call allocate_test ( grids_tmp%deriv_flags, k, 'Grids_tmp%deriv_flags', &
                       & moduleName )

    grids_tmp%frq_basis = 0.0
    grids_tmp%zet_basis = temp%template%surfs(1:n_t_zeta,1)
    grids_tmp%phi_basis = temp%template%phi(1,windowStart:windowFinish)*Deg2Rad
    grids_tmp%values = reshape(temp%values(:,windowStart:windowFinish),(/k/))

d663 45
d724 16
d758 8
a774 43

    end if

    if ( FwdModelConf%polarized ) then

      call allocate_test ( grids_mag%no_z, 1, 'Grids_mag%no_z', moduleName )
      call allocate_test ( grids_mag%no_p, 1, 'Grids_mag%no_p', moduleName )
      call allocate_test ( grids_mag%no_f, 1, 'Grids_mag%no_f', moduleName )
      call allocate_test ( grids_mag%windowstart, 1, 'Grids_mag%windowstart', &
           & moduleName )
      call allocate_test ( grids_mag%windowfinish, 1, 'Grids_mag%windowfinish', &
           & moduleName )
      call allocate_test ( grids_mag%lin_log, 1, 'lin_log', moduleName )

      grids_mag%windowStart(1) = windowStart
      grids_mag%windowFinish(1) = windowFinish

      grids_mag%no_f = magfield%template%noChans
      grids_mag%no_z = magfield%template%noSurfs
      grids_mag%no_p = grids_mag%windowFinish(1)-grids_mag%windowStart(1)+1
      k = grids_mag%no_f(1) * grids_mag%no_z(1) * grids_mag%no_p(1)
      grids_mag%lin_log = .false.

      call allocate_test ( grids_mag%zet_basis, grids_mag%no_z(1), 'Grids_mag%zet_basis', &
           & moduleName )
      call allocate_test ( grids_mag%phi_basis, grids_mag%no_p(1), 'Grids_mag%phi_basis', &
           & moduleName )
      call allocate_test ( grids_mag%frq_basis, grids_mag%no_f(1), 'Grids_mag%frq_basis', moduleName )
      call allocate_test ( grids_mag%values, k, 'Grids_mag%values', moduleName )
      call allocate_test ( grids_mag%deriv_flags, k, 'Grids_mag%deriv_flags', &
           & moduleName )

      grids_mag%frq_basis = 0.0
      grids_mag%zet_basis = MagField%template%surfs(1:n_t_zeta,1)
!??? The subscripts for MagField%template%phi and MagField%values are
!??? inconsistent.  windowStart:windowFinish are used in the instance index
!??? of MagField%template%phi, and in the surfaces*xyz index of MagField%values
!      grids_mag%phi_basis = MagField%template%phi(1,windowStart:windowFinish)*Deg2Rad
      !three vector components are in the frequency dimension
!??? The selected side of MagField%values is not equal to K.
!      grids_mag%values = reshape(MagField%values((windowStart-1)*magfield%template%noChans+1 : &
!        & windowFinish*magfield%template%noChans, :), (/k/))

d778 1
a778 1
    grids_tmp%deriv_flags = .TRUE.
d830 2
a831 1
      if ( fwdModelConf%molecules(specie) > 0 ) then
d873 5
a877 15

!{\begin{equation*}\begin{split}
! R_{eq} =\;& \sqrt \frac{R_a^4 \sin^2 \phi + R_c^4 \cos^2 \phi}
!                       {R_a^2 \cos^2 \phi + R_c^2 \sin^2 \phi}\\
!        =\;& \sqrt \frac{R_a^4 - (R_a^2+R_c^2)(R_a^2-R_c^2) \cos^2 \phi}
!                       {R_c^2 +              (R_a^2-R_c^2) \cos^2 \phi}
! \end{split}\end{equation*}

    req_out = (earthrada-earthradc)*(earthrada+earthradc) * &
      & COS(phitan%values(:,maf)*Deg2Rad)**2
    req_out = 0.001_rp * SQRT( &
      & ( earthrada**4 - (earthrada**2+earthradc**2) * req_out ) / &
      & ( earthradc**2 + req_out ) )

    call allocate_test ( tan_chi_out, ptan%template%nosurfs, 'tan_chi_out', &
d879 1
a879 1
    call allocate_test ( dx_dh_out, ptan%template%nosurfs, 'dx_dh_out', &
d881 1
a881 1
    call allocate_test ( dhdz_out, ptan%template%nosurfs, 'dhdz_out', &
d883 1
a883 2

    if ( h2o_ind > 0 ) then
d889 1
a889 1
                  & grids_f%no_f(1:h2o_ind))
d891 1
a891 3
                     &  grids_f%no_f(h2o_ind) + 1
    end if
    if ( h2o_ind > 0 .and. .not. temp_der ) then
d909 1
a909 1
    else if ( h2o_ind > 0 .and. temp_der ) then
d914 8
d933 5
a937 5
    else ! h2o_ind == 0 .and. temp_der
      call allocate_test ( dxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'dxdt_tan', moduleName )
      call allocate_test ( d2xdxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'd2xdxdt_tan', moduleName )
d1353 2
a1354 2
      call allocate_test ( k_atmos, noUsedChannels, no_tan_hts, f_len, &
        & 'k_atmos', moduleName )
d1715 1
a1715 1
        call comp_eta_docalc_no_frq ( Grids_f, z_path(1:no_ele), &
d1894 5
a1898 1
          else ! Not cloud model
a2003 10
! print *, 'alpha_path_polarized'
! do i = max(1,npc-2), npc
! print '(i3,6g15.7)', i, alpha_path_polarized(:,i)
! end do
! 
! print *, 'alpha_path_polarized_f'
! do i = max(1,ngl-8), ngl
! print '(i3,6g15.7)', i, alpha_path_polarized_f(:,i)
! end do

a2008 5
! print *, 'gl_delta_polarized'
! do i = max(1,npc-2), npc
! print '(i3,6g15.7)', i, gl_delta_polarized(:,i)
! end do

a2012 5
! print *, 'incoptdepth_pol_gl'
! do i = max(1,npc-2), npc
! print '(i3,8g15.7)', i, incoptdepth_pol_gl(:,:,i)
! end do

a2016 4
! print *, 'incoptdepth_pol'
! do i = max(1,npc-2), npc
! print '(i3,8g15.7)', i, incoptdepth_pol(:,:,i)
! end do
a2889 3
! Revision 2.126.2.17  2003/03/05 03:40:07  vsnyder
! Do tanh correction for polarized, more polarized work, simplifications
!
@


2.126.2.19
log
@Use ASSOCIATED instead of PRESENT of GET_CHI_OUT
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.18 2003/03/06 22:47:29 vsnyder Exp $"
a880 6
    if ( temp_der ) then
      call allocate_test ( dxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'dxdt_tan',moduleName )
      call allocate_test ( d2xdxdt_tan, ptan%template%nosurfs, sv_t_len, &
                         & 'd2xdxdt_tan',moduleName )
    end if
d890 24
a919 1
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan, &
d923 7
a929 2
         & lin_log=grids_f%lin_log(h2o_ind) )
    else
d949 2
a950 2
    z_all = (/ -3.000_rp, temp%template%surfs(:,1), 4.0_rp /)

d954 3
a956 3
      call allocate_test ( z_tmp, SIZE(z_ALL) + FwdModelConf%tangentGrid%nosurfs, &
        & 'z_tmp',moduleName )
      z_tmp = (/ z_all, FwdModelConf%tangentGrid%surfs /)
d960 2
a961 2
      call deallocate_test ( z_all, 'z_all', moduleName )
      call allocate_test ( z_all, SIZE(z_tmp), 'z_all', moduleName )
d976 1
a976 1
      z_tmp = (/ z_all, f%template%surfs(:,1) /)
d980 1
a980 1
      call allocate_test ( z_all, SIZE(z_tmp), 'z_all',moduleName )
d990 1
a990 1
    z_tmp = (/ z_all, FwdModelConf%integrationGrid%surfs /)
d1125 30
a1154 21
    end if
    if ( h2o_ind > 0 ) then
      end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
      beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
      end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
      beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
      end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
              & grids_f%no_f(1:h2o_ind))
      beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
              & grids_f%no_f(h2o_ind) + 1
      call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
         & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh, &
         & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface, &
         & h2o_zeta_basis=grids_f%zet_basis(beg_ind_z:end_ind_z), &
         & h2o_phi_basis=grids_f%phi_basis(beg_ind_p:end_ind_p), &
         & h2o_coeffs=grids_f%values(beg_ind:end_ind), &
         & lin_log=grids_f%lin_log(h2o_ind) )
d1156 29
a1184 7
      call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
         & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
         & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
         & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
         & (/req_out(1)/), surf_angle, one_dhdz, one_dxdh,  &
         & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )
a1185 1
    call deallocate_test ( d2xdxdt_surface, 'd2xdxdt_surface',moduleName )
d1729 1
a1729 1
          call comp_eta_docalc_no_frq ( Grids_Iwc, z_path(1:no_ele), &
d1745 1
a1745 1
          call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:no_ele), &
a1854 1

d1992 10
d2007 5
d2016 5
d2025 4
a2901 3
! Revision 2.126.2.18  2003/03/06 22:47:29  vsnyder
! Polarized radiative transfer sort-of works
!
@


2.126.2.20
log
@Added factors of 1/2 to scalar "power" absorption to get "field" absorption
for polarized model.
Made call to get_beta_path_polarized explicit insead of
through generic get_beta_path.
Added external procedure call testfield for polarized model debugging purposes
@
text
@d9 1
a9 1
  private 
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.19 2003/03/07 23:17:05 vsnyder Exp $"
d27 1
a27 1
use testfield_m
d45 1
a45 2
    use Get_Beta_Path_m, only: Get_Beta_Path, Beta_Group_T,  Get_Beta_Path_Cloud, &
      & Get_Beta_Path_Polarized
d1237 2
a1238 2
    call allocate_test ( do_calc_mag  , no_ele, f_len,  'do_calc_mag',    moduleName )
    call allocate_test ( do_calc_mag_zp, no_ele, p_len,  'do_calc_mag_zp',    moduleName )
d1405 1
a1405 1
      h = 1.0
a1408 1
      call testfield(h,ct,stcp, stsp)
d1691 1
a1691 1
!        if ( FwdModelConf%polarized ) then
d1693 2
d1696 6
a1701 2
!           call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:no_ele), &
!             &  phi_path(1:no_ele), do_calc_mag_zp(1:no_ele,:), eta_mag_zp(1:no_ele,:) )
d1703 2
a1704 6
!           ! Compute MAG_PATH
           Frq = 0.0
!           call comp_sps_path_frq ( Grids_mag, firstSignal%lo, thisSideband, &
!             & Frq, eta_zp(1:no_ele,:), &
!             & do_calc_zp(1:no_ele,:), mag_path(1:no_ele,:),      &
!             & do_calc_mag(1:no_ele,:), eta_mag(1:no_ele,:) )
d1706 1
a1706 4
!           !This is where we should rotate mag_path from ECR to IFOVPP (R1A) coordinates
!           !????

!         end if
d1850 1
a1850 1
              call get_beta_path_polarized ( frq, h, my_Catalog, beta_group, gl_slabs, &
a1853 1

a1862 4


!???? Added 1/2 terms to scalar "power absorption" to get "field absorption" 

d1864 1
a1864 2
                   & incoptdepth(1:npc)/2
!                   & incoptdepth(1:npc)
d1868 2
a1869 3
                   & incoptdepth(1:npc)/2
!                   & incoptdepth(1:npc)
!call dump( incoptdepth_pol )
d1923 1
a1923 6
         else
         !Polarized model

!??????  This seems not to do the job, though it makes agreement better
alpha_path_f=alpha_path_f/2

d1927 1
a1927 1
            call get_beta_path_polarized ( frq, h, my_Catalog, beta_group, gl_slabs, &
a1930 1

a1964 2


a2826 3
! Revision 2.126.2.19  2003/03/07 23:17:05  vsnyder
! Use ASSOCIATED instead of PRESENT of GET_CHI_OUT
!
@


2.126.2.21
log
@Revise Grids_T structure
@
text
@d9 1
a9 1
  private
d25 3
a27 2
  ! This is the full radiative transfer forward model, the workhorse code

d52 6
a57 5
    use Intrinsic, only: L_CHANNEL, L_CLOUDICE, L_CLOUDWATER, &
      & L_DN, L_DV, L_DW, L_EARTHREFL,    &
      & L_ELEVOFFSET, L_LOSVEL, L_MAGNETICFIELD, L_NONE, L_ORBITINCLINATION,  &
      & L_PHITAN, L_PTAN, L_RADIANCE, L_REFGPH, L_SCGEOCALT, L_SIDEBANDRATIO, &
      & L_SIZEDISTRIBUTION, L_SPACERADIANCE, L_TEMPERATURE, L_VMR
d59 1
a59 2
    use Load_sps_data_m, ONLY: Create_Grids_1, Create_Grids_2, Destroygrids_t, &
      & Grids_T, LOAD_SPS_DATA, Modify_values_for_supersat
a83 1
!use testfield_m
d119 1
d149 1
d161 1
d299 2
a300 2
    real(rp), dimension(:,:), pointer :: ETA_Iwc_ZP   ! Eta_z x Eta_p
    real(rp), dimension(:,:), pointer :: ETA_Mag_ZP   ! Eta_z x Eta_p
d343 2
d485 1
a485 1
      & tau_pol, &
d620 2
a621 1
    call create_grids_1 ( grids_tmp, 1 )
d623 8
a630 2
    no_sv_p_t = windowFinish - windowStart + 1
    sv_t_len = n_t_zeta * no_sv_p_t
d632 3
a634 5
    grids_tmp%l_f(1) = 1
    grids_tmp%l_z(1) = n_t_zeta
    grids_tmp%l_p(1) = no_sv_p_t
    grids_tmp%l_v(1) = sv_t_len
    grids_tmp%p_len = sv_t_len
d641 9
a649 1
    call create_grids_2 ( grids_tmp )
d654 1
a654 1
    grids_tmp%values = reshape(temp%values(:,windowStart:windowFinish),(/sv_t_len/))
d658 21
a678 2
      call create_grids_1 ( grids_iwc, 1 )
      call create_grids_1 ( grids_tscat, 1 )
d680 3
a682 4
      grids_iwc%l_f(1) = 1
      grids_iwc%l_z(1) = n_t_zeta
      grids_iwc%l_p(1) = no_sv_p_t
      grids_iwc%l_v(1) = grids_iwc%l_f(1) * grids_iwc%l_z(1) * grids_iwc%l_p(1)
d687 3
a689 4
      grids_tscat%l_f(1) = grids_iwc%l_f(1)
      grids_tscat%l_z(1) = grids_iwc%l_z(1)
      grids_tscat%l_p(1) = grids_iwc%l_p(1)
      grids_tscat%l_v(1) = grids_iwc%l_v(1)
d694 17
a710 2
      call create_grids_2 ( grids_iwc )
      call create_grids_2 ( grids_tscat )
d715 1
a715 1
      grids_iwc%values = reshape(CloudIce%values(:,windowStart:windowFinish),(/sv_t_len/))
d726 8
a733 1
      call create_grids_1 ( grids_mag, 1 )
d737 5
d744 8
a751 7
      grids_mag%l_f(1) = magfield%template%noChans
      grids_mag%l_z(1) = magfield%template%noSurfs
      grids_mag%l_p(1) = grids_mag%windowFinish(1)-grids_mag%windowStart(1)+1
      k = grids_mag%l_f(1) * grids_mag%l_z(1) * grids_mag%l_p(1)
      grids_mag%l_z(1) = k

      call create_grids_2 ( grids_mag )
d830 6
a835 1
    temp_prof => grids_tmp%values(1:n_t_zeta)
a838 3
    call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
      & firstSignal%radiometer, mol_cat_index, l_vmr, &
      & grids_f, h2o_ind, ext_ind )
d841 4
a844 1
        & firstSignal%radiometer, mol_cat_index, l_dn, grids_dn )
d846 2
a847 13
        & firstSignal%radiometer, mol_cat_index, l_dv, grids_dv )
      call load_sps_data ( FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
        & firstSignal%radiometer, mol_cat_index, l_dw, grids_dw )
    end if

    if ( fwdModelConf%Incl_Cld ) then
      if ( icon /= 0 .and. h2o_ind > 0 ) then
        if ( grids_f%l_z(h2o_ind) - grids_f%l_z(h2o_ind-1) /= n_t_zeta ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Temperature and H2O grids not the same size' )
! modify h2o mixing ratio if a special supersaturation /= 0
        call modify_values_for_supersat ( grids_f, h2o_ind, icon, temp_prof )
      end if
d888 29
a916 8

    call get_chi_out ( ptan%values(:,maf), phitan%values(:,maf)*deg2rad, &
       & 0.001_rp*scGeocAlt%values(:,maf), Grids_tmp, &
       & (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
       & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
       & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
       & req_out, grids_f, h2o_ind, tan_chi_out, dhdz_out, dx_dh_out, &
       & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan )
d1101 2
a1102 2
      call allocate_test ( dxdt_surface, 1, sv_t_len,  'dxdt_surface', moduleName )
      call allocate_test ( d2xdxdt_surface, 1, sv_t_len,  'd2xdxdt_surface', &
d1105 29
a1133 9

    call get_chi_out ( tan_press(1:1), tan_phi(1:1), &
       & 0.001_rp*est_scgeocalt(1:1), Grids_tmp, &
       & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
       & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
       & orbIncline%values(1,maf)*Deg2Rad, elevoffset%values(1,1)*Deg2Rad, &
       & (/req_out(1)/), grids_f, h2o_ind, surf_angle, one_dhdz, one_dxdh,  &
       & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface )

d1157 3
d1234 1
a1234 1
    call allocate_test ( beta_path_phh_c,  npc, NU,     'beta_path_phh_c', moduleName )
d1236 11
a1246 4
    call allocate_test ( do_calc_fzp,   no_ele, size(grids_f%values),  'do_calc_fzp',   moduleName )
    call allocate_test ( do_calc_zp,    no_ele, grids_f%p_len,  'do_calc_zp',    moduleName )
    call allocate_test ( eta_fzp,       no_ele, size(grids_f%values),  'eta_fzp',       moduleName )
    call allocate_test ( eta_zp,        no_ele, grids_f%p_len,  'eta_zp',        moduleName )
d1248 4
a1251 16
    if ( fwdModelConf%Incl_Cld ) then
      call allocate_test ( do_calc_iwc,    no_ele, size(grids_f%values),  'do_calc_iwc',   moduleName )
      call allocate_test ( eta_iwc,        no_ele, size(grids_f%values),  'eta_iwc',       moduleName )
      call allocate_test ( eta_iwc_zp,     no_ele, grids_f%p_len,  'eta_iwc_zp',    moduleName )
      call allocate_test ( iwc_path,       no_ele, 1, 'iwc_path',           moduleName )
      call allocate_test ( ipsd,           no_ele, 'IPSD', moduleName )
      call allocate_test ( wc,          n, no_ele, 'WC', moduleName )
    end if
    if ( FwdModelConf%polarized ) then
      call allocate_test ( do_calc_mag,    no_ele, size(grids_f%values), 'do_calc_mag',    moduleName )
      call allocate_test ( do_calc_mag_zp, no_ele, grids_f%p_len,        'do_calc_mag_zp', moduleName )
      call allocate_test ( eta_mag,        no_ele, size(grids_f%values), 'eta_mag',        moduleName )
      call allocate_test ( eta_mag_zp,     no_ele, grids_f%p_len,        'eta_mag_zp',     moduleName )
      call allocate_test ( mag_path,       no_ele, magfield%template%noChans, 'mag_path', &
        & moduleName )
    end if
d1293 2
a1294 2
      call allocate_test ( dRad_df, size(grids_f%values), 'dRad_df', moduleName )
      call allocate_test ( k_atmos, noUsedChannels, no_tan_hts, size(grids_f%values), &
d1316 3
a1318 3
      f_len_dw = grids_dw%l_v(ubound(grids_dw%l_v,1))
      f_len_dn = grids_dn%l_v(ubound(grids_dn%l_v,1))
      f_len_dv = grids_dv%l_v(ubound(grids_dv%l_v,1))
d1406 1
a1406 1
      h = 0.5
d1410 1
a1410 1
!call testfield ( h, ct, stcp, stsp )
d1515 1
a1515 1
        & call allocate_test ( k_atmos_frq, maxNoPtgFreqs, size(grids_f%values), 'k_atmos_frq',&
d1670 6
a1678 6
          !set cloud parameters to zero
          iwc_path(1:no_ele,1) = 0.
          WC(1,1:no_ele)=iwc_path(1:no_ele,1)
          WC(2,1:no_ele)=0.  
          IPSD(1:no_ele)=1000

d1693 2
a1694 1
        if ( FwdModelConf%polarized ) then
d1696 2
a1697 2
!          call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:no_ele), &
!            &  phi_path(1:no_ele), do_calc_mag_zp(1:no_ele,:), eta_mag_zp(1:no_ele,:) )
d1699 6
a1704 6
          ! Compute MAG_PATH
          Frq = 0.0
!          call comp_sps_path_frq ( Grids_mag, firstSignal%lo, thisSideband, &
!            & Frq, eta_zp(1:no_ele,:), &
!            & do_calc_zp(1:no_ele,:), mag_path(1:no_ele,:),      &
!            & do_calc_mag(1:no_ele,:), eta_mag(1:no_ele,:) )
d1706 2
a1707 2
          !This is where we should rotate mag_path from ECR to IFOVPP (R1A) coordinates
          !????
d1709 1
a1709 1
        end if
d1868 1
d1872 2
a1873 2
!                  & incoptdepth(1:npc)
                   & 0.5*incoptdepth(1:npc)
d1877 3
a1879 3
!                  & incoptdepth(1:npc)
                   & 0.5*incoptdepth(1:npc)

d1933 1
a1933 1
          else
d1946 1
d1981 2
d1995 1
a1995 1
            k_atmos_frq(frq_i,1:size(grids_f%values)) = drad_df(1:size(grids_f%values))
d2124 1
d2148 9
a2156 3
            k_temp(1:noUsedChannels,ptg_i,1:n_t_zeta,1:no_sv_p_t) = &
              & reshape( k_temp_frq(1:noUsedChannels,1:no_sv_p_t*n_t_zeta), &
                &        (/ noUsedChannels, n_t_zeta, no_sv_p_t /) )
d2162 1
d2166 1
d2168 17
a2184 10
            if ( fwdModelConf%moleculeDerivatives(mol_cat_index(k)) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd),             &
                    & sideband = thisSideband, channel=channel )
                  do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
d2194 17
a2210 9
                  end do                ! Surface loop X Instance loop
                end do                  ! Channel loop
              else                      ! Else not frequency averaging
                do sv_i = grids_f%l_v(k-1)+1, grids_f%l_v(k)
                  if ( grids_f%deriv_flags(sv_i) ) then
                    k_atmos(1:noUsedChannels,ptg_i,sv_i) = k_atmos_frq(1:noUsedChannels,sv_i)
                  else
                    k_atmos(1:noUsedChannels,ptg_i,sv_i) = 0.0
                  end if
d2212 2
a2213 2
              end if                    ! Frequency averaging or not
            end if                      ! Want derivatives for this specie?
d2220 1
d2224 90
d2315 38
a2352 7
            if ( fwdModelConf%moleculeDerivatives(mol_cat_index(k)) ) then
              !  *** dI/dW
              call dI_dSomething ( grids_dw, k_spect_dw_frq, k_spect_dw, k )
              !  *** dI/dN
              call dI_dSomething ( grids_dn, k_spect_dn_frq, k_spect_dn, k )
              !  *** dI/dV
              call dI_dSomething ( grids_dv, k_spect_dv_frq, k_spect_dv, k )
d2446 1
a2446 1
          ! Now change channel from starting at 0 or 1 to definitely 1
d2452 1
a2452 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2458 3
a2460 3
            call convolve_all ( FwdModelConf, FwdModelIn, FwdModelExtra, maf,  &
               & chanInd, windowStart, windowFinish, mol_cat_index, temp, ptan,&
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2470 1
a2470 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2475 1
a2475 1
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d2479 1
a2479 1
               & thisRadiance, update, ptg_angles, Radiances(:,i), tan_chi_out,&
d2487 1
a2487 1
!              & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d2516 1
a2516 1
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d2526 1
a2526 1
!             &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,size(grids_f%values)/))) )
d2613 2
a2833 46

  contains

    subroutine dI_dSomething ( grids_dS, k_spect_dS_frq, k_spect_dS, K )

    ! Do or don't do frequency averaging, to finish up derivative of I w.r.t. S

      type(grids_T), intent(in) :: grids_dS
      real(rp), dimension(:,:), intent(in) :: K_SPECT_DS_FRQ ! ****
      real(r4), dimension(:,:,:,:,:,:), intent(out) :: K_SPECT_DS
      integer, intent(in) :: K ! Which molecule

      if ( fwdModelConf%do_freq_avg ) then
        do i = 1, noUsedChannels
          sigInd = usedSignals(i)
          channel = usedChannels(i)
          shapeInd = MatchSignal ( filterShapes%signal, &
            & fwdModelConf%signals(sigInd),             &
            & sideband = thisSideband, channel=channel )
          j = Size(FilterShapes(shapeInd)%FilterGrid)
          sv_i = Grids_dS%l_v(k-1)
          do instance = WindowStart, WindowFinish
            do surface = 1, Grids_dS%l_z(k) - Grids_dS%l_z(k-1)
              do jf = 1, Grids_dS%l_f(k) - Grids_dS%l_f(k-1)
                sv_i = sv_i + 1
                call Freq_Avg ( frequencies,           &
                  & FilterShapes(shapeInd)%FilterGrid, &
                  & FilterShapes(shapeInd)%FilterShape,&
                  & k_spect_dS_frq(:,sv_i), noFreqs, j, r )
                k_spect_dS(i,ptg_i,jf,surface,instance,k) = r
              end do              ! Frequencies loop
            end do                ! Surface loop
          end do                  ! Instance loop
        end do                    ! Channel loop
      else                        ! else not frequency averaging
        k_spect_dS( 1:noUsedChannels, ptg_i, &
          &         1:Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
          &         1:Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &
          &         windowStart:windowFinish, k ) = &
          & reshape(k_spect_dS_frq( 1:noUsedChannels, &
          &                         Grids_dS%l_v(k-1) + 1: Grids_dS%l_v(k) ), &
            &       (/ noUsedChannels, Grids_dS%l_f(k) - Grids_dS%l_f(k-1), &
            &          Grids_dS%l_z(k) - Grids_dS%l_z(k-1), &                
            &          windowFinish - windowStart + 1 /) )                   
      end if                      ! Frequency averaging or not
    end subroutine dI_dSomething
@


2.126.2.22
log
@More futzing with grids_t and stuff that uses it
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.21 2003/03/20 01:42:25 vsnyder Exp $"
d57 2
a58 2
    use Load_sps_data_m, ONLY: Destroygrids_t, Grids_T, Load_One_Item_Grid, &
      & LOAD_SPS_DATA, Modify_values_for_supersat
d600 3
d610 4
a613 1
! Create the Grids_tmp structure:
d615 1
a615 2
    !??? Should .true. be temp_der ???
    call load_one_item_grid ( grids_tmp, temp, phitan, maf, fwdModelConf, .true. )
a616 4
    !??? These windowStart and windowFinish values are used ubiquitously ???
    !??? Shouldn't each thing-o use its own ???
    windowStart = grids_tmp%windowStart(1)
    windowFinish = grids_tmp%windowFinish(1)
d618 19
a636 2
    n_t_zeta = grids_tmp%l_z(1)
    sv_t_len = grids_tmp%l_z(1) * grids_tmp%l_p(1)
d640 2
a641 1
      call load_one_item_grid ( grids_iwc, cloudIce, phitan, maf, fwdModelConf, .false. )
d643 28
a670 2
      !??? Is cloudIce the correct quantity to use here ???
      call load_one_item_grid ( grids_tscat, cloudIce, phitan, maf, fwdModelConf, .false. )
d674 37
a710 3
    if ( FwdModelConf%polarized ) &
      & call load_one_item_grid ( grids_mag, magfield, phitan, maf, &
        & fwdModelConf, .false. )
a831 1
    !??? Which grids_... should give the windowStart:windowFinish to use here ???
a1027 1
    !??? Which grids_... should give the windowStart:windowFinish to use here ???
a1040 1
    !??? Which grids_... should give the windowStart:windowFinish to use here ???
a2201 1
          !??? Which grids_... should give the windowStart:windowFinish to use here ???
a2244 1
          !??? Which grids_... should give the windowStart:windowFinish to use here ???
d2399 3
a2401 3
    call deallocate_test ( h_glgrid,     'h_glgrid',     moduleName )
    call deallocate_test ( t_glgrid,     't_glgrid',     moduleName )
    call deallocate_test ( dhdz_glgrid,  'dhdz_glgrid',  moduleName )
d2403 1
a2403 1
    call deallocate_test ( ddhidhidtl0,  'ddhidhidtl0',  moduleName )
d2405 6
a2410 6
    call deallocate_test ( tan_inds,      'tan_inds',      moduleName )
    call deallocate_test ( tan_press,     'tan_press',     moduleName )
    call deallocate_test ( tan_phi,       'tan_phi',       moduleName )
    call deallocate_test ( tan_hts,       'tan_hts',       moduleName )
    call deallocate_test ( tan_temps,     'tan_temps',     moduleName )
    call deallocate_test ( reqs,          'reqs',          moduleName )
d2412 1
a2412 1
    call deallocate_test ( tan_temp,      'tan_temp',      moduleName )
d2416 1
a2418 1
    call destroygrids_t ( grids_tmp )
d2469 3
a2471 3
    call deallocate_test ( tan_chi_out, 'tan_chi_out', moduleName )
    call deallocate_test ( dx_dh_out,   'dx_dh_out',   moduleName )
    call deallocate_test ( dhdz_out,    'dhdz_out',    moduleName )
d2606 1
a2606 1
          do instance = Grids_dS%WindowStart(k), Grids_dS%WindowFinish(k)
d2623 1
a2623 1
          &         Grids_dS%WindowStart(k):Grids_dS%WindowFinish(k), k ) = &
d2628 1
a2628 1
            &          Grids_dS%WindowFinish(k) - Grids_dS%WindowStart(k) + 1 /) )                   
a2641 3
! Revision 2.126.2.21  2003/03/20 01:42:25  vsnyder
! Revise Grids_T structure
!
@


2.126.2.23
log
@Use an array of pointers to quantities instead of searching several times
using GetQuantityForForwardModel.  Move stuff around.  Cosmetic changes.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.22 2003/03/20 19:21:05 vsnyder Exp $"
d41 1
a41 1
    use ForwardModelVectorTools, only: GetQuantityForForwardModel, QtyStuff_T
d57 1
a57 1
    use Load_sps_data_m, only: Destroygrids_t, Grids_T, Load_One_Item_Grid, &
a164 2
    integer :: Z_ALL_PREV               ! Z_ALL_SIZE before adding something
    integer :: Z_ALL_SIZE               ! Size of Z_ALL, q.v.
d348 1
a368 2
    type (qtyStuff_t), pointer :: Qtys(:)      ! Array of pointers to Qty's.

d444 1
a444 1
    ! Nullify all our pointers that are allocated!
d449 1
a449 1
      & channelOrigins, ct, &
d474 1
a474 1
      & k_temp_frq, mag_path, mol_cat_index, n_path, path_dsdh, &
d476 1
a476 1
      & radiances, RadV, ref_corr, req_out, reqs, &
d483 1
a483 1
      & z_glgrid, z_path, z_path_c )
a499 27
    ! Think about sidebands
    if ( ( fwdModelConf%signals(1)%sideband == 0 ) .and.&
      &  ( fwdModelConf%signals(1)%singleSideband == 0 ) ) then
      ! Do a folded measurement
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      ! It's either a single sideband radiometer, or the user requested a
      ! specific sideband.
      ! Check sanity, if they are both non zero they should be the same.
      if ( ( fwdModelConf%signals(1)%singleSideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%sideband /= 0 ) .and. &
        &  ( fwdModelConf%signals(1)%singleSideband /= &
        &    fwdModelConf%signals(1)%sideband ) ) call MLSMessage ( &
        &      MLSMSG_Error, ModuleName, &
        &      "User requested a sideband that doesn't exist" )
      ! OK, use whichever one is given
      if ( fwdModelConf%signals(1)%singleSideband /= 0 ) then
        sidebandStart = fwdModelConf%signals(1)%singleSideband
      else
        sidebandStart = fwdModelConf%signals(1)%sideband
      end if
      sidebandStop = sidebandStart
      sidebandStep = 1
    end if

a503 21
    ! Create the data structures for the species

    call get_species_data ( fwdModelConf%molecules, fwdModelConf, &
      & fwdModelIn, fwdModelExtra, sidebandStart, sidebandStop, &
      & noSpecies, no_mol, beta_group, my_catalog )

    call allocate_test ( mol_cat_index, no_mol, 'mol_cat_index', moduleName )

    mol_cat_index = PACK((/(i,i=1,noSpecies)/), fwdModelConf%molecules > 0)

    allocate ( qtys(no_mol), stat = ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'QTYS' )

    ! Get state vector quantities for species
    do sps_i = 1 , no_mol
      qtys(sps_i)%qty => GetQuantityForForwardModel(fwdmodelin, fwdmodelextra, &
        &  quantitytype = l_vmr, molIndex=mol_cat_index(sps_i), config=fwdModelConf, &
        &  radiometer = firstsignal%radiometer, foundInFirst=qtys(sps_i)%foundInFirst )
    end do

d540 1
a540 1
    sizeDistribution => GetVectorQuantityByType( fwdModelIn, fwdModelExtra, &
d550 5
d573 27
d612 2
d633 11
a643 1
! Work out which channels are used; also check we have radiances for them.
d676 8
a683 3
    do sps_i = 1 , no_mol
      maxNoFFreqs = max(maxNoFFreqs, qtys(sps_i)%qty%template%noChans)
      maxNoFSurfs = max(maxNoFSurfs, qtys(sps_i)%qty%template%noSurfs)
d690 1
a690 1
! Set up our temporary `state vector' like arrays ------------------------
d709 1
a709 1
        ! modify h2o mixing ratio if a special supersaturation /= 0
d714 1
a714 1
! set up output pointing angles ------------------------------------------
d753 1
a753 2
    ! Temperature's windowStart:windowFinish are correct here.  There is an
    ! assumption that refGPH and temperature have the same horizontal basis.
d767 1
a767 10
! Calculate size of z_all and allocate it

    z_all_size = temp%template%nosurfs+2 + &
      & Size(FwdModelConf%integrationGrid%surfs)
    if ( associated(FwdModelConf%tangentGrid) ) &
      & z_all_size = z_all_size + FwdModelConf%tangentGrid%nosurfs
    do sps_i = 1 , no_mol
      z_all_size = z_all_size + qtys(sps_i)%qty%template%nosurfs
    end do
    call allocate_test ( z_all, z_all_size, 'z_all', moduleName )
a768 1
! Fill in z_all
d770 1
d772 1
a772 9
    z_all_prev = temp%template%nosurfs+2
    z_all(1) = -3.000_rp
    z_all(2:z_all_prev-1) = temp%template%surfs(:,1)
    z_all(z_all_prev) = 4.000_rp

    ! Add the original Integration Grid:
    z_all_size = z_all_prev + Size(FwdModelConf%integrationGrid%surfs)
    z_all(z_all_prev+1:z_all_size) = FwdModelConf%integrationGrid%surfs
    z_all_prev = z_all_size
d774 2
d777 10
a786 4
      ! if pointing grid is associated concatenate it to the state vector
      z_all_size = z_all_prev + FwdModelConf%tangentGrid%nosurfs
      z_all(z_all_prev+1:z_all_size) = FwdModelConf%tangentGrid%surfs
      z_all_prev = z_all_size
d790 17
a806 3
      z_all_size = z_all_size + qtys(sps_i)%qty%template%nosurfs
      z_all(z_all_prev+1:z_all_size) = qtys(sps_i)%qty%template%surfs(:,1)
      z_all_prev = z_all_size
d809 13
a821 1
! Now, create the final grid and discard the temporary array:
d859 16
a941 18
    ! Compute hydrostatic grid -----------------------------------------------

    ! Insert into bill's 2d hydrostatic equation.
    ! The phi input for this program are the orbit plane projected
    ! geodetic locations of the temperature phi basis--not necessarily
    ! the tangent phi's which may be somewhat different.

    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_Begin ( 'ForwardModel.Hydrostatic' )

    ! Temperature's windowStart:windowFinish are correct here.  There is an
    ! assumption that refGPH and temperature have the same horizontal basis.
    call two_d_hydrostatic ( Grids_tmp, &
      &  (/ (refGPH%template%surfs(1,1), j=1,no_sv_p_t) /), &
      &  0.001*refGPH%values(1,windowStart:windowFinish), z_glgrid, &
      &  orbIncline%values(1,maf)*Deg2Rad, t_glgrid, h_glgrid, &
      &  dhdz_glgrid, dh_dt_glgrid, DDHDHDTL0=ddhidhidtl0 )

d950 1
a950 2
    ! Temperature's windowStart:windowFinish are correct here.  There is an
    ! assumption that refGPH and temperature have the same horizontal basis.
d964 1
a964 1
    !??? Temperature's windowStart:windowFinish are probably not correct here ???
d967 1
a967 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d971 1
a971 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d975 1
a975 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1065 3
a1067 3
      call allocate_test ( do_calc_iwc,    no_ele, size(grids_iwc%values),  'do_calc_iwc',   moduleName )
      call allocate_test ( eta_iwc,        no_ele, size(grids_iwc%values),  'eta_iwc',       moduleName )
      call allocate_test ( eta_iwc_zp,     no_ele, grids_iwc%p_len,  'eta_iwc_zp',    moduleName )
d1073 4
a1076 4
      call allocate_test ( do_calc_mag,    no_ele, size(grids_mag%values), 'do_calc_mag',    moduleName )
      call allocate_test ( do_calc_mag_zp, no_ele, grids_mag%p_len,        'do_calc_mag_zp', moduleName )
      call allocate_test ( eta_mag,        no_ele, size(grids_mag%values), 'eta_mag',        moduleName )
      call allocate_test ( eta_mag_zp,     no_ele, grids_mag%p_len,        'eta_mag_zp',     moduleName )
d1763 1
a1763 1
alpha_path_f = 0.5 * alpha_path_f
d2129 1
a2129 1
               & chanInd, windowStart, windowFinish, qtys, temp,ptan, &
d2137 1
a2137 1
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
d2147 1
a2147 1
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
d2156 1
a2156 1
               & chanInd, windowStart, windowFinish, qtys, temp, ptan,&
d2177 2
a2178 2
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
              &  PTAN_DER=ptan_der)
d2184 2
a2185 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
d2193 2
a2194 2
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
              &  DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
d2201 2
a2202 1
              &  Radiances(:,i), thisRatio, qtys, fmStat%rows, Jacobian,  &
a2507 4
    deallocate ( qtys, stat = ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_DeAllocate // 'QTYS' )

a2567 3
! Revision 2.126.2.22  2003/03/20 19:21:05  vsnyder
! More futzing with grids_t and stuff that uses it
!
@


2.126.2.24
log
@Interpolate the magnetic field onto the path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.23 2003/03/21 02:49:55 vsnyder Exp $"
d30 1
a30 1
    use Comp_Sps_Path_Frq_m, only: Comp_Sps_Path, Comp_Sps_Path_Frq
d201 2
d296 2
d300 1
a300 1
    real(rp), dimension(:,:), pointer :: ETA_ZP       ! Eta_z x Eta_p
a301 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN   ! Eta_z x Eta_p for N
d303 1
a304 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV   ! Eta_z x Eta_p for V
d306 1
a307 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW   ! Eta_z x Eta_p for W
d309 1
a310 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T    ! Eta_t_z x Eta_t_p
a312 1
    real(rp), dimension(:,:), pointer :: IWC_PATH   ! species on path
a317 1
    real(rp), dimension(:,:), pointer :: MAG_PATH   ! Magnetic field on path
d320 4
a323 2
    real(rp), dimension(:,:), pointer :: TAN_DH_DT  ! dH/dT at Tangent
    real(rp), dimension(:,:), pointer :: T_GLGRID   ! Temp on glGrid surfs
d452 1
a452 1
      & channelOrigins, &
d463 1
d467 1
a467 1
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, eta_iwc, &
d473 1
a473 1
      & h_glgrid, h_path, h_path_c, h_path_f, &
d480 1
a480 1
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, superset, &
d1062 3
d1066 1
a1066 1
      call allocate_test ( mag_path,       no_ele, magfield%template%noChans+1, 'mag_path', &
d1210 18
d1475 1
a1475 1
          &  phi_path(1:no_ele), eta_zp(1:no_ele,:), do_calc_zp(1:no_ele,:) )
d1497 2
a1498 2
            &  phi_path(1:no_ele), eta_iwc_zp(1:no_ele,:), &
            &  do_calc_iwc_zp(1:no_ele,:) )
d1512 2
a1513 2
          call comp_eta_docalc_no_frq ( Grids_Mag, z_path(1:no_ele), &
            &  phi_path(1:no_ele), eta_mag_zp(1:no_ele,:) )
d1515 6
a1520 12
          ! Compute the three components of MAG_PATH
          call comp_sps_path ( Grids_mag, 1, eta_mag_zp(1:no_ele,:), &
            & mag_path(1:no_ele,1:3) )

          do j = 1, no_ele
            ! Rotate mag_path from ECR to IFOVPP (R1A) coordinates
            !???? Still needs to be done
            ! Put the magnitude of mag_path(j,1:3) in mag_path(j,4), then
            ! normalize mag_path(j,1:3).
            mag_path(j,4) = sqrt(sum(mag_path(j,1:3)**2))
            mag_path(j,1:3) = mag_path(j,1:3) / mag_path(j,4)
          end do
d1522 2
a1523 5
          !??? The second subscript depends on the ordering of the rotation matrix ???
          ct => mag_path(1:no_ele,1)   ! cos(theta)
          stcp => mag_path(1:no_ele,2) ! sin(theta) cos(phi)
          stsp => mag_path(1:no_ele,3) ! sin(theta) sin(phi)
          h => mag_path(1:no_ele,4)    ! magnitude of magnetic field
d2368 2
d2372 3
a2374 2
    call deallocate_test ( do_calc_iwc_zp,'do_calc_iwc_zp',moduleName )
    call deallocate_test ( do_calc_zp,    'do_calc_zp',    moduleName )
d2377 2
a2378 3
    call deallocate_test ( eta_iwc_zp,    'eta_iwc_zp',    moduleName )
    call deallocate_test ( eta_mag_zp,    'eta_mag_zp',    moduleName )
    call deallocate_test ( eta_zp,        'eta_zp',        moduleName )
a2380 1
    call deallocate_test ( sps_path,      'sps_path',      moduleName )
d2479 6
a2558 4
! Revision 2.126.2.23  2003/03/21 02:49:55  vsnyder
! Use an array of pointers to quantities instead of searching several times
! using GetQuantityForForwardModel.  Move stuff around.  Cosmetic changes.
!
@


2.126.2.25
log
@Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.24 2003/03/22 02:48:53 vsnyder Exp $"
d44 1
a44 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, &
d49 1
a49 2
    use Get_Species_Data_M, only: Beta_Group_T, Get_Species_Data, &
      Destroy_Species_Data, Destroy_Beta_Group
d422 1
a422 1
    integer, dimension(:), pointer :: mol_cat_index
d424 1
a424 1
    type (beta_group_T), dimension(:), pointer :: beta_group
d878 17
a894 19
    ! Sort z_path.  Permute p_path and t_path the same way.
    do i = 2, k ! Invariant: z_path(1:i-1) are sorted.
      r = z_path(i)
      if ( r < z_path(i-1) ) then
        r1 = p_path(i)
        r2 = t_path(i)
        jf = i
        do ! Find where to insert R.  Make room as we go.
          z_path(jf) = z_path(jf-1)
          p_path(jf) = p_path(jf-1)
          t_path(jf) = t_path(jf-1)
          jf = jf - 1
          if ( jf == 1 ) exit
          if ( r >= z_path(jf-1) ) exit
        end do
        z_path(jf) = r
        p_path(jf) = r1
        t_path(jf) = r2
      end if
a935 1
    !??? Check whether temperature and refGPH have the same hGrid ???
d949 13
a961 16
    if ( spect_der ) then
      !??? Temperature's windowStart:windowFinish are probably not correct here ???
      allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dw' )
      allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dn' )
      allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFFreqs, &
        & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_spect_dv' )
    end if

a1421 1
        !??? tan_temps is only used in a commented-out call to dump ???
a1443 1
        !??? This is never used for anything ???
d2262 8
a2269 1
    call destroy_beta_group ( beta_group )
d2272 1
d2281 9
a2289 11
    if ( spect_der ) then
      deallocate ( k_spect_dw, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dw' )
      deallocate ( k_spect_dn, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dn' )
      deallocate ( k_spect_dv, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dv' )
    end if
a2535 3
! Revision 2.126.2.24  2003/03/22 02:48:53  vsnyder
! Interpolate the magnetic field onto the path
!
d2547 1
a2547 1
! Use ASSOCIATED instead of PRESENT for "optional" arguments GET_CHI_OUT
@


2.126.2.26
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.25 2003/03/22 04:03:04 vsnyder Exp $"
d57 3
a59 2
    use Load_Sps_Data_m, only: DestroyGrids_t, Grids_T, Load_One_Item_Grid, &
      & Load_Sps_Data, Modify_values_for_supersat
d63 1
d73 1
a73 1
    use Molecules, only: L_Extinction ! Used in include dump_print_code.f9h
d83 1
a83 1
    use String_table, only: GET_STRING ! Used in include dump_print_code.f9h
d90 2
a91 1
                         &   GETVECTORQUANTITYBYTYPE
d2282 12
a2434 10
      deallocate ( k_spect_dw, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dw' )
      deallocate ( k_spect_dn, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dn' )
      deallocate ( k_spect_dv, stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_spect_dv' )

d2480 1
a2480 1
      call trace_end ( 'ForwardModel MAF=', fmStat%maf )
a2538 3
! Revision 2.126.2.25  2003/03/22 04:03:04  vsnyder
! Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
!
@


2.126.2.27
log
@Get ECRtoFOV, use it to rotate mag_path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.26 2003/03/22 04:19:13 vsnyder Exp $"
d53 1
a53 1
      & L_DN, L_DV, L_DW, L_EARTHREFL, L_ECRtoFOV, &
a61 1
    use ManipulateVectorQuantities, only: DoHGridsMatch
a132 1
    integer :: MIF                      ! GRIDS(PTG_I)
d369 2
a370 5
    type (VectorValue_T), pointer :: CLOUDICE      ! Profiles
    type (VectorValue_T), pointer :: CLOUDWATER    ! Profiles
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
    type (VectorValue_T), pointer :: ECRtoFOV      ! Rotation matrices
    type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset
d373 2
a374 3
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    type (VectorValue_T), pointer :: MAGFIELD      ! Profiles
    type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination
a379 1
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really
d382 5
a386 1
    type (VectorValue_T), pointer :: THISRADIANCE  ! A radiance vector quantity
d576 2
a577 2
    if ( FwdModelConf%polarized ) then
      magField => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
a578 3
      ECRtoFOV => GetQuantityForForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ECRtoFOV, config=fwdModelConf )
    end if
a600 5
    if ( .not. ValidateVectorQuantity(refGPH, stacked=.TRUE., coherent=.TRUE., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'refGPH' )
    if ( .not. doHGridsMatch ( refGPH, temp ) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, 'Different horizontal grids for refGPH and temperature' )
d934 3
a936 2
    ! Temperature's windowStart:windowFinish are correct here.
    ! refGPH and temperature have the same horizontal basis.
a1330 2
        mif = grids(ptg_i)

d1501 2
a1502 8
            ! Rotate mag_path from ECR to IFOVPP (R1A) coordinates.  Use
            ! the rotation matrix for the MIF nearest to the current
            ! pointing angle instead of interpolating.  They are nearly
            ! identical anyway.
            !??? Do we need to transpose the matrix ???
            mag_path(j,1:3) = matmul(reshape( &
              & ECRtoFOV%values(9*mif-8:9*mif,maf), (/3,3/)), &
              & mag_path(j,1:3) )
a1514 7
          if ( index(switches,'mag') /= 0 ) then
            call dump ( h, 'H' )
            call dump ( ct, 'Cos(theta)' )
            call dump ( stcp, 'Sin(theta) Cos(phi)' )
            call dump ( stsp, 'Sin(theta) Sin(phi)' )
          end if

d1575 2
a1576 2
          k = SIZE(PointingGrids(whichPointingGrid)% &
                       & oneGrid(mif)%frequencies)
d1578 1
a1578 1
                       & oneGrid(mif)%frequencies, k, j, frq_i )
d1580 1
a1580 1
                       & oneGrid(mif)%frequencies, k, frq_i, m )
d1584 1
a1584 1
                      & oneGrid(mif)%frequencies(j:m)
a2533 3
! Revision 2.126.2.26  2003/03/22 04:19:13  vsnyder
! Cosmetic changes
!
@


2.126.2.28
log
@Houst a reshape out of a loop
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.27 2003/03/27 00:50:35 vsnyder Exp $"
a216 1
    real(rp) :: ROT(3,3)      ! ECR-to-FOV rotation matrix
a1511 2
          !??? Do we need to transpose the rotation matrix ???
          rot = reshape(ECRtoFOV%values(9*mif-8:9*mif,maf), (/3,3/))
d1517 4
a1520 1
            mag_path(j,1:3) = matmul ( rot, mag_path(j,1:3) )
a2558 3
! Revision 2.126.2.27  2003/03/27 00:50:35  vsnyder
! Get ECRtoFOV, use it to rotate mag_path
!
@


2.126.2.29
log
@add new scaterring source module
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.28 2003/03/27 23:32:19 vsnyder Exp $"
a79 1
    use ScatSourceFunc, only: T_SCAT
d430 1
a430 9
! scatering source function for each temperature surface
    real(r8), dimension(:,:), pointer :: scat_src
    real(r8), dimension(:), pointer :: U          ! COSINE OF SCATTERING ANGLES
    real(r8), dimension(:), pointer :: DU         ! DELTA U
    real(r8), dimension(:), pointer :: UA         ! COSINE OF SCATTERING AZIMUTH ANGLES
    real(r8), dimension(:), pointer :: THETA      ! SCATTERING ANGLES
    real(r8), dimension(:), pointer :: PHI        ! SCATTERING AZIMUTH ANGLES
    real(r8), dimension(:,:,:), pointer :: UI     ! COSINE OF ANGLES FOR INCIDENT TB
    real(r8), dimension(:,:,:), pointer :: THETAI ! ANGLES FOR INCIDENT TB
d484 1
a484 1
      & z_glgrid, z_path, z_path_c, scat_src, u, du, ua, theta, phi, ui, thetai )
a1629 18
          ! Compute Scattering source function based on temp_prof
         
             call allocate_test ( scat_src, n_t_zeta, nu, &
               & 'scat_src', moduleName )

             call allocate_test ( U,  nu, 'U',  moduleName )
             call allocate_test ( DU, nu, 'DU', moduleName )
             call allocate_test ( UA, nua,'UA', moduleName )
             call allocate_test ( THETA, nu,'THETA', moduleName )
             call allocate_test ( PHI, nua,'PHI', moduleName )
             call allocate_test ( UI, nu, nu, nua,'UI', moduleName )
             call allocate_test ( THETAI, nu, nu, nua,'THETAI', moduleName )

             IF ( associated(CloudIce) ) then
                 CALL T_scat (n_t_zeta, temp_prof, Frq, scat_src, NU, NUA, &
                         &   U, DU, UA, THETA, PHI, UI, THETAI )  
             END IF

a1906 9
          call deallocate_test ( scat_src, 'scat_src', moduleName )
          call deallocate_test ( U, 'U', moduleName )
          call deallocate_test ( DU, 'DU', moduleName )
          call deallocate_test ( UA, 'UA', moduleName )
          call deallocate_test ( THETA, 'THETA', moduleName )
          call deallocate_test ( PHI, 'PHI', moduleName )
          call deallocate_test ( UI, 'UI', moduleName )
          call deallocate_test ( THETAI, 'THETAI', moduleName )

a2558 3
! Revision 2.126.2.28  2003/03/27 23:32:19  vsnyder
! Houst a reshape out of a loop
!
@


2.126.2.30
log
@update call to T_scat
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.29 2003/03/28 18:14:19 jonathan Exp $"
d1654 1
a1654 2
                         &   U, DU, UA, THETA, PHI, UI, THETAI,            &
                         &   IPSD(1:n_t_zeta), NAB, NR, N )  
a2594 3
! Revision 2.126.2.29  2003/03/28 18:14:19  jonathan
! add new scaterring source module
!
@


2.126.2.31
log
@modified cal to T_scat
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.30 2003/04/04 20:43:53 jonathan Exp $"
d18 1
a18 1
!-----------------------------------------------------------------------------
d21 1
a21 1
! ---------------------------------------------  FullForwardModel  ---------
d384 1
a384 1
    type (VectorValue_T), pointer :: PTAN   ! Tangent pressure component of state vector
a1652 2
             ! COMPUTE SCATTERING SOURCE FUNCTION AT ALL ANGLES U FOR EACH 
             ! TEMPERATURE LAYER ASSUMING A PLANE PARALLEL ATMOSPHERE       
d1654 2
a1655 1
                         &   U, DU, UA, THETA, PHI, UI, THETAI, NAB, NR, N )  
a1657 2


a2595 3
! Revision 2.126.2.30  2003/04/04 20:43:53  jonathan
! update call to T_scat
!
@


2.126.2.32
log
@remove if condition for Modify_values_for_supersat
@
text
@d12 1
a12 1
!------------------------------ RCS Ident Info -------------------------------
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.31 2003/04/07 17:13:52 jonathan Exp $"
d18 1
a18 1
!------------------------------------------------------------------------------
d21 1
a21 1
!---------------------------------------------  FullForwardModel  -------------
d44 1
a44 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Get_Beta_Path_Cloud, & ! JJ
d52 1
a52 1
    use Intrinsic, only: L_CHANNEL, L_CLOUDICE, L_CLOUDWATER, &      ! JJ
d58 1
a58 1
      & Load_Sps_Data, Modify_values_for_supersat                    ! JJ
d80 1
a80 1
    use ScatSourceFunc, only: T_SCAT             !JJ
d84 1
a84 1
! use testfield_m
d99 2
a100 2
    !--------------------------------------------
    real(r8), dimension(:,:), pointer :: WC   !JJ
d102 1
a102 1
    !--------------------------------------------
d168 1
a168 1
    integer :: ICON                     ! i_saturation                 !JJ
d199 1
a199 1
    logical, dimension(:,:), pointer :: DO_CALC_IWC   ! 'Avoid zeros' indicator  !JJ
d206 1
a206 1
    logical, dimension(:,:), pointer :: DO_CALC_IWC_ZP! 'Avoid zeros' indicator  !JJ
d226 1
a226 1
    real(rp), dimension(:), pointer :: BETA_PATH_cloud_C ! Beta on path coarse   !JJ
d277 1
a277 1
    real(rp), dimension(:,:), pointer :: BETA_PATH_PHH_C   ! Scattering phase function !JJ 
d295 2
a296 2
    real(rp), dimension(:,:), pointer :: ETA_IWC      ! JJ
    real(rp), dimension(:,:), pointer :: ETA_Iwc_ZP   ! JJ
d312 1
a312 1
    real(rp), dimension(:,:), pointer :: IWC_PATH     ! species on path   !JJ
d373 1
a373 1
    type (VectorValue_T), pointer :: CLOUDICE      ! Profiles    !JJ
d383 3
a385 3
    type (VectorValue_T), pointer :: PHITAN    ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTAN      ! Tangent pressure component of state vector
    type (VectorValue_T), pointer :: REFGPH    ! Reference geopotential height
d388 1
a388 1
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really   !JJ
d405 1
a405 1
    type (Grids_T) :: Grids_iwc ! All the coordinates for WC     !JJ
d408 1
a408 1
    type (Grids_T) :: Grids_Tscat ! All the coordinates for scaterring source function !JJ
d430 1
a430 1
    real(r8), dimension(:), pointer :: temp_prof      !JJ
d432 1
a432 1
    real(r8), dimension(:,:), pointer :: scat_src     !JJ
d591 1
a591 1
        & quantityType=l_magneticField, config=fwdModelConf )
d593 1
a593 1
        & quantityType=l_ECRtoFOV, config=fwdModelConf )
d595 10
a604 9
    if ( FwdModelConf%incl_cld ) then          !JJ
      cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,  &
        & quantityType=l_cloudIce, noError=.true. )
      cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_cloudWater, noError=.true. )
      sizeDistribution => GetVectorQuantityByType( fwdModelIn, fwdModelExtra, &
        & quantityType=l_sizeDistribution, noError=.true. )
    endif
    icon = fwdModelConf%i_saturation           !JJ
d656 1
a656 1
      !??? Is cloudIce the correct quantity to use here ???  !JJ need to work out later here
d721 8
a728 6
    if ( icon /= 0 .and. h2o_ind > 0 ) then  !JJ
      if ( grids_f%l_z(h2o_ind) - grids_f%l_z(h2o_ind-1) /= n_t_zeta ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Temperature and H2O grids not the same size' )
      ! modify h2o mixing ratio if a special supersaturation /= 0
      call modify_values_for_supersat ( grids_f, h2o_ind, icon, temp_prof )
d1050 2
a1051 2
    call allocate_test ( beta_path_cloud_c,   npc, 'beta_path__cloud_c', moduleName ) !JJ
    call allocate_test ( beta_path_w0_c, npc, 'beta_path_w0_c',          moduleName ) !JJ
d1066 1
a1066 1
    call allocate_test ( beta_path_phh_c,  npc, NU,     'beta_path_phh_c', moduleName ) !JJ
d1073 3
a1075 3
    if ( fwdModelConf%Incl_Cld ) then !JJ
      call allocate_test ( do_calc_iwc,    no_ele, size(grids_iwc%values),  'do_calc_iwc',  moduleName )
      call allocate_test ( eta_iwc,        no_ele, size(grids_iwc%values),  'eta_iwc',      moduleName )
d1652 1
a1652 1
             IF ( associated(CloudIce) ) then   !JJ
d1659 2
d1680 1
a1680 1
          if ( associated(CloudIce) ) then    !JJ
d1937 1
a1937 2
          
          !JJ
d1939 1
a1939 1
          call deallocate_test ( U, 'U', moduleName   )
d1944 1
a1944 1
          call deallocate_test ( UI, 'UI', moduleName   )
d1979 1
a1979 1
              &   FilterShapes(shapeInd)%FilterGrid,  &
a2101 1

d2110 1
a2110 1

d2313 2
a2314 2
        print "( /'ptan\ ',i3.3)", k
        Print "( 4(3x, f11.7) )", Ptan%values(1:k,maf)
d2316 1
a2316 1
        Print *
d2324 1
a2324 1
        Print *
d2337 1
a2337 1
    call Deallocate_Test ( WC, 'WC', moduleName )        !JJ
d2366 1
a2366 1
    call destroygrids_t ( grids_iwc )          !JJ
d2369 1
a2369 1
    call destroygrids_t ( grids_tscat )        !JJ
d2387 3
a2389 3
    call deallocate_test ( beta_path_cloud_c, 'beta_path_cloud_c', moduleName ) ! JJ
    call deallocate_test ( beta_path_phh_c,  'beta_path_phh_c',  moduleName )   
    call deallocate_test ( beta_path_w0_c,   'beta_path_w0_c',   moduleName )   
d2406 1
a2406 1
    call deallocate_test ( do_calc_iwc,   'do_calc_iwc',   moduleName ) ! JJ
d2410 2
a2411 2
    call deallocate_test ( eta_iwc,       'eta_iwc',       moduleName ) 
    call deallocate_test ( eta_iwc_zp,    'eta_iwc_zp',    moduleName ) 
a2598 3
! Revision 2.126.2.31  2003/04/07 17:13:52  jonathan
! modified cal to T_scat
!
@


2.126.2.33
log
@fix bug
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.32 2003/04/08 21:44:23 jonathan Exp $"
a1654 3
             
!             Need to work out way to interpolate scat_src on to los
!             stop
a2595 3
! Revision 2.126.2.32  2003/04/08 21:44:23  jonathan
! remove if condition for Modify_values_for_supersat
!
@


2.126.2.34
log
@interpolate scat_src%values to LOS
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.33 2003/04/10 16:16:06 jonathan Exp $"
d383 4
a386 4
    type (VectorValue_T), pointer :: PHITAN        ! Tangent geodAngle component of state vector
    type (VectorValue_T), pointer :: PTAN          ! Tangent pressure component of state vector
    type (VectorValue_T), pointer :: REFGPH        ! Reference geopotential height
    type (VectorValue_T), pointer :: SCGEOCALT     ! S/C geocentric altitude /m
d390 1
a390 1
    type (VectorValue_T), pointer :: TEMP          ! Temperature component of state vector
d432 1
a432 2
    type (VectorValue_T), pointer :: scat_src     !JJ
!    real(r8), dimension(:), pointer :: scat_src   ! JJ  
d1638 3
a1648 3
             call allocate_test ( scat_src%values, n_t_zeta, nu, &
               & 'scat_src', moduleName )
 
d1652 1
a1652 1
                 CALL T_scat (n_t_zeta, temp_prof, Frq, scat_src%values, NU, NUA, &
a1653 5

                 scat_src%template = temp%template

                 call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, fwdModelConf, .false. )

d1655 3
d1937 1
a1937 1
          call deallocate_test ( scat_src%values, 'scat_src%values', moduleName )
a2598 3
! Revision 2.126.2.33  2003/04/10 16:16:06  jonathan
! fix bug
!
@


2.126.2.35
log
@FullForwardModel_m.f90 change scat_src as non-pointer
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.34 2003/04/15 14:18:22 jonathan Exp $"
d432 1
a432 1
    type (VectorValue_T) :: scat_src     !JJ
d494 1
a494 1
      & z_glgrid, z_path, z_path_c, scat_src%values, u, du, ua, theta, phi, ui, thetai )
d656 3
a2601 3
! Revision 2.126.2.34  2003/04/15 14:18:22  jonathan
! interpolate scat_src%values to LOS
!
@


2.126.2.36
log
@Correct choice of mag field coordinate indices, futzing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.35 2003/04/15 17:55:19 jonathan Exp $"
a175 1
    logical :: Clean                    ! Used for dumping
d1532 3
a1534 3
          ct => mag_path(1:no_ele,3)   ! cos(theta)
          stcp => mag_path(1:no_ele,1) ! sin(theta) cos(phi)
          stsp => mag_path(1:no_ele,2) ! sin(theta) sin(phi)
d1538 4
a1541 5
            clean = index(switches,'clean') /= 0
            call dump ( h, 'H', clean )
            call dump ( ct, 'Cos(theta)', clean )
            call dump ( stcp, 'Sin(theta) Cos(phi)', clean )
            call dump ( stsp, 'Sin(theta) Sin(phi)', clean )
a2598 3
! Revision 2.126.2.35  2003/04/15 17:55:19  jonathan
! FullForwardModel_m.f90 change scat_src as non-pointer
!
@


2.126.2.37
log
@Move working storage for T_Scat into T_Scat
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.36 2003/04/15 23:45:45 vsnyder Exp $"
d169 1
a169 1
    integer :: NU, NUA, NAB, NR, NC     ! cloud ext parameters
d434 7
d495 1
a495 1
      & z_glgrid, z_path, z_path_c, scat_src%values, thetai )
d610 1
a610 1
    nc  = fwdModelConf%no_cloud_species
d1075 1
a1075 1
      call allocate_test ( wc,         nc, no_ele, 'WC', moduleName )
d1636 18
a1653 7
          if ( associated(CloudIce) ) then   !JJ
            ! Compute Scattering source function based on temp_prof
            call allocate_test ( scat_src%values, n_t_zeta, nu, &
              & 'scat_src', moduleName )
            ! Compute scattering source function at all angles U for each
            ! temperature layer assuming a plane parallel atmosphere.
            call T_scat (temp_prof, Frq, nua, nab, nr, nc, scat_src%values )
d1655 1
a1655 1
            scat_src%template = temp%template
d1657 1
a1657 1
            call load_one_item_grid ( grids_tscat, scat_src, phitan, maf, fwdModelConf, .false. )
d1659 1
a1659 4
            call deallocate_test ( scat_src%values, 'scat_src%values', &
              & moduleName )

          end if
d1687 1
a1687 1
              &  WC(:,1:no_ele), NU, NUA, NAB, NR, NC ) 
d1938 10
a2600 3
! Revision 2.126.2.36  2003/04/15 23:45:45  vsnyder
! Correct choice of mag field coordinate indices, futzing
!
@


2.126.2.38
log
@Move allocate for scat_src%values out of the loops
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.37 2003/04/16 19:32:02 vsnyder Exp $"
d434 1
d481 1
a481 1
      & radiances, RadV, ref_corr, req_out, reqs, scat_src%values, &
d485 2
a486 1
      & tau_pol, t_glgrid, t_path, t_path_c, t_path_f, t_script, &
d488 1
a488 1
      & z_glgrid, z_path, z_path_c )
d597 1
a597 1
    end if
a695 1
    ! Stuff for clouds
a696 3
    if ( associated(cloudIce) ) &
      & call allocate_test ( scat_src%values, n_t_zeta, nu, 'scat_src', &
        &                    moduleName )
d1630 5
a1634 3
            ! Compute Scattering source function based on temp_prof at all
            ! angles U for each temperature layer assuming a plane parallel
            ! atmosphere.
d1641 3
a2398 4
    if ( associated(cloudIce) ) &
      & call deallocate_test ( scat_src%values, 'scat_src%values', &
        &                      moduleName )

a2575 3
! Revision 2.126.2.37  2003/04/16 19:32:02  vsnyder
! Move working storage for T_Scat into T_Scat
!
@


2.126.2.39
log
@Compute MIF correctly
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.38 2003/04/16 20:44:20 vsnyder Exp $"
d135 1
a135 1
    integer :: MIF                      ! MIF number for tan_press(ptg_i)
d1342 1
a1342 3
        if ( FwdModelConf%polarized ) &
          & mif = minloc(abs(tan_press(ptg_i) - &
          &                  ptan%values(:ptan%template%nosurfs,maf)),1)
d1602 1
a1602 1
                       & oneGrid(grids(ptg_i))%frequencies)
d1604 1
a1604 1
                       & oneGrid(grids(ptg_i))%frequencies, k, j, frq_i )
d1606 1
a1606 1
                       & oneGrid(grids(ptg_i))%frequencies, k, frq_i, m )
d1610 1
a1610 1
                      & oneGrid(grids(ptg_i))%frequencies(j:m)
d2271 1
d2287 2
a2288 2
      print "( /'ptan\ ',i3.3)", k
      Print "( 4(3x, f11.7) )", Ptan%values(1:k,maf)
d2290 1
a2290 1
      Print *
d2298 1
a2298 1
      Print *
a2576 3
! Revision 2.126.2.38  2003/04/16 20:44:20  vsnyder
! Move allocate for scat_src%values out of the loops
!
@


2.126.2.40
log
@Check FwdModelConf%incl_cld instead of associated(cloudIce)
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.126.2.39 2003/04/24 19:01:19 vsnyder Exp $"
d644 1
a644 1
    if ( FwdModelConf%incl_cld ) then
d696 1
a696 1
    if ( FwdModelConf%incl_cld ) &
d1633 1
a1633 1
          if ( FwdModelConf%incl_cld ) then   !JJ
d1664 1
a1664 1
          if ( FwdModelConf%incl_cld ) then    !JJ
d1762 1
a1762 1
          ! if ( FwdModelConf%incl_cld ) then
d2397 1
a2397 1
    if ( FwdModelConf%incl_cld ) &
a2577 3
! Revision 2.126.2.39  2003/04/24 19:01:19  vsnyder
! Compute MIF correctly
!
@


2.125
log
@Bug fix in call to rad_tran
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.124 2003/02/07 01:07:41 jonathan Exp $"
d44 1
a44 1
    use Get_Beta_Path_m, only: Get_Beta_Path, Beta_Group_T
d283 1
d402 1
a402 1
    type (Grids_T) :: Grids_iwc  ! All the coordinates for WC
d445 1
a445 1
      & beta_path, beta_path_c, beta_path_f, beta_path_polarized, &
d524 1
d617 1
a617 1

d654 1
a654 1

d669 1
d901 1
d1340 1
d1893 1
d1917 35
a1951 3
          ! The derivatives that get_beta_path computes depend on which
          ! derivative arrays are allocated.  This avoids having four
          ! paths, each with a different set of optional arguments.
d1953 1
d1961 2
a1962 3
            &  dbeta_dn_path_c, dbeta_dv_path_c, ICON,                &
            &  fwdModelConf%Incl_Cld, IPSD(1:no_ele),                 &
            &  WC(:,1:no_ele), NU, NUA, NAB, NR, N )                    
d1977 2
d1991 2
a1992 3
            & dbeta_dn_path_f, dbeta_dv_path_f, ICON,                 &
            & fwdModelConf%Incl_Cld, IPSD(1:no_ele),                  &
            &  WC(:,1:no_ele), NU, NUA, NAB, NR, N )
d2847 3
@


2.124
log
@add in option to compute dry and super-saturation case in load_sps
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.123 2003/02/06 22:04:25 vsnyder Exp $"
d1960 1
a1960 1
          CALL rad_tran ( indices_c(1:npc), gl_inds, Frq,                    &
d2808 3
@


2.123
log
@Add f_moleculesPol, f_moleculeDerivativesPol, delete f_polarized
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.122 2003/02/06 19:15:47 jonathan Exp $"
d423 4
d475 1
a475 1
      & tan_hts, reqs, cloudIce, cloudWater, sizeDistribution )
d891 5
d902 1
a902 1
       &   f_len_dv, Grids_dv )
d906 1
a906 1
       &   ext_ind, Grids_f )
d909 3
d2808 3
@


2.122
log
@ fix a bug
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.121 2003/02/06 19:06:49 jonathan Exp $"
d71 1
d211 10
a220 10
    real(rp) :: DEL_TEMP   ! Temp. step-size in evaluation of Temp. power dep.
    real(rp) :: E_RFLTY                 ! Earth reflectivity at given tan. point
    real(r8) :: FRQ                     ! Frequency
    real(rp) :: NEG_TAN_HT              ! GP Height (in KM.) of tan. press.
                                        ! below surface
    real(rp) :: R,R1,R2                 ! real variables for various uses
    real(rp) :: RAD                     ! Radiance
    real(rp) :: REQ                     ! Equivalent Earth Radius
    real(rp) :: THISRATIO               ! A sideband ratio
    real(rp) :: Vel_Cor                 ! Velocity correction due to Vel_z
d226 2
d259 6
d329 1
d331 1
d459 1
a459 1
      & incoptdepth, indices_c, k_atmos, k_atmos_frq, &
a731 1
    mol_cat_index(:) = 0
d747 2
a748 2
      beta_group(i)%ratio(1:k) = 0.0
      beta_group(i)%cat_index(1:k) = 0
d751 1
a751 1
    if ( all ( fwdModelConf%molecules > 0 ) ) then
d767 2
d869 1
a869 1
        call allocate_test ( my_catalog(j)%lines, count(lineFlag),&
d1447 4
a1450 3
    if ( FwdModelConf%polarized ) then
      allocate ( alpha_path_polarized(3,npc) ,stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1452 2
a1453 2
      allocate ( beta_path_polarized(3,npc,no_mol) ,stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1455 18
d1876 1
a1876 1
          if ( FwdModelConf%polarized ) then
d1879 18
a1896 6
            alpha_path_polarized(1,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized(1,1:npc,:), DIM=2 )
            alpha_path_polarized(2,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized(2,1:npc,:), DIM=2 )
            alpha_path_polarized(3,1:npc) = SUM( sps_path(indices_c,:) * &
              & beta_path_polarized(3,1:npc,:), DIM=2 )
d2753 5
a2757 1
    if ( FwdModelConf%polarized ) then
d2761 9
d2796 3
@


2.121
log
@add eta_iwc, eta_iwc_zp, do_calc_iwc, do_cala_iwc_zp and also not passing through comp_eta_docalc and comp_sps_path_frq if fwdModelConf%Incl_Cld is false
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.120 2003/02/06 05:55:47 livesey Exp $"
d1698 3
d1704 10
d2740 3
@


2.120
log
@Fix to sort of fix Jonathan's cloud ice stuff.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.119 2003/02/06 00:20:08 jonathan Exp $"
d199 1
d206 1
d290 1
d292 1
d438 1
a438 1
      & do_calc_fzp, do_calc_hyd, do_calc_hyd_c, &
d440 1
a440 1
      & do_calc_zp, do_gl, drad_df, &
d442 2
a443 2
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, &
      & eta_zp, eta_zxp_dn, eta_zxp_dn_c, eta_zxp_dn_f, &
a507 1

d1314 1
d1317 1
d1319 1
d1321 1
a1321 1
    call allocate_test ( iwc_path,      no_ele, 1, 'iwc_path',      moduleName )
d1695 20
d1728 5
a1732 6
       ! Compute IWC_PATH
        Frq = 0.0
        call comp_sps_path_frq ( Grids_iwc, firstSignal%lo, thisSideband, &
          & Frq, eta_zp(1:no_ele,:), &
          & do_calc_zp(1:no_ele,:), iwc_path(1:no_ele,:),      &
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d1734 1
a1734 3
        WC(1,1:no_ele)=iwc_path(1:no_ele,1)
        WC(2,1:no_ele)=0._r8   !will change later
        IPSD(1:no_ele)=1000    !will change later
d2619 1
d2621 1
d2623 1
d2625 1
d2727 3
@


2.119
log
@Add in many stuff to deal with clouds CloudIce, iwc_path, etc
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.118 2003/02/03 23:18:43 vsnyder Exp $"
d506 1
a506 1
      & quantityType=l_cloudIce )    
d508 1
a508 1
      & quantityType=l_cloudWater )
d510 1
a510 1
      & quantityType=l_sizeDistribution )
d649 11
a659 5
    grids_iwc%frq_basis = 0.0
    grids_iwc%zet_basis = CloudIce%template%surfs(1:n_t_zeta,1)
    grids_iwc%phi_basis = temp%template%phi(1,windowStart:windowFinish)*Deg2Rad
    grids_iwc%values = reshape(CloudIce%values(:,windowStart:windowFinish),(/k/))

d2700 3
@


2.118
log
@Squash a bug in deallocating beta_path_polarized
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.117 2003/02/03 22:58:17 vsnyder Exp $"
d51 3
a53 1
      & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_REFGPH
d58 1
a58 1
    use ManipulateVectorQuantities, only: FindInstanceWindow
d94 5
d165 3
d309 1
d367 3
d386 1
d451 1
a451 1
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, &
d456 1
a456 1
      & tan_hts, reqs )
d505 14
d598 10
d615 8
d635 9
d647 6
a653 1
    grids_tmp%values = reshape(temp%values(:,windowStart:windowFinish),(/k/))
d1235 3
d1309 1
d1696 11
a1817 2
          ICON = FwdModelConf%i_saturation

d1826 2
a1827 1
            &  fwdModelConf%Incl_Cld )                    
a1846 2
          ICON = FwdModelConf%i_saturation

d1855 2
a1856 1
            & fwdModelConf%Incl_Cld )
d2507 3
d2558 1
d2594 1
d2694 3
@


2.117
log
@Plug a memory leak, delete gl_ndx, some polarized stuff
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.116 2003/02/03 19:00:36 bill Exp $"
d2586 1
a2586 1
      deallocate ( beta_path_polarized(3,no_ele,no_mol) ,stat=ier )
d2615 3
@


2.116
log
@changed interface to rad tran to speed up program
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.115 2003/02/01 02:33:22 vsnyder Exp $"
a175 2
    integer, dimension(:,:), pointer :: GL_NDX ! Packed Index array of GL intervals

a188 2
!    logical, dimension(:,:), pointer :: DO_CALC_FZP_C ! DO_CALC_FZP on coarse grid
!    logical, dimension(:,:), pointer :: DO_CALC_FZP_F ! DO_CALC_FZP on fine grid
a210 1
    real(r8), dimension(:), pointer :: FREQUENCIES ! Frequencies to compute for
a214 1
!    real(rp), dimension(:), pointer :: DHDZ_PATH_F  ! DHDZ_PATH on find grid
d220 3
a228 1
!    real(rp), dimension(:), pointer :: PATH_DSDH_F  ! PATH_DSDH on find grid
d237 1
d272 1
a273 1
    real(rp), dimension(:,:), pointer :: DH_DT_PATH_C ! DH_DT_PATH on coarse grid
a277 2
!    real(rp), dimension(:,:), pointer :: ETA_FZP_C    ! ETA_FZP on coarse grid
!    real(rp), dimension(:,:), pointer :: ETA_FZP_F    ! ETA_FZP on fine grid
a296 1
    real(rp), dimension(:),   pointer :: PTG_ANGLES ! (no_tan_hts)
a298 2
!    real(rp), dimension(:,:), pointer :: SPS_PATH_C ! SPS_PATH on coarse grid
!    real(rp), dimension(:,:), pointer :: SPS_PATH_F ! SPS_PATH on fine grid
d304 3
d409 2
a410 1
    NULLIFY (alpha_path_c, alpha_path_f, beta_path, beta_path_c, beta_path_f, &
d419 1
a419 2
      & do_calc_fzp, &
      & do_calc_hyd, do_calc_hyd_c, &
d428 1
a428 1
      & gl_inds, gl_ndx, grids, h_glgrid, h_path, h_path_c, h_path_f, &
d908 1
a908 1
    call allocate_test ( z_all,temp%template%nosurfs+2, 'z_all', moduleName )
d932 1
a932 1
      f => GetQuantityForForwardModel(fwdmodelin,fwdmodelextra, &
a1210 1
!    call allocate_test ( dhdz_path_f, no_ele, 'dhdz_path_f', moduleName )
a1215 1
!    call allocate_test ( path_dsdh_f, no_ele, 'path_dsdh_f', moduleName )
a1240 2
!    call allocate_test ( do_calc_fzp_c, no_ele, f_len,  'do_calc_fzp_c', moduleName )
!    call allocate_test ( do_calc_fzp_f, no_ele, f_len,  'do_calc_fzp_f', moduleName )
a1242 2
!    call allocate_test ( eta_fzp_c,     no_ele, f_len,  'eta_fzp_c',     moduleName )
!    call allocate_test ( eta_fzp_f,     no_ele, f_len,  'eta_fzp_f',     moduleName )
a1244 2
!    call allocate_test ( sps_path_c,    no_ele, no_mol, 'sps_path_c',    moduleName )
!    call allocate_test ( sps_path_f,    no_ele, no_mol, 'sps_path_f',    moduleName )
d1358 9
a1629 3
!        sps_path_c(1:npc,:) = sps_path(indices_c(1:npc),:)
!        do_calc_fzp_c(1:npc,:) = do_calc_fzp(indices_c(1:npc),:)
!        eta_fzp_c(1:npc,:) = eta_fzp(indices_c(1:npc),:)
d1726 11
a1736 3
!          sps_path_c(1:npc,:) = sps_path(indices_c(1:npc),:)
!          do_calc_fzp_c(1:npc,:) = do_calc_fzp(indices_c(1:npc),:)
!          eta_fzp_c(1:npc,:) = eta_fzp(indices_c(1:npc),:)
d1765 1
a1765 5
          call get_GL_inds ( do_gl(1:npc), gl_inds, gl_ndx, ngl )

!          dhdz_path_f(:ngl) = dhdz_path(gl_inds(:ngl))
!          path_dsdh_f(:ngl) = path_dsdh(gl_inds(:ngl))
!          sps_path_f(:ngl,:) = sps_path(gl_inds(:ngl),:)
a1892 2
          call deallocate_test ( gl_ndx, 'gl_ndx', moduleName )

a2482 1
!    call deallocate_test ( dhdz_path_f, 'dhdz_path_f', moduleName )
a2488 1
!    call deallocate_test ( path_dsdh_f, 'path_dsdh_f', moduleName )
a2512 2
!    call deallocate_test ( do_calc_fzp_c, 'do_calc_fzp_c', moduleName )
!    call deallocate_test ( do_calc_fzp_f, 'do_calc_fzp_f', moduleName )
a2514 2
!    call deallocate_test ( eta_fzp_c,     'eta_fzp_c',     moduleName )
!    call deallocate_test ( eta_fzp_f,     'eta_fzp_f',     moduleName )
a2515 1
!    call deallocate_test ( sps_path_c,    'sps_path_c',    moduleName )
d2585 5
d2615 3
@


2.115
log
@Plug a bunch of memory leaks
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.114 2003/01/31 17:53:39 jonathan Exp $"
d191 2
a192 2
    logical, dimension(:,:), pointer :: DO_CALC_FZP_C ! DO_CALC_FZP on coarse grid
    logical, dimension(:,:), pointer :: DO_CALC_FZP_F ! DO_CALC_FZP on fine grid
d216 2
a217 2
    real(rp), dimension(:), pointer :: ALPHA_PATH_C ! coarse grid Sing.
    real(rp), dimension(:), pointer :: ALPHA_PATH_F ! fine grid Sing.
d220 1
a220 1
    real(rp), dimension(:), pointer :: DHDZ_PATH_F  ! DHDZ_PATH on find grid
d232 1
a232 1
    real(rp), dimension(:), pointer :: PATH_DSDH_F  ! PATH_DSDH on find grid
d281 2
a282 2
    real(rp), dimension(:,:), pointer :: ETA_FZP_C    ! ETA_FZP on coarse grid
    real(rp), dimension(:,:), pointer :: ETA_FZP_F    ! ETA_FZP on fine grid
d305 2
a306 2
    real(rp), dimension(:,:), pointer :: SPS_PATH_C ! SPS_PATH on coarse grid
    real(rp), dimension(:,:), pointer :: SPS_PATH_F ! SPS_PATH on fine grid
a399 1

d414 1
a414 1
    nullify ( alpha_path_c, alpha_path_f, beta_path, beta_path_c, beta_path_f, &
d419 1
a419 1
      & dhdz_glgrid, dhdz_out, dhdz_path, dhdz_path_f, &
d423 1
a423 1
      & do_calc_fzp, do_calc_fzp_c, do_calc_fzp_f, &
d428 1
a428 1
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, eta_fzp_c, eta_fzp_f, &
d437 1
a437 1
      & k_temp_frq, lineFlag, n_path, path_dsdh, path_dsdh_f, &
d441 1
a441 1
      & sps_beta_dbeta_c, sps_beta_dbeta_f, sps_path, sps_path_c, sps_path_f, &
d1216 1
a1216 1
    call allocate_test ( dhdz_path_f, no_ele, 'dhdz_path_f', moduleName )
d1222 1
a1222 1
    call allocate_test ( path_dsdh_f, no_ele, 'path_dsdh_f', moduleName )
d1248 2
a1249 2
    call allocate_test ( do_calc_fzp_c, no_ele, f_len,  'do_calc_fzp_c', moduleName )
    call allocate_test ( do_calc_fzp_f, no_ele, f_len,  'do_calc_fzp_f', moduleName )
d1252 2
a1253 2
    call allocate_test ( eta_fzp_c,     no_ele, f_len,  'eta_fzp_c',     moduleName )
    call allocate_test ( eta_fzp_f,     no_ele, f_len,  'eta_fzp_f',     moduleName )
d1256 2
a1257 2
    call allocate_test ( sps_path_c,    no_ele, no_mol, 'sps_path_c',    moduleName )
    call allocate_test ( sps_path_f,    no_ele, no_mol, 'sps_path_f',    moduleName )
d1634 3
a1636 3
        sps_path_c(1:npc,:) = sps_path(indices_c(1:npc),:)
        do_calc_fzp_c(1:npc,:) = do_calc_fzp(indices_c(1:npc),:)
        eta_fzp_c(1:npc,:) = eta_fzp(indices_c(1:npc),:)
d1641 1
a1641 1
            &  h2o_path=sps_path_c(1:npc, h2o_ind) )
d1733 3
a1735 3
          sps_path_c(1:npc,:) = sps_path(indices_c(1:npc),:)
          do_calc_fzp_c(1:npc,:) = do_calc_fzp(indices_c(1:npc),:)
          eta_fzp_c(1:npc,:) = eta_fzp(indices_c(1:npc),:)
d1753 1
a1753 1
          alpha_path_c(1:npc) = SUM(sps_path_c(1:npc,:) *  &
d1766 3
a1768 3
          dhdz_path_f(:ngl) = dhdz_path(gl_inds(:ngl))
          path_dsdh_f(:ngl) = path_dsdh(gl_inds(:ngl))
          sps_path_f(:ngl,:) = sps_path(gl_inds(:ngl),:)
d1787 1
a1787 1
          alpha_path_f(1:ngl) = SUM(sps_path_f(1:ngl,:) *  &
d1792 5
a1796 5
          call rad_tran ( Frq, spaceRadiance%values(1,1), e_rflty,         &  
            & z_path_c(1:npc), t_path_c(1:npc),                            &  
            & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),          &  
            & incoptdepth(1:npc), alpha_path_f(1:ngl),                     &
            & path_dsdh_f(:ngl), dhdz_path_f(:ngl), t_script(1:npc),       &
d1805 5
a1809 9
            do_calc_fzp_f(:ngl,:) = do_calc_fzp(gl_inds(:ngl),:)
            eta_fzp_f(:ngl,:) = eta_fzp(gl_inds(:ngl),:)
            call drad_tran_df ( z_path_c(1:npc), Grids_f,                 &
              &  beta_path_c(1:npc,:), eta_fzp_c(1:npc,:),                &
              &  sps_path_c(1:npc,:), do_calc_fzp_c(1:npc,:),             &
              &  beta_path_f(:ngl,:), eta_fzp_f(:ngl,:), sps_path_f(:ngl,:),    &
              &  do_calc_fzp_f(:ngl,:), do_gl(1:npc), del_s(1:npc),       &
              &  ref_corr(1:npc), path_dsdh_f(:ngl), dhdz_path_f(:ngl), &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_df, ptg_i, frq_i )
d1822 1
a1822 1
            sps_beta_dbeta_c(:npc) = SUM(sps_path_c(1:npc,:) * &
d1825 1
a1825 1
            sps_beta_dbeta_f(:ngl) = SUM(sps_path_f(1:ngl,:) * &
d1839 2
a1840 2
              & eta_zxp_t_f(:ngl,:), do_calc_t_f(:ngl,:), path_dsdh_f(:ngl),   &
              & dhdz_path_f(:ngl), t_script(1:npc), tau(1:npc), i_stop,        &
d1855 3
a1857 2
              &  sps_path_c(1:npc,:), do_calc_dw_c(1:npc,:),                  &
              &  dbeta_dw_path_f(:ngl,:), eta_zxp_dw_f(:ngl,:), sps_path_f(:ngl,:), &
d1859 1
a1859 1
              &  ref_corr(1:npc), path_dsdh_f(:ngl), dhdz_path_f(:ngl),     &
d1870 3
a1872 2
              &  sps_path_c(1:npc,:), do_calc_dn_c(1:npc,:),                  &
              &  dbeta_dn_path_f(:ngl,:), eta_zxp_dn_f(:ngl,:), sps_path_f(:ngl,:), &
d1874 1
a1874 1
              &  ref_corr(1:npc), path_dsdh_f(:ngl), dhdz_path_f(:ngl),     &
d1885 3
a1887 2
              &  sps_path_c(1:npc,:), do_calc_dv_c(1:npc,:),                  &
              &  dbeta_dv_path_f(:ngl,:), eta_zxp_dv_f(:ngl,:), sps_path_f(:ngl,:), &
d1889 1
a1889 1
              &  ref_corr(1:npc), path_dsdh_f(:ngl), dhdz_path_f(:ngl),     &
d2488 1
a2488 1
    call deallocate_test ( dhdz_path_f, 'dhdz_path_f', moduleName )
d2495 1
a2495 1
    call deallocate_test ( path_dsdh_f, 'path_dsdh_f', moduleName )
d2520 2
a2521 2
    call deallocate_test ( do_calc_fzp_c, 'do_calc_fzp_c', moduleName )
    call deallocate_test ( do_calc_fzp_f, 'do_calc_fzp_f', moduleName )
d2524 2
a2525 2
    call deallocate_test ( eta_fzp_c,     'eta_fzp_c',     moduleName )
    call deallocate_test ( eta_fzp_f,     'eta_fzp_f',     moduleName )
d2527 1
a2527 1
    call deallocate_test ( sps_path_c,    'sps_path_c',    moduleName )
d2622 3
@


2.114
log
@change z_path to z_path_c in passing to get_beta_path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.113 2003/01/31 17:15:49 jonathan Exp $"
d2489 14
a2502 11
    call deallocate_test ( dhdz_path, 'dhdz_path', moduleName )
    call deallocate_test ( h_path,    'h_path',    moduleName )
    call deallocate_test ( h_path_c,  'h_path_c',  moduleName )
    call deallocate_test ( p_path,    'p_path',    moduleName )
    call deallocate_test ( p_path_c,  'p_path_c',  moduleName )
    call deallocate_test ( path_dsdh, 'path_dsdh', moduleName )
    call deallocate_test ( phi_path,  'phi_path',  moduleName )
    call deallocate_test ( t_path,    't_path',    moduleName )
    call deallocate_test ( t_path_c,  't_path_c',  moduleName )
    call deallocate_test ( z_path,    'z_path',    moduleName )
    call deallocate_test ( z_path_c,  'z_path_c',  moduleName )
d2523 1
d2527 1
d2542 1
d2547 1
d2550 1
d2576 1
d2579 1
d2582 1
d2586 1
d2589 1
d2592 1
d2624 3
@


2.113
log
@add Inc_Cld to get_beta_path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.112 2003/01/31 01:53:01 vsnyder Exp $"
d1745 1
a1745 1
            &  p_path(1:no_ele), t_path(1:no_ele), z_path(1:no_ele),  &   
d1779 1
a1779 1
            & p_path(1:no_ele), t_path(1:no_ele), z_path(1:no_ele),   &
d2610 3
@


2.112
log
@Move array temps to arrays explicitly allocated outside the loop
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.109 2003/01/21 18:20:32 vsnyder Exp $"
d1751 2
a1752 1
            &  dbeta_dn_path_c, dbeta_dv_path_c, ICON )                    
d1785 2
a1786 1
            & dbeta_dn_path_f, dbeta_dv_path_f, ICON )
d2610 3
@


2.111
log
@add z_path to get_beta_path
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.110 2003/01/26 04:42:42 livesey Exp $"
d125 1
d182 2
d185 2
d188 2
d191 2
d194 1
d196 2
d217 17
a233 12
    real(rp), dimension(:), pointer :: DEL_S ! Integration lengths along path
    real(rp), dimension(:), pointer :: DHDZ_PATH ! dH/dZ on path
    real(rp), dimension(:), pointer :: DRAD_DF ! dI/dVmr
    real(rp), dimension(:), pointer :: DRAD_DN ! dI/dN
    real(rp), dimension(:), pointer :: DRAD_DT ! dI/dT
    real(rp), dimension(:), pointer :: DRAD_DV ! dI/dV
    real(rp), dimension(:), pointer :: DRAD_DW ! dI/dW
    real(rp), dimension(:), pointer :: H_PATH ! Heights on path
    real(rp), dimension(:), pointer :: INCOPTDEPTH ! Incremental Optical depth
    real(rp), dimension(:), pointer :: N_PATH ! Refractivity on path
    real(rp), dimension(:), pointer :: PATH_DSDH ! dS/dH on path
    real(rp), dimension(:), pointer :: P_GLGRID ! Pressure on glGrid surfs
d237 25
a261 19
    real(rp), dimension(:), pointer :: PHI_BASIS ! phi basis per species
    real(rp), dimension(:), pointer :: PHI_PATH ! Phi's on path
    real(rp), dimension(:), pointer :: P_PATH ! Pressure on path
    real(rp), dimension(:), pointer :: RADV ! Radiances for 1 pointing on
                                            ! Freq_Grid
    real(rp), dimension(:), pointer :: REF_CORR ! Refraction correction
    real(rp), dimension(:), pointer :: REQS      ! Accumulation of REQ
    real(rp), dimension(:), pointer :: TAN_HTS ! Accumulation of ONE_TAN_HT
    real(rp), dimension(:), pointer :: TAN_TEMP ! ***
    real(rp), dimension(:), pointer :: TAN_TEMPS ! Accumulation of ONE_TAN_TEMP
    real(rp), dimension(:), pointer :: TAU ! Optical depth
    real(rp), dimension(:), pointer :: T_PATH ! Temperatures on path
    real(rp), dimension(:), pointer :: T_SCRIPT ! ********
    real(rp), dimension(:), pointer :: Z_BASIS_DN ! zeta basis for dw (n_dn_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DV ! zeta basis for dw (n_dv_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DW ! zeta basis for dw (n_dw_z)
    real(rp), dimension(:), pointer :: Z_BASIS !zeta basis per specie (n_f_zeta)
    real(rp), dimension(:), pointer :: Z_GLGRID ! Zeta on glGrid surfs
    real(rp), dimension(:), pointer :: Z_PATH ! Zeta on path
d263 1
a263 1
    real(rp), dimension(:,:), pointer :: BETA_PATH ! Beta on path
d275 23
a297 11
    real(rp), dimension(:,:), pointer :: DH_DT_PATH ! dH/dT on path
    real(rp), dimension(:,:), pointer :: DHDZ_GLGRID ! dH/dZ on glGrid surfs
    real(rp), dimension(:,:), pointer :: DX_DT       ! (No_tan_hts, nz*np)
    real(rp), dimension(:,:), pointer :: ETA_FZP ! Eta_z x Eta_p * Eta_f
    real(rp), dimension(:,:), pointer :: ETA_ZP  ! Eta_z x Eta_p
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN ! Eta_z x Eta_p for N
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV ! Eta_z x Eta_p for V
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW ! Eta_z x Eta_p for W
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T ! Eta_t_z x Eta_t_p
    real(rp), dimension(:,:), pointer :: H_GLGRID ! H on glGrid surfs
    real(rp), dimension(:,:), pointer :: K_ATMOS_FRQ ! Storage for Atmos deriv.
d303 5
a307 3
    real(rp), dimension(:,:), pointer :: RADIANCES     ! (Nptg,noChans)
    real(rp), dimension(:,:), pointer :: SPS_PATH ! spsices on path
    REAL(rp), DIMENSION(:,:), POINTER :: TAN_DH_DT ! dH/dT at Tangent
d415 1
a415 1
    nullify ( alpha_path_c, beta_path, beta_path_c, beta_path_f, &
d419 9
a427 3
      & ddhidhidtl0, del_s, dh_dt_glgrid, dh_dt_path, dhdz_glgrid, &
      & dhdz_out, dhdz_path, do_calc_dn, do_calc_dv, do_calc_dw, &
      & do_calc_fzp, do_calc_hyd, do_calc_t, do_calc_zp, do_gl, drad_df, &
d429 8
a436 4
      & dxdt_surface, dxdt_tan, est_scgeocalt, eta_fzp, eta_zp, &
      & eta_zxp_dn, eta_zxp_dv, eta_zxp_dw, eta_zxp_t, frequencies, &
      & gl_inds, gl_ndx, grids, h_glgrid, h_path, incoptdepth, &
      & indices_c, k_atmos, k_atmos_frq, k_spect_dn, k_spect_dn_frq, &
d438 5
a442 3
      & k_temp_frq, lineFlag, n_path, path_dsdh, p_glgrid, phi_basis, &
      & phi_basis_dn, phi_basis_dv, phi_basis_dw, phi_path, p_path, &
      & ptg_angles, radiances, RadV, ref_corr, req_out, sps_path, &
d444 3
a446 3
      & tan_phi, tan_press, tan_temp, tau, t_glgrid, t_path, t_script, &
      & usedchannels, usedsignals, z_all, z_basis, z_basis_dn, &
      & z_basis_dv, z_basis_dw, z_glgrid, z_path, z_tmp, tan_temps, &
d561 1
a561 1
      & fwdModelConf%windowUnits, windowStart, windowFinish )
d980 2
a981 2
    call allocate_test ( z_glGrid, maxVert, 'z_glGrid', moduleName )
    call allocate_test ( p_glGrid, maxVert, 'p_glGrid', moduleName )
d983 2
a984 2
    call allocate_test ( h_glgrid, maxVert, no_sv_p_t, 'h_glgrid', moduleName )
    call allocate_test ( t_glgrid, maxVert, no_sv_p_t, 't_glgrid', moduleName )
d1026 3
a1028 3
    call allocate_test ( tan_inds, no_tan_hts, 'tan_inds', moduleName )
    call allocate_test ( tan_press, no_tan_hts, 'tan_press', moduleName )
    call allocate_test ( tan_phi, no_tan_hts, 'tan_phi', moduleName )
d1030 3
a1032 3
    call allocate_test ( tan_hts, no_tan_hts, 'tan_hts', moduleName )
    call allocate_test ( tan_temps, no_tan_hts, 'tan_temps', moduleName )
    call allocate_test ( reqs, no_tan_hts, 'reqs', moduleName )
d1051 1
a1051 1
    call allocate_test ( z_path, k, 'h_path', moduleName )
d1085 1
a1085 1
    call deallocate_test ( z_path, 'h_path', moduleName )
d1216 43
a1258 24
    call allocate_test ( dhdz_path, no_ele, 'dhdz_path', moduleName )
    call allocate_test ( h_path,    no_ele, 'h_path',    moduleName )
    call allocate_test ( p_path,    no_ele, 'p_path',    moduleName )
    call allocate_test ( path_dsdh, no_ele, 'path_dsdh', moduleName )
    call allocate_test ( phi_path,  no_ele, 'phi_path',  moduleName )
    call allocate_test ( t_path,    no_ele, 't_path',    moduleName )
    call allocate_test ( z_path,    no_ele, 'z_path',    moduleName )

    call allocate_test ( alpha_path_c, npc, 'alpha_path_c', moduleName )
    call allocate_test ( incoptdepth,  npc, 'incoptdept',   moduleName )
    call allocate_test ( t_script,     npc, 't_script',     moduleName )
    call allocate_test ( tau,          npc, 'tau',          moduleName )
    call allocate_test ( del_s,        npc, 'del_s',        moduleName )
    call allocate_test ( do_gl,        npc, 'do_gl',        moduleName )
    call allocate_test ( indices_c,    npc, 'indices_c',    moduleName )
    call allocate_test ( n_path,       npc, 'n_path',       moduleName )
    call allocate_test ( ref_corr,     npc, 'ref_corr',     moduleName )

    call allocate_test ( beta_path_c, npc, no_mol, 'beta_path_c', moduleName )
    call allocate_test ( do_calc_fzp, no_ele, f_len, 'do_calc_fzp', moduleName )
    call allocate_test ( do_calc_zp, no_ele, p_len, 'do_calc_zp', moduleName )
    call allocate_test ( eta_zp, no_ele, p_len, 'eta_zp', moduleName )
    call allocate_test ( eta_fzp, no_ele, f_len, 'eta_fzp', moduleName )
    call allocate_test ( sps_path, no_ele, no_mol, 'sps_path', moduleName )
d1269 3
a1271 1
      call allocate_test ( dbeta_dt_path_c, npc, no_mol, 'dbeta_dt_path_c', &
d1275 4
d1281 2
d1285 4
d1291 4
d1311 1
a1311 1
      call allocate_test ( dbeta_dw_path_c, npc, no_mol, &
d1313 3
a1315 1
      call allocate_test ( dbeta_dn_path_c, npc, no_mol, &
d1317 3
a1319 1
      call allocate_test ( dbeta_dv_path_c, npc, no_mol, &
d1321 2
d1330 4
d1336 4
d1342 4
d1349 4
d1355 4
d1361 4
d1510 2
d1539 7
d1554 4
a1557 1
          end if
d1578 8
a1585 1
          else
d1592 4
a1595 1
          end if
d1606 2
d1611 2
d1616 2
d1628 1
a1628 1
       ! to compute sps_path for all those witn no frequency component
d1632 1
a1632 1
          & Frq,eta_zp(1:no_ele,:), &
d1635 3
d1640 3
a1642 3
          call refractive_index ( p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)), n_path(1:npc),     &
            &  h2o_path=sps_path((indices_c(1:npc)), h2o_ind) )
d1644 2
a1645 2
          call refractive_index ( p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)), n_path(1:npc) )
d1655 1
a1655 1
             & one_tan_ht(1), tan_phi(ptg_i),Req, 0.0_rp,                 &
d1659 1
a1659 1
        n_path(1:npc) = min ( n_path(1:npc), MaxRefraction )
d1661 1
a1661 1
        call comp_refcor ( Req+h_path(indices_c(1:npc)), 1.0_rp+n_path(1:npc), &
d1666 1
a1666 1
        path_dsdh(2:brkpt-1) = path_ds_dh(Req+h_path(2:brkpt-1), &
d1668 1
a1668 1
        path_dsdh(brkpt+2:no_ele-1)=path_ds_dh(Req+h_path(brkpt+2:no_ele-1), &
d1731 1
a1731 1
            & Frq,eta_zp(1:no_ele,:), &
d1734 3
d1744 7
a1750 6
          call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), & 
            &  z_path(1:no_ele), my_Catalog, beta_group, gl_slabs,      &
            &  indices_c(1:npc), beta_path_c(1:npc,:),                  &   
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,                   &   
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,                   &   
            &  dbeta_dt_path_c, dbeta_dw_path_c,                        &   
d1753 2
a1754 2
          alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                  & beta_path_c(1:npc,:),DIM=2)
d1764 1
a1764 11
          call get_GL_inds ( do_gl(1:npc), gl_inds, gl_ndx )

          j = size(gl_inds)

          ! ALLOCATE GL grid beta and GL derivative grids

          call allocate_test ( beta_path_f, j, no_mol, 'beta_path_f', &
                             & moduleName )

          if ( temp_der ) call allocate_test ( dbeta_dt_path_f, j, no_mol, &
              & 'dbeta_dt_path_f', moduleName )
d1766 3
a1768 8
          if ( spect_der ) then
            call allocate_test ( dbeta_dw_path_f, j, no_mol, &
              & 'dbeta_dw_path_f', moduleName )
            call allocate_test ( dbeta_dn_path_f, j, no_mol, &
              & 'dbeta_dn_path_f', moduleName )
            call allocate_test ( dbeta_dv_path_f, j, no_mol, &
              & 'dbeta_dv_path_f', moduleName )
          end if
d1777 7
a1783 6
          call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), &
            & z_path(1:no_ele),my_Catalog, beta_group, gl_slabs,        &
            & gl_inds, beta_path_f,   &
            & gl_slabs_m, t_path(1:no_ele)-del_temp,                    &
            & gl_slabs_p, t_path(1:no_ele)+del_temp,                    &
            & dbeta_dt_path_f, dbeta_dw_path_f,                         &
d1786 3
d1791 5
a1795 5
          call rad_tran ( Frq, spaceRadiance%values(1,1), e_rflty,           &
            & z_path(indices_c(1:npc)), t_path(indices_c(1:npc)),            &
            & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),            &
            & incoptdepth(1:npc), SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
            & path_dsdh(gl_inds), dhdz_path(gl_inds), t_script(1:npc),       &
d1804 8
a1811 6
            call drad_tran_df ( z_path(indices_c(1:npc)), Grids_f,             &
              &  beta_path_c(1:npc,:), eta_fzp(indices_c(1:npc),:),            &
              &  sps_path(indices_c(1:npc),:), do_calc_fzp(indices_c(1:npc),:),&
              &  beta_path_f, eta_fzp(gl_inds,:), sps_path(gl_inds,:),    &
              &  do_calc_fzp(gl_inds,:), do_gl(1:npc), del_s(1:npc),      &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds), &
d1820 18
a1837 7
            call drad_tran_dt ( z_path(indices_c(1:npc)),                      &
              & Req+h_path(indices_c(1:npc)),                                  &
              & t_path(indices_c(1:npc)), dh_dt_path(indices_c(1:npc),:),      &
              & alpha_path_c(1:npc), SUM(sps_path(indices_c(1:npc),:) *        &
              & dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),        &
              & eta_zxp_t(indices_c(1:npc),:), do_calc_t(indices_c(1:npc),:),  &
              & do_calc_hyd(indices_c(1:npc),:), del_s(1:npc), ref_corr(1:npc),&
d1839 5
a1843 5
              & req + h_path(gl_inds), t_path(gl_inds), dh_dt_path(gl_inds,:), &
              & SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),                    &
              & SUM(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),    &
              & eta_zxp_t(gl_inds,:), do_calc_t(gl_inds,:), path_dsdh(gl_inds),&
              & dhdz_path(gl_inds), t_script(1:npc), tau(1:npc), i_stop,       &
d1854 8
a1861 6
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dw,           &
              &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dw(indices_c(1:npc),:),&
              &  dbeta_dw_path_f, eta_zxp_dw(gl_inds,:), sps_path(gl_inds,:), &
              &  do_calc_dw(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
d1868 8
a1875 6
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dn,           &
              &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dn(indices_c(1:npc),:),&
              &  dbeta_dn_path_f, eta_zxp_dn(gl_inds,:), sps_path(gl_inds,:), &
              &  do_calc_dn(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
d1882 8
a1889 6
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dv,           &
              &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dv(indices_c(1:npc),:),&
              &  dbeta_dv_path_f, eta_zxp_dv(gl_inds,:), sps_path(gl_inds,:), &
              &  do_calc_dv(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
a1895 2
          call deallocate_test ( gl_inds, 'gl_inds', moduleName )
          call deallocate_test ( beta_path_f, 'beta_path_f', moduleName )
a1897 10
          if ( temp_der ) &
            & call deallocate_test ( dbeta_dt_path_f, 'dbeta_dt_path_f', &
            & moduleName )

          if ( spect_der ) then
            call deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f',moduleName )
            call deallocate_test ( dbeta_dn_path_f, 'dbeta_dn_path_f',moduleName )
            call deallocate_test ( dbeta_dv_path_f, 'dbeta_dv_path_f',moduleName )
          end if

d1999 1
a1999 1
                  & fwdModelConf%signals(sigInd), &
d2004 2
a2005 2
                      call Freq_Avg ( frequencies, &
                        & FilterShapes(shapeInd)%FilterGrid, &
d2053 1
a2053 1
                    & fwdModelConf%signals(sigInd), &
d2059 1
a2059 1
                        call Freq_Avg ( frequencies, &
d2097 1
a2097 1
                    & fwdModelConf%signals(sigInd), &
d2103 1
a2103 1
                        call Freq_Avg ( frequencies, &
d2141 1
a2141 1
                    & fwdModelConf%signals(sigInd), &
d2147 1
a2147 1
                        call Freq_Avg ( frequencies, &
d2200 1
a2200 1
        if ( ptg_angles(ptg_i) < ptg_angles(ptg_i-1) ) &
d2489 1
d2491 1
d2495 1
d2497 1
d2499 24
a2522 16
    call deallocate_test ( alpha_path_c, 'alpha_path_c', moduleName )
    call deallocate_test ( incoptdepth,  'incoptdept',   moduleName )
    call deallocate_test ( t_script,     't_script',     moduleName )
    call deallocate_test ( tau,          'tau',          moduleName )
    call deallocate_test ( del_s,        'del_s',        moduleName )
    call deallocate_test ( do_gl,        'do_gl',        moduleName )
    call deallocate_test ( indices_c,   'indices_c',   moduleName )
    call deallocate_test ( n_path,       'n_path',       moduleName )
    call deallocate_test ( ref_corr,     'ref_corr',     moduleName )

    call deallocate_test ( beta_path_c, 'beta_path_c', moduleName )
    call deallocate_test ( do_calc_zp, 'do_calc_zp', moduleName )
    call deallocate_test ( do_calc_fzp, 'do_calc_fzp', moduleName )
    call deallocate_test ( eta_zp, 'eta_zp', moduleName )
    call deallocate_test ( eta_fzp, 'eta_fzp', moduleName )
    call deallocate_test ( sps_path, 'sps_path', moduleName )
d2530 1
a2530 1
      call deallocate_test ( dRad_dt, 'dRad_dt', moduleName )
d2532 14
a2545 9
      call deallocate_test ( dh_dt_path, 'dh_dt_path', moduleName )
      call deallocate_test ( do_calc_hyd, 'do_calc_hyd', moduleName )
      call deallocate_test ( do_calc_t, 'do_calc_t', moduleName )
      call deallocate_test ( eta_zxp_t, 'eta_zxp_t', moduleName )
      call deallocate_test ( tan_dh_dt, 'tan_dh_dt', moduleName )
      call deallocate_test ( tan_d2h_dhdt, 'tan_d2h_dhdt', moduleName )
      call deallocate_test ( dxdt_tan, 'dxdt_tan',moduleName )
      call deallocate_test ( d2xdxdt_tan, 'd2xdxdt_tan',moduleName )
      call deallocate_test ( dxdt_surface, 'dxdt_surface',moduleName )
d2558 1
d2560 1
d2562 1
d2564 13
a2576 7
      call deallocate_test ( do_calc_dw, 'do_calc_dw', moduleName )
      call deallocate_test ( do_calc_dn, 'do_calc_dn', moduleName )
      call deallocate_test ( do_calc_dv, 'do_calc_dv', moduleName )

      call deallocate_test ( eta_zxp_dw, 'eta_zxp_dw', moduleName )
      call deallocate_test ( eta_zxp_dn, 'eta_zxp_dn', moduleName )
      call deallocate_test ( eta_zxp_dv, 'eta_zxp_dv', moduleName )
d2589 3
d2608 3
@


2.110
log
@Added profiles/angle options for phiWindow
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.109 2003/01/21 18:20:32 vsnyder Exp $"
d1596 3
a1598 3
          call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), &   
            &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),      &   
            &  beta_path_c(1:npc,:),                                    &   
d1644 2
a1645 1
            & my_Catalog, beta_group, gl_slabs, gl_inds, beta_path_f,   &
d2434 3
@


2.109
log
@Put dimensions back onto actual arguments to path_contrib
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.108 2003/01/18 03:36:09 vsnyder Exp $"
d512 1
a512 1
                            & windowStart, windowFinish )
d2433 3
@


2.108
log
@Undo ill-advised cosmetic changes -- that weren't cosmetic
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.106 2003/01/16 23:13:03 livesey Exp $"
d1612 2
a1613 1
          call path_contrib ( incoptdepth, e_rflty, fwdModelConf%tolerance, do_gl )
d1615 1
a1615 1
          call get_GL_inds ( do_gl, gl_inds, gl_ndx )
d2433 3
@


2.107
log
@Use separated Get_GL_Inds in revised path_contrib.  Cosmetics.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.104 2003/01/14 21:48:58 jonathan Exp $"
d70 1
a70 1
    use Path_Contrib_M, only: Path_Contrib, Get_GL_Inds
d951 1
a951 1
      & spread((/-1.0_rp,Gx/),2,NLm1), (/maxVert-1/))
d1131 1
a1131 1
    allocate ( gl_slabs ( no_ele, noSpecies ), stat=ier )
d1144 2
a1145 2
      allocate ( gl_slabs_p ( no_ele, noSpecies ), &
        &        gl_slabs_m ( no_ele, noSpecies ), STAT=ier )
d1388 2
a1389 1
        indices_c = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)
d1392 4
a1395 4
        z_path = (/(z_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                 & (z_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
        p_path = (/(p_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                 & (p_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
d1412 2
a1413 2
              &  h_path, phi_path,                                           &
              &  t_path, dhdz_path, Req,                                     &
d1418 1
a1418 1
              &  DHITDTLM = dh_dt_path,                                      &
d1420 3
a1422 3
              &  ETA_ZXP=eta_zxp_t,                                          &
              &  DO_CALC_T = do_calc_t,                                      &
              &  DO_CALC_HYD = do_calc_hyd )
d1427 2
a1428 2
              &  dummy, h_path, phi_path,                                    &
              &  t_path, dhdz_path, Req,                                     &
d1442 2
a1443 2
              &  h_path, phi_path,                                           &
              &  t_path, dhdz_path, Req,                                     &
d1447 1
a1447 1
              &  DHITDTLM = dh_dt_path,                                      &
d1449 3
a1451 3
              &  ETA_ZXP = eta_zxp_t,                                        &
              &  DO_CALC_T = do_calc_t,                                      &
              &  DO_CALC_HYD = do_calc_hyd )
d1456 2
a1457 2
              &  dummy, h_path, phi_path,                                    &
              &  t_path, dhdz_path, Req,                                     &
d1468 2
a1469 1
            & z_path, phi_path, do_calc_dw, eta_zxp_dw )
d1471 2
a1472 1
            & z_path, phi_path, do_calc_dn, eta_zxp_dn )
d1474 2
a1475 1
            & z_path, phi_path, do_calc_dv, eta_zxp_dv )
d1481 2
a1482 2
        call comp_eta_docalc_no_frq ( Grids_f, z_path, &
          &  phi_path, do_calc_zp, eta_zp )
d1490 3
a1492 1
          & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp )
d1495 3
a1497 3
          call refractive_index ( p_path(indices_c), &
            &  t_path(indices_c), n_path,            &
            &  h2o_path=sps_path((indices_c), h2o_ind) )
d1499 2
a1500 2
          call refractive_index ( p_path(indices_c), &
            &  t_path(indices_c), n_path )
d1514 4
a1517 3
        n_path = min ( n_path, MaxRefraction )
        call comp_refcor ( Req+h_path(indices_c), 1.0_rp+n_path,          &
                      &  Req+one_tan_ht(1), del_s, ref_corr )
d1530 2
a1531 2
        call get_gl_slabs_arrays ( my_Catalog, p_path,           &
          &  t_path, 0.001*losVel%values(1,maf), gl_slabs,       &
d1536 2
a1537 2
          call get_gl_slabs_arrays ( my_Catalog, p_path,           &
            &  t_path, 0.001*losVel%values(1,maf), gl_slabs_p,     &
d1539 2
a1540 2
          call get_gl_slabs_arrays ( my_Catalog, p_path,           &
            &  t_path, 0.001*losVel%values(1,maf), gl_slabs_m,     &
d1564 1
d1586 3
a1588 1
            & Frq, eta_zp, do_calc_zp, sps_path, do_calc_fzp, eta_fzp )
d1596 6
a1601 6
          call get_beta_path ( Frq, p_path, t_path,            &            
            &  my_Catalog, beta_group, gl_slabs, indices_c,    &            
            &  beta_path_c,                                    &            
            &  gl_slabs_m, t_path-del_temp,                    &         
            &  gl_slabs_p, t_path+del_temp,                    &         
            &  dbeta_dt_path_c, dbeta_dw_path_c,               &            
d1604 2
a1605 2
          alpha_path_c = SUM(sps_path(indices_c,:) *  &
                           & beta_path_c,DIM=2)
d1607 1
a1607 1
          incoptdepth = alpha_path_c * del_s
d1618 1
a1618 1
          ! Allocate GL grid beta and GL derivative grids
d1642 1
a1642 1
          call get_beta_path ( Frq, p_path, t_path,                     &
d1644 2
a1645 2
            & gl_slabs_m, t_path-del_temp,                              &
            & gl_slabs_p, t_path+del_temp,                              &
d1651 6
a1656 6
          call rad_tran ( Frq, spaceRadiance%values(1,1), e_rflty,      &     
            & z_path(indices_c), t_path(indices_c),                     &     
            & alpha_path_c, ref_corr, do_gl,                            & 
            & incoptdepth, SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),  & 
            & path_dsdh(gl_inds), dhdz_path(gl_inds), t_script,         &     
            & tau, Rad, i_stop )
d1664 3
a1666 3
            call drad_tran_df ( z_path(indices_c), Grids_f,               &
              &  beta_path_c, eta_fzp(indices_c,:),                       &
              &  sps_path(indices_c,:), do_calc_fzp(indices_c,:),         &
d1668 3
a1670 3
              &  do_calc_fzp(gl_inds,:), do_gl, del_s,                    &
              &  ref_corr, path_dsdh(gl_inds), dhdz_path(gl_inds),        &
              &  t_script, tau, i_stop, drad_df, ptg_i, frq_i )
d1672 1
a1672 1
            k_atmos_frq(frq_i,:) = drad_df
d1678 8
a1685 8
            call drad_tran_dt ( z_path(indices_c),                             &
              & Req+h_path(indices_c),                                         &
              & t_path(indices_c), dh_dt_path(indices_c,:),                    &
              & alpha_path_c,                                                  &
              & SUM(sps_path(indices_c,:) * dbeta_dt_path_c * beta_path_c, DIM=2),                          &
              & eta_zxp_t(indices_c,:), do_calc_t(indices_c,:),                &
              & do_calc_hyd(indices_c,:), del_s, ref_corr,                     &
              & Req + one_tan_ht(1), dh_dt_path(brkpt,:), frq, do_gl,          &
d1690 1
a1690 1
              & dhdz_path(gl_inds), t_script, tau, i_stop,              &
d1701 3
a1703 3
            call drad_tran_dx ( z_path(indices_c), Grids_dw,                  &
              &  dbeta_dw_path_c, eta_zxp_dw(indices_c,:),                    &
              &  sps_path(indices_c,:), do_calc_dw(indices_c,:),              &
d1705 3
a1707 3
              &  do_calc_dw(gl_inds,:), do_gl, del_s,                         &
              &  ref_corr, path_dsdh(gl_inds), dhdz_path(gl_inds),            &
              &  t_script, tau, i_stop, drad_dw, ptg_i, frq_i )
d1713 3
a1715 3
            call drad_tran_dx ( z_path(indices_c), Grids_dn,                  &
              &  dbeta_dn_path_c, eta_zxp_dn(indices_c,:),                    &
              &  sps_path(indices_c,:), do_calc_dn(indices_c,:),              &
d1717 3
a1719 3
              &  do_calc_dn(gl_inds,:), do_gl, del_s,                         &
              &  ref_corr, path_dsdh(gl_inds), dhdz_path(gl_inds),            &
              &  t_script, tau, i_stop, drad_dn, ptg_i, frq_i )
d1725 3
a1727 3
            call drad_tran_dx ( z_path(indices_c), Grids_dv,                  &
              &  dbeta_dv_path_c, eta_zxp_dv(indices_c,:),                    &
              &  sps_path(indices_c,:), do_calc_dv(indices_c,:),              &
d1729 3
a1731 3
              &  do_calc_dv(gl_inds,:), do_gl, del_s,                         &
              &  ref_corr, path_dsdh(gl_inds), dhdz_path(gl_inds),            &
              &  t_script, tau, i_stop, drad_dv, ptg_i, frq_i )
d1788 1
a1788 1
          Radiances(ptg_i,1:noUsedChannels) = RadV
d2432 6
@


2.106
log
@Added MaxRefraction stuff
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.105 2003/01/16 18:04:01 jonathan Exp $"
d70 1
a70 1
    use Path_Contrib_M, only: Path_Contrib
d951 1
a951 1
      & spread((/-1.0_rp,Gx(1:Ng)/),2,NLm1), (/maxVert-1/))
d1006 3
a1008 3
    z_path(1:k) = ptan%values(1:k,maf)
    p_path(1:k) = phitan%values(1:k,maf)
    t_path(1:k) = scgeocalt%values(1:k,maf)
d1034 1
a1034 1
    tan_phi(1:no_tan_hts) = tan_phi(1:no_tan_hts) * deg2rad
d1131 1
a1131 1
    allocate ( gl_slabs ( no_ele, noSpecies), stat=ier )
d1137 1
a1137 1
      gl_slabs(1:no_ele,i)%no_lines = nl
d1144 2
a1145 2
      allocate ( gl_slabs_p(no_ele,noSpecies), &
        &        gl_slabs_m(no_ele,noSpecies), STAT=ier )
d1151 2
a1152 2
        gl_slabs_m(1:no_ele,i)%no_lines = nl
        gl_slabs_p(1:no_ele,i)%no_lines = nl
d1201 1
a1201 1
      call allocate_test ( dbeta_dt_path_c,npc,no_mol, 'dbeta_dt_path_c', &
d1388 1
a1388 2
        indices_c(1:npc) = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)
        indices_c(npc+1:) = 0
d1391 4
a1394 4
        z_path(1:no_ele) = (/(z_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                           & (z_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
        p_path(1:no_ele) = (/(p_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
                           & (p_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
d1411 2
a1412 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1417 1
a1417 1
              &  DHITDTLM = dh_dt_path(1:no_ele,:),                          &
d1419 3
a1421 3
              &  ETA_ZXP=eta_zxp_t(1:no_ele,:),                              &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:) )
d1426 2
a1427 2
              &  dummy, h_path(1:no_ele), phi_path(1:no_ele),                &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1441 2
a1442 2
              &  h_path(1:no_ele), phi_path(1:no_ele),                       &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1446 1
a1446 1
              &  DHITDTLM = dh_dt_path(1:no_ele,:),                          &
d1448 3
a1450 3
              &  ETA_ZXP = eta_zxp_t(1:no_ele,:),                            &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:) )
d1455 2
a1456 2
              &  dummy, h_path(1:no_ele), phi_path(1:no_ele),                &
              &  t_path(1:no_ele), dhdz_path(1:no_ele), Req,                 &
d1467 1
a1467 2
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dw(1:no_ele,:), eta_zxp_dw(1:no_ele,:) )
d1469 1
a1469 2
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dn(1:no_ele,:), eta_zxp_dn(1:no_ele,:) )
d1471 1
a1471 2
            & z_path(1:no_ele), phi_path(1:no_ele), &
            & do_calc_dv(1:no_ele,:), eta_zxp_dv(1:no_ele,:) )
d1477 2
a1478 2
        call comp_eta_docalc_no_frq ( Grids_f,z_path(1:no_ele), &
          &  phi_path(1:no_ele), do_calc_zp(1:no_ele,:), eta_zp(1:no_ele,:) )
d1486 1
a1486 3
          & Frq,eta_zp(1:no_ele,:), &
          & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
          & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d1489 3
a1491 3
          call refractive_index ( p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)), n_path(1:npc),     &
            &  h2o_path=sps_path((indices_c(1:npc)), h2o_ind) )
d1493 2
a1494 2
          call refractive_index ( p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)), n_path(1:npc) )
d1508 3
a1510 4
        n_path(1:npc) = min ( n_path(1:npc), MaxRefraction )

        call comp_refcor ( Req+h_path(indices_c(1:npc)), 1.0_rp+n_path(1:npc), &
                      &  Req+one_tan_ht(1), del_s(1:npc), ref_corr(1:npc) )
d1523 2
a1524 2
        call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
          &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs, &
d1529 2
a1530 2
          call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
            &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_p, &
d1532 2
a1533 2
          call get_gl_slabs_arrays ( my_Catalog, p_path(1:no_ele), &
            &  t_path(1:no_ele), 0.001*losVel%values(1,maf), gl_slabs_m, &
d1552 3
a1554 5
          call allocate_test ( frequencies,noFreqs, "frequencies", moduleName )
          frequencies(1:noFreqs) = PointingGrids(whichPointingGrid)%&
                                   &oneGrid(grids(ptg_i))%frequencies(j:m)

! VELOCITY shift correction to frequency grid
d1556 1
d1578 1
a1578 3
            & Frq,eta_zp(1:no_ele,:), &
            & do_calc_zp(1:no_ele,:), sps_path(1:no_ele,:),      &
            & do_calc_fzp(1:no_ele,:), eta_fzp(1:no_ele,:) )
d1586 6
a1591 6
          call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), &   
            &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),      &   
            &  beta_path_c(1:npc,:),                                    &   
            &  gl_slabs_m, t_path(1:no_ele)-del_temp,                   &   
            &  gl_slabs_p, t_path(1:no_ele)+del_temp,                   &   
            &  dbeta_dt_path_c, dbeta_dw_path_c,                        &   
d1594 2
a1595 2
          alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                  & beta_path_c(1:npc,:),DIM=2)
d1597 1
a1597 1
          incoptdepth(1:npc) = alpha_path_c(1:npc) * del_s(1:npc)
d1601 4
a1604 2
          call path_contrib ( incoptdepth(1:npc), e_rflty,   &
                  & fwdModelConf%tolerance, do_gl(1:npc), gl_inds, gl_ndx )
d1608 1
a1608 1
          ! ALLOCATE GL grid beta and GL derivative grids
d1632 1
a1632 1
          call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), &
d1634 2
a1635 2
            & gl_slabs_m, t_path(1:no_ele)-del_temp,                    &
            & gl_slabs_p, t_path(1:no_ele)+del_temp,                    &
d1641 6
a1646 6
          call rad_tran ( Frq, spaceRadiance%values(1,1), e_rflty,           &
            & z_path(indices_c(1:npc)), t_path(indices_c(1:npc)),            &
            & alpha_path_c(1:npc), ref_corr(1:npc), do_gl(1:npc),            &
            & incoptdepth(1:npc), SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
            & path_dsdh(gl_inds), dhdz_path(gl_inds), t_script(1:npc),       &
            & tau(1:npc),Rad,i_stop )
d1654 3
a1656 3
            call drad_tran_df ( z_path(indices_c(1:npc)), Grids_f,             &
              &  beta_path_c(1:npc,:), eta_fzp(indices_c(1:npc),:),            &
              &  sps_path(indices_c(1:npc),:), do_calc_fzp(indices_c(1:npc),:),&
d1658 3
a1660 3
              &  do_calc_fzp(gl_inds,:), do_gl(1:npc), del_s(1:npc),      &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds), &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_df, ptg_i, frq_i )
d1662 1
a1662 1
            k_atmos_frq(frq_i,1:f_len) = drad_df(1:f_len)
d1668 8
a1675 8
            call drad_tran_dt ( z_path(indices_c(1:npc)),                      &
              & Req+h_path(indices_c(1:npc)),                                  &
              & t_path(indices_c(1:npc)), dh_dt_path(indices_c(1:npc),:),      &
              & alpha_path_c(1:npc), SUM(sps_path(indices_c(1:npc),:) *        &
              & dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),        &
              & eta_zxp_t(indices_c(1:npc),:), do_calc_t(indices_c(1:npc),:),  &
              & do_calc_hyd(indices_c(1:npc),:), del_s(1:npc), ref_corr(1:npc),&
              & Req + one_tan_ht(1), dh_dt_path(brkpt,:), frq, do_gl(1:npc),   &
d1680 1
a1680 1
              & dhdz_path(gl_inds), t_script(1:npc), tau(1:npc), i_stop,       &
d1691 3
a1693 3
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dw,           &
              &  dbeta_dw_path_c(1:npc,:), eta_zxp_dw(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dw(indices_c(1:npc),:),&
d1695 3
a1697 3
              &  do_calc_dw(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dw, ptg_i, frq_i )
d1703 3
a1705 3
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dn,           &
              &  dbeta_dn_path_c(1:npc,:), eta_zxp_dn(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dn(indices_c(1:npc),:),&
d1707 3
a1709 3
              &  do_calc_dn(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dn, ptg_i, frq_i )
d1715 3
a1717 3
            call drad_tran_dx ( z_path(indices_c(1:npc)), Grids_dv,           &
              &  dbeta_dv_path_c(1:npc,:), eta_zxp_dv(indices_c(1:npc),:),    &
              &  sps_path(indices_c(1:npc),:), do_calc_dv(indices_c(1:npc),:),&
d1719 3
a1721 3
              &  do_calc_dv(gl_inds,:), do_gl(1:npc), del_s(1:npc),           &
              &  ref_corr(1:npc), path_dsdh(gl_inds), dhdz_path(gl_inds),     &
              &  t_script(1:npc), tau(1:npc), i_stop, drad_dv, ptg_i, frq_i )
d1778 1
a1778 1
          Radiances(ptg_i,1:noUsedChannels) = RadV(1:)
a2421 3
! Revision 2.105  2003/01/16 18:04:01  jonathan
! add Do_1D option to get_gl_slabs_arrays
!
@


2.105
log
@add Do_1D option to get_gl_slabs_arrays
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.104 2003/01/14 21:48:58 jonathan Exp $"
d43 1
a43 1
    use Geometry, only: EarthRadA, EarthRadB
d1514 2
d2042 14
d2430 3
@


2.104
log
@add i_saturation
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.103 2003/01/10 21:55:26 vsnyder Exp $"
d1530 1
a1530 1
          &  no_ele, del_temp )
d1536 1
a1536 1
            &  no_ele, del_temp )
d1539 1
a1539 1
            &  no_ele, -del_temp )
d2414 3
@


2.103
log
@Move SpeedOfLight from Geometry ot Units
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.102 2003/01/08 00:16:39 vsnyder Exp $"
d156 1
d1592 2
d1600 1
a1600 1
            &  dbeta_dn_path_c, dbeta_dv_path_c )                    
d1636 2
d1643 1
a1643 1
            & dbeta_dn_path_f, dbeta_dv_path_f )
d2414 3
@


2.102
log
@Use "associated" instead of "present" to control optional computations.
Cosmetic changes, too.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.101 2002/12/12 01:12:47 vsnyder Exp $"
d43 1
a43 1
    use Geometry, only: EarthRadA, EarthRadB, SpeedOfLight
d80 1
a80 1
    use Units, only: Deg2Rad
d2409 4
@


2.101
log
@Let InvalidQuantity have a length > 1
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.100 2002/11/15 01:33:08 livesey Exp $"
d28 1
a28 1
    use Allocate_Deallocate, only: ALLOCATE_TEST, deallocate_test
d70 1
d72 1
a72 2
    use RAD_TRAN_M, only: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, &
                         &  DRAD_TRAN_DX
d103 5
a108 2
    integer :: F_LEN                    ! Total number of f's
    integer :: P_LEN                    ! Partial number of f's (No freq.)
a109 1
    integer :: EXT_IND                  ! Index of extinction inside f array
d111 2
d114 1
a114 2
    integer :: INSTANCE                 ! Loop counter
    integer :: I                        ! Loop index and other uses .
a117 2
    integer :: M                        ! Loop index and other uses ..
    integer :: JF                       ! Loop index and other uses ..
a118 1
    integer :: MAXNOPTGFREQS            ! Used for sizing arrays
d121 1
d124 2
a126 1
    integer :: NLM1                     ! Nlvl - 1
d128 1
d130 1
d132 1
a132 1
    integer :: NO_MOL                   ! Number of major molecules (NO iso/vib)
a133 3
    integer :: NO_ELE                   ! Length of a gl path
    integer :: NO_GL_NDX                ! Number of GL points to do
    integer :: NO_TAN_HTS               ! Number of tangent heights
d136 1
d143 1
d145 1
d148 3
d152 1
a155 9
    integer :: SPECIE                   ! Loop counter
    integer :: SV_I                     ! Loop index and other uses .
    integer :: F_LEN_DW                 ! Length of DW in vector
    integer :: F_LEN_DN                 ! Length of DN in vector
    integer :: F_LEN_DV                 ! Length of DV in vector
    integer :: SV_START                 ! Temporary sv_i
    integer :: SV_T_LEN                 ! Number of t_phi*t_zeta in the window
    integer :: SURFACE                  ! Loop counter
    integer :: WHICHPATTERN             ! Index of antenna pattern
d165 2
d168 3
a170 1
    integer, dimension(:), pointer :: CHANNELORIGINS ! Does this band start at 0 or 1
a172 4
    integer, dimension(:), pointer :: SUPERSET ! Used for matching signals
    integer, dimension(:), pointer :: INDICES_C ! Indecies on coarse grid
    integer, dimension(:), pointer :: TAN_INDS ! Index of tangent grid into gl grid
    integer, dimension(:), pointer :: GL_INDS ! Index of GL indecies
a174 1
    integer, dimension(:,:), pointer :: GL_INDGEN ! Temp. array of indecies
a178 2
    logical, dimension(:,:), pointer :: DO_CALC_ZP    ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_FZP   ! 'Avoid zeros' indicator
d182 1
d185 1
a188 2
    real(r8) :: FRQ                     ! Frequency

d191 1
d197 1
a198 1
    real(rp) :: THISRATIO               ! A sideband ratio
a201 4
    real(rp), dimension(:), pointer :: TAN_HTS ! Accumulation of ONE_TAN_HT
    real(rp), dimension(:), pointer :: TAN_TEMPS ! Accumulation of ONE_TAN_TEMP
    real(rp), dimension(:), pointer :: REQS      ! Accumulation of REQ

a202 1

d215 1
a215 1
    real(rp), dimension(:), pointer :: PHI_BASIS ! phi basis per species
d219 1
a220 1
    real(rp), dimension(:), pointer :: P_GLGRID ! Pressure on glGrid surfs
d225 4
a229 1
    real(rp), dimension(:), pointer :: TAN_TEMP ! ***
a231 1
    real(rp), dimension(:), pointer :: Z_BASIS !zeta basis per specie (n_f_zeta)
d235 1
d242 1
a242 1

d251 1
a252 1
    real(rp), dimension(:,:), pointer :: DH_DT_PATH ! dH/dT on path
d254 1
a254 1
    real(rp), dimension(:,:), pointer :: D2X_DXDT    ! (No_tan_hts, nz*np)
a255 1
    real(rp), dimension(:,:), pointer :: ETA_FZP ! Eta_z x Eta_p * Eta_f
a275 2
    integer(ip) :: sps_i  ! a species counter
    integer(ip) :: no_sv_p_t ! number of phi basis for temperature
d278 2
d281 1
a282 1
    real(rp) :: earthradc ! minor axis of orbit plane projected Earth ellipse
d293 1
a293 1
    real(rp), dimension(:), pointer :: tan_chi_out
d295 1
a295 1
    real(rp), dimension(:), pointer :: dhdz_out
d297 2
d300 1
a300 3
    real(rp), dimension(:), pointer :: tan_phi
    real(rp), dimension(:), pointer :: est_scgeocalt
    real(rp), dimension(:,:), pointer :: dxdt_tan
d303 1
a303 1
    real(rp), dimension(:,:), pointer :: d2xdxdt_surface
d311 1
a313 1
    type (VectorValue_T), pointer :: F             ! An arbitrary species
d327 1
a328 1
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS_M ! ***
a333 2
    type (Grids_T) :: Grids_f   ! All the coordinates for VMR
    type (Grids_T) :: Grids_dw  ! All the spectroscopy(W) coordinates
d336 2
a345 1
    real(r4), dimension(:,:,:,:,:,:), pointer :: K_SPECT_DW
d348 1
d369 1
a369 1
!   spect_der = FwdModelConf%spect_der
d387 1
a387 1
      & gl_indgen, gl_inds, gl_ndx, grids, h_glgrid, h_path, incoptdepth, &
d1144 1
a1144 1
        &  gl_slabs_m(no_ele,noSpecies), STAT=ier )
d1587 11
a1597 1
          if ( temp_der  .and. spect_der ) then
d1599 2
a1600 32
            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),  &
              &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),       &
              &  beta_path_c(1:npc,:), GL_SLABS_M=gl_slabs_m,              &
              &  T_PATH_M=t_path(1:no_ele)-del_temp, GL_SLABS_P=gl_slabs_p,&
              &  T_PATH_P=t_path(1:no_ele)+del_temp,                       &
              &  DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:),                   &
              &  DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                   &
              &  DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                   &
              &  DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )

          else if ( temp_der ) then

            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),  &
              &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),       &
              &  beta_path_c(1:npc,:),                                     &
              &  GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp,&
              &  GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp,&
              &  DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:) )

          else if ( spect_der ) then

            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),    &
              &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),         &
              &  beta_path_c(1:npc,:), DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),&
              &  DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                     &
              &  DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )

          else

            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),  &
              &  my_Catalog, beta_group, gl_slabs, indices_c(1:npc),       &
              &  beta_path_c(1:npc,:) )
d1602 1
a1602 1
          end if
d1604 1
a1604 2
          alpha_path_c(1:npc) = SUM(sps_path(indices_c(1:npc),:) *  &
                                  & beta_path_c(1:npc,:),DIM=2)
d1606 2
a1607 3
          call path_contrib ( alpha_path_c(1:npc), del_s(1:npc), e_rflty,   &
                  & fwdModelConf%tolerance, tau(1:npc), incoptdepth(1:npc), &
                  & do_gl(1:npc) )
d1609 1
a1609 1
          ! ALLOCATE gl grid beta
d1611 1
a1611 2
          no_gl_ndx = count(do_gl(1:npc))
          j = Ng * no_gl_ndx
a1612 1
          call allocate_test ( gl_inds, j, 'gl_inds', moduleName )
a1614 3
          call allocate_test ( gl_indgen, Ng, no_gl_ndx, 'gl_indgen', &
                             & moduleName )
          call allocate_test ( gl_ndx, no_gl_ndx, 2, 'gl_ndx', moduleName )
d1616 2
a1617 1
          gl_ndx(:,1) = pack((/(i,i=1,npc)/),do_gl(1:npc))
d1619 1
a1619 22
  ! Make (/(j-Ng-1,j=1,Ng)/), (/(j,j=1,Ng)/) parameter variables later on

          do i = 1 , no_gl_ndx
            if ( gl_ndx(i,1) > npc/2 ) then
              gl_ndx(i,2) = 1 - Ng + Ngp1 * (gl_ndx(i,1) - 1)
              gl_indgen(:,i) = (/(j,j=1,Ng)/)
            else
              gl_ndx(i,2) = 1 +      Ngp1 * (gl_ndx(i,1) - 1)
              gl_indgen(:,i) = (/(j-Ng-1,j=1,Ng)/)
            end if
          end do

          ! compute the gl indicies

          gl_inds = reshape(spread(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
            &  gl_indgen,(/Ng*no_gl_ndx/))

          j = Ng * no_gl_ndx
          if ( temp_der  .and. spect_der ) then

            call allocate_test ( dbeta_dt_path_f, j, no_mol, &
              & 'dbeta_dt_path_f', moduleName )
d1626 1
d1628 11
a1638 36
            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),   &
              & my_Catalog, beta_group, gl_slabs, gl_inds, beta_path_f,     &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp,  &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp,  &
              & DBETA_DT_PATH=dbeta_dt_path_f, DBETA_DW_PATH=dbeta_dw_path_f,&
              & DBETA_DN_PATH=dbeta_dn_path_f, DBETA_DV_PATH=dbeta_dv_path_f )

          else if ( temp_der ) then

            call allocate_test ( dbeta_dt_path_f, j, no_mol, &
              & 'dbeta_dt_path_f', moduleName )
            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),    &
              &   my_Catalog, beta_group, gl_slabs, gl_inds, beta_path_f,    &
              &   GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp, &
              &   GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp, &
              &   DBETA_DT_PATH=dbeta_dt_path_f )

          else if ( spect_der ) then

            call allocate_test ( dbeta_dw_path_f, j, no_mol, &
                              & 'dbeta_dw_path_f', moduleName )
            call allocate_test ( dbeta_dn_path_f, j, no_mol, &
                              & 'dbeta_dn_path_f', moduleName )
            call allocate_test ( dbeta_dv_path_f, j, no_mol, &
                              & 'dbeta_dv_path_f', moduleName )
            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele),    &
              & my_Catalog, beta_group, gl_slabs, gl_inds, beta_path_f,      &
              & DBETA_DW_PATH=dbeta_dw_path_f, DBETA_DN_PATH=dbeta_dn_path_f,&
              & DBETA_DV_PATH=dbeta_dv_path_f )

          else

            call get_beta_path ( Frq, p_path(1:no_ele), t_path(1:no_ele), &
              &  my_Catalog, beta_group, gl_slabs, gl_inds, beta_path_f )

          end if
a1730 1
          call deallocate_test ( gl_indgen, 'gl_indgen', moduleName )
d2409 3
@


2.100
log
@Added allLinesForRadiometer functionality.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.99 2002/11/13 17:07:44 livesey Exp $"
d93 1
a93 1
    character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d2487 3
@


2.99
log
@Passes FwdModelExtra into convolve/no_conv
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.98 2002/10/26 00:13:35 livesey Exp $"
d66 1
a66 1
                          & GetNameOfSignal
d713 13
a725 4
              doThis = any ( thisLine%signals == &
                & fwdModelConf%signals(sigInd)%index )

! If we're only doing one sideband, maybe we can remove some more lines
d727 1
d731 4
a734 1
              lineFlag(k) = lineFlag(k) .or. doThis
d2487 3
@


2.98
log
@Made the warning about lines less common as it checks for continuum
aswell.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.97 2002/10/25 01:12:43 livesey Exp $"
d2204 1
a2204 1
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2211 1
a2211 1
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2220 1
a2220 1
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2228 1
a2228 1
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2474 4
@


2.97
log
@Added an array to accumulate the stuff such as one_tan_ht etc.
Also put in but commented out some code to dump it.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.96 2002/10/10 19:38:22 vsnyder Exp $"
d731 1
a731 1
        if ( count(lineFlag) == 0 ) then
d734 1
a734 1
            & 'No relevant lines for '//trim(molName) )
d2474 4
@


2.96
log
@Mostly cosmetic, some performance improvements
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.95 2002/10/10 01:46:50 livesey Exp $"
d205 3
d402 2
a403 1
      & z_basis_dv, z_basis_dw, z_glgrid, z_path, z_tmp )
d973 3
d1453 4
d2100 9
d2372 3
d2474 3
@


2.95
log
@Whoops, typo fix
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.94 2002/10/10 01:28:06 livesey Exp $"
a17 1
  private :: not_used_here 
a233 3
    real(rp), dimension(:), pointer :: XM ! Midpoint of integration grid intervals
    real(rp), dimension(:), pointer :: YM ! Half length of integration grid intervals
    real(rp), dimension(:), pointer :: ZGX ! Gauss weights (with -1 at front)
d398 2
a399 2
      & usedchannels, usedsignals, xm, ym, z_all, z_basis, z_basis_dn, &
      & z_basis_dv, z_basis_dw, z_glgrid, zgx, z_path, z_tmp )
d772 1
a772 1
                 &   SIN(Deg2Rad*orbIncline%values(1,maf))**2 + &
d774 1
a774 1
    req_out = COS(Deg2Rad*phitan%values(:,maf))**2
d785 1
a785 1
      end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
d787 1
a787 1
      end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
d789 1
a789 1
      end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
d793 1
a793 1
      call get_chi_out ( ptan%values(:,maf), Deg2Rad*phitan%values(:,maf), &
d795 1
a795 1
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
d804 1
a804 1
      call get_chi_out ( ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d806 1
a806 1
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
d823 1
a823 1
      call get_chi_out ( ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d825 1
a825 1
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
d839 1
a839 1
      call get_chi_out ( ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d841 1
a841 1
         & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
a913 3
    maxVert = (Nlvl-1) * Ng + Nlvl

    ! Work out the dimensions of it
d915 1
a930 4
    call allocate_test ( xm, NLm1, 'xm', moduleName )
    call allocate_test ( ym, NLm1, 'ym', moduleName )
    call allocate_test ( zgx, Ngp1, 'zgx', moduleName )

d933 7
a939 7
    zGx(1) = -1.0_rp
    zGx(2:Ngp1) = Gx(1:Ng)

    xm(1:NLm1) = 0.5_rp * (z_psig(2:Nlvl) + z_psig(1:Nlm1))
    ym(1:NLm1) = 0.5_rp * (z_psig(2:Nlvl) - z_psig(1:Nlm1))
    z_glgrid(1:maxVert-1) = RESHAPE ((SPREAD(xm,1,Ngp1) + &
       & SPREAD(ym,1,Ngp1) * SPREAD(zGx,2,NLm1)), (/maxVert-1/))
a942 3
    call deallocate_test ( xm, 'xm', moduleName )
    call deallocate_test ( ym, 'ym', moduleName )
    call deallocate_test ( zgx, 'zgx', moduleName )
d956 1
a956 1
      &  SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
d961 1
a961 2
! We are going to over-writing the user's Tangent Grid specifications ..
! (Replacing "fwdModelConf%tangentGrid%surfs" with: "tan_press")
d1019 2
d1040 1
a1040 1
        call get_chi_out ( tan_press(1:1), deg2rad*tan_phi(1:1), &
d1052 1
a1052 1
        call get_chi_out ( tan_press(1:1), deg2rad*tan_phi(1:1), &
d1072 1
a1072 1
        call get_chi_out ( tan_press(1:1), deg2rad*tan_phi(1:1), &
d1083 1
a1083 1
        call get_chi_out ( tan_press(1:1), deg2rad*tan_phi(1:1), &
d1289 2
a1290 2
          k = Size(pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%&
                  &frequencies)
d1341 2
a1342 2
        & call allocate_test ( k_temp_frq,maxNoPtgFreqs,sv_t_len, 'k_temp_frq', &
        &  moduleName )
d1345 1
a1345 1
        & call allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len, 'k_atmos_frq',&
d1350 1
a1350 1
                          & 'k_spect_dw_frq', moduleName )
d1352 1
a1352 1
                          & 'k_spect_dn_frq', moduleName )
d1354 1
a1354 1
                          & 'k_spect_dv_frq', moduleName )
a1372 1
        indices_c(1:) = 0
d1374 1
d1378 1
a1378 1
          (z_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
d1380 1
a1380 1
          (p_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
d1394 1
a1394 1
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/), (/tan_inds(ptg_i)/),  &
d1396 1
a1396 1
              &  Deg2Rad*orbIncline%values(1,maf), Grids_tmp%deriv_flags,    &
d1409 1
a1409 1
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/), (/tan_inds(ptg_i)/),  &
d1411 1
a1411 1
              &  Deg2Rad*orbIncline%values(1,maf),                           &
d1424 1
a1424 1
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/), (/tan_inds(ptg_i)/),  &
d1426 2
a1427 2
              &  Deg2Rad*orbIncline%values(1,maf),                           &
              &  Grids_tmp%deriv_flags, h_path(1:no_ele), phi_path(1:no_ele),&
d1438 1
a1438 1
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/), (/tan_inds(ptg_i)/),  &
d1440 1
a1440 1
              &  Deg2Rad*orbIncline%values(1,maf),                           &
d1486 1
a1486 1
             & one_tan_ht(1), tan_phi(ptg_i)*Deg2Rad, Req, 0.0_rp,        &
d1491 1
a1491 1
             & one_tan_ht(1), tan_phi(ptg_i)*Deg2Rad,Req, 0.0_rp,         &
d2264 1
a2264 1
        molName(j:32)=' '
d2441 1
a2441 1
 end subroutine FullForwardModel
d2443 2
a2444 1
  logical function not_used_here()
d2446 1
a2446 1
  end function not_used_here
d2451 3
@


2.94
log
@Bug fix in k_temp windowing
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.93 2002/10/08 17:08:03 pwagner Exp $"
d1863 1
a1863 1
              do instance = 1, no_sv_p_t, WindowFinish
d2462 3
@


2.93
log
@Added idents to survive zealous Lahey optimizer
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.92 2002/10/04 23:49:50 vsnyder Exp $"
d1863 1
a1863 1
              do instance = WindowStart, WindowFinish
d1878 1
a1878 1
              do instance = WindowStart, WindowFinish
d2462 3
@


2.92
log
@More cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.91 2002/10/02 23:06:42 vsnyder Exp $"
d18 1
d2455 4
d2462 3
@


2.91
log
@Add 'seez' switch, instead of uncommenting include, to get Zvi's debug print.
Get SpeedOfLight from Geometry.  Cosmetic changes.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.90 2002/09/26 18:02:49 livesey Exp $"
d33 1
a33 1
    use D_Hunt_m, only: Hunt_Zvi => Hunt
d258 2
a259 2
    REAL(rp), DIMENSION(:,:), POINTER :: DX_DT       ! (No_tan_hts, nz*np)
    REAL(rp), DIMENSION(:,:), POINTER :: D2X_DXDT    ! (No_tan_hts, nz*np)
d295 1
a295 1
    real(rp), dimension(:), POINTER :: z_psig(:) ! recommended PSIG for
d369 1
a369 1
!   Print *,'** Enter ForwardModel, MAF =',fmstat%maf   ! ** ZEBUG
d378 1
a378 1
    if ( toggle(emit) ) &
d383 3
a385 18
    nullify ( grids, usedchannels, channelOrigins, usedsignals, superset, &
           &  indices_c, tan_inds, tan_press )
    nullify ( gl_ndx, gl_indgen )
    nullify ( do_gl)
    nullify ( do_calc_zp, do_calc_dn, do_calc_dv, do_calc_dw, &
           &  do_calc_hyd, do_calc_t, do_calc_fzp )
    nullify ( k_temp, k_atmos, k_spect_dw, k_spect_dn, k_spect_dv )
    nullify ( frequencies )
    nullify ( alpha_path_c, del_s, dhdz_path, drad_df, drad_dn, &
      & drad_dt, drad_dv, drad_dw, h_path, incoptdepth, n_path, &
      & path_dsdh, phi_basis, phi_basis_dn, &
      & phi_basis_dv, phi_basis_dw, phi_path, p_glgrid, p_path, RadV, &
      & ref_corr, tau, t_path, t_script, xm, ym, zgx,&
      & z_basis, z_basis_dn, z_basis_dv, z_basis_dw, z_glgrid, z_path, &
      & z_all, z_tmp )

    nullify ( beta_path, beta_path_c, beta_path_f, dbeta_dn_path_c, &
      & dbeta_dn_path_f, dbeta_dt_path_c, dbeta_dt_path_f, &
d387 16
a402 9
      & dhdz_glgrid, dh_dt_path, dx_dt, d2x_dxdt, eta_zp, eta_zxp_dn, &
      & eta_zxp_dv, eta_zxp_dw, eta_zxp_t, h_glgrid, k_atmos_frq, &
      & k_spect_dn_frq, k_spect_dv_frq, k_spect_dw_frq, eta_fzp, &
      & k_temp_frq, ptg_angles, radiances, sps_path, tan_dh_dt, tan_temp, &
      & t_glgrid, dh_dt_glgrid )
    nullify ( tan_phi, est_scgeocalt, tan_chi_out, dx_dh_out, dxdt_tan, &
      &     d2xdxdt_tan,ddhidhidtl0,tan_d2h_dhdt,dhdz_out,dxdt_surface,&
      &     d2xdxdt_surface, req_out )
    nullify ( lineFlag )
d513 1
a513 1
! Work out the `window' stuff for temperature. Create the Grids_tmp stracture:
d515 1
a515 1
    call findinstancewindow ( temp,phitan,maf,fwdModelConf%phiWindow, &
d549 3
a551 3
    grids_tmp%frq_basis=0.0
    grids_tmp%zet_basis=temp%template%surfs(1:n_t_zeta,1)
    grids_tmp%phi_basis=temp%template%phi(1,windowStart:windowFinish)*Deg2Rad
d635 1
a635 1
      beta_ratio = 1.0_rp   ! Allways, for single element (no grouping)
d648 1
a648 1
      allocate ( gl_inds(k+1), stat=i )
d678 1
a678 1
      deallocate ( gl_inds, stat=i )
a681 2
    nullify ( gl_inds )

d771 6
a776 5
    call allocate_test ( req_out,ptan%template%nosurfs,'req_out', &
                     & moduleName )
    earthradc = earthrada*earthradb / &
          & SQRT(earthrada**2*SIN(Deg2Rad*orbIncline%values(1,maf))**2 + &
          & earthradb**2*COS(Deg2Rad*orbIncline%values(1,maf))**2)
d781 1
a781 1
    call allocate_test ( tan_chi_out,ptan%template%nosurfs,'tan_chi_out', &
d783 1
a783 1
    call allocate_test ( dx_dh_out,ptan%template%nosurfs,'dx_dh_out', &
d785 1
a785 1
    call allocate_test ( dhdz_out,ptan%template%nosurfs,'dhdz_out', &
d856 1
a856 1
    call allocate_test ( z_all,temp%template%nosurfs+2,'z_all', moduleName )
d872 2
a873 2
      call deallocate_test ( z_all,'z_all',moduleName )
      call allocate_test ( z_all,SIZE(z_tmp),'z_all',moduleName )
d875 1
a875 1
      call deallocate_test ( z_tmp,'z_tmp',moduleName )
d878 1
a878 1
    DO sps_i = 1 , no_mol
d892 1
a892 1
      call allocate_test ( z_all,SIZE(z_tmp),'z_all',moduleName )
d894 1
a894 1
      call deallocate_test ( z_tmp,'z_tmp',moduleName )
d906 1
a906 1
    call allocate_test ( z_all,SIZE(z_tmp),'z_all',moduleName )
d908 1
a908 1
    call deallocate_test ( z_tmp,'z_tmp',moduleName )
d913 1
a913 1
    call deallocate_test ( z_all,'z_all',moduleName )
a923 4
    call allocate_test ( xm, NLm1, 'xm', moduleName )
    call allocate_test ( ym, NLm1, 'ym', moduleName )
    call allocate_test ( zgx, Ngp1, 'zgx', moduleName )

d936 4
d954 1
a954 1
    call deallocate_test ( zgx,'zgx', moduleName )
d968 1
a968 1
      &  SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t),&
d981 2
a982 1
    call allocate_test ( est_scgeocalt,no_tan_hts,'est_scgeocalt',moduleName )
d984 1
a984 5
    call deallocate_test ( rec_tan_inds,'rec_tan_inds',moduleName )
    if ( j > 0 ) then
      tan_inds(1:j) = 1
      tan_press(1:j) = fwdModelConf%tangentGrid%surfs(1:j)
    end if
d986 1
d988 1
d993 2
a994 4
    if ( j > 0 ) then
      tan_phi(1:j) = phitan%values(1,MAF)
      est_scgeocalt(1:j) = scGeocAlt%values(1,maf)
    end if
d996 1
a996 1
! Since the interpolatevalues routine needs the OldX array to be sorted
d1028 1
a1028 1
      &  tan_phi(j+1:no_tan_hts),METHOD = 'L' )
d1030 1
a1030 1
       & est_scgeocalt(j+1:no_tan_hts),METHOD='L' )
d1039 2
a1040 2
      call allocate_test ( dxdt_surface,1,sv_t_len,'dxdt_surface',moduleName )
      call allocate_test ( d2xdxdt_surface,1,sv_t_len,'d2xdxdt_surface', &
d1071 1
a1071 1
      call deallocate_test ( d2xdxdt_surface,'d2xdxdt_surface',moduleName )
d1101 1
a1101 1
      call deallocate_test ( d2xdxdt_surface,'d2xdxdt_surface',moduleName )
d1103 1
a1103 1
    call deallocate_test ( req_out,'req_out',moduleName )
d1192 1
a1192 1
!      call allocate_test ( k_temp,noUsedChannels, no_tan_hts, n_t_zeta, &
d1197 1
a1197 1
      call allocate_test ( dbeta_dt_path_c,npc,no_mol,'dbeta_dt_path_c', &
d1207 2
a1208 2
      call allocate_test ( tan_dh_dt,1,sv_t_len,'tan_dh_dt',moduleName )
      call allocate_test ( tan_d2h_dhdt,1,sv_t_len,'tan_d2h_dhdt',moduleName )
d1214 1
a1214 1
      call allocate_test ( k_atmos,noUsedChannels,no_tan_hts,f_len,'k_atmos',&
d1254 1
a1254 1
    call allocate_test ( ptg_angles,no_tan_hts,'ptg_angles',moduleName )
d1258 2
a1259 2
    call allocate_test ( dx_dt, no_tan_hts,sv_t_len,'dx_dt',moduleName )
    call allocate_test ( d2x_dxdt,no_tan_hts,sv_t_len,'d2x_dxdt',moduleName )
d1288 1
a1288 3
        where ( superset < 0 )
          superset = maxSuperset + 1
        end where
d1296 1
a1296 1
                 &  tan_press, grids, allowTopValue=.TRUE.,nearest=.TRUE. )
d1305 2
a1306 2
        min_ch_freq_grid =  1.0e+12_rp
        max_ch_freq_grid = -1.0e+12_rp
d1352 1
a1352 1
        & call allocate_test ( k_temp_frq,maxNoPtgFreqs,sv_t_len,'k_temp_frq', &
d1356 1
a1356 1
        & call allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
d1381 1
a1381 1
        ! This is not pretty but we need some coarse grid extraction indicies
d1393 1
a1393 1
        ! Compute the h_path,t_path,dhdz_path,phi_path,dhdt_path
d1410 2
a1411 2
              &  TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,      &
              &  NEG_H_TAN=(/neg_tan_ht/),DHTDTL0=tan_dh_dt,                 &
d1413 2
a1414 2
              &  DHIDTLM=dh_dt_glgrid,                                       &
              &  DHITDTLM=dh_dt_path(1:no_ele,:),                            &
d1425 1
a1425 1
              &  TAN_PHI_H_GRID=one_tan_ht, TAN_PHI_T_GRID=one_tan_temp,     &
d1440 4
a1443 4
              &  TAN_PHI_H_GRID=one_tan_ht, TAN_PHI_T_GRID=one_tan_temp,     &
              &  DHTDTL0=tan_dh_dt, DDHIDHIDTL0 = ddhidhidtl0,               &
              &  DDHTDHTDTL0 = tan_d2h_dhdt, DHIDTLM=dh_dt_glgrid,           &
              &  DHITDTLM=dh_dt_path(1:no_ele,:),                            &
d1445 1
a1445 1
              &  ETA_ZXP=eta_zxp_t(1:no_ele,:),                              &
d1454 1
a1454 1
              &  TAN_PHI_H_GRID=one_tan_ht, TAN_PHI_T_GRID=one_tan_temp )
d1544 1
a1544 1
          call Hunt_zvi ( min_ch_freq_grid, PointingGrids(whichPointingGrid)% &
d1546 1
a1546 1
          call Hunt_zvi ( max_ch_freq_grid,PointingGrids(whichPointingGrid)% &
d1802 3
a1804 3
            call deallocate_test ( dbeta_dw_path_f,'dbeta_dw_path_f',moduleName )
            call deallocate_test ( dbeta_dn_path_f,'dbeta_dn_path_f',moduleName )
            call deallocate_test ( dbeta_dv_path_f,'dbeta_dv_path_f',moduleName )
d2092 1
a2092 1
           & call deallocate_test ( frequencies,'frequencies',moduleName )
d2265 1
a2265 1
    if ( index(switches,'seez') /= 0 ) then
d2272 1
a2272 1
    i = Index(molName,'.B')
d2280 1
a2280 1
    if ( index(switches,'rad') /= 0 ) then
d2283 1
a2283 1
        print *,'Convolution: ON'
d2285 1
a2285 1
        print *,'Convolution: OFF'
d2289 1
a2289 1
        print *,'Frequency Averaging: ON'
d2292 2
a2293 2
        print *,'Frequency Averaging: OFF'
        print '(a,f12.4,a)', ' (All computations done at Frq =',Frq,')'
d2395 3
a2397 3
    call deallocate_test ( tan_chi_out,'tan_chi_out',moduleName )
    call deallocate_test ( dx_dh_out,'dx_dh_out',moduleName )
    call deallocate_test ( dhdz_out,'dhdz_out',moduleName )
d2409 3
a2411 3
      call deallocate_test ( dxdt_tan,'dxdt_tan',moduleName )
      call deallocate_test ( d2xdxdt_tan,'d2xdxdt_tan',moduleName )
      call deallocate_test ( dxdt_surface,'dxdt_surface',moduleName )
d2457 4
@


2.90
log
@Now uses GetQuantityForForwardModel.
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.89 2002/09/10 17:05:38 livesey Exp $"
d43 1
a43 1
    use Geometry, only: EarthRadA, EarthRadB
a349 1
    real(r8), allocatable :: PrtRad(:)
a365 3
!   real(rp) :: Q       ! ** ZEBUG, for dumping purposes (creating 'seez' file)
!   Integer :: L1, L2   ! ** ZEBUG, for dumping purposes (creating 'seez' file)

d434 1
a434 1
    temp => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d436 1
a436 1
    ptan => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d439 1
a439 1
    phitan => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d442 1
a442 1
    elevOffset => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d445 1
a445 1
    orbIncline => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d447 1
a447 1
    spaceRadiance => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d449 1
a449 1
    earthRefl => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d451 1
a451 1
    refGPH => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d453 1
a453 1
    losVel => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d456 1
a456 1
    scGeocAlt => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d461 1
a461 1
    ! vmr => GetQuantityforForwardModel (fwdModelIn, fwdModelExtra, &
d464 3
a466 3
    ! Now we're going to validate the quantities we've been given, don't forget
    ! we already know what their quantityType's are as that's how we found them
    !, so we don't need to check that.
d516 1
a516 1
    Vel_Cor = 1.0_rp - losvel%values(1,maf)/299792458.3_rp
d608 1
a608 1
        f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d675 1
a675 1
          f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d889 1
a889 1
      f => GetQuantityforForwardModel(fwdmodelin,fwdmodelextra, &
d2130 1
a2130 1
          GetQuantityforForwardModel (fwdModelOut, quantityType=l_radiance, &
d2134 1
a2134 1
          sidebandRatio => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d2277 1
a2277 1
! *** To create *seez* file for "nasty" purposes, include the following:
d2279 3
a2281 1
!   Include 'dump_print_code.f9h'
d2307 1
a2307 1
        print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
a2309 1
      print *
d2311 2
a2312 7
      print 901, k
      Print 902,Ptan%values(1:k,maf)

901   format ( 'ptan\ ',i3.3)
902   format ( 4(3x, f11.7))

      allocate ( PrtRad(k), STAT=i )
a2315 1
        PrtRad(:) = 0.0
d2317 4
a2320 6
        print 903, channel, char(92), k
        do ptg_i = 1, k
          j = channel + thisRadiance%template%noChans*(ptg_i-1)
          PrtRad(ptg_i) = thisRadiance%values(j,maf )
        end do
        print 905, PrtRad(1:ptan%template%noSurfs)
a2323 6
903   format (/, 'ch', i2.2, '_pfa_rad', a1, i3.3 )
905   format ( 4(2x, 1pg15.8) )
906   format ( 5(1x, f14.4))

      deallocate ( PrtRad, STAT=i )

d2471 3
@


2.89
log
@New update arguments to convolve/noconvole
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.88 2002/09/07 02:18:50 vsnyder Exp $"
d41 1
d438 3
a440 3
    temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature )
    ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d442 19
a460 16
      & foundInFirst=ptan_der )
    phitan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, instrumentModule=firstSignal%instrumentModule )
    elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_elevOffset, radiometer=firstSignal%radiometer )
    orbIncline => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_orbitInclination )
    spaceRadiance => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_spaceRadiance )
    earthRefl => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_earthRefl )
    refGPH => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_refGPH )
    losVel => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule )
    scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d465 1
a465 1
    ! vmr => GetVectorQuantityBytype (fwdModelIn, fwdModelExtra, &
d612 3
a614 7
        if ( l == l_extinction ) then
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_extinction, radiometer=firstSignal%radiometer )
        else
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_vmr, molecule=l )
        end if
d679 3
a681 2
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              & quantityType=l_isotoperatio, molecule=l, noError=.TRUE. )
d893 3
a895 9
      l = fwdModelConf%molecules(mol_cat_index(sps_i))
      if ( l == l_extinction ) then
        f => getvectorquantitybytype(fwdmodelin,fwdmodelextra, &
          &  quantitytype = l_extinction, radiometer = &
          &  firstsignal%radiometer)
      else
        f => getvectorquantitybytype(fwdmodelin,fwdmodelextra, &
          &  quantitytype = l_vmr, molecule = l)
      end if
d2134 1
a2134 1
          GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
d2138 1
a2138 1
          sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d2140 1
a2140 1
            & sideband=thisSideband )
d2488 3
@


2.88
log
@More cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.87 2002/09/06 20:23:22 livesey Exp $"
d159 1
d2152 1
d2170 2
a2171 2
   ! Now change channel from starting at 0 or 1 to definately 1

d2176 1
a2176 1
               & thisRadiance, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2184 1
a2184 1
               & thisRadiance, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2194 1
a2194 1
               & thisRadiance, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2203 1
a2203 1
               & thisRadiance, ptg_angles, Radiances(:,i), tan_chi_out,        &
d2219 1
a2219 1
              &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
d2226 1
a2226 1
              &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
d2235 1
a2235 1
              &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
d2243 1
a2243 1
              &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
d2493 3
@


2.87
log
@Merged in bug fixes with change from Van
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.86 2002/09/06 18:19:04 vsnyder Exp $"
d22 2
a23 2
 subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
                            &  FwdModelOut, oldIfm, FmStat, Jacobian )
d47 1
a47 1
    use INTRINSIC, only: L_TEMPERATURE, L_RADIANCE, L_PHITAN, L_PTAN, &
d277 1
a277 1
!
d279 1
a279 1
!
d296 1
a296 1
!
d310 1
a310 1
!
d312 1
a312 1
!
d362 1
a362 1
!
d364 1
a364 1
!
d523 1
a523 1
                          & windowStart, windowFinish )
d527 1
a527 1
!
d532 1
a532 1
                     & moduleName )
d534 1
a534 1
                     & moduleName )
d543 1
a543 1
!
d545 1
a545 1
!
d548 1
a548 1
                     & moduleName )
d550 1
a550 1
                     & moduleName )
d554 1
a554 1
                     & moduleName )
d567 1
a567 1
    if ( associated(temp%mask)) Grids_tmp%deriv_flags = RESHAPE((IAND( &
d570 1
a570 1
!
d618 1
a618 1
!
d642 3
a644 3
!
    if ( ALL ( fwdModelConf%molecules > 0 ) ) THEN
!
d655 1
a655 1
!
d657 1
a657 1
!
d659 1
a659 1
      allocate(gl_inds(k+1), stat=i)
d688 2
a689 2
      deallocate(gl_inds, stat=i)
!
d693 1
a693 1
!
d695 1
a695 1
!
d709 1
a709 1
          CYCLE
d726 1
a726 1
!
d728 1
a728 1
!
d736 1
a736 1
!
d739 1
a739 1
!
d741 1
a741 1
!
d751 1
a751 1
!
d753 1
a753 1
!
d760 1
a760 1
!
d768 4
a771 4
      call load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
       &   firstSignal%radiometer, mol_cat_index, p_len, f_len, h2o_ind,    &
       &   ext_ind, Grids_f, f_len_dw, Grids_dw, f_len_dn, Grids_dn,        &
       &   f_len_dv, Grids_dv)
d773 3
a775 3
      call load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
       &   firstSignal%radiometer, mol_cat_index, p_len, f_len, h2o_ind,    &
       &   ext_ind, Grids_f)
d777 1
a777 1
!
d780 1
a780 1
!
d782 1
a782 1
!
d793 1
a793 1
                     & moduleName )
d795 1
a795 1
                     & moduleName )
d797 2
a798 2
                     & moduleName )
    if ( h2o_ind > 0 .and. .not. temp_der) THEN
d807 2
a808 2
      call get_chi_out(ptan%values(:,maf), Deg2Rad*phitan%values(:,maf), &
         & 0.001_rp*scGeocAlt%values(:,maf),Grids_tmp, &
d811 2
a812 2
         & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
         & req_out,tan_chi_out,dhdz_out,dx_dh_out,&
d817 3
a819 3
    else if ( h2o_ind == 0 .and. .not. temp_der) THEN
      call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
         & 0.001_rp*scGeocAlt%values(:,maf),Grids_tmp, &
d822 3
a824 3
         & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
         & req_out,tan_chi_out,dhdz_out,dx_dh_out)
    else if ( h2o_ind > 0 .and.  temp_der) THEN
d826 1
a826 1
                      & 'dxdt_tan',moduleName )
d828 8
a835 8
                      & 'd2xdxdt_tan',moduleName )
      end_ind_z=SUM(grids_f%no_z(1:h2o_ind))
      beg_ind_z=end_ind_z - grids_f%no_z(h2o_ind) + 1
      end_ind_p=SUM(grids_f%no_p(1:h2o_ind))
      beg_ind_p=end_ind_p - grids_f%no_p(h2o_ind) + 1
      end_ind=SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) * &
                & grids_f%no_f(1:h2o_ind))
      beg_ind=end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) * &
d837 2
a838 2
      call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
         & 0.001_rp*scGeocAlt%values(:,maf),Grids_tmp, &
d841 2
a842 2
         & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
         & req_out,tan_chi_out,dhdz_out,dx_dh_out, &
d847 1
a847 1
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan)
d850 1
a850 1
                     &  'dxdt_tan',moduleName )
d852 3
a854 3
                      & 'd2xdxdt_tan',moduleName )
      call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
         & 0.001_rp*scGeocAlt%values(:,maf),Grids_tmp, &
d857 3
a859 3
         & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
         & req_out,tan_chi_out,dhdz_out,dx_dh_out, &
         & dxdt_tan=dxdt_tan, d2xdxdt_tan=d2xdxdt_tan)
d861 1
a861 1
!
d863 1
a863 1
!
d866 1
a866 1
!
d868 1
a868 1
!
d871 1
a871 1
!
d876 1
a876 1
    if ( ASSOCIATED(FwdModelConf%tangentGrid)) THEN
d880 1
a880 1
!
d882 1
a882 1
!
d888 1
a888 1
!
d890 1
a890 1
!
d892 1
a892 1
      if ( l == l_extinction ) THEN
d900 1
a900 1
!
d902 1
a902 1
!
d906 1
a906 1
!
d908 1
a908 2
!
      call deallocate_test ( z_all,'z_all',moduleName )
d912 3
a914 3
!
    END DO
!
d916 1
a916 1
!
d920 1
a920 1
!
d922 1
a922 2
!
    call deallocate_test ( z_all,'z_all',moduleName )
d926 1
a926 1
!
d928 2
a929 2
!
    call make_z_grid(z_all,z_psig,rec_tan_inds)
d931 1
a931 1
!
d953 1
a953 1
                      & 'dh_dt_glgrid', moduleName )
d955 2
a956 2
                      & 'ddhidhidtl0', moduleName )
!
d958 1
a958 1
!
d961 1
a961 1
!
d984 1
a984 1
    call two_d_hydrostatic(Grids_tmp, &
d986 4
a989 4
      &  0.001*refGPH%values(1,windowStart:windowFinish),z_glgrid, &
      &  orbIncline%values(1,maf)*Deg2Rad,t_glgrid,h_glgrid, &
      &  dhdz_glgrid,dh_dt_glgrid,DDHDHDTL0=ddhidhidtl0)
!
d1008 1
a1008 1
!
d1010 2
a1011 2
!
    if ( j > 0) THEN
d1015 1
a1015 1
!
d1018 1
a1018 1
!
d1047 4
a1050 4
    call interpolatevalues(z_path, p_path, tan_press(j+1:no_tan_hts),&
      &  tan_phi(j+1:no_tan_hts),METHOD = 'L')
    call interpolatevalues(z_path, t_path, tan_press(j+1:no_tan_hts),&
       & est_scgeocalt(j+1:no_tan_hts),METHOD='L')
d1055 1
a1055 1
!
d1057 2
a1058 2
!
    if ( temp_der) THEN
d1062 1
a1062 1
      if ( h2o_ind > 0) THEN
d1071 1
a1071 1
        call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1075 2
a1076 2
           & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
           & (/req_out(1)/),surf_angle,one_dhdz,one_dxdh, &
d1080 4
a1083 4
           & lin_log=grids_f%lin_log(h2o_ind),&
           & dxdt_tan=dxdt_surface, d2xdxdt_tan=d2xdxdt_surface)
      else if ( h2o_ind == 0) THEN
        call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1087 3
a1089 3
           & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
           & (/req_out(1)/),surf_angle,one_dhdz,one_dxdh,  &
           & dxdt_tan=dxdt_surface,d2xdxdt_tan=d2xdxdt_surface)
d1094 1
a1094 1
      if ( h2o_ind > 0) THEN
d1103 1
a1103 1
        call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1107 2
a1108 2
           & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
           & (/req_out(1)/),surf_angle,one_dhdz,one_dxdh, &
d1112 3
a1114 3
           & lin_log=grids_f%lin_log(h2o_ind))
      else if ( h2o_ind == 0) THEN
        call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1118 2
a1119 2
           & orbIncline%values(1,maf)*Deg2Rad,elevoffset%values(1,1)*Deg2Rad,&
           & (/req_out(1)/),surf_angle,one_dhdz,one_dxdh)
d1160 2
a1161 2
      allocate(gl_slabs_p(no_ele,noSpecies), &
        &  gl_slabs_m(no_ele,noSpecies), STAT=ier)
d1276 1
a1276 1
                      & 'radiances', moduleName )
d1305 1
a1305 1
        if ( all( superset < 0 )) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1324 1
a1324 1
          maxNoPtgFreqs = MAX ( maxNoPtgFreqs, k)
d1346 1
a1346 1
        call allocate_test ( frequencies,noUsedChannels, "frequencies", &
d1377 3
a1379 4
      if ( atmos_der ) then
        call allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
                           & moduleName )
      end if
d1427 5
a1431 5
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),   &
              &  Grids_tmp%phi_basis,z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid, &
              &  Deg2Rad*orbIncline%values(1,maf),Grids_tmp%deriv_flags,     &
              &  h_path(1:no_ele),phi_path(1:no_ele),                        &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),Req,                   &
d1434 1
a1434 1
              &  DDHIDHIDTL0 = ddhidhidtl0 ,DDHTDHTDTL0 = tan_d2h_dhdt,      &
d1442 2
a1443 2
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),   &
              &  Grids_tmp%phi_basis,z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid, &
d1445 3
a1447 3
              &  dummy,h_path(1:no_ele),phi_path(1:no_ele),                  &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),Req,                   &
              &  TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,      &
d1457 2
a1458 2
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),   &
              &  Grids_tmp%phi_basis,z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid, &
d1460 3
a1462 3
              &  Grids_tmp%deriv_flags,h_path(1:no_ele),phi_path(1:no_ele),  &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),Req,                   &
              &  TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,      &
d1471 2
a1472 2
            call metrics ( (/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),   &
              &  Grids_tmp%phi_basis,z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid, &
d1474 3
a1476 3
              &  dummy,h_path(1:no_ele),phi_path(1:no_ele),                  &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),Req,                   &
              &  TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp )
d1482 2
a1483 2
            & z_path(1:no_ele),phi_path(1:no_ele), &
            & do_calc_dw(1:no_ele,:),eta_zxp_dw(1:no_ele,:) )
d1485 2
a1486 2
            & z_path(1:no_ele),phi_path(1:no_ele), &
            & do_calc_dn(1:no_ele,:),eta_zxp_dn(1:no_ele,:) )
d1488 2
a1489 2
            & z_path(1:no_ele),phi_path(1:no_ele), &
            & do_calc_dv(1:no_ele,:),eta_zxp_dv(1:no_ele,:) )
d1496 1
a1496 1
          &  phi_path(1:no_ele),do_calc_zp(1:no_ele,:),eta_zp(1:no_ele,:) )
d1505 2
a1506 2
          & do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),      &
          & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:) )
d1510 2
a1511 2
            &  t_path(indices_c(1:npc)),n_path(1:npc),      &
            &  h2o_path=sps_path((indices_c(1:npc)),h2o_ind) )
d1514 1
a1514 1
            &  t_path(indices_c(1:npc)),n_path(1:npc) )
d1518 4
a1521 4
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
             & one_tan_ht(1),tan_phi(ptg_i)*Deg2Rad,Req,0.0_rp,        &
             & ptg_angles(ptg_i),r,1.0_rp,tan_dh_dt(1,:),            &
             & tan_d2h_dhdt(1,:),dx_dt(ptg_i,:),d2x_dxdt(ptg_i,:) )
d1523 3
a1525 3
          call get_chi_angles ( 0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
             & one_tan_ht(1),tan_phi(ptg_i)*Deg2Rad,Req,0.0_rp,        &
             & ptg_angles(ptg_i),r,1.0_rp )
d1542 3
a1544 3
        call get_gl_slabs_arrays ( my_Catalog,p_path(1:no_ele), &
          &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs, &
          &  no_ele,del_temp )
d1548 6
a1553 6
          call get_gl_slabs_arrays ( my_Catalog,p_path(1:no_ele), &
            &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_p, &
            &  no_ele,del_temp )
          call get_gl_slabs_arrays ( my_Catalog,p_path(1:no_ele), &
            &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_m, &
            &  no_ele,-del_temp )
d1566 4
a1569 4
          call Hunt_zvi ( min_ch_freq_grid,PointingGrids(whichPointingGrid)%&
                        &oneGrid(grids(ptg_i))%frequencies,k,j,frq_i )
          call Hunt_zvi ( max_ch_freq_grid,PointingGrids(whichPointingGrid)%&
                        &oneGrid(grids(ptg_i))%frequencies,k,frq_i,m )
d1574 1
a1574 1
!
d1576 1
a1576 1
!
d1578 1
a1578 1
!
d1580 1
a1580 1
!
d1599 2
a1600 2
            & do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),      &
            & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:) )
d1604 4
a1607 4
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),    &
              &  my_Catalog,beta_group,gl_slabs,indices_c(1:npc),          &
              &  beta_path_c(1:npc,:),GL_SLABS_M=gl_slabs_m,               &
              &  T_PATH_M=t_path(1:no_ele)-del_temp,GL_SLABS_P=gl_slabs_p, &
d1616 2
a1617 2
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),    &
              &  my_Catalog, beta_group,gl_slabs,indices_c(1:npc),         &
d1625 3
a1627 3
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &  my_Catalog,beta_group,gl_slabs,indices_c(1:npc),            &
              &  beta_path_c(1:npc,:),DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),&
d1633 2
a1634 2
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),  &
              &  my_Catalog, beta_group,gl_slabs,indices_c(1:npc),       &
d1642 2
a1643 2
          call path_contrib ( alpha_path_c(1:npc),del_s(1:npc),e_rflty,   &
                  & fwdModelConf%tolerance,tau(1:npc),incoptdepth(1:npc), &
d1689 2
a1690 2
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              & my_Catalog, beta_group,gl_slabs,gl_inds,beta_path_f,        &
d1693 2
a1694 2
              & DBETA_DT_PATH=dbeta_dt_path_f,DBETA_DW_PATH=dbeta_dw_path_f,&
              & DBETA_DN_PATH=dbeta_dn_path_f,DBETA_DV_PATH=dbeta_dv_path_f )
d1700 5
a1704 5
            call get_beta_path ( Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              &   my_Catalog,beta_group,gl_slabs,gl_inds,beta_path_f,       &
              &   GL_SLABS_M=gl_slabs_m,T_PATH_M=t_path(1:no_ele)-del_temp, &
              &   GL_SLABS_P=gl_slabs_p,T_PATH_P=t_path(1:no_ele)+del_temp, &
              &   DBETA_DT_PATH=dbeta_dt_path_f)
d1714 4
a1717 4
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
              & my_Catalog,beta_group,gl_slabs,gl_inds,beta_path_f,         &
              & DBETA_DW_PATH=dbeta_dw_path_f,DBETA_DN_PATH=dbeta_dn_path_f,&
              & DBETA_DV_PATH=dbeta_dv_path_f)
d1721 2
a1722 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &  my_Catalog,beta_group,gl_slabs,gl_inds,beta_path_f)
d1728 5
a1732 5
          call rad_tran ( Frq,spaceRadiance%values(1,1),e_rflty,            &
            & z_path(indices_c(1:npc)),t_path(indices_c(1:npc)),            &
            & alpha_path_c(1:npc),ref_corr(1:npc),do_gl(1:npc),             &
            & incoptdepth(1:npc),SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
            & path_dsdh(gl_inds),dhdz_path(gl_inds),t_script(1:npc),        &
d1741 7
a1747 7
            call drad_tran_df ( z_path(indices_c(1:npc)),Grids_f,              &
              &  beta_path_c(1:npc,:),eta_fzp(indices_c(1:npc),:),             &
              &  sps_path(indices_c(1:npc),:),do_calc_fzp(indices_c(1:npc),:), &
              &  beta_path_f,eta_fzp(gl_inds,:),sps_path(gl_inds,:),    &
              &  do_calc_fzp(gl_inds,:),do_gl(1:npc),del_s(1:npc),      &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_df,ptg_i,frq_i )
d1755 14
a1768 14
            call drad_tran_dt ( z_path(indices_c(1:npc)),                    &
              & Req+h_path(indices_c(1:npc)),                                &
              & t_path(indices_c(1:npc)),dh_dt_path(indices_c(1:npc),:),     &
              & alpha_path_c(1:npc),SUM(sps_path(indices_c(1:npc),:) *       &
              & dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),      &
              & eta_zxp_t(indices_c(1:npc),:),do_calc_t(indices_c(1:npc),:), &
              & do_calc_hyd(indices_c(1:npc),:),del_s(1:npc),ref_corr(1:npc),&
              & Req + one_tan_ht(1),dh_dt_path(brkpt,:),frq,do_gl(1:npc),    &
              & req + h_path(gl_inds),t_path(gl_inds),dh_dt_path(gl_inds,:), &
              & SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
              & SUM(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
              & eta_zxp_t(gl_inds,:),do_calc_t(gl_inds,:),path_dsdh(gl_inds),&
              & dhdz_path(gl_inds),t_script(1:npc),tau(1:npc),i_stop,drad_dt,&
              & ptg_i,frq_i )
d1778 7
a1784 7
            call drad_tran_dx ( z_path(indices_c(1:npc)),Grids_dw,            &
              &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(indices_c(1:npc),:),     &
              &  sps_path(indices_c(1:npc),:),do_calc_dw(indices_c(1:npc),:), &
              &  dbeta_dw_path_f,eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),   &
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dw,ptg_i,frq_i )
d1790 7
a1796 7
            call drad_tran_dx ( z_path(indices_c(1:npc)),Grids_dn,            &
              &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(indices_c(1:npc),:),     &
              &  sps_path(indices_c(1:npc),:),do_calc_dn(indices_c(1:npc),:), &
              &  dbeta_dn_path_f,eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),   &
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dn,ptg_i,frq_i )
d1802 7
a1808 7
            call drad_tran_dx ( z_path(indices_c(1:npc)),Grids_dv,            &
              &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(indices_c(1:npc),:),     &
              &  sps_path(indices_c(1:npc),:),do_calc_dv(indices_c(1:npc),:), &
              &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),   &
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dv,ptg_i,frq_i )
d1839 1
a1839 1
        ! Work out which channel shape information we're going need ----------
d1890 1
a1890 1
                    & size(FilterShapes(shapeInd)%FilterGrid),r)
d1914 1
a1914 1
!
d1935 1
a1935 1
                      Call Freq_Avg ( frequencies, &
d2152 1
a2152 1
        if ( FwdModelConf%do_conv ) THEN
d2171 7
a2177 7
          if ( .not. temp_der .AND. .not. atmos_der ) THEN
            call convolve_all ( FwdModelConf,FwdModelIn,FwdModelExtra,maf,  &
               & chanInd,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
               & thisRadiance,ptg_angles,Radiances(:,i),tan_chi_out,        &
               & dhdz_out,dx_dh_out,thisRatio,                              &
               & antennaPatterns(whichPattern),Grids_tmp%deriv_flags,       &
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1),     &
d2179 9
a2187 9
          else if ( temp_der .AND. .not. atmos_der ) THEN
            call convolve_all ( FwdModelConf,FwdModelIn,FwdModelExtra,maf,  &
               & chanInd,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
               & thisRadiance,ptg_angles,Radiances(:,i),tan_chi_out,        &
               & dhdz_out,dx_dh_out,thisRatio,                              &
               & antennaPatterns(whichPattern),Grids_tmp%deriv_flags,       &
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1),     &
               & DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),     &
               & DX_DT=dx_dt,D2X_DXDT=d2x_dxdt,DXDT_TAN=dxdt_tan,           &
d2189 7
a2195 7
          else if ( atmos_der .AND. .not. temp_der ) THEN
            call convolve_all ( FwdModelConf,FwdModelIn,FwdModelExtra,maf,  &
               & chanInd,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
               & thisRadiance,ptg_angles,Radiances(:,i),tan_chi_out,        &
               & dhdz_out,dx_dh_out,thisRatio,                              &
               & antennaPatterns(whichPattern),Grids_tmp%deriv_flags,       &
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1),     &
d2199 9
a2207 9
            call convolve_all ( FwdModelConf,FwdModelIn,FwdModelExtra,maf,  &
               & chanInd,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
               & thisRadiance,ptg_angles,Radiances(:,i),tan_chi_out,        &
               & dhdz_out,dx_dh_out,thisRatio,                              &
               & antennaPatterns(whichPattern),Grids_tmp%deriv_flags,       &
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1),     &
               & DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))),     &
               & DX_DT=dx_dt,D2X_DXDT=d2x_dxdt,DXDT_TAN=dxdt_tan,           &
               & DXDT_SURFACE=dxdt_surface,                                 &
d2211 1
a2211 1
!
d2215 1
a2215 1
          if ( .not. temp_der .AND. .not. atmos_der ) THEN
d2218 5
a2222 5
              &  Grids_tmp%deriv_flags,ptg_angles,tan_chi_out,            &
              &  dhdz_out,dx_dh_out,Grids_f, &
              &  Radiances(:,i),thisRatio,mol_cat_index,fmStat%rows,Jacobian,&
              &  PTAN_DER=ptan_der)
          else if ( temp_der .AND. .not. atmos_der ) THEN
d2225 5
a2229 4
              &  Grids_tmp%deriv_flags,ptg_angles,tan_chi_out,            &
              &  dhdz_out,dx_dh_out,Grids_f, &
              &  Radiances(:,i),thisRatio,mol_cat_index,fmStat%rows,Jacobian,&
              &  DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))), &
d2231 1
a2231 1
          else if ( atmos_der .AND. .not. temp_der ) THEN
d2234 4
a2237 4
              &  Grids_tmp%deriv_flags,ptg_angles,tan_chi_out,            &
              &  dhdz_out,dx_dh_out,Grids_f, &
              &  Radiances(:,i),thisRatio,mol_cat_index,fmStat%rows,Jacobian,&
              &  DI_DF=DBLE(k_atmos(i,:,:)), PTAN_DER=ptan_der )
d2242 4
a2245 3
              &  Grids_tmp%deriv_flags,ptg_angles,tan_chi_out,            &
              &  dhdz_out,dx_dh_out,Grids_f, &
              &  Radiances(:,i),thisRatio,mol_cat_index,fmStat%rows,Jacobian,&
d2250 1
a2250 1
!
d2285 1
a2285 1
!
d2287 1
a2287 1
!
d2360 1
a2360 1
!
d2365 1
a2365 1
!
d2368 1
a2368 1
!
d2491 3
@


2.86
log
@Cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.85 2002/09/05 21:00:38 vsnyder Exp $"
d1921 36
a1956 28
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                sv_start = sv_i
                do i = 1, noUsedChannels
                  sv_i = sv_start
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid)
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channel )
                  do instance = Grids_f%WindowStart(k), Grids_f%WindowFinish(k)
                    do surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
                      call Freq_Avg ( frequencies, &
                          & FilterShapes(shapeInd)%FilterGrid, &
                          & FilterShapes(shapeInd)%FilterShape, &
                          & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
                      k_atmos(i,ptg_i,sv_i) = r
                      sv_i = sv_i + 1
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! else not frequency averaging
                sv_start = sv_i
                do i = 1, noUsedChannels
                  sv_i = sv_start
                  do instance = Grids_f%WindowStart(k), Grids_f%WindowFinish(k)
                    do surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
d1958 4
a1961 2
                      sv_i = sv_i + 1
                    end do
d1964 2
a1965 2
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
d1967 1
a1967 1
!
d1969 1
a1969 1

d2492 3
@


2.85
log
@Get rid of some auxiliary variables
@
text
@d8 1
a8 1
  implicit none
d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.84 2002/08/26 20:02:22 livesey Exp $"
d21 2
a22 4
! ================================ FullForwardModel routine ======

! -----------------------------------------------  ForwardModel  -----
 Subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
d25 2
a26 26
    use GLNP, only: NG, GX
    use MLSCommon, only: I4, R4, R8, RP, IP, FINDFIRST
    use MLSFiles, only: get_free_lun
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS, &
                                &  DESTROYCOMPLETESLABS
    use COMP_ETA_DOCALC_NO_FRQ_M, only: comp_eta_docalc_no_frq
    use COMP_SPS_PATH_FRQ_M, only: comp_sps_path_frq
    use EVAL_SPECT_PATH_M, only: EVAL_SPECT_PATH
    use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR, PATH_DS_DH
    use TWO_D_HYDROSTATIC_M, only: two_d_hydrostatic
    use METRICS_M
    use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
    use GET_CHI_OUT_M, only: GET_CHI_OUT
    use GET_BETA_PATH_M, only: GET_BETA_PATH, beta_group_T
    use RAD_TRAN_M, only: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, &
                         &  DRAD_TRAN_DX
    use SLABS_SW_M, only: GET_GL_SLABS_ARRAYS
    use FREQ_AVG_M, only: FREQ_AVG
    use CONVOLVE_ALL_M, only: CONVOLVE_ALL
    use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
    use D_LINTRP_M, only: LINTRP
    use D_HUNT_M, only: hunt_zvi => HUNT

    use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
                         &   GETVECTORQUANTITYBYTYPE, &
                         &   M_FullDerivatives
d28 1
a28 3
    use ForwardModelConfig, only: FORWARDMODELCONFIG_T
    use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, &
                                    &   FORWARDMODELSTATUS_T
d30 17
a46 12
    use FilterShapes_m, only: FILTERSHAPES
    use PointingGrid_m, only: POINTINGGRIDS

    use Load_sps_data_m, ONLY: LOAD_SPS_DATA, Grids_T, destroygrids_t

    use MatrixModule_1, only: MATRIX_T
    use Trace_M, only: Trace_begin, Trace_end
    use Molecules, only: L_EXTINCTION, spec_tags
    use MLSSignals_m, only: SIGNAL_T, MATCHSIGNAL, ARESIGNALSSUPERSET, DUMP, &
                          & GetNameOfSignal
    use String_table, only: GET_STRING, DISPLAY_STRING
    use SpectroscopyCatalog_m, only: CATALOG_T, LINE_T, LINES, CATALOG
d51 10
a60 1
    use Units, only: Deg2Rad
d63 13
a75 1
    use MLSNumerics, ONLY: HUNT, INTERPOLATEVALUES
a76 3
    use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
    use Output_m, only: OUTPUT
    use ManipulateVectorQuantities, only: findinstancewindow
d78 5
a82 2
    use Make_Z_Grid_M, only: MAKE_Z_GRID
    use Geometry, only: earthrada,earthradb
a83 6
    use Dump_0, only: DUMP

    use MatrixModule_0, only: M_ABSENT, M_BANDED, M_FULL
    use MatrixModule_1, only: CREATEBLOCK, FINDBLOCK, MATRIX_T
  ! This is the full radiative transfer forward model, the workhorse
  ! code
d280 4
a283 4
    INTEGER(ip) :: sps_i  ! a species counter
    INTEGER(ip) :: no_sv_p_t ! number of phi basis for temperature
    INTEGER(ip) :: beg_ind, end_ind, beg_ind_z, end_ind_z
    INTEGER(ip) :: beg_ind_p, end_ind_p
d285 2
a286 2
    REAL(rp) :: surf_angle(1), one_dhdz(1), one_dxdh(1)
    REAL(rp) :: earthradc ! minor axis of orbit plane projected Earth ellipse
d288 1
a288 1
    INTEGER(ip), DIMENSION(:), pointer :: rec_tan_inds ! recommended tangent
d290 2
a291 2
    REAL(rp), DIMENSION(:), pointer :: z_tmp ! temporary zeta storage
    REAL(rp), DIMENSION(:), pointer :: z_all ! mass storage of representation
d293 1
a293 1
    REAL(rp), DIMENSION(:), POINTER :: z_psig(:) ! recommended PSIG for
d297 13
a309 13
    REAL(rp), DIMENSION(:), POINTER :: tan_chi_out
    REAL(rp), DIMENSION(:), POINTER :: dx_dh_out
    REAL(rp), DIMENSION(:), POINTER :: dhdz_out
    REAL(rp), DIMENSION(:), POINTER :: req_out
    REAL(rp), DIMENSION(:), POINTER :: tan_press
    REAL(rp), DIMENSION(:), POINTER :: tan_phi
    REAL(rp), DIMENSION(:), POINTER :: est_scgeocalt
    REAL(rp), DIMENSION(:,:), POINTER :: dxdt_tan
    REAL(rp), DIMENSION(:,:), POINTER :: d2xdxdt_tan
    REAL(rp), DIMENSION(:,:), POINTER :: dxdt_surface
    REAL(rp), DIMENSION(:,:), POINTER :: d2xdxdt_surface
    REAL(rp), DIMENSION(:,:), POINTER :: tan_d2h_dhdt
    REAL(rp), DIMENSION(:,:,:), POINTER :: ddhidhidtl0
d381 1
a381 1
      & Call trace_begin ( 'ForwardModel, MAF=', index=fmstat%maf )
d386 1
a386 1
           &  indices_c, tan_inds, tan_press)
d399 1
a399 1
      & z_all, z_tmp)
d408 2
a409 2
      & t_glgrid, dh_dt_glgrid)
    NULLIFY(tan_phi, est_scgeocalt, tan_chi_out, dx_dh_out, dxdt_tan, &
d411 1
a411 1
      &     d2xdxdt_surface, req_out)
d422 6
a427 8
    if ( any( fwdModelConf%signals%sideband /= &
      & firstSignal%sideband ) ) &
      & Call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config")
    if ( any( fwdModelConf%signals%radiometer /= &
      & firstSignal%radiometer ) ) &
      & Call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed radiometers in forward model config")
d467 1
a467 1
      & frequencyCoordinate=(/l_none/)) ) Call MLSMessage ( MLSMSG_Error, &
d470 1
a470 1
      & frequencyCoordinate=(/l_none/)) ) Call MLSMessage ( MLSMSG_Error, &
d473 1
a473 1
      & frequencyCoordinate=(/l_none/)) ) Call MLSMessage ( MLSMSG_Error, &
d477 1
a477 1
      & Call MLSMessage ( MLSMSG_Error, ModuleName, &
d495 1
a495 1
        &    fwdModelConf%signals(1)%sideband ) ) Call MLSMessage ( &
d522 2
a523 2
    Call findinstancewindow(temp,phitan,maf,fwdModelConf%phiWindow, &
                          & windowStart, windowFinish)
d528 15
a542 15
    Call allocate_test(Grids_tmp%no_z,1,'Grids_tmp%no_z',modulename )
    Call allocate_test(Grids_tmp%no_p,1,'Grids_tmp%no_p',modulename )
    Call allocate_test(Grids_tmp%no_f,1,'Grids_tmp%no_f',modulename )
    Call allocate_test(Grids_tmp%windowstart,1,'Grids_tmp%windowstart',&
                     & modulename )
    Call allocate_test(Grids_tmp%windowfinish,1,'Grids_tmp%windowfinish',&
                     & modulename )
    Call Allocate_test(Grids_tmp%lin_log,1,'lin_log',ModuleName )

    Grids_tmp%no_f = 1
    Grids_tmp%no_z = n_t_zeta
    Grids_tmp%no_p = no_sv_p_t
    Grids_tmp%lin_log = .FALSE.
    Grids_tmp%windowStart(1) = windowStart
    Grids_tmp%windowFinish(1) = windowFinish
d547 12
a558 12
    Call allocate_test(Grids_tmp%zet_basis,n_t_zeta,'Grids_tmp%zet_basis',&
                     & ModuleName)
    Call allocate_test(Grids_tmp%phi_basis,no_sv_p_t,'Grids_tmp%phi_basis',&
                     & ModuleName)
    Call allocate_test(Grids_tmp%frq_basis,1,'Grids_tmp%frq_basis',ModuleName)
    Call allocate_test(Grids_tmp%values,k,'Grids_tmp%values',ModuleName)
    Call allocate_test(Grids_tmp%deriv_flags,k,'Grids_tmp%deriv_flags',&
                     & ModuleName)

    Grids_tmp%frq_basis=0.0
    Grids_tmp%zet_basis=temp%template%surfs(1:n_t_zeta,1)
    Grids_tmp%phi_basis=temp%template%phi(1,windowStart:windowFinish)*Deg2Rad
d560 1
a560 1
    Grids_tmp%values = RESHAPE(temp%values(:,windowStart:windowFinish),(/k/))
d563 1
a563 1
    Grids_tmp%deriv_flags(1:k) = .TRUE.
d567 1
a567 1
    IF(associated(temp%mask)) Grids_tmp%deriv_flags = RESHAPE((IAND( &
d578 1
a578 1
        & frequencyCoordinate=(/l_channel/)) ) Call MLSMessage ( MLSMSG_Error, &
d583 6
a588 6
    Call allocate_test ( usedChannels, noUsedChannels, &
      & 'usedChannels', ModuleName )
    Call allocate_test ( channelOrigins, noUsedChannels, &
      & 'channelOrigins', ModuleName )
    Call allocate_test ( usedSignals, noUsedChannels, &
      & 'usedSignals', ModuleName )
d592 1
a592 1
        if (fwdModelConf%signals(sigInd)%channels(i)) then
d613 1
a613 1
        endif
d620 1
a620 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d627 1
a627 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d633 1
a633 1
      if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d636 1
a636 1
      if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d643 1
a643 1
    IF( ALL ( fwdModelConf%molecules > 0 ) ) THEN
d656 1
a656 1
    ELSE
d669 2
a670 2
        if(k > 0) then
          if(gl_inds(j+1) > 0) then
d675 1
a675 1
          endif
d677 1
a677 1
          if(gl_inds(j-1) > 0) sv_i = sv_i + 1
d685 1
a685 1
        endif
d690 1
a690 1
    ENDIF
d698 1
a698 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d707 2
a708 2
          Call Allocate_test ( my_catalog(j)%lines, 0, &
                            & 'my_catalog(?)%lines(0)', ModuleName )
d717 2
a718 2
        Call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                         &  'lineFlag', ModuleName )
d743 2
a744 2
          Call get_string ( lit_indices(l), molName )
          Call MLSMessage ( MLSMSG_Warning, ModuleName, &
d746 3
a748 3
        endif
        Call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
          & 'my_catalog(?)%lines', ModuleName )
d750 1
a750 1
        Call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
d757 2
a758 2
        Call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
          & ModuleName )
d767 2
a768 2
    if(spect_der) then
      Call load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
d773 1
a773 1
      Call load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
d776 1
a776 1
    endif
d783 2
a784 2
    Call ALLOCATE_TEST(req_out,ptan%template%nosurfs,'req_out', &
                     & ModuleName )
d792 7
a798 7
    Call ALLOCATE_TEST(tan_chi_out,ptan%template%nosurfs,'tan_chi_out', &
                     & ModuleName )
    Call ALLOCATE_TEST(dx_dh_out,ptan%template%nosurfs,'dx_dh_out', &
                     & ModuleName )
    Call ALLOCATE_TEST(dhdz_out,ptan%template%nosurfs,'dhdz_out', &
                     & ModuleName )
    IF (h2o_ind > 0 .and. .not. temp_der) THEN
d807 1
a807 1
      Call get_chi_out(ptan%values(:,maf), Deg2Rad*phitan%values(:,maf), &
d817 2
a818 2
    ELSE IF (h2o_ind == 0 .and. .not. temp_der) THEN
      Call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d824 5
a828 5
    ELSE IF (h2o_ind > 0 .and.  temp_der) THEN
      Call ALLOCATE_TEST(dxdt_tan,ptan%template%nosurfs,sv_t_len, &
                      & 'dxdt_tan',ModuleName )
      Call ALLOCATE_TEST(d2xdxdt_tan,ptan%template%nosurfs,sv_t_len, &
                      & 'd2xdxdt_tan',ModuleName )
d837 1
a837 1
      Call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d848 6
a853 6
    ELSE
      Call ALLOCATE_TEST(dxdt_tan,ptan%template%nosurfs,sv_t_len, &
                     &  'dxdt_tan',ModuleName )
      Call ALLOCATE_TEST(d2xdxdt_tan,ptan%template%nosurfs,sv_t_len, &
                      & 'd2xdxdt_tan',ModuleName )
      Call get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d860 1
a860 1
    ENDIF
d867 1
a867 1
    Call Allocate_Test (z_all,temp%template%nosurfs+2,'z_all', ModuleName )
d876 3
a878 3
    IF (ASSOCIATED(FwdModelConf%tangentGrid)) THEN
      CALL ALLOCATE_TEST(z_tmp,SIZE(z_ALL) + FwdModelConf%tangentGrid%nosurfs, &
      & 'z_tmp',modulename)
d883 2
a884 2
      Call Deallocate_test(z_all,'z_all',ModuleName)
      Call Allocate_test(z_all,SIZE(z_tmp),'z_all',ModuleName)
d886 2
a887 2
      Call Deallocate_Test(z_tmp,'z_tmp',ModuleName)
    ENDIF
d892 1
a892 1
      IF( l == l_extinction ) THEN
d896 1
a896 1
      ELSE
d899 1
a899 1
      ENDIF
d904 1
a904 1
      Call allocate_test (z_tmp, j, 'z_tmp', ModuleName )
d909 2
a910 2
      Call Deallocate_test(z_all,'z_all',ModuleName)
      Call Allocate_test(z_all,SIZE(z_tmp),'z_all',ModuleName)
d912 1
a912 1
      Call Deallocate_Test(z_tmp,'z_tmp',ModuleName)
d919 1
a919 1
    Call allocate_test (z_tmp, j, 'z_tmp', ModuleName )
d924 2
a925 2
    Call Deallocate_test(z_all,'z_all',ModuleName)
    Call Allocate_test(z_all,SIZE(z_tmp),'z_all',ModuleName)
d927 1
a927 1
    Call Deallocate_Test(z_tmp,'z_tmp',ModuleName)
d931 2
a932 2
    Call make_z_grid(z_all,z_psig,rec_tan_inds)
    Call Deallocate_test(z_all,'z_all',ModuleName)
d943 15
a957 15
    Call Allocate_test ( xm, NLm1, 'xm', ModuleName )
    Call Allocate_test ( ym, NLm1, 'ym', ModuleName )
    Call Allocate_test ( zgx, Ngp1, 'zgx', ModuleName )

    Call Allocate_test ( z_glGrid, maxVert, 'z_glGrid', ModuleName )
    Call Allocate_test ( p_glGrid, maxVert, 'p_glGrid', ModuleName )

    Call allocate_test ( h_glgrid, maxVert, no_sv_p_t, 'h_glgrid', ModuleName )
    Call allocate_test ( t_glgrid, maxVert, no_sv_p_t, 't_glgrid', ModuleName )
    Call allocate_test ( dhdz_glgrid, maxVert, no_sv_p_t, 'dhdz_glgrid', &
                      &  ModuleName )
    Call allocate_test ( dh_dt_glgrid, maxVert,  n_t_zeta, no_sv_p_t, &
                      & 'dh_dt_glgrid', ModuleName )
    Call allocate_test ( ddhidhidtl0, maxVert, n_t_zeta, no_sv_p_t, &
                      & 'ddhidhidtl0', ModuleName )
d971 4
a974 4
    Call Deallocate_test ( xm, 'xm', ModuleName )
    Call Deallocate_test ( ym, 'ym', ModuleName )
    Call Deallocate_test ( zgx,'zgx', ModuleName )
    Call Deallocate_test ( z_psig, 'z_psig', ModuleName)
d984 1
a984 1
      & Call Trace_Begin ( 'ForwardModel.Hydrostatic' )
d986 1
a986 1
    Call two_d_hydrostatic(Grids_tmp, &
d997 4
a1000 4
    Call allocate_test (tan_inds, no_tan_hts, 'tan_inds', ModuleName )
    Call allocate_test (tan_press, no_tan_hts, 'tan_press', ModuleName )
    Call allocate_test (tan_phi, no_tan_hts, 'tan_phi', ModuleName )
    Call allocate_test (est_scgeocalt,no_tan_hts,'est_scgeocalt',ModuleName )
d1002 2
a1003 2
    Call Deallocate_test(rec_tan_inds,'rec_tan_inds',ModuleName)
    IF(j > 0) then
d1006 1
a1006 1
    ENDIF
d1013 1
a1013 1
    IF(j > 0) THEN
d1016 1
a1016 1
    ENDIF
d1022 3
a1024 3
    Call Allocate_test (z_path, k, 'h_path', ModuleName )
    Call Allocate_test (p_path, k, 'p_path', ModuleName )
    Call Allocate_test (t_path, k, 't_path', ModuleName )
d1033 1
a1033 1
        if(z_path(jf) < z_path(jf-1)) then
d1044 1
a1044 1
        endif
d1046 1
a1046 1
      if(m < 1) EXIT
d1049 1
a1049 1
    Call interpolatevalues(z_path, p_path, tan_press(j+1:no_tan_hts),&
d1051 1
a1051 1
    Call interpolatevalues(z_path, t_path, tan_press(j+1:no_tan_hts),&
d1054 3
a1056 3
    Call deallocate_test (z_path, 'h_path', ModuleName )
    Call deallocate_test (p_path, 'p_path', ModuleName )
    Call deallocate_test (t_path, 't_path', ModuleName )
d1060 5
a1064 5
    IF (temp_der) THEN
      Call allocate_test(dxdt_surface,1,sv_t_len,'dxdt_surface',ModuleName)
      Call allocate_test(d2xdxdt_surface,1,sv_t_len,'d2xdxdt_surface', &
                       & ModuleName)
      IF (h2o_ind > 0) THEN
d1073 1
a1073 1
        Call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1084 2
a1085 2
      ELSE IF (h2o_ind == 0) THEN
        Call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1092 3
a1094 3
      ENDIF
      Call deallocate_test(d2xdxdt_surface,'d2xdxdt_surface',modulename)
    ELSE
d1096 1
a1096 1
      IF (h2o_ind > 0) THEN
d1105 1
a1105 1
        Call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1115 2
a1116 2
      ELSE IF (h2o_ind == 0) THEN
        Call get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1122 4
a1125 4
      ENDIF
      Call deallocate_test(d2xdxdt_surface,'d2xdxdt_surface',modulename)
    ENDIF
    Call deallocate_test(req_out,'req_out',modulename)
d1131 1
a1131 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error,ModuleName, &
d1135 1
a1135 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error,ModuleName, &
d1139 1
a1139 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error,ModuleName, &
d1141 1
a1141 1
    Call allocate_test ( tan_temp, no_tan_hts, 'tan_temp', ModuleName )
d1150 1
a1150 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1157 1
a1157 1
        Call AllocateOneSlabs ( gl_slabs(j,i), nl )
d1161 1
a1161 1
    if(temp_der) then
d1164 1
a1164 1
      if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1172 2
a1173 2
          Call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
          Call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
d1176 1
a1176 1
    endif
d1185 24
a1208 24
    Call Allocate_test ( dhdz_path, no_ele, 'dhdz_path', ModuleName )
    Call Allocate_test ( h_path,    no_ele, 'h_path',    ModuleName )
    Call Allocate_test ( p_path,    no_ele, 'p_path',    ModuleName )
    Call Allocate_test ( path_dsdh, no_ele, 'path_dsdh', ModuleName )
    Call Allocate_test ( phi_path,  no_ele, 'phi_path',  ModuleName )
    Call Allocate_test ( t_path,    no_ele, 't_path',    ModuleName )
    Call Allocate_test ( z_path,    no_ele, 'z_path',    ModuleName )

    Call Allocate_Test ( alpha_path_c, npc, 'alpha_path_c', ModuleName )
    Call Allocate_Test ( incoptdepth,  npc, 'incoptdept',   ModuleName )
    Call Allocate_Test ( t_script,     npc, 't_script',     ModuleName )
    Call Allocate_Test ( tau,          npc, 'tau',          ModuleName )
    Call Allocate_test ( del_s,        npc, 'del_s',        ModuleName )
    Call Allocate_test ( do_gl,        npc, 'do_gl',        ModuleName )
    Call Allocate_test ( indices_c,    npc, 'indices_c',    ModuleName )
    Call Allocate_test ( n_path,       npc, 'n_path',       ModuleName )
    Call Allocate_test ( ref_corr,     npc, 'ref_corr',     ModuleName )

    Call Allocate_test ( beta_path_c, npc, no_mol, 'beta_path_c', ModuleName )
    Call Allocate_test ( do_calc_fzp, no_ele, f_len, 'do_calc_fzp', ModuleName )
    Call Allocate_test ( do_calc_zp, no_ele, p_len, 'do_calc_zp', ModuleName )
    Call Allocate_test ( eta_zp, no_ele, p_len, 'eta_zp', ModuleName )
    Call Allocate_test ( eta_fzp, no_ele, f_len, 'eta_fzp', ModuleName )
    Call Allocate_test ( sps_path, no_ele, no_mol, 'sps_path', ModuleName )
d1210 1
a1210 1
    if(temp_der) then
d1214 17
a1230 17
!      Call allocate_test ( k_temp,noUsedChannels, no_tan_hts, n_t_zeta, &
!                         & no_sv_p_t, 'k_temp',modulename)
      ALLOCATE(k_temp(noUsedChannels, no_tan_hts, n_t_zeta, no_sv_p_t))

      Call Allocate_test ( dRad_dt, sv_t_len, 'dRad_dt', ModuleName )
      Call Allocate_test ( dbeta_dt_path_c,npc,no_mol,'dbeta_dt_path_c', &
                         & ModuleName )
      Call Allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', &
                         & ModuleName )
      Call Allocate_test ( do_calc_hyd, no_ele, sv_t_len, 'do_calc_hyd', &
                         & ModuleName )
      Call Allocate_test ( do_calc_t, no_ele, sv_t_len, 'do_calc_t', &
                         & ModuleName )
      Call Allocate_test ( eta_zxp_t, no_ele, sv_t_len, 'eta_zxp_t', &
                         & ModuleName )
      Call Allocate_test ( tan_dh_dt,1,sv_t_len,'tan_dh_dt',ModuleName )
      Call Allocate_test (tan_d2h_dhdt,1,sv_t_len,'tan_d2h_dhdt',ModuleName )
d1232 1
a1232 1
    endif
d1235 3
a1237 3
      Call Allocate_test ( dRad_df, f_len, 'dRad_df', ModuleName )
      Call allocate_test(k_atmos,noUsedChannels,no_tan_hts,f_len,'k_atmos',&
                       & modulename)
d1239 1
a1239 1
    endif
d1241 1
a1241 1
    if(spect_der) then
d1243 1
a1243 1
      ! Allocation when spectaral derivative are needed:
d1245 6
a1250 6
      Call Allocate_test ( dbeta_dw_path_c, npc, no_mol, &
        & 'dbeta_dw_path_c', ModuleName )
      Call Allocate_test ( dbeta_dn_path_c, npc, no_mol, &
        & 'dbeta_dn_path_c', ModuleName )
      Call Allocate_test ( dbeta_dv_path_c, npc, no_mol, &
        & 'dbeta_dv_path_c', ModuleName )
d1256 19
a1274 23
      Call Allocate_test ( do_calc_dw, no_ele, f_len_dw, 'do_calc_dw', &
                        &  ModuleName )
      Call Allocate_test ( do_calc_dn, no_ele, f_len_dn, 'do_calc_dn', &
                        &  ModuleName )
      Call Allocate_test ( do_calc_dv, no_ele, f_len_dv, 'do_calc_dv', &
                        &  ModuleName )

      Call Allocate_test ( eta_zxp_dw, no_ele, f_len_dw, 'eta_zxp_dw', &
                        &  ModuleName )
      Call Allocate_test ( eta_zxp_dn, no_ele, f_len_dn, 'eta_zxp_dn', &
                        &  ModuleName )
      Call Allocate_test ( eta_zxp_dv, no_ele, f_len_dv, 'eta_zxp_dv', &
                        &  ModuleName )

      Call Allocate_test ( drad_dw, f_len_dw, 'drad_dw', ModuleName )
      Call Allocate_test ( drad_dn, f_len_dn, 'drad_dn', ModuleName )
      Call Allocate_test ( drad_dv, f_len_dv, 'drad_dv', ModuleName )

    endif

    Call allocate_test ( ptg_angles,no_tan_hts,'ptg_angles',ModuleName )
    Call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
                      & 'radiances', ModuleName )
d1276 6
a1281 2
    Call allocate_test (dx_dt, no_tan_hts,sv_t_len,'dx_dt',ModuleName)
    Call allocate_test (d2x_dxdt,no_tan_hts,sv_t_len,'d2x_dxdt',ModuleName)
d1284 1
a1284 1
                  & Call Trace_End ( 'ForwardModel.Hydrostatic' )
d1287 1
a1287 1
                  & Call Trace_Begin ( 'ForwardModel.SidebandLoop' )
d1292 1
a1292 1
        & Call Trace_Begin ( 'ForwardModel.Sideband ', index=thisSideband )
d1301 2
a1302 2
        Call allocate_test ( superset, size(pointingGrids), &
          & 'superset', ModuleName )
d1307 1
a1307 1
        if ( all( superset < 0 )) Call MLSMessage(MLSMSG_Error,ModuleName, &
d1314 1
a1314 1
        Call deallocate_test ( superset, 'superset', ModuleName )
d1318 3
a1320 3
        Call allocate_test ( grids, no_tan_hts, "Grids", ModuleName )
        Call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
                 &  tan_press, grids, allowTopValue=.TRUE.,nearest=.TRUE.)
d1337 1
a1337 1
          if ( shapeInd == 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1348 2
a1349 2
        Call allocate_test ( frequencies,noUsedChannels, "frequencies", &
                           & ModuleName )
d1363 1
a1363 1
          Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1366 1
a1366 1
          Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1373 10
a1382 1
      Call Allocate_test ( RadV, maxNoPtgFreqs, 'RadV', ModuleName )
d1384 8
a1391 17
      if (temp_der) &
        & Call Allocate_test (k_temp_frq,maxNoPtgFreqs,sv_t_len,'k_temp_frq', &
        &  ModuleName )

      if (atmos_der) then
        Call Allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
                           & ModuleName )
      endif

      if (spect_der) then
        Call Allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_len_dw , &
                          & 'k_spect_dw_frq', ModuleName )
        Call Allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_len_dn , &
                          & 'k_spect_dn_frq', ModuleName )
        Call Allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_len_dv , &
                          & 'k_spect_dv_frq', ModuleName )
      endif
d1394 1
a1394 1
        & Call Trace_Begin ( 'ForwardModel.PointingLoop' )
d1399 1
a1399 1
          & Call Trace_Begin ( 'ForwardModel.Pointing ', index=ptg_i )
d1421 1
a1421 1
          & Call Trace_Begin ( 'ForwardModel.MetricsEtc' )
d1423 1
a1423 1
        if (ptg_i < surfaceTangentIndex) then
d1428 1
a1428 1
          if(temp_der) then
d1430 1
a1430 1
            Call metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1443 1
a1443 1
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:))
d1445 1
a1445 1
            Call metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1451 2
a1452 2
              &  NEG_H_TAN = (/neg_tan_ht/))
          endif
d1458 1
a1458 1
          if(temp_der) then
d1460 1
a1460 1
            Call metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1472 1
a1472 1
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:))
d1474 1
a1474 1
            Call metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1479 3
a1481 3
              &  TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp)
          endif
        endif
d1483 2
a1484 2
        if(spect_der) then
          Call eval_spect_path(Grids_dw, firstSignal%lo, thisSideband, &
d1486 2
a1487 2
            & do_calc_dw(1:no_ele,:),eta_zxp_dw(1:no_ele,:))
          Call eval_spect_path(Grids_dn, firstSignal%lo, thisSideband, &
d1489 2
a1490 2
            & do_calc_dn(1:no_ele,:),eta_zxp_dn(1:no_ele,:))
          Call eval_spect_path(Grids_dv, firstSignal%lo, thisSideband, &
d1492 2
a1493 2
            & do_calc_dv(1:no_ele,:),eta_zxp_dv(1:no_ele,:))
        endif
d1498 2
a1499 2
        Call comp_eta_docalc_no_frq(Grids_f,z_path(1:no_ele), &
          &  phi_path(1:no_ele),do_calc_zp(1:no_ele,:),eta_zp(1:no_ele,:))
d1506 1
a1506 1
        Call comp_sps_path_frq(Grids_f, firstSignal%lo, thisSideband, &
d1509 1
a1509 1
          & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1511 4
a1514 4
        if (h2o_ind > 0) then
          Call refractive_index(p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)),n_path(1:npc),    &
            &  h2o_path=sps_path((indices_c(1:npc)),h2o_ind))
d1516 3
a1518 3
          Call refractive_index(p_path(indices_c(1:npc)), &
            &  t_path(indices_c(1:npc)),n_path(1:npc))
        endif
d1520 2
a1521 2
        if(temp_der) then
          Call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
d1524 1
a1524 1
             & tan_d2h_dhdt(1,:),dx_dt(ptg_i,:),d2x_dxdt(ptg_i,:))
d1526 1
a1526 1
          Call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
d1528 2
a1529 2
             & ptg_angles(ptg_i),r,1.0_rp)
        endif
d1531 2
a1532 2
        Call comp_refcor(Req+h_path(indices_c(1:npc)), 1.0_rp+n_path(1:npc), &
                      &  Req+one_tan_ht(1), del_s(1:npc), ref_corr(1:npc))
d1545 1
a1545 1
        Call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1547 1
a1547 1
          &  no_ele,del_temp)
d1549 1
a1549 1
        if(temp_der) then
d1551 1
a1551 1
          Call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1553 2
a1554 2
            &  no_ele,del_temp)
          Call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1556 2
a1557 2
            &  no_ele,-del_temp)
        endif
d1569 4
a1572 4
          Call Hunt_zvi(min_ch_freq_grid,PointingGrids(whichPointingGrid)%&
                        &oneGrid(grids(ptg_i))%frequencies,k,j,frq_i)
          Call Hunt_zvi(max_ch_freq_grid,PointingGrids(whichPointingGrid)%&
                        &oneGrid(grids(ptg_i))%frequencies,k,frq_i,m)
d1574 1
a1574 1
          Call allocate_test ( frequencies,noFreqs, "frequencies", ModuleName )
d1582 1
a1582 1
        endif
d1586 1
a1586 1
          & Call Trace_End ( 'ForwardModel.MetricsEtc' )
d1589 1
a1589 1
          & Call Trace_Begin ( 'ForwardModel.FrequencyLoop' )
d1593 1
a1593 1
            & Call Trace_Begin ('ForwardModel.Frequency ',index=frq_i)
d1600 1
a1600 1
          Call comp_sps_path_frq(Grids_f, firstSignal%lo, thisSideband, &
d1603 1
a1603 1
            & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1605 1
a1605 1
          if(temp_der  .and. spect_der) then
d1607 1
a1607 1
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1617 1
a1617 1
          else if(temp_der) then
d1619 1
a1619 1
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1624 1
a1624 1
              &  DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:))
d1626 1
a1626 1
          else if(spect_der) then
d1628 1
a1628 1
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),        &
d1636 3
a1638 3
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),  &
              &  my_Catalog, beta_group,gl_slabs,indices_c(1:npc),     &
              &  beta_path_c(1:npc,:))
d1640 1
a1640 1
          endif
d1645 3
a1647 3
          Call path_contrib(alpha_path_c(1:npc),del_s(1:npc),e_rflty, &
                  & fwdModelConf%tolerance,tau(1:npc),incoptdepth(1:npc),&
                  & do_gl(1:npc))
d1654 6
a1659 6
          Call Allocate_test ( gl_inds, j, 'gl_inds', ModuleName )
          Call Allocate_test ( beta_path_f, j, no_mol, 'beta_path_f', &
                             & ModuleName )
          Call Allocate_test ( gl_indgen, Ng, no_gl_ndx, 'gl_indgen', &
                             & ModuleName )
          Call Allocate_test ( gl_ndx, no_gl_ndx, 2, 'gl_ndx', ModuleName )
d1666 1
a1666 1
            if(gl_ndx(i,1) > npc/2) then
d1672 2
a1673 2
            endif
          enddo
d1677 1
a1677 1
          gl_inds = RESHAPE(SPREAD(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
d1681 1
a1681 1
          if(temp_der  .and. spect_der) then
d1683 8
a1690 8
            Call Allocate_test ( dbeta_dt_path_f, j, no_mol, &
              & 'dbeta_dt_path_f', ModuleName )
            Call Allocate_test ( dbeta_dw_path_f, j, no_mol, &
              & 'dbeta_dw_path_f', ModuleName )
            Call Allocate_test ( dbeta_dn_path_f, j, no_mol, &
              & 'dbeta_dn_path_f', ModuleName )
            Call Allocate_test ( dbeta_dv_path_f, j, no_mol, &
              & 'dbeta_dv_path_f', ModuleName )
d1692 1
a1692 1
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1697 1
a1697 1
              & DBETA_DN_PATH=dbeta_dn_path_f,DBETA_DV_PATH=dbeta_dv_path_f)
d1699 1
a1699 1
          else if(temp_der) then
d1701 3
a1703 3
            Call Allocate_test ( dbeta_dt_path_f, j, no_mol, &
              & 'dbeta_dt_path_f', ModuleName )
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1709 1
a1709 1
          else if(spect_der) then
d1711 7
a1717 7
            Call Allocate_test ( dbeta_dw_path_f, j, no_mol, &
                              & 'dbeta_dw_path_f', ModuleName )
            Call Allocate_test ( dbeta_dn_path_f, j, no_mol, &
                              & 'dbeta_dn_path_f', ModuleName )
            Call Allocate_test ( dbeta_dv_path_f, j, no_mol, &
                              & 'dbeta_dv_path_f', ModuleName )
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1724 1
a1724 1
            Call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
d1727 1
a1727 1
          endif
d1731 2
a1732 2
          Call rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,              &
            & z_path(indices_c(1:npc)),t_path(indices_c(1:npc)),                          &
d1736 1
a1736 1
            & tau(1:npc),Rad,i_stop)
d1742 1
a1742 1
          if(atmos_der) then
d1744 1
a1744 1
            Call drad_tran_df(z_path(indices_c(1:npc)),Grids_f,                &
d1750 1
a1750 1
              &  t_script(1:npc),tau(1:npc),i_stop,drad_df,ptg_i,frq_i)
d1754 1
a1754 1
          endif
d1756 1
a1756 1
          if(temp_der) then
d1758 1
a1758 1
            Call drad_tran_dt(z_path(indices_c(1:npc)),                      &
d1771 1
a1771 1
              & ptg_i,frq_i)
d1775 1
a1775 1
          endif
d1777 1
a1777 1
          if(spect_der) then
d1781 7
a1787 7
            Call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dw,          &
              &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(indices_c(1:npc),:), &
              &  sps_path(indices_c(1:npc),:),do_calc_dw(indices_c(1:npc),:),&
              &  dbeta_dw_path_f,eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),&
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),  &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),&
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dw,ptg_i,frq_i)
d1793 7
a1799 7
            Call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dn,         &
              &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(indices_c(1:npc),:),&
              &  sps_path(indices_c(1:npc),:),do_calc_dn(indices_c(1:npc),:),&
              &  dbeta_dn_path_f,eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),&
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc), &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dn,ptg_i,frq_i)
d1805 7
a1811 7
            Call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dv,         &
              &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(indices_c(1:npc),:),&
              &  sps_path(indices_c(1:npc),:),do_calc_dv(indices_c(1:npc),:),&
              &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),&
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc), &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dv,ptg_i,frq_i)
d1815 1
a1815 1
          endif
d1817 4
a1820 4
          Call Deallocate_test ( gl_inds, 'gl_inds', ModuleName )
          Call Deallocate_test ( beta_path_f, 'beta_path_f', ModuleName )
          Call Deallocate_test ( gl_ndx, 'gl_ndx', ModuleName )
          Call Deallocate_Test ( gl_indgen, 'gl_indgen', ModuleName )
d1823 2
a1824 2
            & Call Deallocate_test (dbeta_dt_path_f, 'dbeta_dt_path_f', &
            & ModuleName )
d1827 3
a1829 3
            Call Deallocate_test(dbeta_dw_path_f,'dbeta_dw_path_f',ModuleName)
            Call Deallocate_test(dbeta_dn_path_f,'dbeta_dn_path_f',ModuleName)
            Call Deallocate_test(dbeta_dv_path_f,'dbeta_dv_path_f',ModuleName)
d1835 1
a1835 1
            & Call Trace_End ('ForwardModel.Frequency ',index=frq_i)
d1840 1
a1840 1
          & Call Trace_End ( 'ForwardModel.FrequencyLoop' )
d1850 1
a1850 1
          & Call trace_begin ( 'ForwardModel.FrequencyAvg' )
d1860 1
a1860 1
              & Call MLSMessage ( MLSMSG_Error, ModuleName, &
d1863 1
a1863 1
            Call Freq_Avg ( frequencies, &
d1889 1
a1889 1
                  Call Freq_Avg ( frequencies, &
d1934 1
a1934 1
                      Call Freq_Avg ( frequencies, &
d1943 1
a1943 1
              else                        ! Else not frequency averaging
d1979 1
a1979 1
                  if(k == 1) sv_i = 1
d1983 1
a1983 1
                        Call Freq_Avg ( frequencies, &
d1993 1
a1993 1
              else                        ! Else not frequency averaging
d1995 1
a1995 1
                  if(k == 1) sv_i = 1
d2023 1
a2023 1
                  if(k == 1) sv_i = 1
d2027 1
a2027 1
                        Call Freq_Avg ( frequencies, &
d2037 1
a2037 1
              else                        ! Else not frequency averaging
d2039 1
a2039 1
                  if(k == 1) sv_i = 1
d2067 1
a2067 1
                  if(k == 1) sv_i = 1
d2071 1
a2071 1
                        Call Freq_Avg ( frequencies, &
d2081 1
a2081 1
              else                        ! Else not frequency averaging
d2083 1
a2083 1
                  if(k == 1) sv_i = 1
d2101 1
a2101 1
          & Call trace_end ( 'ForwardModel.FrequencyAvg' )
d2104 1
a2104 1
          & Call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )
d2107 1
a2107 1
           & Call DEALLOCATE_TEST(frequencies,'frequencies',ModuleName )
d2113 1
a2113 1
        & Call Trace_End ( 'ForwardModel.PointingLoop' )
d2118 1
a2118 1
        & Call trace_begin ( 'ForwardModel.Convolution' )
d2122 2
a2123 2
      Call allocate_test ( superset, size(antennaPatterns), &
        & 'superset', ModuleName )
d2145 1
a2145 1
        IF ( FwdModelConf%do_conv ) THEN
d2154 1
a2154 1
            Call MLSMessage ( MLSMSG_Error, ModuleName, &
d2158 1
a2158 3
          where ( superset < 0 )
            superset = maxSuperset + 1
          end where
d2164 2
a2165 2
          IF (.not. temp_der .AND. .not. atmos_der ) THEN
            Call convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2172 2
a2173 2
          ELSE IF ( temp_der .AND. .not. atmos_der ) THEN
            Call convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2182 2
a2183 2
          ELSE IF ( atmos_der .AND. .not. temp_der ) THEN
            Call convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2191 2
a2192 2
          ELSE
            Call convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2203 1
a2203 1
          ENDIF
d2205 1
a2205 1
        ELSE          ! No convolution needed ..
d2208 2
a2209 2
          IF (.not. temp_der .AND. .not. atmos_der ) THEN
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2215 2
a2216 2
          ELSE IF ( temp_der .AND. .not. atmos_der ) THEN
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2223 2
a2224 2
          ELSE IF ( atmos_der .AND. .not. temp_der ) THEN
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2231 2
a2232 2
          ELSE
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, chanInd, &
d2240 1
a2240 1
          ENDIF
d2242 1
a2242 1
        ENDIF
d2246 1
a2246 1
      Call deallocate_test ( superset, 'superset', ModuleName )
d2248 1
a2248 1
        & Call trace_end ( 'ForwardModel.Convolution' )
d2251 7
a2257 1
      Call Deallocate_test ( Radv, 'RadV', ModuleName )
d2259 5
a2263 13
      if ( temp_der ) then
        Call Deallocate_test ( k_temp_frq, 'k_temp_frq', ModuleName )
      endif

      if (atmos_der) then
         Call Deallocate_test ( k_atmos_frq, 'k_atmos_frq', ModuleName )
      endif

      if (spect_der) then
        Call Deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq', ModuleName )
        Call Deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq', ModuleName )
        Call Deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq', ModuleName )
      endif
d2266 1
a2266 1
        & Call trace_end ( 'ForwardModel.sideband ',index=thisSideband )
d2271 1
a2271 1
      & Call Trace_End ( 'ForwardModel.SidebandLoop' )
d2281 1
a2281 1
    Call GetNameOfSignal(firstSignal, molName)
d2284 1
a2284 1
      if(molName(j:j) == '.') then
d2286 2
a2287 2
        EXIT
      endif
d2314 1
a2314 1
      Allocate(PrtRad(k), STAT=i)
d2333 1
a2333 1
      Deallocate(PrtRad, STAT=i)
d2342 2
a2343 2
        & Call Deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
        & ModuleName )
d2349 1
a2349 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d2353 1
a2353 1
      deallocate ( beta_group(i)%cat_index, stat=j)
d2357 2
a2358 2
    deallocate ( mol_cat_index, stat=j)
    deallocate ( beta_group, stat=j)
d2360 3
a2362 3
    Call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    Call Deallocate_test ( channelOrigins, 'channelOrigins', ModuleName )
    Call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )
d2365 1
a2365 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d2368 1
a2368 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d2371 1
a2371 1
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
d2376 2
a2377 2
    Call Deallocate_test ( z_glGrid, 'z_glGrid', ModuleName )
    Call Deallocate_test ( p_glGrid, 'z_glGrid', ModuleName )
d2379 61
a2439 61
    Call Deallocate_test ( h_glgrid, 'h_glgrid', ModuleName )
    Call Deallocate_test ( t_glgrid, 't_glgrid', ModuleName )
    Call Deallocate_test ( dhdz_glgrid, 'dhdz_glgrid', ModuleName )
    Call Deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', ModuleName )
    Call Deallocate_test ( ddhidhidtl0, 'ddhidhidtl0', ModuleName )

    Call Deallocate_test ( tan_inds, 'tan_inds', ModuleName )
    Call Deallocate_test ( tan_press, 'tan_press', ModuleName )
    Call Deallocate_test ( tan_phi, 'tan_phi', ModuleName )
    Call Deallocate_test ( est_scgeocalt, 'est_scgeocalt', ModuleName )
    Call Deallocate_test ( tan_temp, 'tan_temp', ModuleName )

    Call DestroyCompleteSlabs ( gl_slabs )
    Call destroygrids_t(grids_f)
    Call destroygrids_t(grids_tmp)

    Call Deallocate_test ( dhdz_path, 'dhdz_path', ModuleName )
    Call Deallocate_test ( h_path,    'h_path',    ModuleName )
    Call Deallocate_test ( p_path,    'p_path',    ModuleName )
    Call Deallocate_test ( path_dsdh, 'path_dsdh', ModuleName )
    Call Deallocate_test ( phi_path,  'phi_path',  ModuleName )
    Call Deallocate_test ( t_path,    't_path',    ModuleName )
    Call Deallocate_test ( z_path,    'z_path',    ModuleName )

    Call Deallocate_test ( alpha_path_c, 'alpha_path_c', ModuleName )
    Call Deallocate_test ( incoptdepth,  'incoptdept',   ModuleName )
    Call Deallocate_test ( t_script,     't_script',     ModuleName )
    Call Deallocate_test ( tau,          'tau',          ModuleName )
    Call Deallocate_test ( del_s,        'del_s',        ModuleName )
    Call Deallocate_test ( do_gl,        'do_gl',        ModuleName )
    Call Deallocate_test ( indices_c,   'indices_c',   ModuleName )
    Call Deallocate_test ( n_path,       'n_path',       ModuleName )
    Call Deallocate_test ( ref_corr,     'ref_corr',     ModuleName )

    Call Deallocate_test ( beta_path_c, 'beta_path_c', ModuleName )
    Call Deallocate_test ( do_calc_zp, 'do_calc_zp', ModuleName )
    Call Deallocate_test ( do_calc_fzp, 'do_calc_fzp', ModuleName )
    Call Deallocate_test ( eta_zp, 'eta_zp', ModuleName )
    Call Deallocate_test ( eta_fzp, 'eta_fzp', ModuleName )
    Call Deallocate_test ( sps_path, 'sps_path', ModuleName )

    Call DEALLOCATE_TEST(tan_chi_out,'tan_chi_out',ModuleName )
    Call DEALLOCATE_TEST(dx_dh_out,'dx_dh_out',ModuleName )
    Call DEALLOCATE_TEST(dhdz_out,'dhdz_out',ModuleName )

    if(temp_der) then
      deallocate( k_temp, STAT=i)
      Call Deallocate_test ( dRad_dt, 'dRad_dt', ModuleName )
      Call Deallocate_test ( dbeta_dt_path_c, 'dbeta_dt_path_c', ModuleName )
      Call Deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
      Call Deallocate_test ( do_calc_hyd, 'do_calc_hyd', ModuleName )
      Call Deallocate_test ( do_calc_t, 'do_calc_t', ModuleName )
      Call Deallocate_test ( eta_zxp_t, 'eta_zxp_t', ModuleName )
      Call Deallocate_test ( tan_dh_dt, 'tan_dh_dt', ModuleName )
      Call Deallocate_test ( tan_d2h_dhdt, 'tan_d2h_dhdt', ModuleName )
      Call DEALLOCATE_TEST(dxdt_tan,'dxdt_tan',ModuleName )
      Call DEALLOCATE_TEST(d2xdxdt_tan,'d2xdxdt_tan',ModuleName )
      Call deallocate_test(dxdt_surface,'dxdt_surface',modulename)
      Call DestroyCompleteSlabs ( gl_slabs_p )
      Call DestroyCompleteSlabs ( gl_slabs_m )
    endif
d2442 2
a2443 2
      Call Deallocate_test ( k_atmos, 'k_atmos', ModuleName )
      Call Deallocate_test ( dRad_df, 'dRad_df', ModuleName )
d2446 1
a2446 1
    if(spect_der) then
d2448 22
a2469 22
      Call Deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', ModuleName )
      Call Deallocate_test ( dbeta_dn_path_c, 'dbeta_dn_path_c', ModuleName )
      Call Deallocate_test ( dbeta_dv_path_c, 'dbeta_dv_path_c', ModuleName )

      Call Deallocate_test ( do_calc_dw, 'do_calc_dw', ModuleName )
      Call Deallocate_test ( do_calc_dn, 'do_calc_dn', ModuleName )
      Call Deallocate_test ( do_calc_dv, 'do_calc_dv', ModuleName )

      Call Deallocate_test ( eta_zxp_dw, 'eta_zxp_dw', ModuleName )
      Call Deallocate_test ( eta_zxp_dn, 'eta_zxp_dn', ModuleName )
      Call Deallocate_test ( eta_zxp_dv, 'eta_zxp_dv', ModuleName )

      Call Deallocate_test ( drad_dw, 'drad_dw', ModuleName )
      Call Deallocate_test ( drad_dn, 'drad_dn', ModuleName )
      Call Deallocate_test ( drad_dv, 'drad_dv', ModuleName )

    endif

    Call Deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
    Call Deallocate_test ( radiances, 'radiances', ModuleName )
    Call Deallocate_test ( dx_dt, 'dx_dt', ModuleName )
    Call Deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )
d2474 1
a2474 1
      Call trace_end ( 'ForwardModel MAF=',fmStat%maf )
d2482 3
d2816 1
a2816 1
! Added Call to AllocateOneSlabs
@


2.84
log
@Checks whether the jacobian is present when setting internal
temp/atmos_der
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.83 2002/08/22 23:13:03 livesey Exp $"
a171 3
    integer, dimension(1) :: WHICHPOINTINGGRIDASARRAY ! Result of minloc
    integer, dimension(1) :: WHICHPATTERNASARRAY      ! Result of minloc

d1323 1
a1323 2
        whichPointingGridAsArray = minloc ( superset )
        whichPointingGrid = whichPointingGridAsArray(1)
d2171 1
a2171 2
          whichPatternAsArray = minloc ( superset )
          whichPattern = whichPatternAsArray(1)
d2496 4
@


2.83
log
@New intermediate frequency based frq_bases
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.82 2002/08/20 23:33:23 livesey Exp $"
d384 2
a385 2
    temp_der = FwdModelConf%temp_der
    atmos_der = FwdModelConf%atmos_der
d389 1
a389 1
    spect_der = .FALSE.    ! ** ZEBUG
d2501 3
@


2.82
log
@Fixed bug with handling of extinction
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.81 2002/08/20 22:37:04 livesey Exp $"
d1498 9
a1506 6
          Call eval_spect_path(Grids_dw,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dw(1:no_ele,:),eta_zxp_dw(1:no_ele,:))
          Call eval_spect_path(Grids_dn,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dn(1:no_ele,:),eta_zxp_dn(1:no_ele,:))
          Call eval_spect_path(Grids_dv,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dv(1:no_ele,:),eta_zxp_dv(1:no_ele,:))
d1520 4
a1523 3
        Call comp_sps_path_frq(Grids_f,Frq,eta_zp(1:no_ele,:), &
           & do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),      &
           & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1614 4
a1617 3
          Call comp_sps_path_frq(Grids_f,Frq,eta_zp(1:no_ele,:), &
            &  do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),      &
            &  do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d2501 3
@


2.81
log
@Moved uses inside routine
@
text
@d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.80 2002/08/02 00:12:07 bill Exp $"
d662 1
a662 1
        if ( l == l_extinction ) CYCLE
d680 1
a680 1
        if ( l == l_extinction ) CYCLE
d2496 3
@


2.80
log
@just testing
@
text
@a5 64
  use GLNP, only: NG, GX
  use MLSCommon, only: I4, R4, R8, RP, IP, FINDFIRST
  USE MLSFiles, only: get_free_lun
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS, &
                              &  DESTROYCOMPLETESLABS
  use COMP_ETA_DOCALC_NO_FRQ_M, only: comp_eta_docalc_no_frq
  use COMP_SPS_PATH_FRQ_M, only: comp_sps_path_frq
  use EVAL_SPECT_PATH_M, only: EVAL_SPECT_PATH
  use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR, PATH_DS_DH
  use TWO_D_HYDROSTATIC_M, only: two_d_hydrostatic
  use METRICS_M
  use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
  use GET_CHI_OUT_M, only: GET_CHI_OUT
  use GET_BETA_PATH_M, only: GET_BETA_PATH, beta_group_T
  use RAD_TRAN_M, only: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, &
                       &  DRAD_TRAN_DX
  use SLABS_SW_M, only: GET_GL_SLABS_ARRAYS
  use FREQ_AVG_M, only: FREQ_AVG
  use CONVOLVE_ALL_M, only: CONVOLVE_ALL
  use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
  use D_LINTRP_M, only: LINTRP
  use D_HUNT_M, only: hunt_zvi => HUNT

  use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY, &
                       &   GETVECTORQUANTITYBYTYPE, &
                       &   M_FullDerivatives

  use ForwardModelConfig, only: FORWARDMODELCONFIG_T
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, &
                                  &   FORWARDMODELSTATUS_T
  use AntennaPatterns_m, only: ANTENNAPATTERNS
  use FilterShapes_m, only: FILTERSHAPES
  use PointingGrid_m, only: POINTINGGRIDS

  USE Load_sps_data_m, ONLY: LOAD_SPS_DATA, Grids_T, destroygrids_t

  use MatrixModule_1, only: MATRIX_T
  use Trace_M, only: Trace_begin, Trace_end
  use Molecules, only: L_EXTINCTION, spec_tags
  use MLSSignals_m, only: SIGNAL_T, MATCHSIGNAL, ARESIGNALSSUPERSET, DUMP, &
                        & GetNameOfSignal
  use String_table, only: GET_STRING, DISPLAY_STRING
  use SpectroscopyCatalog_m, only: CATALOG_T, LINE_T, LINES, CATALOG
  use INTRINSIC, only: L_TEMPERATURE, L_RADIANCE, L_PHITAN, L_PTAN, &
    & L_ELEVOFFSET, LIT_INDICES, L_ISOTOPERATIO, L_VMR, &
    & L_ORBITINCLINATION, L_SPACERADIANCE, L_EARTHREFL, L_LOSVEL, &
    & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_REFGPH
  use Units, only: Deg2Rad
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate,&
    & MLSMSG_Error, MLSMSG_Warning
  USE MLSNumerics, ONLY: HUNT, INTERPOLATEVALUES
  use Toggles, only: Emit, Gen, Levels, Switches, Toggle
  use Allocate_Deallocate, only: ALLOCATE_TEST, DEALLOCATE_TEST
  use Output_m, only: OUTPUT
  use ManipulateVectorQuantities, only: findinstancewindow
  use Trace_M, only: Trace_begin, Trace_end
  USE Make_Z_Grid_M, only: MAKE_Z_GRID
  USE Geometry, only: earthrada,earthradb

  use Dump_0, only: DUMP

  use MatrixModule_0, only: M_ABSENT, M_BANDED, M_FULL
  use MatrixModule_1, only: CREATEBLOCK, FINDBLOCK, MATRIX_T

d14 1
a14 1
    & "$Id: FullForwardModel_m.f90,v 2.79 2002/07/31 23:27:54 bill Exp $"
d19 2
a20 1
CONTAINS
d26 64
d2496 3
@


2.79
log
@added feature to user supply grid points to the psig and tangent grids
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.78 2002/07/31 00:03:45 livesey Exp $"
d2181 2
a2182 1
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1), PTAN_DER=ptan_der )
d2495 3
@


2.78
log
@Embarassing bug fix, was seeking wrong vector quantity.
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.77 2002/07/30 20:03:59 livesey Exp $"
d886 14
d2494 3
@


2.77
log
@More sideband fixes
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.76 2002/07/30 20:03:19 livesey Exp $"
d2127 1
a2127 1
          & sideband=thisSideband )
d2480 3
@


2.76
log
@Fixed bug which had it using the wrong sideband ratio
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.75 2002/07/29 21:41:30 bill Exp $"
d2127 1
a2127 1
          & sideband=firstSignal%sideband )
d2480 3
@


2.75
log
@no changes, just debugging
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.74 2002/07/23 22:26:31 livesey Exp $"
a333 2
    type (VectorValue_T), pointer :: LOWERSIDEBANDRATIO ! The split sideband ratio to use
    type (VectorValue_T), pointer :: UPPERSIDEBANDRATIO ! The split sideband ratio to use
a468 8
    sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.TRUE. )
    lowerSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.TRUE., &
      & sideband = -1 )
    upperSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.TRUE., &
      & sideband = 1 )
a495 4
      if (.not. associated (sidebandRatio) .and. .not. &
        & ( associated ( lowerSidebandRatio) .and. associated ( upperSidebandRatio ) ) ) &
        & Call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
a2127 1

d2129 4
a2132 10
          if ( associated ( sidebandRatio ) ) then
            thisRatio = sidebandRatio%values(chanInd,1)
            if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
          else
            if ( thisSideband == -1 ) then
              thisRatio = lowerSidebandRatio%values(chanInd,1)
            else
              thisRatio = upperSidebandRatio%values(chanInd,1)
            end if
          end if
d2480 3
@


2.74
log
@Added ptan_der, set k_atmos to zero on creation
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.73 2002/07/19 23:35:49 bill Exp $"
a1648 4
! bills debug
!          WRITE(*,'(a)') 'beta path'
!          WRITE(*,'(3f12.4)') p_path(no_ele/2),t_path(no_ele/2), &
!               beta_path_c(npc/2,1)
d2501 3
@


2.73
log
@fixed undefined surf angle
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.72 2002/07/11 20:51:20 bill Exp $"
d165 1
a165 1
    logical :: temp_der, atmos_der, spect_der ! Flags for various derivatives
d453 2
a454 1
      & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule )
d543 3
d1250 1
d2192 1
a2192 1
               & Grids_f,Jacobian,fmStat%rows,SURF_ANGLE=surf_angle(1) )
d2202 1
a2202 1
               & DXDT_SURFACE=dxdt_surface)
d2210 1
a2210 1
               & DI_DF=DBLE(k_atmos(i,:,:)) )
d2222 1
a2222 1
               & DI_DF=DBLE(k_atmos(i,:,:)) )
d2234 2
a2235 1
              &  Radiances(:,i),thisRatio,mol_cat_index,fmStat%rows,Jacobian)
d2242 2
a2243 1
              &  DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),(/no_tan_hts,j/))) )
d2250 1
a2250 1
              &  DI_DF=DBLE(k_atmos(i,:,:)) )
d2259 1
a2259 1
              &  DI_DF=DBLE(k_atmos(i,:,:)) )
d2505 3
@


2.72
log
@fixed bug regarding req
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.71 2002/07/09 17:37:10 livesey Exp $"
d1102 30
d1644 4
d2498 3
@


2.71
log
@Fixed more DACs problems
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.70 2002/07/08 17:45:37 zvi Exp $"
d295 1
a295 1
    REAL(rp) :: cp2, sp2, surf_angle(1), one_dhdz(1), one_dxdh(1)
d310 1
d398 1
a398 1
           &  indices_c, tan_inds, tan_press )
d423 1
a423 1
      &     d2xdxdt_surface)
d805 2
d810 4
a813 4
    cp2 = COS(Deg2Rad*SUM(phitan%values(:,maf))/phitan%template%nosurfs)**2
    sp2 = 1.0_rp - cp2
    req = 0.001_rp*sqrt((earthrada**4*sp2 + earthradc**4*cp2) / &
        & (earthrada**2*cp2 + earthradc**2*sp2))
d834 1
a834 1
         & req,tan_chi_out,dhdz_out,dx_dh_out,&
d845 1
a845 1
         & req,tan_chi_out,dhdz_out,dx_dh_out)
d864 1
a864 1
         & req,tan_chi_out,dhdz_out,dx_dh_out, &
d880 1
a880 1
         & req,tan_chi_out,dhdz_out,dx_dh_out, &
d1086 1
a1086 1
           & req,surf_angle,one_dhdz,one_dxdh, &
d1098 1
a1098 1
           & req,surf_angle,one_dhdz,one_dxdh,  &
d1103 1
a1459 1

d2464 3
@


2.70
log
@Make sure spect_der is turned off for now
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.69 2002/07/05 07:52:45 zvi Exp $"
d106 1
d2098 1
d2107 1
a2107 1
            thisRatio = sidebandRatio%values(channel,1)
d2111 1
a2111 1
              thisRatio = lowerSidebandRatio%values(channel,1)
d2113 1
a2113 1
              thisRatio = upperSidebandRatio%values(channel,1)
a2141 1
          channel = channel + 1 - channelOrigins(i)
d2146 1
a2146 1
               & channel,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
d2153 1
a2153 1
               & channel,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
d2163 1
a2163 1
               & channel,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
d2172 1
a2172 1
               & channel,windowStart,windowFinish,mol_cat_index,temp,ptan,  &
d2188 1
a2188 1
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
d2194 1
a2194 1
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
d2201 1
a2201 1
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
d2209 1
a2209 1
            Call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
d2461 3
@


2.69
log
@Coor. switch (phi,z) -> (z,phi)
@
text
@d49 2
a50 1
  use intrinsic, only: L_TEMPERATURE, L_RADIANCE, L_PHITAN, L_PTAN, L_ELEVOFFSET, &
d52 1
a52 2
    & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_VMR, L_REFGPH, &
    & LIT_INDICES, L_ISOTOPERATIO
d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.68 2002/06/28 21:41:36 livesey Exp $"
d88 1
a88 1
                             &  FwdModelOut, oldIfm, FmStat, Jacobian )
d155 3
a157 3
    integer :: F_DW_LEN                 ! Length of DW in vector
    integer :: F_DN_LEN                 ! Length of DN in vector
    integer :: F_DV_LEN                 ! Length of DV in vector
a383 1
    spect_der = FwdModelConf%spect_der
d386 4
d787 10
a796 3
    Call load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
     &   firstSignal%radiometer, mol_cat_index, p_len, f_len, h2o_ind, &
     &   ext_ind, Grids_f, Grids_dw, Grids_dn, Grids_dv, temp, My_Catalog)
d1224 3
a1226 3
      f_dw_len = SUM(Grids_dw%no_z(:) * Grids_dw%no_p(:) * Grids_dw%no_f(:))
      f_dn_len = SUM(Grids_dn%no_z(:) * Grids_dn%no_p(:) * Grids_dn%no_f(:))
      f_dv_len = SUM(Grids_dv%no_z(:) * Grids_dv%no_p(:) * Grids_dv%no_f(:))
d1228 1
a1228 1
      Call Allocate_test ( do_calc_dw, no_ele, f_dw_len, 'do_calc_dw', &
d1230 1
a1230 1
      Call Allocate_test ( do_calc_dn, no_ele, f_dn_len, 'do_calc_dn', &
d1232 1
a1232 1
      Call Allocate_test ( do_calc_dv, no_ele, f_dv_len, 'do_calc_dv', &
d1235 1
a1235 1
      Call Allocate_test ( eta_zxp_dw, no_ele, f_dw_len, 'eta_zxp_dw', &
d1237 1
a1237 1
      Call Allocate_test ( eta_zxp_dn, no_ele, f_dn_len, 'eta_zxp_dn', &
d1239 1
a1239 1
      Call Allocate_test ( eta_zxp_dv, no_ele, f_dv_len, 'eta_zxp_dv', &
d1242 3
a1244 3
      Call Allocate_test ( drad_dw, f_dw_len, 'drad_dw', ModuleName )
      Call Allocate_test ( drad_dn, f_dn_len, 'drad_dn', ModuleName )
      Call Allocate_test ( drad_dv, f_dv_len, 'drad_dv', ModuleName )
d1358 1
a1358 1
        Call Allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_dw_len , &
d1360 1
a1360 1
        Call Allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_dn_len , &
d1362 1
a1362 1
        Call Allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_dv_len , &
d1465 1
d1758 1
a1758 1
            k_spect_dw_frq(frq_i,1:1:f_dw_len) = drad_dw(1:1:f_dw_len)
d1770 1
a1770 1
            k_spect_dn_frq(frq_i,1:f_dn_len) = drad_dn(1:f_dn_len)
d1782 1
a1782 1
            k_spect_dv_frq(frq_i,1:1:f_dv_len) = drad_dv(1:1:f_dv_len)
d2460 3
@


2.68
log
@Repeat of bug fix with atmos_der being deallocated in wrong place.
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.67 2002/06/28 11:06:46 zvi Exp $"
d265 2
a266 2
    REAL(rp), DIMENSION(:,:,:), POINTER :: DX_DT       ! (No_tan_hts, Tsurfs)
    REAL(rp), DIMENSION(:,:,:), POINTER :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
d282 1
a282 1
    REAL(rp), DIMENSION(:,:,:), POINTER :: TAN_DH_DT ! dH/dT at Tangent
d312 5
a316 4
    REAL(rp), DIMENSION(:,:,:), POINTER :: dxdt_tan
    REAL(rp), DIMENSION(:,:,:), POINTER :: d2xdxdt_tan
    REAL(rp), DIMENSION(:,:,:), POINTER :: dxdt_surface
    REAL(rp), DIMENSION(:,:,:), POINTER :: d2xdxdt_surface
a317 1
    REAL(rp), DIMENSION(:,:,:), POINTER :: tan_d2h_dhdt
d388 1
a388 1
      & call trace_begin ( 'ForwardModel, MAF=', index=fmstat%maf )
d416 3
a418 3
    NULLIFY(tan_press, tan_phi, est_scgeocalt, tan_chi_out,dx_dh_out, &
      & dxdt_tan, d2xdxdt_tan, ddhidhidtl0, tan_d2h_dhdt, dhdz_out, &
      & dxdt_surface, d2xdxdt_surface)
d431 1
a431 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d435 1
a435 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d483 1
a483 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d486 1
a486 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d489 1
a489 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d493 1
a493 1
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d502 1
a502 1
        & call MLSMessage(MLSMSG_Error,ModuleName, &
d515 1
a515 1
        &    fwdModelConf%signals(1)%sideband ) ) call MLSMessage ( &
d539 1
a539 1
    CALL findinstancewindow(temp,phitan,maf,fwdModelConf%phiWindow, &
d545 4
a548 4
    CALL allocate_test(Grids_tmp%no_z,1,'Grids_tmp%no_z',modulename )
    CALL allocate_test(Grids_tmp%no_p,1,'Grids_tmp%no_p',modulename )
    CALL allocate_test(Grids_tmp%no_f,1,'Grids_tmp%no_f',modulename )
    CALL allocate_test(Grids_tmp%windowstart,1,'Grids_tmp%windowstart',&
d550 1
a550 1
    CALL allocate_test(Grids_tmp%windowfinish,1,'Grids_tmp%windowfinish',&
d552 1
a552 1
    call Allocate_test(Grids_tmp%lin_log,1,'lin_log',ModuleName )
d564 1
a564 1
    CALL allocate_test(Grids_tmp%zet_basis,n_t_zeta,'Grids_tmp%zet_basis',&
d566 1
a566 1
    CALL allocate_test(Grids_tmp%phi_basis,no_sv_p_t,'Grids_tmp%phi_basis',&
d568 3
a570 3
    CALL allocate_test(Grids_tmp%frq_basis,1,'Grids_tmp%frq_basis',ModuleName)
    CALL allocate_test(Grids_tmp%values,k,'Grids_tmp%values',ModuleName)
    CALL allocate_test(Grids_tmp%deriv_flags,k,'Grids_tmp%deriv_flags',&
d595 1
a595 1
        & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
d600 1
a600 1
    call allocate_test ( usedChannels, noUsedChannels, &
d602 1
a602 1
    call allocate_test ( channelOrigins, noUsedChannels, &
d604 1
a604 1
    call allocate_test ( usedSignals, noUsedChannels, &
d637 1
a637 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d644 1
a644 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d650 1
a650 1
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d653 1
a653 1
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d715 1
a715 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d724 1
a724 1
          call Allocate_test ( my_catalog(j)%lines, 0, &
d734 1
a734 1
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
d760 2
a761 2
          call get_string ( lit_indices(l), molName )
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
d764 1
a764 1
        call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
d767 1
a767 1
        call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
d774 1
a774 1
        call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
d784 1
a784 1
    CALL load_sps_data (FwdModelConf,  FwdModelIn, FwdModelExtra, FmStat, &
d800 1
a800 1
    CALL ALLOCATE_TEST(tan_chi_out,ptan%template%nosurfs,'tan_chi_out', &
d802 1
a802 1
    CALL ALLOCATE_TEST(dx_dh_out,ptan%template%nosurfs,'dx_dh_out', &
d804 1
a804 1
    CALL ALLOCATE_TEST(dhdz_out,ptan%template%nosurfs,'dhdz_out', &
d815 1
a815 1
      CALL get_chi_out(ptan%values(:,maf), Deg2Rad*phitan%values(:,maf), &
d826 1
a826 1
      CALL get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d833 4
a836 4
      CALL ALLOCATE_TEST(dxdt_tan,ptan%template%nosurfs, &
           & no_sv_p_t, temp%template%nosurfs,'dxdt_tan',ModuleName )
      CALL ALLOCATE_TEST(d2xdxdt_tan,ptan%template%nosurfs, &
           & no_sv_p_t, temp%template%nosurfs,'d2xdxdt_tan',ModuleName )
d845 1
a845 1
      CALL get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d857 5
a861 5
      CALL ALLOCATE_TEST(dxdt_tan,ptan%template%nosurfs, &
         & no_sv_p_t,temp%template%nosurfs,'dxdt_tan',ModuleName )
      CALL ALLOCATE_TEST(d2xdxdt_tan,ptan%template%nosurfs, &
         & no_sv_p_t,temp%template%nosurfs,'d2xdxdt_tan',ModuleName )
      CALL get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
d875 1
a875 1
    CALL Allocate_Test (z_all,temp%template%nosurfs+2,'z_all', ModuleName )
d898 1
a898 1
      CALL allocate_test (z_tmp, j, 'z_tmp', ModuleName )
d903 2
a904 2
      CALL Deallocate_test(z_all,'z_all',ModuleName)
      CALL Allocate_test(z_all,SIZE(z_tmp),'z_all',ModuleName)
d906 1
a906 1
      CALL Deallocate_Test(z_tmp,'z_tmp',ModuleName)
d913 1
a913 1
    CALL allocate_test (z_tmp, j, 'z_tmp', ModuleName )
d918 2
a919 2
    CALL Deallocate_test(z_all,'z_all',ModuleName)
    CALL Allocate_test(z_all,SIZE(z_tmp),'z_all',ModuleName)
d921 1
a921 1
    CALL Deallocate_Test(z_tmp,'z_tmp',ModuleName)
d925 2
a926 2
    CALL make_z_grid(z_all,z_psig,rec_tan_inds)
    CALL Deallocate_test(z_all,'z_all',ModuleName)
d937 10
a946 10
    call Allocate_test ( xm, NLm1, 'xm', ModuleName )
    call Allocate_test ( ym, NLm1, 'ym', ModuleName )
    call Allocate_test ( zgx, Ngp1, 'zgx', ModuleName )

    call Allocate_test ( z_glGrid, maxVert, 'z_glGrid', ModuleName )
    call Allocate_test ( p_glGrid, maxVert, 'p_glGrid', ModuleName )

    call allocate_test ( h_glgrid, maxVert, no_sv_p_t, 'h_glgrid', ModuleName )
    call allocate_test ( t_glgrid, maxVert, no_sv_p_t, 't_glgrid', ModuleName )
    call allocate_test ( dhdz_glgrid, maxVert, no_sv_p_t, 'dhdz_glgrid', &
d948 4
a951 4
    call allocate_test ( dh_dt_glgrid, maxVert, no_sv_p_t, n_t_zeta, &
      &  'dh_dt_glgrid', ModuleName )
    call allocate_test ( ddhidhidtl0, maxVert, no_sv_p_t, n_t_zeta, &
      &  'ddhidhidtl0', ModuleName )
d965 4
a968 4
    call Deallocate_test ( xm, 'xm', ModuleName )
    call Deallocate_test ( ym, 'ym', ModuleName )
    call Deallocate_test ( zgx,'zgx', ModuleName )
    CALL Deallocate_test ( z_psig, 'z_psig', ModuleName)
d978 1
a978 1
      & call Trace_Begin ( 'ForwardModel.Hydrostatic' )
d991 4
a994 4
    call allocate_test (tan_inds, no_tan_hts, 'tan_inds', ModuleName )
    call allocate_test (tan_press, no_tan_hts, 'tan_press', ModuleName )
    call allocate_test (tan_phi, no_tan_hts, 'tan_phi', ModuleName )
    call allocate_test (est_scgeocalt,no_tan_hts,'est_scgeocalt',ModuleName )
d996 1
a996 1
    CALL Deallocate_test(rec_tan_inds,'rec_tan_inds',ModuleName)
d1012 39
a1050 4
    CALL interpolatevalues(ptan%values(:,maf), phitan%values(:,maf), &
       & tan_press(j+1:no_tan_hts), tan_phi(j+1:no_tan_hts),METHOD = 'L')
    CALL interpolatevalues(ptan%values(:,maf), scgeocalt%values(:,maf), &
       & tan_press(j+1:no_tan_hts),est_scgeocalt(j+1:no_tan_hts),METHOD='L')
d1055 3
a1057 4
      CALL allocate_test(dxdt_surface,1,no_sv_p_t,n_t_zeta, &
                      & 'dxdt_surface',modulename)
      CALL allocate_test(d2xdxdt_surface,1,no_sv_p_t,n_t_zeta, &
                      & 'd2xdxdt_surface',modulename)
d1064 1
a1064 1
        &         grids_f%no_f(1:h2o_ind))
d1066 2
a1067 2
        &         grids_f%no_f(h2o_ind) + 1
        CALL get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1079 1
a1079 1
        CALL get_chi_out(tan_press(1:1),deg2rad*tan_phi(1:1), &
d1087 1
a1087 1
      CALL deallocate_test(d2xdxdt_surface,'d2xdxdt_surface',modulename)
d1094 1
a1094 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1098 1
a1098 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1102 1
a1102 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
d1104 1
a1104 1
    call allocate_test ( tan_temp, no_tan_hts, 'tan_temp', ModuleName )
d1113 1
a1113 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1120 1
a1120 1
        call AllocateOneSlabs ( gl_slabs(j,i), nl )
d1127 1
a1127 1
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d1135 2
a1136 2
          call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
          call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
d1148 24
a1171 24
    call Allocate_test ( dhdz_path, no_ele, 'dhdz_path', ModuleName )
    call Allocate_test ( h_path,    no_ele, 'h_path',    ModuleName )
    call Allocate_test ( p_path,    no_ele, 'p_path',    ModuleName )
    call Allocate_test ( path_dsdh, no_ele, 'path_dsdh', ModuleName )
    call Allocate_test ( phi_path,  no_ele, 'phi_path',  ModuleName )
    call Allocate_test ( t_path,    no_ele, 't_path',    ModuleName )
    call Allocate_test ( z_path,    no_ele, 'z_path',    ModuleName )

    call Allocate_Test ( alpha_path_c, npc, 'alpha_path_c', ModuleName )
    call Allocate_Test ( incoptdepth,  npc, 'incoptdept',   ModuleName )
    call Allocate_Test ( t_script,     npc, 't_script',     ModuleName )
    call Allocate_Test ( tau,          npc, 'tau',          ModuleName )
    call Allocate_test ( del_s,        npc, 'del_s',        ModuleName )
    call Allocate_test ( do_gl,        npc, 'do_gl',        ModuleName )
    call Allocate_test ( indices_c,   npc, 'indices_c',    ModuleName )
    call Allocate_test ( n_path,       npc, 'n_path',       ModuleName )
    call Allocate_test ( ref_corr,     npc, 'ref_corr',     ModuleName )

    call Allocate_test ( beta_path_c, npc, no_mol, 'beta_path_c', ModuleName )
    call Allocate_test ( do_calc_fzp, no_ele, f_len, 'do_calc_fzp', ModuleName )
    call Allocate_test ( do_calc_zp, no_ele, p_len, 'do_calc_zp', ModuleName )
    call Allocate_test ( eta_zp, no_ele, p_len, 'eta_zp', ModuleName )
    call Allocate_test ( eta_fzp, no_ele, f_len, 'eta_fzp', ModuleName )
    call Allocate_test ( sps_path, no_ele, no_mol, 'sps_path', ModuleName )
d1177 1
a1177 1
!      CALL allocate_test ( k_temp,noUsedChannels, no_tan_hts, n_t_zeta, &
d1181 2
a1182 2
      call Allocate_test ( dRad_dt, sv_t_len, 'dRad_dt', ModuleName )
      call Allocate_test ( dbeta_dt_path_c,npc,no_mol,'dbeta_dt_path_c', &
d1184 1
a1184 1
      call Allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', &
d1186 1
a1186 1
      call Allocate_test ( do_calc_hyd, no_ele, sv_t_len, 'do_calc_hyd', &
d1188 1
a1188 1
      call Allocate_test ( do_calc_t, no_ele, sv_t_len, 'do_calc_t', &
d1190 1
a1190 1
      call Allocate_test ( eta_zxp_t, no_ele, sv_t_len, 'eta_zxp_t', &
d1192 2
a1193 5
      CALL Allocate_test ( tan_dh_dt, 1, no_sv_p_t, n_t_zeta, 'tan_dh_dt', &
      &  ModuleName )

      CALL Allocate_test (tan_d2h_dhdt, 1, no_sv_p_t, n_t_zeta, &
      &  'tan_d2h_dhdt', ModuleName )
d1198 2
a1199 2
      call Allocate_test ( dRad_df, f_len, 'dRad_df', ModuleName )
      CALL allocate_test(k_atmos,noUsedChannels,no_tan_hts,f_len,'k_atmos',& 
d1207 1
a1207 1
      call Allocate_test ( dbeta_dw_path_c, npc, no_mol, &
d1209 1
a1209 1
      call Allocate_test ( dbeta_dn_path_c, npc, no_mol, &
d1211 1
a1211 1
      call Allocate_test ( dbeta_dv_path_c, npc, no_mol, &
d1218 1
a1218 1
      call Allocate_test ( do_calc_dw, no_ele, f_dw_len, 'do_calc_dw', &
d1220 1
a1220 1
      call Allocate_test ( do_calc_dn, no_ele, f_dn_len, 'do_calc_dn', &
d1222 1
a1222 1
      call Allocate_test ( do_calc_dv, no_ele, f_dv_len, 'do_calc_dv', &
d1225 1
a1225 1
      call Allocate_test ( eta_zxp_dw, no_ele, f_dw_len, 'eta_zxp_dw', &
d1227 1
a1227 1
      call Allocate_test ( eta_zxp_dn, no_ele, f_dn_len, 'eta_zxp_dn', &
d1229 1
a1229 1
      call Allocate_test ( eta_zxp_dv, no_ele, f_dv_len, 'eta_zxp_dv', &
d1232 3
a1234 3
      call Allocate_test ( drad_dw, f_dw_len, 'drad_dw', ModuleName )
      call Allocate_test ( drad_dn, f_dn_len, 'drad_dn', ModuleName )
      call Allocate_test ( drad_dv, f_dv_len, 'drad_dv', ModuleName )
d1238 6
a1243 8
    call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', &
      &    ModuleName )
    call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
      & 'radiances', ModuleName )
    CALL allocate_test ( dx_dt, no_tan_hts, no_sv_p_t,n_t_zeta, 'dx_dt', &
      &  ModuleName )
    CALL allocate_test ( d2x_dxdt,no_tan_hts,no_sv_p_t,n_t_zeta, 'd2x_dxdt', &
                      &  ModuleName )
d1246 1
a1246 1
      & call Trace_End ( 'ForwardModel.Hydrostatic' )
d1249 1
a1249 1
      & call Trace_Begin ( 'ForwardModel.SidebandLoop' )
d1254 1
a1254 1
        & call Trace_Begin ( 'ForwardModel.Sideband ', index=thisSideband )
d1263 1
a1263 1
        call allocate_test ( superset, size(pointingGrids), &
d1269 2
a1270 2
        if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "No matching pointing frequency grids." )
d1277 1
a1277 1
        call deallocate_test ( superset, 'superset', ModuleName )
d1281 3
a1283 3
        call allocate_test ( grids, no_tan_hts, "Grids", ModuleName )
        call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
                 &  tan_press, grids, allowTopValue=.TRUE.,nearest=.true.)
d1300 2
a1301 3
          if ( shapeInd == 0 ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            &    "No matching channel shape information" )
d1311 2
a1312 2
        call allocate_test ( frequencies,noUsedChannels, "frequencies", &
          &   ModuleName )
d1318 1
a1318 1
            &     frequencies(usedChannels(channel))
d1326 1
a1326 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1329 1
a1329 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d1336 1
a1336 1
      call Allocate_test ( RadV, maxNoPtgFreqs, 'RadV', ModuleName )
d1339 1
a1339 1
        & call Allocate_test (k_temp_frq,maxNoPtgFreqs,sv_t_len,'k_temp_frq', &
d1343 1
a1343 1
        call Allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
d1348 6
a1353 6
        call Allocate_test ( k_spect_dw_frq , maxNoPtgFreqs, f_dw_len , &
          & 'k_spect_dw_frq', ModuleName )
        call Allocate_test ( k_spect_dn_frq , maxNoPtgFreqs, f_dn_len , &
          & 'k_spect_dn_frq', ModuleName )
        call Allocate_test ( k_spect_dv_frq , maxNoPtgFreqs, f_dv_len , &
          & 'k_spect_dv_frq', ModuleName )
d1357 1
a1357 1
        & call Trace_Begin ( 'ForwardModel.PointingLoop' )
d1362 1
a1362 1
          & call Trace_Begin ( 'ForwardModel.Pointing ', index=ptg_i )
d1372 1
a1372 1
        indices_c(:) = 0
d1384 1
a1384 1
          & call Trace_Begin ( 'ForwardModel.MetricsEtc' )
d1393 1
a1393 1
            CALL metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1399 1
a1399 1
              &  NEG_H_TAN=(/neg_tan_ht/),DHTDTL0=tan_dh_dt,&
d1408 1
a1408 1
            CALL metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1423 1
a1423 1
            CALL metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1437 1
a1437 1
            CALL metrics((/tan_phi(ptg_i)*Deg2Rad/),(/tan_inds(ptg_i)/),     &
d1448 6
a1453 9
          call eval_spect_path(Grids_dw,z_path(1:no_ele), &
            &  phi_path(1:no_ele),do_calc_dw(1:no_ele,:),         &
            &  eta_zxp_dw(1:no_ele,:))
          call eval_spect_path(Grids_dn,z_path(1:no_ele), &
            &  phi_path(1:no_ele),do_calc_dn(1:no_ele,:),         &
            &  eta_zxp_dn(1:no_ele,:))
          call eval_spect_path(Grids_dv,z_path(1:no_ele), &
            &  phi_path(1:no_ele),do_calc_dv(1:no_ele,:),         &
            &  eta_zxp_dv(1:no_ele,:))
d1458 1
a1458 1
        call comp_eta_docalc_no_frq(Grids_f,z_path(1:no_ele), &
d1466 4
a1469 3
        call comp_sps_path_frq(Grids_f,Frq,eta_zp(1:no_ele,:), &
      &  do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),&
      &  do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1471 1
a1471 1
          call refractive_index(p_path(indices_c(1:npc)), &
d1475 1
a1475 1
          call refractive_index(p_path(indices_c(1:npc)), &
d1480 1
a1480 1
          call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
d1482 2
a1483 2
             & ptg_angles(ptg_i),r,1.0_rp,tan_dh_dt(1,:,:),            &
             & tan_d2h_dhdt(1,:,:),dx_dt(ptg_i,:,:),d2x_dxdt(ptg_i,:,:))
d1485 1
a1485 1
          call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2),&
d1490 1
a1490 1
        call comp_refcor(Req+h_path(indices_c(1:npc)), 1.0_rp+n_path(1:npc), &
d1496 1
a1496 1
          &   Req+one_tan_ht(1))
d1498 1
a1498 1
          &          Req+one_tan_ht(1))
d1504 1
a1504 1
        call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1510 1
a1510 1
          call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1513 1
a1513 1
          call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
d1533 1
a1533 1
          call allocate_test ( frequencies,noFreqs, "frequencies", ModuleName )
d1545 1
a1545 1
          & call Trace_End ( 'ForwardModel.MetricsEtc' )
d1548 1
a1548 1
          & call Trace_Begin ( 'ForwardModel.FrequencyLoop' )
d1552 1
a1552 1
            & call Trace_Begin ('ForwardModel.Frequency ',index=frq_i)
d1559 3
a1561 3
          call comp_sps_path_frq(Grids_f,Frq,eta_zp(1:no_ele,:), &
        &  do_calc_zp(1:no_ele,:),sps_path(1:no_ele,:),&
        &  do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1565 2
a1566 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &  my_Catalog,beta_group,gl_slabs,indices_c(1:npc),         &
d1577 2
a1578 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &  my_Catalog, beta_group,gl_slabs,indices_c(1:npc),        &
d1586 2
a1587 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),        &
              &  my_Catalog,beta_group,gl_slabs,indices_c(1:npc),           &
d1594 2
a1595 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),  &
              &  my_Catalog, beta_group,gl_slabs,indices_c(1:npc),    &
d1601 1
a1601 1
                                &   beta_path_c(1:npc,:),DIM=2)
d1603 3
a1605 2
          call path_contrib(alpha_path_c(1:npc),del_s(1:npc),e_rflty, &
          &  fwdModelConf%tolerance,tau(1:npc),incoptdepth(1:npc),do_gl(1:npc))
d1612 6
a1617 6
          call Allocate_test ( gl_inds, j, 'gl_inds', ModuleName )
          call Allocate_test ( beta_path_f, j, no_mol, 'beta_path_f', &
                           &   ModuleName )
          call Allocate_test ( gl_indgen, Ng, no_gl_ndx, 'gl_indgen', &
                           &   ModuleName )
          call Allocate_test ( gl_ndx, no_gl_ndx, 2, 'gl_ndx', ModuleName )
d1638 1
a1638 1
          j = Ng*no_gl_ndx
d1641 1
a1641 1
            call Allocate_test ( dbeta_dt_path_f, j, no_mol, &
d1643 1
a1643 1
            call Allocate_test ( dbeta_dw_path_f, j, no_mol, &
d1645 1
a1645 1
            call Allocate_test ( dbeta_dn_path_f, j, no_mol, &
d1647 1
a1647 1
            call Allocate_test ( dbeta_dv_path_f, j, no_mol, &
d1650 1
a1650 1
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1659 1
a1659 1
            call Allocate_test ( dbeta_dt_path_f, j, no_mol, &
d1661 1
a1661 1
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1669 7
a1675 7
            call Allocate_test ( dbeta_dw_path_f, j, no_mol, &
              & 'dbeta_dw_path_f', ModuleName )
            call Allocate_test ( dbeta_dn_path_f, j, no_mol, &
              & 'dbeta_dn_path_f', ModuleName )
            call Allocate_test ( dbeta_dv_path_f, j, no_mol, &
              & 'dbeta_dv_path_f', ModuleName )
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
d1682 1
a1682 1
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
d1689 2
a1690 2
          call rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,              &
            & z_path(indices_c(1:npc)),t_path(indices_c(1:npc)),          &
d1702 6
a1707 7
            CALL drad_tran_df(z_path(indices_c(1:npc)), &
              &  Grids_f,beta_path_c(1:npc,:),                           &
              &  eta_fzp(indices_c(1:npc),:),sps_path(indices_c(1:npc),:),&
              &  do_calc_fzp(indices_c(1:npc),:),beta_path_f,              &
              &  eta_fzp(gl_inds,:),sps_path(gl_inds,:),                    &
              &  do_calc_fzp(gl_inds,:),do_gl(1:npc),del_s(1:npc),          &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),     &
d1716 1
a1716 1
            call drad_tran_dt(z_path(indices_c(1:npc)),                      &
d1718 4
a1721 4
              & t_path(indices_c(1:npc)),dh_dt_path(indices_c(1:npc),:),    &
              & alpha_path_c(1:npc),SUM(sps_path(indices_c(1:npc),:)         &
              & * dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),     &
              & eta_zxp_t(indices_c(1:npc),:),do_calc_t(indices_c(1:npc),:),&
d1723 6
a1728 6
              & Req + one_tan_ht(1),dh_dt_path(brkpt,:),frq,do_gl(1:npc),     &
              & req + h_path(gl_inds),t_path(gl_inds),dh_dt_path(gl_inds,:),  &
              & SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),                   &
              & SUM(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),   &
              & eta_zxp_t(gl_inds,:),do_calc_t(gl_inds,:),path_dsdh(gl_inds), &
              & dhdz_path(gl_inds),t_script(1:npc),tau(1:npc),i_stop,drad_dt, &
d1739 1
a1739 1
            call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dw,          &
d1741 4
a1744 5
              &  sps_path(indices_c(1:npc),:),                            &
              &  do_calc_dw(indices_c(1:npc),:),dbeta_dw_path_f,          &
              &  eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),                &
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),          &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),    &
d1747 1
a1747 1
            k_spect_dw_frq(frq_i,:) = drad_dw
d1751 1
a1751 1
            call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dn,         &
d1753 4
a1756 5
              &  sps_path(indices_c(1:npc),:),                           &
              &  do_calc_dn(indices_c(1:npc),:),dbeta_dn_path_f,         &
              &  eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),               &
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),         &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),   &
d1759 1
a1759 1
            k_spect_dn_frq(frq_i,:) = drad_dn
d1763 1
a1763 1
            call drad_tran_dx(z_path(indices_c(1:npc)),Grids_dv,         &
d1765 4
a1768 5
              &  sps_path(indices_c(1:npc),:),                           &
              &  do_calc_dv(indices_c(1:npc),:),dbeta_dv_path_f,         &
              &  eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),               &
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),         &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),   &
d1771 1
a1771 1
            k_spect_dv_frq(frq_i,:) = drad_dv
d1775 4
a1778 4
          call Deallocate_test ( gl_inds, 'gl_inds', ModuleName )
          call Deallocate_test ( beta_path_f, 'beta_path_f', ModuleName )
          call Deallocate_test ( gl_ndx, 'gl_ndx', ModuleName )
          call Deallocate_Test ( gl_indgen, 'gl_indgen', ModuleName )
d1781 1
a1781 1
            & call Deallocate_test (dbeta_dt_path_f, 'dbeta_dt_path_f', &
d1785 3
a1787 3
            call Deallocate_test(dbeta_dw_path_f,'dbeta_dw_path_f',ModuleName)
            call Deallocate_test(dbeta_dn_path_f,'dbeta_dn_path_f',ModuleName)
            call Deallocate_test(dbeta_dv_path_f,'dbeta_dv_path_f',ModuleName)
d1793 1
a1793 1
            & call Trace_End ('ForwardModel.Frequency ',index=frq_i)
d1798 1
a1798 1
          & call Trace_End ( 'ForwardModel.FrequencyLoop' )
d1808 1
a1808 1
          & call trace_begin ( 'ForwardModel.FrequencyAvg' )
d1818 1
a1818 1
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
d1821 1
a1821 1
            call Freq_Avg ( frequencies, &
d1824 1
a1824 1
              &    RadV, noFreqs, k, Radiances(ptg_i,i) )
d1847 1
a1847 1
                  call Freq_Avg ( frequencies, &
d1892 1
a1892 1
                      call Freq_Avg ( frequencies, &
a1927 1
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d1941 1
a1941 1
                        call Freq_Avg ( frequencies, &
a1971 1
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d1985 1
a1985 1
                        call Freq_Avg ( frequencies, &
a2015 1
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d2029 1
a2029 1
                        call Freq_Avg ( frequencies, &
d2059 1
a2059 1
          & call trace_end ( 'ForwardModel.FrequencyAvg' )
d2062 1
a2062 1
          & call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )
d2065 1
a2065 1
           & CALL DEALLOCATE_TEST(frequencies,'frequencies',ModuleName )
d2071 1
a2071 1
        & call Trace_End ( 'ForwardModel.PointingLoop' )
d2076 1
a2076 1
        & call trace_begin ( 'ForwardModel.Convolution' )
d2080 1
a2080 1
      call allocate_test ( superset, size(antennaPatterns), &
d2118 1
a2118 1
            call MLSMessage ( MLSMSG_Error, ModuleName, &
d2133 1
a2133 1
            CALL convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2140 1
a2140 1
            CALL convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2150 1
a2150 1
            CALL convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2156 2
a2157 1
               & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2159 1
a2159 1
            CALL convolve_all(FwdModelConf,FwdModelIn,FwdModelExtra,maf,&
d2168 2
a2169 1
               & DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2194 2
a2195 1
              &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2203 2
a2204 1
              &  DI_DF=DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))) )
d2211 1
a2211 1
      call deallocate_test ( superset, 'superset', ModuleName )
d2213 1
a2213 1
        & call trace_end ( 'ForwardModel.Convolution' )
d2216 1
a2216 1
      call Deallocate_test ( Radv, 'RadV', ModuleName )
d2219 1
a2219 1
        call Deallocate_test ( k_temp_frq, 'k_temp_frq', ModuleName )
d2223 1
a2223 1
         call Deallocate_test ( k_atmos_frq, 'k_atmos_frq', ModuleName )
d2227 3
a2229 3
        call Deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq', ModuleName )
        call Deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq', ModuleName )
        call Deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq', ModuleName )
d2233 1
a2233 1
        & call trace_end ( 'ForwardModel.sideband ',index=thisSideband )
d2238 1
a2238 1
      & call Trace_End ( 'ForwardModel.SidebandLoop' )
d2309 1
a2309 1
        & call Deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
d2316 1
a2316 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2327 3
a2329 3
    call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    call Deallocate_test ( channelOrigins, 'channelOrigins', ModuleName )
    call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )
d2332 1
a2332 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2335 1
a2335 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2338 1
a2338 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d2343 2
a2344 2
    call Deallocate_test ( z_glGrid, 'z_glGrid', ModuleName )
    call Deallocate_test ( p_glGrid, 'z_glGrid', ModuleName )
d2346 44
a2389 44
    call Deallocate_test ( h_glgrid, 'h_glgrid', ModuleName )
    call Deallocate_test ( t_glgrid, 't_glgrid', ModuleName )
    call Deallocate_test ( dhdz_glgrid, 'dhdz_glgrid', ModuleName )
    call Deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', ModuleName )
    call Deallocate_test ( ddhidhidtl0, 'ddhidhidtl0', ModuleName )

    call Deallocate_test ( tan_inds, 'tan_inds', ModuleName )
    call Deallocate_test ( tan_press, 'tan_press', ModuleName )
    call Deallocate_test ( tan_phi, 'tan_phi', ModuleName )
    call Deallocate_test ( est_scgeocalt, 'est_scgeocalt', ModuleName )
    call Deallocate_test ( tan_temp, 'tan_temp', ModuleName )

    call DestroyCompleteSlabs ( gl_slabs )
    call destroygrids_t(grids_f)
    call destroygrids_t(grids_tmp)

    call Deallocate_test ( dhdz_path, 'dhdz_path', ModuleName )
    call Deallocate_test ( h_path,    'h_path',    ModuleName )
    call Deallocate_test ( p_path,    'p_path',    ModuleName )
    call Deallocate_test ( path_dsdh, 'path_dsdh', ModuleName )
    call Deallocate_test ( phi_path,  'phi_path',  ModuleName )
    call Deallocate_test ( t_path,    't_path',    ModuleName )
    call Deallocate_test ( z_path,    'z_path',    ModuleName )

    call Deallocate_test ( alpha_path_c, 'alpha_path_c', ModuleName )
    call Deallocate_test ( incoptdepth,  'incoptdept',   ModuleName )
    call Deallocate_test ( t_script,     't_script',     ModuleName )
    call Deallocate_test ( tau,          'tau',          ModuleName )
    call Deallocate_test ( del_s,        'del_s',        ModuleName )
    call Deallocate_test ( do_gl,        'do_gl',        ModuleName )
    call Deallocate_test ( indices_c,   'indices_c',   ModuleName )
    call Deallocate_test ( n_path,       'n_path',       ModuleName )
    call Deallocate_test ( ref_corr,     'ref_corr',     ModuleName )

    call Deallocate_test ( beta_path_c, 'beta_path_c', ModuleName )
    call Deallocate_test ( do_calc_zp, 'do_calc_zp', ModuleName )
    call Deallocate_test ( do_calc_fzp, 'do_calc_fzp', ModuleName )
    call Deallocate_test ( eta_zp, 'eta_zp', ModuleName )
    call Deallocate_test ( eta_fzp, 'eta_fzp', ModuleName )
    call Deallocate_test ( sps_path, 'sps_path', ModuleName )

    CALL DEALLOCATE_TEST(tan_chi_out,'tan_chi_out',ModuleName )
    CALL DEALLOCATE_TEST(dx_dh_out,'dx_dh_out',ModuleName )
    CALL DEALLOCATE_TEST(dhdz_out,'dhdz_out',ModuleName )
d2393 13
a2405 13
      call Deallocate_test ( dRad_dt, 'dRad_dt', ModuleName )
      call Deallocate_test ( dbeta_dt_path_c, 'dbeta_dt_path_c', ModuleName )
      call Deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
      call Deallocate_test ( do_calc_hyd, 'do_calc_hyd', ModuleName )
      call Deallocate_test ( do_calc_t, 'do_calc_t', ModuleName )
      call Deallocate_test ( eta_zxp_t, 'eta_zxp_t', ModuleName )
      call Deallocate_test ( tan_dh_dt, 'tan_dh_dt', ModuleName )
      call Deallocate_test ( tan_d2h_dhdt, 'tan_d2h_dhdt', ModuleName )
      CALL DEALLOCATE_TEST(dxdt_tan,'dxdt_tan',ModuleName )
      CALL DEALLOCATE_TEST(d2xdxdt_tan,'d2xdxdt_tan',ModuleName )
      CALL deallocate_test(dxdt_surface,'dxdt_surface',modulename)
      call DestroyCompleteSlabs ( gl_slabs_p )
      call DestroyCompleteSlabs ( gl_slabs_m )
d2409 2
a2410 2
      call Deallocate_test ( k_atmos, 'k_atmos', ModuleName )
      call Deallocate_test ( dRad_df, 'dRad_df', ModuleName )
d2415 15
a2429 15
      call Deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', ModuleName )
      call Deallocate_test ( dbeta_dn_path_c, 'dbeta_dn_path_c', ModuleName )
      call Deallocate_test ( dbeta_dv_path_c, 'dbeta_dv_path_c', ModuleName )

      call Deallocate_test ( do_calc_dw, 'do_calc_dw', ModuleName )
      call Deallocate_test ( do_calc_dn, 'do_calc_dn', ModuleName )
      call Deallocate_test ( do_calc_dv, 'do_calc_dv', ModuleName )

      call Deallocate_test ( eta_zxp_dw, 'eta_zxp_dw', ModuleName )
      call Deallocate_test ( eta_zxp_dn, 'eta_zxp_dn', ModuleName )
      call Deallocate_test ( eta_zxp_dv, 'eta_zxp_dv', ModuleName )

      call Deallocate_test ( drad_dw, 'drad_dw', ModuleName )
      call Deallocate_test ( drad_dn, 'drad_dn', ModuleName )
      call Deallocate_test ( drad_dv, 'drad_dv', ModuleName )
d2433 4
a2436 4
    call Deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
    call Deallocate_test ( radiances, 'radiances', ModuleName )
    call Deallocate_test ( dx_dt, 'dx_dt', ModuleName )
    call Deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )
d2441 1
a2441 1
      call trace_end ( 'ForwardModel MAF=',fmStat%maf )
d2449 3
d2731 1
a2731 1
! Added call to AllocateOneSlabs
@


2.67
log
@Now computing dI/dPtan using chain rule
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.66 2002/06/26 19:58:48 livesey Exp $"
a2198 1
         call Deallocate_test ( k_atmos, 'k_atmos', ModuleName )
d2385 1
d2425 3
@


2.66
log
@Bug fix with DAC channel numbering
@
text
@d25 1
a25 1
! use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.65 2002/06/24 21:11:24 zvi Exp $"
d163 1
a163 1
    logical :: DOTHIS                   ! Flag for lines
d293 2
a294 1
    REAL(rp) :: cp2, sp2, surf_angle(1)
d307 2
a386 4
! ** ZEBUG
!    Print *,' temp_der, atmos_der, spect_der:',temp_der,atmos_der,spect_der
! ** END ZEBUG

d392 2
a393 2
    nullify ( grids, usedchannels, channelOrigins, usedsignals, superset, indices_c, &
      &       tan_inds, tan_press )
d416 2
a417 2
    NULLIFY(tan_press, tan_phi, est_scgeocalt, tan_chi_out, &
      & dxdt_tan, d2xdxdt_tan, ddhidhidtl0, tan_d2h_dhdt, &
d802 4
d819 2
a820 2
         & orbIncline%values(1,maf)*Deg2Rad, &
         & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
d830 2
a831 2
         & orbIncline%values(1,maf)*Deg2Rad, &
         & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out)
d849 2
a850 2
         & orbIncline%values(1,maf)*Deg2Rad, &
         & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
d865 2
a866 2
         & orbIncline%values(1,maf)*Deg2Rad, &
         & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
d1037 2
a1038 2
           & orbIncline%values(1,maf)*Deg2Rad, &
           & elevoffset%values(1,1)*Deg2Rad,req,surf_angle, &
d1049 2
a1050 2
           & orbIncline%values(1,maf)*Deg2Rad, &
           & elevoffset%values(1,1)*Deg2Rad,req,surf_angle, &
d1371 1
a1371 1
              &  NEG_H_TAN = (/neg_tan_ht/),DHTDTL0=tan_dh_dt,               &
d1454 4
a1457 4
          call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2),    &
          &    one_tan_ht(1),tan_phi(ptg_i)*Deg2Rad,Req,0.0_rp, &
          &    ptg_angles(ptg_i),tan_dh_dt(1,:,:),tan_d2h_dhdt(1,:,:), &
          &    dx_dt(ptg_i,:,:),d2x_dxdt(ptg_i,:,:))
d1459 3
a1461 3
          call get_chi_angles(0.001*est_scGeocAlt(ptg_i),n_path(npc/2), &
          &    one_tan_ht(1),tan_phi(ptg_i)*Deg2Rad,Req,0.0_rp, &
          &    ptg_angles(ptg_i))
d2108 1
a2108 1
          ! Now change channel from starting at 0 or 1 to definately 1
d2110 1
d2116 2
a2117 1
               & thisRatio,antennaPatterns(whichPattern),Grids_tmp%deriv_flags,&
d2123 2
a2124 1
               & thisRatio,antennaPatterns(whichPattern),Grids_tmp%deriv_flags,&
d2133 2
a2134 1
               & thisRatio,antennaPatterns(whichPattern),Grids_tmp%deriv_flags,&
d2141 2
a2142 1
               & thisRatio,antennaPatterns(whichPattern),Grids_tmp%deriv_flags,&
d2152 30
a2181 6
          WRITE(*,'(a)') 'no convolve feature is not working'
!         call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
!           &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
!           &  ptg_angles, tan_chi_out, Radiances(:,i), k_temp(i,:,:,:),&
!           &  k_atmos(i,:,:,:,:,:), thisRatio, Jacobian, fmStat%rows,  &
!           &  mol_cat_index )
d2365 2
d2425 3
@


2.65
log
@Adding Grids_tmp stracture and modifying calling sequences
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.61 2002/06/17 17:12:15 bill Exp $"
d174 1
d385 1
a385 1
    Print *,' temp_der, atmos_der, spect_der:',temp_der,atmos_der,spect_der
d393 1
a393 1
    nullify ( grids, usedchannels, usedsignals, superset, indices_c, &
d603 2
d611 3
a613 2
          usedChannels(channel) = i + &
            & lbound(fwdModelConf%signals(sigInd)%frequencies,1) - 1
d2104 3
a2106 1
!
d2273 1
d2391 3
@


2.64
log
@Bug fixing and correcting Log entries
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.63 2002/06/24 21:01:28 zvi Exp $"
a2383 3
! Revision 2.63  2002/06/24 21:01:28  zvi
! Adding Grids_tmp stracture and modify calling sequences
!
@


2.63
log
@*** empty log message ***
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.61 2002/06/17 17:12:15 bill Exp $"
d2384 3
@


2.62
log
@fixed deallocation bug?--wgr
@
text
@a196 2
    logical, dimension(:), pointer :: T_DERIV_FLAG

d344 1
a344 1
    type (Grids_T) :: Grids_f   ! All the coordinates
d348 1
d397 1
a397 1
           &  do_calc_hyd, do_calc_t, do_calc_fzp, t_deriv_flag )
d537 1
a537 1
  !  Get some dimensions that we'll use a lot
a538 1
    ! Work out the `window' stuff for temperature.
d540 2
a541 1
    & windowStart, windowFinish)
d543 46
a588 1
    sv_t_len = n_t_zeta*no_sv_p_t
a589 1
    ! Work out which channels are used, also check we have radiances for them.
d808 2
a809 4
      CALL get_chi_out(ptan%values(:,maf), deg2rad*phitan%values(:,maf), &
         & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
         & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
         & RESHAPE(temp%values(:,windowStart:windowFinish),(/sv_t_len/)),&
d820 1
a820 4
         & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
         & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
         & RESHAPE(temp%values(:,windowStart:windowFinish), &
         & (/sv_t_len/)), &
d839 1
a839 3
         & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
         & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
         & RESHAPE(temp%values(:,windowStart:windowFinish),(/sv_t_len/)),&
d855 1
a855 4
         & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
         & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
         & RESHAPE(temp%values(:,windowStart:windowFinish), &
         & (/sv_t_len/)), &
d973 1
a973 3
    Call two_d_hydrostatic(temp%template%surfs(:,1),  &
      &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
      &  temp%values(:,windowStart:windowFinish), &
d1027 1
a1027 4
           & 0.001_rp*est_scgeocalt(1:1), temp%template%surfs(:,1), &
           & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
           & RESHAPE(temp%values(:,windowStart:windowFinish), &
           & (/sv_t_len/)), &
d1039 1
a1039 4
           & 0.001_rp*est_scgeocalt(1:1), temp%template%surfs(:,1), &
           & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
           & RESHAPE(temp%values(:,windowStart:windowFinish), &
           & (/sv_t_len/)), &
a1138 9
      call Allocate_test ( t_deriv_flag, sv_t_len, 't_deriv_flag', ModuleName )

      t_deriv_flag(1:sv_t_len) = .TRUE.  ! ** Initialize to ALL derivatives

! ** Loading the Temp. derivative coeff. flag according to the L2CF

      IF(associated(temp%mask)) t_deriv_flag = RESHAPE((IAND( &
        & M_FullDerivatives,ICHAR(temp%mask(:,WindowStart:WindowFinish)))==0), &
        & (/sv_t_len/))
d1359 2
a1360 3
              &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,      &
              &  z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid,                     &
              &  Deg2Rad*orbIncline%values(1,maf),t_deriv_flag,              &
d1368 1
a1368 1
              &  Z_BASIS = temp%template%surfs(:,1),                         &
d1374 1
a1374 2
              &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,      &
              &  z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid,                     &
d1389 1
a1389 2
              &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,      &
              &  z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid,                     &
d1391 1
a1391 1
              &  t_deriv_flag,h_path(1:no_ele),phi_path(1:no_ele),           &
d1397 1
a1397 1
              &  Z_BASIS = temp%template%surfs(:,1),                         &
d1403 1
a1403 2
              &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,      &
              &  z_glgrid,h_glgrid,t_glgrid,dhdz_glgrid,                     &
a1449 2
          &    t_path(no_ele/2), 1.0 / dhdz_path(no_ele/2), &
          &    TRANSPOSE(RESHAPE(eta_zxp_t(no_ele/2,:),(/n_t_zeta,no_sv_p_t/))), &
d2106 1
a2106 1
               & thisRatio,antennaPatterns(whichPattern),t_deriv_flag,      &
d2112 1
a2112 1
               & thisRatio,antennaPatterns(whichPattern),t_deriv_flag,      &
d2121 1
a2121 1
               & thisRatio,antennaPatterns(whichPattern),t_deriv_flag,      &
d2128 1
a2128 1
               & thisRatio,antennaPatterns(whichPattern),t_deriv_flag,      &
d2161 1
d2298 1
d2326 1
d2328 1
a2328 2
!     CALL deallocate_test ( k_temp, 'k_temp', Modulename )
      deallocate( k_temp)
a2336 1
      call Deallocate_test ( t_deriv_flag, 't_deriv_flag', ModuleName )
a2345 1
      call Deallocate_test ( k_atmos, 'k_atmos', ModuleName )
@


2.61
log
@fixed yet another bug--wgr
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.60 2002/06/17 16:30:52 bill Exp $"
d1438 2
a2146 2
!       CALL deallocate_test ( k_temp, 'k_temp', Modulename )
        deallocate( k_temp)
a2150 1
         call Deallocate_test ( k_atmos, 'k_atmos', ModuleName )
d2315 2
d2335 1
d2374 3
@


2.60
log
@inc zvis changes--wgr
@
text
@d78 1
a78 1
    & "$Id: FullForwardModel_m.f90,v 2.58 2002/06/13 22:40:38 bill Exp $"
d941 2
a942 1
      &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,temp%values,&
d2372 3
@


2.59
log
@fixing bugs--wgr
@
text
@a0 1
!*******************  Bill's version ****************
d24 2
a25 4
! use CONVOLVE_ALL_M, only: CONVOLVE_ALL
!  USE Convolve_all_v2_m, only: Convolve_all_v2
  USE fov_convolve_v2_m, only: fov_convolve_v2
!  use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
d82 3
a84 1
  !---------------------------------------------------------------------------
d86 2
a87 4
contains ! ================================ FullForwardModel routine ======

  ! -----------------------------------------------  ForwardModel  -----
  Subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
d89 2
a90 2
    ! This is the full radiative transfer forward model, the workhorse
    ! code
a121 1
    integer :: ROW, COL                 ! Rows & colomns matrix indecies
a131 1
    integer :: NOMAFS                   ! Number of major frames
a138 1
    integer :: N_T_PHI                  ! Number of phis for temperature
d164 2
a200 1
    real(rp) :: CENTER_ANGLE            ! For angles
a309 1
    REAL(rp), DIMENSION(:), POINTER :: tan
a316 8
! remove when debug is done
!
    REAL(rp), DIMENSION(:,:), POINTER :: drad_dt_out
    REAL(rp), DIMENSION(:,:), POINTER :: drad_df_out
    REAL(rp), DIMENSION(:,:), POINTER :: test1
    REAL(rp), DIMENSION(:,:), POINTER :: test2
    REAL(rp), DIMENSION(:,:), POINTER :: test3
!
d379 8
a386 1
    Print *,'** ForwardModel - Bill'                    ! ** ZEBUG
d418 2
a419 2
      & dxdt_tan, d2xdxdt_tan, ddhidhidtl0, tan_d2h_dhdt, drad_dt_out, &
      & dxdt_surface, d2xdxdt_surface, test1, test2, test3, drad_df_out)
a531 1
    n_t_phi = temp%template%noInstances
a534 1
    noMAFs = firstRadiance%template%noInstances
d756 1
a756 1
    IF (h2o_ind > 0 .and. .not. FwdModelConf%temp_der) THEN
d762 1
a762 1
      &         grids_f%no_f(1:h2o_ind))
d764 1
a764 1
      &         grids_f%no_f(h2o_ind) + 1
d768 1
a768 2
         & RESHAPE(temp%values(:,windowStart:windowFinish), &
         & (/sv_t_len/)), &
d777 1
a777 1
    ELSE IF (h2o_ind == 0 .and. .not. FwdModelConf%temp_der) THEN
d787 1
a787 1
    ELSE IF (h2o_ind > 0 .and.  FwdModelConf%temp_der) THEN
d797 1
a797 1
      &         grids_f%no_f(1:h2o_ind))
d799 1
a799 1
      &       grids_f%no_f(h2o_ind) + 1
d803 1
a803 2
         & RESHAPE(temp%values(:,windowStart:windowFinish), &
         & (/sv_t_len/)), &
d980 1
a980 1
    IF (FwdModelConf%temp_der) THEN
d1057 1
a1057 1
    if(FwdModelConf%temp_der) then
d1106 1
a1106 1
    if(FwdModelConf%temp_der) then
d1108 1
a1108 1
      ! Allocation for metrics routine when Temp. derivative is needed:
d1111 1
a1111 1
!      & no_sv_p_t, 'k_temp',modulename)
d1120 2
a1121 2
      & M_FullDerivatives,ICHAR(temp%mask(:,WindowStart:WindowFinish)))==0), &
      & (/sv_t_len/))
d1139 1
d1142 1
a1142 1
    if ( FwdModelConf%atmos_der ) then
d1144 3
a1146 3
      CALL allocate_test(k_atmos,noUsedChannels,no_tan_hts,f_len, &
        & 'k_atmos', modulename)
    end if
d1148 1
a1148 1
    if(FwdModelConf%spect_der) then
d1286 1
a1286 1
      if (fwdModelConf%temp_der) &
d1290 3
a1292 4
      if (fwdModelConf%atmos_der) then

          call Allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
        &   ModuleName )
d1295 1
a1295 1
      if (fwdModelConf%spect_der) then
d1339 1
a1339 1
          if(FwdModelConf%temp_der) then
d1371 1
a1371 1
          if(FwdModelConf%temp_der) then
d1399 1
a1399 1
        if(FwdModelConf%spect_der) then
d1433 1
a1433 1
        if(FwdModelConf%temp_der) then
d1462 1
a1462 1
        if(FwdModelConf%temp_der) then
d1490 3
d1494 1
a1496 2
! VELOCITY shift correction to frequency grid
!
d1517 1
a1517 1
          if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then
d1529 1
a1529 1
          else if(FwdModelConf%temp_der) then
d1538 1
a1538 1
          else if(FwdModelConf%spect_der) then
d1592 1
a1592 1
          if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then
d1610 1
a1610 1
          else if(FwdModelConf%temp_der) then
d1620 1
a1620 1
          else if(FwdModelConf%spect_der) then
d1653 1
a1653 1
          if(FwdModelConf%atmos_der) then
d1668 1
a1668 1
          if(FwdModelConf%temp_der) then
d1689 1
a1689 1
          if(FwdModelConf%spect_der) then
d1737 1
a1737 1
          if ( FwdModelConf%temp_der ) &
d1741 1
a1741 1
          if ( FwdModelConf%spect_der ) then
d1793 1
a1793 1
        if ( fwdModelConf%temp_der ) then
d1831 2
a1832 2
        if ( fwdModelConf%atmos_der ) then

d1847 2
a1848 2
                  do instance = grids_f%WindowStart(k), grids_f%WindowFinish(k)
                    DO surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
d1850 3
a1852 3
                        & FilterShapes(shapeInd)%FilterGrid, &
                        & FilterShapes(shapeInd)%FilterShape, &
                        & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
d1862 2
a1863 2
                  do instance = grids_f%WindowStart(k), grids_f%WindowFinish(k)
                    DO surface = 1, Grids_f%no_f(k)*Grids_f%no_z(k)
d1872 1
a1872 1

d1879 1
a1879 1
        if ( fwdModelConf%spect_der ) then
a2042 3
      k = ptan%template%nosurfs
      Allocate(PrtRad(ptan%template%nosurfs),STAT=i)

d2069 1
a2069 1
        if ( FwdModelConf%do_conv ) then
d2088 33
a2120 200
!          center_angle = ptg_angles(surfaceTangentIndex)
!
!  New code, from Bill, to eliminate the Temp. derivative jump ..
!
          IF (.not. FwdModelConf%temp_der .and. .not. FwdModelConf%atmos_der) &
          & then
            CALL fov_convolve_v2(antennaPatterns(whichPattern), &
            & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad)
            j = thisradiance%template%noChans
            do ptg_i = 1, ptan%template%nosurfs
              beg_ind = channel + thisradiance%template%noChans * (ptg_i - 1)
              thisRadiance%values(beg_ind,maf) = PrtRad(ptg_i)
            end do
          ELSE IF (FwdModelConf%atmos_der .and. .not. FwdModelConf%temp_der) &
          & then
            CALL ALLOCATE_TEST(drad_df_out,ptan%template%nosurfs,f_len, &
            & 'drad_df_out',ModuleName)
            CALL fov_convolve_v2(antennaPatterns(whichPattern), &
            & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad, &
            & DI_DF = DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))), &
            & DRAD_DF_OUT = drad_df_out)
! load into jacobian
! load into jacobian
            row = FindBlock( Jacobian%row, thisradiance%index, maf )
            fmStat%rows(row) = .true.

            do sps_i = 1, no_mol
              if (fwdModelConf%molecules(mol_cat_index(sps_i)) == &
            &   l_extinction ) then
                f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            &   quantityType=l_extinction,radiometer=firstSignal%radiometer )
              else
                f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            &   quantityType=l_vmr, &
            &   molecule=fwdModelConf%molecules(mol_cat_index(sps_i)))
              endif
              sv_t_len = 0
              DO jf = grids_f%windowStart(sps_i),grids_f%windowfinish(sps_i)
                col = FindBlock ( Jacobian%col, f%index, jf)
                select case ( Jacobian%block(row,col)%kind )
                case ( m_absent )
                  call CreateBlock ( Jacobian, row, col, m_full )
                  jacobian%block(row,col)%values = 0.0_r8
                case ( m_full )
                case default
                  call MLSMessage ( MLSMSG_Error, ModuleName, &
                  & 'Wrong type for temperature derivative matrix' )
                end select

                DO k = 1, grids_f%no_f(sps_i)*grids_f%no_z(sps_i)
 
! Check if derivatives are needed for this (zeta & phi) :

                  sv_t_len = sv_t_len + 1
                  if(.NOT. grids_f%deriv_flags(sv_t_len)) CYCLE

! run through representation basis coefficients

                  do ptg_i = 1, ptan%template%noSurfs
                    beg_ind = channel + thisradiance%template%noChans &
                  &         * (ptg_i-1)
                    jacobian%block(row,col)%values(beg_ind,k) = &
                  &   drad_df_out(ptg_i,sv_t_len)
                  end do
                end do
              enddo
            enddo
            call Deallocate_test ( drad_df_out, 'drad_df_out', ModuleName )
          ELSE IF (FwdModelConf%temp_der) then

            M = sv_t_len
            CALL ALLOCATE_TEST(test1,no_tan_hts,M,'test1',Modulename)
            CALL ALLOCATE_TEST(test2,no_tan_hts,M,'test2',Modulename)
            CALL ALLOCATE_TEST(test3,ptan%template%noSurfs,M,'test3',&
            & Modulename)
            CALL ALLOCATE_TEST(drad_dt_out,ptan%template%noSurfs,  &
            & M,'drad_dt_out',ModuleName)
!
            DO j = 1, no_sv_p_t
              DO k = 1, n_t_zeta
                r1 = dxdt_surface(1,j,k)
                test1(:,k+n_t_zeta*(j-1)) = dx_dt(:,j,k)
                test2(:,k+n_t_zeta*(j-1)) = d2x_dxdt(:,j,k)
! This arithmatic makes a surface value adjustment:
                test3(:,k+n_t_zeta*(j-1)) = dxdt_tan(:,j,k) - r1
              ENDDO
            ENDDO
            IF (FwdModelConf%atmos_der) then
              CALL ALLOCATE_TEST(drad_df_out,ptan%template%nosurfs,f_len, &
              & 'drad_df_out',ModuleName)
              CALL fov_convolve_v2(antennaPatterns(whichPattern), &
              & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad, &
              & SURF_ANGLE=surf_angle(1),DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),&
              & (/no_tan_hts,M/))),DX_DT=test1,DDX_DXDT=test2, &
              & DX_DT_OUT=test3,DRAD_DT_OUT=drad_dt_out, &
              & DI_DF = DBLE(RESHAPE(k_atmos(i,:,:),(/no_tan_hts,f_len/))), &
              & DRAD_DF_OUT = drad_df_out)
! load into jacobian
              row = FindBlock( Jacobian%row, thisradiance%index, maf )
              fmStat%rows(row) = .true.

              do sps_i = 1, no_mol
                if (fwdModelConf%molecules(mol_cat_index(sps_i)) == &
              &   l_extinction ) then
                  f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              &   quantityType=l_extinction,radiometer=firstSignal%radiometer )
                else
                  f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
              &   quantityType=l_vmr, &
              &   molecule=fwdModelConf%molecules(mol_cat_index(sps_i)))
                endif
                sv_t_len = 0
                DO jf = grids_f%windowStart(sps_i),grids_f%windowfinish(sps_i)
                  col = FindBlock ( Jacobian%col, f%index, jf)
                  select case ( Jacobian%block(row,col)%kind )
                  case ( m_absent )
                    call CreateBlock ( Jacobian, row, col, m_full )
                    jacobian%block(row,col)%values = 0.0_r8
                  case ( m_full )
                  case default
                    call MLSMessage ( MLSMSG_Error, ModuleName, &
                    & 'Wrong type for temperature derivative matrix' )
                  end select

                  DO k = 1, grids_f%no_f(sps_i)*grids_f%no_z(sps_i)
 
! Check if derivatives are needed for this (zeta & phi) :

                    sv_t_len = sv_t_len + 1
                    if(.NOT. grids_f%deriv_flags(sv_t_len)) CYCLE

! run through representation basis coefficients

                    do ptg_i = 1, ptan%template%noSurfs
                      beg_ind = channel + thisradiance%template%noChans &
                    &         * (ptg_i-1)
                      jacobian%block(row,col)%values(beg_ind,k) = &
                    &   drad_df_out(ptg_i,sv_t_len)
                    end do
                  end do
                enddo
              enddo
              call Deallocate_test ( drad_df_out, 'drad_df_out', ModuleName )
            ELSE
              CALL fov_convolve_v2(antennaPatterns(whichPattern), &
              & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad, &
              & SURF_ANGLE=surf_angle(1),DI_DT=DBLE(RESHAPE(k_temp(i,:,:,:),&
              & (/no_tan_hts,M/))),DX_DT=test1,DDX_DXDT=test2, &
              & DX_DT_OUT=test3,DRAD_DT_OUT=drad_dt_out)
            ENDIF
!
! Load the Radiance values into the Radiance structure:
!
            j = thisradiance%template%noChans
            do ptg_i = 1, ptan%template%noSurfs
              beg_ind = channel + thisradiance%template%noChans * (ptg_i - 1)
              thisRadiance%values(beg_ind,maf) = PrtRad(ptg_i)
            end do
!
! Load the Temp. derivative values into the Jacobian
!
            row = FindBlock( Jacobian%row, thisradiance%index, maf )
            fmStat%rows(row) = .true.

            sv_t_len = 0
            do jf = windowStart, windowFinish

              col = FindBlock ( Jacobian%col, temp%index, jf )
              select case ( Jacobian%block(row,col)%kind )
              case ( m_absent )
                call CreateBlock ( Jacobian, row, col, m_full )
                jacobian%block(row,col)%values = 0.0_r8
              case ( m_full )
              case default
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                  & 'Wrong type for temperature derivative matrix' )
              end select

              do k = 1, temp%template%noSurfs
 
! Check if derivatives are needed for this (zeta & phi) :

                sv_t_len = sv_t_len + 1
                if(.NOT. t_deriv_flag(sv_t_len)) CYCLE

! run through representation basis coefficients

                do ptg_i = 1, ptan%template%noSurfs
                  r1 = drad_dt_out(ptg_i,sv_t_len)
                  beg_ind = channel + thisradiance%template%noChans * (ptg_i-1)
                  jacobian%block(row,col)%values(beg_ind,k) = r1
                end do

              end do

            end do
            CALL DEALLOCATE_TEST(drad_dt_out,'drad_dt_out',ModuleName)
            CALL DEALLOCATE_TEST(test1,'test1',Modulename)
            CALL DEALLOCATE_TEST(test2,'test2',Modulename)
            CALL DEALLOCATE_TEST(test3,'test3',Modulename)
d2123 1
a2124 17
!      WRITE(*,'(a)') 'WARNING Two d antenna code not properly implemented!'
!      WRITE(*,'(a)') 'for general 2 d temperature coefficients'
!         call convolve_all ( fwdModelConf, fwdModelIn, maf, channel, &
!           &  windowStart, windowFinish, mafTInstance-windowStart+1, &
!           &  temp, ptan, thisRadiance, tan_press, ptg_angles,       &
!           &  tan_temp, RESHAPE(dx_dt(:,3,:),(/no_tan_hts,n_t_zeta/)), &
!           &  RESHAPE(d2x_dxdt(:,3,:),(/no_tan_hts,n_t_zeta/)),       &
!           &  surfaceTangentIndex, center_angle, Radiances(:,i), &
!           &  k_temp(i,:,:,:),         &
!           &  k_atmos(i,:,:,:,:,:), thisRatio, t_deriv_flag, Grids_f,&
!           &  Jacobian, fmStat%rows, antennaPatterns(whichPattern),  &
!           &  mol_cat_index, ier )
!??? Need to choose some index other than 1 for AntennaPatterns ???
!         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'convolve_all failed' )

        else          ! No convolution needed ..
d2126 7
a2132 7
!          call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel, &
!            &  windowStart, windowFinish, temp, ptan, thisRadiance,     &
!            &  ptg_angles, tan_chi_out, Radiances(:,i), k_temp(i,:,:,:),&
!            &  k_atmos(i,:,:,:,:,:), thisRatio, Jacobian, fmStat%rows,  &
!            &  mol_cat_index )

        end if
d2143 4
a2146 4
      if ( fwdModelConf%temp_der ) then
!          CALL deallocate_test ( k_temp, 'k_temp', Modulename )
          deallocate( k_temp)
          call Deallocate_test ( k_temp_frq, 'k_temp_frq', ModuleName )
d2149 1
a2149 1
      if (fwdModelConf%atmos_der) then
d2154 1
a2154 1
      if (fwdModelConf%spect_der) then
d2163 1
a2163 1
      deallocate(PrtRad,STAT=i)
a2164 2
      ! End of loop over sidebands ---------------------------------------------
    end do
d2314 1
a2314 1
    if(FwdModelConf%temp_der) then
d2331 1
a2331 1
    if ( FwdModelConf%atmos_der ) then
d2335 1
a2335 1
    if(FwdModelConf%spect_der) then
d2366 1
a2366 1
  end subroutine FullForwardModel
d2368 1
a2368 1
 end module FullForwardModel_m
@


2.58
log
@some variable name changes--wgr
@
text
@d81 1
a81 1
    & "$Id: FullForwardModel_m.f90,v 2.57 2002/06/11 22:20:10 bill Exp $"
d1501 1
a1505 2
        frequencies =  Vel_Cor * frequencies

d1856 8
a1863 10
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_f%no_z(k)
                      do jf = 1, Grids_f%no_f(k)
                        call Freq_Avg ( frequencies, &
                          & FilterShapes(shapeInd)%FilterGrid, &
                          & FilterShapes(shapeInd)%FilterShape, &
                          & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
                        k_atmos(i,ptg_i,sv_i) = r
                        sv_i = sv_i + 1
                      end do              ! Frequencies loop
d1871 4
a1874 6
                  do instance = WindowStart, WindowFinish
                    do surface = 1, Grids_f%no_z(k)
                      do jf = 1, Grids_f%no_f(k)
                        k_atmos(i,ptg_i,sv_i) = k_atmos_frq(i,sv_i)
                        sv_i = sv_i + 1
                      end do
d2053 1
a2053 1
      Allocate(PrtRad(k),STAT=i)
d2107 1
a2107 1
            & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad(1:L))
d2109 2
a2110 2
            do ptg_i = 1, L
              beg_ind = channel + j * (ptg_i - 1)
d2115 2
a2116 1
            CALL ALLOCATE_TEST(drad_df_out,L,f_len,'drad_df_out',ModuleName)
d2118 1
a2118 1
            & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad(1:L), &
a2170 1
            L = ptan%template%nosurfs
d2173 4
a2176 2
            CALL ALLOCATE_TEST(test3,      L   ,M,'test3',Modulename)
            CALL ALLOCATE_TEST(drad_dt_out,L,   M,'drad_dt_out',ModuleName)
d2188 2
a2189 1
              CALL ALLOCATE_TEST(drad_df_out,L,f_len,'drad_df_out',ModuleName)
d2191 1
a2191 1
              & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad(1:L), &
d2245 1
a2245 1
              & ptg_angles,Radiances(:,i),tan_chi_out,PrtRad(1:L), &
d2254 2
a2255 2
            do ptg_i = 1, L
              beg_ind = channel + j * (ptg_i - 1)
d2289 1
a2289 1
                  beg_ind = channel + j * (ptg_i-1)
d2568 3
@


2.57
log
@work in progress--wgr
@
text
@d1 1
d25 2
a26 1
  use CONVOLVE_ALL_M, only: CONVOLVE_ALL
d28 1
a28 1
  use NO_CONV_AT_ALL_M, only: NO_CONV_AT_ALL
d43 1
a43 1
  use Load_sps_data_m, only: LOAD_SPS_DATA, Grids_T
d63 1
a63 1
  use ManipulateVectorQuantities, only: FindOneClosestInstance
d70 3
d81 1
a81 1
    & "$Id: FullForwardModel_m.f90,v 2.56 2002/06/07 23:22:58 bill Exp $"
d125 1
a126 2
    integer :: MAFTINSTANCE             ! Temperature instance closest to 
                                        ! this MAF
a145 1
    integer :: PHIWINDOW                ! From fwdMdlConfig
d153 1
a153 1
    integer :: SURFACETANGENTINDEX      ! Index in tangent grid of earth's 
a188 1
    logical, dimension(:), pointer :: LIN_LOG ! Is this vmr on a log basis? (noSpecies)
a190 2
    logical, dimension(:), pointer :: SKIP_ETA_FRQ  ! 'Avoid non-freq. mol.'

d208 1
a208 1
    real(rp) :: NEG_TAN_HT              ! GP Height (in KM.) of tan. press. 
d240 1
a240 1
    real(rp), dimension(:), pointer :: RADV ! Radiances for 1 pointing on 
a242 1
    real(rp), dimension(:), pointer :: SPS_VALUES ! all vmrs (f_len)
d322 3
a324 1
! remove when debug is done    
d326 1
d330 1
a330 2
! bills debug
    integer(i4) :: lu_debug
d371 1
a371 1
    real(r4), dimension(:,:,:,:,:,:), pointer :: K_ATMOS
d393 2
a394 5
! bills debug
    if ( index(switches,'billsdebug') /= 0 ) then
      lu_debug = get_free_lun()
      OPEN(UNIT=lu_debug,FILE='debug.txt')
    endif
d403 1
a403 1
    nullify ( do_gl, lin_log )
d412 1
a412 1
      & ref_corr, sps_values, tau, t_path, t_script, xm, ym, zgx,&
d414 1
a414 1
      & z_all, z_tmp )
d423 1
a423 1
      & t_glgrid, dh_dt_glgrid, skip_eta_frq )
d426 1
a426 1
      & dxdt_surface, d2xdxdt_surface, test1, test2, test3) 
d507 1
a507 1
      &  ( fwdModelConf%signals(1)%singleSideband == 0 ) ) then 
d550 2
a551 5
    phiWindow = fwdModelConf%phiWindow
    mafTInstance = FindOneClosestInstance ( temp, firstRadiance, maf )
    windowStart  = max(1, mafTInstance - phiWindow/2)
!   windowFinish = min(mafTInstance + phiWindow/2, n_t_phi)
    windowFinish = min(WindowStart + phiWindow - 1, n_t_phi)  ! ** ZVI's suggestion
d553 1
d674 2
a675 1
    ! Work out which spectroscopy we're going to need ------------------------
d706 3
a708 1
  ! If we're only doing one sideband, maybe we can remove some more lines
d715 2
a716 1
        end do ! End loop over lines
d719 3
a721 1
        ! Check we have at least one line for this
d731 1
d733 1
d740 2
a741 3
    end do ! Loop over species

    ! Now, allocate other variables we're going to need later ----------------
d743 1
a743 1
    call Allocate_test ( skip_eta_frq, no_mol, 'skip_eta_frq', ModuleName )
d747 1
a747 1
    call load_sps_data ( fwdModelIn, fwdModelExtra, fwdModelConf%molecules, &
d749 2
a750 2
     &   ext_ind, lin_log, sps_values, Grids_f, Grids_dw, Grids_dn, Grids_dv, &
     &   temp, My_Catalog, skip_eta_frq )
d753 6
a758 4
    ! compute equivalent earth radius at phi_t(1), nearest surface
    earthradc = earthrada*earthradb &
    &         / SQRT(earthrada**2*SIN(Deg2Rad*orbIncline%values(1,maf))**2 &
    &         + earthradb**2*COS(Deg2Rad*orbIncline%values(1,maf))**2)
d761 2
a762 2
    req = 0.001_rp*sqrt((earthrada**4*sp2 + earthradc**4*cp2) &
    &   / (earthrada**2*cp2 + earthradc**2*sp2))
d764 1
a764 1
    & ModuleName ) 
d770 4
a773 4
      end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind)  &
      &       * grids_f%no_f(1:h2o_ind))
      beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) &
      &       * grids_f%no_f(h2o_ind) + 1
d775 12
a786 11
      & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
      & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
      & RESHAPE(temp%values(:,windowStart:windowFinish), &
      & (/temp%template%nosurfs * no_sv_p_t/)), &
      & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
      & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
      & orbIncline%values(1,maf)*Deg2Rad, &
      & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
      & h2o_zeta_basis = grids_f%zet_basis(beg_ind_z:end_ind_z), &
      & h2o_phi_basis = grids_f%phi_basis(beg_ind_p:end_ind_p), &
      & h2o_coeffs = sps_values(beg_ind:end_ind), lin_log = lin_log(h2o_ind))
d789 8
a796 8
      & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
      & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
      & RESHAPE(temp%values(:,windowStart:windowFinish), &
      & (/temp%template%nosurfs * no_sv_p_t/)), &
      & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
      & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
      & orbIncline%values(1,maf)*Deg2Rad, &
      & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out)
d799 1
a799 1
      & no_sv_p_t, temp%template%nosurfs,'dxdt_tan',ModuleName ) 
d801 9
a809 9
      & no_sv_p_t, temp%template%nosurfs,'d2xdxdt_tan',ModuleName ) 
      end_ind_z = SUM(grids_f%no_z(1:h2o_ind))
      beg_ind_z = end_ind_z - grids_f%no_z(h2o_ind) + 1
      end_ind_p = SUM(grids_f%no_p(1:h2o_ind))
      beg_ind_p = end_ind_p - grids_f%no_p(h2o_ind) + 1
      end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind) &
      &       * grids_f%no_f(1:h2o_ind))
      beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) &
      &       * grids_f%no_f(h2o_ind) + 1
d811 13
a823 12
      & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
      & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
      & RESHAPE(temp%values(:,windowStart:windowFinish), &
      & (/temp%template%nosurfs * no_sv_p_t/)), &
      & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
      & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
      & orbIncline%values(1,maf)*Deg2Rad, &
      & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
      & h2o_zeta_basis = grids_f%zet_basis(beg_ind_z:end_ind_z), &
      & h2o_phi_basis = grids_f%phi_basis(beg_ind_p:end_ind_p), &
      & h2o_coeffs = sps_values(beg_ind:end_ind), lin_log = lin_log(h2o_ind), &
      & dxdt_tan = dxdt_tan, d2xdxdt_tan = d2xdxdt_tan)
d826 1
a826 1
      & no_sv_p_t,temp%template%nosurfs,'dxdt_tan',ModuleName ) 
d828 1
a828 1
      & no_sv_p_t,temp%template%nosurfs,'d2xdxdt_tan',ModuleName ) 
d830 9
a838 9
      & 0.001_rp*scGeocAlt%values(:,maf),temp%template%surfs(:,1), &
      & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
      & RESHAPE(temp%values(:,windowStart:windowFinish), &
      & (/temp%template%nosurfs * no_sv_p_t/)), &
      & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
      & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
      & orbIncline%values(1,maf)*Deg2Rad, &
      & elevoffset%values(1,1)*Deg2Rad,req,tan_chi_out, &
      & dxdt_tan = dxdt_tan, d2xdxdt_tan = d2xdxdt_tan)
d840 1
a840 10
! bills debug
    if ( index(switches,'billsdebug') /= 0 ) then
      WRITE(lu_debug,'(a)') 'mmif based ptan, phitan, tan_chi_out'
      DO i = 1 , ptan%template%nosurfs
        WRITE(lu_debug,'(1x,f7.4,1x,f8.3,1x,f11.8)')  &
         & ptan%values(i,maf),phitan%values(i,maf),tan_chi_out(i)
      ENDDO
      WRITE(lu_debug, '(a)') 'pressure, height, refractive, angle'
    endif
  
d843 1
a843 1
! Insert automatic preselected integration gridder here. Need to make a 
d931 2
a932 2
    z_glgrid(1:maxVert-1) = RESHAPE ((SPREAD(xm,1,Ngp1) +          &
      &   SPREAD(ym,1,Ngp1) * SPREAD(zGx,2,NLm1)), (/maxVert-1/))
d952 1
a952 1
      &  temp%template%phi(1,windowStart:windowFinish)*Deg2Rad,temp%values,  &
d955 2
a956 3
      &  orbIncline%values(1,maf)*Deg2Rad, &
      &  t_glgrid, h_glgrid, dhdz_glgrid,dh_dt_glgrid, &
      &  DDHDHDTL0 = ddhidhidtl0)
d976 1
d978 1
d983 1
d985 1
a985 1
    & tan_press(j+1:no_tan_hts), tan_phi(j+1:no_tan_hts),METHOD = 'L')
d987 2
a988 1
    & tan_press(j+1:no_tan_hts), est_scgeocalt(j+1:no_tan_hts), METHOD = 'L')
d990 1
d993 1
a993 1
      & 'dxdt_surface',modulename)
d995 1
a995 1
      & 'd2xdxdt_surface',modulename)
d1001 4
a1004 4
        end_ind = SUM(grids_f%no_z(1:h2o_ind)*grids_f%no_p(1:h2o_ind)  &
        &       * grids_f%no_f(1:h2o_ind))
        beg_ind = end_ind - grids_f%no_z(h2o_ind)*grids_f%no_p(h2o_ind) &
        &       * grids_f%no_f(h2o_ind) + 1
d1006 14
a1019 13
        & 0.001_rp*est_scgeocalt(1:1), temp%template%surfs(:,1), &
        & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
        & RESHAPE(temp%values(:,windowStart:windowFinish), &
        & (/temp%template%nosurfs * no_sv_p_t/)), &
        & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
        & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
        & orbIncline%values(1,maf)*Deg2Rad, &
        & elevoffset%values(1,1)*Deg2Rad,req,surf_angle, &
        & h2o_zeta_basis = grids_f%zet_basis(beg_ind_z:end_ind_z), &
        & h2o_phi_basis = grids_f%phi_basis(beg_ind_p:end_ind_p), &
        & h2o_coeffs = sps_values(beg_ind:end_ind), lin_log=lin_log(h2o_ind), &
        & dxdt_tan = dxdt_surface, d2xdxdt_tan = d2xdxdt_surface)
        ELSE IF (h2o_ind == 0) THEN
d1021 9
a1029 9
        & 0.001_rp*est_scgeocalt(1:1), temp%template%surfs(:,1), &
        & temp%template%phi(1,windowStart:windowFinish)*Deg2Rad, &
        & RESHAPE(temp%values(:,windowStart:windowFinish), &
        & (/temp%template%nosurfs * no_sv_p_t/)), &
        & SPREAD(refGPH%template%surfs(1,1),1,no_sv_p_t), &
        & 0.001_rp*refGPH%values(1,windowStart:windowFinish), &
        & orbIncline%values(1,maf)*Deg2Rad, &
        & elevoffset%values(1,1)*Deg2Rad,req,surf_angle, &
        & dxdt_tan = dxdt_surface,d2xdxdt_tan = d2xdxdt_surface)
a1035 8
    allocate ( k_temp(noUsedChannels, no_tan_hts, n_t_zeta, &
      & windowStart:windowFinish), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_temp' )
    allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos' )
d1114 1
a1114 1
    call Allocate_test ( eta_fzp, no_ele, f_len, 'eta_zp', ModuleName )
d1121 3
a1123 2
      sv_t_len = n_t_zeta*(windowFinish-windowStart+1)

d1130 3
a1132 10
      IF(associated(temp%mask)) THEN
        k = 0
        do j = 1, WindowFinish - WindowStart + 1
          do i = 1, n_t_zeta
            k = k + 1
            DoThis = (iand(M_FullDerivatives,ichar(temp%mask(i,j))) == 0)
            t_deriv_flag(k) = DoThis
          end do
        end do
      ENDIF
d1154 2
d1300 3
a1302 2
      if (fwdModelConf%atmos_der) &
        & call Allocate_test ( k_atmos_frq,maxNoPtgFreqs,f_len,'k_atmos_frq',&
d1304 1
d1346 1
a1346 1
          neg_tan_ht = temp%values(1,mafTInstance) * &
d1429 1
a1429 1
       ! to compute sps_path for all those witn no frequecy componenet
d1432 2
a1433 2
        call comp_sps_path_frq(Grids_f,Frq,sps_values,eta_zp(1:no_ele,:), &
      &  do_calc_zp(1:no_ele,:),skip_eta_frq,lin_log,sps_path(1:no_ele,:),&
a1434 1

d1454 1
a1454 5
! bills debug
        if ( index(switches,'billsdebug') /= 0 ) &
            WRITE(lu_debug,'(1x,f7.4,1x,f8.3,1x,f14.11,1x,f11.8)')  &
               tan_press(ptg_i),one_tan_ht(1),n_path(npc/2), &
               ptg_angles(ptg_i)
d1523 2
a1524 2
          call comp_sps_path_frq(Grids_f,Frq,sps_values,eta_zp(1:no_ele,:), &
        &  do_calc_zp(1:no_ele,:),skip_eta_frq,lin_log,sps_path(1:no_ele,:),&
d1665 2
a1666 2
            call drad_tran_df(z_path(indices_c(1:npc)),Grids_f,lin_log,    &
              &  sps_values,beta_path_c(1:npc,:),                           &
d1864 1
a1864 1
                        k_atmos(i,ptg_i,jf,surface,instance,k) = r
d1877 1
a1877 2
                        k_atmos(i,ptg_i,jf,surface,instance,k) = &
                          k_atmos_frq(i,sv_i)
d2057 3
d2104 77
a2180 12

          center_angle = ptg_angles(surfaceTangentIndex)
! bills debug
          if ( index(switches,'billsdebug') /= 0 ) then
            CALL ALLOCATE_TEST(drad_dt_out,ptan%template%nosurfs, &
            & n_t_zeta*no_sv_p_t,'drad_dt_out',ModuleName)
            CALL ALLOCATE_TEST(test1,no_tan_hts,n_t_zeta*no_sv_p_t, &
            & 'test1',Modulename)
            CALL ALLOCATE_TEST(test2,no_tan_hts,n_t_zeta*no_sv_p_t, &
            & 'test2',Modulename)
            CALL ALLOCATE_TEST(test3,ptan%template%nosurfs,n_t_zeta*no_sv_p_t,&
            & 'test3',Modulename)
d2183 1
d2186 2
a2187 3
! This arithmatic makes a surface value adjustment
                test3(:,k+n_t_zeta*(j-1)) = dxdt_tan(:,j,k) &
                & - dxdt_surface(1,j,k)
d2190 108
a2297 54
            k = 1
            WRITE(*,'(a)') 'press_out, dx_dt 1, 2, 3, 4, 5 coeff 1'
            DO  j = 1 , no_tan_hts
              WRITE(*,'(f10.5,1x,5e11.2)') tan_press(j), &
              & dx_dt(j,1,k), dx_dt(j,2,k), dx_dt(j,3,k), dx_dt(j,4,k), &
              & dx_dt(j,5,k)
            ENDDO
            WRITE(*,'(a)') 'press_out, d2x_dxdt 1, 2, 3, 4, 5 coeff 1'
            DO  j = 1 , no_tan_hts
              WRITE(*,'(f10.5,1x,5e11.2)') tan_press(j), &
              & d2x_dxdt(j,1,k), d2x_dxdt(j,2,k), d2x_dxdt(j,3,k), &
              & d2x_dxdt(j,4,k), d2x_dxdt(j,5,k)
            ENDDO
            WRITE(*,'(a)') 'press_out, dxdt_tan 1, 2, 3, 4, 5 coeff 1'
            DO  j = 1 , ptan%template%nosurfs
              WRITE(*,'(f10.5,1x,5e11.2)') ptan%values(j,maf), &
              & dxdt_tan(j,1,k) - dxdt_surface(1,1,k), &
              & dxdt_tan(j,2,k) - dxdt_surface(1,2,k), &
              & dxdt_tan(j,3,k) - dxdt_surface(1,3,k), &
              & dxdt_tan(j,4,k) - dxdt_surface(1,4,k), &
              & dxdt_tan(j,5,k) - dxdt_surface(1,5,k)
            ENDDO
            WRITE(*,'(a)') 'press_out, di_dt 1, 2, 3, 4, 5 coeff 1'
            DO  j = 1 , no_tan_hts
              WRITE(*,'(f10.5,1x,5f9.5)') ptan%values(j,maf), &
              & k_temp(i,j,k,1), k_temp(i,j,k,2), k_temp(i,j,k,3), &
              & k_temp(i,j,k,4), k_temp(i,j,k,5)
            ENDDO
            CALL fov_convolve_v2(antennaPatterns(whichPattern)%aaap, &
            & antennaPatterns(whichPattern)%lambda,ptg_angles, &
            & Radiances(:,i),tan_chi_out, &
            & thisradiance%values(1:ptan%template%nosurfs,maf), &
            & SURF_ANGLE=surf_angle(1), DI_DT = DBLE(RESHAPE(k_temp(i,:,:,:), &
            & (/no_tan_hts,n_t_zeta*no_sv_p_t/))),DX_DT = test1, &
            & DDX_DXDT = test2, DX_DT_OUT = test3, DRAD_DT_OUT = drad_dt_out)
            WRITE(lu_debug,'(a)') 'angles_out, press_out, rad_out'
            DO  j = 1 , ptan%template%nosurfs
              WRITE(lu_debug,'(f11.8,1x,f10.5,1x,f9.4)') tan_chi_out(j), &
            ptan%values(j,maf),thisradiance%values(j,maf)
            ENDDO
            WRITE(lu_debug,'(a)') 'press_out, drad_dt 1, 2, 3, 4, 5 coeff 1'
            DO  j = 1 , ptan%template%nosurfs
              WRITE(lu_debug,'(f10.5,1x,5f9.4)') ptan%values(j,maf), &
              & drad_dt_out(j,1), drad_dt_out(j,1+n_t_zeta), &
              & drad_dt_out(j,1+2*n_t_zeta), drad_dt_out(j,1+3*n_t_zeta), &
              & drad_dt_out(j,1+4*n_t_zeta)
            ENDDO
            WRITE(lu_debug,'(a)') 'press_out, drad_dt 1, 2, 3, 4, 5 coeff 11'
            DO  j = 1 , ptan%template%nosurfs
              WRITE(lu_debug,'(f10.5,1x,5f9.4)') ptan%values(j,maf), &
              & drad_dt_out(j,11), drad_dt_out(j,11+n_t_zeta), &
              & drad_dt_out(j,11+2*n_t_zeta), drad_dt_out(j,11+3*n_t_zeta), &
              & drad_dt_out(j,11+4*n_t_zeta)
            ENDDO
d2302 15
a2316 13
          endif
       WRITE(*,'(a)') 'WARNING Two d antenna code not properly implemented!'
       WRITE(*,'(a)') 'for general 2 d temperature coefficients'
          call convolve_all ( fwdModelConf, fwdModelIn, maf, channel, &
            &  windowStart, windowFinish, mafTInstance-windowStart+1, &
            &  temp, ptan, thisRadiance, tan_press, ptg_angles,       &
            &  tan_temp, RESHAPE(dx_dt(:,3,:),(/no_tan_hts,n_t_zeta/)), &
            &  RESHAPE(d2x_dxdt(:,3,:),(/no_tan_hts,n_t_zeta/)),       &
            &  surfaceTangentIndex, center_angle, Radiances(:,i), &
            &  k_temp(i,:,:,:),         &
            &  k_atmos(i,:,:,:,:,:), thisRatio, t_deriv_flag, Grids_f,&
            &  Jacobian, fmStat%rows, antennaPatterns(whichPattern),  &
            &  mol_cat_index, ier, lu_debug )
d2318 2
a2319 2
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'convolve_all failed' )
d2322 6
a2327 6

          call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel,  &
            &     windowStart, windowFinish, temp, ptan, thisRadiance, &
            &     tan_press, Radiances(:,i), k_temp(i,:,:,:),          &
            &     k_atmos(i,:,:,:,:,:), thisRatio, Jacobian, fmStat%rows, &
            &     mol_cat_index )
a2336 1

d2340 5
a2344 2
      if ( fwdModelConf%temp_der ) &
        & call Deallocate_test ( k_temp_frq, 'k_temp_frq', ModuleName )
d2346 4
a2349 2
      if (fwdModelConf%atmos_der) &
        & call Deallocate_test ( k_atmos_frq, 'k_atmos_frq', ModuleName )
d2360 2
a2456 6
    deallocate ( k_temp, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_temp' )
    deallocate ( k_atmos, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_atmos' )
d2485 1
a2485 4
    if ( fwdModelConf%temp_der ) then
      call DestroyCompleteSlabs ( gl_slabs_p )
      call DestroyCompleteSlabs ( gl_slabs_m )
    end if
d2512 1
a2512 3
    call Deallocate_test ( skip_eta_frq, 'skip_eta_frq', ModuleName )
    CALL DEALLOCATE_TEST(tan_chi_out,'tan_chi_out',ModuleName ) 

d2523 2
a2524 2
      CALL DEALLOCATE_TEST(dxdt_tan,'dxdt_tan',ModuleName ) 
      CALL DEALLOCATE_TEST(d2xdxdt_tan,'d2xdxdt_tan',ModuleName ) 
d2526 2
d2564 1
a2564 2
! bills debug
  if ( index(switches,'billsdebug') /= 0 ) CLOSE(UNIT=lu_debug)
d2570 3
@


2.56
log
@add debug switch--wgr
@
text
@d76 1
a76 1
    & "$Id: FullForwardModel_m.f90,v 2.55 2002/06/07 23:01:25 bill Exp $"
d300 1
a300 1
    REAL(rp) :: cp2, sp2
d319 2
d323 5
d427 2
a428 1
      & dxdt_tan, d2xdxdt_tan, ddhidhidtl0, tan_d2h_dhdt) 
d769 1
a769 1
      CALL get_chi_out(ptan%values(:,maf), phitan%values(:,maf), &
d782 1
a782 1
      CALL get_chi_out(ptan%values(:,maf), phitan%values(:,maf), &
d804 1
a804 1
      CALL get_chi_out(ptan%values(:,maf), phitan%values(:,maf), &
d822 1
a822 1
      CALL get_chi_out(ptan%values(:,maf), phitan%values(:,maf), &
d901 1
d988 42
d2118 46
a2163 1
          CALL fov_convolve_v2(antennaPatterns(whichPattern)%aaap, &
d2166 4
a2169 1
            & thisradiance%values(1:ptan%template%nosurfs,maf))
d2175 18
d2201 2
a2202 2
            &  surfaceTangentIndex,        &
            &  center_angle, Radiances(:,i), k_temp(i,:,:,:),         &
d2419 1
d2463 3
@


2.55
log
@work in progress
@
text
@d76 1
a76 1
    & "$Id: FullForwardModel_m.f90,v 2.54 2002/06/07 04:50:03 bill Exp $"
d386 4
a389 2
    lu_debug = get_free_lun()
    OPEN(UNIT=lu_debug,FILE='debug.txt')
d826 8
a833 6
    WRITE(lu_debug,'(a)') 'mmif based ptan, phitan, tan_chi_out'
    DO i = 1 , ptan%template%nosurfs
      WRITE(lu_debug,'(1x,f7.4,1x,f8.3,1x,f11.8)')  &
       & ptan%values(i,maf),phitan%values(i,maf),tan_chi_out(i)
    ENDDO
    WRITE(lu_debug, '(a)') 'pressure, height, refractive, angle'
d1412 4
a1415 3
        WRITE(lu_debug,'(1x,f7.4,1x,f8.3,1x,f14.11,1x,f11.8)')  &
             tan_press(ptg_i),one_tan_ht(1),n_path(npc/2), &
             ptg_angles(ptg_i)
a1999 1
! BILLs DEBUG
d2065 2
d2071 6
a2076 6
! bills debug
          WRITE(lu_debug,'(a)') 'angles_out, press_out, rad_out'
          DO  j = 1 , ptan%template%nosurfs
            WRITE(lu_debug,'(f11.8,1x,f10.5,1x,f9.4)') tan_chi_out(j), &
          ptan%values(j,maf),thisradiance%values(j,maf)
          ENDDO
d2339 1
a2339 1
  CLOSE(UNIT=lu_debug)
d2345 3
@


2.54
log
@fixes and improvements--wgr
@
text
@d25 1
d76 1
a76 1
    & "$Id: FullForwardModel_m.f90,v 2.53 2002/06/05 17:20:28 livesey Exp $"
d2061 10
d2339 3
@


2.53
log
@Fixed tan_temp
@
text
@d8 1
d18 1
d56 1
a56 1
  use MLSNumerics, only: HUNT
d63 1
d75 1
a75 1
    & "$Id: FullForwardModel_m.f90,v 2.52 2002/06/04 23:06:47 livesey Exp $"
d177 1
a177 1
    integer, dimension(:), pointer :: INDECIES_C ! Indecies on coarse grid
a205 1
    real(rp) :: ELEV_OFFSET             ! Elevation offset
a208 1
    real(rp) :: PHI_TAN                 ! Phi at tanget point for given pointing
a213 1
    real(rp) :: ORB_INC                 ! orbital incline angle, Radians
d271 2
a272 2
    real(rp), dimension(:,:), pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
    real(rp), dimension(:,:), pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
d285 1
a285 1
    real(rp), dimension(:,:), pointer :: PTG_ANGLES ! (no_tan_hts,noMaf)
d288 1
a288 1
    real(rp), dimension(:,:), pointer :: TAN_DH_DT ! dH/dT at Tangent
d296 5
d311 11
a321 1
    REAL(rp), DIMENSION(:), POINTER :: tan_press(:)
d384 3
a386 1

d392 1
a392 1
    nullify ( grids, usedchannels, usedsignals, superset, indecies_c, &
d416 2
a417 1

a453 1
    ORB_INC = orbIncline%values(1,1)*Deg2Rad
d546 1
d737 93
a829 1

d903 3
a905 3
    call allocate_test ( h_glgrid, maxVert, n_t_phi, 'h_glgrid', ModuleName )
    call allocate_test ( t_glgrid, maxVert, n_t_phi, 't_glgrid', ModuleName )
    call allocate_test ( dhdz_glgrid, maxVert, n_t_phi, 'dhdz_glgrid', &
d907 1
a907 1
    call allocate_test ( dh_dt_glgrid, maxVert, n_t_phi, n_t_zeta, &
d909 2
d940 6
a945 4
      &  temp%template%phi(1,:)*Deg2Rad,temp%values,  &
      &  SPREAD(refGPH%template%surfs(1,1),1,n_t_phi),&
      &  0.001*refGPH%values(1,:),z_glgrid,ORB_INC,   &
      &  t_glgrid, h_glgrid, dhdz_glgrid,dh_dt_glgrid )
d954 2
d965 9
a973 2

    elev_offset= 0.0_rp
d997 1
a997 2
    call allocate_test ( tan_temp, no_tan_hts, 'tan_temp', &
      &  ModuleName )
d1055 1
a1055 1
    call Allocate_test ( indecies_c,   npc, 'indecies_c',    ModuleName )
d1100 2
a1101 1
      call Allocate_test ( tan_dh_dt, 1, n_t_zeta, 'tan_dh_dt', ModuleName )
d1103 2
d1146 1
a1146 1
    call allocate_test ( ptg_angles, no_tan_hts, noMAFs, 'ptg_angles', &
d1150 3
a1152 2
    call allocate_test ( dx_dt, no_tan_hts, n_t_zeta, 'dx_dt', ModuleName )
    call allocate_test ( d2x_dxdt, no_tan_hts, n_t_zeta, 'd2x_dxdt', &
d1282 2
a1283 2
        indecies_c(:) = 0
        indecies_c(1:npc) = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)
a1295 7
        ! Phi tan values are:
        ! phiTan%values ( mif, maf )

! *** This is where we will interpolate Phi_tan
        
        phi_tan = firstRadiance%template%phi(1,MAF)*Deg2Rad

d1303 5
a1307 6
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  ORB_INC,t_deriv_flag,h_path(1:no_ele),phi_path(1:no_ele),   &
d1311 2
a1312 1
              &  DHIDTLM=dh_dt_glgrid(:,windowStart:windowFinish,:),         &
d1319 4
a1322 5
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),ORB_INC,            &
d1335 4
a1338 5
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),ORB_INC,            &
d1342 2
a1343 2
              &  DHTDTL0=tan_dh_dt,                                          &
              &  DHIDTLM=dh_dt_glgrid(:,windowStart:windowFinish,:),         &
d1350 4
a1353 5
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),ORB_INC,            &
d1388 3
a1390 3
          call refractive_index(p_path(indecies_c(1:npc)), &
            &  t_path(indecies_c(1:npc)),n_path(1:npc),    &
            &  h2o_path=sps_path((indecies_c(1:npc)),h2o_ind))
d1392 2
a1393 2
          call refractive_index(p_path(indecies_c(1:npc)), &
            &  t_path(indecies_c(1:npc)),n_path(1:npc))
d1397 4
a1400 5
          call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2),    &
          &    one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf), &
          &    tan_dh_dt(1,:), temp%template%surfs(:,1),                    &
          &    temp%template%geodLat(1,:)*Deg2Rad, one_tan_temp(1),         &
          &    tan_press(ptg_i),dx_dt(ptg_i,:),d2x_dxdt(ptg_i,:))
d1402 3
a1404 2
          call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2), &
          &    one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf))
d1406 5
a1410 2

        call comp_refcor(Req+h_path(indecies_c(1:npc)), 1.0_rp+n_path(1:npc), &
d1485 1
a1485 1
              &  my_Catalog,beta_group,gl_slabs,indecies_c(1:npc),         &
d1497 1
a1497 1
              &  my_Catalog, beta_group,gl_slabs,indecies_c(1:npc),        &
d1506 1
a1506 1
              &  my_Catalog,beta_group,gl_slabs,indecies_c(1:npc),           &
d1514 1
a1514 1
              &  my_Catalog, beta_group,gl_slabs,indecies_c(1:npc),    &
d1519 1
a1519 1
          alpha_path_c(1:npc) = SUM(sps_path(indecies_c(1:npc),:) *  &
d1608 1
a1608 1
            & z_path(indecies_c(1:npc)),t_path(indecies_c(1:npc)),          &
d1620 1
a1620 1
            call drad_tran_df(z_path(indecies_c(1:npc)),Grids_f,lin_log,    &
d1622 2
a1623 2
              &  eta_fzp(indecies_c(1:npc),:),sps_path(indecies_c(1:npc),:),&
              &  do_calc_fzp(indecies_c(1:npc),:),beta_path_f,              &
d1635 4
a1638 4
            call drad_tran_dt(z_path(indecies_c(1:npc)),                      &
              & Req+h_path(indecies_c(1:npc)),                                &
              & t_path(indecies_c(1:npc)),dh_dt_path(indecies_c(1:npc),:),    &
              & alpha_path_c(1:npc),SUM(sps_path(indecies_c(1:npc),:)         &
d1640 2
a1641 2
              & eta_zxp_t(indecies_c(1:npc),:),do_calc_t(indecies_c(1:npc),:),&
              & do_calc_hyd(indecies_c(1:npc),:),del_s(1:npc),ref_corr(1:npc),&
d1658 4
a1661 4
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dw,          &
              &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(indecies_c(1:npc),:), &
              &  sps_path(indecies_c(1:npc),:),                            &
              &  do_calc_dw(indecies_c(1:npc),:),dbeta_dw_path_f,          &
d1671 4
a1674 4
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dn,         &
              &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(indecies_c(1:npc),:),&
              &  sps_path(indecies_c(1:npc),:),                           &
              &  do_calc_dn(indecies_c(1:npc),:),dbeta_dn_path_f,         &
d1684 4
a1687 4
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dv,         &
              &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(indecies_c(1:npc),:),&
              &  sps_path(indecies_c(1:npc),:),                           &
              &  do_calc_dv(indecies_c(1:npc),:),dbeta_dv_path_f,         &
d2059 3
a2061 1
          center_angle = ptg_angles(surfaceTangentIndex,maf)
d2064 4
a2067 2
            &  temp, ptan, thisRadiance, tan_press, ptg_angles(:,maf),&
            &  tan_temp, dx_dt, d2x_dxdt, surfaceTangentIndex,        &
d2071 1
a2071 1
            &  mol_cat_index, ier )
d2231 1
d2235 2
d2259 1
a2259 1
    call Deallocate_test ( indecies_c,   'indecies_c',   ModuleName )
d2271 1
d2281 1
d2283 2
d2321 2
a2322 1

d2328 3
@


2.52
log
@On the way to having phiTan
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.51 2002/06/04 10:27:59 zvi Exp $"
d244 1
a288 1
    real(rp), dimension(:,:), pointer :: TAN_TEMP ! ***
d874 1
a874 1
    call allocate_test ( tan_temp, no_tan_hts, n_t_phi, 'tan_temp', &
d1256 1
a1256 1
        tan_temp(ptg_i,maf) = one_tan_temp(1)
d1944 1
a1944 1
            &  tan_temp(:,maf), dx_dt, d2x_dxdt, surfaceTangentIndex, &
d2197 3
@


2.51
log
@Encorporate deriv. flag into convolution
@
text
@d47 1
a47 1
  use intrinsic, only: L_TEMPERATURE, L_RADIANCE, L_PTAN, L_ELEVOFFSET, &
d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.50 2002/05/28 17:09:14 livesey Exp $"
d315 1
d430 2
d470 3
d1170 3
d1174 1
a1174 1

d2197 3
@


2.50
log
@Removed print statement
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.49 2002/05/24 17:10:57 livesey Exp $"
d195 3
a197 3
    logical, dimension(:), pointer :: T_DERIV_FLAG  ! Array of Flags indicating
                                                    ! which Temp. coefficient 
                                                    ! to process
d655 3
a657 3
          call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
            & ModuleName )
          cycle
d962 10
a971 5
      call Allocate_test ( dbeta_dt_path_c, npc, no_mol, 'dbeta_dt_path_c', ModuleName )
      call Allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', ModuleName )
      call Allocate_test ( do_calc_hyd, no_ele, sv_t_len, 'do_calc_hyd', ModuleName )
      call Allocate_test ( do_calc_t, no_ele, sv_t_len, 'do_calc_t', ModuleName )
      call Allocate_test ( eta_zxp_t, no_ele, sv_t_len, 'eta_zxp_t', ModuleName )
d1671 1
a1671 1
          do k = 1, NO_MOL
d1725 1
a1725 1
          do k = 1, NO_MOL
d1770 1
a1770 1
          do k = 1, NO_MOL
d1815 1
a1815 1
          do k = 1, NO_MOL
d1937 3
a1939 2
            &  k_atmos(i,:,:,:,:,:), thisRatio, Jacobian, fmStat%rows, &
            &  antennaPatterns(whichPattern), mol_cat_index, ier )
d2188 3
@


2.49
log
@Fixed bug with my_catalog(?)%lines not being associated for parent
species.
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.48 2002/05/23 21:01:11 livesey Exp $"
a1994 1
    Print *,'Signal: ',Trim(molName)
d2182 4
@


2.48
log
@No, that was the wrong thing to do.  Think a bit more.
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.47 2002/05/23 20:55:20 livesey Exp $"
d653 6
a658 1
        if ( fwdModelConf%molecules(j+1) < 0 ) cycle
d2183 3
@


2.47
log
@Put more checking around case where a molecule has no lines.
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.46 2002/05/22 19:44:51 zvi Exp $"
d877 5
a881 7
      if ( associated ( my_catalog(i)%lines ) ) then
        nl = size(My_Catalog(i)%Lines)
        gl_slabs(1:no_ele,i)%no_lines = nl
        do j = 1, no_ele
          call AllocateOneSlabs ( gl_slabs(j,i), nl )
        end do
      end if
d891 7
a897 9
        if ( associated ( my_catalog(i)%lines ) ) then
          nl = size(My_Catalog(i)%Lines)
          gl_slabs_m(1:no_ele,i)%no_lines = nl
          gl_slabs_p(1:no_ele,i)%no_lines = nl
          do j = 1, no_ele
            call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
            call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
          end do
        end if
d2178 3
@


2.46
log
@Fix a bug in the mol. index loop
@
text
@d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.45 2002/05/17 22:13:20 livesey Exp $"
d877 7
a883 5
      nl = size(My_Catalog(i)%Lines)
      gl_slabs(1:no_ele,i)%no_lines = nl
      do j = 1, no_ele
        call AllocateOneSlabs ( gl_slabs(j,i), nl )
      end do
d893 9
a901 7
        nl = size(My_Catalog(i)%Lines)
        gl_slabs_m(1:no_ele,i)%no_lines = nl
        gl_slabs_p(1:no_ele,i)%no_lines = nl
        do j = 1, no_ele
          call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
          call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
        end do
d2182 3
@


2.45
log
@Bug fix for case where channels start at zero.
@
text
@d43 2
a44 1
  use MLSSignals_m, only: SIGNAL_T, MATCHSIGNAL, ARESIGNALSSUPERSET, DUMP
d72 1
a72 1
    & "$Id: FullForwardModel_m.f90,v 2.44 2002/05/14 22:40:45 livesey Exp $"
d724 2
a725 2
      IF(abs(fwdModelConf%molecules(mol_cat_index(sps_i))) == &
          &  l_extinction ) THEN
d731 1
a731 2
          &  quantitytype = l_vmr, molecule = &
          &  abs(fwdModelConf%molecules(sps_i)))
a1038 1

d1928 1
a1928 1
            &  antennaPatterns(whichPattern), ier )
d1938 2
a1939 1
            &     k_atmos(i,:,:,:,:,:), thisRatio, Jacobian, fmStat%rows )
d1981 10
d2032 1
d2178 3
@


2.44
log
@Bug fix in change in line gathering.  Never got to run it mercifully!
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.43 2002/05/14 22:32:45 livesey Exp $"
d542 2
a543 1
          usedChannels(channel) = i
d2167 3
@


2.43
log
@Added single sideband stuff.  Also skip line gathering for parent
molecules.
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.42 2002/05/14 00:19:10 livesey Exp $"
d650 1
a650 1
      if ( j < noSpecies ) then
d2166 4
@


2.42
log
@Minor bug fixes
@
text
@d43 1
a43 1
  use MLSSignals_m, only: SIGNAL_T, MATCHSIGNAL, ARESIGNALSSUPERSET
d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.41 2002/05/10 16:18:45 livesey Exp $"
d473 2
a474 1
    if ( fwdModelConf%signals(1)%sideband == 0 ) then
d479 1
d484 16
a499 2
      sidebandStart = fwdModelConf%signals(1)%sideband
      sidebandStop = sideBandStart
d501 1
a501 1
    endif
d648 5
d2166 3
@


2.41
log
@Code for dealing with new channel shape information
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.40 2002/05/08 08:53:42 zvi Exp $"
d536 12
a547 10
      l = abs(fwdModelConf%molecules(specie))
      if ( l == l_extinction ) then
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_extinction, radiometer=firstSignal%radiometer )
      else
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molecule=l )
      endif
      maxNoFFreqs = max(maxNoFFreqs, f%template%noChans)
      maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
d699 1
a699 1
    DO sps_i = 1 , noSpecies
d2145 3
@


2.40
log
@All radiometers grid concept implemented
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.39 2002/05/03 23:29:18 livesey Exp $"
a198 1
    real(r8) :: CENTERFREQ              ! Of band
d1043 2
a1044 1
            & fwdModelConf%signals(sigInd), sideband = thisSideband )
d1048 3
a1050 9
          k = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
          centerFreq = firstSignal%lo + &
            & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
          direction = fwdModelConf%signals(sigInd)%direction
!         direction = 1     ! *** ZEBUG
          r1 = centerFreq+thisSideband * direction * &
            &   FilterShapes(shapeInd)%FilterGrid(channel,1)
          r2 = centerFreq+thisSideband * direction * &
              &   FilterShapes(shapeInd)%FilterGrid(channel,k)
a1060 1
!         direction = 1     ! *** ZEBUG
a1574 4
            centerFreq = firstSignal%lo + &
              & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
            direction = fwdModelConf%signals(sigInd)%direction
!           direction = 1     ! *** ZEBUG
d1576 2
a1577 1
              & fwdModelConf%signals(sigInd), sideband = thisSideband )
d1581 1
a1581 1
            k = size(FilterShapes(shapeInd)%FilterGrid(channel,:))
d1583 3
a1585 4
              & CenterFreq+thisSideband * direction * &
              &   FilterShapes(shapeInd)%FilterGrid(channel,:), &
              &   FilterShapes(shapeInd)%FilterShape(channel,:),&
              & RadV, noFreqs, k, Radiances(ptg_i,i) )
a1601 4
              centerFreq = firstSignal%lo + thisSideband * &
                & fwdModelConf%signals(sigInd)%centerFrequency
              direction = fwdModelConf%signals(sigInd)%direction
!             direction = 1     ! *** ZEBUG
d1608 3
a1610 4
                  call Freq_Avg ( frequencies,                      &
                    & centerFreq+thisSideband*direction* &
                    & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                    & FilterShapes(shapeInd)%FilterShape(channel,:),&
d1612 1
a1612 1
                    & size(FilterShapes(shapeInd)%FilterGrid(channel,:)),r)
d1647 1
a1647 5
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  direction = fwdModelConf%signals(sigInd)%direction
!                 direction = 1     ! *** ZEBUG
d1654 3
a1656 4
                        call Freq_Avg ( frequencies,                      &
                          & centerFreq+thisSideband * direction * &
                          & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                          & FilterShapes(shapeInd)%FilterShape(channel,:),&
d1700 1
a1700 5
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  direction = fwdModelConf%signals(sigInd)%direction
!                 direction = 1     ! *** ZEBUG
d1708 3
a1710 4
                        call Freq_Avg ( frequencies,                      &
                          & centerFreq+thisSideband * direction * &
                          & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                          & FilterShapes(shapeInd)%FilterShape(channel,:),&
d1745 1
a1745 5
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  direction = fwdModelConf%signals(sigInd)%direction
!                 direction = 1     ! *** ZEBUG
d1753 3
a1755 4
                        call Freq_Avg ( frequencies,                      &
                          & centerFreq+thisSideband * direction * &
                          & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                          & FilterShapes(shapeInd)%FilterShape(channel,:),&
d1790 1
a1790 5
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  direction = fwdModelConf%signals(sigInd)%direction
!                 direction = 1     ! *** ZEBUG
d1798 3
a1800 4
                        call Freq_Avg ( frequencies,                      &
                          & centerFreq+thisSideband * direction * &
                          & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                          & FilterShapes(shapeInd)%FilterShape(channel,:),&
d2143 3
@


2.39
log
@Added direction and split sideband ratio stuff
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.38 2002/02/22 00:52:06 bill Exp $"
d113 1
a127 1
    integer :: NOMIFS                   ! Number of minor frames
a165 2
    character (len=78) :: ErrMsg        ! Error Message

d208 1
a208 1
    real(rp) :: R                       ! real variable for various uses
d211 1
d218 2
a219 1
    real(r8), dimension(:), pointer :: FREQUENCIES ! What frequencies to compute for
d351 4
d385 1
a385 1
      & phi_basis_dv, phi_basis_dw, phi_path, p_glgrid, p_path, radv, &
d496 2
a497 1
    noMIFs = firstRadiance%template%noSurfs
d636 2
a637 2
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), 'lineFlag', &
                         &   ModuleName )
d645 1
a645 1
              ! If we're only doing one sideband, maybe we can remove some more lines
d1033 26
a1058 2
          maxNoPtgFreqs = max ( maxNoPtgFreqs, &
            & Size(pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies) )
d1066 2
d1070 1
a1070 2
            & fwdModelConf%signals(usedSignals(channel))%direction * &
            &   fwdModelConf%signals(usedSignals(channel))% &
d1089 1
a1089 1
      call Allocate_test ( radv, maxNoPtgFreqs, 'radV', ModuleName )
d1176 2
a1177 1
          ! Tan heights for a negative tan height from metrics is not correctly working.
d1259 2
a1260 2
        ! This only needs to be computed on the gl (not coarse) grid thus there is
        ! some duplication here.
d1291 2
a1292 2
! ** BILLs DEBUG
          nofreqs = SIZE(PointingGrids(whichPointingGrid)%oneGrid( &
d1294 10
a1303 1
          call allocate_test ( frequencies,nofreqs, "frequencies", ModuleName )
d1305 2
a1306 8
          frequencies =  &
       & (PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies) &
                      *(1.0_rp - losvel%values(1,maf) / 299792458.3_rp)
!          frequencies =>  &
!         & PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
!          noFreqs = size(frequencies)

        end if ! If not, we dealt with this outside the loop
d1562 1
d1564 1
d1577 1
d1585 1
d1591 1
d1593 1
a1593 1
              & centerFreq+thisSideband * direction * &
d1596 1
a1596 3
              & RadV, noFreqs,  &
              & size(FilterShapes(shapeInd)%FilterGrid(channel,:)), &
              & Radiances(ptg_i,i) )
d1616 1
d1667 1
d1715 1
a1715 1
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d1725 1
d1765 1
a1765 1
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d1775 1
d1815 1
a1815 1
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
d1825 1
d2010 1
a2010 1
      k=ptan%template%noSurfs
d2032 1
a2032 1
903   format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
d2179 3
@


2.38
log
@fixed units error for light speed--wgr
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.37 2002/02/20 22:19:45 zvi Exp $"
d100 1
d319 2
d442 6
d471 2
a472 1
      if (.not. associated (sidebandRatio) ) &
d1039 3
a1041 2
            & fwdModelConf%signals(usedSignals(channel))% &
            & frequencies(usedChannels(channel))
d1547 1
d1554 3
a1556 3
              & centerFreq+thisSideband * &
              & FilterShapes(shapeInd)%FilterGrid(channel,:), &
              & FilterShapes(shapeInd)%FilterShape(channel,:),&
d1578 1
d1586 1
a1586 1
                    & centerFreq+thisSideband* &
d1628 1
d1636 1
a1636 1
                          & centerFreq+thisSideband * &
d1685 1
d1694 1
a1694 1
                          & centerFreq+thisSideband * &
d1734 1
d1743 1
a1743 1
                          & centerFreq+thisSideband * &
d1783 1
d1792 1
a1792 1
                          & centerFreq+thisSideband * &
d1857 10
a1866 2
          thisRatio = sidebandRatio%values(channel,1)
          if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
d2137 3
@


2.37
log
@Reversing the subset logic ..
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.36 2002/02/16 10:32:16 zvi Exp $"
d1014 1
a1014 1
                 &  tan_press, grids, allowTopValue=.TRUE. )
d1255 2
a1256 5
         & PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
!
          r = 1.0_rp - losvel%values(1,maf) / 299792.4583_rp
          frequencies = frequencies * r

a1517 1

d2112 3
@


2.36
log
@Fixing small bug..
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.35 2002/02/16 06:49:59 zvi Exp $"
d354 3
d777 2
a778 1
    call two_d_hydrostatic(temp%template%surfs(:,1),  &
d903 1
a903 1
      t_deriv_flag(1:sv_t_len) = .FALSE.  ! ** Initialize to NO derivatives
d912 1
a912 1
            DoThis = (iand(M_FullDerivatives,ichar(temp%mask(i,j))) /= 0)
a915 3
! ** ZEBUG: Until Van changes the Subset logic, we will invert it here:
        t_deriv_flag(1:k) = (.NOT. t_deriv_flag(1:k))
! ** END ZEBUG
d1256 4
a1259 1
          frequencies = frequencies * (1.0_r8-losvel%values(1,maf)/2.9979d08)
d1263 1
d2116 3
@


2.35
log
@Retain deriv flag code ..
@
text
@d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.32 2002/02/14 19:05:01 bill Exp $"
d1249 3
a1251 4
        nofreqs = SIZE(PointingGrids(whichPointingGrid)%oneGrid( &
          &            grids(ptg_i))%frequencies)
        call allocate_test ( frequencies,nofreqs, "frequencies", &
          &   ModuleName )
d1255 1
a1255 2
          frequencies = frequencies * (1.0_r8 - losvel%values(1,maf) &
         &  / 2.9979d08)
d2111 3
@


2.34
log
@shifted frid grid by losvel--wgr
@
text
@d28 3
a30 1
                       &   GETVECTORQUANTITYBYTYPE
d38 1
a38 2
! use Load_sps_data_m, only: LOAD_SPS_DATA, Grids_T
  use Load_sps_data_m, only: LOAD_SPS_DATA, LOAD_DERIV_FLAG, Grids_T ! ** ZEBUG
d71 1
a71 1
    & "$Id: FullForwardModel_m.f90,v 2.33 2002/02/15 22:52:29 livesey Exp $"
d163 1
a163 1
    logical :: dummy(2) = (/.false.,.false./)  ! dummy Flag array
d435 2
a436 1
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.true. )
d445 1
a445 1
    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
d448 1
a448 1
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
d495 1
a495 1
      if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.true.,&
d530 1
a530 1

d591 1
a591 1
              & quantityType=l_isotoperatio, molecule=l, noError=.true. )
d620 1
a620 1
        lineFlag = .false.
d899 1
a899 1
      t_deriv_flag(1:sv_t_len) = .TRUE.   ! ** initialize values to .TRUE.
d901 15
a915 9
! ** ZEBUG *** Loading the Temp. derivative coeff. flag from file ***
      Spectag = 10000     ! Temperature's 'Spectag'
      j = WindowFinish - WindowStart + 1
      Call load_deriv_flag(Spectag,j,n_t_zeta,1,t_deriv_flag,ErrMsg,k)
      if(k < 0) then
        Print *,ErrMsg(1:Len_Trim(ErrMsg))
        Print *,'** Setting all t_deriv_flag = .TRUE.'
      endif
! ** END ZEBUG ***
d1013 1
a1013 1
                 &  tan_press, grids, allowTopValue=.true. )
d1213 2
a1214 3
        call comp_refcor(Req+h_path(indecies_c(1:npc)), &
          &   1.0_rp+n_path(1:npc),Req+one_tan_ht(1), &
          &   del_s(1:npc),ref_corr(1:npc))
d1246 1
d1248 1
a1248 1
! billsdebug
d1253 1
a1253 1
! velocity shift correction to frequency grid
a1549 1
             
d1551 1
a1551 1
          Radiances(ptg_i,1:noUsedChannels) = RadV
d1811 1
a1811 2
        ! End of pointing loop -------------------------------------------------
! billsdebug
d1814 2
d1897 1
a1897 1
      call Deallocate_test ( radv, 'radV', ModuleName )
a2112 3
! Revision 2.33  2002/02/15 22:52:29  livesey
! Bug fix in antenna pattern selection
!
@


2.33
log
@Bug fix in antenna pattern selection
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.32 2002/02/14 19:05:01 bill Exp $"
a434 1

d1240 7
a1246 1
          frequencies =>  &
d1248 5
a1252 1
          noFreqs = size(frequencies)
d1542 1
d1805 3
d2105 3
@


2.32
log
@Fixed no spectral avg bug--wgr
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.31 2002/02/13 20:35:47 livesey Exp $"
d1832 1
a1832 1
              & fwdModelConf%signals, sideband=thisSideband, &
d2092 3
@


2.31
log
@Added some nullifies
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.30 2002/02/08 00:46:05 zvi Exp $"
d1510 1
a1510 1
        ! we just store what we have as we're using delta funciton channels
d1534 1
a1534 1
          Radiances(ptg_i,1:noUsedChannels) = RadV(1)
d1572 1
a1572 1
                  k_temp(i,ptg_i,surface,instance) = k_temp_frq(1,sv_i)
d1624 1
a1624 1
                          k_atmos_frq(1,sv_i)
d1680 1
a1680 1
                          k_spect_dw_frq(1,sv_i)
d1728 1
a1728 1
                          k_spect_dn_frq(1,sv_i)
d1776 1
a1776 1
                          k_spect_dv_frq(1,sv_i)
d2092 3
@


2.30
log
@Some cosmetic changes..
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.29 2002/02/07 00:36:31 zvi Exp $"
d376 2
a377 1
      & z_basis, z_basis_dn, z_basis_dv, z_basis_dw, z_glgrid, z_path )
d2092 3
@


2.29
log
@Fix a bug - phi_tan non defined..
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.28 2002/02/05 21:54:29 zvi Exp $"
d897 1
a897 1
      t_deriv_flag(1:sv_t_len) = .true.   ! ** initialize values to .TRUE.
d1088 2
a1096 2
          ! *** This is where we will interpolate Phi_tan

d2091 3
@


2.28
log
@Fix a bug ..
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.27 2002/02/04 22:44:40 zvi Exp $"
d1088 2
a1093 1
          phi_tan = firstRadiance%template%phi(1,MAF)*Deg2Rad
d2091 3
@


2.27
log
@Fixing some bugs in the automatic grid selection process
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.26 2002/02/02 11:20:17 zvi Exp $"
a780 1
    tan_press(j+1:no_tan_hts) = z_glgrid(tan_inds(j+1:no_tan_hts))
d2090 3
@


2.26
log
@Code to overwrite the l2cf integration & tanget grids
@
text
@d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.25 2002/01/30 01:11:18 zvi Exp $"
d469 1
a469 1
    ! Sort out some important dimensions
d474 1
a474 1
    no_tan_hts = fwdModelConf%tangentGrid%noSurfs
d479 1
a479 1
    !  Get some dimensions that we'll use a lot
a653 3
    ! Work out which frequencies we're going to need in non frequency --------
    ! averaging case

a655 21
    allocate ( k_temp(noUsedChannels, no_tan_hts, n_t_zeta, &
      & windowStart:windowFinish), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_temp' )
    allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_atmos' )
    allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dw' )
    allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dn' )
    allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFFreqs, &
      & maxNoFSurfs, windowStart:windowFinish, no_mol), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
      & MLSMSG_Allocate//'k_spect_dv' )

d706 15
a723 8
! We are going to ignore data in FwdModelConf%integrationGrid%surfs
! and replace this with z_psig
!
    write(6,928)
 928 format('** Note **',/,3x,'Ignoring FwdModelConf%integrationGrid%surfs, &
       &fwdModelConf%tangentGrid%surfs',/,3x,'and replacing it with the &
       &output from the make_z_grid subroutine !')

d778 4
d798 22
d1004 1
a1004 2
        call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
          "Grids", ModuleName )
d1006 1
a1006 1
          & tan_press, grids, allowTopValue=.true. )
d2091 3
@


2.25
log
@Fix bug in user selectable coeff. code
@
text
@d58 1
d70 1
a70 1
    & "$Id: FullForwardModel_m.f90,v 2.24 2002/01/27 08:37:45 zvi Exp $"
d92 1
a92 1
    integer, parameter :: NGP1=NG+1     ! NG + 1
d113 2
a114 1
    integer :: MAFTINSTANCE             ! Temperature instance closest to this MAF
d121 2
a122 2
    integer :: NLM1                     ! NLVL - 1
    integer :: NLVL                     ! Size of integration grid
d126 1
a126 1
    integer :: NOSPECIES                ! Number of molecules under consideration
d143 2
a144 1
    integer :: SURFACETANGENTINDEX      ! Index in tangent grid of earth's surface
d169 1
a169 1
    integer, dimension(:), pointer :: GRIDS ! Heights in ptgGrid for each tangent
d194 3
a196 2
    logical, dimension(:), pointer :: T_DERIV_FLAG  ! Array of Flags indicating which 
                                                    ! Temp. coefficient to process
d205 2
a206 1
    real(rp) :: NEG_TAN_HT              ! GP Height (in KM.) of tan. press. below surface
d219 1
a219 1
    real(rp), dimension(:), pointer :: DEL_S ! Integration lengths along the path
d237 2
a238 1
    real(rp), dimension(:), pointer :: RADV ! Radiances for 1 pointing on freqGrid
d247 1
a247 1
    real(rp), dimension(:), pointer :: Z_BASIS ! zeta basis per species (n_f_zeta)
d290 4
d295 12
d364 1
a364 1
      &       tan_inds )
d682 2
a683 1
    ! Setup our temporary `state vector' like arrays -------------------------
d689 53
a741 2
    ! Compute Gauss Legendre (GL) grid ---------------------------------------
    nlvl = size(FwdModelConf%integrationGrid%surfs)
d745 3
a747 1
    NLm1 = nlvl - 1
a748 1
    ! Allocate GL grid stuff
d754 1
a754 1
    call Allocate_test ( p_glGrid, maxVert, 'z_glGrid', ModuleName )
d758 2
a759 1
    call allocate_test ( dhdz_glgrid, maxVert, n_t_phi, 'dhdz_glgrid', ModuleName )
d762 3
a764 3

    ! From the selected integration grid pressures define the GL pressure
    ! grid:
d767 6
a772 10
    xm(1:NLm1) = 0.5_rp * ( &
      &   FwdModelConf%integrationGrid%surfs(2:nlvl) + &
      &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    ym(1:NLm1) = 0.5_rp * ( &
      &   FwdModelConf%integrationGrid%surfs(2:nlvl) - &
      &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
      &   spread(ym,1,Ngp1) * spread(zGx,2,NLm1)), &
      &  (/maxVert-1/))
    z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
d778 1
d791 1
a791 1
      &  spread(refGPH%template%surfs(1,1),1,n_t_phi),&
d794 11
d806 2
a807 5
    call allocate_test ( tan_inds, no_tan_hts, 'tan_inds', ModuleName )
    call Hunt ( z_glgrid-0.0001_rp, &
      & fwdModelConf%tangentGrid%surfs, &
      & tan_inds, allowTopValue=.true. )
    surfaceTangentIndex = count ( tan_inds == 1 )
d998 1
a998 1
          & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
d1083 1
a1083 1
            &  (fwdModelConf%tangentGrid%surfs(ptg_i) - z_glgrid(1)) / 14.8_rp
d1191 1
a1191 2
          &    fwdModelConf%tangentGrid%surfs(ptg_i),dx_dt(ptg_i,:),        &
          &    d2x_dxdt(ptg_i,:))
d1328 1
a1328 1
          gl_inds = reshape(spread(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
d1841 4
a1844 5
            &  temp, ptan, thisRadiance,FwdModelConf%tangentGrid%surfs,&
            &  ptg_angles(:,maf), tan_temp(:,maf), dx_dt, d2x_dxdt,  &
            &  surfaceTangentIndex, center_angle, &
            &  Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:,:), &
            &  thisRatio, Jacobian, fmStat%rows,  &
d1846 1
a1846 1
          !??? Need to choose some index other than 1 for AntennaPatterns ???
d1854 2
a1855 3
            &     FwdModelConf%tangentGrid%surfs, &
            &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:,:), &
            &     thisRatio, Jacobian, fmStat%rows )
d1919 1
a1919 1
902   format ( 4(4x, f10.7))
d1996 1
d2083 3
@


2.24
log
@Adding Users selected coefficients for derivatives
@
text
@d35 4
a38 1
  use Load_sps_data_m, only: LOAD_SPS_DATA, Grids_T
d69 1
a69 1
    & "$Id: FullForwardModel_m.f90,v 2.22 2002/01/08 01:01:19 livesey Exp $"
d159 4
d183 10
a192 7
    logical, dimension(:,:), pointer :: DO_CALC_ZP  ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_FZP ! 'Avoid zeros' indicator
    logical, dimension(:,:), pointer :: DO_CALC_DN ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DV ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DW ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_HYD ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_T ! 'Avoid zeros'
d207 1
d346 1
a346 1
      & do_calc_hyd, do_calc_t, do_calc_fzp )
d399 1
d716 2
a717 3
    call two_d_hydrostatic(temp%template%surfs(:,1), &
      &  temp%template%phi(1,:)*Deg2Rad,  &
      &  temp%values, &
d719 2
a720 4
      &  0.001*refGPH%values(1,:),  &
      &  z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
      &  t_glgrid, h_glgrid, dhdz_glgrid, &
      &  dh_dt_glgrid )
d806 14
d1015 3
a1017 4
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,                              &
              &  TAN_PHI_T_GRID=one_tan_temp,                                &
d1019 2
a1020 2
              &  DHIDTLM=dh_dt_glgrid(:,windowStart:windowFinish,:), &
              &  DHITDTLM=dh_dt_path(1:no_ele,:),      &
d1030 4
a1033 4
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,  &
d1046 4
a1049 4
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,  &
d1062 4
a1065 4
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp)
d1961 1
d2004 3
@


2.23
log
@Fix a bug with skip_eta_frq
@
text
@d3 1
a3 1
 
d5 1
a5 1
 
d26 1
a26 1
 
d55 1
a55 1
 
d57 1
a57 1
 
d59 1
a59 1
 
d63 1
a63 1
 
d71 1
a71 1
 
d73 1
a73 1
 
d85 1
a85 1
 
d89 1
a89 1
 
d92 1
a92 1
 
d107 1
d110 2
a111 1
    integer :: MAXNOFREQS               ! Used for sizing arrays
d145 3
a147 3
    integer :: SV_DW_LEN                ! Length of DW in vector
    integer :: SV_DN_LEN                ! Length of DN in vector
    integer :: SV_DV_LEN                ! Length of DV in vector
d152 1
a152 1
 
d155 1
a155 1
 
d158 1
a158 1
 
d166 1
a166 1
 
d169 1
a169 1
 
d173 1
a173 1
 
d175 1
a175 1
 
d183 1
a183 1
 
d186 1
a186 1
 
d197 1
a197 1
 
d236 1
a236 1
 
d240 1
a240 1
 
d271 1
a271 1
 
d273 1
a273 1
 
d287 1
a287 1
 
d289 1
a289 1
 
d293 1
a293 1
 
d297 1
a297 1
 
d302 1
a302 1
 
d305 1
a305 1
 
d309 5
a313 5
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DW
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DN
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DV
 
d322 3
a324 1
 
d327 1
a327 1
 
d329 1
a329 1
 
d344 1
a344 1
 
d353 1
a353 1
 
d355 1
a355 1
 
d357 1
a357 1
 
d361 1
a361 1
 
d372 1
a372 1
 
d376 1
a376 1
 
d378 1
a378 1
 
d400 1
a400 1
 
d405 1
a405 1
 
d420 1
a420 1
 
d434 1
a434 1
 
d444 1
a444 1
 
d446 1
a446 1
 
d453 1
a453 1
 
d479 2
a480 1
 
d491 1
d498 1
a498 1
 
d505 1
a505 1
 
d538 1
a538 1
 
d563 1
a563 1
 
d569 1
a569 1

d575 1
a575 1
 
d619 1
a619 1
 
d622 1
a622 1
 
d624 1
a624 1
 
d629 2
a630 2
    allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, no_mol), stat=ier )
d633 2
a634 2
    allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, no_mol), stat=ier )
d637 2
a638 2
    allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, no_mol), stat=ier )
d641 2
a642 2
    allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFSurfs, &
      & windowStart:windowFinish, no_mol), stat=ier )
d645 1
a645 1
 
d647 1
a647 1
 
d653 1
a653 1
 
d657 1
a657 1
 
d660 1
a660 1
 
d665 1
a665 1
 
d668 1
a668 1
 
d674 1
a674 1
 
d690 1
a690 1
 
d694 1
a694 1
 
d696 1
a696 1
 
d701 1
a701 1
 
d712 1
a712 1
 
d718 1
a718 1
 
d720 1
a720 1
 
d723 1
a723 1
 
d725 1
a725 1
 
d727 1
a727 1
 
d729 1
a729 1
 
d733 1
a733 1
 
d741 1
a741 1
 
d747 1
a747 1
 
d758 1
a758 1
 
d760 1
a760 1
 
d763 1
a763 1
 
d765 1
a765 1
 
d773 1
a773 1
 
d783 1
a783 1
 
d790 1
a790 1
 
d792 1
a792 1
 
d794 1
a794 1
 
d796 1
a796 1
 
d804 1
a804 1
 
d806 1
a806 1
 
d810 1
a810 1
 
d812 1
a812 1
 
d814 1
a814 1
 
d821 6
a826 6
 
      sv_dw_len = SUM(Grids_dw%no_z(:) * Grids_dw%no_p(:) * Grids_dw%no_f(:))
      sv_dn_len = SUM(Grids_dn%no_z(:) * Grids_dn%no_p(:) * Grids_dn%no_f(:))
      sv_dv_len = SUM(Grids_dv%no_z(:) * Grids_dv%no_p(:) * Grids_dv%no_f(:))
 
      call Allocate_test ( do_calc_dw, no_ele, sv_dw_len, 'do_calc_dw', &
d828 1
a828 1
      call Allocate_test ( do_calc_dn, no_ele, sv_dn_len, 'do_calc_dn', &
d830 1
a830 1
      call Allocate_test ( do_calc_dv, no_ele, sv_dv_len, 'do_calc_dv', &
d832 2
a833 2
 
      call Allocate_test ( eta_zxp_dw, no_ele, sv_dw_len, 'eta_zxp_dw', &
d835 1
a835 1
      call Allocate_test ( eta_zxp_dn, no_ele, sv_dn_len, 'eta_zxp_dn', &
d837 1
a837 1
      call Allocate_test ( eta_zxp_dv, no_ele, sv_dv_len, 'eta_zxp_dv', &
d839 5
a843 5
 
      call Allocate_test ( drad_dw, sv_dw_len, 'drad_dw', ModuleName )
      call Allocate_test ( drad_dn, sv_dn_len, 'drad_dn', ModuleName )
      call Allocate_test ( drad_dv, sv_dv_len, 'drad_dv', ModuleName )
 
d845 1
a845 1
 
d853 1
a853 1
 
d856 1
a856 1
 
d859 1
a859 1
 
d864 1
a864 2
 
 
d867 1
a867 1
 
d871 1
a871 1
 
d880 1
a880 1
 
d888 1
a888 1
 
d896 1
a896 1
        maxNoFreqs = 0
d898 1
a898 1
          maxNoFreqs = max ( maxNoFreqs, &
d901 1
a901 1
 
d903 1
a903 1
 
d925 1
a925 1
        maxNoFreqs = noUsedChannels
d927 3
a929 3
 
      call Allocate_test ( radv, maxNoFreqs, 'radV', ModuleName )
 
d931 1
a931 1
        & call Allocate_test (k_temp_frq,maxNoFreqs,sv_t_len,'k_temp_frq', &
d933 1
a933 1
 
d935 1
a935 1
        & call Allocate_test ( k_atmos_frq,maxNoFreqs,f_len,'k_atmos_frq',&
d937 1
a937 1
 
d939 1
a939 1
        call Allocate_test ( k_spect_dw_frq , maxNoFreqs, sv_dw_len , &
d941 1
a941 1
        call Allocate_test ( k_spect_dn_frq , maxNoFreqs, sv_dn_len , &
d943 1
a943 1
        call Allocate_test ( k_spect_dv_frq , maxNoFreqs, sv_dv_len , &
d946 1
a946 1
 
d949 1
a949 1
 
d954 1
a954 1
 
d959 1
a959 1
 
d965 1
a965 1
 
d971 1
a971 1
 
d973 1
a973 1
 
d976 1
a976 1
 
d982 1
a982 1
 
d984 1
a984 1
 
d1014 1
a1014 1
 
d1046 1
a1046 1
 
d1060 1
a1060 1
 
d1064 1
a1064 1
 
d1068 1
a1068 1
 
d1073 1
a1073 1
 
d1082 1
a1082 1
 
d1094 1
a1094 1
 
d1098 1
a1098 1
 
d1105 1
a1105 1
 
d1108 1
a1108 1
 
d1113 1
a1113 1
 
d1123 1
a1123 1
 
d1126 1
a1126 1
 
d1131 1
a1131 1
            &   PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
d1134 1
a1134 1
 
d1138 1
a1138 1
 
d1141 1
a1141 1
 
d1145 1
a1145 1
 
d1147 1
a1147 1
 
d1149 1
a1149 1
 
d1154 1
a1154 1
 
d1156 1
a1156 1
 
d1166 1
a1166 1
 
d1168 1
a1168 1
 
d1175 1
a1175 1
 
d1177 1
a1177 1
 
d1183 1
a1183 1
 
d1185 1
a1185 1
 
d1189 1
a1189 1
 
d1191 1
a1191 1
 
d1194 1
a1194 1
 
d1197 1
a1197 1
 
d1199 1
a1199 1
 
d1202 1
a1202 1
 
d1209 1
a1209 1
 
d1211 1
a1211 1
 
d1213 1
a1213 1
 
d1223 1
a1223 1
 
d1225 1
a1225 1
 
d1228 1
a1228 1
 
d1231 1
a1231 1
 
d1240 1
a1240 1
 
d1247 1
a1247 1
 
d1249 1
a1249 1
 
d1257 1
a1257 1
 
d1259 1
a1259 1
 
d1270 1
a1270 1
 
d1272 1
a1272 1
 
d1275 1
a1275 1
 
d1277 1
a1277 1
 
d1279 1
a1279 1
 
d1286 1
a1286 1
 
d1288 1
a1288 1
 
d1290 1
a1290 1
 
d1292 3
a1294 3
 
            call drad_tran_df(z_path(indecies_c(1:npc)),Grids_f%no_z,       &
              &  Grids_f%no_p,lin_log,sps_values,beta_path_c(1:npc,:),      &
d1301 3
a1303 3
 
            k_atmos_frq(frq_i,:) = drad_df
 
d1305 1
a1305 1
 
d1307 1
a1307 1
 
d1322 1
a1322 1
 
d1324 1
a1324 1
 
d1326 1
a1326 1
 
d1328 1
a1328 1
 
d1330 8
a1337 8
 
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dw%no_z, &
              &  Grids_dw%no_p,dbeta_dw_path_c(1:npc,:),              &
              &  eta_zxp_dw(indecies_c(1:npc),:),sps_path(indecies_c(1:npc),:), &
              &  do_calc_dw(indecies_c(1:npc),:),dbeta_dw_path_f,      &
              &  eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),           &
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),     &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
d1339 1
a1339 1
 
d1341 1
a1341 1
 
d1343 8
a1350 8
 
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dn%no_z,   &
              &  Grids_dn%no_p,dbeta_dn_path_c(1:npc,:),                &
              &  eta_zxp_dn(indecies_c(1:npc),:),sps_path(indecies_c(1:npc),:), &
              &  do_calc_dn(indecies_c(1:npc),:),dbeta_dn_path_f,        &
              &  eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),             &
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),       &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
d1352 1
a1352 1
 
d1354 1
a1354 1
 
d1356 8
a1363 8
 
            call drad_tran_dx(z_path(indecies_c(1:npc)),Grids_dv%no_z,   &
              &  Grids_dv%no_p,dbeta_dv_path_c(1:npc,:),                &
              &  eta_zxp_dv(indecies_c(1:npc),:),sps_path(indecies_c(1:npc),:), &
              &  do_calc_dv(indecies_c(1:npc),:),dbeta_dv_path_f,        &
              &  eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),             &
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),       &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds), &
d1365 1
a1365 1
 
d1367 1
a1367 1
 
d1369 1
a1369 1
 
d1374 1
a1374 1
 
d1378 1
a1378 1
 
d1380 3
a1382 3
            call Deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f', ModuleName )
            call Deallocate_test ( dbeta_dn_path_f, 'dbeta_dn_path_f', ModuleName )
            call Deallocate_test ( dbeta_dv_path_f, 'dbeta_dv_path_f', ModuleName )
d1384 1
a1384 1
 
d1386 1
a1386 1
 
d1390 1
a1390 1
 
d1393 1
a1393 1
 
d1395 1
a1395 1
 
d1397 1
a1397 1
 
d1400 1
a1400 1
 
d1425 1
a1425 1
 
d1427 1
a1427 1
 
d1431 1
a1431 1
 
d1445 1
a1445 1
                  call Freq_Avg ( frequencies,                        &
d1468 1
a1468 1
 
d1472 1
a1472 1
 
d1474 1
a1474 1
 
d1476 1
a1476 1
            do k = 1, NO_MOL
d1493 9
a1501 7
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
                      k_atmos(i,ptg_i,surface,instance,k) = r
                      sv_i = sv_i + 1
d1511 5
a1515 3
                      k_atmos(i,ptg_i,surface,instance,k) = &
                        k_atmos_frq(1,sv_i)
                      sv_i = sv_i + 1
d1522 1
a1522 1
 
d1524 1
a1524 1
 
d1528 1
a1528 1
 
d1530 1
a1530 1
 
d1532 1
a1532 1
 
d1550 9
a1558 7
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dw_frq(:,sv_i), noFreqs, j, r )
                      k_spect_dw(i,ptg_i,surface,instance,k) = r
                      sv_i = sv_i + 1
d1567 5
a1571 3
                      k_spect_dw(i,ptg_i,surface,instance,k) = &
                        k_spect_dw_frq(1,sv_i)
                      sv_i = sv_i + 1
d1578 1
a1578 1
 
d1580 1
a1580 1
 
d1598 9
a1606 7
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dn_frq(:,sv_i), noFreqs, j, r )
                      k_spect_dn(i,ptg_i,surface,instance,k) = r
                      sv_i = sv_i + 1
d1615 5
a1619 3
                      k_spect_dn(i,ptg_i,surface,instance,k) = &
                        k_spect_dn_frq(1,sv_i)
                      sv_i = sv_i + 1
d1626 1
a1626 1
 
d1628 1
a1628 1
 
d1646 9
a1654 7
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dv_frq(:,sv_i), noFreqs, j, r)
                      k_spect_dv(i,ptg_i,surface,instance,k) = r
                      sv_i = sv_i + 1
d1663 5
a1667 3
                      k_spect_dv(i,ptg_i,surface,instance,k) = &
                        k_spect_dv_frq(1,sv_i)
                      sv_i = sv_i + 1
d1674 1
a1674 1
 
d1676 1
a1676 1
 
d1679 1
a1679 1
 
d1682 1
a1682 1
 
d1685 1
a1685 1
 
d1688 1
a1688 1
 
d1690 1
a1690 1
 
d1693 1
a1693 1
 
d1695 1
a1695 1
 
d1698 1
a1698 1
 
d1700 1
a1700 1
 
d1707 1
a1707 1
 
d1714 1
a1714 1
 
d1716 1
a1716 1
 
d1718 1
a1718 1
 
d1724 1
a1724 1
 
d1728 1
a1728 1
 
d1735 1
a1735 1
 
d1742 1
a1742 1
            &  Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
d1748 1
a1748 1
 
d1750 1
a1750 1
 
d1754 1
a1754 1
            &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
d1756 1
a1756 1
 
d1758 1
a1758 1
 
d1760 1
a1760 1
 
d1764 3
a1766 3
 
 
      ! Deallocate maxNoFreqs stuff
d1768 1
a1768 1
 
d1771 1
a1771 1
 
d1774 1
a1774 1
 
d1780 1
a1780 1
 
d1783 1
a1783 1
 
d1788 1
a1788 1
 
d1790 7
a1796 1
 
d1804 1
a1804 1
 
d1812 1
a1812 1
 
d1817 1
a1817 1
 
d1820 1
a1820 1
 
d1822 1
a1822 1
 
d1834 2
a1835 1
 
d1838 1
a1838 1
 
d1840 1
a1840 4
 
932   format (A,i2.2,A1,i4.4)
933   format ( 5(2x, 1pg13.6) )
 
d1842 1
a1842 1
 
d1844 1
a1844 1
 
d1884 1
a1884 1
 
d1886 1
a1886 1
 
d1889 1
a1889 1
 
d1894 1
a1894 1
 
d1897 1
a1897 1
 
d1903 1
a1903 1
 
d1911 1
a1911 1
 
d1921 1
a1921 1
 
d1928 1
a1928 1
 
d1930 1
a1930 1
 
d1940 1
a1940 1
 
d1944 1
a1944 1
 
d1946 1
a1946 1
 
d1950 1
a1950 1
 
d1954 1
a1954 1
 
d1958 1
a1958 1
 
d1962 1
a1962 1
 
d1964 1
a1964 1
 
d1969 1
a1969 1
 
d1971 1
a1971 1
 
d1975 1
a1975 1
 
d1977 1
a1977 1
 
d1979 1
a1979 1
 
d2073 1
a2073 1
 
d2076 1
a2076 1
 
d2079 1
a2079 1
 
d2082 1
a2082 1
 
d2085 1
a2085 1
 
d2088 1
a2088 1
 
d2091 1
a2091 1
 
d2094 1
a2094 1
 
d2097 1
a2097 1
 
d2100 1
a2100 1
 
d2103 1
a2103 1
 
d2106 1
a2106 1
 
d2109 1
a2109 1
 
d2112 1
a2112 1
 
d2115 1
a2115 1
 
d2118 1
a2118 1
 
d2121 1
a2121 1
 
d2124 1
a2124 1
 
d2127 1
a2127 1
 
d2130 1
a2130 1
 
d2133 1
a2133 1
 
d2136 1
a2136 1
 
d2139 1
a2139 1
 
d2142 1
a2142 1
 
d2145 1
a2145 1
 
d2148 1
a2148 1
 
d2151 1
a2151 1
 
d2154 1
a2154 1
 
d2157 1
a2157 1
 
d2160 1
a2160 1
 
d2163 1
a2163 1
 
d2166 1
a2166 1
 
d2169 1
a2169 1
 
d2172 1
a2172 1
 
d2175 1
a2175 1
 
d2178 1
a2178 1
 
d2181 1
a2181 1
 
d2184 1
a2184 1
 
d2187 1
a2187 1
 
d2190 1
a2190 1
 
d2193 1
a2193 1
 
d2196 1
a2196 1
 
d2199 1
a2199 1
 
d2202 1
a2202 1
 
d2205 1
a2205 1
 
d2208 1
a2208 1
 
d2211 1
a2211 1
 
d2214 1
a2214 1
 
d2217 1
a2217 1
 
d2220 1
a2220 1
 
d2223 1
a2223 1
 
d2226 1
a2226 1
 
d2229 1
a2229 1
 
@


2.22
log
@Some changes to my_catalog and one_tan_height and one_tan_temp
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.21 2001/12/26 04:05:04 zvi Exp $"
d488 1
a488 1
 
d495 1
a495 1
 
d563 1
a563 1
 
d640 2
d646 1
a646 1
     &   temp, My_Catalog )
a784 4
    call Allocate_test ( skip_eta_frq, no_mol, 'skip_eta_frq', ModuleName )
 
    skip_eta_frq = (Grids_f%no_f < 1)
 
d1904 1
a1904 1
    call Deallocate_test ( skip_eta_frq,   'skip_eta_frq',   ModuleName )
d1956 3
@


2.21
log
@Convert phi_tan to Radians
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.20 2001/12/14 23:43:05 zvi Exp $"
d196 3
a210 2
    real(rp), dimension(:), pointer :: ONE_TAN_HT ! ***
    real(rp), dimension(:), pointer :: ONE_TAN_TEMP ! ***
d336 1
a336 1
      & one_tan_ht, one_tan_temp, path_dsdh, phi_basis, phi_basis_dn, &
d565 1
d608 1
a618 3
    call allocate_test ( one_tan_ht, 1, 'one_tan_ht', ModuleName )
    call allocate_test ( one_tan_temp, 1, 'one_tan_temp', ModuleName )
 
d644 1
a644 1
     &   temp, My_Catalog)
d1824 2
a1825 1
      call Deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
d1829 3
d1845 1
a1845 3
    call Deallocate_test ( one_tan_ht, 'one_tan_ht', ModuleName )
    call Deallocate_test ( one_tan_temp, 'one_tan_temp', ModuleName )
 
d1958 3
@


2.20
log
@Modification for Grouping concept
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.19 2001/11/25 07:57:12 zvi Exp $"
d978 1
a978 1
          phi_tan = firstRadiance%template%phi(1,MAF)
d1956 3
@


2.19
log
@Fixing inconsistency in k_xxx instance loops
@
text
@d3 1
a3 1

d5 1
a5 1

d17 1
a17 1
  use GET_BETA_PATH_M, only: GET_BETA_PATH
d26 1
a26 1

d40 1
a40 1
  use String_table, only: GET_STRING
d45 1
a45 1
    & LIT_INDICES
d55 1
a55 1

d57 1
a57 1

d59 1
a59 1

d63 1
a63 1

d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.18 2001/11/20 10:23:27 zvi Exp $"
d71 1
a71 1

d73 1
a73 1

d85 1
a85 1

d89 1
a89 1

d92 1
a92 1

a99 1
    integer :: I                        ! Loop index and other uses .
d103 1
d106 1
d120 1
d150 1
a150 1

d153 1
a153 1

d156 1
a156 1

d164 1
a164 1

d167 1
a167 1

d171 1
a171 1

d173 1
a173 1

d181 1
a181 1

d184 1
a184 1

d195 1
a195 1

d233 1
a233 1

d237 1
a237 1

d268 1
a268 1

d270 1
a270 1

d284 1
a284 1

d286 1
a286 1

d290 1
a290 1

d294 1
a294 1

d299 1
a299 1

d302 1
a302 1

d310 7
a316 1

d319 1
a319 1

d322 1
a322 1

d324 1
a324 1

d326 1
a326 1
      & tan_inds, gl_inds )
d339 1
a339 1

d348 1
a348 1

d350 1
a350 1

d352 1
a352 1

d356 1
a356 1

d359 1
a359 1
    if ( any( fwdModelConf%signals%sideband .ne. &
d363 1
a363 1
    if ( any( fwdModelConf%signals%radiometer .ne. &
d367 1
a367 1

d371 1
a371 1

d373 1
a373 1

d395 1
a395 1

d400 1
a400 1

d415 1
a415 1

d429 1
a429 1

d432 1
d439 1
a439 1

d441 1
a441 1

d448 1
a448 1

d474 1
a474 1

d477 2
a478 1
      if ( fwdModelConf%molecules(specie) == l_extinction ) then
d483 1
a483 1
          & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
d487 73
d561 2
d567 1
a567 1

d569 2
a570 1
      Spectag = spec_tags(fwdModelConf%molecules(j))
d595 1
a595 1
          call get_string ( lit_indices(fwdModelConf%molecules(j)), molName )
d610 1
a610 1

d613 1
a613 1

d615 1
a615 1

d618 1
a618 1

d624 1
a624 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d628 1
a628 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d632 1
a632 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d636 1
a636 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d639 1
a639 1

d642 4
a645 3
     & firstSignal%radiometer, p_len, f_len, h2o_ind, ext_ind, lin_log, &
     & sps_values, Grids_f, Grids_dw, Grids_dn, Grids_dv, temp, My_Catalog)

d649 1
a649 1

d652 1
a652 1

d657 1
a657 1

d660 1
a660 1

d666 1
a666 1

d682 1
a682 1

d686 1
a686 1

d688 1
a688 1

d693 1
a693 1

d704 1
a704 1

d710 1
a710 1

d712 1
a712 1

d715 1
a715 1

d717 1
a717 1

d719 1
a719 1

d721 1
a721 1

d723 1
a723 2
    if ( ier /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d725 2
a726 2

    do i = 1, NOSPECIES
d733 1
a733 1

d735 2
a736 2
      allocate(gl_slabs_p(no_ele,NOSPECIES), &
        &  gl_slabs_m(no_ele,NOSPECIES), STAT=ier)
d739 2
a740 2

      do i = 1, NOSPECIES
d750 1
a750 1

d752 1
a752 1

d755 1
a755 1

d757 1
a757 1

d765 1
a765 1

d775 2
a776 2

    call Allocate_test ( beta_path_c, npc, noSpecies, 'beta_path_c', ModuleName )
d781 4
a784 4
    call Allocate_test ( sps_path, no_ele, noSpecies, 'sps_path', ModuleName )

    call Allocate_test ( skip_eta_frq, noSpecies, 'skip_eta_frq', ModuleName )

d786 1
a786 1

d788 1
a788 1

d790 1
a790 1

d792 1
a792 1

d794 1
a794 1
      call Allocate_test ( dbeta_dt_path_c, npc, noSpecies, 'dbeta_dt_path_c', ModuleName )
d800 1
a800 1

d802 1
a802 1

d806 1
a806 1

d808 1
a808 1

d810 2
a811 2

      call Allocate_test ( dbeta_dw_path_c, npc, noSpecies, &
d813 1
a813 1
      call Allocate_test ( dbeta_dn_path_c, npc, noSpecies, &
d815 1
a815 1
      call Allocate_test ( dbeta_dv_path_c, npc, noSpecies, &
d817 1
a817 1

d821 1
a821 1

d828 1
a828 1

d835 1
a835 1

d839 1
a839 1

d841 1
a841 1

d849 1
a849 1

d852 1
a852 1

d855 1
a855 1

d860 2
a861 2


d864 1
a864 1

d868 1
a868 1

d877 1
a877 1

d885 1
a885 1

d898 1
a898 1

d900 1
a900 1

d924 1
a924 1

d926 1
a926 1

d930 1
a930 1

d934 1
a934 1

d943 1
a943 1

d946 1
a946 1

d951 1
a951 1

d956 1
a956 1

d962 1
a962 1

d968 1
a968 1

d970 1
a970 1

d973 1
a973 1

d979 1
a979 1

d981 1
a981 1

d1011 1
a1011 1

d1043 1
a1043 1

d1057 1
a1057 1

d1061 1
a1061 1

d1065 1
a1065 1

d1070 1
a1070 1

d1079 1
a1079 1

d1091 1
a1091 1

d1095 1
a1095 1

d1102 1
a1102 1

d1105 1
a1105 1

d1110 1
a1110 1

d1120 1
a1120 1

d1123 1
a1123 1

d1131 1
a1131 1

d1135 1
a1135 1

d1138 1
a1138 1

d1142 1
a1142 1

d1144 1
a1144 1

d1146 1
a1146 1

d1151 1
a1151 1

d1153 1
a1153 1

d1155 4
a1158 3
              &  my_Catalog,gl_slabs,indecies_c(1:npc),beta_path_c(1:npc,:),&
              &  GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp,&
              &  GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp,&
d1163 1
a1163 1

d1165 1
a1165 1

d1167 2
a1168 1
              &  my_Catalog,gl_slabs,indecies_c(1:npc),beta_path_c(1:npc,:),&
d1172 1
a1172 1

d1174 5
a1178 5

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),       &
              &  my_Catalog,gl_slabs,indecies_c(1:npc),beta_path_c(1:npc,:),&
              &  DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                    &
              &  DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                    &
d1180 1
a1180 1

d1182 5
a1186 4

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &  my_Catalog,gl_slabs,indecies_c(1:npc),beta_path_c(1:npc,:))

d1188 1
a1188 1

d1191 1
a1191 1

d1194 1
a1194 1

d1196 1
a1196 1

d1199 1
a1199 1

d1201 1
a1201 1
          call Allocate_test ( beta_path_f, j, noSpecies, 'beta_path_f', &
d1206 1
a1206 1

d1208 1
a1208 1

d1210 1
a1210 1

d1220 1
a1220 1

d1222 1
a1222 1

d1225 1
a1225 1

d1228 2
a1229 2

            call Allocate_test ( dbeta_dt_path_f, j, noSpecies, &
d1231 1
a1231 1
            call Allocate_test ( dbeta_dw_path_f, j, noSpecies, &
d1233 1
a1233 1
            call Allocate_test ( dbeta_dn_path_f, j, noSpecies, &
d1235 1
a1235 1
            call Allocate_test ( dbeta_dv_path_f, j, noSpecies, &
d1237 3
a1239 3

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              & my_Catalog,gl_slabs,gl_inds,beta_path_f,                    &
d1244 1
a1244 1

d1246 2
a1247 2

            call Allocate_test ( dbeta_dt_path_f, j, noSpecies, &
d1249 2
a1250 2
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &   my_Catalog,gl_slabs,gl_inds,beta_path_f,                  &
d1254 1
a1254 1

d1256 2
a1257 2

            call Allocate_test ( dbeta_dw_path_f, j, noSpecies, &
d1259 1
a1259 1
            call Allocate_test ( dbeta_dn_path_f, j, noSpecies, &
d1261 1
a1261 1
            call Allocate_test ( dbeta_dv_path_f, j, noSpecies, &
d1264 1
a1264 1
              & my_Catalog,gl_slabs,gl_inds,beta_path_f,                    &
d1267 1
a1267 1

d1269 1
a1269 1

d1271 2
a1272 2
              &  my_Catalog,gl_slabs,gl_inds,beta_path_f)

d1274 1
a1274 1

d1276 1
a1276 1

d1283 1
a1283 1

d1285 1
a1285 1

d1287 1
a1287 1

d1289 1
a1289 1

d1298 1
a1298 1

d1300 1
a1300 1

d1302 1
a1302 1

d1304 1
a1304 1

d1319 1
a1319 1

d1321 1
a1321 1

d1323 1
a1323 1

d1325 1
a1325 1

d1327 1
a1327 1

d1336 1
a1336 1

d1338 1
a1338 1

d1340 1
a1340 1

d1349 1
a1349 1

d1351 1
a1351 1

d1353 1
a1353 1

d1362 1
a1362 1

d1364 1
a1364 1

d1366 1
a1366 1

d1371 1
a1371 1

d1375 1
a1375 1

d1381 1
a1381 1

d1383 1
a1383 1

d1387 1
a1387 1

d1390 1
a1390 1

d1392 1
a1392 1

d1394 1
a1394 1

d1397 1
a1397 1

d1422 1
a1422 1

d1424 1
a1424 1

d1428 1
a1428 1

d1465 1
a1465 1

d1469 1
a1469 1

d1471 1
a1471 1

d1473 2
a1474 1
          do specie = 1, noSpecies
d1489 1
a1489 1
                    do surface = 1, Grids_f%no_z(specie)
d1495 1
a1495 1
                      k_atmos(i,ptg_i,surface,instance,specie) = r
d1505 2
a1506 2
                    do surface = 1, Grids_f%no_z(specie)
                      k_atmos(i,ptg_i,surface,instance,specie) = &
d1514 2
a1515 2
          end do                          ! Loop over species

d1517 1
a1517 1

d1521 1
a1521 1

d1523 1
a1523 1

d1525 3
a1527 2

          do specie = 1, noSpecies
d1540 1
a1540 1
                  if(specie == 1) sv_i = 1
d1542 1
a1542 1
                    do surface = 1, Grids_dw%no_z(specie)
d1548 1
a1548 1
                      k_spect_dw(i,ptg_i,surface,instance,specie) = r
d1555 1
a1555 1
                  if(specie == 1) sv_i = 1
d1557 2
a1558 2
                    do surface = 1, Grids_dw%no_z(specie)
                      k_spect_dw(i,ptg_i,surface,instance,specie) = &
d1566 2
a1567 2
          end do                          ! Loop over species

d1569 3
a1571 2

          do specie = 1, noSpecies
d1584 1
a1584 1
                  if(specie == 1) sv_i = 1
d1586 1
a1586 1
                    do surface = 1, Grids_dn%no_z(specie)
d1592 1
a1592 1
                      k_spect_dn(i,ptg_i,surface,instance,specie) = r
d1599 1
a1599 1
                  if(specie == 1) sv_i = 1
d1601 2
a1602 2
                    do surface = 1, Grids_dn%no_z(specie)
                      k_spect_dn(i,ptg_i,surface,instance,specie) = &
d1610 2
a1611 2
          end do                          ! Loop over species

d1613 3
a1615 2

          do specie = 1, noSpecies
d1628 1
a1628 1
                  if(specie == 1) sv_i = 1
d1630 1
a1630 1
                    do surface = 1, Grids_dv%no_z(specie)
d1636 1
a1636 1
                      k_spect_dv(i,ptg_i,surface,instance,specie) = r
d1643 1
a1643 1
                  if(specie == 1) sv_i = 1
d1645 2
a1646 2
                    do surface = 1, Grids_dv%no_z(specie)
                      k_spect_dv(i,ptg_i,surface,instance,specie) = &
d1654 2
a1655 2
          end do                          ! Loop over species

d1657 1
a1657 1

d1660 1
a1660 1

d1663 1
a1663 1

d1666 1
a1666 1

d1669 1
a1669 1

d1671 1
a1671 1

d1674 1
a1674 1

d1676 1
a1676 1

d1679 1
a1679 1

d1681 1
a1681 1

d1688 1
a1688 1

d1695 1
a1695 1

d1697 1
a1697 1

d1699 1
a1699 1

d1705 1
a1705 1

d1709 1
a1709 1

d1716 1
a1716 1

d1729 1
a1729 1

d1731 1
a1731 1

d1737 1
a1737 1

d1739 1
a1739 1

d1741 1
a1741 1

d1745 2
a1746 2


d1749 1
a1749 1

d1752 1
a1752 1

d1755 1
a1755 1

d1761 1
a1761 1

d1764 1
a1764 1

d1769 1
a1769 1

d1771 1
a1771 1

d1779 1
a1779 1

d1787 1
a1787 1

d1792 1
a1792 1

d1795 1
a1795 1

d1797 1
a1797 1

d1804 2
a1805 2
          j = channel + thisRadiance%template%noChans*(ptg_i-1) 
          PrtRad(ptg_i) = thisRadiance%values(j,maf ) 
d1809 1
a1809 1

d1812 1
a1812 1

d1814 1
a1814 1

d1817 1
a1817 1

d1819 1
a1819 1

d1821 1
a1821 1

d1830 9
a1838 1

d1843 1
a1843 1

d1859 1
a1859 1

d1861 1
a1861 1

d1864 1
a1864 1

d1869 1
a1869 1

d1872 1
a1872 1

d1878 1
a1878 1

d1886 1
a1886 1

d1896 1
a1896 1

d1903 1
a1903 1

d1905 1
a1905 1

d1915 1
a1915 1

d1919 1
a1919 1

d1921 1
a1921 1

d1925 1
a1925 1

d1929 1
a1929 1

d1933 1
a1933 1

d1937 1
a1937 1

d1939 1
a1939 1

d1944 1
a1944 1

d1946 1
a1946 1

d1950 1
a1950 1

d1952 1
a1952 1

d1954 1
a1954 1

d1956 3
d2039 1
a2039 1

d2042 1
a2042 1

d2045 1
a2045 1

d2048 1
a2048 1

d2051 1
a2051 1

d2054 1
a2054 1

d2057 1
a2057 1

d2060 1
a2060 1

d2063 1
a2063 1

d2066 1
a2066 1

d2069 1
a2069 1

d2072 1
a2072 1

d2075 1
a2075 1

d2078 1
a2078 1

d2081 1
a2081 1

d2084 1
a2084 1

d2087 1
a2087 1

d2090 1
a2090 1

d2093 1
a2093 1

d2096 1
a2096 1

d2099 1
a2099 1

d2102 1
a2102 1

d2105 1
a2105 1

d2108 1
a2108 1

d2111 1
a2111 1

d2114 1
a2114 1

d2117 1
a2117 1

d2120 1
a2120 1

d2123 1
a2123 1

d2126 1
a2126 1

d2129 1
a2129 1

d2132 1
a2132 1

d2135 1
a2135 1

d2138 1
a2138 1

d2141 1
a2141 1

d2144 1
a2144 1

d2147 1
a2147 1

d2150 1
a2150 1

d2153 1
a2153 1

d2156 1
a2156 1

d2159 1
a2159 1

d2162 1
a2162 1

d2165 1
a2165 1

d2168 1
a2168 1

d2171 1
a2171 1

d2174 1
a2174 1

d2177 1
a2177 1

d2180 1
a2180 1

d2183 1
a2183 1

d2186 1
a2186 1

d2189 1
a2189 1

d2192 1
a2192 1

d2195 1
a2195 1

@


2.18
log
@Fixing window bug & diemsion
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.17 2001/11/20 01:18:59 zvi Exp $"
d1351 1
a1351 1
              do instance = 1, n_t_phi
d1398 1
a1398 1
                  do instance = 1, Grids_f%no_p(specie)
d1414 1
a1414 1
                  do instance = 1, Grids_f%no_p(specie)
d1450 1
a1450 1
                  do instance = 1, Grids_dw%no_p(specie)
d1465 1
a1465 1
                  do instance = 1, Grids_dw%no_p(specie)
d1493 1
a1493 1
                  do instance = 1, Grids_dn%no_p(specie)
d1508 1
a1508 1
                  do instance = 1, Grids_dn%no_p(specie)
d1536 1
a1536 1
                  do instance = 1, Grids_dv%no_p(specie)
d1551 1
a1551 1
                  do instance = 1, Grids_dv%no_p(specie)
d1855 3
@


2.17
log
@Fixing Shifting Window bug
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.16 2001/11/15 01:21:57 zvi Exp $"
d437 2
a438 1
    windowFinish = min(mafTInstance + phiWindow/2, n_t_phi)
d1367 1
a1367 1
              do instance = 1, n_t_phi
d1855 3
@


2.16
log
@Extiction debug fix
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.15 2001/11/10 00:46:40 zvi Exp $"
d302 1
d907 2
a908 1
              &  DHIDTLM=dh_dt_glgrid, DHITDTLM=dh_dt_path(1:no_ele,:),      &
d938 2
a939 1
              &  DHTDTL0=tan_dh_dt,DHIDTLM=dh_dt_glgrid,                     &
a1302 1

d1330 1
a1330 1
          Radiances(ptg_i,1:noFreqs) = RadV(1:noFreqs)
d1697 2
a1699 1
      Print 902,Ptan%values(1:k,maf)
d1702 3
a1704 1
      print *
d1706 1
d1708 6
a1713 5
        print 903, channel, char(92), ptan%template%noSurfs
903     format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
        print 905, &
          & firstRadiance%values(i:firstRadiance%template%InstanceLen:25,maf)
905     format ( 4(2x, 1pg15.8) )
d1716 5
d1854 3
@


2.15
log
@Adding the EXTINCTION capabilitis
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.14 2001/11/08 21:52:23 jonathan Exp $"
a235 3
    real(rp), dimension(:), pointer :: BN2_PATH_C ! Beta for N2 on path coarse
    real(rp), dimension(:), pointer :: BN2_PATH_F ! Beta for N2 on path fine

a339 2
    nullify ( bn2_path_c, bn2_path_f)

d555 1
a555 1
     & sps_values, Grids_f, Grids_dw, Grids_dn, Grids_dv)
a694 2
    call Allocate_test ( bn2_path_c, npc, 'bn2_path_c', ModuleName )

d697 1
a697 1
    skip_eta_frq = (Grids_f%no_f < 2)
d987 1
a987 1
            &   t_path(indecies_c(1:npc)),n_path(1:npc))
d1091 1
a1091 7
            if(ext_ind > 0) then
              call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &  my_Catalog,gl_slabs,indecies_c(1:npc),beta_path_c(1:npc,:), &
              &  ext_ind=ext_ind,bn2_path=bn2_path_c(1:npc))
              sps_path(indecies_c(1:npc),ext_ind) = 0.8061*bn2_path_c(1:npc)
            else
              call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
a1092 1
            endif
a1113 2
          call Allocate_test ( bn2_path_f, j, 'bn2_path_f', ModuleName )

d1170 1
a1170 1
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1177 2
a1178 9
            if(ext_ind > 0) then
              call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &  my_Catalog,gl_slabs,gl_inds,beta_path_f,               &
              &  ext_ind=ext_ind,bn2_path=bn2_path_f)
              sps_path(gl_inds,ext_ind) = 0.8061*bn2_path_f
            else
              call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &    my_Catalog,gl_slabs,gl_inds,beta_path_f)
            endif
a1278 2
          call Deallocate_test ( bn2_path_f, 'bn2_path_f', ModuleName )

a1789 2
    call Deallocate_test ( bn2_path_c, 'bn2_path_c', ModuleName )

d1842 3
d1866 1
a1866 1
! 
@


2.14
log
@add spec_tags to Molecules
@
text
@d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.13 2001/11/08 09:56:59 zvi Exp $"
d99 1
d159 1
a159 1
    integer, dimension(:), pointer :: EXT_IND_C ! Indecies on coarse grid
d235 4
d319 1
a319 1
    nullify ( grids, usedchannels, usedsignals, superset, ext_ind_c, &
d343 2
d491 2
a492 1
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), 'lineFlag', ModuleName )
d559 1
a559 1
     & firstSignal%radiometer, p_len, f_len, h2o_ind, lin_log, &
d689 1
a689 1
    call Allocate_test ( ext_ind_c,    npc, 'ext_ind_c',    ModuleName )
d700 2
a747 1

d879 2
a880 2
        ext_ind_c(:) = 0
        ext_ind_c(1:npc) = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)
d989 3
a991 3
          call refractive_index(p_path(ext_ind_c(1:npc)), &
            &  t_path(ext_ind_c(1:npc)),n_path(1:npc),    &
            &  h2o_path=sps_path((ext_ind_c(1:npc)),h2o_ind))
d993 2
a994 2
          call refractive_index(p_path(ext_ind_c(1:npc)), &
            &   t_path(ext_ind_c(1:npc)),n_path(1:npc))
d1009 1
a1009 1
        call comp_refcor(Req+h_path(ext_ind_c(1:npc)), &
d1071 8
a1078 8
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:), &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp, &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp, &
              & DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:),                    &
              & DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                    &
              & DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                    &
              & DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )
d1082 5
a1086 5
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:), &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp, &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp, &
              & DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:))
d1090 5
a1094 5
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),    &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:),&
              & DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                   &
              & DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                   &
              & DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )
d1098 9
a1106 3
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &   my_Catalog,gl_slabs,ext_ind_c(1:npc),  &
              &   beta_path_c(1:npc,:))
d1110 3
a1112 2
          alpha_path_c(1:npc) = SUM(sps_path(ext_ind_c(1:npc),:) &
            &    * beta_path_c(1:npc,:),DIM=2)
d1114 1
a1114 2
            &  fwdModelConf%tolerance,tau(1:npc),        &
            &  incoptdepth(1:npc),do_gl(1:npc))
d1122 4
a1125 2
          call Allocate_test ( beta_path_f, j, noSpecies, 'beta_path_f', ModuleName )
          call Allocate_test ( gl_indgen, Ng, no_gl_ndx, 'gl_indgen', ModuleName )
d1128 2
d1132 1
a1132 1
          ! Make (/(j-Ng-1,j=1,Ng)/), (/(j,j=1,Ng)/) parameter variables later on
d1193 7
a1199 1
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
d1201 1
d1207 2
a1208 2
          call rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,             &
            & z_path(ext_ind_c(1:npc)),t_path(ext_ind_c(1:npc)),            &
d1220 7
a1226 7
            call drad_tran_df(z_path(ext_ind_c(1:npc)),Grids_f%no_z,       &
              &  Grids_f%no_p,lin_log,sps_values,beta_path_c(1:npc,:),     &
              &  eta_fzp(ext_ind_c(1:npc),:),sps_path(ext_ind_c(1:npc),:), &
              &  do_calc_fzp(ext_ind_c(1:npc),:),beta_path_f,              &
              &  eta_fzp(gl_inds,:),sps_path(gl_inds,:),                   &
              &  do_calc_fzp(gl_inds,:),do_gl(1:npc),del_s(1:npc),         &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),    &
d1235 13
a1247 13
            call drad_tran_dt(z_path(ext_ind_c(1:npc)),                      &
              & Req+h_path(ext_ind_c(1:npc)),                                &
              & t_path(ext_ind_c(1:npc)),dh_dt_path(ext_ind_c(1:npc),:),     &
              & alpha_path_c(1:npc),SUM(sps_path(ext_ind_c(1:npc),:)         &
              & * dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),    &
              & eta_zxp_t(ext_ind_c(1:npc),:),do_calc_t(ext_ind_c(1:npc),:), &
              & do_calc_hyd(ext_ind_c(1:npc),:),del_s(1:npc),ref_corr(1:npc),&
              & Req + one_tan_ht(1),dh_dt_path(brkpt,:),frq,do_gl(1:npc),    &
              & req + h_path(gl_inds),t_path(gl_inds),dh_dt_path(gl_inds,:), &
              & SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
              & SUM(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
              & eta_zxp_t(gl_inds,:),do_calc_t(gl_inds,:),path_dsdh(gl_inds),&
              & dhdz_path(gl_inds),t_script(1:npc),tau(1:npc),i_stop,drad_dt,&
d1258 1
a1258 1
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),Grids_dw%no_z, &
d1260 2
a1261 2
              &  eta_zxp_dw(ext_ind_c(1:npc),:),sps_path(ext_ind_c(1:npc),:), &
              &  do_calc_dw(ext_ind_c(1:npc),:),dbeta_dw_path_f,      &
d1271 1
a1271 1
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),Grids_dn%no_z,   &
d1273 2
a1274 2
              &  eta_zxp_dn(ext_ind_c(1:npc),:),sps_path(ext_ind_c(1:npc),:), &
              &  do_calc_dn(ext_ind_c(1:npc),:),dbeta_dn_path_f,        &
d1284 1
a1284 1
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),Grids_dv%no_z,   &
d1286 2
a1287 2
              &  eta_zxp_dv(ext_ind_c(1:npc),:),sps_path(ext_ind_c(1:npc),:), &
              &  do_calc_dv(ext_ind_c(1:npc),:),dbeta_dv_path_f,        &
d1302 2
d1734 1
a1735 1
934   format (A,i2.2,A1,i5.5)
d1804 1
a1804 1
    call Deallocate_test ( ext_ind_c,    'ext_ind_c',    ModuleName )
d1815 2
d1869 3
@


2.13
log
@Fixing a bug..
@
text
@d38 1
a38 1
  use Molecules, only: L_EXTINCTION
a50 1
  use Molecules, only: spec_tags
d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.12 2001/11/08 00:11:29 livesey Exp $"
d1839 3
@


2.12
log
@Added extinction stuff
@
text
@d44 2
a45 1
    & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_VMR, L_REFGPH, LIT_INDICES
d67 1
a67 1
    & "$Id: FullForwardModel_m.f90,v 2.11 2001/11/07 21:19:01 livesey Exp $"
d1840 3
a2060 5





@


2.11
log
@Put Zvi's change comments back
@
text
@d38 1
d43 1
a43 1
    & L_ORBITINCLINATION, L_SPACERADIANCE, L_EARTHREFL, L_LOSVEL,       &
d66 1
a66 1
    & "$Id: FullForwardModel_m.f90,v 2.10 2001/11/07 21:16:56 livesey Exp $"
d464 7
a470 2
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
d551 2
a552 2
     &   p_len, f_len, h2o_ind, lin_log, sps_values, Grids_f, Grids_dw, &
     &   Grids_dn, Grids_dv)
d1839 3
d2057 5
@


2.10
log
@Now defaults to *not* using a line if no bands listed.
@
text
@d65 1
a65 1
    & "$Id: FullForwardModel_m.f90,v 2.9 2001/11/07 09:58:41 zvi Exp $"
d1833 3
d1838 7
@


2.9
log
@More effective code for sps_path calculations
@
text
@d65 1
a65 1
    & "$Id: FullForwardModel_m.f90,v 2.6 2001/10/12 20:40:25 livesey Exp $"
d482 4
a485 3
          do sigInd = 1, size(fwdModelConf%signals)
            if ( associated(thisLine%signals) ) then
              doThis = any ( thisLine%signals == fwdModelConf%signals(sigInd)%index )
d490 3
a492 5
            else
              doThis = .true.
            end if
            lineFlag(k) = lineFlag(k) .or. doThis
          end do ! End loop over signals requested in fwm
d1833 3
@


2.8
log
@Add more informative message if no spectroscopy information available
for a molecule
@
text
@d39 1
a39 1
  use String_table, only: GET_STRING, DISPLAY_STRING
d65 1
a65 1
    & "$Id: FullForwardModel_m.f90,v 2.7 2001/11/02 10:47:57 zvi Exp $"
a92 1
    integer :: CATINDEX                 ! Index for molecule
d168 2
d335 1
a335 1
      & t_glgrid, dh_dt_glgrid )
d475 1
a475 10
      catIndex = FindFirst(catalog%spec_tag == spectag)

      if ( catIndex < 1 ) then
        call output ( 'No catalog entry for molecule ' )
        call display_string ( lit_indices ( fwdModelConf%molecules(j) ), advance='yes' )
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Possible problem with spectroscopy catalog" )
      endif

      thisCatalogEntry => Catalog(catIndex)
d478 1
a478 2
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
          & 'lineFlag', ModuleName )
d484 1
a484 2
              doThis = any ( thisLine%signals == &
                & fwdModelConf%signals(sigInd)%index )
d687 4
d733 1
d965 9
a974 4
          Frq = 0.0
          call comp_sps_path_frq(Grids_f,Frq,sps_values,eta_zp(1:no_ele,:), &
            &  do_calc_zp(1:no_ele,:),lin_log,sps_path(1:no_ele,:),       &
            &  do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1052 2
a1053 2
               & do_calc_zp(1:no_ele,:),lin_log,sps_path(1:no_ele,:),       &
               & do_calc_fzp(1:no_ele,:),eta_fzp(1:no_ele,:))
d1782 2
a1833 3
! Revision 2.7  2001/11/02 10:47:57  zvi
! Implementing frequecy grid
!
@


2.7
log
@Implementing frequecy grid
@
text
@d39 1
a39 1
  use String_table, only: GET_STRING
d65 1
a65 1
    & "$Id: FullForwardModel_m.f90,v 2.6 2001/10/12 20:40:25 livesey Exp $"
d93 1
d474 10
a483 1
      thisCatalogEntry => Catalog(FindFirst(catalog%spec_tag == spectag ) )
d486 2
a487 1
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), 'lineFlag', ModuleName )
d493 2
a494 1
              doThis = any ( thisLine%signals == fwdModelConf%signals(sigInd)%index )
d1832 3
@


2.6
log
@Moved sideband ratio check
@
text
@d3 1
a3 1
 
d5 1
a5 1
 
d8 4
a11 2
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS, DESTROYCOMPLETESLABS
  use COMP_SPS_PATH_M, only: COMP_SPS_PATH
d26 1
a26 1
 
d35 1
a35 1
  use Load_sps_data_m, only: LOAD_SPS_DATA
d58 1
a58 1
 
d62 1
a62 1
 
d65 1
a65 1
    & "$Id: FullForwardModel_m.f90,v 2.5 2001/10/09 22:39:08 livesey Exp $"
d70 1
a70 1
 
d72 1
a72 1
 
d74 2
a75 2
  subroutine FullForwardModel ( FwdModelConf, FwdModelIn, FwdModelExtra, &
    &                       FwdModelOut, oldIfm, FmStat, Jacobian )
d96 1
a109 1
    integer :: N2LVL                    ! 2*nLvl
a121 8
    integer :: N_DN_PHI                 ! Number of phi's for all n's (spectroscopy)
    integer :: N_DN_ZETA                ! Number of zetas for all n's (spectroscopy)
    integer :: N_DV_PHI                 ! Number of phi's for all v's (spectroscopy)
    integer :: N_DV_ZETA                ! Number of zetas for all v's (spectroscopy)
    integer :: N_DW_PHI                 ! Number of phi's for all w's (spectroscopy)
    integer :: N_DW_ZETA                ! Number of zetas for all w's (spectroscopy)
    integer :: N_F_PHI                  ! Number of phis for all f's
    integer :: N_F_ZETA                 ! Number of zetas for all f's
a153 8
    integer, dimension(:), pointer :: NO_Z ! Number of z components (noSpecies)
    integer, dimension(:), pointer :: NO_PHI ! Number of phi components (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DW ! no. z compts. for w derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DW ! no. phi compts. for w derivative (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DN ! no. z compts. for n derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DN ! no. phi compts. for n derivative (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DV ! no. z compts. for v derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DV ! no. phi compts. for v derivative (noSpecies)
d168 2
a169 1
    logical, dimension(:,:), pointer :: DO_CALC ! 'Avoid zeros' indicator
d180 1
a180 1
    real(rp) :: DEL_TEMP            ! Temp. step-size in evaluation of Temp. power dep.
d205 4
a208 4
    real(rp), dimension(:), pointer :: PHI_BASIS ! phi basis per species (n_f_phi)
    real(rp), dimension(:), pointer :: PHI_BASIS_DN ! phi basis per species (n_dn_phi)
    real(rp), dimension(:), pointer :: PHI_BASIS_DV ! phi basis per species (n_dv_phi)
    real(rp), dimension(:), pointer :: PHI_BASIS_DW ! phi basis per species (n_dw_phi)
d243 2
a244 1
    real(rp), dimension(:,:), pointer :: ETA_ZXP ! Eta_z x Eta_p
d288 5
a302 1

d311 1
a311 2
    nullify ( grids, no_z, no_phi, no_z_dw, no_phi_dw, no_z_dn, no_phi_dn, &
      & no_z_dv, no_phi_dv, usedchannels, usedsignals, superset, ext_ind_c, &
d315 2
a316 2
    nullify ( do_calc, do_calc_dn, do_calc_dv, do_calc_dw, &
      & do_calc_hyd, do_calc_t )
d329 1
a329 1
      & dhdz_glgrid, dh_dt_path, dx_dt, d2x_dxdt, eta_zxp, eta_zxp_dn, &
d331 1
a331 1
      & k_spect_dn_frq, k_spect_dv_frq, k_spect_dw_frq, &
d544 2
a545 5
      f_len, n_f_phi, n_f_zeta, &
      h2o_ind, no_z, no_phi, lin_log, z_basis, phi_basis, sps_values, &
      n_dw_phi, n_dw_zeta, n_dn_phi, n_dn_zeta, n_dv_phi, n_dv_zeta, &
      no_z_dw, no_phi_dw, no_z_dn, no_phi_dn, no_z_dv, no_phi_dv, &
      z_basis_dw, phi_basis_dw, z_basis_dn, phi_basis_dn, z_basis_dv,phi_basis_dv )
a548 1
    n2lvl = 2 * nlvl
d679 4
a682 2
    call Allocate_test ( do_calc, no_ele, f_len, 'do_calc', ModuleName )
    call Allocate_test ( eta_zxp, no_ele, f_len, 'eta_zxp', ModuleName )
d716 17
a732 11
      sv_dw_len = SUM(no_z_dw(:) * no_phi_dw(:))
      sv_dn_len = SUM(no_z_dn(:) * no_phi_dn(:))
      sv_dv_len = SUM(no_z_dv(:) * no_phi_dv(:))

      call Allocate_test ( do_calc_dw, no_ele, sv_dw_len, 'do_calc_dw', ModuleName )
      call Allocate_test ( do_calc_dn, no_ele, sv_dn_len, 'do_calc_dn', ModuleName )
      call Allocate_test ( do_calc_dv, no_ele, sv_dv_len, 'do_calc_dv', ModuleName )

      call Allocate_test ( eta_zxp_dw, no_ele, sv_dw_len, 'eta_zxp_dw', ModuleName )
      call Allocate_test ( eta_zxp_dn, no_ele, sv_dn_len, 'eta_zxp_dn', ModuleName )
      call Allocate_test ( eta_zxp_dv, no_ele, sv_dv_len, 'eta_zxp_dv', ModuleName )
d745 2
a746 1
    call allocate_test ( d2x_dxdt, no_tan_hts, n_t_zeta, 'd2x_dxdt', ModuleName )
d805 1
a805 1
            &  frequencies(usedChannels(channel))
d942 9
a950 9
          call eval_spect_path(z_basis_dw,phi_basis_dw+phi_tan,       &
            &  no_z_dw,no_phi_dw,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dw(1:no_ele,:),eta_zxp_dw(1:no_ele,:))
          call eval_spect_path(z_basis_dn,phi_basis_dn+phi_tan,       &
            &  no_z_dn,no_phi_dn,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dn(1:no_ele,:),eta_zxp_dn(1:no_ele,:))
          call eval_spect_path(z_basis_dv,phi_basis_dv+phi_tan,       &
            &  no_z_dv,no_phi_dv,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dv(1:no_ele,:),eta_zxp_dv(1:no_ele,:))
d954 3
a956 5
        ! Now compute the sps_path
        call comp_sps_path(z_basis,phi_basis,sps_values,no_z,no_phi, &
          &   lin_log,z_path(1:no_ele),phi_path(1:no_ele),   &
          &   sps_path(1:no_ele,:),do_calc(1:no_ele,:),      &
          &   eta_zxp(1:no_ele,:))
d959 4
d1038 5
d1078 1
a1078 1
          alpha_path_c(1:npc) = sum(sps_path(ext_ind_c(1:npc),:) &
d1088 1
a1088 1
          
d1167 1
a1167 1
            & incoptdepth(1:npc),sum(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
d1177 7
a1183 6
            call drad_tran_df(z_path(ext_ind_c(1:npc)),no_z,no_phi,lin_log,&
              &  sps_values,beta_path_c(1:npc,:),eta_zxp(ext_ind_c(1:npc),:), &
              &  sps_path(ext_ind_c(1:npc),:),do_calc(ext_ind_c(1:npc),:),    &
              &  beta_path_f,eta_zxp(gl_inds,:),sps_path(gl_inds,:),          &
              &  do_calc(gl_inds,:),do_gl(1:npc),del_s(1:npc),                &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
d1192 2
a1193 2
            call drad_tran_dt(z_path(ext_ind_c(1:npc)),                    &
              & Req + h_path(ext_ind_c(1:npc)),                              &
d1195 1
a1195 1
              & alpha_path_c(1:npc),sum(sps_path(ext_ind_c(1:npc),:)         &
d1201 2
a1202 2
              & sum(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
              & sum(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
d1215 7
a1221 6
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dw,no_phi_dw,  &
              &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(ext_ind_c(1:npc),:),    &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dw(ext_ind_c(1:npc),:),&
              &  dbeta_dw_path_f,eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),  &
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
d1228 7
a1234 6
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dn,no_phi_dn,   &
              &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(ext_ind_c(1:npc),:),     &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dn(ext_ind_c(1:npc),:), &
              &  dbeta_dn_path_f,eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),   &
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
d1241 7
a1247 6
            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dv,no_phi_dv,  &
              &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(ext_ind_c(1:npc),:),    &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dv(ext_ind_c(1:npc),:),&
              &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),  &
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
d1279 1
a1279 1
        
d1359 1
a1359 1
          
d1375 2
a1376 2
                  do instance = 1, no_phi(specie)
                    do surface = 1, no_z(specie)
d1391 2
a1392 2
                  do instance = 1, no_phi(specie)
                    do surface = 1, no_z(specie)
d1427 2
a1428 2
                  do instance = 1, no_phi_dw(specie)
                    do surface = 1, no_z_dw(specie)
d1442 2
a1443 2
                  do instance = 1, no_phi_dw(specie)
                    do surface = 1, no_z_dw(specie)
d1470 2
a1471 2
                  do instance = 1, no_phi_dn(specie)
                    do surface = 1, no_z_dn(specie)
d1485 2
a1486 2
                  do instance = 1, no_phi_dn(specie)
                    do surface = 1, no_z_dn(specie)
d1513 2
a1514 2
                  do instance = 1, no_phi_dv(specie)
                    do surface = 1, no_z_dv(specie)
d1528 2
a1529 2
                  do instance = 1, no_phi_dv(specie)
                    do surface = 1, no_z_dv(specie)
d1764 4
a1767 2
    call Deallocate_test ( do_calc, 'do_calc', ModuleName )
    call Deallocate_test ( eta_zxp, 'eta_zxp', ModuleName )
d1818 1
a1818 1
 
d1820 3
@


2.5
log
@Allow for molecules with zero lines.  This may need attention
from Bill/Zvi later on.
@
text
@d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 2.4 2001/10/02 16:51:41 livesey Exp $"
a366 13
    if ( fwdModelConf%signals(1)%sideband == 0 ) then
      if (.not. associated (sidebandRatio) ) &
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      sidebandStart = fwdModelConf%signals(1)%sideband
      sidebandStop = sideBandStart
      sidebandStep = 1
    endif

d411 14
d1811 4
@


2.4
log
@Removed fmStat%finished and reordered loops in forward models
@
text
@d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 2.3 2001/09/19 04:38:48 livesey Exp $"
d482 37
a518 30
      ! Now subset the lines according to the signal we're using
      call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), 'lineFlag', ModuleName )
      lineFlag = .false.
      do k = 1, size ( thisCatalogEntry%lines )
        thisLine => lines(thisCatalogEntry%lines(k))
        do sigInd = 1, size(fwdModelConf%signals)
          if ( associated(thisLine%signals) ) then
            doThis = any ( thisLine%signals == fwdModelConf%signals(sigInd)%index )
            ! If we're only doing one sideband, maybe we can remove some more lines
            if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
              & any( ( thisLine%sidebands == sidebandStart ) .or. &
              & ( thisLine%sidebands == 0 ) )
          else
            doThis = .true.
          end if
          lineFlag(k) = lineFlag(k) .or. doThis
        end do ! End loop over signals requested in fwm
      end do ! End loop over lines
      My_Catalog(j) = thisCatalogEntry
      nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
      ! Check we have at least one line for this
      if ( count(lineFlag) == 0 ) then
        call get_string ( lit_indices(fwdModelConf%molecules(j)), molName )
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
          & 'No relevant lines for '//trim(molName) )
      endif
      call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
        & 'my_catalog(?)%lines', ModuleName )
      my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
      call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
d1810 3
@


2.3
log
@Lines per band stuff works now
@
text
@d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 2.2 2001/09/18 02:04:38 livesey Exp $"
a1793 2
    if ( maf == noMAFs ) fmStat%finished = .true.

d1803 3
@


2.2
log
@Bug fix with signals/spectroscopy interaction
@
text
@d37 1
d41 1
a41 1
    & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL, L_VMR, L_REFGPH
d44 1
a44 1
    & MLSMSG_Error
d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 2.1 2001/09/18 01:23:19 livesey Exp $"
d154 1
d489 1
a489 1
            doThis = any (fwdModelConf%signals%index == thisLine%signals(sigInd) )
d502 6
d1682 4
a1685 2
    call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )
d1689 3
d1805 3
@


2.1
log
@Added band discrimination for lines catalog.  Not tested yet.
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 2.0 2001/09/17 20:26:25 livesey Exp $"
d152 2
d481 5
a485 4
      do sigInd = 1, size(fwdModelConf%signals)
        call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), 'lineFlag', ModuleName )
        do k = 1, size ( thisCatalogEntry%lines )
          thisLine => lines(thisCatalogEntry%lines(k))
d487 1
a487 1
            lineFlag(k) = any (fwdModelConf%signals%index == thisLine%signals(sigInd) )
d489 1
a489 1
            if ( sidebandStart==sidebandStop ) lineFlag(k) = lineFlag(k) .and. &
d491 1
a491 1
              & ( thisLine%sidebands == 0 ))
d493 1
a493 1
            lineFlag(k) = .true.
d495 9
a503 8
        end do
        My_Catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
        call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
          & 'my_catalog(?)%lines', ModuleName )
        my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
        call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
      end do ! Loop over signals to be processed
d1792 3
@


2.0
log
@New forward model
@
text
@d37 1
a37 1
  use SpectroscopyCatalog_m, only: CATALOG_T, LINES, CATALOG
d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.56 2001/09/14 22:19:39 livesey Exp $"
d176 1
d293 2
a294 1

d340 2
d477 24
a500 2
      My_Catalog(j) = Catalog(FindFirst(catalog%spec_tag == spectag ) )
    end do
d1788 3
@


1.5
log
@Modified & new code(s) for better timing
@
text
@d3 1
a3 1

d5 9
a13 11

  use GLNP, only: NG
  use MLSCommon, only: I4, R4, R8
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
  use ELLIPSE_M, only: ELLIPSE
  use COMP_PATH_ENTITIES_M, only: COMP_PATH_ENTITIES
  use GET_PATH_SPSFUNC_NGRID_M, only: GET_PATH_SPSFUNC_NGRID
  use REFRACTION_M, only: REFRACTION_CORRECTION
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
      PATH_DERIVATIVE, PATH_VECTOR_2D, PATH_INT_VECTOR_2D
  use HYDROSTATIC_MODEL_M, only: HYDROSTATIC_MODEL
d15 3
a17 6
  use GET_BETA_PATH_M, only: GET_COARSE_BETA_PATH, GET_GLBETA_PATH
  use GEOC_GEOD_CONV_M, only: GEOC_GEOD_CONV
  use PATH_CONTRIB_M, only: PATH_CONTRIB
  use COARSE_DELTA_M, only: COARSE_DELTA
  use RAD_TRAN_M, only: RAD_TRAN
  use RAD_TRAN_WD_M, only: RAD_TRAN_WD
d24 1
d33 1
d38 1
a38 1
  use Intrinsic, only: L_TEMPERATURE, L_RADIANCE, L_PTAN, L_ELEVOFFSET, &
d49 4
a52 1
  use ManipulateVectorQuantities, only: FindClosestInstances
d55 1
a55 1

d59 1
a59 1

d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.4 2001/06/22 02:35:08 zvi Exp $"
d67 1
a67 1

d69 1
a69 1

d72 3
a74 6
    &                       FwdModelOut, Ifm, FmStat, Jacobian )


    ! Dummy arguments --------------------------------------------------------

    ! From ForwardModelSetup
d78 1
a78 1
    type(forwardModelIntermediate_T), intent(inout) :: Ifm ! Workspace
d82 1
a82 2
    ! Local parameters ---------------------------------------------------------

d84 1
d86 2
a87 6
    ! Local variables ----------------------------------------------------------

    ! First the old stuff which we hope to get rid of or redefine
    integer(i4) :: brkpt, ch, frq_i, i, ier, ihi, ilo, j, k, lmax, m, maf, &
      max_phi_dim, max_zeta_dim, mid, n, no_ele, no_tan_hts, &
      ptg_i, si, Spectag
d89 8
a96 24
    type(path_derivative) :: K_temp_frq
    type(path_derivative), allocatable, dimension(:) :: K_atmos_frq

    type(path_beta), dimension(:,:), pointer :: Beta_path

    real(r8) :: Frq, Geod_lat, H_tan, Phi_tan, Rad

    ! This is the `legit stuff' we hope will stay; they are all pointers to
    ! VectorValue_T's containing vector quantities.
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
    type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset quantity
    type (VectorValue_T), pointer :: F             ! An arbitrary species
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination (beta)
    type (VectorValue_T), pointer :: PTAN          ! PTAN quantity
    type (VectorValue_T), pointer :: FIRSTRADIANCE ! One radiance quantity to be filled
    type (VectorValue_T), pointer :: THISRADIANCE ! One radiance quantity to be filled
    type (VectorValue_T), pointer :: REFGPH        ! Reference GPH, (zRef and hRef)
    type (VectorValue_T), pointer :: SCGEOCALT     ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: SIDEBANDRATIO ! Sideband ratio for radiance
    type (VectorValue_T), pointer :: SPACERADIANCE ! Space radiance
    type (VectorValue_T), pointer :: TEMP          ! Temperature quantity

    integer :: CHANNEL                  ! Loop counter
d98 3
d106 4
a109 2
    integer :: N2LVL                    ! Twice size of tangent grid
    integer :: NLVL                     ! Size of tangent grid
d113 18
a130 4
    integer :: NOSPECIES                ! Number of molecules we're considering
    integer :: NOUSEDCHANNELS           ! Number of channels to output
    integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
    integer :: PHIWINDOW                ! Copy of forward model config%phiWindow
d135 7
a141 1
    integer :: SIGIND                   ! Loop counter
d143 6
a148 1
    integer :: STATUS                   ! From allocates etc.
a149 2
    integer :: THISSIDEBAND             ! Loop counter
    integer :: TOTALSIGNALS             ! Used when hunting for pointing grids
a150 34
    integer :: WHICHPOINTINGGRID        ! Index of pointing grid
    integer :: WINDOWFINISH             ! Range of window
    integer :: WINDOWSTART              ! Range of window

    real (r8) :: CENTERFREQ             ! Of band
    real (r8) :: CENTER_ANGLE           ! For angles
    real (r8) :: R                      ! To convert the kind of output from
    !                                     Freq_Avg
    real (r8) :: THISRATIO              ! A sideband ratio

    integer, dimension(:), pointer :: CHANNELINDEX ! E.g. 1..25
    integer, dimension(:), pointer :: GRIDS ! Frq grid for each tan_press
    integer, dimension(:), pointer :: SUPERSET ! Result of AreSignalsSuperset
    integer, dimension(:), pointer :: USEDCHANNELS ! Array of indices used
    integer, dimension(:), pointer :: USEDSIGNALS ! Array of indices used

    logical :: FOUNDINFIRST                     ! Flag to indicate derivatives

    real(r8), dimension(:,:),   pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:,:,:), pointer :: DH_DT_PATH  ! (pathSize, Tsurfs, Tinstance)
    real(r8), dimension(:), allocatable :: Dum
    real(r8), dimension(:,:),   pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
    real(r8), dimension(:),     pointer :: FREQUENCIES ! Frequency points
    real(r8), dimension(:,:),   pointer :: I_STAR_ALL    ! (noMIFs,noChans)
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS ! (channel,Nptg,mxco,mnp,Nsps)
    real(r4), dimension(:,:,:,:), pointer :: K_TEMP    ! (channel,Nptg,mxco,mnp)
    real(r8), dimension(:),     pointer :: PTG_ANGLES  ! (no_tan_hts)
    real(r8), dimension(:,:),   pointer :: RADIANCES     ! (Nptg,noChans)
    real(r8), dimension(:),     pointer :: RadV
    real(r8), dimension(:,:),   pointer :: REF_CORR    ! (n2lvl, no_tan_hts)
    real(kind(k_temp_frq%values)), &
      & dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
    real(r8), dimension(:),     pointer :: T_SCRIPT    ! (n2lvl)
    real(r8), dimension(:),     pointer :: TAU         ! (n2lvl)
d155 148
a302 1
    type(path_vector), dimension(:), allocatable :: N_PATH    ! (No_tan_hts)
a303 2
    ! dimensions of SPSFUNC_PATH are: (Nsps,No_tan_hts)
    type(path_vector), allocatable, dimension(:,:) :: SPSFUNC_PATH
d305 2
a306 4
    ! dimensions of SPS_PHI_LOOP  are: (Nsps,No_tan_hts)
    ! dimensions of SPS_ZETA_LOOP are: (Nsps,No_tan_hts)
    type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_PHI_LOOP
    type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_ZETA_LOOP
d308 2
a309 3
    Integer :: no_midval_ndx, no_gl_ndx, max_nl, max_num_frq
    Integer, DIMENSION(:,:), ALLOCATABLE :: gl_ndx, midval_ndx
    real(r8), dimension(:,:), pointer :: midval_delta   ! (N2lvl,Nsps)
d311 1
a311 1
    Type (slabs_struct), DIMENSION(:,:), POINTER :: gl_slabs
d313 24
a336 3
    type(signal_t) :: FirstSignal
    type(signal_t) :: ThisSignal
    type(catalog_T), dimension(:), pointer :: My_Catalog
d338 1
a338 12
    ! Executable code --------------------------------------------------------

    if ( toggle(emit) ) call trace_begin ( 'ForwardModel' )

    ! Nullify a bunch of pointers so that Allocate_Test doesn't try to
    ! deallocate them.  We don't want them to be initialized NULL()
    ! because that makes them SAVEd.

    nullify (beta_path, channelIndex, d2x_dxdt, dh_dt_path, dx_dt, &
      & frequencies, grids, i_star_all, k_atmos, k_temp, my_Catalog, &
      & ptg_angles, radiances, radV, ref_corr, superset, t_script, &
      & tau, usedChannels, usedSignals, midval_delta )
d359 15
d416 6
a421 59
    noSpecies = size(fwdModelConf%molecules)

    !  Create a subset of the catalog composed only of those molecules to be
    !  used for this run

    maxNoFSurfs = 0
    do specie = 1, noSpecies
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
      maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
    end do

    allocate ( My_Catalog(noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog' )

    max_nl = 1
    do j = 1, noSpecies
      Spectag = spec_tags(fwdModelConf%molecules(j))
      do i = 1, Size(Catalog)
        if ( Catalog(i)%Spec_Tag == Spectag ) then
          My_Catalog(j) = Catalog(i)
          m = Size(Catalog(i)%Lines)
          if(m > max_nl) max_nl = m
          EXIT
        end if
      end do
    end do

    ! Get the max. dimension in zeta coeff. space and phi coeff. space
    ! (To be used later in rad_tran_wd, for automatic arrays asignement)
    max_phi_dim = 1
    max_zeta_dim = 1
    if ( FwdModelConf%temp_der ) then
      max_zeta_dim = temp%template%noSurfs
      max_phi_dim = temp%template%noInstances
    end if

    if ( fwdModelConf%atmos_der ) then
      do k = 1, noSpecies
        if ( fwdModelConf%moleculeDerivatives(k) ) then
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            &     quantityType=l_vmr, molecule=fwdModelConf%molecules(k))
          j = f%template%noInstances
          max_phi_dim = max(max_phi_dim,j)
          j = f%template%noSurfs
          max_zeta_dim = max(max_zeta_dim,j)
        end if
      end do
    end if

    ! Deal with fmStat%rows
    if ( present(Jacobian) .and. ( .not. associated (fmStat%rows) ) ) then
      call Allocate_test ( fmStat%rows, Jacobian%row%nb, 'fmStat%rows', &
        & ModuleName)
      fmStat%rows = .false.
    endif

    ! Get some dimensions that we'll use a lot
a423 7
    no_phi_t = temp%template%noInstances
    no_tan_hts = FwdModelConf%TangentGrid%nosurfs
    nlvl=size(FwdModelConf%integrationGrid%surfs)
    n2lvl=2*nlvl
!   maxVert = n2lvl * (NG+1)
    maxVert = 2 * ( (NG+1) * (nlvl-1) + 1)
    phiWindow = FwdModelConf%phiWindow
d425 7
a431 14
    if ( toggle(emit) ) then
      print*,'Dimensions:'
      print*,'noMAFs:',noMAFs
      print*,'no_phi_t:',no_phi_t
      print*,'no_tan_hts:',no_tan_hts
      print*,'maxVert:',maxVert
      print*,'nlvl:',nlvl
      print*,'n2lvl:',n2lvl
      print*,'phiWindow:',phiWindow
      print*,'noSpecies:',noSpecies
      print*,'maxNoFSurfs:',maxNoFSurfs
      print*,'MAF:',fmStat%maf
      print*,'tolerance:',fwdModelConf%tolerance
    end if
d459 19
a477 2
    ! --------------- Hydrostatic stuff ---------------------------------
    if ( fmStat%newHydros ) then
d479 1
a479 2
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.hydrostatic' )
d481 2
a482 27
      ! Now we're going to create the many temporary arrays we need
      allocate ( ifm%ndx_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'ndx_path' )
      allocate ( ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'dhdz_path' )
      allocate ( ifm%h_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'h_path' )
      allocate ( ifm%phi_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'phi_path' )
      allocate ( ifm%t_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'t_path' )
      allocate ( ifm%z_path(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'z_path' )

      allocate ( ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'eta_phi' )

      allocate ( ifm%elvar(no_phi_t), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'elvar' )
d484 99
a582 2
      call allocate_test ( ifm%geoc_lat, no_phi_t, 'geoc_lat', ModuleName )
      call allocate_test ( ifm%e_rad, no_phi_t, 'e_rad', ModuleName )
d584 16
a599 25
      call allocate_test ( ifm%z_glgrid, maxVert/2, 'z_glgrid', ModuleName )
      call allocate_test ( ifm%h_glgrid, maxVert, no_phi_t, 'h_glgrid', &
        &  ModuleName )
      call allocate_test ( ifm%t_glgrid, maxVert, no_phi_t, 't_glgrid', &
        &  ModuleName )
      call allocate_test ( ifm%dh_dt_glgrid, maxVert, no_phi_t, &
        & temp%template%noSurfs,'dh_dt_glgrid', ModuleName )
      call allocate_test ( ifm%dhdz_glgrid, maxVert, no_phi_t, &
        &  'dhdz_glgrid', ModuleName )
      call allocate_test ( ifm%tan_hts, no_tan_hts, no_phi_t, 'tan_hts', &
        &  ModuleName )
      call allocate_test ( ifm%tan_temp, no_tan_hts, no_phi_t, 'tan_hts', &
        &  ModuleName )
      call allocate_test ( ifm%tan_dh_dt, no_tan_hts, no_phi_t, &
        & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
      call Allocate_test( ifm%closestInstances, noMAFs, 'closestInstances', ModuleName)

      ! Setup for hydrostatic calculation
      call FindClosestInstances ( temp, firstRadiance, ifm%closestInstances )

      do i = 1, no_phi_t
        phi_tan = Deg2Rad*temp%template%phi(1,i)
        geod_lat= Deg2Rad*temp%template%geodLat(1,i)
        call geoc_geod_conv ( ifm%elvar(i), orbIncline%values(1,1), &
          &  phi_tan, geod_lat, ifm%geoc_lat(i), ifm%E_rad(i) )
d601 1
d603 3
a605 12
      ! Now compute a hydrostatic grid given the temperature and refGPH
      ! information.
      call hydrostatic_model ( FwdModelConf%SurfaceTangentIndex, &
        &  no_phi_t, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
        &  refGPH%template%surfs(1,1), &
        &  FwdModelConf%integrationGrid%surfs, &
        &  temp%template%surfs(:,1), temp%values, &
        &  ifm%z_glgrid, ifm%h_glgrid, ifm%t_glgrid, &
        &  ifm%dhdz_glgrid, ifm%dh_dt_glgrid, &
        &  FwdModelConf%TangentGrid%surfs, &
        &  ifm%tan_hts, ifm%tan_temp, ifm%tan_dh_dt, &
        &  ifm%gl_count, Ier )
d607 1
a607 1
        & 'Hydrostatic model failed' )
d609 54
a662 10
      ! Now compute stuff along the path given this hydrostatic grid.
      call comp_path_entities ( temp, ifm%closestInstances, &
        &  FwdModelConf%integrationGrid%noSurfs, &
        &  temp%template%noSurfs, ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, &
        &  ifm%t_glgrid, ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts,        &
        &  no_tan_hts, ifm%z_path, ifm%h_path, ifm%t_path, ifm%phi_path,    &
        &  ifm%dhdz_path, ifm%eta_phi, no_phi_t,                            &
        &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier)
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Hydrostatic model failed' )
d664 1
a664 1
      fmStat%newHydros = .false.
d666 2
a667 2
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.hydrostatic' )
d670 63
a732 1
    ! ------ End of hydrostatic setup stuff --------------------------
d734 7
a740 43
    ! Skip this MAF if it's in an overlap region possibly
    maf=fmStat%maf
    if ( (.not. fwdModelConf%skipOverlaps) .or. &
      & ( maf > firstRadiance%template%noInstancesLowerOverlap .and. &
      &   maf <= noMAFs - firstRadiance%template%noInstancesUpperOverlap ) ) then

      ! ------ Begin main MAF Specific stuff ---------------------------

      ! Now allocate other stuff
      call allocate_test ( t_script, n2lvl, 't_srcipt', ModuleName )
      call allocate_test ( ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName )
      call allocate_test ( tau, n2lvl, 'tau', ModuleName )
      call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', ModuleName )

      call allocate_test ( midval_delta, n2lvl, noSpecies, &
                     &    'midval_delta', ModuleName )

      allocate ( k_atmos_frq(noSpecies), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_atmos_frq' )

      allocate ( n_path(No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'n_path' )
      allocate ( spsfunc_path(noSpecies,No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'spsfunc_path' )
      call allocate_test ( dx_dt, No_tan_hts, temp%template%noSurfs, &
        & 'dx_dt', ModuleName )
      call allocate_test ( d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
        & 'd2x_dxdt', ModuleName )

      allocate ( sps_phi_loop(noSpecies,No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'sps_phi_loop' )
      allocate ( sps_zeta_loop(noSpecies,No_tan_hts), stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'sps_zeta_loop' )

      call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
        & 'Radiances', ModuleName )
      call allocate_test ( i_star_all, noUsedChannels, noMIFs, &
        & 'i_star_all', ModuleName )
d742 22
a763 10
      ! Now set radiances to zero, forward model just adds in terms
      do i = 1, noUsedChannels
        thisRadiance = GetVectorQuantityByType (fwdModelOut, &
          & quantityType=l_radiance, &
          & signal=fwdModelConf%signals(usedSignals(i))%index, &
          & sideband=firstSignal%sideband )
        ch = usedChannels(i)
        do j = 1, noMIFs
          k = ch + (j-1)*thisRadiance%template%noChans
          thisRadiance%values(k, fmStat%maf) = 0.0
d765 21
a785 1
      end do
d787 11
a797 11
      if ( fwdModelConf%signals(1)%sideband == 0 ) then
        if (.not. associated (sidebandRatio) ) &
          & call MLSMessage(MLSMSG_Error,ModuleName, &
          & "No sideband ratio supplied")
        sidebandStart = -1
        sidebandStop = 1
        sidebandStep = 2
      else
        sidebandStart = fwdModelConf%signals(1)%sideband
        sidebandStop = sideBandStart
        sidebandStep = 1
d800 66
a865 2
      ! ----------------- Begin loop over sidebands -----------------------
      do thisSideband = sidebandStart, sidebandStop, sidebandStep
d867 103
a969 8
        if ( toggle(emit) .and. levels(emit) > 0 ) then
          call trace_begin ( 'ForwardModel.sideband' )
          call output ( ' Doing sideband ' )
          call output ( thisSideband )
          call output ( ' (' ); call output ( sidebandStart )
          call output ( ', ' ); call output ( sidebandStop )
          call output ( ')', advance='yes' )
        end if
d971 49
a1019 14
        ! Now code splits into two sections, one for when we're doing frequency
        ! averaging, and one when we're not.
        if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_begin ( 'ForwardModel.FreqAvg' )

          call allocate_test ( superset, size(pointingGrids), &
            & 'superset', ModuleName )
          do i = 1, size(pointingGrids)
            superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
              & fwdModelConf%signals, sideband=thisSideband )
          end do
          if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "No matching pointing frequency grids." )
d1021 1
a1021 12
          maxSuperset = maxval ( superset )
          where ( superset < 0 )
            superset = maxSuperset + 1
          end where
          whichPointingGridAsArray = minloc ( superset )
          whichPointingGrid = whichPointingGridAsArray(1)
          call deallocate_test ( superset, 'superset', ModuleName )

          if ( toggle(emit) ) then
            call output ( 'Using pointing frequency grid: ' )
            call output ( whichPointingGrid, advance='yes' )
          end if
d1023 3
a1025 37
          ! Now we've identified the pointing grids.  Locate the tangent grid
          ! within it.
          call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
            "Grids", ModuleName )
          call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
            & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_end ( 'ForwardModel.FreqAvg' )

        else ! ------------------------- Not frequency averaging ---------

          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_begin ( 'ForwardModel.NotFreqAvg' )

          call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
          do channel = 1, noUsedchannels
            frequencies(channel) = &
              & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
              & fwdModelConf%signals(usedSignals(channel))% &
              &  frequencies(usedChannels(channel))
          end do
          select case ( thisSideband )
          case ( -1 )
            frequencies = firstSignal%lo - frequencies
          case ( +1 )
            frequencies = firstSignal%lo + frequencies
          case ( 0 )
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Folded signal requested in forward model' )
          case default
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Bad value of signal%sideband' )
          end select
          noFreqs = noUsedChannels
          if ( toggle(emit) .and. levels(emit) > 0 ) &
            & call trace_end ( 'ForwardModel.NotFreqAvg' )
        end if
d1027 1
a1027 1
        ! ----------- Done the gnarly frequency stuff ----------
d1029 76
a1104 15
        ! Now work out what `window' we're inside.  This will need to be changed
        ! a bit in later versions to avoid the noMAFS==noTemp/f instances
        ! assertion

        mafTInstance = ifm%closestInstances(maf)

        windowStart  = max(1, mafTInstance - phiWindow/2)
        windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)

        if ( toggle(emit) .and. levels(emit) > 0 ) then
          print *, 'Doing MAF: ', maf
          Print *, 'mafTInstance:',mafTInstance
          print *, 'WindowStart:',WindowStart
          print *, 'WindowFinish:',WindowFinish
        end if
d1106 1
a1106 62
        allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
          & windowStart:windowFinish), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_temp' )
        allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_atmos' )

        ! Compute the specie function (spsfunc) and the refraction along
        ! all the paths for the current maf

        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
        Call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
          &  fwdModelConf%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
          &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), &
          &  n_path, spsfunc_path, sps_zeta_loop, sps_phi_loop, ier)
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'get_path_sps_fun_ngrid failed' )

        !??? Choose better value for phi_tan later
        phi_tan = Deg2Rad * temp%template%phi(1,mafTInstance)

        ! Compute the ptg_angles (chi) for Antenna convolution, also the
        ! derivatives of chi w.r.t to T and other parameters
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.get_chi_angles' )
        call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
          &  fwdModelConf%tangentGrid%surfs, &
          &  ifm%tan_hts(:,mafTInstance),ifm%tan_temp(:,mafTInstance),&
          &  phi_tan,ifm%elvar(maf)%Roc,&
          &  0.001*scGeocAlt%values(1,1),  &
          &  elevOffset%values(1,1), &
          &  ifm%tan_dh_dt(:,mafTInstance,:), no_tan_hts, &
          &  temp%template%noSurfs, &
          &  temp%template%surfs(:,1), &
          &  fwdModelConf%SurfaceTangentIndex, &
          &  center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.get_chi_angles' )
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'get_chi_angles failed' )

        ! Compute the refraction correction scaling matrix for this mmaf:
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.refraction_correction' )
        call refraction_correction ( no_tan_hts, ifm%tan_hts(:,mafTInstance), &
          &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
          &  ifm%E_rad(mafTInstance), ref_corr )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.refraction_correction' )

        Radiances = 0.0

        ! If we're not doing frequency averaging, instead outputting radiances
        ! corresponding to delta function responses, we can set up the frequency
        ! information here.  In the more common case where we are doing the
        ! averaging, the frequency grid varies from pointing to pointing, and is
        ! allocated inside the pointing loop.
d1108 2
a1109 11
        ! First we have a mini loop over pointings to work out an upper limit
        ! for the number of frequencies we're going to be dealing with
        if ( fwdModelConf%do_freq_avg ) then
          maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
          do ptg_i = 2, no_tan_hts - 1
            maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
              & %OneGrid(grids(ptg_i))%Frequencies) )
          end do
        else
          maxNoFreqs = noFreqs
        end if
d1111 1
a1111 8
        ! Now allocate arrays this size
        if ( fwdModelConf%temp_der ) then
          allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
            & windowStart:windowFinish), stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
            & MLSMSG_Allocate//'k_temp_frq' )
          k_temp_frq%values = 0.0_r8
        end if
d1113 1
a1113 1
        call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )
d1115 20
a1134 11
        do specie = 1, noSpecies
          f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
            & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )

          ! Allocate intermediate space for vmr derivatives
          if ( fwdModelConf%moleculeDerivatives(specie) ) then
            allocate ( k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
              & windowStart:windowFinish), stat=status )
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
              & MLSMSG_Allocate//'k_atmos_frq' )
          end if
d1136 1
a1136 1
        end do ! End loop over species
d1138 1
a1138 1
!  Find the maximum number of frequencies over all heights
d1140 1
a1140 17
        max_num_frq = 1
        i = whichPointingGrid
        if ( FwdModelConf%do_freq_avg ) then
          do j = 1, no_tan_hts
            m = Size(PointingGrids(i)%oneGrid(grids(j))%frequencies)
            if ( m > max_num_frq) max_num_frq = m
          end do
        end if
!
        ! Now we can go ahead and loop over pointings
        ! ------------------------------ Begin loop over pointings --------
        do ptg_i = 1, no_tan_hts - 1

          if ( toggle(emit) .and. levels(emit) > 1 ) then
            call trace_begin ( 'ForwardModel.Pointing' )
            call output ( 'Ptg = ' ); call output ( ptg_i, advance='yes' )
          end if
d1142 14
a1155 7
          k = ptg_i
          h_tan = ifm%tan_hts(k,mafTInstance)
          lmax = ubound(ifm%eta_phi(ptg_i,maf)%values,2)
!
          ifm%elvar(maf)%ht = h_tan
          ifm%elvar(maf)%Rr = ifm%elvar(maf)%ht + ifm%elvar(maf)%RoC
          ifm%elvar(maf)%ht2 = ifm%elvar(maf)%Rr * ifm%elvar(maf)%Rr
d1157 1
a1157 1
 ! Compute the beta's along the path, for this tanget hight and this mmaf:
a1158 8
          brkpt = ifm%ndx_path(ptg_i,maf)%break_point_index
          no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements
!
          if(ptg_i == 1) then
            j = no_ele / Ng
            allocate(midval_ndx(j,2),gl_ndx(j,2),stat=status)
            if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
              & MLSMSG_Allocate//'midval_ndx/gl_ndx' )
d1161 35
a1195 6
          ! If we're doing frequency averaging, get the frequencies we need for
          ! this pointing.
          if ( FwdModelConf%do_freq_avg ) then
            frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
            noFreqs = size(frequencies)
          end if ! If not, we dealt with this outside the loop
d1197 3
a1199 23
          if(noFreqs > 1) tau(1:) = 1.0
!
! Compute ALL the slabs_prep entities over the path's GL grid for this
! pointing & mmaf:
!
          Call get_gl_slabs_arrays(my_Catalog,ifm%z_path(ptg_i,maf),&
             & ifm%t_path(ptg_i,maf),0.001*losVel%values(1,maf), &
             & gl_slabs,ptg_i,no_ele,max_nl,ier)
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'get_gl_slabs_arrays' )
!
! Compute the beta's along the path on the COARSE grid only, for this pointing
! and this mmaf (recall that k=ptg_i):
!
          Call get_coarse_beta_path(k,my_Catalog,ifm%ndx_path(k,maf), &
             & gl_slabs,noFreqs,max_num_frq,h_tan,frequencies,        &
             & ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf), &
             & fwdModelConf%frqGap,fwdModelConf%temp_der,             &
             & fwdModelConf%spect_der, beta_path, Ier)
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'get_coarse_beta_path' )
!
          ! Define the dh_dt_path for this pointing and this MAF:
d1201 4
a1204 1
          ! Need to allocate this even if no derivatives as we pass it
d1206 3
a1208 2
          call allocate_test ( dh_dt_path, no_ele, phiWindow, &
            & temp%template%noSurfs, "dh_dt_path", ModuleName )
d1210 4
a1213 16
          if ( fwdModelConf%temp_der ) then
            allocate ( dum(no_ele), stat=ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & MLSMSG_Allocate // 'dum' )
            do j = 1, temp%template%noSurfs
              do i = 1, phiWindow
                m = min(lmax,i+windowStart-1)
                call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
                  &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
                  &           no_ele )
                dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
              end do
            end do
            deallocate ( dum, stat=ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
              & MLSMSG_DeAllocate // 'dum' )
d1216 41
a1256 65
          ! ------------------------------- Begin loop over frequencies ------
          do frq_i = 1, noFreqs
!
            Call path_contrib(tau, brkpt, no_ele, fwdModelConf%tolerance, &
              &  mid, midval_ndx, no_midval_ndx, gl_ndx, no_gl_ndx, Ier)
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Path_contrib failed' )
!
            Call coarse_delta(mid,brkpt,no_ele,ifm%h_path(k,maf), &
              &  beta_path(:,frq_i),spsfunc_path(:,k),        &
              &  noSpecies,Nlvl,ref_corr(:,k),ifm%elvar(maf),     &
              &  midval_delta,Ier)
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'coarse_delta failed' )
!
            Frq = frequencies(frq_i)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call trace_begin ( 'ForwardModel.Frequencies' )
              call output ( 'Frq = ' ); call output ( frq_i, advance='yes' )
            end if
!
! Compute the beta's along the path, for this tanget hight and this mmaf:
!
            Call get_glbeta_path(k,frq_i,my_Catalog,gl_ndx,no_gl_ndx, &
               & gl_slabs,Frq,ifm%z_path(k,maf),ifm%t_path(k,maf),    &
               & fwdModelConf%frqGap,fwdModelConf%temp_der,           &
               & fwdModelConf%spect_der, beta_path, Ier)
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'get_glbeta_path failed' )
!
            Call Rad_Tran ( ifm%elvar(maf), Frq,                         &
              &  fwdModelConf%integrationGrid%noSurfs,h_tan,noSpecies,   &
              &  ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf),  &
              &  ifm%dHdz_path(k,maf),earthRefl%values(1,1),             &
              &  beta_path(:,frq_i),spsfunc_path(:,k),ref_corr(:,k),     &
              &  spaceRadiance%values(1,1),brkpt,no_ele,mid,ilo,ihi,     &
              &  t_script,tau,midval_ndx,no_midval_ndx,gl_ndx,no_gl_ndx, &
              &  midval_delta,Rad,Ier)
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
              & 'rad_tran failed' )

            RadV(frq_i) = Rad

            ! Now, Compute the radiance derivatives:

            !??? Do we need to do this if there's no Jacobian or no derivatives requested ???

            Call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn,    &
              &  ifm%elvar(maf),frq_i,Frq,noSpecies,ifm%z_path(k,maf),     &
              &  ifm%h_path(k,maf),ifm%t_path(k,maf),ifm%phi_path(k,maf),  &
              &  ifm%dHdz_path(k,maf),beta_path(:,frq_i),spsfunc_path(:,k),&
              &  temp%template%surfs(:,1),temp%template%noSurfs,           &
              &  ref_corr(:,k),temp%template%noInstances,                  &
              &  temp%template%phi(1,:)*Deg2Rad,dh_dt_path,k_temp_frq,     &
              &  k_atmos_frq,brkpt,no_ele,mid,ilo,ihi,t_script,tau,        &
              &  max_zeta_dim,max_phi_dim,midval_ndx,no_midval_ndx,        &
              &  gl_ndx,no_gl_ndx,midval_delta,Sps_zeta_loop(:,k),         &
              &  Sps_phi_loop(:,k),Ier)
            if( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,     &
              & 'rad_tran_wd failed' )

            if ( toggle(emit) .and. levels(emit) > 2 ) &
              & call trace_end ( 'ForwardModel.Frequencies' )

          end do                          ! Frequency loop
d1258 1
a1258 1
          ! ----------------------------- End loop over frequencies ----
d1260 3
a1262 2
          ! Here we either frequency average to get the unconvolved radiances, or
          ! we just store what we have as we're using delta funciton channels
d1264 1
a1264 2
          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_begin ( 'ForwardModel.FrequencyAvg' )
d1268 3
a1270 12
              ch = usedChannels(i)
              if ( toggle(emit) .and. levels(emit) > 2 ) then
                call output ( 'Channel = ' )
                call output ( i )
                call output ( ' ( ' )
                call output ( sigInd )
                call output ( ':' )
                call output ( ch )
                call output ( ' )', advance='yes' )
              end if
              centerFreq = firstSignal%lo + &
                & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
d1272 16
a1287 14
                & fwdModelConf%signals(sigInd), sideband = thisSideband )
              if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                & "No matching channel shape information" )
              if ( toggle(emit) .and. levels(emit) > 2 ) then
                call output ( 'Using filter shape:' )
                call output ( shapeInd, advance='yes' )
              endif

              call Freq_Avg ( frequencies, &
                & centerFreq+thisSideband * &
                & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                & FilterShapes(shapeInd)%FilterShape(ch,:), RadV, noFreqs,  &
                & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
            end do
d1289 7
a1295 34
            Radiances(ptg_i,:) = RadV(1:noFreqs)
          end if

          ! Frequency Average the temperature derivatives with the appropriate
          ! filter shapes
          !??? Do we need to do this if there's no Jacobian ???
          if ( fwdModelConf%temp_der ) then
            if ( fwdModelConf%do_freq_avg ) then
              do i = 1, noUsedChannels
                sigInd = usedSignals(i)
                ch = usedChannels(i)
                centerFreq = firstSignal%lo + &
                  & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
                shapeInd = MatchSignal ( filterShapes%signal, &
                  & fwdModelConf%signals(sigInd), &
                  & sideband = thisSideband, channel=ch )
                do instance = lbound(k_temp_frq%values,3), &
                  & ubound(k_temp_frq%values,3)
                  do surface = 1, temp%template%noSurfs
                    ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
                    call Freq_Avg ( frequencies,                        &
                      & centerFreq+thisSideband* &
                      & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                      & FilterShapes(shapeInd)%FilterShape(ch,:),&
                      & real(ToAvg,r8), noFreqs, &
                      & Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
                    k_temp(i,ptg_i,surface,instance) = r
                  end do                  ! Surface loop
                end do                    ! Instance loop
              end do                      ! Channel loop
            else
              do i = 1, noUsedChannels
                k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
                  &  k_temp_frq%values(i,1:temp%template%noSurfs,:)
d1297 1
a1297 1
            end if
d1299 1
d1301 7
a1307 3
          ! Frequency Average the atmospheric derivatives with the appropriate
          ! filter shapes
          !??? Do we need to do this if there's no Jacobian ???
a1309 2
              f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
                &  quantityType=l_vmr, molecule=fwdModelConf%molecules(specie))
d1311 1
d1313 1
d1315 4
a1318 3
                  ch = usedChannels(i)
                  centerFreq = firstSignal%lo + &
                    & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
d1321 3
a1323 5
                    & sideband = thisSideband, channel=ch )
                  do instance = lbound(k_atmos_frq(specie)%values,3),&
                    & ubound(k_atmos_frq(specie)%values,3)
                    do surface = 1, f%template%noSurfs
                      ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
d1326 3
a1328 4
                        & FilterShapes(shapeInd)%FilterGrid(ch,:), &
                        & FilterShapes(shapeInd)%FilterShape(ch,:), &
                        & real(ToAvg,r8),  &
                        & noFreqs, Size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
d1330 1
d1335 1
a1335 1
                surface = f%template%noSurfs
d1337 8
a1344 2
                  k_atmos(i,ptg_i,1:surface,:,specie) = &
                    &  k_atmos_frq(specie)%values(i,1:surface,:)
d1350 5
a1354 2
          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_end ( 'ForwardModel.FrequencyAvg' )
d1356 44
a1399 1
          call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
d1401 1
a1401 2
          if ( toggle(emit) .and. levels(emit) > 1 ) &
            & call trace_end ( 'ForwardModel.Pointing' )
d1403 40
a1442 24
        end do                            ! Pointing Loop
        ! ---------------------------------- End of Pointing Loop ---------------
!
! ========= Pointings dependance deallocation section:
! (De-Allocate some of the arrays connected with pointing)
!
        deallocate(midval_ndx,gl_ndx,stat=status)
        if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
          & MLSMSG_DeAllocate // 'midval_ndx/gl_ndx' )

        do j = 1, size(gl_slabs,1)
          do i = 1, size(gl_slabs,2)
            deallocate(gl_slabs(j,i)%v0s, gl_slabs(j,i)%v0sm,     &
            &    gl_slabs(j,i)%v0sp, gl_slabs(j,i)%x1,            &
            &    gl_slabs(j,i)%y, gl_slabs(j,i)%yi,               &
            &    gl_slabs(j,i)%slabs1, gl_slabs(j,i)%dx1_dv0,     &
            &    gl_slabs(j,i)%dy_dv0, gl_slabs(j,i)%dslabs1_dv0, &
            &    gl_slabs(j,i)%v0sm, gl_slabs(j,i)%x1m,           &
            &    gl_slabs(j,i)%ym, gl_slabs(j,i)%yim,             &
            &    gl_slabs(j,i)%slabs1m, gl_slabs(j,i)%v0sp,       &
            &    gl_slabs(j,i)%x1p, gl_slabs(j,i)%yp,             &
            &    gl_slabs(j,i)%yip, gl_slabs(j,i)%slabs1p, STAT=k)
          end do
        end do
d1444 1
a1444 1
        deallocate ( gl_slabs, STAT=k )
d1446 40
a1485 9
        if ( associated(beta_path) ) then
          do i = 1, size(beta_path,1)
            do j = 1, size(beta_path,2)
              deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
                & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
                & beta_path(i,j)%dbeta_dnu, STAT=k )
            end do
          end do
        end if
d1487 1
a1487 6
        deallocate ( beta_path, STAT=k )
!
! ========= End of pointing dependence De-Allocate section
!
        ! Complete the radiance's last location; also complete k_temp last
        ! location.
d1489 2
a1490 19
        do i = 1, noUsedChannels
          ch = usedChannels(i)
          Radiances(no_tan_hts,i) = Radiances(no_tan_hts-1,i)
          if ( FwdModelConf%temp_der ) then
            n = temp%template%noSurfs
            k_temp(i,no_tan_hts,1:n,:) = k_temp(i,no_tan_hts-1,1:n,:)
          end if
          if ( FwdModelConf%atmos_der ) then
            do m = 1, noSpecies
              f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
                & quantityType=l_vmr, molecule=fwdModelConf%molecules(m),&
                & foundInFirst=foundInFirst )
              if ( foundInFirst ) then
                n = f%template%noSurfs
                k_atmos(i,no_tan_hts,1:n,:,m)= k_atmos(i,no_tan_hts-1,1:n,:,m)
              end if
            end do
          end if
        end do
d1492 2
a1493 6
        !  Here comes the Convolution code
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.Convolution' )
        call allocate_test ( superset, size(antennaPatterns), &
          & 'superset', ModuleName )
        do i = 1, noUsedChannels
d1495 2
a1496 12
          ch = usedChannels(i)
          sigInd = usedSignals(i)
          thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
            & signal=fwdModelConf%signals(sigInd)%index, &
            & sideband=firstSignal%sideband )

          if ( sidebandStart /= sidebandStop ) then ! We're folding
            thisRatio = sidebandRatio%values(ch,1)
            if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
          else ! Otherwise, want just unfolded signal
            thisRatio = 1.0
          end if
d1498 2
a1499 1
          if ( FwdModelConf%do_conv ) then
d1501 1
a1501 6
            do j = 1, size(antennaPatterns)
              superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
                & fwdModelConf%signals, sideband=thisSideband, channel=ch )
            end do
            if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & "No matching antenna patterns." )
d1503 2
a1504 28
            maxSuperset = maxval ( superset )
            where ( superset < 0 )
              superset = maxSuperset + 1
            end where
            whichPatternAsArray = minloc ( superset )
            whichPattern = whichPatternAsArray(1)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Using antenna pattern: ' )
              call output ( whichPattern, advance='yes' )
            end if

            call convolve_all ( fwdModelConf, fwdModelIn, maf, ch, &
              &     windowStart, windowFinish, mafTInstance-windowStart+1, &
              &     temp, ptan, thisRadiance, &
              &     FwdModelConf%tangentGrid%surfs, ptg_angles, &
              &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt, si, center_angle, &
              &     Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
              &     thisRatio, Jacobian, fmStat%rows,  &
              &     antennaPatterns(whichPattern), ier )
            !??? Need to choose some index other than 1 for AntennaPatterns ???
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'convolve_all failed' )
          else
            call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, ch,  &
              &     windowStart, windowFinish, temp, ptan, thisRadiance, &
              &     FwdModelConf%tangentGrid%surfs, &
              &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
              &     thisRatio, Jacobian, fmStat%rows )
d1506 1
a1506 1
          end if
d1508 2
a1509 1
        end do                            ! Channel loop
d1511 1
a1511 3
        call deallocate_test ( superset, 'superset', ModuleName )
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.Convolution' )
d1513 6
a1518 4
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.sideband' )
      end do
      ! ---------------------------- End of loop over sideband ------------------
d1520 6
a1525 1
      ! ------------------------------ End of Major Frame Specific stuff --------
d1527 1
a1527 8
      if ( FwdModelConf%temp_der ) call deallocate_test &
        & ( k_temp_frq%values, "k_temp_frq%values", ModuleName )
      if ( FwdModelConf%atmos_der ) then
        do j = 1, noSpecies
          call deallocate_test(k_atmos_frq(j)%values,"k_atmos_frq(j)%values",&
            & ModuleName )
        end do
      end if
a1528 2
      if ( index(switches,'rad') /= 0 ) then
        ! *** DEBUG Print
d1530 39
a1568 3
          print *,'Convolution: ON'
        else
          print *,'Convolution: OFF'
d1571 39
a1609 7
        if ( FwdModelConf%do_freq_avg ) then
          print *,'Frequency Averaging: ON'
        else
          Frq = Frequencies(1)
          print *,'Frequency Averaging: OFF'
          print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
        end if
d1611 6
a1616 16
        print *
        k=ptan%template%noSurfs
        print 901, k
901     format ( 'ptan\',i3.3)
        Print 902,Ptan%values(1:k,maf)
902     format ( 4(4x, f10.7))

        print *
        do i = 1, noUsedChannels
          ch = usedChannels(i)
          print 903, ch, char(92), ptan%template%noSurfs
903       format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
          print 905, ( firstRadiance%values(ch+(k-1)*firstRadiance%template%noChans,maf),&
            & k = 1, ptan%template%noSurfs )
905       format ( 4(2x, 1pg15.8) )
        end do
d1619 15
a1633 15
      do j = 1, No_tan_hts
        deallocate ( n_path(j)%values, stat=status )
        if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & MLSMSG_Deallocate//'n_path%values' )
        do i = 1, noSpecies
          deallocate ( spsfunc_path(i,j)%values, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Deallocate//'spsfunc_path%values' )
          deallocate ( sps_phi_loop(i,j)%values, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Deallocate//'sps_phi_loop%values' )
          deallocate ( sps_zeta_loop(i,j)%values, stat=status )
          if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & MLSMSG_Deallocate//'sps_zeta_loop%values' )
        end do
d1636 2
a1637 41
      deallocate ( n_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'n_path' )

      deallocate ( spsfunc_path, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'spsfunc_path' )

      deallocate ( sps_phi_loop, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'sps_phi_loop' )
      deallocate ( sps_zeta_loop, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'sps_zeta_loop' )

      call deallocate_test ( dx_dt, 'dx_dt', ModuleName )
      call deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

      call deallocate_test ( t_script, 't_srcipt', ModuleName )
      call deallocate_test ( ref_corr, 'ref_corr', ModuleName )
      call deallocate_test ( tau, 'tau', ModuleName )
      call deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
      call deallocate_test ( midval_delta, 'midval_delta', ModuleName )

      deallocate ( k_atmos_frq, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'k_atmos_frq' )
      deallocate ( k_temp, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'k_temp' )
      deallocate ( k_atmos, stat=status )
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
        & MLSMSG_Allocate//'k_atmos' )
      deallocate ( My_Catalog, stat=status)
      if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'My_catalog' )

      call deallocate_test ( radiances, 'Radiances', ModuleName )
      call deallocate_test ( i_star_all, 'i_star_all', ModuleName )
      call deallocate_test ( radv, 'rad_v', ModuleName )
      call deallocate_test ( grids, 'grids',  ModuleName )
d1639 1
a1639 4
    else
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call output ( 'This MAF skipped as in overlap region', advance='yes' )
    endif ! --------------------------- Possible skip of this major frame
d1641 1
a1641 1
    if ( maf == noMAFs ) fmStat%finished = .true.
d1643 1
d1646 73
d1720 3
a1722 2
    if ( .not. fwdModelConf%do_freq_avg ) call deallocate_test ( &
      & frequencies, "frequencies", ModuleName )
d1724 32
a1755 1
    if ( toggle(emit) ) call trace_end ( 'ForwardModel' )
d1759 171
a1929 1
end module FullForwardModel_m
a1930 1
! $Log: FullForwardModel_m.f90,v $
d1933 1
a1933 1
!
d1936 1
a1936 1
!
d1939 1
a1939 1
!
@


1.5.2.1
log
@Minor cosmetic change
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5 2001/07/04 00:34:24 zvi Exp $"
d1201 1
a1201 1
901     format ( 'ptan\ ',i3.3)
a1294 3
! Revision 1.5  2001/07/04 00:34:24  zvi
! Modified & new code(s) for better timing
!
@


1.5.2.2
log
@Starting new code developement
@
text
@d7 1
a7 2
  use SET_PRECISION_M
! use MLSCommon, only: I4, R4, R8
a202 22
!
!-------- Variables needed by Bill's & Zvi's New code  -------------------
!
    type Spect_Der_T
      Character(LEN=1) :: type
      Integer :: Spectag
      Integer :: no_phi_values
      Integer :: no_zeta_values
      Real(r8), dimension(:,:), pointer :: phi_basis => NULL()
      Real(r8), dimension(:,:), pointer :: zeta_basis => NULL()
    end type Spect_Der_T

    type(Spect_Der_T), ALLOCATABLE :: spect_der(:)
!
    Character(LEN=8) :: WNV
    Real(r8), POINTER :: p_glgrid(:)
    REAL(r8), ALLOCATABLE ::  xm(:),ym(:),zgx(:)

    Integer(ip) ::  NLm1, Ngp1, no_ss
    INTEGER(ip), ALLOCATABLE :: tan_inds(:),gl_indgen(:,:),gl_inds(:)
!
!-------- End of Variables needed by Bill's & Zvi's New code
d328 1
a328 47
!
!  *** ZEBUG
!
    if ( fwdModelConf%spect_der ) then
      j = 0
      WNV = '--WNV---'
      ALLOCATE(Spect_der(3*noSpecies))
      do k = 1, noSpecies
        Spectag = spec_tags(fwdModelConf%molecules(k))
        if(Spectag /= 18003) CYCLE
        j = j + 1
        Spect_der(j)%type = 'W'
        Spect_der(j)%Spectag = Spectag
        Spect_der(j)%no_phi_values = 3
        Spect_der(j)%no_zeta_values = 4
        ALLOCATE(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        ALLOCATE(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
        Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
        Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
        j = j + 1
        Spect_der(j)%type = 'N'
        Spect_der(j)%Spectag = Spectag
        Spect_der(j)%no_phi_values = 3
        Spect_der(j)%no_zeta_values = 4
        ALLOCATE(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        ALLOCATE(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
        Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
        Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
        j = j + 1
        Spect_der(j)%type = 'V'
        Spect_der(j)%Spectag = Spectag
        Spect_der(j)%no_phi_values = 5
        Spect_der(j)%no_zeta_values = 16
        ALLOCATE(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        ALLOCATE(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
        Spect_der(j)%phi_basis = (/-3.0,-1.5,0.0,1.5,3.0/)
        Spect_der(j)%zeta_basis = (/ &
            &  -1.000000, -0.666667, -0.333333,  0.000000,  0.333333, &
            &   0.666667,  1.000000,  1.333333,  1.666667,  2.000000, &
            &   2.333333,  2.666667,  3.000000,  3.333333,  3.666667, &
            &   4.000000 /)
      end do
      if(j < 1) DEALLOCATE(Spect_der,STAT=i)
    end if
!
!  *** END ZEBUG
!
d341 4
a344 5

    nlvl = Size(FwdModelConf%integrationGrid%surfs)
    n2lvl = 2 * nlvl
    maxVert = (Nlvl-1) * Ng + Nlvl

d425 1
a425 3
      call allocate_test ( ifm%z_glgrid, maxVert, 'z_glgrid', ModuleName )
      call allocate_test ( p_glgrid, maxVert, 'p_glgrid', ModuleName )

d445 5
a449 42
!zzzzzzzzzzzzzzz
!
      NLm1 = nlvl - 1
      Ngp1 = Ng + 1
      ALLOCATE(xm(NLm1),ym(NLm1),zgx(Ngp1),STAT=i)
!
! From the selected integration grid pressures define the GL pressure
! grid:
      zGx(1) = -1.0_rp
      zGx(2:Ngp1) = Gx(1:Ng)
      xm(1:NLm1) = 0.5_rp * ( &
                   &   FwdModelConf%integrationGrid%surfs(2:nlvl) + &
                   &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
      ym(1:NLm1) = 0.5_rp * ( &
                   &   FwdModelConf%integrationGrid%surfs(2:nlvl) - &
                   &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
      ifm%z_glgrid(1:maxVert-1) = RESHAPE ((SPREAD(xm,1,Ngp1) +          &
                            &   SPREAD(ym,1,Ngp1) * SPREAD(zGx,2,NLm1)), &
                            &  (/maxVert-1/))
      ifm%z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
      p_glgrid = 10.0_rp**(-ifm%z_glgrid)
      DEALLOCATE(xm,ym,zgx,STAT=i)
!
! insert into bill's 2 d hydrostatic
! The phi input for this program are the orbit plane projected
! geodetic locations of the temperature phi basis--not necessarily
! the tangent phi's which may be somewhat different.
!
      CALL two_d_hydrostatic(temp%template%surfs(:,1),
            &  temp%template%geodLat*Deg2Rad,   &
            &  temp%values, &
            &  SPREAD(refGPH%template%surfs(1,1),1,noMAFs),&
            &  0.001*refGPH%values(1,:),  &
            &  ifm%z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
            &  ifm%t_glgrid,ifm%h_glgrid,ifm%dhdz_glgrid, &
            &  ifm%dh_dt_glgrid)

      ALLOCATE(tan_inds(1:no_tan_hts))
      do k = 1, no_tan_hts
        Zeta = fwdModelConf%tangentGrid%surfs(k)
        CALL Hunt_zvi(Zeta,ifm%z_glgrid-0.0001_rp,maxVert,i,j)
        tan_inds(k) = i
a450 3
      no_ss = COUNT(tan_inds == 1) - 1
      FwdModelConf%SurfaceTangentIndex = no_ss + 1
      fmStat%newHydros = .false.
d452 25
a476 1
!zzzzzzzzzzzzzzzzzz
d478 1
a478 37
!     do i = 1, no_phi_t
!       phi_tan = Deg2Rad*temp%template%phi(1,i)
!       geod_lat= Deg2Rad*temp%template%geodLat(1,i)
!       call geoc_geod_conv ( ifm%elvar(i), orbIncline%values(1,1), &
!         &  phi_tan, geod_lat, ifm%geoc_lat(i), ifm%E_rad(i) )
!     end do
!
!     ! Now compute a hydrostatic grid given the temperature and refGPH
!     ! information.
!     call hydrostatic_model ( FwdModelConf%SurfaceTangentIndex, &
!       &  no_phi_t, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
!       &  refGPH%template%surfs(1,1), &
!       &  FwdModelConf%integrationGrid%surfs, &
!       &  temp%template%surfs(:,1), temp%values, &
!       &  ifm%z_glgrid, ifm%h_glgrid, ifm%t_glgrid, &
!       &  ifm%dhdz_glgrid, ifm%dh_dt_glgrid, &
!       &  FwdModelConf%TangentGrid%surfs, &
!       &  ifm%tan_hts, ifm%tan_temp, ifm%tan_dh_dt, &
!       &  ifm%gl_count, Ier )
!     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Hydrostatic model failed' )
!
!     ! Now compute stuff along the path given this hydrostatic grid.
!     call comp_path_entities ( temp, ifm%closestInstances, &
!       &  FwdModelConf%integrationGrid%noSurfs, &
!       &  temp%template%noSurfs, ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, &
!       &  ifm%t_glgrid, ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts,        &
!       &  no_tan_hts, ifm%z_path, ifm%h_path, ifm%t_path, ifm%phi_path,    &
!       &  ifm%dhdz_path, ifm%eta_phi, no_phi_t,                            &
!       &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier)
!     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & 'Hydrostatic model failed' )
!
!     fmStat%newHydros = .false.
!
!     if ( toggle(emit) .and. levels(emit) > 0 ) &
!       & call trace_end ( 'ForwardModel.hydrostatic' )
d480 2
a485 51
!zzzzzzzzzzzzzzzzzzzzzzzzzzz
!******************* LOAD SPECIES DATA (Including Spectroscopy) ********

    Call load_sps_data(fwdModelIn,fwdModelExtra,fwdModelConf%molecules,   &
        &     noSpecies,no_coeffs_f,no_phi_f,sv_len,n_sv_phi,n_sv_zeta,   &
        &     h2o_ind,no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,   &
        &     Spect_Der,WNV,n_sv_phi_dw,n_sv_zeta_dw,n_sv_phi_dn,         &
        &     n_sv_zeta_dn,n_sv_phi_dv,n_sv_zeta_dv,no_z_dw,no_phi_dw,    &
        &     no_z_dn,no_phi_dn,no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,&
        &     z_basis_dn,phi_basis_dn,z_basis_dv,phi_basis_dv)

!******************* LOAD gl_slabs structures ******

    no_ele = 2*maxVert ! maximum possible
    call allocate_test (gl_slabs, no_ele, noSpecies, 'gl_slabs', &
                    &   ModuleName )
!
    DO i = 1, noSpecies
      nl = Size(My_Catalog(i)%Lines)
      gl_slabs(1:no_ele,i)%no_lines = nl
      DO j = 1, no_ele
        ALLOCATE(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
            &    gl_slabs(j,i)%y(nl),gl_slabs(j,i)%yi(nl),   &
            &    gl_slabs(j,i)%slabs1(nl),                   &
            &    gl_slabs(j,i)%dslabs1_dv0(nl))
      END DO
    END DO
!
    IF ( FwdModelConf%temp_der ) THEN
      ALLOCATE(gl_slabs_p(no_ele,noSpecies), &
            &  gl_slabs_m(no_ele,noSpecies) )
      DO i = 1, noSpecies
        nl = Size(My_Catalog(i)%Lines)
        gl_slabs_m(1:no_ele,i)%no_lines = nl
        gl_slabs_p(1:no_ele,i)%no_lines = nl
        DO j = 1, no_ele
          ALLOCATE(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
              &    gl_slabs_p(j,i)%y(nl),gl_slabs_p(j,i)%yi(nl),   &
              &    gl_slabs_p(j,i)%slabs1(nl),                     &
              &    gl_slabs_p(j,i)%dslabs1_dv0(nl),                &
              &    gl_slabs_m(j,i)%v0s(nl),gl_slabs_m(j,i)%x1(nl), &
              &    gl_slabs_m(j,i)%y(nl),gl_slabs_m(j,i)%yi(nl),   &
              &    gl_slabs_m(j,i)%slabs1(nl),                     &
              &    gl_slabs_m(j,i)%dslabs1_dv0(nl)  )
        END DO
      END DO
    ENDIF

!******************* END of gl_slabs structures load ******
!zzzzzzzzzzzzzzzzzzzzzzzzzzz
!
d765 1
a765 1
        do ptg_i = 1, no_tan_hts
d1077 23
d1201 1
a1201 1
901     format ( 'ptan\',i3.3)
a1280 2

    DEALLOCATE(tan_inds,STAT=i)
@


1.5.2.3
log
@Cosmetic change again.
@
text
@d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.2 2001/09/07 19:58:49 zvi Exp $"
d1351 1
a1351 1
901     format ( 'ptan\ ',i3.3)
a1446 3
! Revision 1.5.2.2  2001/09/07 19:58:49  zvi
! Starting new code developement
!
@


1.5.2.4
log
@Changed stuff to lower case
@
text
@d42 1
a42 1
  use intrinsic, only: L_TEMPERATURE, L_RADIANCE, L_PTAN, L_ELEVOFFSET, &
d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.3 2001/09/07 20:05:26 livesey Exp $"
d195 2
a196 2
    integer :: no_midval_ndx, no_gl_ndx, max_nl, max_num_frq
    integer, dimension(:,:), allocatable :: gl_ndx, midval_ndx
d199 1
a199 1
    type (slabs_struct), dimension(:,:), pointer :: gl_slabs
d208 6
a213 6
      character(LEN=1) :: type
      integer :: Spectag
      integer :: no_phi_values
      integer :: no_zeta_values
      real(r8), dimension(:,:), pointer :: phi_basis => NULL()
      real(r8), dimension(:,:), pointer :: zeta_basis => NULL()
d216 1
a216 1
    type(Spect_Der_T), allocatable :: spect_der(:)
d218 3
a220 3
    character(LEN=8) :: WNV
    real(r8), pointer :: p_glgrid(:)
    real(r8), allocatable ::  xm(:),ym(:),zgx(:)
d222 2
a223 2
    integer(ip) ::  NLm1, Ngp1, no_ss
    integer(ip), allocatable :: tan_inds(:),gl_indgen(:,:),gl_inds(:)
d320 1
a320 1
      do i = 1, size(Catalog)
d323 1
a323 1
          m = size(Catalog(i)%Lines)
d325 1
a325 1
          exit
d357 1
a357 1
      allocate(Spect_der(3*noSpecies))
d360 1
a360 1
        if(Spectag /= 18003) cycle
d366 2
a367 2
        allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
d375 2
a376 2
        allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
d384 2
a385 2
        allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
        allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
d393 1
a393 1
      if(j < 1) deallocate(Spect_der,STAT=i)
d411 1
a411 1
    nlvl = size(FwdModelConf%integrationGrid%surfs)
d521 1
a521 1
      allocate(xm(NLm1),ym(NLm1),zgx(Ngp1),STAT=i)
d533 2
a534 2
      ifm%z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
                            &   spread(ym,1,Ngp1) * spread(zGx,2,NLm1)), &
d538 1
a538 1
      deallocate(xm,ym,zgx,STAT=i)
d545 1
a545 1
      call two_d_hydrostatic(temp%template%surfs(:,1),
d548 1
a548 1
            &  spread(refGPH%template%surfs(1,1),1,noMAFs),&
d554 1
a554 1
      allocate(tan_inds(1:no_tan_hts))
d557 1
a557 1
        call Hunt_zvi(Zeta,ifm%z_glgrid-0.0001_rp,maxVert,i,j)
d560 1
a560 1
      no_ss = count(tan_inds == 1) - 1
d611 1
a611 1
    call load_sps_data(fwdModelIn,fwdModelExtra,fwdModelConf%molecules,   &
d625 2
a626 2
    do i = 1, noSpecies
      nl = size(My_Catalog(i)%Lines)
d628 2
a629 2
      do j = 1, no_ele
        allocate(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
d633 2
a634 2
      end do
    end do
d636 2
a637 2
    if ( FwdModelConf%temp_der ) then
      allocate(gl_slabs_p(no_ele,noSpecies), &
d639 2
a640 2
      do i = 1, noSpecies
        nl = size(My_Catalog(i)%Lines)
d643 2
a644 2
        do j = 1, no_ele
          allocate(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
d652 3
a654 3
        end do
      end do
    endif
d820 1
a820 1
          print *, 'mafTInstance:',mafTInstance
d839 1
a839 1
        call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
d931 1
a931 1
            m = size(PointingGrids(i)%oneGrid(grids(j))%frequencies)
d977 1
a977 1
          call get_gl_slabs_arrays(my_Catalog,ifm%z_path(ptg_i,maf),&
d986 1
a986 1
          call get_coarse_beta_path(k,my_Catalog,ifm%ndx_path(k,maf), &
d1022 1
a1022 1
            call path_contrib(tau, brkpt, no_ele, fwdModelConf%tolerance, &
d1027 1
a1027 1
            call coarse_delta(mid,brkpt,no_ele,ifm%h_path(k,maf), &
d1042 1
a1042 1
            call get_glbeta_path(k,frq_i,my_Catalog,gl_ndx,no_gl_ndx, &
d1049 1
a1049 1
            call Rad_Tran ( ifm%elvar(maf), Frq,                         &
d1066 1
a1066 1
            call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn,    &
d1120 1
a1120 1
                & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
d1148 1
a1148 1
                      & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
d1186 1
a1186 1
                        & noFreqs, size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
d1352 1
a1352 1
        print 902,Ptan%values(1:k,maf)
d1432 1
a1432 1
    deallocate(tan_inds,STAT=i)
a1446 3
! Revision 1.5.2.3  2001/09/07 20:05:26  livesey
! Cosmetic change again.
!
@


1.5.2.5
log
@More comments
@
text
@d7 2
a8 1
  use MLSCommon, only: I4, R4, R8, RP, IP
d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.4 2001/09/07 20:16:37 livesey Exp $"
d73 1
a73 1
    &                       FwdModelOut, oldIfm, FmStat, Jacobian )
d82 1
a82 1
    type(forwardModelIntermediate_T), intent(inout) :: oldIfm ! Workspace
d88 1
a88 1
!     character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d90 1
a90 1
!     ! Local variables ----------------------------------------------------------
d92 129
a220 129
!     ! First the old stuff which we hope to get rid of or redefine
!     integer(i4) :: brkpt, ch, frq_i, i, ier, ihi, ilo, j, k, lmax, m, maf, &
!       max_phi_dim, max_zeta_dim, mid, n, no_ele, no_tan_hts, &
!       ptg_i, si, Spectag

!     type(path_derivative) :: K_temp_frq
!     type(path_derivative), allocatable, dimension(:) :: K_atmos_frq

!     type(path_beta), dimension(:,:), pointer :: Beta_path

!     real(r8) :: Frq, Geod_lat, H_tan, Phi_tan, Rad

!     ! This is the `legit stuff' we hope will stay; they are all pointers to
!     ! VectorValue_T's containing vector quantities.
!     type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
!     type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset quantity
!     type (VectorValue_T), pointer :: F             ! An arbitrary species
!     type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
!     type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination (beta)
!     type (VectorValue_T), pointer :: PTAN          ! PTAN quantity
!     type (VectorValue_T), pointer :: FIRSTRADIANCE ! One radiance quantity to be filled
!     type (VectorValue_T), pointer :: THISRADIANCE ! One radiance quantity to be filled
!     type (VectorValue_T), pointer :: REFGPH        ! Reference GPH, (zRef and hRef)
!     type (VectorValue_T), pointer :: SCGEOCALT     ! Geocentric spacecraft altitude
!     type (VectorValue_T), pointer :: SIDEBANDRATIO ! Sideband ratio for radiance
!     type (VectorValue_T), pointer :: SPACERADIANCE ! Space radiance
!     type (VectorValue_T), pointer :: TEMP          ! Temperature quantity

!     integer :: CHANNEL                  ! Loop counter
!     integer :: INSTANCE                 ! Loop counter
!     integer :: MAFTINSTANCE             ! Temperature instance closest to this MAF
!     integer :: MAXNOFREQS               ! Used for sizing arrays
!     integer :: MAXNOFSURFS              ! Max. no. surfaces for any molecule
!     integer :: MAXSUPERSET              ! Max. value of superset
!     integer :: MAXVERT                  ! Number of points in gl grid
!     integer :: N2LVL                    ! Twice size of tangent grid
!     integer :: NLVL                     ! Size of tangent grid
!     integer :: NOFREQS                  ! Number of frequencies for a pointing
!     integer :: NOMAFS                   ! Number of major frames
!     integer :: NOMIFS                   ! Number of minor frames
!     integer :: NOSPECIES                ! Number of molecules we're considering
!     integer :: NOUSEDCHANNELS           ! Number of channels to output
!     integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
!     integer :: PHIWINDOW                ! Copy of forward model config%phiWindow
!     integer :: SHAPEIND                 ! Index into filter shapes
!     integer :: SIDEBANDSTART            ! Loop limit
!     integer :: SIDEBANDSTEP             ! Loop step
!     integer :: SIDEBANDSTOP             ! Loop limit
!     integer :: SIGIND                   ! Loop counter
!     integer :: SPECIE                   ! Loop counter
!     integer :: STATUS                   ! From allocates etc.
!     integer :: SURFACE                  ! Loop counter
!     integer :: THISSIDEBAND             ! Loop counter
!     integer :: TOTALSIGNALS             ! Used when hunting for pointing grids
!     integer :: WHICHPATTERN             ! Index of antenna pattern
!     integer :: WHICHPOINTINGGRID        ! Index of pointing grid
!     integer :: WINDOWFINISH             ! Range of window
!     integer :: WINDOWSTART              ! Range of window

!     real (r8) :: CENTERFREQ             ! Of band
!     real (r8) :: CENTER_ANGLE           ! For angles
!     real (r8) :: R                      ! To convert the kind of output from
!     !                                     Freq_Avg
!     real (r8) :: THISRATIO              ! A sideband ratio

!     integer, dimension(:), pointer :: CHANNELINDEX ! E.g. 1..25
!     integer, dimension(:), pointer :: GRIDS ! Frq grid for each tan_press
!     integer, dimension(:), pointer :: SUPERSET ! Result of AreSignalsSuperset
!     integer, dimension(:), pointer :: USEDCHANNELS ! Array of indices used
!     integer, dimension(:), pointer :: USEDSIGNALS ! Array of indices used

!     logical :: FOUNDINFIRST                     ! Flag to indicate derivatives

!     real(r8), dimension(:,:),   pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
!     real(r8), dimension(:,:,:), pointer :: DH_DT_PATH  ! (pathSize, Tsurfs, Tinstance)
!     real(r8), dimension(:), allocatable :: Dum
!     real(r8), dimension(:,:),   pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
!     real(r8), dimension(:),     pointer :: FREQUENCIES ! Frequency points
!     real(r8), dimension(:,:),   pointer :: I_STAR_ALL    ! (noMIFs,noChans)
!     real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS ! (channel,Nptg,mxco,mnp,Nsps)
!     real(r4), dimension(:,:,:,:), pointer :: K_TEMP    ! (channel,Nptg,mxco,mnp)
!     real(r8), dimension(:),     pointer :: PTG_ANGLES  ! (no_tan_hts)
!     real(r8), dimension(:,:),   pointer :: RADIANCES     ! (Nptg,noChans)
!     real(r8), dimension(:),     pointer :: RadV
!     real(r8), dimension(:,:),   pointer :: REF_CORR    ! (n2lvl, no_tan_hts)
!     real(kind(k_temp_frq%values)), &
!       & dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
!     real(r8), dimension(:),     pointer :: T_SCRIPT    ! (n2lvl)
!     real(r8), dimension(:),     pointer :: TAU         ! (n2lvl)

!     integer, dimension(1) :: WHICHPOINTINGGRIDASARRAY ! Result of minloc
!     integer, dimension(1) :: WHICHPATTERNASARRAY      ! Result of minloc

!     type(path_vector), dimension(:), allocatable :: N_PATH    ! (No_tan_hts)

!     ! dimensions of SPSFUNC_PATH are: (Nsps,No_tan_hts)
!     type(path_vector), allocatable, dimension(:,:) :: SPSFUNC_PATH

!     ! dimensions of SPS_PHI_LOOP  are: (Nsps,No_tan_hts)
!     ! dimensions of SPS_ZETA_LOOP are: (Nsps,No_tan_hts)
!     type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_PHI_LOOP
!     type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_ZETA_LOOP

!     integer :: no_midval_ndx, no_gl_ndx, max_nl, max_num_frq
!     integer, dimension(:,:), allocatable :: gl_ndx, midval_ndx
!     real(r8), dimension(:,:), pointer :: midval_delta   ! (N2lvl,Nsps)

!     type (slabs_struct), dimension(:,:), pointer :: gl_slabs

!     type(signal_t) :: FirstSignal
!     type(signal_t) :: ThisSignal
!     type(catalog_T), dimension(:), pointer :: My_Catalog
! !
! !-------- Variables needed by Bill's & Zvi's New code  -------------------
! !
!     type Spect_Der_T
!       character(LEN=1) :: type
!       integer :: Spectag
!       integer :: no_phi_values
!       integer :: no_zeta_values
!       real(r8), dimension(:,:), pointer :: phi_basis => NULL()
!       real(r8), dimension(:,:), pointer :: zeta_basis => NULL()
!     end type Spect_Der_T

!     type(Spect_Der_T), allocatable :: spect_der(:)
! !
!     character(LEN=8) :: WNV
!     real(r8), pointer :: p_glgrid(:)
!     real(r8), allocatable ::  xm(:),ym(:),zgx(:)
d222 2
a223 2
!     integer(ip) ::  NLm1, Ngp1, no_ss
!     integer(ip), allocatable :: tan_inds(:),gl_indgen(:,:),gl_inds(:)
a227 1
    ! ------------------------------------------------------------------------
d229 1
d231 282
a512 1
    ! Work out what we've been asked to do -----------------------------------
d514 2
a515 1
    ! Start sorting out stuff from state vector ------------------------------
d517 86
a602 1
    ! Work out which spectroscopy we're going to need ------------------------
d604 1
a604 1
    ! Work out which channel shape information we're going need --------------
d606 1
a606 2
    ! Work out which pointing frequency grid we're going to need if ----------
    ! frequency averaging
d608 2
a609 2
    ! Work out which frequencies we're going to need in non frequency --------
    ! averaging case
d611 7
a617 44
    ! Now, allocate other variables we're going to need later ----------------

    ! Setup our temporary `state vector' like arrays -------------------------

    ! Compute hydrostatic grid -----------------------------------------------

    ! Compute Gauss Legendre (GL) grid ---------------------------------------

    ! Allocate path quantities -----------------------------------------------

    ! Loop over sidebands ----------------------------------------------------

      ! Loop over pointings --------------------------------------------------

        ! Setup path quantities ----------------------------------------------

        ! Work out what frequencies we're using for --------------------------
        ! frequency averaging case

        ! Loop over frequencies ----------------------------------------------
     
          ! Compute radiative transfer ---------------------------------------

          ! Compute derivatives if needed ------------------------------------

        ! End of frequency loop ----------------------------------------------

        ! Frequency averaging if needed --------------------------------------

        ! Frequency averaging of derivatives if needed -----------------------

      ! End of pointing loop -------------------------------------------------

      ! Work out which antenna patterns we're going to need ------------------

      ! Convolution if needed, or interpolation to ptan ----------------------

      ! Convolution of derivatives if needed, as appropriate -----------------

    ! End of loop over sidebands ---------------------------------------------

    ! Deallocate all variables allocated earlier -----------------------------

    ! Done -------------------------------------------------------------------
d619 1
d621 34
d656 296
d953 1
d955 16
d972 23
d996 1
d998 2
d1001 17
d1019 184
d1204 1
d1206 2
d1209 36
d1246 187
d1434 2
d1437 2
d1440 1
d1442 1
d1444 1
a1445 1254




























!     if ( toggle(emit) ) call trace_begin ( 'ForwardModel' )

!     ! Nullify a bunch of pointers so that Allocate_Test doesn't try to
!     ! deallocate them.  We don't want them to be initialized NULL()
!     ! because that makes them SAVEd.

!     nullify (beta_path, channelIndex, d2x_dxdt, dh_dt_path, dx_dt, &
!       & frequencies, grids, i_star_all, k_atmos, k_temp, my_Catalog, &
!       & ptg_angles, radiances, radV, ref_corr, superset, t_script, &
!       & tau, usedChannels, usedSignals, midval_delta )

!     ! Identify the vector quantities we're going to need.
!     ! The key is to identify the signal we'll be working with first
!     firstSignal = fwdModelConf%signals(1)

!     ! Now make sure all the signals we're dealing with are same module,
!     ! radiometer and sideband.
!     if ( any( fwdModelConf%signals%sideband .ne. &
!       & firstSignal%sideband ) ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       &  "Can't have mixed sidebands in forward model config")
!     if ( any( fwdModelConf%signals%radiometer .ne. &
!       & firstSignal%radiometer ) ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       &  "Can't have mixed radiometers in forward model config")

!     ! Now from that we identify the radiance quantity we'll be outputting
!     firstRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
!       & signal=firstSignal%index, sideband=firstSignal%sideband )

!     ! Identify the appropriate state vector components, save vmrs for later
!     temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_temperature )
!     ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule )
!     elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_elevOffset, radiometer=firstSignal%radiometer )
!     orbIncline => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_orbitInclination )
!     spaceRadiance => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_spaceRadiance )
!     earthRefl => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_earthRefl )
!     refGPH => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_refGPH )
!     losVel => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule )
!     scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_scGeocAlt )
!     sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!       & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.true. )

!     ! We won't seek for molecules here as we can't have an array of pointers.
!     ! When we do want molecule i we would do something like
!     ! vmr => GetVectorQuantityBytype (fwdModelIn, fwdModelExtra, &
!     !   quantityType=l_vmr, molecule=fwdModelConf.molecules(i))

!     ! Now we're going to validate the quantities we've been given, don't forget
!     ! we already know what their quantityType's are as that's how we found them
!     !, so we don't need to check that.
!     if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
!       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
!       & ModuleName, InvalidQuantity//'temperature' )
!     if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
!       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
!       & ModuleName, InvalidQuantity//'ptan' )
!     if ( .not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
!       & frequencyCoordinate=(/l_none/), noInstances=(/1/)) ) &
!       & call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & InvalidQuantity//'elevOffset' )
!     ! There will be more to come here.

!     noSpecies = size(fwdModelConf%molecules)

!     !  Create a subset of the catalog composed only of those molecules to be
!     !  used for this run

!     maxNoFSurfs = 0
!     do specie = 1, noSpecies
!       f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!         & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
!       maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
!     end do

!     allocate ( My_Catalog(noSpecies), stat=ier )
!     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!       & MLSMSG_Allocate//'my_catalog' )

!     max_nl = 1
!     do j = 1, noSpecies
!       Spectag = spec_tags(fwdModelConf%molecules(j))
!       do i = 1, size(Catalog)
!         if ( Catalog(i)%Spec_Tag == Spectag ) then
!           My_Catalog(j) = Catalog(i)
!           m = size(Catalog(i)%Lines)
!           if(m > max_nl) max_nl = m
!           exit
!         end if
!       end do
!     end do

!     ! Get the max. dimension in zeta coeff. space and phi coeff. space
!     ! (To be used later in rad_tran_wd, for automatic arrays asignement)
!     max_phi_dim = 1
!     max_zeta_dim = 1
!     if ( FwdModelConf%temp_der ) then
!       max_zeta_dim = temp%template%noSurfs
!       max_phi_dim = temp%template%noInstances
!     end if

!     if ( fwdModelConf%atmos_der ) then
!       do k = 1, noSpecies
!         if ( fwdModelConf%moleculeDerivatives(k) ) then
!           f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!             &     quantityType=l_vmr, molecule=fwdModelConf%molecules(k))
!           j = f%template%noInstances
!           max_phi_dim = max(max_phi_dim,j)
!           j = f%template%noSurfs
!           max_zeta_dim = max(max_zeta_dim,j)
!         end if
!       end do
!     end if
! !
! !  *** ZEBUG
! !
!     if ( fwdModelConf%spect_der ) then
!       j = 0
!       WNV = '--WNV---'
!       allocate(Spect_der(3*noSpecies))
!       do k = 1, noSpecies
!         Spectag = spec_tags(fwdModelConf%molecules(k))
!         if(Spectag /= 18003) cycle
!         j = j + 1
!         Spect_der(j)%type = 'W'
!         Spect_der(j)%Spectag = Spectag
!         Spect_der(j)%no_phi_values = 3
!         Spect_der(j)%no_zeta_values = 4
!         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
!         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
!         Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
!         Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
!         j = j + 1
!         Spect_der(j)%type = 'N'
!         Spect_der(j)%Spectag = Spectag
!         Spect_der(j)%no_phi_values = 3
!         Spect_der(j)%no_zeta_values = 4
!         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
!         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
!         Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
!         Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
!         j = j + 1
!         Spect_der(j)%type = 'V'
!         Spect_der(j)%Spectag = Spectag
!         Spect_der(j)%no_phi_values = 5
!         Spect_der(j)%no_zeta_values = 16
!         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
!         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
!         Spect_der(j)%phi_basis = (/-3.0,-1.5,0.0,1.5,3.0/)
!         Spect_der(j)%zeta_basis = (/ &
!             &  -1.000000, -0.666667, -0.333333,  0.000000,  0.333333, &
!             &   0.666667,  1.000000,  1.333333,  1.666667,  2.000000, &
!             &   2.333333,  2.666667,  3.000000,  3.333333,  3.666667, &
!             &   4.000000 /)
!       end do
!       if(j < 1) deallocate(Spect_der,STAT=i)
!     end if
! !
! !  *** END ZEBUG
! !
!     ! Deal with fmStat%rows
!     if ( present(Jacobian) .and. ( .not. associated (fmStat%rows) ) ) then
!       call Allocate_test ( fmStat%rows, Jacobian%row%nb, 'fmStat%rows', &
!         & ModuleName)
!       fmStat%rows = .false.
!     endif

!     ! Get some dimensions that we'll use a lot
!     noMAFs = firstRadiance%template%noInstances
!     noMIFs = firstRadiance%template%noSurfs
!     no_phi_t = temp%template%noInstances
!     no_tan_hts = FwdModelConf%TangentGrid%nosurfs

!     nlvl = size(FwdModelConf%integrationGrid%surfs)
!     n2lvl = 2 * nlvl
!     maxVert = (Nlvl-1) * Ng + Nlvl

!     phiWindow = FwdModelConf%phiWindow

!     if ( toggle(emit) ) then
!       print*,'Dimensions:'
!       print*,'noMAFs:',noMAFs
!       print*,'no_phi_t:',no_phi_t
!       print*,'no_tan_hts:',no_tan_hts
!       print*,'maxVert:',maxVert
!       print*,'nlvl:',nlvl
!       print*,'n2lvl:',n2lvl
!       print*,'phiWindow:',phiWindow
!       print*,'noSpecies:',noSpecies
!       print*,'maxNoFSurfs:',maxNoFSurfs
!       print*,'MAF:',fmStat%maf
!       print*,'tolerance:',fwdModelConf%tolerance
!     end if

!     ! Work out which channels are used, also check we have radiances for them.
!     noUsedChannels = 0
!     do sigInd = 1, size(fwdModelConf%signals)
!       thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
!         & signal=fwdModelConf%signals(sigInd)%index, sideband=firstSignal%sideband )
!       if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.true.,&
!         & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
!         & ModuleName, InvalidQuantity//'radiance' )
!       noUsedChannels = noUsedChannels + &
!         & count( fwdModelConf%signals(sigInd)%channels )
!     end do
!     call allocate_test ( usedChannels, noUsedChannels, &
!       & 'usedChannels', ModuleName )
!     call allocate_test ( usedSignals, noUsedChannels, &
!       & 'usedSignals', ModuleName )
!     channel = 1
!     do sigInd = 1, size(fwdModelConf%signals)
!       do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
!         if (fwdModelConf%signals(sigInd)%channels(i)) then
!           usedChannels(channel) = i
!           usedSignals(channel) = sigInd
!           channel = channel + 1
!         end if
!       end do
!     end do

!     ! --------------- Hydrostatic stuff ---------------------------------
!     if ( fmStat%newHydros ) then

!       if ( toggle(emit) .and. levels(emit) > 0 ) &
!         & call trace_begin ( 'ForwardModel.hydrostatic' )

!       ! Now we're going to create the many temporary arrays we need
!       call Allocate_test ( dhdz_path, no_tan_hts, noMAFs, 'dhdz_path', ModuleName )


!       allocate ( ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'dhdz_path' )
!       allocate ( ifm%h_path(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'h_path' )
!       allocate ( ifm%phi_path(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'phi_path' )
!       allocate ( ifm%t_path(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'t_path' )
!       allocate ( ifm%z_path(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'z_path' )

!       allocate ( ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'eta_phi' )

!       allocate ( ifm%elvar(no_phi_t), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'elvar' )

!       call allocate_test ( ifm%geoc_lat, no_phi_t, 'geoc_lat', ModuleName )
!       call allocate_test ( ifm%e_rad, no_phi_t, 'e_rad', ModuleName )

!       call allocate_test ( ifm%z_glgrid, maxVert, 'z_glgrid', ModuleName )
!       call allocate_test ( p_glgrid, maxVert, 'p_glgrid', ModuleName )

!       call allocate_test ( ifm%h_glgrid, maxVert, no_phi_t, 'h_glgrid', &
!         &  ModuleName )
!       call allocate_test ( ifm%t_glgrid, maxVert, no_phi_t, 't_glgrid', &
!         &  ModuleName )
!       call allocate_test ( ifm%dh_dt_glgrid, maxVert, no_phi_t, &
!         & temp%template%noSurfs,'dh_dt_glgrid', ModuleName )
!       call allocate_test ( ifm%dhdz_glgrid, maxVert, no_phi_t, &
!         &  'dhdz_glgrid', ModuleName )
!       call allocate_test ( ifm%tan_hts, no_tan_hts, no_phi_t, 'tan_hts', &
!         &  ModuleName )
!       call allocate_test ( ifm%tan_temp, no_tan_hts, no_phi_t, 'tan_hts', &
!         &  ModuleName )
!       call allocate_test ( ifm%tan_dh_dt, no_tan_hts, no_phi_t, &
!         & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
!       call Allocate_test( ifm%closestInstances, noMAFs, 'closestInstances', ModuleName)

!       ! Setup for hydrostatic calculation
!       call FindClosestInstances ( temp, firstRadiance, ifm%closestInstances )

! !zzzzzzzzzzzzzzz
! !
!       NLm1 = nlvl - 1
!       Ngp1 = Ng + 1
!       allocate(xm(NLm1),ym(NLm1),zgx(Ngp1),STAT=i)
! !
! ! From the selected integration grid pressures define the GL pressure
! ! grid:
!       zGx(1) = -1.0_rp
!       zGx(2:Ngp1) = Gx(1:Ng)
!       xm(1:NLm1) = 0.5_rp * ( &
!                    &   FwdModelConf%integrationGrid%surfs(2:nlvl) + &
!                    &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
!       ym(1:NLm1) = 0.5_rp * ( &
!                    &   FwdModelConf%integrationGrid%surfs(2:nlvl) - &
!                    &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
!       ifm%z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
!                             &   spread(ym,1,Ngp1) * spread(zGx,2,NLm1)), &
!                             &  (/maxVert-1/))
!       ifm%z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
!       p_glgrid = 10.0_rp**(-ifm%z_glgrid)
!       deallocate(xm,ym,zgx,STAT=i)
! !
! ! insert into bill's 2 d hydrostatic
! ! The phi input for this program are the orbit plane projected
! ! geodetic locations of the temperature phi basis--not necessarily
! ! the tangent phi's which may be somewhat different.
! !
!       call two_d_hydrostatic(temp%template%surfs(:,1),
!             &  temp%template%geodLat*Deg2Rad,   &
!             &  temp%values, &
!             &  spread(refGPH%template%surfs(1,1),1,noMAFs),&
!             &  0.001*refGPH%values(1,:),  &
!             &  ifm%z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
!             &  ifm%t_glgrid,ifm%h_glgrid,ifm%dhdz_glgrid, &
!             &  ifm%dh_dt_glgrid)

!       allocate(tan_inds(1:no_tan_hts))
!       do k = 1, no_tan_hts
!         Zeta = fwdModelConf%tangentGrid%surfs(k)
!         call Hunt_zvi(Zeta,ifm%z_glgrid-0.0001_rp,maxVert,i,j)
!         tan_inds(k) = i
!       end do
!       no_ss = count(tan_inds == 1) - 1
!       FwdModelConf%SurfaceTangentIndex = no_ss + 1
!       fmStat%newHydros = .false.

! !zzzzzzzzzzzzzzzzzz

! !     do i = 1, no_phi_t
! !       phi_tan = Deg2Rad*temp%template%phi(1,i)
! !       geod_lat= Deg2Rad*temp%template%geodLat(1,i)
! !       call geoc_geod_conv ( ifm%elvar(i), orbIncline%values(1,1), &
! !         &  phi_tan, geod_lat, ifm%geoc_lat(i), ifm%E_rad(i) )
! !     end do
! !
! !     ! Now compute a hydrostatic grid given the temperature and refGPH
! !     ! information.
! !     call hydrostatic_model ( FwdModelConf%SurfaceTangentIndex, &
! !       &  no_phi_t, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
! !       &  refGPH%template%surfs(1,1), &
! !       &  FwdModelConf%integrationGrid%surfs, &
! !       &  temp%template%surfs(:,1), temp%values, &
! !       &  ifm%z_glgrid, ifm%h_glgrid, ifm%t_glgrid, &
! !       &  ifm%dhdz_glgrid, ifm%dh_dt_glgrid, &
! !       &  FwdModelConf%TangentGrid%surfs, &
! !       &  ifm%tan_hts, ifm%tan_temp, ifm%tan_dh_dt, &
! !       &  ifm%gl_count, Ier )
! !     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
! !       & 'Hydrostatic model failed' )
! !
! !     ! Now compute stuff along the path given this hydrostatic grid.
! !     call comp_path_entities ( temp, ifm%closestInstances, &
! !       &  FwdModelConf%integrationGrid%noSurfs, &
! !       &  temp%template%noSurfs, ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, &
! !       &  ifm%t_glgrid, ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts,        &
! !       &  no_tan_hts, ifm%z_path, ifm%h_path, ifm%t_path, ifm%phi_path,    &
! !       &  ifm%dhdz_path, ifm%eta_phi, no_phi_t,                            &
! !       &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier)
! !     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
! !       & 'Hydrostatic model failed' )
! !
! !     fmStat%newHydros = .false.
! !
! !     if ( toggle(emit) .and. levels(emit) > 0 ) &
! !       & call trace_end ( 'ForwardModel.hydrostatic' )

!     end if

!     ! ------ End of hydrostatic setup stuff --------------------------

! !zzzzzzzzzzzzzzzzzzzzzzzzzzz
! !******************* LOAD SPECIES DATA (Including Spectroscopy) ********

!     call load_sps_data(fwdModelIn,fwdModelExtra,fwdModelConf%molecules,   &
!         &     no_coeffs_f,no_phi_f,sv_len,n_sv_phi,n_sv_zeta,   &
!         &     h2o_ind,no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,   &
!         &     Spect_Der,WNV,n_sv_phi_dw,n_sv_zeta_dw,n_sv_phi_dn,         &
!         &     n_sv_zeta_dn,n_sv_phi_dv,n_sv_zeta_dv,no_z_dw,no_phi_dw,    &
!         &     no_z_dn,no_phi_dn,no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,&
!         &     z_basis_dn,phi_basis_dn,z_basis_dv,phi_basis_dv)

! !******************* LOAD gl_slabs structures ******

!     no_ele = 2*maxVert ! maximum possible
!     call allocate_test (gl_slabs, no_ele, noSpecies, 'gl_slabs', &
!                     &   ModuleName )
! !
!     do i = 1, noSpecies
!       nl = size(My_Catalog(i)%Lines)
!       gl_slabs(1:no_ele,i)%no_lines = nl
!       do j = 1, no_ele
!         allocate(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
!             &    gl_slabs(j,i)%y(nl),gl_slabs(j,i)%yi(nl),   &
!             &    gl_slabs(j,i)%slabs1(nl),                   &
!             &    gl_slabs(j,i)%dslabs1_dv0(nl))
!       end do
!     end do
! !
!     if ( FwdModelConf%temp_der ) then
!       allocate(gl_slabs_p(no_ele,noSpecies), &
!             &  gl_slabs_m(no_ele,noSpecies) )
!       do i = 1, noSpecies
!         nl = size(My_Catalog(i)%Lines)
!         gl_slabs_m(1:no_ele,i)%no_lines = nl
!         gl_slabs_p(1:no_ele,i)%no_lines = nl
!         do j = 1, no_ele
!           allocate(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
!               &    gl_slabs_p(j,i)%y(nl),gl_slabs_p(j,i)%yi(nl),   &
!               &    gl_slabs_p(j,i)%slabs1(nl),                     &
!               &    gl_slabs_p(j,i)%dslabs1_dv0(nl),                &
!               &    gl_slabs_m(j,i)%v0s(nl),gl_slabs_m(j,i)%x1(nl), &
!               &    gl_slabs_m(j,i)%y(nl),gl_slabs_m(j,i)%yi(nl),   &
!               &    gl_slabs_m(j,i)%slabs1(nl),                     &
!               &    gl_slabs_m(j,i)%dslabs1_dv0(nl)  )
!         end do
!       end do
!     endif

! !******************* END of gl_slabs structures load ******
! !zzzzzzzzzzzzzzzzzzzzzzzzzzz
! !
!     ! Skip this MAF if it's in an overlap region possibly
!     maf=fmStat%maf
!     if ( (.not. fwdModelConf%skipOverlaps) .or. &
!       & ( maf > firstRadiance%template%noInstancesLowerOverlap .and. &
!       &   maf <= noMAFs - firstRadiance%template%noInstancesUpperOverlap ) ) then

!       ! ------ Begin main MAF Specific stuff ---------------------------

!       ! Now allocate other stuff
!       call allocate_test ( t_script, n2lvl, 't_srcipt', ModuleName )
!       call allocate_test ( ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName )
!       call allocate_test ( tau, n2lvl, 'tau', ModuleName )
!       call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', ModuleName )

!       call allocate_test ( midval_delta, n2lvl, noSpecies, &
!                      &    'midval_delta', ModuleName )

!       allocate ( k_atmos_frq(noSpecies), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'k_atmos_frq' )

!       allocate ( n_path(No_tan_hts), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'n_path' )
!       allocate ( spsfunc_path(noSpecies,No_tan_hts), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'spsfunc_path' )
!       call allocate_test ( dx_dt, No_tan_hts, temp%template%noSurfs, &
!         & 'dx_dt', ModuleName )
!       call allocate_test ( d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
!         & 'd2x_dxdt', ModuleName )

!       allocate ( sps_phi_loop(noSpecies,No_tan_hts), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'sps_phi_loop' )
!       allocate ( sps_zeta_loop(noSpecies,No_tan_hts), stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'sps_zeta_loop' )

!       call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
!         & 'Radiances', ModuleName )
!       call allocate_test ( i_star_all, noUsedChannels, noMIFs, &
!         & 'i_star_all', ModuleName )

!       ! Now set radiances to zero, forward model just adds in terms
!       do i = 1, noUsedChannels
!         thisRadiance = GetVectorQuantityByType (fwdModelOut, &
!           & quantityType=l_radiance, &
!           & signal=fwdModelConf%signals(usedSignals(i))%index, &
!           & sideband=firstSignal%sideband )
!         ch = usedChannels(i)
!         do j = 1, noMIFs
!           k = ch + (j-1)*thisRadiance%template%noChans
!           thisRadiance%values(k, fmStat%maf) = 0.0
!         end do
!       end do

!       if ( fwdModelConf%signals(1)%sideband == 0 ) then
!         if (.not. associated (sidebandRatio) ) &
!           & call MLSMessage(MLSMSG_Error,ModuleName, &
!           & "No sideband ratio supplied")
!         sidebandStart = -1
!         sidebandStop = 1
!         sidebandStep = 2
!       else
!         sidebandStart = fwdModelConf%signals(1)%sideband
!         sidebandStop = sideBandStart
!         sidebandStep = 1
!       endif

!       ! ----------------- Begin loop over sidebands -----------------------
!       do thisSideband = sidebandStart, sidebandStop, sidebandStep

!         if ( toggle(emit) .and. levels(emit) > 0 ) then
!           call trace_begin ( 'ForwardModel.sideband' )
!           call output ( ' Doing sideband ' )
!           call output ( thisSideband )
!           call output ( ' (' ); call output ( sidebandStart )
!           call output ( ', ' ); call output ( sidebandStop )
!           call output ( ')', advance='yes' )
!         end if

!         ! Now code splits into two sections, one for when we're doing frequency
!         ! averaging, and one when we're not.
!         if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
!           if ( toggle(emit) .and. levels(emit) > 0 ) &
!             & call trace_begin ( 'ForwardModel.FreqAvg' )

!           call allocate_test ( superset, size(pointingGrids), &
!             & 'superset', ModuleName )
!           do i = 1, size(pointingGrids)
!             superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
!               & fwdModelConf%signals, sideband=thisSideband )
!           end do
!           if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & "No matching pointing frequency grids." )

!           maxSuperset = maxval ( superset )
!           where ( superset < 0 )
!             superset = maxSuperset + 1
!           end where
!           whichPointingGridAsArray = minloc ( superset )
!           whichPointingGrid = whichPointingGridAsArray(1)
!           call deallocate_test ( superset, 'superset', ModuleName )

!           if ( toggle(emit) ) then
!             call output ( 'Using pointing frequency grid: ' )
!             call output ( whichPointingGrid, advance='yes' )
!           end if

!           ! Now we've identified the pointing grids.  Locate the tangent grid
!           ! within it.
!           call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
!             "Grids", ModuleName )
!           call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
!             & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
!           if ( toggle(emit) .and. levels(emit) > 0 ) &
!             & call trace_end ( 'ForwardModel.FreqAvg' )

!         else ! ------------------------- Not frequency averaging ---------

!           if ( toggle(emit) .and. levels(emit) > 0 ) &
!             & call trace_begin ( 'ForwardModel.NotFreqAvg' )

!           call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
!           do channel = 1, noUsedchannels
!             frequencies(channel) = &
!               & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
!               & fwdModelConf%signals(usedSignals(channel))% &
!               &  frequencies(usedChannels(channel))
!           end do
!           select case ( thisSideband )
!           case ( -1 )
!             frequencies = firstSignal%lo - frequencies
!           case ( +1 )
!             frequencies = firstSignal%lo + frequencies
!           case ( 0 )
!             call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'Folded signal requested in forward model' )
!           case default
!             call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'Bad value of signal%sideband' )
!           end select
!           noFreqs = noUsedChannels
!           if ( toggle(emit) .and. levels(emit) > 0 ) &
!             & call trace_end ( 'ForwardModel.NotFreqAvg' )
!         end if

!         ! ----------- Done the gnarly frequency stuff ----------

!         ! Now work out what `window' we're inside.  This will need to be changed
!         ! a bit in later versions to avoid the noMAFS==noTemp/f instances
!         ! assertion

!         mafTInstance = ifm%closestInstances(maf)

!         windowStart  = max(1, mafTInstance - phiWindow/2)
!         windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)

!         if ( toggle(emit) .and. levels(emit) > 0 ) then
!           print *, 'Doing MAF: ', maf
!           print *, 'mafTInstance:',mafTInstance
!           print *, 'WindowStart:',WindowStart
!           print *, 'WindowFinish:',WindowFinish
!         end if

!         allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
!           & windowStart:windowFinish), stat=status )
!         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!           & MLSMSG_Allocate//'k_temp' )
!         allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
!           & windowStart:windowFinish, noSpecies), stat=status )
!         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!           & MLSMSG_Allocate//'k_atmos' )

!         ! Compute the specie function (spsfunc) and the refraction along
!         ! all the paths for the current maf

!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
!         call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
!           &  fwdModelConf%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
!           &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), &
!           &  n_path, spsfunc_path, sps_zeta_loop, sps_phi_loop, ier)
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
!         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'get_path_sps_fun_ngrid failed' )

!         !??? Choose better value for phi_tan later
!         phi_tan = Deg2Rad * temp%template%phi(1,mafTInstance)

!         ! Compute the ptg_angles (chi) for Antenna convolution, also the
!         ! derivatives of chi w.r.t to T and other parameters
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_begin ( 'ForwardModel.get_chi_angles' )
!         call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
!           &  fwdModelConf%tangentGrid%surfs, &
!           &  ifm%tan_hts(:,mafTInstance),ifm%tan_temp(:,mafTInstance),&
!           &  phi_tan,ifm%elvar(maf)%Roc,&
!           &  0.001*scGeocAlt%values(1,1),  &
!           &  elevOffset%values(1,1), &
!           &  ifm%tan_dh_dt(:,mafTInstance,:), no_tan_hts, &
!           &  temp%template%noSurfs, &
!           &  temp%template%surfs(:,1), &
!           &  fwdModelConf%SurfaceTangentIndex, &
!           &  center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_end ( 'ForwardModel.get_chi_angles' )
!         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & 'get_chi_angles failed' )

!         ! Compute the refraction correction scaling matrix for this mmaf:
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_begin ( 'ForwardModel.refraction_correction' )
!         call refraction_correction ( no_tan_hts, ifm%tan_hts(:,mafTInstance), &
!           &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
!           &  ifm%E_rad(mafTInstance), ref_corr )
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_end ( 'ForwardModel.refraction_correction' )

!         Radiances = 0.0

!         ! If we're not doing frequency averaging, instead outputting radiances
!         ! corresponding to delta function responses, we can set up the frequency
!         ! information here.  In the more common case where we are doing the
!         ! averaging, the frequency grid varies from pointing to pointing, and is
!         ! allocated inside the pointing loop.

!         ! First we have a mini loop over pointings to work out an upper limit
!         ! for the number of frequencies we're going to be dealing with
!         if ( fwdModelConf%do_freq_avg ) then
!           maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
!           do ptg_i = 2, no_tan_hts - 1
!             maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
!               & %OneGrid(grids(ptg_i))%Frequencies) )
!           end do
!         else
!           maxNoFreqs = noFreqs
!         end if

!         ! Now allocate arrays this size
!         if ( fwdModelConf%temp_der ) then
!           allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
!             & windowStart:windowFinish), stat=status )
!           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
!             & MLSMSG_Allocate//'k_temp_frq' )
!           k_temp_frq%values = 0.0_r8
!         end if

!         call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )

!         do specie = 1, noSpecies
!           f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!             & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )

!           ! Allocate intermediate space for vmr derivatives
!           if ( fwdModelConf%moleculeDerivatives(specie) ) then
!             allocate ( k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
!               & windowStart:windowFinish), stat=status )
!             if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
!               & MLSMSG_Allocate//'k_atmos_frq' )
!           end if

!         end do ! End loop over species

! !  Find the maximum number of frequencies over all heights

!         max_num_frq = 1
!         i = whichPointingGrid
!         if ( FwdModelConf%do_freq_avg ) then
!           do j = 1, no_tan_hts
!             m = size(PointingGrids(i)%oneGrid(grids(j))%frequencies)
!             if ( m > max_num_frq) max_num_frq = m
!           end do
!         end if
! !
!         ! Now we can go ahead and loop over pointings
!         ! ------------------------------ Begin loop over pointings --------
!         do ptg_i = 1, no_tan_hts

!           if ( toggle(emit) .and. levels(emit) > 1 ) then
!             call trace_begin ( 'ForwardModel.Pointing' )
!             call output ( 'Ptg = ' ); call output ( ptg_i, advance='yes' )
!           end if

!           k = ptg_i
!           h_tan = ifm%tan_hts(k,mafTInstance)
!           lmax = ubound(ifm%eta_phi(ptg_i,maf)%values,2)
! !
!           ifm%elvar(maf)%ht = h_tan
!           ifm%elvar(maf)%Rr = ifm%elvar(maf)%ht + ifm%elvar(maf)%RoC
!           ifm%elvar(maf)%ht2 = ifm%elvar(maf)%Rr * ifm%elvar(maf)%Rr

!  ! Compute the beta's along the path, for this tanget hight and this mmaf:

!           brkpt = ifm%ndx_path(ptg_i,maf)%break_point_index
!           no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements
! !
!           if(ptg_i == 1) then
!             j = no_ele / Ng
!             allocate(midval_ndx(j,2),gl_ndx(j,2),stat=status)
!             if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
!               & MLSMSG_Allocate//'midval_ndx/gl_ndx' )
!           endif

!           ! If we're doing frequency averaging, get the frequencies we need for
!           ! this pointing.
!           if ( FwdModelConf%do_freq_avg ) then
!             frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
!             noFreqs = size(frequencies)
!           end if ! If not, we dealt with this outside the loop

!           if(noFreqs > 1) tau(1:) = 1.0
! !
! ! Compute ALL the slabs_prep entities over the path's GL grid for this
! ! pointing & mmaf:
! !
!           call get_gl_slabs_arrays(my_Catalog,ifm%z_path(ptg_i,maf),&
!              & ifm%t_path(ptg_i,maf),0.001*losVel%values(1,maf), &
!              & gl_slabs,ptg_i,no_ele,max_nl,ier)
!           if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & 'get_gl_slabs_arrays' )
! !
! ! Compute the beta's along the path on the COARSE grid only, for this pointing
! ! and this mmaf (recall that k=ptg_i):
! !
!           call get_coarse_beta_path(k,my_Catalog,ifm%ndx_path(k,maf), &
!              & gl_slabs,noFreqs,max_num_frq,h_tan,frequencies,        &
!              & ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf), &
!              & fwdModelConf%frqGap,fwdModelConf%temp_der,             &
!              & fwdModelConf%spect_der, beta_path, Ier)
!           if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & 'get_coarse_beta_path' )
! !
!           ! Define the dh_dt_path for this pointing and this MAF:

!           ! Need to allocate this even if no derivatives as we pass it

!           call allocate_test ( dh_dt_path, no_ele, phiWindow, &
!             & temp%template%noSurfs, "dh_dt_path", ModuleName )

!           if ( fwdModelConf%temp_der ) then
!             allocate ( dum(no_ele), stat=ier )
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
!               & MLSMSG_Allocate // 'dum' )
!             do j = 1, temp%template%noSurfs
!               do i = 1, phiWindow
!                 m = min(lmax,i+windowStart-1)
!                 call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
!                   &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
!                   &           no_ele )
!                 dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
!               end do
!             end do
!             deallocate ( dum, stat=ier )
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
!               & MLSMSG_DeAllocate // 'dum' )
!           end if

!           ! ------------------------------- Begin loop over frequencies ------
!           do frq_i = 1, noFreqs
! !
!             call path_contrib(tau, brkpt, no_ele, fwdModelConf%tolerance, &
!               &  mid, midval_ndx, no_midval_ndx, gl_ndx, no_gl_ndx, Ier)
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'Path_contrib failed' )
! !
!             call coarse_delta(mid,brkpt,no_ele,ifm%h_path(k,maf), &
!               &  beta_path(:,frq_i),spsfunc_path(:,k),        &
!               &  noSpecies,Nlvl,ref_corr(:,k),ifm%elvar(maf),     &
!               &  midval_delta,Ier)
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'coarse_delta failed' )
! !
!             Frq = frequencies(frq_i)
!             if ( toggle(emit) .and. levels(emit) > 2 ) then
!               call trace_begin ( 'ForwardModel.Frequencies' )
!               call output ( 'Frq = ' ); call output ( frq_i, advance='yes' )
!             end if
! !
! ! Compute the beta's along the path, for this tanget hight and this mmaf:
! !
!             call get_glbeta_path(k,frq_i,my_Catalog,gl_ndx,no_gl_ndx, &
!                & gl_slabs,Frq,ifm%z_path(k,maf),ifm%t_path(k,maf),    &
!                & fwdModelConf%frqGap,fwdModelConf%temp_der,           &
!                & fwdModelConf%spect_der, beta_path, Ier)
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'get_glbeta_path failed' )
! !
!             call Rad_Tran ( ifm%elvar(maf), Frq,                         &
!               &  fwdModelConf%integrationGrid%noSurfs,h_tan,noSpecies,   &
!               &  ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf),  &
!               &  ifm%dHdz_path(k,maf),earthRefl%values(1,1),             &
!               &  beta_path(:,frq_i),spsfunc_path(:,k),ref_corr(:,k),     &
!               &  spaceRadiance%values(1,1),brkpt,no_ele,mid,ilo,ihi,     &
!               &  t_script,tau,midval_ndx,no_midval_ndx,gl_ndx,no_gl_ndx, &
!               &  midval_delta,Rad,Ier)
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
!               & 'rad_tran failed' )

!             RadV(frq_i) = Rad

!             ! Now, Compute the radiance derivatives:

!             !??? Do we need to do this if there's no Jacobian or no derivatives requested ???

!             call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn,    &
!               &  ifm%elvar(maf),frq_i,Frq,noSpecies,ifm%z_path(k,maf),     &
!               &  ifm%h_path(k,maf),ifm%t_path(k,maf),ifm%phi_path(k,maf),  &
!               &  ifm%dHdz_path(k,maf),beta_path(:,frq_i),spsfunc_path(:,k),&
!               &  temp%template%surfs(:,1),temp%template%noSurfs,           &
!               &  ref_corr(:,k),temp%template%noInstances,                  &
!               &  temp%template%phi(1,:)*Deg2Rad,dh_dt_path,k_temp_frq,     &
!               &  k_atmos_frq,brkpt,no_ele,mid,ilo,ihi,t_script,tau,        &
!               &  max_zeta_dim,max_phi_dim,midval_ndx,no_midval_ndx,        &
!               &  gl_ndx,no_gl_ndx,midval_delta,Sps_zeta_loop(:,k),         &
!               &  Sps_phi_loop(:,k),Ier)
!             if( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,     &
!               & 'rad_tran_wd failed' )

!             if ( toggle(emit) .and. levels(emit) > 2 ) &
!               & call trace_end ( 'ForwardModel.Frequencies' )

!           end do                          ! Frequency loop

!           ! ----------------------------- End loop over frequencies ----

!           ! Here we either frequency average to get the unconvolved radiances, or
!           ! we just store what we have as we're using delta funciton channels

!           if ( toggle(emit) .and. levels(emit) > 1 ) &
!             & call trace_begin ( 'ForwardModel.FrequencyAvg' )
!           if ( fwdModelConf%do_freq_avg ) then
!             do i = 1, noUsedChannels
!               sigInd = usedSignals(i)
!               ch = usedChannels(i)
!               if ( toggle(emit) .and. levels(emit) > 2 ) then
!                 call output ( 'Channel = ' )
!                 call output ( i )
!                 call output ( ' ( ' )
!                 call output ( sigInd )
!                 call output ( ':' )
!                 call output ( ch )
!                 call output ( ' )', advance='yes' )
!               end if
!               centerFreq = firstSignal%lo + &
!                 & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
!               shapeInd = MatchSignal ( filterShapes%signal, &
!                 & fwdModelConf%signals(sigInd), sideband = thisSideband )
!               if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!                 & "No matching channel shape information" )
!               if ( toggle(emit) .and. levels(emit) > 2 ) then
!                 call output ( 'Using filter shape:' )
!                 call output ( shapeInd, advance='yes' )
!               endif

!               call Freq_Avg ( frequencies, &
!                 & centerFreq+thisSideband * &
!                 & FilterShapes(shapeInd)%FilterGrid(ch,:), &
!                 & FilterShapes(shapeInd)%FilterShape(ch,:), RadV, noFreqs,  &
!                 & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
!             end do
!           else
!             Radiances(ptg_i,:) = RadV(1:noFreqs)
!           end if

!           ! Frequency Average the temperature derivatives with the appropriate
!           ! filter shapes
!           !??? Do we need to do this if there's no Jacobian ???
!           if ( fwdModelConf%temp_der ) then
!             if ( fwdModelConf%do_freq_avg ) then
!               do i = 1, noUsedChannels
!                 sigInd = usedSignals(i)
!                 ch = usedChannels(i)
!                 centerFreq = firstSignal%lo + &
!                   & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
!                 shapeInd = MatchSignal ( filterShapes%signal, &
!                   & fwdModelConf%signals(sigInd), &
!                   & sideband = thisSideband, channel=ch )
!                 do instance = lbound(k_temp_frq%values,3), &
!                   & ubound(k_temp_frq%values,3)
!                   do surface = 1, temp%template%noSurfs
!                     ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
!                     call Freq_Avg ( frequencies,                        &
!                       & centerFreq+thisSideband* &
!                       & FilterShapes(shapeInd)%FilterGrid(ch,:), &
!                       & FilterShapes(shapeInd)%FilterShape(ch,:),&
!                       & real(ToAvg,r8), noFreqs, &
!                       & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
!                     k_temp(i,ptg_i,surface,instance) = r
!                   end do                  ! Surface loop
!                 end do                    ! Instance loop
!               end do                      ! Channel loop
!             else
!               do i = 1, noUsedChannels
!                 k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
!                   &  k_temp_frq%values(i,1:temp%template%noSurfs,:)
!               end do
!             end if
!           end if

!           ! Frequency Average the atmospheric derivatives with the appropriate
!           ! filter shapes
!           !??? Do we need to do this if there's no Jacobian ???
!           do specie = 1, noSpecies
!             if ( fwdModelConf%moleculeDerivatives(specie) ) then
!               f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!                 &  quantityType=l_vmr, molecule=fwdModelConf%molecules(specie))
!               if ( fwdModelConf%do_freq_avg ) then
!                 do i = 1, noUsedChannels
!                   sigInd = usedSignals(i)
!                   ch = usedChannels(i)
!                   centerFreq = firstSignal%lo + &
!                     & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
!                   shapeInd = MatchSignal ( filterShapes%signal, &
!                     & fwdModelConf%signals(sigInd), &
!                     & sideband = thisSideband, channel=ch )
!                   do instance = lbound(k_atmos_frq(specie)%values,3),&
!                     & ubound(k_atmos_frq(specie)%values,3)
!                     do surface = 1, f%template%noSurfs
!                       ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
!                       call Freq_Avg ( frequencies,                      &
!                         & centerFreq+thisSideband * &
!                         & FilterShapes(shapeInd)%FilterGrid(ch,:), &
!                         & FilterShapes(shapeInd)%FilterShape(ch,:), &
!                         & real(ToAvg,r8),  &
!                         & noFreqs, size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
!                       k_atmos(i,ptg_i,surface,instance,specie) = r
!                     end do                ! Surface loop
!                   end do                  ! Instance loop
!                 end do                    ! Channel loop
!               else                        ! Else not frequency averaging
!                 surface = f%template%noSurfs
!                 do i = 1, noUsedChannels
!                   k_atmos(i,ptg_i,1:surface,:,specie) = &
!                     &  k_atmos_frq(specie)%values(i,1:surface,:)
!                 end do
!               end if                      ! Frequency averaging or not
!             end if                        ! Want derivatives for this
!           end do                          ! Loop over species

!           if ( toggle(emit) .and. levels(emit) > 1 ) &
!             & call trace_end ( 'ForwardModel.FrequencyAvg' )

!           call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )

!           if ( toggle(emit) .and. levels(emit) > 1 ) &
!             & call trace_end ( 'ForwardModel.Pointing' )

!         end do                            ! Pointing Loop
!         ! ---------------------------------- End of Pointing Loop ---------------
! !
! ! ========= Pointings dependance deallocation section:
! ! (De-Allocate some of the arrays connected with pointing)
! !
!         deallocate(midval_ndx,gl_ndx,stat=status)
!         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
!           & MLSMSG_DeAllocate // 'midval_ndx/gl_ndx' )

!         do j = 1, size(gl_slabs,1)
!           do i = 1, size(gl_slabs,2)
!             deallocate(gl_slabs(j,i)%v0s, gl_slabs(j,i)%v0sm,     &
!             &    gl_slabs(j,i)%v0sp, gl_slabs(j,i)%x1,            &
!             &    gl_slabs(j,i)%y, gl_slabs(j,i)%yi,               &
!             &    gl_slabs(j,i)%slabs1, gl_slabs(j,i)%dx1_dv0,     &
!             &    gl_slabs(j,i)%dy_dv0, gl_slabs(j,i)%dslabs1_dv0, &
!             &    gl_slabs(j,i)%v0sm, gl_slabs(j,i)%x1m,           &
!             &    gl_slabs(j,i)%ym, gl_slabs(j,i)%yim,             &
!             &    gl_slabs(j,i)%slabs1m, gl_slabs(j,i)%v0sp,       &
!             &    gl_slabs(j,i)%x1p, gl_slabs(j,i)%yp,             &
!             &    gl_slabs(j,i)%yip, gl_slabs(j,i)%slabs1p, STAT=k)
!           end do
!         end do

!         deallocate ( gl_slabs, STAT=k )

!         if ( associated(beta_path) ) then
!           do i = 1, size(beta_path,1)
!             do j = 1, size(beta_path,2)
!               deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
!                 & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
!                 & beta_path(i,j)%dbeta_dnu, STAT=k )
!             end do
!           end do
!         end if

!         deallocate ( beta_path, STAT=k )
! !
! ! ========= End of pointing dependence De-Allocate section
! !
!         !  Here comes the Convolution code
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_begin ( 'ForwardModel.Convolution' )
!         call allocate_test ( superset, size(antennaPatterns), &
!           & 'superset', ModuleName )
!         do i = 1, noUsedChannels

!           ch = usedChannels(i)
!           sigInd = usedSignals(i)
!           thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
!             & signal=fwdModelConf%signals(sigInd)%index, &
!             & sideband=firstSignal%sideband )

!           if ( sidebandStart /= sidebandStop ) then ! We're folding
!             thisRatio = sidebandRatio%values(ch,1)
!             if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
!           else ! Otherwise, want just unfolded signal
!             thisRatio = 1.0
!           end if

!           if ( FwdModelConf%do_conv ) then

!             do j = 1, size(antennaPatterns)
!               superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
!                 & fwdModelConf%signals, sideband=thisSideband, channel=ch )
!             end do
!             if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & "No matching antenna patterns." )

!             maxSuperset = maxval ( superset )
!             where ( superset < 0 )
!               superset = maxSuperset + 1
!             end where
!             whichPatternAsArray = minloc ( superset )
!             whichPattern = whichPatternAsArray(1)
!             if ( toggle(emit) .and. levels(emit) > 2 ) then
!               call output ( 'Using antenna pattern: ' )
!               call output ( whichPattern, advance='yes' )
!             end if

!             call convolve_all ( fwdModelConf, fwdModelIn, maf, ch, &
!               &     windowStart, windowFinish, mafTInstance-windowStart+1, &
!               &     temp, ptan, thisRadiance, &
!               &     FwdModelConf%tangentGrid%surfs, ptg_angles, &
!               &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt, si, center_angle, &
!               &     Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
!               &     thisRatio, Jacobian, fmStat%rows,  &
!               &     antennaPatterns(whichPattern), ier )
!             !??? Need to choose some index other than 1 for AntennaPatterns ???
!             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!               & 'convolve_all failed' )
!           else
!             call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, ch,  &
!               &     windowStart, windowFinish, temp, ptan, thisRadiance, &
!               &     FwdModelConf%tangentGrid%surfs, &
!               &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
!               &     thisRatio, Jacobian, fmStat%rows )

!           end if

!         end do                            ! Channel loop

!         call deallocate_test ( superset, 'superset', ModuleName )
!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_end ( 'ForwardModel.Convolution' )

!         if ( toggle(emit) .and. levels(emit) > 0 ) &
!           & call trace_end ( 'ForwardModel.sideband' )
!       end do
!       ! ---------------------------- End of loop over sideband ------------------

!       ! ------------------------------ End of Major Frame Specific stuff --------


!       ! Deallocate stuff allocated earlier
!       call Deallocate_test ( sps_values, 'sps_values', ModuleName )
!       call Deallocate_test ( no_z, 'no_z', ModuleName )
!       call Deallocate_test ( no_phi, 'no_phi', ModuleName )
!       call Deallocate_test ( lin_log, 'lin_log', ModuleName )
!       call Deallocate_test ( z_basis, 'z_basis', ModuleName )
!       call Deallocate_test ( phi_basis, 'phi_basis', ModuleName )

!       if ( FwdModelConf%temp_der ) call deallocate_test &
!         & ( k_temp_frq%values, "k_temp_frq%values", ModuleName )
!       if ( FwdModelConf%atmos_der ) then
!         do j = 1, noSpecies
!           call deallocate_test(k_atmos_frq(j)%values,"k_atmos_frq(j)%values",&
!             & ModuleName )
!         end do
!       end if

!       if ( index(switches,'rad') /= 0 ) then
!         ! *** DEBUG Print
!         if ( FwdModelConf%do_conv ) then
!           print *,'Convolution: ON'
!         else
!           print *,'Convolution: OFF'
!         end if

!         if ( FwdModelConf%do_freq_avg ) then
!           print *,'Frequency Averaging: ON'
!         else
!           Frq = Frequencies(1)
!           print *,'Frequency Averaging: OFF'
!           print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
!         end if

!         print *
!         k=ptan%template%noSurfs
!         print 901, k
! 901     format ( 'ptan\ ',i3.3)
!         print 902,Ptan%values(1:k,maf)
! 902     format ( 4(4x, f10.7))

!         print *
!         do i = 1, noUsedChannels
!           ch = usedChannels(i)
!           print 903, ch, char(92), ptan%template%noSurfs
! 903       format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
!           print 905, ( firstRadiance%values(ch+(k-1)*firstRadiance%template%noChans,maf),&
!             & k = 1, ptan%template%noSurfs )
! 905       format ( 4(2x, 1pg15.8) )
!         end do
!       end if

!       do j = 1, No_tan_hts
!         deallocate ( n_path(j)%values, stat=status )
!         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & MLSMSG_Deallocate//'n_path%values' )
!         do i = 1, noSpecies
!           deallocate ( spsfunc_path(i,j)%values, stat=status )
!           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & MLSMSG_Deallocate//'spsfunc_path%values' )
!           deallocate ( sps_phi_loop(i,j)%values, stat=status )
!           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & MLSMSG_Deallocate//'sps_phi_loop%values' )
!           deallocate ( sps_zeta_loop(i,j)%values, stat=status )
!           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!             & MLSMSG_Deallocate//'sps_zeta_loop%values' )
!         end do
!       end do

!       deallocate ( n_path, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Deallocate//'n_path' )

!       deallocate ( spsfunc_path, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Deallocate//'spsfunc_path' )

!       deallocate ( sps_phi_loop, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Deallocate//'sps_phi_loop' )
!       deallocate ( sps_zeta_loop, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Deallocate//'sps_zeta_loop' )

!       call deallocate_test ( dx_dt, 'dx_dt', ModuleName )
!       call deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

!       call deallocate_test ( t_script, 't_srcipt', ModuleName )
!       call deallocate_test ( ref_corr, 'ref_corr', ModuleName )
!       call deallocate_test ( tau, 'tau', ModuleName )
!       call deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
!       call deallocate_test ( midval_delta, 'midval_delta', ModuleName )

!       deallocate ( k_atmos_frq, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Deallocate//'k_atmos_frq' )
!       deallocate ( k_temp, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Allocate//'k_temp' )
!       deallocate ( k_atmos, stat=status )
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
!         & MLSMSG_Allocate//'k_atmos' )
!       deallocate ( My_Catalog, stat=status)
!       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!         & MLSMSG_Allocate//'My_catalog' )

!       call deallocate_test ( radiances, 'Radiances', ModuleName )
!       call deallocate_test ( i_star_all, 'i_star_all', ModuleName )
!       call deallocate_test ( radv, 'rad_v', ModuleName )
!       call deallocate_test ( grids, 'grids',  ModuleName )

!     else
!       if ( toggle(emit) .and. levels(emit) > 0 ) &
!         & call output ( 'This MAF skipped as in overlap region', advance='yes' )
!     endif ! --------------------------- Possible skip of this major frame

!     if ( maf == noMAFs ) fmStat%finished = .true.

!     deallocate(tan_inds,STAT=i)

!     call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
!     call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )

!     if ( .not. fwdModelConf%do_freq_avg ) call deallocate_test ( &
!       & frequencies, "frequencies", ModuleName )

!     if ( toggle(emit) ) call trace_end ( 'ForwardModel' )

  end subroutine FullForwardModel

 end module FullForwardModel_m
 
a1446 3
! Revision 1.5.2.4  2001/09/07 20:16:37  livesey
! Changed stuff to lower case
!
@


1.5.2.6
log
@change comments..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.5 2001/09/07 22:18:04 livesey Exp $"
d248 2
a251 2
    ! Compute hydrostatic grid -----------------------------------------------

d261 1
a261 1
        ! frequency averaging case for this pointing
a1562 3
! Revision 1.5.2.5  2001/09/07 22:18:04  livesey
! More comments
!
@


1.5.2.7
log
@Very intermediate
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.6 2001/09/07 22:34:21 zvi Exp $"
d87 1
a87 1
    !     character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
d89 1
a89 1
    !     ! Local variables ----------------------------------------------------------
d91 129
a219 126
    !     ! First the old stuff which we hope to get rid of or redefine
    !     integer(i4) :: brkpt, ch, frq_i, i, ier, ihi, ilo, j, k, lmax, m, maf, &
    !       max_phi_dim, max_zeta_dim, mid, n, no_ele, no_tan_hts, &
    !       ptg_i, si, Spectag

    !     type(path_derivative) :: K_temp_frq
    !     type(path_derivative), allocatable, dimension(:) :: K_atmos_frq

    !     type(path_beta), dimension(:,:), pointer :: Beta_path

    !     real(r8) :: Frq, Geod_lat, H_tan, Phi_tan, Rad

    !     ! This is the `legit stuff' we hope will stay; they are all pointers to
    !     ! VectorValue_T's containing vector quantities.
    !     type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
    !     type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset quantity
    !     type (VectorValue_T), pointer :: F             ! An arbitrary species
    !     type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    !     type (VectorValue_T), pointer :: ORBINCLINE    ! Orbital inclination (beta)
    !     type (VectorValue_T), pointer :: PTAN          ! PTAN quantity
    !     type (VectorValue_T), pointer :: FIRSTRADIANCE ! One radiance quantity to be filled
    !     type (VectorValue_T), pointer :: THISRADIANCE ! One radiance quantity to be filled
    !     type (VectorValue_T), pointer :: REFGPH        ! Reference GPH, (zRef and hRef)
    !     type (VectorValue_T), pointer :: SCGEOCALT     ! Geocentric spacecraft altitude
    !     type (VectorValue_T), pointer :: SIDEBANDRATIO ! Sideband ratio for radiance
    !     type (VectorValue_T), pointer :: SPACERADIANCE ! Space radiance
    !     type (VectorValue_T), pointer :: TEMP          ! Temperature quantity

    !     integer :: CHANNEL                  ! Loop counter
    !     integer :: INSTANCE                 ! Loop counter
    !     integer :: MAFTINSTANCE             ! Temperature instance closest to this MAF
    !     integer :: MAXNOFREQS               ! Used for sizing arrays
    !     integer :: MAXNOFSURFS              ! Max. no. surfaces for any molecule
    !     integer :: MAXSUPERSET              ! Max. value of superset
    !     integer :: MAXVERT                  ! Number of points in gl grid
    !     integer :: N2LVL                    ! Twice size of tangent grid
    !     integer :: NLVL                     ! Size of tangent grid
    !     integer :: NOFREQS                  ! Number of frequencies for a pointing
    !     integer :: NOMAFS                   ! Number of major frames
    !     integer :: NOMIFS                   ! Number of minor frames
    !     integer :: NOSPECIES                ! Number of molecules we're considering
    !     integer :: NOUSEDCHANNELS           ! Number of channels to output
    !     integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
    !     integer :: PHIWINDOW                ! Copy of forward model config%phiWindow
    !     integer :: SHAPEIND                 ! Index into filter shapes
    !     integer :: SIGIND                   ! Loop counter
    !     integer :: SPECIE                   ! Loop counter
    !     integer :: STATUS                   ! From allocates etc.
    !     integer :: SURFACE                  ! Loop counter
    !     integer :: THISSIDEBAND             ! Loop counter
    !     integer :: TOTALSIGNALS             ! Used when hunting for pointing grids
    !     integer :: WHICHPATTERN             ! Index of antenna pattern
    !     integer :: WHICHPOINTINGGRID        ! Index of pointing grid
    !     integer :: WINDOWFINISH             ! Range of window
    !     integer :: WINDOWSTART              ! Range of window

    !     real (r8) :: CENTERFREQ             ! Of band
    !     real (r8) :: CENTER_ANGLE           ! For angles
    !     real (r8) :: R                      ! To convert the kind of output from
    !     !                                     Freq_Avg
    !     real (r8) :: THISRATIO              ! A sideband ratio

    !     integer, dimension(:), pointer :: CHANNELINDEX ! E.g. 1..25
    !     integer, dimension(:), pointer :: GRIDS ! Frq grid for each tan_press
    !     integer, dimension(:), pointer :: SUPERSET ! Result of AreSignalsSuperset
    !     integer, dimension(:), pointer :: USEDCHANNELS ! Array of indices used
    !     integer, dimension(:), pointer :: USEDSIGNALS ! Array of indices used

    !     logical :: FOUNDINFIRST                     ! Flag to indicate derivatives

    !     real(r8), dimension(:,:),   pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
    !     real(r8), dimension(:,:,:), pointer :: DH_DT_PATH  ! (pathSize, Tsurfs, Tinstance)
    !     real(r8), dimension(:), allocatable :: Dum
    !     real(r8), dimension(:,:),   pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
    !     real(r8), dimension(:),     pointer :: FREQUENCIES ! Frequency points
    !     real(r8), dimension(:,:),   pointer :: I_STAR_ALL    ! (noMIFs,noChans)
    !     real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS ! (channel,Nptg,mxco,mnp,Nsps)
    !     real(r4), dimension(:,:,:,:), pointer :: K_TEMP    ! (channel,Nptg,mxco,mnp)
    !     real(r8), dimension(:),     pointer :: PTG_ANGLES  ! (no_tan_hts)
    !     real(r8), dimension(:,:),   pointer :: RADIANCES     ! (Nptg,noChans)
    !     real(r8), dimension(:),     pointer :: RadV
    !     real(r8), dimension(:,:),   pointer :: REF_CORR    ! (n2lvl, no_tan_hts)
    !     real(kind(k_temp_frq%values)), &
    !       & dimension(:), pointer :: TOAVG ! Stuff to be passed to frq.avg.
    !     real(r8), dimension(:),     pointer :: T_SCRIPT    ! (n2lvl)
    !     real(r8), dimension(:),     pointer :: TAU         ! (n2lvl)

    !     integer, dimension(1) :: WHICHPOINTINGGRIDASARRAY ! Result of minloc
    !     integer, dimension(1) :: WHICHPATTERNASARRAY      ! Result of minloc

    !     type(path_vector), dimension(:), allocatable :: N_PATH    ! (No_tan_hts)

    !     ! dimensions of SPSFUNC_PATH are: (Nsps,No_tan_hts)
    !     type(path_vector), allocatable, dimension(:,:) :: SPSFUNC_PATH

    !     ! dimensions of SPS_PHI_LOOP  are: (Nsps,No_tan_hts)
    !     ! dimensions of SPS_ZETA_LOOP are: (Nsps,No_tan_hts)
    !     type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_PHI_LOOP
    !     type(path_int_vector_2d), allocatable, dimension(:,:) :: SPS_ZETA_LOOP

    !     integer :: no_midval_ndx, no_gl_ndx, max_nl, max_num_frq
    !     integer, dimension(:,:), allocatable :: gl_ndx, midval_ndx
    !     real(r8), dimension(:,:), pointer :: midval_delta   ! (N2lvl,Nsps)

    !     type (slabs_struct), dimension(:,:), pointer :: gl_slabs

    !     type(signal_t) :: FirstSignal
    !     type(signal_t) :: ThisSignal
    !     type(catalog_T), dimension(:), pointer :: My_Catalog
    ! !
    ! !-------- Variables needed by Bill's & Zvi's New code  -------------------
    ! !
    !     type Spect_Der_T
    !       character(LEN=1) :: type
    !       integer :: Spectag
    !       integer :: no_phi_values
    !       integer :: no_zeta_values
    !       real(r8), dimension(:,:), pointer :: phi_basis => NULL()
    !       real(r8), dimension(:,:), pointer :: zeta_basis => NULL()
    !     end type Spect_Der_T

    !     type(Spect_Der_T), allocatable :: spect_der(:)
    ! !
    !     character(LEN=8) :: WNV
    !     real(r8), pointer :: p_glgrid(:)
    !     real(r8), allocatable ::  xm(:),ym(:),zgx(:)
d221 2
a222 2
    !     integer(ip) ::  NLm1, Ngp1, no_ss
    !     integer(ip), allocatable :: tan_inds(:),gl_indgen(:,:),gl_inds(:)
d224 1
a224 18
    !-------- End of Variables needed by Bill's & Zvi's New code

    integer, parameter :: NGP1=NG+1                     ! NG + 1

    integer :: BRKPT                    ! Index of midpoint of path
    integer :: PTG_I                    ! Loop counter for the pointings
    integer :: SIDEBANDSTART            ! Loop limit
    integer :: SIDEBANDSTEP             ! Loop step
    integer :: SIDEBANDSTOP             ! Loop limit
    integer :: THISSIDEBAND             ! Loop counter for sidebands
    integer :: NLVL                     ! Size of tangent grid
    integer :: N2LVL                    ! 2*nLvl
    integer :: MAXVERT                  ! Number of points in gl grid
    integer :: NO_ELE                   ! Length of a gl path
    integer :: NPC                      ! Length of coarse path



d249 1
a249 4
    nlvl = size(FwdModelConf%integrationGrid%surfs)
    n2lvl = 2 * nlvl
    maxVert = (Nlvl-1) * Ng + Nlvl
    
a254 1
    do thisSideband = sidebandStart, sidebandStop, sidebandStep
a256 170
      do ptg_i = 1, no_tan_hts

        ! allocate the path stuff
        brkpt = MaxVert + 1 - tan_inds(ptg_i) ! path tangent index
        no_ele = 2 * brkpt
        npc = 2 * (brkpt + Ng) / Ngp1

        ! This is not pretty but we need some coarse grid extraction indicies
        k = Ngp1
        j = (npc+1)/2
        ext_ind_c(:) = 0
        ext_ind_c(1:npc) = (/(i*k-Ng,i=1,j),((i-1)*k-Ng+1,i=j+1,npc)/)

        ! Compute z_path & p_path
        z_path(1:no_ele) = (/(z_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
          (z_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)
        p_path(1:no_ele) = (/(p_glgrid(i),i=MaxVert,tan_inds(ptg_i),-1), &
          (p_glgrid(i),i=tan_inds(ptg_i),MaxVert)/)

        ! Compute the h_path,t_path,dhdz_path,phi_path,dhdt_path

        if (ptg_i <= no_ss) then
          neg_tan_ht = T_FMI%t_coeff(1,l)*(FMI%tan_press(ptg_i) &
            - z_glgrid(1)) / 14.8_rp
          e_rflty = T_FMI%earth_ref

          if(FMC%temp_der) then
            ! Set up temperature representation basis stuff
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  T_FMI%t_geod_lat(l1:l2)*Deg2Rad,z_glgrid,h_glgrid(:,l1:l2), &
              &  t_glgrid(:,l1:l2),dhdz_glgrid(:,l1:l2),                     &
              &  T_FMI%beta_inc*Deg2Rad,h_path(1:no_ele),phi_path(1:no_ele), &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),                       &
              &  Req,TAN_PHI_T_GRID=one_tan_temp,                            &
              &  NEG_H_TAN = (/neg_tan_ht/),DHTDTL0=tan_dh_dt,               &
              &  DHIDTLM=dh_dt_glgrid, DHITDTLM=dh_dt_path(1:no_ele,:),      &
              &  Z_BASIS = T_FMI%t_zeta_basis,ETA_ZXP=eta_zxp_t(1:no_ele,:), &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:))
          else
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  T_FMI%t_geod_lat(l1:l2)*Deg2Rad,z_glgrid,h_glgrid(:,l1:l2), &
              &  t_glgrid(:,l1:l2),dhdz_glgrid(:,l1:l2),                     &
              &  T_FMI%beta_inc*Deg2Rad, h_path(1:no_ele),phi_path(1:no_ele),&
              &  t_path(1:no_ele),dhdz_path(1:no_ele),                       &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,  &
              &  NEG_H_TAN = (/neg_tan_ht/))
          endif
          ! Tan heights for a negative tan height from metrics is not correctly working.
        else
          e_rflty = 1.0_rp
          if(FMC%temp_der) then
            ! Set up temperature representation basis stuff
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  T_FMI%t_geod_lat(l1:l2)*Deg2Rad,z_glgrid,h_glgrid(:,l1:l2), &
              &  t_glgrid(:,l1:l2),dhdz_glgrid(:,l1:l2),                     &
              &  T_FMI%beta_inc*Deg2Rad,h_path(1:no_ele),phi_path(1:no_ele), &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),                       &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp,  &
              &  DHTDTL0=tan_dh_dt,DHIDTLM=dh_dt_glgrid,                     &
              &  DHITDTLM=dh_dt_path(1:no_ele,:),                            &
              &  Z_BASIS = T_FMI%t_zeta_basis,ETA_ZXP=eta_zxp_t(1:no_ele,:), &
              &  DO_CALC_T = do_calc_t(1:no_ele,:),                          &
              &  DO_CALC_HYD = do_calc_hyd(1:no_ele,:))
          else
            call metrics((/phi_tan/),(/tan_inds(ptg_i)/),                    &
              &  T_FMI%t_geod_lat(l1:l2)*Deg2Rad,z_glgrid,h_glgrid(:,l1:l2), &
              &  t_glgrid(:,l1:l2),dhdz_glgrid(:,l1:l2),                     &
              &  T_FMI%beta_inc*Deg2Rad,h_path(1:no_ele),phi_path(1:no_ele), &
              &  t_path(1:no_ele),dhdz_path(1:no_ele),                       &
              &  Req,TAN_PHI_H_GRID=one_tan_ht,TAN_PHI_T_GRID=one_tan_temp)
          endif
        endif

        !  ** Determine the eta_zxp_dw, eta_zxp_dn, eta_zxp_dv
        if(FMC%spect_der) then
          call eval_spect_path(z_basis_dw,phi_basis_dw+phi_tan, &
            &  no_z_dw,no_phi_dw,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dw(1:no_ele,:),eta_zxp_dw(1:no_ele,:))
          call eval_spect_path(z_basis_dn,phi_basis_dn+phi_tan, &
            &  no_z_dn,no_phi_dn,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dn(1:no_ele,:),eta_zxp_dn(1:no_ele,:))
          call eval_spect_path(z_basis_dv,phi_basis_dv+phi_tan, &
            &  no_z_dv,no_phi_dv,z_path(1:no_ele),phi_path(1:no_ele), &
            &  do_calc_dv(1:no_ele,:),eta_zxp_dv(1:no_ele,:))
        endif
        tan_temp(ptg_i,l) = one_tan_temp(1)

        ! Now compute the sps_path
        call comp_sps_path(z_basis,phi_basis,sps_values,no_z,no_phi, &
          &   lin_log,z_path(1:no_ele),phi_path(1:no_ele),   &
          &   sps_path(1:no_ele,:),do_calc(1:no_ele,:),      &
          &   eta_zxp(1:no_ele,:))

        if (h2o_ind > 0) then
          call refractive_index(p_path(ext_ind_c(1:npc)), &
            &  t_path(ext_ind_c(1:npc)),n_path(1:npc),    &
            &  h2o_path=sps_path((ext_ind_c(1:npc)),h2o_ind))
        else
          call refractive_index(p_path(ext_ind_c(1:npc)), &
            &   t_path(ext_ind_c(1:npc)),n_path(1:npc))
        endif

        call get_chi_angles(T_FMI%h_obs,n_path(npc/2),one_tan_ht(1), &
          &  phi_tan,Req,elev_offset,ptg_angles(ptg_i,l))

        call comp_refcor(Req+h_path(ext_ind_c(1:npc)), &
          &   1.0_rp+n_path(1:npc),Req+one_tan_ht(1), &
          &   del_s(1:npc),ref_corr(1:npc))

        ! this only needs to be computed on the gl (not coarse) grid thus there is
        ! some duplication here.
        path_dsdh(2:brkpt-1) = path_ds_dh(Req+h_path(2:brkpt-1), &
          &  Req+one_tan_ht(1))
        path_dsdh(brkpt+2:no_ele-1) = path_ds_dh(Req+h_path(brkpt+2:no_ele-1), &
          &         Req+one_tan_ht(1))
        k = ptg_i

        ! Compute ALL the slabs_prep entities over the path's GL grid for this
        ! pointing & mmaf:

        del_temp = 0.0_rp
        call get_gl_slabs_arrays(FMI%pfa_spectrum,p_path(1:no_ele), &
          &   t_path(1:no_ele),FMC%vel_z_mmaf(l),gl_slabs,no_ele,del_temp)

        if(FMC%temp_der) then
          del_temp = 10.0_rp
          call get_gl_slabs_arrays(FMI%pfa_spectrum,p_path(1:no_ele), &
            & t_path(1:no_ele),FMC%vel_z_mmaf(l),gl_slabs_p,no_ele,del_temp)
          call get_gl_slabs_arrays(FMI%pfa_spectrum,p_path(1:no_ele), &
            & t_path(1:no_ele),FMC%vel_z_mmaf(l),gl_slabs_m,no_ele,-del_temp)
        endif

        ! Do a frequencies loop:
        ! allocate frequency dependent stuff here
        no_frq_on_ptg_i = 1
        if(FMC%do_frqavg) no_frq_on_ptg_i = FMI%no_ptg_frq(ptg_i)

        allocate(RadV(1:no_frq_on_ptg_i),F_grid(1:no_frq_on_ptg_i),STAT=ier)
        if(ier /= 0) then
          print *,'** ALLOCATE Error **'
          print *,'** RadV or F_grid arrays, STAT =',ier
          goto 99
        endif

        if(FMC%temp_der) then
          allocate(k_temp_frq(1:no_frq_on_ptg_i,1:sv_t_len),STAT=ier)
          if(ier /= 0) then
            print *,'** ALLOCATE Error: k_temp_frq array, STAT =',ier
            goto 99
          endif
        endif

        if(FMC%atmos_der) then
          allocate(k_atmos_frq(1:no_frq_on_ptg_i,1:sv_len),STAT=ier)
          if(ier /= 0) then
            print *,'** ALLOCATE Error: k_atmos_frq, STAT =',ier
            goto 99
          endif
        endif

        if(FMC%spect_der) then
          allocate(k_spect_dw_frq(1:no_frq_on_ptg_i,1:sv_dw_len))
          allocate(k_spect_dn_frq(1:no_frq_on_ptg_i,1:sv_dn_len))
          allocate(k_spect_dv_frq(1:no_frq_on_ptg_i,1:sv_dv_len))
        endif

        F_grid(1:no_frq_on_ptg_i) = &
          FMI%ptg_frq_grid(ptg_i)%values(1:no_frq_on_ptg_i)

d264 2
d267 1
a267 3
        ! Compute radiative transfer ---------------------------------------

        ! Compute derivatives if needed ------------------------------------
d275 1
a275 2
        ! End of pointing loop -------------------------------------------------
      end do
d283 1
a283 2
      ! End of loop over sidebands ---------------------------------------------
    end do
d336 1
a336 1
    !     if ( toggle(emit) ) call trace_begin ( 'ForwardModel' )
d338 1211
a1548 1211
    !     ! Nullify a bunch of pointers so that Allocate_Test doesn't try to
    !     ! deallocate them.  We don't want them to be initialized NULL()
    !     ! because that makes them SAVEd.

    !     nullify (beta_path, channelIndex, d2x_dxdt, dh_dt_path, dx_dt, &
    !       & frequencies, grids, i_star_all, k_atmos, k_temp, my_Catalog, &
    !       & ptg_angles, radiances, radV, ref_corr, superset, t_script, &
    !       & tau, usedChannels, usedSignals, midval_delta )

    !     ! Identify the vector quantities we're going to need.
    !     ! The key is to identify the signal we'll be working with first
    !     firstSignal = fwdModelConf%signals(1)

    !     ! Now make sure all the signals we're dealing with are same module,
    !     ! radiometer and sideband.
    !     if ( any( fwdModelConf%signals%sideband .ne. &
    !       & firstSignal%sideband ) ) &
    !       & call MLSMessage ( MLSMSG_Error, ModuleName, &
    !       &  "Can't have mixed sidebands in forward model config")
    !     if ( any( fwdModelConf%signals%radiometer .ne. &
    !       & firstSignal%radiometer ) ) &
    !       & call MLSMessage ( MLSMSG_Error, ModuleName, &
    !       &  "Can't have mixed radiometers in forward model config")

    !     ! Now from that we identify the radiance quantity we'll be outputting
    !     firstRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
    !       & signal=firstSignal%index, sideband=firstSignal%sideband )

    !     ! Identify the appropriate state vector components, save vmrs for later
    !     temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_temperature )
    !     ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule )
    !     elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_elevOffset, radiometer=firstSignal%radiometer )
    !     orbIncline => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_orbitInclination )
    !     spaceRadiance => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_spaceRadiance )
    !     earthRefl => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_earthRefl )
    !     refGPH => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_refGPH )
    !     losVel => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule )
    !     scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_scGeocAlt )
    !     sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !       & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.true. )

    !     ! We won't seek for molecules here as we can't have an array of pointers.
    !     ! When we do want molecule i we would do something like
    !     ! vmr => GetVectorQuantityBytype (fwdModelIn, fwdModelExtra, &
    !     !   quantityType=l_vmr, molecule=fwdModelConf.molecules(i))

    !     ! Now we're going to validate the quantities we've been given, don't forget
    !     ! we already know what their quantityType's are as that's how we found them
    !     !, so we don't need to check that.
    !     if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
    !       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
    !       & ModuleName, InvalidQuantity//'temperature' )
    !     if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
    !       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
    !       & ModuleName, InvalidQuantity//'ptan' )
    !     if ( .not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
    !       & frequencyCoordinate=(/l_none/), noInstances=(/1/)) ) &
    !       & call MLSMessage ( MLSMSG_Error, ModuleName, &
    !       & InvalidQuantity//'elevOffset' )
    !     ! There will be more to come here.

    !     noSpecies = size(fwdModelConf%molecules)

    !     !  Create a subset of the catalog composed only of those molecules to be
    !     !  used for this run

    !     maxNoFSurfs = 0
    !     do specie = 1, noSpecies
    !       f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !         & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
    !       maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
    !     end do

    !     allocate ( My_Catalog(noSpecies), stat=ier )
    !     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !       & MLSMSG_Allocate//'my_catalog' )

    !     max_nl = 1
    !     do j = 1, noSpecies
    !       Spectag = spec_tags(fwdModelConf%molecules(j))
    !       do i = 1, size(Catalog)
    !         if ( Catalog(i)%Spec_Tag == Spectag ) then
    !           My_Catalog(j) = Catalog(i)
    !           m = size(Catalog(i)%Lines)
    !           if(m > max_nl) max_nl = m
    !           exit
    !         end if
    !       end do
    !     end do

    !     ! Get the max. dimension in zeta coeff. space and phi coeff. space
    !     ! (To be used later in rad_tran_wd, for automatic arrays asignement)
    !     max_phi_dim = 1
    !     max_zeta_dim = 1
    !     if ( FwdModelConf%temp_der ) then
    !       max_zeta_dim = temp%template%noSurfs
    !       max_phi_dim = temp%template%noInstances
    !     end if

    !     if ( fwdModelConf%atmos_der ) then
    !       do k = 1, noSpecies
    !         if ( fwdModelConf%moleculeDerivatives(k) ) then
    !           f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !             &     quantityType=l_vmr, molecule=fwdModelConf%molecules(k))
    !           j = f%template%noInstances
    !           max_phi_dim = max(max_phi_dim,j)
    !           j = f%template%noSurfs
    !           max_zeta_dim = max(max_zeta_dim,j)
    !         end if
    !       end do
    !     end if
    ! !
    ! !  *** ZEBUG
    ! !
    !     if ( fwdModelConf%spect_der ) then
    !       j = 0
    !       WNV = '--WNV---'
    !       allocate(Spect_der(3*noSpecies))
    !       do k = 1, noSpecies
    !         Spectag = spec_tags(fwdModelConf%molecules(k))
    !         if(Spectag /= 18003) cycle
    !         j = j + 1
    !         Spect_der(j)%type = 'W'
    !         Spect_der(j)%Spectag = Spectag
    !         Spect_der(j)%no_phi_values = 3
    !         Spect_der(j)%no_zeta_values = 4
    !         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
    !         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
    !         Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
    !         Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
    !         j = j + 1
    !         Spect_der(j)%type = 'N'
    !         Spect_der(j)%Spectag = Spectag
    !         Spect_der(j)%no_phi_values = 3
    !         Spect_der(j)%no_zeta_values = 4
    !         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
    !         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
    !         Spect_der(j)%phi_basis = (/-1.5,0.0,1.5/)
    !         Spect_der(j)%zeta_basis = (/-3.0,-1.0,2.0,4.0/)
    !         j = j + 1
    !         Spect_der(j)%type = 'V'
    !         Spect_der(j)%Spectag = Spectag
    !         Spect_der(j)%no_phi_values = 5
    !         Spect_der(j)%no_zeta_values = 16
    !         allocate(Spect_der(j)%phi_basis(Spect_der(j)%no_phi_values))
    !         allocate(Spect_der(j)%zeta_basis(Spect_der(j)%no_zeta_values))
    !         Spect_der(j)%phi_basis = (/-3.0,-1.5,0.0,1.5,3.0/)
    !         Spect_der(j)%zeta_basis = (/ &
    !             &  -1.000000, -0.666667, -0.333333,  0.000000,  0.333333, &
    !             &   0.666667,  1.000000,  1.333333,  1.666667,  2.000000, &
    !             &   2.333333,  2.666667,  3.000000,  3.333333,  3.666667, &
    !             &   4.000000 /)
    !       end do
    !       if(j < 1) deallocate(Spect_der,STAT=i)
    !     end if
    ! !
    ! !  *** END ZEBUG
    ! !
    !     ! Deal with fmStat%rows
    !     if ( present(Jacobian) .and. ( .not. associated (fmStat%rows) ) ) then
    !       call Allocate_test ( fmStat%rows, Jacobian%row%nb, 'fmStat%rows', &
    !         & ModuleName)
    !       fmStat%rows = .false.
    !     endif

    !     ! Get some dimensions that we'll use a lot
    !     noMAFs = firstRadiance%template%noInstances
    !     noMIFs = firstRadiance%template%noSurfs
    !     no_phi_t = temp%template%noInstances
    !     no_tan_hts = FwdModelConf%TangentGrid%nosurfs

    !     nlvl = size(FwdModelConf%integrationGrid%surfs)
    !     n2lvl = 2 * nlvl
    !     maxVert = (Nlvl-1) * Ng + Nlvl

    !     phiWindow = FwdModelConf%phiWindow

    !     if ( toggle(emit) ) then
    !       print*,'Dimensions:'
    !       print*,'noMAFs:',noMAFs
    !       print*,'no_phi_t:',no_phi_t
    !       print*,'no_tan_hts:',no_tan_hts
    !       print*,'maxVert:',maxVert
    !       print*,'nlvl:',nlvl
    !       print*,'n2lvl:',n2lvl
    !       print*,'phiWindow:',phiWindow
    !       print*,'noSpecies:',noSpecies
    !       print*,'maxNoFSurfs:',maxNoFSurfs
    !       print*,'MAF:',fmStat%maf
    !       print*,'tolerance:',fwdModelConf%tolerance
    !     end if

    !     ! Work out which channels are used, also check we have radiances for them.
    !     noUsedChannels = 0
    !     do sigInd = 1, size(fwdModelConf%signals)
    !       thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
    !         & signal=fwdModelConf%signals(sigInd)%index, sideband=firstSignal%sideband )
    !       if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.true.,&
    !         & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
    !         & ModuleName, InvalidQuantity//'radiance' )
    !       noUsedChannels = noUsedChannels + &
    !         & count( fwdModelConf%signals(sigInd)%channels )
    !     end do
    !     call allocate_test ( usedChannels, noUsedChannels, &
    !       & 'usedChannels', ModuleName )
    !     call allocate_test ( usedSignals, noUsedChannels, &
    !       & 'usedSignals', ModuleName )
    !     channel = 1
    !     do sigInd = 1, size(fwdModelConf%signals)
    !       do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
    !         if (fwdModelConf%signals(sigInd)%channels(i)) then
    !           usedChannels(channel) = i
    !           usedSignals(channel) = sigInd
    !           channel = channel + 1
    !         end if
    !       end do
    !     end do

    !     ! --------------- Hydrostatic stuff ---------------------------------
    !     if ( fmStat%newHydros ) then

    !       if ( toggle(emit) .and. levels(emit) > 0 ) &
    !         & call trace_begin ( 'ForwardModel.hydrostatic' )

    !       ! Now we're going to create the many temporary arrays we need
    !       call Allocate_test ( dhdz_path, no_tan_hts, noMAFs, 'dhdz_path', ModuleName )


    !       allocate ( ifm%dhdz_path(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'dhdz_path' )
    !       allocate ( ifm%h_path(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'h_path' )
    !       allocate ( ifm%phi_path(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'phi_path' )
    !       allocate ( ifm%t_path(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'t_path' )
    !       allocate ( ifm%z_path(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'z_path' )

    !       allocate ( ifm%eta_phi(No_tan_hts,noMAFs), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'eta_phi' )

    !       allocate ( ifm%elvar(no_phi_t), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'elvar' )

    !       call allocate_test ( ifm%geoc_lat, no_phi_t, 'geoc_lat', ModuleName )
    !       call allocate_test ( ifm%e_rad, no_phi_t, 'e_rad', ModuleName )

    !       call allocate_test ( ifm%z_glgrid, maxVert, 'z_glgrid', ModuleName )
    !       call allocate_test ( p_glgrid, maxVert, 'p_glgrid', ModuleName )

    !       call allocate_test ( ifm%h_glgrid, maxVert, no_phi_t, 'h_glgrid', &
    !         &  ModuleName )
    !       call allocate_test ( ifm%t_glgrid, maxVert, no_phi_t, 't_glgrid', &
    !         &  ModuleName )
    !       call allocate_test ( ifm%dh_dt_glgrid, maxVert, no_phi_t, &
    !         & temp%template%noSurfs,'dh_dt_glgrid', ModuleName )
    !       call allocate_test ( ifm%dhdz_glgrid, maxVert, no_phi_t, &
    !         &  'dhdz_glgrid', ModuleName )
    !       call allocate_test ( ifm%tan_hts, no_tan_hts, no_phi_t, 'tan_hts', &
    !         &  ModuleName )
    !       call allocate_test ( ifm%tan_temp, no_tan_hts, no_phi_t, 'tan_hts', &
    !         &  ModuleName )
    !       call allocate_test ( ifm%tan_dh_dt, no_tan_hts, no_phi_t, &
    !         & temp%template%noSurfs, 'tan_dh_dt', ModuleName )
    !       call Allocate_test( ifm%closestInstances, noMAFs, 'closestInstances', ModuleName)

    !       ! Setup for hydrostatic calculation
    !       call FindClosestInstances ( temp, firstRadiance, ifm%closestInstances )

    ! !zzzzzzzzzzzzzzz
    ! !
    !       NLm1 = nlvl - 1
    !       Ngp1 = Ng + 1
    !       allocate(xm(NLm1),ym(NLm1),zgx(Ngp1),STAT=i)
    ! !
    ! ! From the selected integration grid pressures define the GL pressure
    ! ! grid:
    !       zGx(1) = -1.0_rp
    !       zGx(2:Ngp1) = Gx(1:Ng)
    !       xm(1:NLm1) = 0.5_rp * ( &
    !                    &   FwdModelConf%integrationGrid%surfs(2:nlvl) + &
    !                    &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    !       ym(1:NLm1) = 0.5_rp * ( &
    !                    &   FwdModelConf%integrationGrid%surfs(2:nlvl) - &
    !                    &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    !       ifm%z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
    !                             &   spread(ym,1,Ngp1) * spread(zGx,2,NLm1)), &
    !                             &  (/maxVert-1/))
    !       ifm%z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
    !       p_glgrid = 10.0_rp**(-ifm%z_glgrid)
    !       deallocate(xm,ym,zgx,STAT=i)
    ! !
    ! ! insert into bill's 2 d hydrostatic
    ! ! The phi input for this program are the orbit plane projected
    ! ! geodetic locations of the temperature phi basis--not necessarily
    ! ! the tangent phi's which may be somewhat different.
    ! !
    !       call two_d_hydrostatic(temp%template%surfs(:,1),
    !             &  temp%template%geodLat*Deg2Rad,   &
    !             &  temp%values, &
    !             &  spread(refGPH%template%surfs(1,1),1,noMAFs),&
    !             &  0.001*refGPH%values(1,:),  &
    !             &  ifm%z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
    !             &  ifm%t_glgrid,ifm%h_glgrid,ifm%dhdz_glgrid, &
    !             &  ifm%dh_dt_glgrid)

    !       allocate(tan_inds(1:no_tan_hts))
    !       do k = 1, no_tan_hts
    !         Zeta = fwdModelConf%tangentGrid%surfs(k)
    !         call Hunt_zvi(Zeta,ifm%z_glgrid-0.0001_rp,maxVert,i,j)
    !         tan_inds(k) = i
    !       end do
    !       no_ss = count(tan_inds == 1) - 1
    !       FwdModelConf%SurfaceTangentIndex = no_ss + 1
    !       fmStat%newHydros = .false.

    ! !zzzzzzzzzzzzzzzzzz

    ! !     do i = 1, no_phi_t
    ! !       phi_tan = Deg2Rad*temp%template%phi(1,i)
    ! !       geod_lat= Deg2Rad*temp%template%geodLat(1,i)
    ! !       call geoc_geod_conv ( ifm%elvar(i), orbIncline%values(1,1), &
    ! !         &  phi_tan, geod_lat, ifm%geoc_lat(i), ifm%E_rad(i) )
    ! !     end do
    ! !
    ! !     ! Now compute a hydrostatic grid given the temperature and refGPH
    ! !     ! information.
    ! !     call hydrostatic_model ( FwdModelConf%SurfaceTangentIndex, &
    ! !       &  no_phi_t, ifm%geoc_lat, 0.001*refGPH%values(1,:), &
    ! !       &  refGPH%template%surfs(1,1), &
    ! !       &  FwdModelConf%integrationGrid%surfs, &
    ! !       &  temp%template%surfs(:,1), temp%values, &
    ! !       &  ifm%z_glgrid, ifm%h_glgrid, ifm%t_glgrid, &
    ! !       &  ifm%dhdz_glgrid, ifm%dh_dt_glgrid, &
    ! !       &  FwdModelConf%TangentGrid%surfs, &
    ! !       &  ifm%tan_hts, ifm%tan_temp, ifm%tan_dh_dt, &
    ! !       &  ifm%gl_count, Ier )
    ! !     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    ! !       & 'Hydrostatic model failed' )
    ! !
    ! !     ! Now compute stuff along the path given this hydrostatic grid.
    ! !     call comp_path_entities ( temp, ifm%closestInstances, &
    ! !       &  FwdModelConf%integrationGrid%noSurfs, &
    ! !       &  temp%template%noSurfs, ifm%gl_count, ifm%ndx_path, ifm%z_glgrid, &
    ! !       &  ifm%t_glgrid, ifm%h_glgrid, ifm%dhdz_glgrid, ifm%tan_hts,        &
    ! !       &  no_tan_hts, ifm%z_path, ifm%h_path, ifm%t_path, ifm%phi_path,    &
    ! !       &  ifm%dhdz_path, ifm%eta_phi, no_phi_t,                            &
    ! !       &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier)
    ! !     if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    ! !       & 'Hydrostatic model failed' )
    ! !
    ! !     fmStat%newHydros = .false.
    ! !
    ! !     if ( toggle(emit) .and. levels(emit) > 0 ) &
    ! !       & call trace_end ( 'ForwardModel.hydrostatic' )

    !     end if

    !     ! ------ End of hydrostatic setup stuff --------------------------

    ! !zzzzzzzzzzzzzzzzzzzzzzzzzzz
    ! !******************* LOAD SPECIES DATA (Including Spectroscopy) ********

    !     call load_sps_data(fwdModelIn,fwdModelExtra,fwdModelConf%molecules,   &
    !         &     no_coeffs_f,no_phi_f,sv_len,n_sv_phi,n_sv_zeta,   &
    !         &     h2o_ind,no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,   &
    !         &     Spect_Der,WNV,n_sv_phi_dw,n_sv_zeta_dw,n_sv_phi_dn,         &
    !         &     n_sv_zeta_dn,n_sv_phi_dv,n_sv_zeta_dv,no_z_dw,no_phi_dw,    &
    !         &     no_z_dn,no_phi_dn,no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,&
    !         &     z_basis_dn,phi_basis_dn,z_basis_dv,phi_basis_dv)

    ! !******************* LOAD gl_slabs structures ******

    !     no_ele = 2*maxVert ! maximum possible
    !     call allocate_test (gl_slabs, no_ele, noSpecies, 'gl_slabs', &
    !                     &   ModuleName )
    ! !
    !     do i = 1, noSpecies
    !       nl = size(My_Catalog(i)%Lines)
    !       gl_slabs(1:no_ele,i)%no_lines = nl
    !       do j = 1, no_ele
    !         allocate(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
    !             &    gl_slabs(j,i)%y(nl),gl_slabs(j,i)%yi(nl),   &
    !             &    gl_slabs(j,i)%slabs1(nl),                   &
    !             &    gl_slabs(j,i)%dslabs1_dv0(nl))
    !       end do
    !     end do
    ! !
    !     if ( FwdModelConf%temp_der ) then
    !       allocate(gl_slabs_p(no_ele,noSpecies), &
    !             &  gl_slabs_m(no_ele,noSpecies) )
    !       do i = 1, noSpecies
    !         nl = size(My_Catalog(i)%Lines)
    !         gl_slabs_m(1:no_ele,i)%no_lines = nl
    !         gl_slabs_p(1:no_ele,i)%no_lines = nl
    !         do j = 1, no_ele
    !           allocate(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
    !               &    gl_slabs_p(j,i)%y(nl),gl_slabs_p(j,i)%yi(nl),   &
    !               &    gl_slabs_p(j,i)%slabs1(nl),                     &
    !               &    gl_slabs_p(j,i)%dslabs1_dv0(nl),                &
    !               &    gl_slabs_m(j,i)%v0s(nl),gl_slabs_m(j,i)%x1(nl), &
    !               &    gl_slabs_m(j,i)%y(nl),gl_slabs_m(j,i)%yi(nl),   &
    !               &    gl_slabs_m(j,i)%slabs1(nl),                     &
    !               &    gl_slabs_m(j,i)%dslabs1_dv0(nl)  )
    !         end do
    !       end do
    !     endif

    ! !******************* END of gl_slabs structures load ******
    ! !zzzzzzzzzzzzzzzzzzzzzzzzzzz
    ! !
    !     ! Skip this MAF if it's in an overlap region possibly
    !     maf=fmStat%maf
    !     if ( (.not. fwdModelConf%skipOverlaps) .or. &
    !       & ( maf > firstRadiance%template%noInstancesLowerOverlap .and. &
    !       &   maf <= noMAFs - firstRadiance%template%noInstancesUpperOverlap ) ) then

    !       ! ------ Begin main MAF Specific stuff ---------------------------

    !       ! Now allocate other stuff
    !       call allocate_test ( t_script, n2lvl, 't_srcipt', ModuleName )
    !       call allocate_test ( ref_corr, n2lvl, no_tan_hts, 'ref_corr', ModuleName )
    !       call allocate_test ( tau, n2lvl, 'tau', ModuleName )
    !       call allocate_test ( ptg_angles, no_tan_hts, 'ptg_angles', ModuleName )

    !       call allocate_test ( midval_delta, n2lvl, noSpecies, &
    !                      &    'midval_delta', ModuleName )

    !       allocate ( k_atmos_frq(noSpecies), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'k_atmos_frq' )

    !       allocate ( n_path(No_tan_hts), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'n_path' )
    !       allocate ( spsfunc_path(noSpecies,No_tan_hts), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'spsfunc_path' )
    !       call allocate_test ( dx_dt, No_tan_hts, temp%template%noSurfs, &
    !         & 'dx_dt', ModuleName )
    !       call allocate_test ( d2x_dxdt, No_tan_hts, temp%template%noSurfs, &
    !         & 'd2x_dxdt', ModuleName )

    !       allocate ( sps_phi_loop(noSpecies,No_tan_hts), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'sps_phi_loop' )
    !       allocate ( sps_zeta_loop(noSpecies,No_tan_hts), stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'sps_zeta_loop' )

    !       call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
    !         & 'Radiances', ModuleName )
    !       call allocate_test ( i_star_all, noUsedChannels, noMIFs, &
    !         & 'i_star_all', ModuleName )

    !       ! Now set radiances to zero, forward model just adds in terms
    !       do i = 1, noUsedChannels
    !         thisRadiance = GetVectorQuantityByType (fwdModelOut, &
    !           & quantityType=l_radiance, &
    !           & signal=fwdModelConf%signals(usedSignals(i))%index, &
    !           & sideband=firstSignal%sideband )
    !         ch = usedChannels(i)
    !         do j = 1, noMIFs
    !           k = ch + (j-1)*thisRadiance%template%noChans
    !           thisRadiance%values(k, fmStat%maf) = 0.0
    !         end do
    !       end do

    !       if ( fwdModelConf%signals(1)%sideband == 0 ) then
    !         if (.not. associated (sidebandRatio) ) &
    !           & call MLSMessage(MLSMSG_Error,ModuleName, &
    !           & "No sideband ratio supplied")
    !         sidebandStart = -1
    !         sidebandStop = 1
    !         sidebandStep = 2
    !       else
    !         sidebandStart = fwdModelConf%signals(1)%sideband
    !         sidebandStop = sideBandStart
    !         sidebandStep = 1
    !       endif

    !       ! ----------------- Begin loop over sidebands -----------------------
    !       do thisSideband = sidebandStart, sidebandStop, sidebandStep

    !         if ( toggle(emit) .and. levels(emit) > 0 ) then
    !           call trace_begin ( 'ForwardModel.sideband' )
    !           call output ( ' Doing sideband ' )
    !           call output ( thisSideband )
    !           call output ( ' (' ); call output ( sidebandStart )
    !           call output ( ', ' ); call output ( sidebandStop )
    !           call output ( ')', advance='yes' )
    !         end if

    !         ! Now code splits into two sections, one for when we're doing frequency
    !         ! averaging, and one when we're not.
    !         if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
    !           if ( toggle(emit) .and. levels(emit) > 0 ) &
    !             & call trace_begin ( 'ForwardModel.FreqAvg' )

    !           call allocate_test ( superset, size(pointingGrids), &
    !             & 'superset', ModuleName )
    !           do i = 1, size(pointingGrids)
    !             superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
    !               & fwdModelConf%signals, sideband=thisSideband )
    !           end do
    !           if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & "No matching pointing frequency grids." )

    !           maxSuperset = maxval ( superset )
    !           where ( superset < 0 )
    !             superset = maxSuperset + 1
    !           end where
    !           whichPointingGridAsArray = minloc ( superset )
    !           whichPointingGrid = whichPointingGridAsArray(1)
    !           call deallocate_test ( superset, 'superset', ModuleName )

    !           if ( toggle(emit) ) then
    !             call output ( 'Using pointing frequency grid: ' )
    !             call output ( whichPointingGrid, advance='yes' )
    !           end if

    !           ! Now we've identified the pointing grids.  Locate the tangent grid
    !           ! within it.
    !           call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
    !             "Grids", ModuleName )
    !           call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
    !             & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
    !           if ( toggle(emit) .and. levels(emit) > 0 ) &
    !             & call trace_end ( 'ForwardModel.FreqAvg' )

    !         else ! ------------------------- Not frequency averaging ---------

    !           if ( toggle(emit) .and. levels(emit) > 0 ) &
    !             & call trace_begin ( 'ForwardModel.NotFreqAvg' )

    !           call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
    !           do channel = 1, noUsedchannels
    !             frequencies(channel) = &
    !               & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
    !               & fwdModelConf%signals(usedSignals(channel))% &
    !               &  frequencies(usedChannels(channel))
    !           end do
    !           select case ( thisSideband )
    !           case ( -1 )
    !             frequencies = firstSignal%lo - frequencies
    !           case ( +1 )
    !             frequencies = firstSignal%lo + frequencies
    !           case ( 0 )
    !             call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'Folded signal requested in forward model' )
    !           case default
    !             call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'Bad value of signal%sideband' )
    !           end select
    !           noFreqs = noUsedChannels
    !           if ( toggle(emit) .and. levels(emit) > 0 ) &
    !             & call trace_end ( 'ForwardModel.NotFreqAvg' )
    !         end if

    !         ! ----------- Done the gnarly frequency stuff ----------

    !         ! Now work out what `window' we're inside.  This will need to be changed
    !         ! a bit in later versions to avoid the noMAFS==noTemp/f instances
    !         ! assertion

    !         mafTInstance = ifm%closestInstances(maf)

    !         windowStart  = max(1, mafTInstance - phiWindow/2)
    !         windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)

    !         if ( toggle(emit) .and. levels(emit) > 0 ) then
    !           print *, 'Doing MAF: ', maf
    !           print *, 'mafTInstance:',mafTInstance
    !           print *, 'WindowStart:',WindowStart
    !           print *, 'WindowFinish:',WindowFinish
    !         end if

    !         allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
    !           & windowStart:windowFinish), stat=status )
    !         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !           & MLSMSG_Allocate//'k_temp' )
    !         allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
    !           & windowStart:windowFinish, noSpecies), stat=status )
    !         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !           & MLSMSG_Allocate//'k_atmos' )

    !         ! Compute the specie function (spsfunc) and the refraction along
    !         ! all the paths for the current maf

    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_begin ( 'ForwardModel.get_path_spsfunc_ngrid' )
    !         call get_path_spsfunc_ngrid ( fwdModelIn, fwdModelExtra, &
    !           &  fwdModelConf%molecules, ifm%ndx_path(:,maf), no_tan_hts, &
    !           &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), &
    !           &  n_path, spsfunc_path, sps_zeta_loop, sps_phi_loop, ier)
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_end ( 'ForwardModel.get_path_spsfunc_ngrid' )
    !         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !           & 'get_path_sps_fun_ngrid failed' )

    !         !??? Choose better value for phi_tan later
    !         phi_tan = Deg2Rad * temp%template%phi(1,mafTInstance)

    !         ! Compute the ptg_angles (chi) for Antenna convolution, also the
    !         ! derivatives of chi w.r.t to T and other parameters
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_begin ( 'ForwardModel.get_chi_angles' )
    !         call get_chi_angles ( ifm%ndx_path(:,maf), n_path, &
    !           &  fwdModelConf%tangentGrid%surfs, &
    !           &  ifm%tan_hts(:,mafTInstance),ifm%tan_temp(:,mafTInstance),&
    !           &  phi_tan,ifm%elvar(maf)%Roc,&
    !           &  0.001*scGeocAlt%values(1,1),  &
    !           &  elevOffset%values(1,1), &
    !           &  ifm%tan_dh_dt(:,mafTInstance,:), no_tan_hts, &
    !           &  temp%template%noSurfs, &
    !           &  temp%template%surfs(:,1), &
    !           &  fwdModelConf%SurfaceTangentIndex, &
    !           &  center_angle, ptg_angles, dx_dt, d2x_dxdt, ier )
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_end ( 'ForwardModel.get_chi_angles' )
    !         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !           & 'get_chi_angles failed' )

    !         ! Compute the refraction correction scaling matrix for this mmaf:
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_begin ( 'ForwardModel.refraction_correction' )
    !         call refraction_correction ( no_tan_hts, ifm%tan_hts(:,mafTInstance), &
    !           &  ifm%h_path(:,maf), n_path, ifm%ndx_path(:,maf),      &
    !           &  ifm%E_rad(mafTInstance), ref_corr )
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_end ( 'ForwardModel.refraction_correction' )

    !         Radiances = 0.0

    !         ! If we're not doing frequency averaging, instead outputting radiances
    !         ! corresponding to delta function responses, we can set up the frequency
    !         ! information here.  In the more common case where we are doing the
    !         ! averaging, the frequency grid varies from pointing to pointing, and is
    !         ! allocated inside the pointing loop.

    !         ! First we have a mini loop over pointings to work out an upper limit
    !         ! for the number of frequencies we're going to be dealing with
    !         if ( fwdModelConf%do_freq_avg ) then
    !           maxNoFreqs = size(PointingGrids(whichPointingGrid)%OneGrid(grids(1))%Frequencies)
    !           do ptg_i = 2, no_tan_hts - 1
    !             maxNoFreqs = max ( maxNoFreqs, size(PointingGrids(whichPointingGrid) &
    !               & %OneGrid(grids(ptg_i))%Frequencies) )
    !           end do
    !         else
    !           maxNoFreqs = noFreqs
    !         end if

    !         ! Now allocate arrays this size
    !         if ( fwdModelConf%temp_der ) then
    !           allocate ( k_temp_frq%values( maxNoFreqs, temp%template%noSurfs, &
    !             & windowStart:windowFinish), stat=status )
    !           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
    !             & MLSMSG_Allocate//'k_temp_frq' )
    !           k_temp_frq%values = 0.0_r8
    !         end if

    !         call allocate_test ( radV,maxNoFreqs, 'radV', ModuleName )

    !         do specie = 1, noSpecies
    !           f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !             & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )

    !           ! Allocate intermediate space for vmr derivatives
    !           if ( fwdModelConf%moleculeDerivatives(specie) ) then
    !             allocate ( k_atmos_frq(specie)%values(maxNoFreqs,f%template%noSurfs,&
    !               & windowStart:windowFinish), stat=status )
    !             if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
    !               & MLSMSG_Allocate//'k_atmos_frq' )
    !           end if

    !         end do ! End loop over species

    ! !  Find the maximum number of frequencies over all heights

    !         max_num_frq = 1
    !         i = whichPointingGrid
    !         if ( FwdModelConf%do_freq_avg ) then
    !           do j = 1, no_tan_hts
    !             m = size(PointingGrids(i)%oneGrid(grids(j))%frequencies)
    !             if ( m > max_num_frq) max_num_frq = m
    !           end do
    !         end if
    ! !
    !         ! Now we can go ahead and loop over pointings
    !         ! ------------------------------ Begin loop over pointings --------
    !         do ptg_i = 1, no_tan_hts

    !           if ( toggle(emit) .and. levels(emit) > 1 ) then
    !             call trace_begin ( 'ForwardModel.Pointing' )
    !             call output ( 'Ptg = ' ); call output ( ptg_i, advance='yes' )
    !           end if

    !           k = ptg_i
    !           h_tan = ifm%tan_hts(k,mafTInstance)
    !           lmax = ubound(ifm%eta_phi(ptg_i,maf)%values,2)
    ! !
    !           ifm%elvar(maf)%ht = h_tan
    !           ifm%elvar(maf)%Rr = ifm%elvar(maf)%ht + ifm%elvar(maf)%RoC
    !           ifm%elvar(maf)%ht2 = ifm%elvar(maf)%Rr * ifm%elvar(maf)%Rr

    !  ! Compute the beta's along the path, for this tanget hight and this mmaf:

    !           brkpt = ifm%ndx_path(ptg_i,maf)%break_point_index
    !           no_ele = ifm%ndx_path(ptg_i,maf)%total_number_of_elements
    ! !
    !           if(ptg_i == 1) then
    !             j = no_ele / Ng
    !             allocate(midval_ndx(j,2),gl_ndx(j,2),stat=status)
    !             if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName,&
    !               & MLSMSG_Allocate//'midval_ndx/gl_ndx' )
    !           endif

    !           ! If we're doing frequency averaging, get the frequencies we need for
    !           ! this pointing.
    !           if ( FwdModelConf%do_freq_avg ) then
    !             frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
    !             noFreqs = size(frequencies)
    !           end if ! If not, we dealt with this outside the loop

    !           if(noFreqs > 1) tau(1:) = 1.0
    ! !
    ! ! Compute ALL the slabs_prep entities over the path's GL grid for this
    ! ! pointing & mmaf:
    ! !
    !           call get_gl_slabs_arrays(my_Catalog,ifm%z_path(ptg_i,maf),&
    !              & ifm%t_path(ptg_i,maf),0.001*losVel%values(1,maf), &
    !              & gl_slabs,ptg_i,no_ele,max_nl,ier)
    !           if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & 'get_gl_slabs_arrays' )
    ! !
    ! ! Compute the beta's along the path on the COARSE grid only, for this pointing
    ! ! and this mmaf (recall that k=ptg_i):
    ! !
    !           call get_coarse_beta_path(k,my_Catalog,ifm%ndx_path(k,maf), &
    !              & gl_slabs,noFreqs,max_num_frq,h_tan,frequencies,        &
    !              & ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf), &
    !              & fwdModelConf%frqGap,fwdModelConf%temp_der,             &
    !              & fwdModelConf%spect_der, beta_path, Ier)
    !           if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & 'get_coarse_beta_path' )
    ! !
    !           ! Define the dh_dt_path for this pointing and this MAF:

    !           ! Need to allocate this even if no derivatives as we pass it

    !           call allocate_test ( dh_dt_path, no_ele, phiWindow, &
    !             & temp%template%noSurfs, "dh_dt_path", ModuleName )

    !           if ( fwdModelConf%temp_der ) then
    !             allocate ( dum(no_ele), stat=ier )
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
    !               & MLSMSG_Allocate // 'dum' )
    !             do j = 1, temp%template%noSurfs
    !               do i = 1, phiWindow
    !                 m = min(lmax,i+windowStart-1)
    !                 call Lintrp ( ifm%z_glgrid, ifm%z_path(ptg_i,maf)%values,&
    !                   &           ifm%dh_dt_glgrid(:,m,j), dum, ifm%gl_count,&
    !                   &           no_ele )
    !                 dh_dt_path(:,i,j) = dum(:) * ifm%eta_phi(ptg_i,maf)%values(:,m)
    !               end do
    !             end do
    !             deallocate ( dum, stat=ier )
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
    !               & MLSMSG_DeAllocate // 'dum' )
    !           end if

    !           ! ------------------------------- Begin loop over frequencies ------
    !           do frq_i = 1, noFreqs
    ! !
    !             call path_contrib(tau, brkpt, no_ele, fwdModelConf%tolerance, &
    !               &  mid, midval_ndx, no_midval_ndx, gl_ndx, no_gl_ndx, Ier)
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'Path_contrib failed' )
    ! !
    !             call coarse_delta(mid,brkpt,no_ele,ifm%h_path(k,maf), &
    !               &  beta_path(:,frq_i),spsfunc_path(:,k),        &
    !               &  noSpecies,Nlvl,ref_corr(:,k),ifm%elvar(maf),     &
    !               &  midval_delta,Ier)
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'coarse_delta failed' )
    ! !
    !             Frq = frequencies(frq_i)
    !             if ( toggle(emit) .and. levels(emit) > 2 ) then
    !               call trace_begin ( 'ForwardModel.Frequencies' )
    !               call output ( 'Frq = ' ); call output ( frq_i, advance='yes' )
    !             end if
    ! !
    ! ! Compute the beta's along the path, for this tanget hight and this mmaf:
    ! !
    !             call get_glbeta_path(k,frq_i,my_Catalog,gl_ndx,no_gl_ndx, &
    !                & gl_slabs,Frq,ifm%z_path(k,maf),ifm%t_path(k,maf),    &
    !                & fwdModelConf%frqGap,fwdModelConf%temp_der,           &
    !                & fwdModelConf%spect_der, beta_path, Ier)
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'get_glbeta_path failed' )
    ! !
    !             call Rad_Tran ( ifm%elvar(maf), Frq,                         &
    !               &  fwdModelConf%integrationGrid%noSurfs,h_tan,noSpecies,   &
    !               &  ifm%z_path(k,maf),ifm%h_path(k,maf),ifm%t_path(k,maf),  &
    !               &  ifm%dHdz_path(k,maf),earthRefl%values(1,1),             &
    !               &  beta_path(:,frq_i),spsfunc_path(:,k),ref_corr(:,k),     &
    !               &  spaceRadiance%values(1,1),brkpt,no_ele,mid,ilo,ihi,     &
    !               &  t_script,tau,midval_ndx,no_midval_ndx,gl_ndx,no_gl_ndx, &
    !               &  midval_delta,Rad,Ier)
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
    !               & 'rad_tran failed' )

    !             RadV(frq_i) = Rad

    !             ! Now, Compute the radiance derivatives:

    !             !??? Do we need to do this if there's no Jacobian or no derivatives requested ???

    !             call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn,    &
    !               &  ifm%elvar(maf),frq_i,Frq,noSpecies,ifm%z_path(k,maf),     &
    !               &  ifm%h_path(k,maf),ifm%t_path(k,maf),ifm%phi_path(k,maf),  &
    !               &  ifm%dHdz_path(k,maf),beta_path(:,frq_i),spsfunc_path(:,k),&
    !               &  temp%template%surfs(:,1),temp%template%noSurfs,           &
    !               &  ref_corr(:,k),temp%template%noInstances,                  &
    !               &  temp%template%phi(1,:)*Deg2Rad,dh_dt_path,k_temp_frq,     &
    !               &  k_atmos_frq,brkpt,no_ele,mid,ilo,ihi,t_script,tau,        &
    !               &  max_zeta_dim,max_phi_dim,midval_ndx,no_midval_ndx,        &
    !               &  gl_ndx,no_gl_ndx,midval_delta,Sps_zeta_loop(:,k),         &
    !               &  Sps_phi_loop(:,k),Ier)
    !             if( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,     &
    !               & 'rad_tran_wd failed' )

    !             if ( toggle(emit) .and. levels(emit) > 2 ) &
    !               & call trace_end ( 'ForwardModel.Frequencies' )

    !           end do                          ! Frequency loop

    !           ! ----------------------------- End loop over frequencies ----

    !           ! Here we either frequency average to get the unconvolved radiances, or
    !           ! we just store what we have as we're using delta funciton channels

    !           if ( toggle(emit) .and. levels(emit) > 1 ) &
    !             & call trace_begin ( 'ForwardModel.FrequencyAvg' )
    !           if ( fwdModelConf%do_freq_avg ) then
    !             do i = 1, noUsedChannels
    !               sigInd = usedSignals(i)
    !               ch = usedChannels(i)
    !               if ( toggle(emit) .and. levels(emit) > 2 ) then
    !                 call output ( 'Channel = ' )
    !                 call output ( i )
    !                 call output ( ' ( ' )
    !                 call output ( sigInd )
    !                 call output ( ':' )
    !                 call output ( ch )
    !                 call output ( ' )', advance='yes' )
    !               end if
    !               centerFreq = firstSignal%lo + &
    !                 & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
    !               shapeInd = MatchSignal ( filterShapes%signal, &
    !                 & fwdModelConf%signals(sigInd), sideband = thisSideband )
    !               if ( shapeInd == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !                 & "No matching channel shape information" )
    !               if ( toggle(emit) .and. levels(emit) > 2 ) then
    !                 call output ( 'Using filter shape:' )
    !                 call output ( shapeInd, advance='yes' )
    !               endif

    !               call Freq_Avg ( frequencies, &
    !                 & centerFreq+thisSideband * &
    !                 & FilterShapes(shapeInd)%FilterGrid(ch,:), &
    !                 & FilterShapes(shapeInd)%FilterShape(ch,:), RadV, noFreqs,  &
    !                 & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), Radiances(ptg_i,i) )
    !             end do
    !           else
    !             Radiances(ptg_i,:) = RadV(1:noFreqs)
    !           end if

    !           ! Frequency Average the temperature derivatives with the appropriate
    !           ! filter shapes
    !           !??? Do we need to do this if there's no Jacobian ???
    !           if ( fwdModelConf%temp_der ) then
    !             if ( fwdModelConf%do_freq_avg ) then
    !               do i = 1, noUsedChannels
    !                 sigInd = usedSignals(i)
    !                 ch = usedChannels(i)
    !                 centerFreq = firstSignal%lo + &
    !                   & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
    !                 shapeInd = MatchSignal ( filterShapes%signal, &
    !                   & fwdModelConf%signals(sigInd), &
    !                   & sideband = thisSideband, channel=ch )
    !                 do instance = lbound(k_temp_frq%values,3), &
    !                   & ubound(k_temp_frq%values,3)
    !                   do surface = 1, temp%template%noSurfs
    !                     ToAvg => k_temp_frq%values(1:noFreqs,surface,instance)
    !                     call Freq_Avg ( frequencies,                        &
    !                       & centerFreq+thisSideband* &
    !                       & FilterShapes(shapeInd)%FilterGrid(ch,:), &
    !                       & FilterShapes(shapeInd)%FilterShape(ch,:),&
    !                       & real(ToAvg,r8), noFreqs, &
    !                       & size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
    !                     k_temp(i,ptg_i,surface,instance) = r
    !                   end do                  ! Surface loop
    !                 end do                    ! Instance loop
    !               end do                      ! Channel loop
    !             else
    !               do i = 1, noUsedChannels
    !                 k_temp(i,ptg_i,1:temp%template%noSurfs,:) = &
    !                   &  k_temp_frq%values(i,1:temp%template%noSurfs,:)
    !               end do
    !             end if
    !           end if

    !           ! Frequency Average the atmospheric derivatives with the appropriate
    !           ! filter shapes
    !           !??? Do we need to do this if there's no Jacobian ???
    !           do specie = 1, noSpecies
    !             if ( fwdModelConf%moleculeDerivatives(specie) ) then
    !               f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
    !                 &  quantityType=l_vmr, molecule=fwdModelConf%molecules(specie))
    !               if ( fwdModelConf%do_freq_avg ) then
    !                 do i = 1, noUsedChannels
    !                   sigInd = usedSignals(i)
    !                   ch = usedChannels(i)
    !                   centerFreq = firstSignal%lo + &
    !                     & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
    !                   shapeInd = MatchSignal ( filterShapes%signal, &
    !                     & fwdModelConf%signals(sigInd), &
    !                     & sideband = thisSideband, channel=ch )
    !                   do instance = lbound(k_atmos_frq(specie)%values,3),&
    !                     & ubound(k_atmos_frq(specie)%values,3)
    !                     do surface = 1, f%template%noSurfs
    !                       ToAvg => k_atmos_frq(specie)%values(1:noFreqs,surface,instance)
    !                       call Freq_Avg ( frequencies,                      &
    !                         & centerFreq+thisSideband * &
    !                         & FilterShapes(shapeInd)%FilterGrid(ch,:), &
    !                         & FilterShapes(shapeInd)%FilterShape(ch,:), &
    !                         & real(ToAvg,r8),  &
    !                         & noFreqs, size(FilterShapes(shapeInd)%FilterGrid(ch,:)), r )
    !                       k_atmos(i,ptg_i,surface,instance,specie) = r
    !                     end do                ! Surface loop
    !                   end do                  ! Instance loop
    !                 end do                    ! Channel loop
    !               else                        ! Else not frequency averaging
    !                 surface = f%template%noSurfs
    !                 do i = 1, noUsedChannels
    !                   k_atmos(i,ptg_i,1:surface,:,specie) = &
    !                     &  k_atmos_frq(specie)%values(i,1:surface,:)
    !                 end do
    !               end if                      ! Frequency averaging or not
    !             end if                        ! Want derivatives for this
    !           end do                          ! Loop over species

    !           if ( toggle(emit) .and. levels(emit) > 1 ) &
    !             & call trace_end ( 'ForwardModel.FrequencyAvg' )

    !           call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )

    !           if ( toggle(emit) .and. levels(emit) > 1 ) &
    !             & call trace_end ( 'ForwardModel.Pointing' )

    !         end do                            ! Pointing Loop
    !         ! ---------------------------------- End of Pointing Loop ---------------
    ! !
    ! ! ========= Pointings dependance deallocation section:
    ! ! (De-Allocate some of the arrays connected with pointing)
    ! !
    !         deallocate(midval_ndx,gl_ndx,stat=status)
    !         if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
    !           & MLSMSG_DeAllocate // 'midval_ndx/gl_ndx' )

    !         do j = 1, size(gl_slabs,1)
    !           do i = 1, size(gl_slabs,2)
    !             deallocate(gl_slabs(j,i)%v0s, gl_slabs(j,i)%v0sm,     &
    !             &    gl_slabs(j,i)%v0sp, gl_slabs(j,i)%x1,            &
    !             &    gl_slabs(j,i)%y, gl_slabs(j,i)%yi,               &
    !             &    gl_slabs(j,i)%slabs1, gl_slabs(j,i)%dx1_dv0,     &
    !             &    gl_slabs(j,i)%dy_dv0, gl_slabs(j,i)%dslabs1_dv0, &
    !             &    gl_slabs(j,i)%v0sm, gl_slabs(j,i)%x1m,           &
    !             &    gl_slabs(j,i)%ym, gl_slabs(j,i)%yim,             &
    !             &    gl_slabs(j,i)%slabs1m, gl_slabs(j,i)%v0sp,       &
    !             &    gl_slabs(j,i)%x1p, gl_slabs(j,i)%yp,             &
    !             &    gl_slabs(j,i)%yip, gl_slabs(j,i)%slabs1p, STAT=k)
    !           end do
    !         end do

    !         deallocate ( gl_slabs, STAT=k )

    !         if ( associated(beta_path) ) then
    !           do i = 1, size(beta_path,1)
    !             do j = 1, size(beta_path,2)
    !               deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
    !                 & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
    !                 & beta_path(i,j)%dbeta_dnu, STAT=k )
    !             end do
    !           end do
    !         end if

    !         deallocate ( beta_path, STAT=k )
    ! !
    ! ! ========= End of pointing dependence De-Allocate section
    ! !
    !         !  Here comes the Convolution code
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_begin ( 'ForwardModel.Convolution' )
    !         call allocate_test ( superset, size(antennaPatterns), &
    !           & 'superset', ModuleName )
    !         do i = 1, noUsedChannels

    !           ch = usedChannels(i)
    !           sigInd = usedSignals(i)
    !           thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
    !             & signal=fwdModelConf%signals(sigInd)%index, &
    !             & sideband=firstSignal%sideband )

    !           if ( sidebandStart /= sidebandStop ) then ! We're folding
    !             thisRatio = sidebandRatio%values(ch,1)
    !             if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
    !           else ! Otherwise, want just unfolded signal
    !             thisRatio = 1.0
    !           end if

    !           if ( FwdModelConf%do_conv ) then

    !             do j = 1, size(antennaPatterns)
    !               superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
    !                 & fwdModelConf%signals, sideband=thisSideband, channel=ch )
    !             end do
    !             if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & "No matching antenna patterns." )

    !             maxSuperset = maxval ( superset )
    !             where ( superset < 0 )
    !               superset = maxSuperset + 1
    !             end where
    !             whichPatternAsArray = minloc ( superset )
    !             whichPattern = whichPatternAsArray(1)
    !             if ( toggle(emit) .and. levels(emit) > 2 ) then
    !               call output ( 'Using antenna pattern: ' )
    !               call output ( whichPattern, advance='yes' )
    !             end if

    !             call convolve_all ( fwdModelConf, fwdModelIn, maf, ch, &
    !               &     windowStart, windowFinish, mafTInstance-windowStart+1, &
    !               &     temp, ptan, thisRadiance, &
    !               &     FwdModelConf%tangentGrid%surfs, ptg_angles, &
    !               &     ifm%tan_temp(:,maf), dx_dt, d2x_dxdt, si, center_angle, &
    !               &     Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
    !               &     thisRatio, Jacobian, fmStat%rows,  &
    !               &     antennaPatterns(whichPattern), ier )
    !             !??? Need to choose some index other than 1 for AntennaPatterns ???
    !             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !               & 'convolve_all failed' )
    !           else
    !             call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, ch,  &
    !               &     windowStart, windowFinish, temp, ptan, thisRadiance, &
    !               &     FwdModelConf%tangentGrid%surfs, &
    !               &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
    !               &     thisRatio, Jacobian, fmStat%rows )

    !           end if

    !         end do                            ! Channel loop

    !         call deallocate_test ( superset, 'superset', ModuleName )
    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_end ( 'ForwardModel.Convolution' )

    !         if ( toggle(emit) .and. levels(emit) > 0 ) &
    !           & call trace_end ( 'ForwardModel.sideband' )
    !       end do
    !       ! ---------------------------- End of loop over sideband ------------------

    !       ! ------------------------------ End of Major Frame Specific stuff --------


    !       ! Deallocate stuff allocated earlier
    !       call Deallocate_test ( sps_values, 'sps_values', ModuleName )
    !       call Deallocate_test ( no_z, 'no_z', ModuleName )
    !       call Deallocate_test ( no_phi, 'no_phi', ModuleName )
    !       call Deallocate_test ( lin_log, 'lin_log', ModuleName )
    !       call Deallocate_test ( z_basis, 'z_basis', ModuleName )
    !       call Deallocate_test ( phi_basis, 'phi_basis', ModuleName )

    !       if ( FwdModelConf%temp_der ) call deallocate_test &
    !         & ( k_temp_frq%values, "k_temp_frq%values", ModuleName )
    !       if ( FwdModelConf%atmos_der ) then
    !         do j = 1, noSpecies
    !           call deallocate_test(k_atmos_frq(j)%values,"k_atmos_frq(j)%values",&
    !             & ModuleName )
    !         end do
    !       end if

    !       if ( index(switches,'rad') /= 0 ) then
    !         ! *** DEBUG Print
    !         if ( FwdModelConf%do_conv ) then
    !           print *,'Convolution: ON'
    !         else
    !           print *,'Convolution: OFF'
    !         end if

    !         if ( FwdModelConf%do_freq_avg ) then
    !           print *,'Frequency Averaging: ON'
    !         else
    !           Frq = Frequencies(1)
    !           print *,'Frequency Averaging: OFF'
    !           print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
    !         end if

    !         print *
    !         k=ptan%template%noSurfs
    !         print 901, k
    ! 901     format ( 'ptan\ ',i3.3)
    !         print 902,Ptan%values(1:k,maf)
    ! 902     format ( 4(4x, f10.7))

    !         print *
    !         do i = 1, noUsedChannels
    !           ch = usedChannels(i)
    !           print 903, ch, char(92), ptan%template%noSurfs
    ! 903       format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
    !           print 905, ( firstRadiance%values(ch+(k-1)*firstRadiance%template%noChans,maf),&
    !             & k = 1, ptan%template%noSurfs )
    ! 905       format ( 4(2x, 1pg15.8) )
    !         end do
    !       end if

    !       do j = 1, No_tan_hts
    !         deallocate ( n_path(j)%values, stat=status )
    !         if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !           & MLSMSG_Deallocate//'n_path%values' )
    !         do i = 1, noSpecies
    !           deallocate ( spsfunc_path(i,j)%values, stat=status )
    !           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & MLSMSG_Deallocate//'spsfunc_path%values' )
    !           deallocate ( sps_phi_loop(i,j)%values, stat=status )
    !           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & MLSMSG_Deallocate//'sps_phi_loop%values' )
    !           deallocate ( sps_zeta_loop(i,j)%values, stat=status )
    !           if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !             & MLSMSG_Deallocate//'sps_zeta_loop%values' )
    !         end do
    !       end do

    !       deallocate ( n_path, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Deallocate//'n_path' )

    !       deallocate ( spsfunc_path, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Deallocate//'spsfunc_path' )

    !       deallocate ( sps_phi_loop, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Deallocate//'sps_phi_loop' )
    !       deallocate ( sps_zeta_loop, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Deallocate//'sps_zeta_loop' )

    !       call deallocate_test ( dx_dt, 'dx_dt', ModuleName )
    !       call deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

    !       call deallocate_test ( t_script, 't_srcipt', ModuleName )
    !       call deallocate_test ( ref_corr, 'ref_corr', ModuleName )
    !       call deallocate_test ( tau, 'tau', ModuleName )
    !       call deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
    !       call deallocate_test ( midval_delta, 'midval_delta', ModuleName )

    !       deallocate ( k_atmos_frq, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Deallocate//'k_atmos_frq' )
    !       deallocate ( k_temp, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Allocate//'k_temp' )
    !       deallocate ( k_atmos, stat=status )
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
    !         & MLSMSG_Allocate//'k_atmos' )
    !       deallocate ( My_Catalog, stat=status)
    !       if ( status /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !         & MLSMSG_Allocate//'My_catalog' )

    !       call deallocate_test ( radiances, 'Radiances', ModuleName )
    !       call deallocate_test ( i_star_all, 'i_star_all', ModuleName )
    !       call deallocate_test ( radv, 'rad_v', ModuleName )
    !       call deallocate_test ( grids, 'grids',  ModuleName )

    !     else
    !       if ( toggle(emit) .and. levels(emit) > 0 ) &
    !         & call output ( 'This MAF skipped as in overlap region', advance='yes' )
    !     endif ! --------------------------- Possible skip of this major frame

    !     if ( maf == noMAFs ) fmStat%finished = .true.

    !     deallocate(tan_inds,STAT=i)
d1550 2
a1551 2
    !     call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    !     call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )
d1553 2
a1554 2
    !     if ( .not. fwdModelConf%do_freq_avg ) call deallocate_test ( &
    !       & frequencies, "frequencies", ModuleName )
d1556 1
a1556 1
    !     if ( toggle(emit) ) call trace_end ( 'ForwardModel' )
a1562 3
! Revision 1.5.2.6  2001/09/07 22:34:21  zvi
! change comments..
!
@


1.5.2.8
log
@Starting to import codes
@
text
@d3 1
a3 1
 
d5 1
a5 1
 
d53 1
a53 1
 
d55 1
a55 1
 
d59 1
a59 1
 
d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.7 2001/09/07 22:49:10 livesey Exp $"
d67 1
a67 1
 
d69 1
a69 1
 
d73 2
a74 2
 
 
d76 1
a76 1
 
d84 1
a84 1
 
d86 1
a86 1
 
d88 1
a88 1
 
d90 1
a90 1
 
d95 1
a95 1
 
d98 1
a98 1
 
d100 1
a100 1
 
d102 1
a102 1
 
d105 1
d118 1
a118 1
 
d146 1
a146 1
 
d152 1
a152 1
 
d158 1
a158 1
 
d160 1
a160 1
 
d177 1
a177 1
 
d180 1
a180 1
 
d182 1
a182 1
 
d185 1
a185 1
 
d190 1
a190 1
 
d194 1
a194 1
 
d196 1
a196 1
 
d211 1
a211 1
 
d213 1
a213 1
    !
d217 2
a218 2
 
    !     integer(ip) ::  no_ss
d222 3
a224 3
 
    integer, parameter :: NGP1=NG+1     ! NG + 1
 
d236 4
a239 19
    integer :: NO_SS                    ! Number of sub-surface poitings
    integer :: I                        ! Loop index and other uses ..
    integer :: J                        ! Loop index and other uses ..
    integer :: K                        ! Loop index and other uses ..
 
    integer, allocatable :: EXT_IND_C(:) ! Indecies on coarse grid
    integer, allocatable :: TAN_INDS(:)  ! Index of tangent grid into gl grid
!   ,gl_indgen(:,:),gl_inds(:)
 
    type (VectorValue_T), pointer :: EARTHREFL     ! Earth reflectivity
    real(r8) :: E_RFLTY       ! Earth reflectivity at given tan. point
    real(r8) :: NEG_TAN_HT    ! GP Height (in KM.) of tan. press. below surface
    real(r8) :: PHI_TAN       ! Phi at tanget point for given pointing
 
    real(r8), dimension(:), allocatable :: Z_PATH    ! Zeta on path
    real(r8), dimension(:), allocatable :: P_PATH    ! Pressure on path
 
 
 
d242 2
a243 2
 
 
d245 1
a245 1
 
d247 1
a247 1
 
d249 1
a249 1
 
d251 1
a251 1
 
d254 1
a254 1
 
d257 1
a257 1
 
d259 1
a259 1
 
d261 1
a261 1
 
d266 1
a266 1
 
d268 1
a268 1
 
d270 1
a270 1
 
d273 1
a273 1
 
d276 1
a276 1
 
d281 1
a281 1
 
d287 1
a287 1
 
d293 1
a293 1
 
d295 1
a295 1
 
d297 5
a301 5
          neg_tan_ht = temp%values(1,?) * &
          &  (fwdModelConf%tangentGrid%surfs(ptg_i) - z_glgrid(1)) / 14.8_rp
          e_rflty = earthRefl%values(1,1)
 
          if(FwdModelConf%temp_der) then
d304 4
a307 6
              &  temp%template%geodLat(windowStart:windowFinish)*Deg2Rad,    &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &                   &
d316 2
a317 2
              &  T_FMI%t_geod_lat(windowStart:windowFinish)*Deg2Rad,z_glgrid,h_glgrid(:,windowStart:windowFinish), &
              &  t_glgrid(:,windowStart:windowFinish),dhdz_glgrid(:,windowStart:windowFinish),                     &
d329 2
a330 2
              &  T_FMI%t_geod_lat(windowStart:windowFinish)*Deg2Rad,z_glgrid,h_glgrid(:,windowStart:windowFinish), &
              &  t_glgrid(:,windowStart:windowFinish),dhdz_glgrid(:,windowStart:windowFinish),                     &
d341 2
a342 2
              &  T_FMI%t_geod_lat(windowStart:windowFinish)*Deg2Rad,z_glgrid,h_glgrid(:,windowStart:windowFinish), &
              &  t_glgrid(:,windowStart:windowFinish),dhdz_glgrid(:,windowStart:windowFinish),                     &
d348 1
a348 1
 
d362 1
a362 1
 
d368 1
a368 1
 
d377 1
a377 1
 
d380 1
a380 1
 
d384 1
a384 1
 
d392 1
a392 1
 
d395 1
a395 1
 
d399 1
a399 1
 
d407 1
a407 1
 
d412 1
a412 1
 
d419 1
a419 1
 
d427 1
a427 1
 
d435 1
a435 1
 
d441 1
a441 1
 
d444 2
a445 2
 
 
d447 1
a447 1
 
d450 1
a450 1
 
d452 1
a452 1
 
d454 1
a454 1
 
d456 1
a456 1
 
d458 1
a458 1
 
d460 1
a460 1
 
d462 1
a462 1
 
d465 1
a465 1
 
d467 1
a467 1
 
d469 1
a469 1
 
d471 1
a471 1
 
d474 1
a474 1
 
d476 1
a476 1
 
d478 48
a525 48
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
d527 1
a527 1
 
d531 1
a531 1
 
d536 1
a536 1
 
d540 1
a540 1
 
d551 1
a551 1
 
d555 1
a555 1
 
d577 1
a577 1
 
d582 1
a582 1
 
d597 1
a597 1
 
d599 1
a599 1
 
d602 1
a602 1
 
d609 1
a609 1
 
d613 1
a613 1
 
d626 1
a626 1
 
d635 1
a635 1
 
d701 1
a701 1
 
d707 1
a707 1
 
d711 1
a711 1
 
d713 1
a713 1
 
d728 1
a728 1
 
d754 1
a754 1
 
d757 1
a757 1
 
d760 1
a760 1
 
d763 2
a764 2
 
 
d780 1
a780 1
 
d784 1
a784 1
 
d788 1
a788 1
 
d791 1
a791 1
 
d794 1
a794 1
 
d810 1
a810 1
 
d813 1
a813 1
 
d816 3
a818 2
    !       i = nlvl - 1
    !       allocate(xm(i),ym(i),zgx(Ngp1),STAT=j)
d824 1
a824 1
    !       xm(1:i) = 0.5_rp * ( &
d826 2
a827 2
    !                    &   FwdModelConf%integrationGrid%surfs(1:i) )
    !       ym(1:i) = 0.5_rp * ( &
d829 1
a829 1
    !                    &   FwdModelConf%integrationGrid%surfs(1:i) )
d831 1
a831 1
    !                             &   spread(ym,1,Ngp1) * spread(zGx,2,i)), &
d835 1
a835 1
    !       deallocate(xm,ym,zgx,STAT=j)
d850 1
a850 1
 
d860 1
a860 1
 
d862 1
a862 1
 
d900 1
a900 1
 
d902 1
a902 1
 
d904 1
a904 1
 
d907 1
a907 1
 
d915 1
a915 1
 
d917 1
a917 1
 
d952 1
a952 1
 
d961 1
a961 1
 
d963 1
a963 1
 
d969 1
a969 1
 
d972 1
a972 1
 
d976 1
a976 1
 
d987 1
a987 1
 
d994 1
a994 1
 
d999 1
a999 1
 
d1012 1
a1012 1
 
d1025 1
a1025 1
 
d1028 1
a1028 1
 
d1037 1
a1037 1
 
d1043 1
a1043 1
 
d1052 1
a1052 1
 
d1060 1
a1060 1
 
d1065 1
a1065 1
 
d1074 1
a1074 1
 
d1076 1
a1076 1
 
d1079 1
a1079 1
 
d1103 1
a1103 1
 
d1105 1
a1105 1
 
d1109 1
a1109 1
 
d1111 1
a1111 1
 
d1114 1
a1114 1
 
d1121 1
a1121 1
 
d1130 1
a1130 1
 
d1133 1
a1133 1
 
d1144 1
a1144 1
 
d1147 1
a1147 1
 
d1167 1
a1167 1
 
d1176 1
a1176 1
 
d1178 1
a1178 1
 
d1184 1
a1184 1
 
d1196 1
a1196 1
 
d1205 1
a1205 1
 
d1207 1
a1207 1
 
d1211 1
a1211 1
 
d1219 1
a1219 1
 
d1221 1
a1221 1
 
d1223 1
a1223 1
 
d1236 1
a1236 1
 
d1241 1
a1241 1
 
d1249 1
a1249 1
 
d1251 1
a1251 1
 
d1261 1
a1261 1
 
d1268 1
a1268 1
 
d1292 1
a1292 1
 
d1294 1
a1294 1
 
d1297 1
a1297 1
 
d1315 1
a1315 1
 
d1356 1
a1356 1
 
d1358 1
a1358 1
 
d1360 1
a1360 1
 
d1362 1
a1362 1
 
d1376 1
a1376 1
 
d1379 1
a1379 1
 
d1381 1
a1381 1
 
d1383 1
a1383 1
 
d1386 1
a1386 1
 
d1412 1
a1412 1
 
d1422 1
a1422 1
 
d1457 1
a1457 1
 
d1497 1
a1497 1
 
d1500 1
a1500 1
 
d1502 1
a1502 1
 
d1505 1
a1505 1
 
d1515 1
a1515 1
 
d1530 1
a1530 1
 
d1532 1
a1532 1
 
d1542 1
a1542 1
 
d1553 1
a1553 1
 
d1559 1
a1559 1
 
d1566 1
a1566 1
 
d1568 1
a1568 1
 
d1575 1
a1575 1
 
d1586 1
a1586 1
 
d1604 1
a1604 1
 
d1606 1
a1606 1
 
d1608 1
a1608 1
 
d1612 1
a1612 1
 
d1617 1
a1617 1
 
d1619 2
a1620 2
 
 
d1628 1
a1628 1
 
d1637 1
a1637 1
 
d1645 1
a1645 1
 
d1653 1
a1653 1
 
d1660 1
a1660 1
 
d1671 1
a1671 1
 
d1688 1
a1688 1
 
d1692 1
a1692 1
 
d1696 1
a1696 1
 
d1703 1
a1703 1
 
d1706 1
a1706 1
 
d1712 1
a1712 1
 
d1725 1
a1725 1
 
d1730 1
a1730 1
 
d1735 1
a1735 1
 
d1737 1
a1737 1
 
d1739 1
a1739 1
 
d1742 1
a1742 1
 
d1745 1
a1745 1
 
d1747 1
a1747 1
 
d1749 1
a1749 1
 
a1752 3
! Revision 1.5.2.7  2001/09/07 22:49:10  livesey
! Very intermediate
!
a1781 1
 
@


1.5.2.9
log
@Sent to zvi
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.8 2001/09/08 21:41:14 zvi Exp $"
a221 4

    character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "


a224 19
    integer :: F_LEN                    ! Total number of f's
    integer :: H2O_IND                  ! Index of h2o inside f array
    integer :: I                        ! Loop index and other uses ..
    integer :: J                        ! Loop index and other uses ..
    integer :: K                        ! Loop index and other uses ..
    integer :: MAXVERT                  ! Number of points in gl grid
    integer :: N2LVL                    ! 2*nLvl
    integer :: NLVL                     ! Size of tangent grid
    integer :: NO_ELE                   ! Length of a gl path
    integer :: NO_SS                    ! Number of sub-surface poitings
    integer :: NPC                      ! Length of coarse path
    integer :: N_DN_PHI                 ! Number of phi's for all n's (spectroscopy)
    integer :: N_DN_ZETA                ! Number of zetas for all n's (spectroscopy)
    integer :: N_DV_PHI                 ! Number of phi's for all v's (spectroscopy)
    integer :: N_DV_ZETA                ! Number of zetas for all v's (spectroscopy)
    integer :: N_DW_PHI                 ! Number of phi's for all w's (spectroscopy)
    integer :: N_DW_ZETA                ! Number of zetas for all w's (spectroscopy)
    integer :: N_F_PHI                  ! Number of phis for all f's
    integer :: N_F_ZETA                 ! Number of zetas for all f's
d230 9
a238 22

    integer, dimension(:), pointer :: NO_Z ! Number of z components (noSpecies)
    integer, dimension(:), pointer :: NO_PHI ! Number of phi components (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DW ! no. z compts. for w derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DW ! no. phi compts. for w derivative (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DN ! no. z compts. for n derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DN ! no. phi compts. for n derivative (noSpecies)
    integer, dimension(:), pointer :: NO_Z_DV ! no. z compts. for v derivative (noSpecies)
    integer, dimension(:), pointer :: NO_PHI_DV ! no. phi compts. for v derivative (noSpecies)

    logical, dimension(:), pointer :: LIN_LOG ! Is this vmr on a log basis? (noSpecies)

    
    real(rp), dimension(:), pointer :: Z_BASIS ! zeta basis per species (n_f_zeta)
    real(rp), dimension(:), pointer :: PHI_BASIS ! phi basis per species (n_f_phi)
    real(rp), dimension(:), pointer :: Z_BASIS_DW ! zeta basis for dw (n_dw_z)
    real(rp), dimension(:), pointer :: PHI_BASIS_DW ! phi basis per species (n_dw_phi)
    real(rp), dimension(:), pointer :: Z_BASIS_DN ! zeta basis for dw (n_dn_z)
    real(rp), dimension(:), pointer :: PHI_BASIS_DN ! phi basis per species (n_dn_phi)
    real(rp), dimension(:), pointer :: Z_BASIS_DV ! zeta basis for dw (n_dv_z)
    real(rp), dimension(:), pointer :: PHI_BASIS_DV ! phi basis per species (n_dv_phi)
    real(rp), dimension(:), pointer :: SPS_VALUES ! all vmrs (f_len)
d244 1
a244 14
    type (VectorValue_T), pointer :: EARTHREFL ! Earth reflectivity
    type (VectorValue_T), pointer :: ELEVOFFSET ! Elevation offset
    type (VectorValue_T), pointer :: FIRSTRADIANCE ! Radiance qty for first signal
    type (VectorValue_T), pointer :: LOSVEL ! Line of sight velocity
    type (VectorValue_T), pointer :: ORBINCLINE ! Orbital inclination
    type (VectorValue_T), pointer :: PTAN ! Tangent pressure component of state vector
    type (VectorValue_T), pointer :: REFGPH ! Reference geopotential height
    type (VectorValue_T), pointer :: SCGEOCALT ! S/C geocentric altitude /m
    type (VectorValue_T), pointer :: SIDEBANDRATIO ! The sideband ratio to use
    type (VectorValue_T), pointer :: SPACERADIANCE ! Emission from space
    type (VectorValue_T), pointer :: TEMP ! Temperature component of state vector

    type (Signal_T) :: FIRSTSIGNAL   ! The first signal we're dealing with
    
d252 2
d256 2
a257 3
  
    if ( toggle(emit) ) call trace_begin ( 'ForwardModel' )
    
d259 1
a259 62
  
    ! Identify the vector quantities we're going to need.
    ! The key is to identify the signal we'll be working with first
    firstSignal = fwdModelConf%signals(1)
    
    ! Now make sure all the signals we're dealing with are same module,
    ! radiometer and sideband.
    if ( any( fwdModelConf%signals%sideband .ne. &
      & firstSignal%sideband ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config")
    if ( any( fwdModelConf%signals%radiometer .ne. &
      & firstSignal%radiometer ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed radiometers in forward model config")
    
    ! Now from that we identify the radiance quantity we'll be outputting
    firstRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
      & signal=firstSignal%index, sideband=firstSignal%sideband )
    
    ! Identify the appropriate state vector components, save vmrs for later
    temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature )
    ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, instrumentModule=firstSignal%instrumentModule )
    elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_elevOffset, radiometer=firstSignal%radiometer )
    orbIncline => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_orbitInclination )
    spaceRadiance => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_spaceRadiance )
    earthRefl => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_earthRefl )
    refGPH => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_refGPH )
    losVel => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_losVel, instrumentModule=firstSignal%instrumentModule )
    scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_scGeocAlt )
    sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= firstSignal%index, noError=.true. )
    
    ! We won't seek for molecules here as we can't have an array of pointers.
    ! When we do want molecule i we would do something like
    ! vmr => GetVectorQuantityBytype (fwdModelIn, fwdModelExtra, &
    !   quantityType=l_vmr, molecule=fwdModelConf.molecules(i))
    
    ! Now we're going to validate the quantities we've been given, don't forget
    ! we already know what their quantityType's are as that's how we found them
    !, so we don't need to check that.
    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
      & ModuleName, InvalidQuantity//'ptan' )
    if ( .not. ValidateVectorQuantity(elevOffset, verticalCoordinate=(/l_none/), &
      & frequencyCoordinate=(/l_none/), noInstances=(/1/)) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & InvalidQuantity//'elevOffset' )
    ! There will be more to come here.

a274 7
    Call load_sps_data ( fwdModelIn, fwdModelExtra, fwdModelConf%molecules, &
      f_len, n_f_phi, n_f_zeta, &
      h2o_ind, no_z, no_phi, lin_log, z_basis, phi_basis, sps_values, &
      n_dw_phi, n_dw_zeta, n_dn_phi, n_dn_zeta, n_dv_phi, n_dv_zeta, &
      no_z_dw, no_phi_dw, no_z_dn, no_phi_dn, no_z_dv, no_phi_dv, &
      z_basis_dw, phi_basis_dw, z_basis_dn, phi_basis_dn, z_basis_dv,phi_basis_dv )
 
a280 26
    ! Work out the dimensions of it
    NLm1 = nlvl - 1
    Ngp1 = Ng + 1

    ! Allocate GL grid stuff
    call Allocate_test ( xm, NLm1, 'xm', ModuleName )
    call Allocate_test ( ym, NLm1, 'ym', ModuleName )
    call Allocate_test ( zgx, Ngp1, 'zgx', ModuleName )

    ! From the selected integration grid pressures define the GL pressure
    ! grid:
    zGx(1) = -1.0_rp
    zGx(2:Ngp1) = Gx(1:Ng)
    xm(1:NLm1) = 0.5_rp * ( &
      &   FwdModelConf%integrationGrid%surfs(2:nlvl) + &
      &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    ym(1:NLm1) = 0.5_rp * ( &
      &   FwdModelConf%integrationGrid%surfs(2:nlvl) - &
      &   FwdModelConf%integrationGrid%surfs(1:NLm1) )
    ifm%z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
      &   spread(ym,1,Ngp1) * spread(zGx,2,NLm1)), &
      &  (/maxVert-1/))
    ifm%z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
    p_glgrid = 10.0_rp**(-ifm%z_glgrid)
    deallocate(xm,ym,zgx,STAT=i)

a281 31

    ! Insert into bill's 2d hydrostatic equation.
    ! The phi input for this program are the orbit plane projected
    ! geodetic locations of the temperature phi basis--not necessarily
    ! the tangent phi's which may be somewhat different.

    call two_d_hydrostatic(temp%template%surfs(:,1), &
      &  temp%template%geodLat*Deg2Rad,   &
      &  temp%values, &
      &  spread(refGPH%template%surfs(1,1),1,noMAFs),&
      &  0.001*refGPH%values(1,:),  &
      &  ifm%z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
      &  ifm%t_glgrid,ifm%h_glgrid,ifm%dhdz_glgrid, &
      &  ifm%dh_dt_glgrid)
    
    call allocate_test ( tan_inds, no_tan_hts, 'tan_inds', ModuleName )
    do k = 1, no_tan_hts
      Zeta = fwdModelConf%tangentGrid%surfs(k)
      call Hunt_zvi(Zeta,ifm%z_glgrid-0.0001_rp,maxVert,i,j)
      tan_inds(k) = i
    end do
    no_ss = count(tan_inds == 1) - 1
    FwdModelConf%SurfaceTangentIndex = no_ss + 1
    fmStat%newHydros = .false.

    ! Load species data





d323 1
a323 1
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
d332 2
a333 4
              &  T_FMI%t_geod_lat(windowStart:windowFinish)*Deg2Rad, &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish), &
              &  t_glgrid(:,windowStart:windowFinish), &
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
d445 1
a445 1
          allocate(k_atmos_frq(1:no_frq_on_ptg_i,1:f_len),STAT=ier)
d924 1
a924 1
    !         &     no_coeffs_f,no_phi_f,f_len,n_sv_phi,n_sv_zeta,   &
a1767 3
! Revision 1.5.2.8  2001/09/08 21:41:14  zvi
! Starting to import codes
!
@


1.5.2.10
log
@More updates
@
text
@d6 1
a6 1
  use GLNP, only: NG, GX
d52 1
a52 1
  use ManipulateVectorQuantities, only: FindOneClosestInstance
d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.9 2001/09/08 23:11:23 livesey Exp $"
d236 1
a236 2
    integer :: NLVL                     ! Size of integration grid
    integer :: NLM1                     ! NLVL - 1
a274 5
    real(rp), dimension(:), pointer :: XM ! Midpoint of integration grid intervals
    real(rp), dimension(:), pointer :: YM ! Half length of integration grid intervals
    real(rp), dimension(:), pointer :: ZGX ! Gauss weights (with -1 at front)
    real(r8), dimension(:), pointer :: p_glgrid ! Pressure on glGrid surfs
    real(r8), dimension(:), pointer :: z_glgrid ! Zeta on glGrid surfs
a326 2
    ! Start sorting out stuff from state vector ------------------------------
 
d369 2
a370 5
    ! Work out the `window' stuff for temperature.
    mafTInstance = FindOneClosestInstance ( temp, firstRadiance, fmc%maf )
    windowStart  = max(1, mafTInstance - phiWindow/2)
    windowFinish = min(mafTInstance + phiWindow/2, no_phi_t)

d390 2
a391 1
  
d399 1
a405 5
    call Allocate_test ( z_glGrid, maxVert, 'z_glGrid', ModuleName )
    call Allocate_test ( p_glGrid, maxVert, 'z_glGrid', ModuleName )

    call Allocate_test ( h_glGrid, maxVert, 'z_glGrid', ModuleName )

d416 1
a416 1
    z_glgrid(1:maxVert-1) = reshape ((spread(xm,1,Ngp1) +          &
d419 3
a421 6
    z_glgrid(maxVert) = FwdModelConf%integrationGrid%surfs(nlvl)
    p_glgrid = 10.0_rp**(z_glgrid)

    call Deallocate_test ( xm, 'xm', ModuleName )
    call Deallocate_test ( ym, 'ym', ModuleName )
    call Deallocate_test ( zgx,'zgx', ModuleName )
d435 3
a437 3
      &  z_glgrid,orbIncline%values(1,1)*Deg2Rad,    &
      &  t_glgrid, h_glgrid, dhdz_glgrid, &
      &  dh_dt_glgrid )
d667 1
a667 4

    call Deallocate_test ( z_glGrid, 'z_glGrid', ModuleName )
    call Deallocate_test ( p_glGrid, 'z_glGrid', ModuleName )
    
a1942 3
! Revision 1.5.2.9  2001/09/08 23:11:23  livesey
! Sent to zvi
!
@


1.5.2.11
log
@Another intermediate
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.10 2001/09/08 23:47:52 livesey Exp $"
a233 1
    integer :: MAFTINSTANCE             ! Temperature instance closest to this MAF
d239 1
a248 4
    integer :: N_T_PHI                  ! Number of phis for temperature
    integer :: N_T_ZETA                 ! Number of zetas for temperature
    integer :: NO_TAN_HTS               ! Number of tangent heights
    integer :: PHIWINDOW                ! From fwdMdlConfig
a252 1
    integer :: SURFACETANGENTINDEX      ! Index in tangent grid of earth's surface
a253 2
    integer :: WINDOWSTART              ! Start of temperature `window'
    integer :: WINDOWFINISH             ! End of temperature `window'
a376 5
    ! Sort out some important dimensions
    no_t_phi = temp%template%noInstances
    no_t_zeta = temp%template%noSurfs
    no_tan_hts = fwdModelConf%tangentGrid%noSurfs

d378 1
a378 2
    phiWindow = fwdModelConf%phiWindow
    mafTInstance = FindOneClosestInstance ( temp, firstRadiance, fmStat%maf )
d380 1
a380 1
    windowFinish = min(mafTInstance + phiWindow/2, temp%template%noInstances)
d457 8
a464 4
    call Hunt ( z_glgrid-0.0001_rp, &
      & fwdModelConf%tangentGrid%surfs, &
      & tan_inds, allowTopValue=.true. )
    surfaceTangentIndex = count ( tan_inds == 1 ) 
d500 1
a500 1
        if (ptg_i < surfaceTangentIndex) then
a1962 3
! Revision 1.5.2.10  2001/09/08 23:47:52  livesey
! More updates
!
@


1.5.2.12
log
@more metric work
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.11 2001/09/09 00:09:15 livesey Exp $"
a233 1
    integer :: MAF                      ! MAF under consideration
d273 1
d307 3
a309 7
    real(rp) :: E_RFLTY       ! Earth reflectivity at given tan. point
    real(rp) :: NEG_TAN_HT    ! GP Height (in KM.) of tan. press. below surface
    real(rp) :: PHI_TAN       ! Phi at tanget point for given pointing
    real(rp) :: REQ           ! Equivalent Earth Radius

    REAL(rp), ALLOCATABLE :: one_tan_temp(:)
    REAL(rp), ALLOCATABLE :: one_tan_ht(:)
d311 2
a312 2
    real(rp), dimension(:), allocatable :: Z_PATH    ! Zeta on path
    real(rp), dimension(:), allocatable :: P_PATH    ! Pressure on path
a387 1
    MAF = fmStat%maf
d391 1
a391 1
    mafTInstance = FindOneClosestInstance ( temp, firstRadiance, maf )
d393 1
a393 1
    windowFinish = min(mafTInstance + phiWindow/2, no_t_phi)
a405 2

    ALLOCATE(one_tan_ht(1),one_tan_temp(1))
d475 6
d513 1
a513 4
          phi_tan = firstRadiance%template%phi(1,MAF)
!
! *** This is where we will interpolate Phi_tan
! 
d526 1
a526 1
              &  Z_BASIS = temp%template%surfs,ETA_ZXP=eta_zxp_t(1:no_ele,:),&
a1971 3
! Revision 1.5.2.11  2001/09/09 00:09:15  livesey
! Another intermediate
!
@


1.5.2.13
log
@Allocatios ..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.12 2001/09/09 00:43:34 zvi Exp $"
a483 37

 ! First, Allocate gl_slab arrays....

    no_ele = 2*maxVert     ! maximum possible
    ALLOCATE(gl_slabs(no_ele,NOSPECIES))

    DO i = 1, NOSPECIES
      nl = Size(My_Catalog(i)%Lines)
      gl_slabs(1:no_ele,i)%no_lines = nl
      DO j = 1, no_ele
        ALLOCATE(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
            &    gl_slabs(j,i)%y(nl),gl_slabs(j,i)%yi(nl),   &
            &    gl_slabs(j,i)%slabs1(nl),                   &
            &    gl_slabs(j,i)%dslabs1_dv0(nl) )
      END DO
    END DO
!
    IF(FwdModelConf%temp_de) THEN
      ALLOCATE(gl_slabs_p(no_ele,NOSPECIES), &
            &  gl_slabs_m(no_ele,NOSPECIES), STAT=ier)
      DO i = 1, NOSPECIES
        nl = Size(My_Catalog(i)%Lines)
        gl_slabs_m(1:no_ele,i)%no_lines = nl
        gl_slabs_p(1:no_ele,i)%no_lines = nl
        DO j = 1, no_ele
          ALLOCATE(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
              &    gl_slabs_p(j,i)%y(nl),gl_slabs_p(j,i)%yi(nl),   &
              &    gl_slabs_p(j,i)%slabs1(nl),                     &
              &    gl_slabs_p(j,i)%dslabs1_dv0(nl),                &
              &    gl_slabs_m(j,i)%v0s(nl),gl_slabs_m(j,i)%x1(nl), &
              &    gl_slabs_m(j,i)%y(nl),gl_slabs_m(j,i)%yi(nl),   &
              &    gl_slabs_m(j,i)%slabs1(nl),                     &
              &    gl_slabs_m(j,i)%dslabs1_dv0(nl) )
        END DO
      END DO
    ENDIF
!
a1975 3
! Revision 1.5.2.12  2001/09/09 00:43:34  zvi
! more metric work
!
@


1.5.2.14
log
@More work
@
text
@d7 1
a7 1
  use MLSCommon, only: I4, R4, R8, RP, IP, FINDFIRST
d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.13 2001/09/09 01:41:58 zvi Exp $"
a228 1
    integer :: CHANNEL                  ! A Loop counter
a252 2
    integer :: NOSPECIES                ! Number of molecules under consideration
    integer :: NOUSEDCHANNELS           ! How many channels are we considering
a257 1
    integer :: SIGIND                   ! Signal index, loop counter
a270 2
    integer, dimension(:), pointer :: USEDCHANNNELS ! Which channel is this
    integer, dimension(:), pointer :: USEDSIGNALS ! Which signal is this channel from
a303 1
    type (VectorValue_T), pointer :: THISRADIANCE ! A radiance vector quantity
d389 2
a390 3
    noSpecies = size ( fwdModelConf%molecules )
    n_t_phi = temp%template%noInstances
    n_t_zeta = temp%template%noSurfs
d398 1
a398 27
    windowFinish = min(mafTInstance + phiWindow/2, n_t_phi)

    ! Work out which channels are used, also check we have radiances for them.
    noUsedChannels = 0
    do sigInd = 1, size(fwdModelConf%signals)
      thisRadiance => GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
        & signal=fwdModelConf%signals(sigInd)%index, sideband=firstSignal%sideband )
      if ( .not. ValidateVectorQuantity(thisRadiance, minorFrame=.true.,&
        & frequencyCoordinate=(/l_channel/)) ) call MLSMessage ( MLSMSG_Error, &
        & ModuleName, InvalidQuantity//'radiance' )
      noUsedChannels = noUsedChannels + &
        & count( fwdModelConf%signals(sigInd)%channels )
    end do
    call allocate_test ( usedChannels, noUsedChannels, &
      & 'usedChannels', ModuleName )
    call allocate_test ( usedSignals, noUsedChannels, &
      & 'usedSignals', ModuleName )
    channel = 1
    do sigInd = 1, size(fwdModelConf%signals)
      do i = 1, size(fwdModelConf%signals(sigInd)%frequencies)
        if (fwdModelConf%signals(sigInd)%channels(i)) then
          usedChannels(channel) = i
          usedSignals(channel) = sigInd
          channel = channel + 1
        end if
      end do
    end do
d401 5
a405 8
    allocate ( My_Catalog(noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog' )

    do j = 1, noSpecies
      Spectag = spec_tags(fwdModelConf%molecules(j))
      My_Catalog(j) = Catalog(FindFirst(catalog%spec_tag == spectag ) )
    end do
a523 4
      
      ! Work out which pointing frequency grid we're going to need if ----------
      ! frequency averaging
    
a716 2
        ! Work out which channel shape information we're going need ----------
 
a2012 3
! Revision 1.5.2.13  2001/09/09 01:41:58  zvi
! Allocatios ..
!
@


1.5.2.15
log
@more Allocatios ..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.14 2001/09/09 01:40:18 livesey Exp $"
a266 2
    type (slabs_struct), dimension(:,:), pointer :: gl_slabs

d538 1
a538 1
    IF(FwdModelConf%temp_der) THEN
a556 64

    ! Now allocate all path related... with maximum lenght..

    brkpt = maxVert
    npc = 2 * (brkpt + Ng) / Ngp1
!
! This can be put outside the mmaf loop

    ALLOCATE(z_path(1:no_ele),h_path(1:no_ele),phi_path(1:no_ele),  &
          &  t_path(1:no_ele),dhdz_path(1:no_ele), del_s(1:npc),    &
          &  n_path(1:npc),ext_ind_c(1:npc),ref_corr(1:npc),        &
          &  sps_path(1:no_ele,1:NOSPECIES),do_calc(1:no_ele,1:f_len), &
          &  do_gl(1:npc),incoptdepth(1:npc),path_dsdh(1:no_ele),   &
          &  tau(1:npc),t_script(1:npc),alpha_path_c(1:npc),        &
          &  beta_path_c(1:npc,1:NOSPECIES),p_path(1:no_ele),           &
          &  eta_zxp(1:no_ele,1:f_len))
!
    IF(FwdModelConf%temp_der) THEN
!
! Allocation for metrics routine when Temp. derivative is needed:
!
      sv_t_len = no_t_zeta*(windowFinish-windowStart+1)
      ALLOCATE(dh_dt_path(1:no_ele,sv_t_len),           &
           &   tan_dh_dt(1,1:no_t_zeta), &
           &   do_calc_t(1:no_ele,1:sv_t_len),          &
           &   do_calc_hyd(1:no_ele,1:sv_t_len),        &
           &   eta_zxp_t(1:no_ele,1:sv_t_len),          &
           &   dbeta_dt_path_c(1:npc,1:NOSPECIES),drad_dt(1:sv_t_len))
!
    ENDIF

    IF(FwdModelConf%spect_der) THEN
!
! Allocation when spectaral derivative are needed:
!
      ALLOCATE(dbeta_dw_path_c(1:npc,1:NOSPECIES))
      ALLOCATE(dbeta_dn_path_c(1:npc,1:NOSPECIES))
      ALLOCATE(dbeta_dv_path_c(1:npc,1:NOSPECIES))

      DO i = 1, NOSPECIES
        kz = no_z_dw(i)
        if(kz > 0) then
          sv_dw_len = kz * (windowFinish - windowStart + 1)
          ALLOCATE(do_calc_dw(1:no_ele,1:sv_dw_len), &
             &     eta_zxp_dw(1:no_ele,1:sv_dw_len), &
             &     drad_dw(1:sv_dw_len))
        endif
        kz = no_z_dn(i)
        if(kz > 0) then
          sv_dn_len = kz * (windowFinish - windowStart + 1)
          ALLOCATE(do_calc_dn(1:no_ele,1:sv_dn_len), &
             &     eta_zxp_dn(1:no_ele,1:sv_dn_len), &
             &     drad_dn(1:sv_dn_len))
        endif
        kz = no_z_dv(i)
        if(kz > 0) then
          sv_dv_len = kz * (windowFinish - windowStart + 1)
          ALLOCATE(do_calc_dv(1:no_ele,1:sv_dv_len), &
             &     eta_zxp_dv(1:no_ele,1:sv_dv_len), &
             &     drad_dv(1:sv_dv_len))
        endif
      END DO
!
    ENDIF
a2055 3
! Revision 1.5.2.14  2001/09/09 01:40:18  livesey
! More work
!
@


1.5.2.16
log
@Work
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.15 2001/09/09 01:57:41 zvi Exp $"
a236 1
    integer :: MAXSUPERSET              ! Max. value of superset
a263 1
    integer :: WHICHPOINTINGGRID        ! Index into the pointing grids
a266 3
    integer, dimension(1) :: WHICHPOINTINGGRIDASARRAY ! Result of minloc
    integer, dimension(:), pointer :: GRIDS ! Heights in ptgGrid for each tangent

a278 1
    integer, dimension(:), pointer :: SUPERSET ! Used for matching signals
a281 1
    real(r8), dimension(:), pointer :: FREQUENCIES ! What frequencies to compute for
d630 1
a630 62

      ! Code splits into two sections, one for when we're doing frequency
      ! averaging, and one when we're not.
      if ( fwdModelConf%do_freq_avg ) then ! --- Doing freq. avg. ---
        
        call allocate_test ( superset, size(pointingGrids), &
          & 'superset', ModuleName )
        do i = 1, size(pointingGrids)
          superset(i) = AreSignalsSuperset ( pointingGrids(i)%signals, &
            & fwdModelConf%signals, sideband=thisSideband )
        end do
        if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "No matching pointing frequency grids." )
        
        maxSuperset = maxval ( superset )
        where ( superset < 0 )
          superset = maxSuperset + 1
        end where
        whichPointingGridAsArray = minloc ( superset )
        whichPointingGrid = whichPointingGridAsArray(1)
        call deallocate_test ( superset, 'superset', ModuleName )
        
        if ( toggle(emit) ) then
          call output ( 'Using pointing frequency grid: ' )
          call output ( whichPointingGrid, advance='yes' )
        end if
        
        ! Now we've identified the pointing grids.  Locate the tangent grid
        ! within it.
        call allocate_test ( grids, FwdModelConf%TangentGrid%nosurfs, &
          "Grids", ModuleName )
        call Hunt ( PointingGrids(whichPointingGrid)%oneGrid%height, &
          & FwdModelConf%TangentGrid%surfs, grids, allowTopValue=.true. )
        
      else ! ------------------------- Not frequency averaging ---------
        
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_begin ( 'ForwardModel.NotFreqAvg' )
        
        call allocate_test ( frequencies,noUsedChannels, "frequencies", ModuleName )
        do channel = 1, noUsedchannels
          frequencies(channel) = &
            & fwdModelConf%signals(usedSignals(channel))%centerFrequency + &
            & fwdModelConf%signals(usedSignals(channel))% &
            &  frequencies(usedChannels(channel))
        end do
        select case ( thisSideband )
        case ( -1 )
          frequencies = firstSignal%lo - frequencies
        case ( +1 )
          frequencies = firstSignal%lo + frequencies
        case ( 0 )
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Folded signal requested in forward model' )
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Bad value of signal%sideband' )
        end select
        noFreqs = noUsedChannels
        if ( toggle(emit) .and. levels(emit) > 0 ) &
          & call trace_end ( 'ForwardModel.NotFreqAvg' )
      end if
a814 10

        ! If we're doing frequency averaging, get the frequencies we need for
        ! this pointing.
        if ( FwdModelConf%do_freq_avg ) then
          frequencies => PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
          noFreqs = size(frequencies)
        end if ! If not, we dealt with this outside the loop
        
        if(noFreqs > 1) tau(1:) = 1.0 !******* What is this

a2121 3
! Revision 1.5.2.15  2001/09/09 01:57:41  zvi
! more Allocatios ..
!
@


1.5.2.17
log
@more definirions ..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.16 2001/09/09 01:57:31 livesey Exp $"
a332 26
    real(rp), dimension(:), allocatable :: H_PATH    ! Heights on path
    real(rp), dimension(:), allocatable :: T_PATH    ! Temperatures on path
    real(rp), dimension(:), allocatable :: N_PATH    ! Refractivity on path
    real(rp), dimension(:), allocatable :: PHI_PATH  ! Phi's on path
    real(rp), dimension(:), allocatable :: DHDZ_PATH ! dH/dZ on path
    real(rp), dimension(:), allocatable :: DEL_S     ! Integration Intervals 
                                                     ! lenghts along the path
    real(rp), dimension(:), allocatable :: REF_CORR  ! Refraction correction
    real(rp), dimension(:), allocatable :: PATH_DSDH ! dS/dH on path

    real(rp), dimension(:,:), allocatable :: SPS_PATH  ! spsices on path
    real(rp), dimension(:,:), allocatable :: BETA_PATH  ! Beta on path
    real(rp), dimension(:,:), allocatable :: ETA_ZXP  ! Eta_z x Eta_p

    real(rp), dimension(:), allocatable :: TAU       ! Optical depth 
    real(rp), dimension(:), allocatable :: T_SCRIPT
    real(rp), dimension(:), allocatable :: INCOPTDEPTH  ! Incremental Optical 
                                                        ! depth 
    real(rp), dimension(:), allocatable :: ALPHA_PATH_C ! coarse grid Sing.


    integer,  dimension(:), allocatable :: EXT_IND_C

    logical,  dimension(:), allocatable :: DO_GL      ! GL indicator
    logical,  dimension(:,:), allocatable :: DO_CALC  ! 'Avoid zeros' indicator

a2199 3
! Revision 1.5.2.16  2001/09/09 01:57:31  livesey
! Work
!
@


1.5.2.18
log
@More..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.17 2001/09/09 02:18:03 zvi Exp $"
a695 6
        ! Work out the maximum number of frequencies
        maxNoFreqs = 0
        do ptg_i = 1, no_tan_hts
          maxNoFreqs = max ( maxNoFreqs, &
            & size (pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies) )
        end do
d699 3
d722 2
a723 1
        maxNoFreqs = noUsedChannels
a724 17

      call Allocate_test ( radv, maxNoFreqs, 'radV', ModuleName )

      if (fwdModelConf%tempDer) &
        & call Allocate_test ( k_temp_frq, maxNoFreqs, t_len, 'k_temp_frq', ModuleName )

      if (fwdModelConf%atmos_der) &
        & call Allocate_test ( k_atmos_frq, maxNoFreqs, f_len, 'k_atmos_frq', ModuleName )
 
      if(FMC%spect_der) then
        call Allocate_test ( k_spect_dw_frq ( maxNoFreqs, dw_len ), &
          & 'k_spect_dw_frq', ModuleName )
        call Allocate_test ( k_spect_dn_frq ( maxNoFreqs, dw_len ), &
          & 'k_spect_dn_frq', ModuleName )
        call Allocate_test ( k_spect_dv_frq ( maxNoFreqs, dw_len ), &
          & 'k_spect_dv_frq', ModuleName )
      endif
d867 40
a918 9
        ! Do a frequencies loop:
        ! allocate frequency dependent stuff here
        no_frq_on_ptg_i = 1
        if(FMC%do_frqavg) noFreqs = FMI%no_ptg_frq(ptg_i)
 
 
        ! Setup path quantities ----------------------------------------------
 

a2225 3
! Revision 1.5.2.17  2001/09/09 02:18:03  zvi
! more definirions ..
!
@


1.5.2.19
log
@more definitions ..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.18 2001/09/09 02:16:56 livesey Exp $"
d359 1
a359 41
!  Temperature related variables..

    integer :: SV_T_LEN         ! Number of t_phi*t_zeta in the window

    real(rp), dimension(:), allocatable :: DRAD_DT      ! dI/dT

    real(rp), dimension(:,:), allocatable :: DH_DT_PATH  ! dH/dT on path
    real(rp), dimension(:,:), allocatable :: TAN_DH_DT   ! dH/dT at Tangent
    real(rp), dimension(:,:), allocatable :: DBETA_DT_PATH_C ! dBeta_dt
                                                             ! on coarse grid
    real(rp), dimension(:,:), allocatable :: ETA_ZXP_T  ! Eta_t_z x Eta_t_p

    logical,  dimension(:,:), allocatable :: DO_CALC_T    ! 'Avoid zeros'
    logical,  dimension(:,:), allocatable :: DO_CALC_HYD  ! 'Avoid zeros'

!  Some more Spectroscopy derivatives related variables..

    integer ::  kz, sv_dw_len, sv_dn_len, sv_dv_len

    real(rp), dimension(:,:), allocatable :: eta_zxp_dw ! Eta_z x Eta_p for W
    real(rp), dimension(:,:), allocatable :: eta_zxp_dn ! Eta_z x Eta_p for N
    real(rp), dimension(:,:), allocatable :: eta_zxp_dv ! Eta_z x Eta_p for V

    logical,  dimension(:,:), allocatable :: DO_CALC_DW  ! 'Avoid zeros'
    logical,  dimension(:,:), allocatable :: DO_CALC_DN  ! 'Avoid zeros'
    logical,  dimension(:,:), allocatable :: DO_CALC_DV  ! 'Avoid zeros'

    real(rp), dimension(:,:), allocatable :: DBETA_DW_PATH_C ! dBeta_dw on 
                                                             ! coarse grid
    real(rp), dimension(:,:), allocatable :: DBETA_DN_PATH_C ! dBeta_dn on 
                                                             ! coarse grid
    real(rp), dimension(:,:), allocatable :: DBETA_DV_PATH_C ! dBeta_dv on 
                                                             ! coarse grid

    real(rp), dimension(:,:), allocatable :: DBETA_DW_PATH_F ! dBeta_dw on 
                                                             ! fine grid
    real(rp), dimension(:,:), allocatable :: DBETA_DN_PATH_F ! dBeta_dn on 
                                                             ! fine grid
    real(rp), dimension(:,:), allocatable :: DBETA_DV_PATH_F ! dBeta_dv on 
                                                             ! fine grid

a2213 3
! Revision 1.5.2.18  2001/09/09 02:16:56  livesey
! More..
!
@


1.5.2.20
log
@more definitions ..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.19 2001/09/09 02:42:52 zvi Exp $"
a364 2
    real(rp), allocatable :: DH_DT_GLGRID(:,:,:)

d832 1
a832 1
              &  temp%template%geodLat(windowStart:windowFinish)*Deg2Rad,    &
d836 2
a837 2
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
d844 1
a844 1
          if(FwdModelConf%temp_der) then
d847 4
a850 6
              &  temp%template%geodLat(windowStart:windowFinish)*Deg2Rad,    &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
d859 4
a862 6
              &  temp%template%geodLat(windowStart:windowFinish)*Deg2Rad,    &
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
              &  dhdz_glgrid(:,windowStart:windowFinish),                    &
              &  orbIncline%values(1,1)*Deg2Rad,h_path(1:no_ele),            &
              &  phi_path(1:no_ele),t_path(1:no_ele),dhdz_path(1:no_ele),    &
d868 1
a868 1
        if(FwdModelConf%spect_der) then
d918 1
a918 1
        if(FwdModelConf%temp_der) then
a2253 3
! Revision 1.5.2.19  2001/09/09 02:42:52  zvi
! more definitions ..
!
@


1.5.2.21
log
@More
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.20 2001/09/09 03:02:53 zvi Exp $"
d944 6
a2259 3
! Revision 1.5.2.20  2001/09/09 03:02:53  zvi
! more definitions ..
!
@


1.5.2.22
log
@End of working day (ha ha!)
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.21 2001/09/09 03:03:25 livesey Exp $"
d232 1
a232 2
    integer :: I                        ! Loop index and other uses .
    integer :: IER                      ! Status flag from allocates
a256 1
    integer :: NL                       ! Number of lines
a263 1
    integer :: SPECTAG                  ! A single spectag
a272 3
    type (slabs_struct), dimension(:,:), pointer :: gl_slabs_p
    type (slabs_struct), dimension(:,:), pointer :: gl_slabs_m
    type(catalog_T), dimension(:), pointer :: My_Catalog
d282 1
a282 1
    integer, dimension(:), pointer :: USEDCHANNELS ! Which channel is this
a344 1
    real(rp), dimension(:,:), allocatable :: BETA_PATH_C  ! Beta on path coarse
d354 1
d655 1
a655 1
      sv_t_len = n_t_zeta*(windowFinish-windowStart+1)
d657 1
a657 1
           &   tan_dh_dt(1,1:n_t_zeta), &
a2253 3
! Revision 1.5.2.21  2001/09/09 03:03:25  livesey
! More
!
@


1.5.2.23
log
@Cleaning up..
@
text
@d12 1
a12 2
! use REFRACTION_M, only: REFRACTION_CORRECTION
  USE REFRACTION_M, ONLY: REFRACTIVE_INDEX, COMP_REFCOR, PATH_DS_DH
d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.22 2001/09/09 03:16:48 livesey Exp $"
d222 1
a222 1
 
d224 2
a225 2
 
 
a236 1
    integer :: MAXNOFREQS               ! Used for sizing arrays
a243 3
    integer :: NOFREQS                  ! Number of frequencies for a pointing
    integer :: NOMAFS                   ! Number of major frames
    integer :: NOMIFS                   ! Number of minor frames
a254 1
    integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
d271 1
a271 1
 
d274 1
a274 1
 
d278 1
a279 2
    type(catalog_T), dimension(:), pointer :: My_Catalog
 
d291 1
a291 1
 
d293 1
a293 1
 
a308 8

    real(rp), dimension(:), pointer :: RadV

    real(r8), dimension(:,:), pointer :: PTG_ANGLES  ! (no_tan_hts,noMaf)

    real(r8), dimension(:,:), pointer :: h_glgrid    ! H on glGrid surfs
    real(r8), dimension(:,:), pointer :: t_glgrid    ! Temp on glGrid surfs
    real(r8), dimension(:,:), pointer :: dhdz_glgrid ! dH/dZ on glGrid surfs
d326 1
a326 1
 
d328 1
a328 1
 
d333 1
a333 3
    real(rp) :: DEL_TEMP      ! Temp. step-size in evaluation of Temp. power dep.
    real(rp) :: ELEV_OFFSET   ! Elevation offset
 
d344 1
a344 1
    real(rp), dimension(:), allocatable :: DEL_S     ! Integration Intervals
d348 1
a348 1
 
d353 2
a354 2
 
    real(rp), dimension(:), allocatable :: TAU       ! Optical depth
d356 2
a357 2
    real(rp), dimension(:), allocatable :: INCOPTDEPTH  ! Incremental Optical
                                                        ! depth
d359 3
a361 1
 
d364 1
a364 1
 
d366 1
a366 1
 
d368 1
a368 1
 
d370 1
a370 1
 
d372 1
a372 1
 
d378 1
a378 1
 
d381 1
a381 1
 
d383 1
a383 1
 
a384 8
 
    real(rp), dimension(:), allocatable :: DRAD_DW      ! dI/dW
    real(rp), dimension(:), allocatable :: DRAD_DN      ! dI/dN
    real(rp), dimension(:), allocatable :: DRAD_DV      ! dI/dV

    real(rp), dimension(:,:), pointer :: k_spect_dw_frq
    real(rp), dimension(:,:), pointer :: k_spect_dn_frq
    real(rp), dimension(:,:), pointer :: k_spect_dv_frq
d389 1
a389 1
 
d393 2
a394 2
 
    real(rp), dimension(:,:), allocatable :: DBETA_DW_PATH_C ! dBeta_dw on
d396 1
a396 1
    real(rp), dimension(:,:), allocatable :: DBETA_DN_PATH_C ! dBeta_dn on
d398 1
a398 1
    real(rp), dimension(:,:), allocatable :: DBETA_DV_PATH_C ! dBeta_dv on
d400 2
a401 2
 
    real(rp), dimension(:,:), allocatable :: DBETA_DW_PATH_F ! dBeta_dw on
d403 1
a403 1
    real(rp), dimension(:,:), allocatable :: DBETA_DN_PATH_F ! dBeta_dn on
d405 1
a405 1
    real(rp), dimension(:,:), allocatable :: DBETA_DV_PATH_F ! dBeta_dv on
a407 3
    real(r8), dimension(:,:), pointer :: k_temp_frq  ! Storage for Temp. deriv.
    real(r8), dimension(:,:), pointer :: k_atmos_frq ! Storage for Atmos deriv.
 
d410 1
a410 1
 
d412 1
a412 1
 
d414 1
a414 1
 
d418 1
a418 1
 
d429 1
a429 1
 
d433 1
a433 1
 
d457 1
a457 1
 
d462 1
a462 1
 
d477 1
a477 1
 
a483 5
    noMAFs = firstRadiance%template%noInstances
    noMIFs = firstRadiance%template%noSurfs

    !  Get some dimensions that we'll use a lot
    no_phi_t = temp%template%noInstances
d490 1
a490 1
 
d516 1
a516 1
 
d521 1
a521 1
 
d531 1
a531 1
 
d541 1
a541 1
 
d549 1
a549 1
 
d554 1
a554 1
 
d557 3
a559 7
 
    call allocate_test ( h_glgrid, maxVert, n_t_phi, 'h_glgrid', ModuleName )
    call allocate_test ( t_glgrid, maxVert, n_t_phi, 't_glgrid', ModuleName )
    call allocate_test ( dh_dt_glgrid, maxVert, n_t_phi, &
                      &  temp%template%noSurfs,'dh_dt_glgrid', ModuleName )
    call allocate_test ( dhdz_glgrid, maxVert, n_t_phi, 'dhdz_glgrid', ModuleName )
 
d575 1
a575 1
 
d579 1
a579 1
 
d581 1
a581 1
 
d586 1
a586 1
 
d595 1
a595 1
 
d600 2
a601 3
    surfaceTangentIndex = count ( tan_inds == 1 )
 
    elev_offset= 0.0_rp
d604 1
a604 1
 
d606 1
a606 1
 
d609 1
a609 1
 
d640 1
a640 1
 
d642 1
a642 1
 
d647 1
a647 1
 
d670 1
a670 1
 
d678 1
a678 1
 
a704 1
    call allocate_test ( ptg_angles, no_tan_hts, noMAFs, 'ptg_angles', ModuleName )
d708 1
a708 1
 
d711 1
a711 1
 
d715 1
a715 1
 
d724 1
a724 1
 
d732 1
a732 1
 
d737 1
a737 1
 
d750 1
a750 1
 
d752 1
a752 1
 
d775 1
a775 1
 
d777 4
a780 4
 
      if (fwdModelConf%temp_der) &
        & call Allocate_test (k_temp_frq,maxNoFreqs,sv_t_len,'k_temp_frq',ModuleName )
 
d784 2
a785 2
      if (fwdModelConf%spect_der) then
        call Allocate_test ( k_spect_dw_frq ( maxNoFreqs, sv_dw_len ), &
d787 1
a787 1
        call Allocate_test ( k_spect_dn_frq ( maxNoFreqs, sv_dn_len ), &
d789 1
a789 1
        call Allocate_test ( k_spect_dv_frq ( maxNoFreqs, sv_dv_len ), &
d816 1
a816 2
          k = (windowStart + windowFinish) / 2
          neg_tan_ht = temp%values(1,k) * &
d822 1
a822 1
!
d864 1
a864 1
              &  Z_BASIS = temp%template%surfs,ETA_ZXP=eta_zxp_t(1:no_ele,:),&
d891 1
a891 1
        tan_temp(ptg_i,maf) = one_tan_temp(1)
d908 2
a909 2
        call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2), &
          &  one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf))
d927 3
a929 3
        call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
          &   t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs,no_ele,del_temp)

d932 4
a935 4
          call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
            & t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_p,no_ele,del_temp)
          call get_gl_slabs_arrays(my_Catalog,p_path(1:no_ele), &
            & t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_m,no_ele,-del_temp)
d940 1
a940 1
 
d947 1
a947 1
 
d949 1
a949 1
 
d952 1
a952 1
 
d981 1
a981 1
 
d984 1
a984 1
 
d1213 1
d1225 1
a1225 1
    !       print*,'n_t_phi:',n_t_phi
a2259 3
! Revision 1.5.2.22  2001/09/09 03:16:48  livesey
! End of working day (ha ha!)
!
d2334 1
@


1.5.2.24
log
@Cleanup..comp_path_entities_m.f90
@
text
@d9 4
a12 2
  USE COMP_SPS_PATH_M, only: COMP_SPS_PATH
  USE EVAL_SPECT_PATH_M, only: EVAL_SPECT_PATH
d14 3
a16 2
  use TWO_D_HYDROSTATIC_M, only: two_d_hydrostatic
  use METRICS_M
d18 6
a23 3
  use GET_BETA_PATH_M, only: GET_BETA_PATH
  USE RAD_TRAN_M, ONLY: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, &
                       &  DRAD_TRAN_DX
a29 1
 
d63 1
a63 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.23 2001/09/09 11:17:43 zvi Exp $"
a232 1
    integer :: FRQ_I                    ! Frequency loop index
a233 1
    integer :: I_STOP                   ! Upper index for radiance comp.
a248 1
    integer :: NO_GL_NDX                ! Number of GL points to do
d284 1
a284 1
 
d316 3
a318 3
 
    real(r8), dimension(:),     pointer :: RadV
 
d320 1
a320 1
 
d326 2
a327 4
    integer, pointer :: TAN_INDS(:)      ! Index of tangent grid into gl grid
    integer, allocatable :: GL_INDS(:)   ! Index of GL indecies
    integer, allocatable :: GL_NDX(:,:)  ! Packed Index array of GL intervals
    integer, allocatable :: GL_INDGEN(:,:) ! Temp. array of indecies
a349 2
    real(r8) :: FRQ           ! Frequency
    real(r8) :: RAD           ! Radiance
a353 2
    REAL(rp), POINTER :: tan_temp(:,:)
 
a368 1
    real(rp), dimension(:,:), allocatable :: BETA_PATH_F  ! Beta on path fine
a384 1
    real(rp), dimension(:), allocatable :: DRAD_DF      ! dI/dVmr
d386 1
a386 1
    real(rp), dimension(:,:,:), pointer :: DH_DT_GLGRID
a391 2
    real(rp), dimension(:,:), allocatable :: DBETA_DT_PATH_F ! dBeta_dt
                                                             ! on fine grid
d404 1
a404 1
 
d408 1
a408 1
 
d430 1
a430 1
 
d512 1
a512 1
 
d515 1
a515 1
 
d591 2
a593 2
    call allocate_test ( dh_dt_glgrid, maxVert, n_t_phi, n_t_zeta, &
                     &  'dh_dt_glgrid', ModuleName )
d623 1
a623 1
      &  temp%template%geodLat(1,:)*Deg2Rad,  &
a638 3
    call allocate_test ( tan_temp, no_tan_hts, no_phi_t, 'tan_temp', &
                      &  ModuleName )
 
d822 1
a822 1
        call Allocate_test ( k_spect_dw_frq , maxNoFreqs, sv_dw_len , &
d824 1
a824 1
        call Allocate_test ( k_spect_dn_frq , maxNoFreqs, sv_dn_len , &
d826 1
a826 1
        call Allocate_test ( k_spect_dv_frq , maxNoFreqs, sv_dv_len , &
a852 1
 
d864 1
a864 1
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
d873 1
a873 2
              &  Z_BASIS = temp%template%surfs(:,k),                         &
              &  ETA_ZXP=eta_zxp_t(1:no_ele,:),                              &
d878 1
a878 1
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
d887 1
a887 1
 ! Tan heights for a negative tan height from metrics is not correctly working.
d893 1
a893 1
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
d902 1
a902 2
              &  Z_BASIS = temp%template%surfs(:,k),                         &
              &  ETA_ZXP=eta_zxp_t(1:no_ele,:),                              &
d907 1
a907 1
              &  temp%template%geodLat(1,windowStart:windowFinish)*Deg2Rad,  &
d959 1
d966 2
a967 3
          &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs, &
          &  no_ele,del_temp)
 
d971 1
a971 2
            &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_p, &
            &  no_ele,del_temp)
d973 1
a973 2
            &  t_path(1:no_ele),0.001*losVel%values(1,maf),gl_slabs_m, &
            &  no_ele,-del_temp)
d982 1
a982 2
          frequencies =>  &
       &   PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
d986 1
a986 1
        ! Loop over frequencies ----------------------------------------------
d988 1
a988 1
        do frq_i = 1, noFreqs
a989 1
           Frq = frequencies(frq_i)
a990 1
           ! Setup path quantities --------------------------------------
d992 1
a992 65
           IF(FwdModelConf%temp_der  .AND. FwdModelConf%spect_der) then
!
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:), &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp, &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp, &
              & DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:),                    &
              & DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                    &
              & DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                    &
              & DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )
 
           ELSE IF(FwdModelConf%temp_der) then
!
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:), &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp, &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp, &
              & DBETA_DT_PATH=dbeta_dt_path_c(1:npc,:))
 
           ELSE IF(FwdModelConf%spect_der) then
!
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),    &
              & my_Catalog,gl_slabs,ext_ind_c(1:npc),beta_path_c(1:npc,:),&
              & DBETA_DW_PATH=dbeta_dw_path_c(1:npc,:),                   &
              & DBETA_DN_PATH=dbeta_dn_path_c(1:npc,:),                   &
              & DBETA_DV_PATH=dbeta_dv_path_c(1:npc,:) )
!
           ELSE
!
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
                            &   my_Catalog,gl_slabs,ext_ind_c(1:npc),  &
                            &   beta_path_c(1:npc,:))
!
           ENDIF
!
           alpha_path_c(1:npc) = SUM(sps_path(ext_ind_c(1:npc),:) &
                              &    * beta_path_c(1:npc,:),DIM=2)
           CALL path_contrib(alpha_path_c(1:npc),del_s(1:npc),e_rflty, &
                          &  fwdModelConf%tolerance,tau(1:npc),        &
                          &  incoptdepth(1:npc),do_gl(1:npc))
!
! ALLOCATE gl grid beta
!
           no_gl_ndx = COUNT(do_gl(1:npc))
           j = Ng * no_gl_ndx
           ALLOCATE(gl_inds(1:j),beta_path_f(1:j,1:NOSPECIES), &
                    gl_indgen(1:Ng,1:no_gl_ndx),gl_ndx(1:no_gl_ndx,1:2))
           gl_ndx(:,1) = PACK((/(i,i=1,npc)/),do_gl(1:npc))
!
! Make (/(j-Ng-1,j=1,Ng)/), (/(j,j=1,Ng)/) parameter variables later on
!
           DO i = 1 , no_gl_ndx
             IF(gl_ndx(i,1) > npc/2) THEN
               gl_ndx(i,2) = 1 - Ng + Ngp1 * (gl_ndx(i,1) - 1)
               gl_indgen(:,i) = (/(j,j=1,Ng)/)
             ELSE
               gl_ndx(i,2) = 1 +      Ngp1 * (gl_ndx(i,1) - 1)
               gl_indgen(:,i) = (/(j-Ng-1,j=1,Ng)/)
             ENDIF
           ENDDO
!
! compute the gl indicies
!
           gl_inds = RESHAPE(SPREAD(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
                                 &  gl_indgen,(/Ng*no_gl_ndx/))
d994 1
a994 23
           j = Ng*no_gl_ndx
           IF(FwdModelConf%temp_der  .AND. FwdModelConf%spect_der) then
!
             ALLOCATE(dbeta_dt_path_f(1:j,1:NOSPECIES))
             ALLOCATE(dbeta_dw_path_f(1:j,1:NOSPECIES))
             ALLOCATE(dbeta_dn_path_f(1:j,1:NOSPECIES))
             ALLOCATE(dbeta_dv_path_f(1:j,1:NOSPECIES))
 
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              & my_Catalog,gl_slabs,gl_inds,beta_path_f,                    &
              & GL_SLABS_M=gl_slabs_m, T_PATH_M=t_path(1:no_ele)-del_temp,  &
              & GL_SLABS_P=gl_slabs_p, T_PATH_P=t_path(1:no_ele)+del_temp,  &
              & DBETA_DT_PATH=dbeta_dt_path_f,DBETA_DW_PATH=dbeta_dw_path_f,&
              & DBETA_DN_PATH=dbeta_dn_path_f,DBETA_DV_PATH=dbeta_dv_path_f)
!
           ELSE IF(FwdModelConf%temp_der) then
!
             ALLOCATE(dbeta_dt_path_f(1:j,1:NOSPECIES))
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              &   my_Catalog,gl_slabs,gl_inds,beta_path_f,                  &
              &   GL_SLABS_M=gl_slabs_m,T_PATH_M=t_path(1:no_ele)-del_temp, &
              &   GL_SLABS_P=gl_slabs_p,T_PATH_P=t_path(1:no_ele)+del_temp, &
              &   DBETA_DT_PATH=dbeta_dt_path_f)
d996 1
a996 16
           ELSE IF(FwdModelConf%spect_der) then
!
             ALLOCATE(dbeta_dw_path_f(1:j,1:NOSPECIES))
             ALLOCATE(dbeta_dn_path_f(1:j,1:NOSPECIES))
             ALLOCATE(dbeta_dv_path_f(1:j,1:NOSPECIES))
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
              & my_Catalog,gl_slabs,gl_inds,beta_path_f,                    &
              & DBETA_DW_PATH=dbeta_dw_path_f,DBETA_DN_PATH=dbeta_dn_path_f,&
              & DBETA_DV_PATH=dbeta_dv_path_f)
!
           ELSE
!
             CALL get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
                      &    my_Catalog,gl_slabs,gl_inds,beta_path_f)
!
           ENDIF
a997 93
           ! Compute radiative transfer ---------------------------------------
!
           CALL rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,             &
            & z_path(ext_ind_c(1:npc)),t_path(ext_ind_c(1:npc)),            &
            & alpha_path_c(1:npc),ref_corr(1:npc),do_gl(1:npc),             &
            & incoptdepth(1:npc),SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
            & path_dsdh(gl_inds),dhdz_path(gl_inds),t_script(1:npc),        &
            & tau(1:npc),Rad,i_stop)
!
           RadV(frq_i) = Rad
!
           ! Compute derivatives if needed ----------------------------------
!
           IF(FwdModelConf%atmos_der) THEN
!
             CALL drad_tran_df(z_path(ext_ind_c(1:npc)),no_z,no_phi,lin_log,&
            &  sps_values,beta_path_c(1:npc,:),eta_zxp(ext_ind_c(1:npc),:), &
            &  sps_path(ext_ind_c(1:npc),:),do_calc(ext_ind_c(1:npc),:),    &
            &  beta_path_f,eta_zxp(gl_inds,:),sps_path(gl_inds,:),          &
            &  do_calc(gl_inds,:),do_gl(1:npc),del_s(1:npc),                &
            &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
            &  t_script(1:npc),tau(1:npc),i_stop,drad_df,ptg_i,frq_i)
!
             k_atmos_frq(frq_i,:) = drad_df
!
           ENDIF
!
           IF(FwdModelConf%temp_der) THEN
!
             CALL drad_tran_dt(z_path(ext_ind_c(1:npc)),                    &
             & Req + h_path(ext_ind_c(1:npc)),                              &
             & t_path(ext_ind_c(1:npc)),dh_dt_path(ext_ind_c(1:npc),:),     &
             & alpha_path_c(1:npc),SUM(sps_path(ext_ind_c(1:npc),:)         &
             & * dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),    &
             & eta_zxp_t(ext_ind_c(1:npc),:),do_calc_t(ext_ind_c(1:npc),:), &
             & do_calc_hyd(ext_ind_c(1:npc),:),del_s(1:npc),ref_corr(1:npc),&
             & Req + one_tan_ht(1),dh_dt_path(brkpt,:),frq,do_gl(1:npc),    &
             & req + h_path(gl_inds),t_path(gl_inds),dh_dt_path(gl_inds,:), &
             & SUM(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
             & SUM(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
             & eta_zxp_t(gl_inds,:),do_calc_t(gl_inds,:),path_dsdh(gl_inds),&
             & dhdz_path(gl_inds),t_script(1:npc),tau(1:npc),i_stop,drad_dt,&
             & ptg_i,frq_i)
!
             k_temp_frq(frq_i,:) = drad_dt
!
           ENDIF
!
           IF(FwdModelConf%spect_der) THEN
!
! Spectrrrroscopic derivative  wrt: W
!
             CALL drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dw,no_phi_dw,  &
             &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(ext_ind_c(1:npc),:),    &
             &  sps_path(ext_ind_c(1:npc),:),do_calc_dw(ext_ind_c(1:npc),:),&
             &  dbeta_dw_path_f,eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),  &
             &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
             &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
             &  t_script(1:npc),tau(1:npc),i_stop,drad_dw,ptg_i,frq_i)
!
             k_spect_dw_frq(frq_i,:) = drad_dw
!
! Spectroscopic derivative  wrt: N
!
             CALL drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dn,no_phi_dn,   &
             &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(ext_ind_c(1:npc),:),     &
             &  sps_path(ext_ind_c(1:npc),:),do_calc_dn(ext_ind_c(1:npc),:), &
             &  dbeta_dn_path_f,eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),   &
             &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
             &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
             &  t_script(1:npc),tau(1:npc),i_stop,drad_dn,ptg_i,frq_i)
!
             k_spect_dn_frq(frq_i,:) = drad_dn
!
! Spectroscopic derivative  wrt: Nu0
!
             CALL drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dv,no_phi_dv,  &
             &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(ext_ind_c(1:npc),:),    &
             &  sps_path(ext_ind_c(1:npc),:),do_calc_dv(ext_ind_c(1:npc),:),&
             &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),  &
             &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
             &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
             &  t_script(1:npc),tau(1:npc),i_stop,drad_dv,ptg_i,frq_i)
!
             k_spect_dv_frq(frq_i,:) = drad_dv
!
           ENDIF
!
           DEALLOCATE(gl_inds,beta_path_f,gl_indgen,gl_ndx)
           IF(FwdModelConf%temp_der) DEALLOCATE(dbeta_dt_path_f)
           IF(FwdModelConf%spect_der) &
             DEALLOCATE(dbeta_dw_path_f,dbeta_dn_path_f,dbeta_dv_path_f)
!
a999 2
        end do            ! End freq. loop
 
a1006 1
 
d1025 46
a1070 1
!zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
a2296 3
! Revision 1.5.2.23  2001/09/09 11:17:43  zvi
! Cleaning up..
!
@


1.5.2.25
log
@Tidied up variable definitions a bit.
@
text
@d9 3
a11 3
  use COMP_SPS_PATH_M, only: COMP_SPS_PATH
  use EVAL_SPECT_PATH_M, only: EVAL_SPECT_PATH
  use REFRACTION_M, only: REFRACTIVE_INDEX, COMP_REFCOR, PATH_DS_DH
d16 1
a16 1
  use RAD_TRAN_M, only: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT, &
d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.24 2001/09/10 10:02:32 zvi Exp $"
d218 1
a218 2

    ! Define local parameters
d220 2
a222 3

    ! Now define local variables, group by type and then
    ! alphabetically
a225 1
    integer :: FRQ_I                    ! Frequency loop index
d228 1
d230 1
a231 1
    integer :: I_STOP                   ! Upper index for radiance comp.
d235 1
a236 1
    integer :: MAXNOFREQS               ! Used for sizing arrays
d240 1
a240 1
    integer :: NL                       ! Number of lines
d242 1
a242 1
    integer :: NLVL                     ! Size of integration grid
a245 3
    integer :: NOSPECIES                ! Number of molecules under consideration
    integer :: NOUSEDCHANNELS           ! How many channels are we considering
    integer :: NO_ELE                   ! Length of a gl path
a246 2
    integer :: NO_PHI_T                 ! No. of Temp. profiles in the chunk
    integer :: NO_TAN_HTS               ! Number of tangent heights
d258 5
d269 1
a270 1
    integer :: SURFACETANGENTINDEX      ! Index in tangent grid of earth's surface
d273 1
d275 1
a275 7
    integer :: WINDOWSTART              ! Start of temperature `window'
    integer :: KZ                       ! What is this Zvi ********?
    integer :: SV_DW_LEN                ! Length of DW in vector
    integer :: SV_DN_LEN                ! Length of DN in vector
    integer :: SV_DV_LEN                ! Length of DV in vector
    integer :: SV_T_LEN                 ! Number of t_phi*t_zeta in the window
  
a276 1

d278 7
a295 5
    integer, dimension(:), pointer :: EXT_IND_C ! Indecies on coarse grid
    integer, dimension(:), pointer :: TAN_INDS ! Index of tangent grid into gl grid
    integer, dimension(:), pointer :: GL_INDS ! Index of GL indecies
    integer, dimension(:), pointer :: GL_NDX ! Packed Index array of GL intervals
    integer, dimension(:,:), pointer :: GL_INDGEN ! Temp. array of indecies
a296 2
    logical, dimension(:), pointer :: DO_GL ! GL indicator
    logical, dimension(:,:), pointer :: DO_CALC ! 'Avoid zeros' indicator
d298 1
a298 16
    logical, dimension(:,:), pointer :: DO_CALC_T ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_HYD ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DW ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DN ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_DV ! 'Avoid zeros'
 
    real(r8) :: FRQ                     ! Frequency

    real(rp) :: DEL_TEMP                ! Temp. step-size in evaluation of Temp. power dep.
    real(rp) :: ELEV_OFFSET             ! Elevation offset
    real(rp) :: E_RFLTY                 ! Earth reflectivity at given tan. point
    real(rp) :: NEG_TAN_HT              ! GP Height (in KM.) of tan. press. below surface
    real(rp) :: PHI_TAN                 ! Phi at tanget point for given pointing
    real(rp) :: RAD                     ! Radiance
    real(rp) :: REQ                     ! Equivalent Earth Radius

d300 1
a300 15

    real(rp), dimension(:), pointer :: ALPHA_PATH_C ! coarse grid Sing.
    real(rp), dimension(:), pointer :: DEL_S ! Integration lengths along the path
    real(rp), dimension(:), pointer :: DHDZ_PATH ! dH/dZ on path
    real(rp), dimension(:), pointer :: DRAD_DF ! dI/dVmr
    real(rp), dimension(:), pointer :: DRAD_DN ! dI/dN
    real(rp), dimension(:), pointer :: DRAD_DT ! dI/dT
    real(rp), dimension(:), pointer :: DRAD_DV ! dI/dV
    real(rp), dimension(:), pointer :: DRAD_DW ! dI/dW
    real(rp), dimension(:), pointer :: H_PATH ! Heights on path
    real(rp), dimension(:), pointer :: INCOPTDEPTH ! Incremental Optical depth
    real(rp), dimension(:), pointer :: N_PATH ! Refractivity on path
    real(rp), dimension(:), pointer :: ONE_TAN_HT ! ***
    real(rp), dimension(:), pointer :: ONE_TAN_TEMP ! ***
    real(rp), dimension(:), pointer :: PATH_DSDH ! dS/dH on path
d302 3
d306 1
a307 6
    real(rp), dimension(:), pointer :: PHI_BASIS_DW ! phi basis per species (n_dw_phi)
    real(rp), dimension(:), pointer :: PHI_PATH ! Phi's on path
    real(rp), dimension(:), pointer :: P_GLGRID ! Pressure on glGrid surfs
    real(rp), dimension(:), pointer :: P_PATH ! Pressure on path
    real(rp), dimension(:), pointer :: RADV ! Radiances for 1 pointing on freqGrid
    real(rp), dimension(:), pointer :: REF_CORR ! Refraction correction
a308 4
    real(rp), dimension(:), pointer :: TAN_TEMP ! ***
    real(rp), dimension(:), pointer :: TAU ! Optical depth
    real(rp), dimension(:), pointer :: T_PATH ! Temperatures on path
    real(rp), dimension(:), pointer :: T_SCRIPT ! ********
d312 17
a328 38
    real(rp), dimension(:), pointer :: Z_BASIS ! zeta basis per species (n_f_zeta)
    real(rp), dimension(:), pointer :: Z_BASIS_DN ! zeta basis for dw (n_dn_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DV ! zeta basis for dw (n_dv_z)
    real(rp), dimension(:), pointer :: Z_BASIS_DW ! zeta basis for dw (n_dw_z)
    real(rp), dimension(:), pointer :: Z_GLGRID ! Zeta on glGrid surfs
    real(rp), dimension(:), pointer :: Z_PATH ! Zeta on path

    real(rp), dimension(:,:), pointer :: BETA_PATH ! Beta on path
    real(rp), dimension(:,:), pointer :: BETA_PATH_C ! Beta on path coarse
    real(rp), dimension(:,:), pointer :: BETA_PATH_F ! Beta on path fine
    real(rp), dimension(:,:), pointer :: DBETA_DN_PATH_C ! dBeta_dn on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DN_PATH_F ! dBeta_dn on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_C ! dBeta_dt on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DT_PATH_F ! dBeta_dt on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DV_PATH_C ! dBeta_dv on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DV_PATH_F ! dBeta_dv on fine grid
    real(rp), dimension(:,:), pointer :: DBETA_DW_PATH_C ! dBeta_dw on coarse grid
    real(rp), dimension(:,:), pointer :: DBETA_DW_PATH_F ! dBeta_dw on fine grid
    real(rp), dimension(:,:), pointer :: DHDZ_GLGRID ! dH/dZ on glGrid surfs
    real(rp), dimension(:,:), pointer :: DH_DT_PATH ! dH/dT on path
    real(rp), dimension(:,:), pointer :: ETA_ZXP ! Eta_z x Eta_p
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DN ! Eta_z x Eta_p for N
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DV ! Eta_z x Eta_p for V
    real(rp), dimension(:,:), pointer :: ETA_ZXP_DW ! Eta_z x Eta_p for W
    real(rp), dimension(:,:), pointer :: ETA_ZXP_T ! Eta_t_z x Eta_t_p
    real(rp), dimension(:,:), pointer :: H_GLGRID ! H on glGrid surfs
    real(rp), dimension(:,:), pointer :: K_ATMOS_FRQ ! Storage for Atmos deriv.
    real(rp), dimension(:,:), pointer :: K_SPECT_DN_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_SPECT_DV_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_SPECT_DW_FRQ ! ****
    real(rp), dimension(:,:), pointer :: K_TEMP_FRQ ! Storage for Temp. deriv.
    real(rp), dimension(:,:), pointer :: PTG_ANGLES ! (no_tan_hts,noMaf)
    real(rp), dimension(:,:), pointer :: SPS_PATH ! spsices on path
    real(rp), dimension(:,:), pointer :: TAN_DH_DT ! dH/dT at Tangent
    real(rp), dimension(:,:), pointer :: T_GLGRID ! Temp on glGrid surfs

    real(rp), dimension(:,:,:), pointer :: DH_DT_GLGRID ! *****

d342 100
a441 9
    type (Signal_T) :: FIRSTSIGNAL      ! The first signal we're dealing with

    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS ! ***
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS_P ! ***
    type (slabs_struct), dimension(:,:), pointer :: GL_SLABS_M ! ***
 
    type (catalog_T), dimension(:), pointer :: MY_CATALOG ! ***


d571 1
a571 1
    allocate(one_tan_ht(1),one_tan_temp(1))
d574 1
a574 1
    call load_sps_data ( fwdModelIn, fwdModelExtra, fwdModelConf%molecules, &
d655 1
a655 1
    allocate(gl_slabs(no_ele,NOSPECIES))
d657 2
a658 2
    do i = 1, NOSPECIES
      nl = size(My_Catalog(i)%Lines)
d660 2
a661 2
      do j = 1, no_ele
        allocate(gl_slabs(j,i)%v0s(nl),gl_slabs(j,i)%x1(nl), &
d665 2
a666 2
      end do
    end do
d668 2
a669 2
    if(FwdModelConf%temp_der) then
      allocate(gl_slabs_p(no_ele,NOSPECIES), &
d671 2
a672 2
      do i = 1, NOSPECIES
        nl = size(My_Catalog(i)%Lines)
d675 2
a676 2
        do j = 1, no_ele
          allocate(gl_slabs_p(j,i)%v0s(nl),gl_slabs_p(j,i)%x1(nl), &
d684 3
a686 3
        end do
      end do
    endif
d695 1
a695 1
    allocate(z_path(1:no_ele),h_path(1:no_ele),phi_path(1:no_ele),  &
d704 1
a704 1
    if(FwdModelConf%temp_der) then
d709 1
a709 1
      allocate(dh_dt_path(1:no_ele,sv_t_len),           &
d716 1
a716 1
    endif
d718 1
a718 1
    if(FwdModelConf%spect_der) then
d722 3
a724 3
      allocate(dbeta_dw_path_c(1:npc,1:NOSPECIES))
      allocate(dbeta_dn_path_c(1:npc,1:NOSPECIES))
      allocate(dbeta_dv_path_c(1:npc,1:NOSPECIES))
d726 1
a726 1
      do i = 1, NOSPECIES
d730 1
a730 1
          allocate(do_calc_dw(1:no_ele,1:sv_dw_len), &
d737 1
a737 1
          allocate(do_calc_dn(1:no_ele,1:sv_dn_len), &
d744 1
a744 1
          allocate(do_calc_dv(1:no_ele,1:sv_dv_len), &
d748 1
a748 1
      end do
d750 1
a750 1
    endif
d1011 1
a1011 1
           if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then
d1013 1
a1013 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
d1022 1
a1022 1
           else if(FwdModelConf%temp_der) then
d1024 1
a1024 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
d1030 1
a1030 1
           else if(FwdModelConf%spect_der) then
d1032 1
a1032 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),    &
d1038 1
a1038 1
           else
d1040 1
a1040 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
d1044 1
a1044 1
           endif
d1046 1
a1046 1
           alpha_path_c(1:npc) = sum(sps_path(ext_ind_c(1:npc),:) &
d1048 1
a1048 1
           call path_contrib(alpha_path_c(1:npc),del_s(1:npc),e_rflty, &
d1054 1
a1054 1
           no_gl_ndx = count(do_gl(1:npc))
d1056 1
a1056 1
           allocate(gl_inds(1:j),beta_path_f(1:j,1:NOSPECIES), &
d1058 1
a1058 1
           gl_ndx(:,1) = pack((/(i,i=1,npc)/),do_gl(1:npc))
d1062 2
a1063 2
           do i = 1 , no_gl_ndx
             if(gl_ndx(i,1) > npc/2) then
d1066 1
a1066 1
             else
d1069 2
a1070 2
             endif
           enddo
d1074 1
a1074 1
           gl_inds = reshape(spread(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
d1078 1
a1078 1
           if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then
d1080 4
a1083 4
             allocate(dbeta_dt_path_f(1:j,1:NOSPECIES))
             allocate(dbeta_dw_path_f(1:j,1:NOSPECIES))
             allocate(dbeta_dn_path_f(1:j,1:NOSPECIES))
             allocate(dbeta_dv_path_f(1:j,1:NOSPECIES))
d1085 1
a1085 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1092 1
a1092 1
           else if(FwdModelConf%temp_der) then
d1094 2
a1095 2
             allocate(dbeta_dt_path_f(1:j,1:NOSPECIES))
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1101 1
a1101 1
           else if(FwdModelConf%spect_der) then
d1103 4
a1106 4
             allocate(dbeta_dw_path_f(1:j,1:NOSPECIES))
             allocate(dbeta_dn_path_f(1:j,1:NOSPECIES))
             allocate(dbeta_dv_path_f(1:j,1:NOSPECIES))
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1111 1
a1111 1
           else
d1113 1
a1113 1
             call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
d1116 1
a1116 1
           endif
d1120 1
a1120 1
           call rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,             &
d1123 1
a1123 1
            & incoptdepth(1:npc),sum(sps_path(gl_inds,:)*beta_path_f,DIM=2),&
d1131 1
a1131 1
           if(FwdModelConf%atmos_der) then
d1133 1
a1133 1
             call drad_tran_df(z_path(ext_ind_c(1:npc)),no_z,no_phi,lin_log,&
d1143 1
a1143 1
           endif
d1145 1
a1145 1
           if(FwdModelConf%temp_der) then
d1147 1
a1147 1
             call drad_tran_dt(z_path(ext_ind_c(1:npc)),                    &
d1150 1
a1150 1
             & alpha_path_c(1:npc),sum(sps_path(ext_ind_c(1:npc),:)         &
d1156 2
a1157 2
             & sum(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
             & sum(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
d1164 1
a1164 1
           endif
d1166 1
a1166 1
           if(FwdModelConf%spect_der) then
d1170 1
a1170 1
             call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dw,no_phi_dw,  &
d1182 1
a1182 1
             call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dn,no_phi_dn,   &
d1194 1
a1194 1
             call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dv,no_phi_dv,  &
d1204 1
a1204 1
           endif
d1206 4
a1209 4
           deallocate(gl_inds,beta_path_f,gl_indgen,gl_ndx)
           if(FwdModelConf%temp_der) deallocate(dbeta_dt_path_f)
           if(FwdModelConf%spect_der) &
             deallocate(dbeta_dw_path_f,dbeta_dn_path_f,dbeta_dv_path_f)
a2467 3
! Revision 1.5.2.24  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
@


1.5.2.26
log
@Added call to AllocateOneSlabs
@
text
@d8 1
a8 1
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS
d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.25 2001/09/10 19:38:19 livesey Exp $"
d544 1
a544 2
    call allocate_test ( one_tan_ht, 1, 'one_tan_ht', ModuleName )
    call allocate_test ( one_tan_temp, 1, 'one_tan_temp', ModuleName )
d628 2
a629 6

    allocate ( gl_slabs ( no_ele, noSpecies), stat=ier )
    if ( ier /= 0 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//"gl_slabs" )

d634 4
a637 1
        call AllocateOneSlabs ( gl_slabs(j,i), nl, ModuleName )
d649 8
a656 2
          call AllocateOneSlabs ( gl_slabs_p(j,i), nl, ModuleName )
          call AllocateOneSlabs ( gl_slabs_m(j,i), nl, ModuleName )
a2440 3
! Revision 1.5.2.25  2001/09/10 19:38:19  livesey
! Tidied up variable definitions a bit.
!
@


1.5.2.27
log
@More tidying up
@
text
@d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.26 2001/09/10 19:56:36 livesey Exp $"
d643 1
a643 1
    if(FwdModelConf%temp_der) mthen
d645 1
a645 4
            &  gl_slabs_m(no_ele,NOSPECIES), STAT=ier) 
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//"gl_slabs_[pm]" )

a2436 3
! Revision 1.5.2.26  2001/09/10 19:56:36  livesey
! Added call to AllocateOneSlabs
!
@


1.5.2.28
log
@Interim
@
text
@d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.27 2001/09/10 20:24:06 livesey Exp $"
d667 9
a675 23
    call Allocate_test ( dhdz_path, no_ele, 'dhdz_path', ModuleName )
    call Allocate_test ( h_path,    no_ele, 'h_path',    ModuleName )
    call Allocate_test ( p_path,    no_ele, 'p_path',    ModuleName )
    call Allocate_test ( path_dsdh, no_ele, 'path_dsdh', ModuleName )
    call Allocate_test ( phi_path,  no_ele, 'phi_path',  ModuleName )
    call Allocate_test ( t_path,    no_ele, 't_path',    ModuleName )
    call Allocate_test ( z_path,    no_ele, 'z_path',    ModuleName )

    call Allocate_Test ( alpha_path_c, npc, 'alpha_path_c', ModuleName )
    call Allocate_Test ( incoptdepth,  npc, 'incoptdept',   ModuleName )
    call Allocate_Test ( t_script,     npc, 't_script',     ModuleName )
    call Allocate_Test ( tau,          npc, 'tau',          ModuleName )
    call Allocate_test ( del_s,        npc, 'del_s',        ModuleName )
    call Allocate_test ( do_gl,        npc, 'do_gl',        ModuleName )
    call Allocate_test ( ext_ind_c,    npc, 'ext_ind_c',    ModuleName )
    call Allocate_test ( n_path,       npc, 'n_path',       ModuleName )
    call Allocate_test ( ref_corr,     npc, 'ref_corr',     ModuleName )

    call Allocate_test ( beta_path_c, npc, noSpecies, 'beta_path_c', ModuleName )
    call Allocate_test ( do_calc, no_ele, f_len, 'do_calc', ModuleName )
    call Allocate_test ( eta_zxp, no_ele, f_len, 'eta_zxp', ModuleName )
    call Allocate_test ( sps_path, no_ele, noSpecies, 'sps_path', ModuleName )

d681 6
a686 9

      call Allocate_test ( dRad_dt, sv_t_len, 'dRad_dt', ModuleName )
      call Allocate_test ( dbeta_dt_path_c, npc, noSpecies, 'dbeta_dt_path_c', ModuleName )
      call Allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', ModuleName )
      call Allocate_test ( dh_dt_path, no_ele, sv_t_len, 'dh_dt_path', ModuleName )
      call Allocate_test ( do_calc_hyd, no_ele, sv_t_len, 'do_calc_hyd', ModuleName )
      call Allocate_test ( do_calc_t, no_ele, sv_t_len, 'do_calc_t', ModuleName )
      call Allocate_test ( eta_zxp_t, no_ele, sv_t_len, 'eta_zxp_t', ModuleName )
      call Allocate_test ( tan_dh_dt, 1, n_t_zeta, 'tan_dh_dt', ModuleName )
a2439 3
! Revision 1.5.2.27  2001/09/10 20:24:06  livesey
! More tidying up
!
@


1.5.2.29
log
@Interim
@
text
@d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.28 2001/09/10 20:46:42 livesey Exp $"
d304 1
d306 3
a308 2

    logical, dimension(:,:), pointer :: DO_CALC ! 'Avoid zeros' indicator
a310 3
    logical, dimension(:,:), pointer :: DO_CALC_DW ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_HYD ! 'Avoid zeros'
    logical, dimension(:,:), pointer :: DO_CALC_T ! 'Avoid zeros'
d348 1
a388 1
    real(rp), dimension(:,:), pointer :: TAN_TEMP ! ***
d643 1
a643 1
    if(FwdModelConf%temp_der) then
d646 1
a646 1
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d660 1
a660 1
    ! Now allocate all path related... with maximum length..
d1184 6
a1189 6
               &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(ext_ind_c(1:npc),:),    &
               &  sps_path(ext_ind_c(1:npc),:),do_calc_dv(ext_ind_c(1:npc),:),&
               &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),  &
               &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
               &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
               &  t_script(1:npc),tau(1:npc),i_stop,drad_dv,ptg_i,frq_i)
a2456 3
! Revision 1.5.2.28  2001/09/10 20:46:42  livesey
! Interim
!
@


1.5.2.30
log
@Interim
@
text
@d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.29 2001/09/10 21:06:42 livesey Exp $"
d300 1
a300 2

    integer, dimension(:,:), pointer :: GL_NDX ! Packed Index array of GL intervals
a2457 3
! Revision 1.5.2.29  2001/09/10 21:06:42  livesey
! Interim
!
@


1.5.2.31
log
@Added freq_avg code..
@
text
@d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.30 2001/09/10 21:07:58 livesey Exp $"
a233 1
    integer :: INSTANCE                 ! Loop counter
a266 1
    integer :: SHAPEIND                 ! Index into filter shapes
d277 1
a277 2
    integer :: SPECIE                   ! Loop counter
    integer :: SV_I                     ! Loop index and other uses .
a281 1
    integer :: SURFACE                  ! Loop counter
a312 7

! Local atorage places for derivatives..(Temporary..)
    real(r4), dimension(:,:,:,:)  , pointer :: K_TEMP
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DW
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DN
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DV
a313 1
    real(r8) :: R                       ! real variable for various uses
a314 1
    real(r8) :: CENTERFREQ              ! Of band
a323 1

a387 1
    real(rp), dimension(:,:), pointer :: RADIANCES     ! (Nptg,noChans)
d416 1
a716 1
      j = windowFinish - windowStart + 1
d718 3
a720 2
        sv_dw_len = no_z_dw(i) * j
        if(sv_dw_len > 0) then
d725 3
a727 2
        sv_dn_len = no_z_dn(i) * j
        if(sv_dn_len > 0) then
d732 3
a734 2
        sv_dv_len = no_z_dv(i) * j
        if(sv_dv_len > 0) then
a1208 3

        ! Here we either frequency average to get the unconvolved radiances, or
        ! we just store what we have as we're using delta funciton channels
a1209 39
           if ( toggle(emit) .and. levels(emit) > 1 ) &
             & call trace_begin ( 'ForwardModel.FrequencyAvg' )
           if ( fwdModelConf%do_freq_avg ) then
             do i = 1, noUsedChannels
               sigInd = usedSignals(i)
               channel = usedChannels(i)
               if ( toggle(emit) .and. levels(emit) > 2 ) then
                 call output ( 'Channel = ' )
                 call output ( i )
                 call output ( ' ( ' )
                 call output ( sigInd )
                 call output ( ':' )
                 call output ( channel )
                 call output ( ' )', advance='yes' )
               end if
               centerFreq = firstSignal%lo + &
                 & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
               shapeInd = MatchSignal ( filterShapes%signal, &
                 & fwdModelConf%signals(sigInd), sideband = thisSideband )
               if ( shapeInd == 0 ) &
                 & call MLSMessage ( MLSMSG_Error, ModuleName, &
                 &    "No matching channel shape information" )
               if ( toggle(emit) .and. levels(emit) > 2 ) then
                 call output ( 'Using filter shape:' )
                 call output ( shapeInd, advance='yes' )
               endif
 
               call Freq_Avg ( frequencies, &
                 & centerFreq+thisSideband * &
                 & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                 & FilterShapes(shapeInd)%FilterShape(channel,:),&
                 & RadV, noFreqs,  &
                 & size(FilterShapes(shapeInd)%FilterGrid(channel,:)), &
                 & Radiances(ptg_i,i) )
             end do
           else
             Radiances(ptg_i,1:noFreqs) = RadV(1:noFreqs)
           end if

a1211 234
           ! Frequency Average the temperature derivatives with the appropriate
           ! filter shapes
           !??? Do we need to do this if there's no Jacobian ???

           if ( fwdModelConf%temp_der ) then
             if ( fwdModelConf%do_freq_avg ) then
               do i = 1, noUsedChannels
                 sigInd = usedSignals(i)
                 channel = usedChannels(i)
                 centerFreq = firstSignal%lo + thisSideband * &
                   & fwdModelConf%signals(sigInd)%centerFrequency
                 shapeInd = MatchSignal ( filterShapes%signal, &
                   & fwdModelConf%signals(sigInd), &
                   & sideband = thisSideband, channel=channel )
                 sv_i = 1
                 do instance = 1, n_t_phi
                   do surface = 1, temp%template%noSurfs
                     call Freq_Avg ( frequencies,                        &
                       & centerFreq+thisSideband* &
                       & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                       & FilterShapes(shapeInd)%FilterShape(channel,:),&
                       & k_temp_frq(:,sv_i), noFreqs, &
                       & size(FilterShapes(shapeInd)%FilterGrid(channel,:)),r)
                     k_temp(i,ptg_i,surface,instance) = r
                     sv_i = sv_i + 1
                   end do                  ! Surface loop
                 end do                    ! Instance loop
               end do                      ! Channel loop
             else
               do i = 1, noUsedChannels
                 sv_i = 1
                 do instance = 1, n_t_phi
                   do surface = 1, temp%template%noSurfs
                     k_temp(i,ptg_i,surface,instance) = k_temp_frq(1,sv_i)
                     sv_i = sv_i + 1
                   end do
                 end do
               end do
             end if
           end if
 
           ! Frequency Average the atmospheric derivatives with the appropriate
           ! filter shapes
           !??? Do we need to do this if there's no Jacobian ???

           if ( fwdModelConf%atmos_der ) then

             do specie = 1, noSpecies
               if ( fwdModelConf%moleculeDerivatives(specie) ) then
                 if ( fwdModelConf%do_freq_avg ) then
                   do i = 1, noUsedChannels
                     sigInd = usedSignals(i)
                     channel = usedChannels(i)
                     j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                     centerFreq = firstSignal%lo + thisSideband * &
                       & fwdModelConf%signals(sigInd)%centerFrequency
                     shapeInd = MatchSignal ( filterShapes%signal, &
                       & fwdModelConf%signals(sigInd), &
                       & sideband = thisSideband, channel=channel )
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi(specie)
                       do surface = 1, no_z(specie)
                         call Freq_Avg ( frequencies,                      &
                           & centerFreq+thisSideband * &
                           & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                           & FilterShapes(shapeInd)%FilterShape(channel,:), &
                           & k_atmos_frq(:,sv_i), noFreqs, j, r )
                         k_atmos(i,ptg_i,surface,instance,specie) = r
                         sv_i = sv_i + 1
                       end do                ! Surface loop
                     end do                  ! Instance loop
                   end do                    ! Channel loop
                 else                        ! Else not frequency averaging
                   do i = 1, noUsedChannels
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi(specie)
                       do surface = 1, no_z(specie)
                         k_atmos(i,ptg_i,surface,instance,specie) = &
                           k_atmos_frq(1,sv_i)
                         sv_i = sv_i + 1
                       end do
                     end do
                   end do
                 end if                      ! Frequency averaging or not
               end if                        ! Want derivatives for this
             end do                          ! Loop over species
  
           end if                          ! Want derivatives for atmos
 
       ! Frequency Average the spectroscopic derivatives with the appropriate
       ! filter shapes
       !??? Do we need to do this if there's no Jacobian ???

           if ( fwdModelConf%spect_der ) then
!
!  *** dI/dW
!
             do specie = 1, noSpecies
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
               if ( fwdModelConf%moleculeDerivatives(specie) ) then
                 if ( fwdModelConf%do_freq_avg ) then
                   do i = 1, noUsedChannels
                     sigInd = usedSignals(i)
                     channel = usedChannels(i)
                     j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                     centerFreq = firstSignal%lo + thisSideband * &
                       & fwdModelConf%signals(sigInd)%centerFrequency
                     shapeInd = MatchSignal ( filterShapes%signal, &
                       & fwdModelConf%signals(sigInd), &
                       & sideband = thisSideband, channel=channel )
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dw(specie)
                       do surface = 1, no_z_dw(specie)
                         call Freq_Avg ( frequencies,                      &
                           & centerFreq+thisSideband * &
                           & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                           & FilterShapes(shapeInd)%FilterShape(channel,:), &
                           & k_spect_dw_frq(:,sv_i), noFreqs, j, r )
                         k_spect_dw(i,ptg_i,surface,instance,specie) = r
                         sv_i = sv_i + 1
                       end do                ! Surface loop
                     end do                  ! Instance loop
                   end do                    ! Channel loop
                 else                        ! Else not frequency averaging
                   do i = 1, noUsedChannels
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dw(specie)
                       do surface = 1, no_z_dw(specie)
                         k_spect_dw(i,ptg_i,surface,instance,specie) = &
                           k_spect_dw_frq(1,sv_i)
                         sv_i = sv_i + 1
                       end do
                     end do
                   end do
                 end if                      ! Frequency averaging or not
               end if                        ! Want derivatives for this
             end do                          ! Loop over species
!
!  *** dI/dN
!
             do specie = 1, noSpecies
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
               if ( fwdModelConf%moleculeDerivatives(specie) ) then
                 if ( fwdModelConf%do_freq_avg ) then
                   do i = 1, noUsedChannels
                     sigInd = usedSignals(i)
                     channel = usedChannels(i)
                     j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                     centerFreq = firstSignal%lo + thisSideband * &
                       & fwdModelConf%signals(sigInd)%centerFrequency
                     shapeInd = MatchSignal ( filterShapes%signal, &
                       & fwdModelConf%signals(sigInd), &
                       & sideband = thisSideband, channel=channel )
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dn(specie)
                       do surface = 1, no_z_dn(specie)
                         call Freq_Avg ( frequencies,                      &
                           & centerFreq+thisSideband * &
                           & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                           & FilterShapes(shapeInd)%FilterShape(channel,:), &
                           & k_spect_dn_frq(:,sv_i), noFreqs, j, r )
                         k_spect_dn(i,ptg_i,surface,instance,specie) = r
                         sv_i = sv_i + 1
                       end do                ! Surface loop
                     end do                  ! Instance loop
                   end do                    ! Channel loop
                 else                        ! Else not frequency averaging
                   do i = 1, noUsedChannels
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dn(specie)
                       do surface = 1, no_z_dn(specie)
                         k_spect_dn(i,ptg_i,surface,instance,specie) = &
                           k_spect_dn_frq(1,sv_i)
                         sv_i = sv_i + 1
                       end do
                     end do
                   end do
                 end if                      ! Frequency averaging or not
               end if                        ! Want derivatives for this
             end do                          ! Loop over species
!
!  *** dI/dV
!
             do specie = 1, noSpecies
! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
               if ( fwdModelConf%moleculeDerivatives(specie) ) then
                 if ( fwdModelConf%do_freq_avg ) then
                   do i = 1, noUsedChannels
                     sigInd = usedSignals(i)
                     channel = usedChannels(i)
                     j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                     centerFreq = firstSignal%lo + thisSideband * &
                       & fwdModelConf%signals(sigInd)%centerFrequency
                     shapeInd = MatchSignal ( filterShapes%signal, &
                       & fwdModelConf%signals(sigInd), &
                       & sideband = thisSideband, channel=channel )
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dv(specie)
                       do surface = 1, no_z_dv(specie)
                         call Freq_Avg ( frequencies,                      &
                           & centerFreq+thisSideband * &
                           & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                           & FilterShapes(shapeInd)%FilterShape(channel,:), &
                           & k_spect_dv_frq(:,sv_i), noFreqs, j, r)
                         k_spect_dv(i,ptg_i,surface,instance,specie) = r
                         sv_i = sv_i + 1
                       end do                ! Surface loop
                     end do                  ! Instance loop
                   end do                    ! Channel loop
                 else                        ! Else not frequency averaging
                   do i = 1, noUsedChannels
                     if(specie == 1) sv_i = 1
                     do instance = 1, no_phi_dv(specie)
                       do surface = 1, no_z_dv(specie)
                         k_spect_dv(i,ptg_i,surface,instance,specie) = &
                           k_spect_dv_frq(1,sv_i)
                         sv_i = sv_i + 1
                       end do
                     end do
                   end do
                 end if                      ! Frequency averaging or not
               end if                        ! Want derivatives for this
             end do                          ! Loop over species
!
           end if                        ! Want derivatives for spect
 
           if ( toggle(emit) .and. levels(emit) > 1 ) &
             & call trace_end ( 'ForwardModel.FrequencyAvg' )
 
           call deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
 
           if ( toggle(emit) .and. levels(emit) > 1 ) &
             & call trace_end ( 'ForwardModel.Pointing' )
 
a2458 3
! Revision 1.5.2.30  2001/09/10 21:07:58  livesey
! Interim
!
@


1.5.2.32
log
@Added a use statement
@
text
@a32 1
  use Load_sps_data_m, only: LOAD_SPS_DATA
d58 1
a58 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.31 2001/09/10 23:34:51 zvi Exp $"
a2746 3
! Revision 1.5.2.31  2001/09/10 23:34:51  zvi
! Added freq_avg code..
!
@


1.5.2.33
log
@adding convolution..incomplete yet
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.32 2001/09/10 23:50:47 livesey Exp $"
d2001 1
a2001 1
    !         channel = usedChannels(i)
d2003 1
a2003 1
    !           k = channel + (j-1)*thisRadiance%template%noChans
d2379 121
d2502 1
a2502 1
    !         ! --------------- End of Pointing Loop ---------------
d2549 1
a2549 1
    !           channel = usedChannels(i)
d2556 1
a2556 1
    !             thisRatio = sidebandRatio%values(channel,1)
d2566 1
a2566 1
    !                 & fwdModelConf%signals, sideband=thisSideband, channel=channel )
d2582 1
a2582 1
    !             call convolve_all ( fwdModelConf, fwdModelIn, maf, channel, &
d2594 1
a2594 1
    !             call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel,  &
a2747 3
! Revision 1.5.2.32  2001/09/10 23:50:47  livesey
! Added a use statement
!
@


1.5.2.34
log
@Convolution code..done
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.33 2001/09/11 00:01:06 zvi Exp $"
a286 1
    integer :: WHICHPATTERN             ! Index of antenna pattern
a288 1
    integer, dimension(1) :: WHICHPATTERNASARRAY      ! Result of minloc
d326 1
a329 1
    real(rp) :: CENTER_ANGLE            ! For angles
a334 1
    real(rp) :: R                       ! real variable for various uses
a336 1
    real(rp) :: THISRATIO               ! A sideband ratio
a390 2
    real(rp), dimension(:,:), pointer :: DX_DT       ! (No_tan_hts, Tsurfs)
    real(rp), dimension(:,:), pointer :: D2X_DXDT    ! (No_tan_hts, Tsurfs)
d1505 2
d1508 2
a1509 80
!
         if ( toggle(emit) .and. levels(emit) > 0 ) &
           & call trace_begin ( 'ForwardModel.Convolution' )

      ! Work out which antenna patterns we're going to need ------------------

         call allocate_test ( superset, size(antennaPatterns), &
           & 'superset', ModuleName )

         do i = 1, noUsedChannels

           channel = usedChannels(i)
           sigInd = usedSignals(i)
           thisRadiance =>  &
              GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
               & signal=fwdModelConf%signals(sigInd)%index, &
               & sideband=firstSignal%sideband )

           if ( sidebandStart /= sidebandStop ) then   ! We're folding
             thisRatio = sidebandRatio%values(channel,1)
             if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
           else                  ! Otherwise, want just unfolded signal
             thisRatio = 1.0
           end if

          ! Here comes the Convolution codes

           if ( FwdModelConf%do_conv ) then

             do j = 1, size(antennaPatterns)
               superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
                 & fwdModelConf%signals, sideband=thisSideband, &
                 & channel=channel )
             end do

             if ( all( superset < 0 ) ) &
                call MLSMessage ( MLSMSG_Error, ModuleName, &
                   & "No matching antenna patterns." )
 
             maxSuperset = maxval ( superset )
             where ( superset < 0 )
               superset = maxSuperset + 1
             end where
             whichPatternAsArray = minloc ( superset )
             whichPattern = whichPatternAsArray(1)
             if ( toggle(emit) .and. levels(emit) > 2 ) then
               call output ( 'Using antenna pattern: ' )
               call output ( whichPattern, advance='yes' )
             end if

             call convolve_all ( fwdModelConf, fwdModelIn, maf, channel, &
               &  windowStart, windowFinish, mafTInstance-windowStart+1, &
               &  temp, ptan, thisRadiance,FwdModelConf%tangentGrid%surfs,&
               &  ptg_angles(:,maf), tan_temp(:,maf), dx_dt, d2x_dxdt,  &
               &  surfaceTangentIndex, center_angle, &
               &  Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
               &  thisRatio, Jacobian, fmStat%rows,  &
               &  antennaPatterns(whichPattern), ier )
             !??? Need to choose some index other than 1 for AntennaPatterns ???
             if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
               & 'convolve_all failed' )

           else          ! No convolution needed ..

             call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel,  &
               &     windowStart, windowFinish, temp, ptan, thisRadiance, &
               &     FwdModelConf%tangentGrid%surfs, &
               &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
               &     thisRatio, Jacobian, fmStat%rows )

           end if

         end do                            ! Channel loop

         call deallocate_test ( superset, 'superset', ModuleName )
         if ( toggle(emit) .and. levels(emit) > 0 ) &
           & call trace_end ( 'ForwardModel.Convolution' )

         if ( toggle(emit) .and. levels(emit) > 0 ) &
           & call trace_end ( 'ForwardModel.sideband' )
a2626 3
! Revision 1.5.2.33  2001/09/11 00:01:06  zvi
! adding convolution..incomplete yet
!
@


1.5.2.35
log
@It compiles
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.34 2001/09/11 00:50:32 zvi Exp $"
d70 5
a74 2
    ! This is the full radiative transfer forward model, the workhorse
    ! code
d82 138
d226 1
a226 1

d321 7
d344 1
a437 13
    
    ! ZVI's dumping ground for variables he's too busy to put in the right
    ! place, and doesn't want to write comments for

    ! Local storage places for derivatives..(Temporary..)
    real(r4), dimension(:,:,:,:)  , pointer :: K_TEMP
    real(r4), dimension(:,:,:,:,:), pointer :: K_ATMOS
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DW
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DN
    real(r4), dimension(:,:,:,:,:), pointer :: K_SPECT_DV
 


a441 27

    ! Nullify all our pointers!

    nullify ( grids, no_z, no_phi, no_z_dw, no_phi_dw, no_z_dn, no_phi_dn, &
      & no_z_dv, no_phi_dv, usedchannels, usedsignals, superset, ext_ind_c, &
      & tan_inds, gl_inds )
    nullify ( gl_ndx, gl_indgen )
    nullify ( do_gl, lin_log )
    nullify ( do_calc, do_calc_dn, do_calc_dv, do_calc_dw, &
      & do_calc_hyd, do_calc_t )
    nullify ( k_temp, k_atmos, k_spect_dw, k_spect_dn, k_spect_dv )
    nullify ( frequencies )
    nullify ( alpha_path_c, del_s, dhdz_path, drad_df, drad_dn, &
      & drad_dt, drad_dv, drad_dw, h_path, incoptdepth, n_path, &
      & one_tan_ht, one_tan_temp, path_dsdh, phi_basis, phi_basis_dn, &
      & phi_basis_dv, phi_basis_dw, phi_path, p_glgrid, p_path, radv, &
      & ref_corr, sps_values, tau, t_path, t_script, xm, ym, zgx,&
      & z_basis, z_basis_dn, z_basis_dv, z_basis_dw, z_glgrid, z_path )

    nullify ( beta_path, beta_path_c, beta_path_f, dbeta_dn_path_c, &
      & dbeta_dn_path_f, dbeta_dt_path_c, dbeta_dt_path_f, &
      & dbeta_dv_path_c, dbeta_dv_path_f, dbeta_dw_path_c, dbeta_dw_path_f, &
      & dhdz_glgrid, dh_dt_path, dx_dt, d2x_dxdt, eta_zxp, eta_zxp_dn, &
      & eta_zxp_dv, eta_zxp_dw, eta_zxp_t, h_glgrid, k_atmos_frq, &
      & k_spect_dn_frq, k_spect_dv_frq, k_spect_dw_frq, &
      & k_temp_frq, ptg_angles, radiances, sps_path, tan_dh_dt, tan_temp, &
      & t_glgrid, dh_dt_glgrid )
d722 1
d763 1
a763 1

d1601 1103
a2708 3
! Revision 1.5.2.34  2001/09/11 00:50:32  zvi
! Convolution code..done
!
@


1.5.2.36
log
@More tidy ups
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.35 2001/09/11 01:27:14 livesey Exp $"
a354 13
    if ( fwdModelConf%signals(1)%sideband == 0 ) then
      if (.not. associated (sidebandRatio) ) &
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      sidebandStart = fwdModelConf%signals(1)%sideband
      sidebandStop = sideBandStart
      sidebandStep = 1
    endif

d649 1
a649 1

d651 1
a651 1

a652 2
    call allocate_test ( radiances, no_tan_hts, noUsedChannels, &
        & 'radiances', ModuleName )
a1495 3
! Revision 1.5.2.35  2001/09/11 01:27:14  livesey
! It compiles
!
@


1.5.2.37
log
@Fixing bugs, adding printing code
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.36 2001/09/11 01:36:54 livesey Exp $"
d82 1
a82 1
 
d85 1
a85 1
 
a99 1
    integer :: MAXNOFSURFS              ! Max. no. surfaces for any molecule
d147 1
a147 1
 
d150 1
a150 1
 
d166 1
a166 1
 
d172 1
a172 1
 
d179 1
a179 1
 
d182 1
a182 1
 
d193 2
a194 1
 
d232 1
a232 1
 
d265 1
a265 1
 
d267 1
a267 1
 
a271 1
    type (VectorValue_T), pointer :: F             ! An arbitrary species
d282 1
a282 1
 
d288 2
a289 2
 
 
d292 1
a292 1
 
d300 2
a301 1
 
d306 1
a306 1
 
d308 1
a308 1
 
d324 1
a324 1
 
d367 1
a367 1
 
a454 7

    maxNoFSurfs = 0
    do specie = 1, noSpecies
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=fwdModelConf%molecules(specie) )
      maxNoFSurfs = max(maxNoFSurfs, f%template%noSurfs)
    end do
a472 21

    allocate ( k_temp(noUsedChannels, no_tan_hts, temp%template%noSurfs, &
          & windowStart:windowFinish), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_temp' )
    allocate ( k_atmos(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_atmos' )
    allocate ( k_spect_dw(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_spect_dw' )
    allocate ( k_spect_dn(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_spect_dn' )
    allocate ( k_spect_dv(noUsedChannels, no_tan_hts, maxNoFSurfs, &
          & windowStart:windowFinish, noSpecies), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error,ModuleName, &
          & MLSMSG_Allocate//'k_spect_dv' )
d556 1
a556 1
 
d561 1
a561 1
 
d572 1
a572 1
            &  gl_slabs_m(no_ele,NOSPECIES), STAT=ier)
d575 1
a575 1
 
d601 1
a601 1
 
d611 1
a611 1
 
d616 1
a616 1
 
d622 1
a622 1
 
d662 1
a662 1
 
d664 2
a665 3
 
    call allocate_test ( ptg_angles, no_tan_hts, noMAFs, 'ptg_angles', &
                    &    ModuleName )
a668 5
    call allocate_test ( dx_dt, no_tan_hts, temp%template%noSurfs, &
        & 'dx_dt', ModuleName )
    call allocate_test ( d2x_dxdt, no_tan_hts, temp%template%noSurfs, &
        & 'd2x_dxdt', ModuleName )
 
d711 1
a711 1
            & Size(pointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies) )
d716 1
a716 2
        call allocate_test ( frequencies,noUsedChannels, "frequencies", &
                         &   ModuleName )
d742 1
a742 2
        & call Allocate_test (k_temp_frq,maxNoFreqs,sv_t_len,'k_temp_frq', &
                           &  ModuleName )
d745 1
a745 2
        & call Allocate_test ( k_atmos_frq,maxNoFreqs,f_len,'k_atmos_frq',&
                           &   ModuleName )
d807 2
a808 2
              &  z_glgrid,h_glgrid(:,windowStart:windowFinish),              &
              &  t_glgrid(:,windowStart:windowFinish),                       &
d848 1
a848 1
          call eval_spect_path(z_basis_dw,phi_basis_dw+phi_tan,       &
d851 1
a851 1
          call eval_spect_path(z_basis_dn,phi_basis_dn+phi_tan,       &
d854 1
a854 1
          call eval_spect_path(z_basis_dv,phi_basis_dv+phi_tan,       &
d877 1
a877 1

d885 3
a887 3
                                      &   Req+one_tan_ht(1))
        path_dsdh(brkpt+2:no_ele-1)=path_ds_dh(Req+h_path(brkpt+2:no_ele-1), &
                                    &          Req+one_tan_ht(1))
d1133 1
a1133 1
 
d1175 1
a1175 1
 
d1181 1
a1181 1
 
d1222 1
a1222 1
 
d1224 1
a1224 1
 
d1264 1
a1264 1
 
d1270 2
a1271 3
 
           if (i > -11) then         ! *** ZEBIG, don't run spec_deriv.
!          if ( fwdModelConf%spect_der ) then
d1420 1
a1420 1
 
d1422 1
a1422 1
 
d1425 1
a1425 1
 
d1427 1
a1427 1
 
d1434 1
a1434 1
 
d1441 1
a1441 1
 
d1443 1
a1443 1
 
d1445 1
a1445 1
 
d1451 1
a1451 1
 
d1466 1
a1466 1
 
d1478 1
a1478 1
 
d1480 1
a1480 1
 
d1486 1
a1486 1
 
d1488 1
a1488 1
 
d1490 1
a1490 1
 
d1494 1
a1494 1
 
a1499 10
!
!  **** DEBUG Printing cycle ...
!
      if ( index(switches,'rad') /= 0 ) then
        ! *** DEBUG Print
        if ( FwdModelConf%do_conv ) then
          print *,'Convolution: ON'
        else
          print *,'Convolution: OFF'
        end if
a1500 31
        if ( FwdModelConf%do_freq_avg ) then
          print *,'Frequency Averaging: ON'
        else
          Frq = Frequencies(1)
          print *,'Frequency Averaging: OFF'
          print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
        end if
 
        print *
        k=ptan%template%noSurfs
        print 901, k
901     format ( 'ptan\',i3.3)
        Print 902,Ptan%values(1:k,maf)
902     format ( 4(4x, f10.7))
 
        print *
        grids = 0
        do i = 1, noUsedChannels
          channel = usedChannels(i)
          print 903, channel, char(92), ptan%template%noSurfs
903       format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
          grids = (/(channel+(k-1)*firstRadiance%template%noChans, &
                &   k=1,ptan%template%noSurfs)/)
          print 905, firstRadiance%values(grids,maf)
905       format ( 4(2x, 1pg15.8) )
        end do
 
      end if
!
!  **** End of Printing cycle ...
!
a1510 3
! Revision 1.5.2.36  2001/09/11 01:36:54  livesey
! More tidy ups
!
@


1.5.2.38
log
@Develop.
@
text
@d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.37 2001/09/11 08:13:33 zvi Exp $"
d114 1
d185 1
a185 1
    real(rp) :: DEL_TEMP            ! Temp. step-size in evaluation of Temp. power dep.
d422 1
d455 1
a455 1
 
d480 2
a481 2
 
    allocate ( k_temp(noUsedChannels, no_tan_hts, n_t_zeta, &
d562 1
a562 1
      &  spread(refGPH%template%surfs(1,1),1,n_t_phi),&
d576 1
a576 1
    call allocate_test ( tan_temp, no_tan_hts, n_t_phi, 'tan_temp', &
d697 5
a701 3
 
    call allocate_test ( dx_dt, no_tan_hts, n_t_zeta, 'dx_dt', ModuleName )
    call allocate_test ( d2x_dxdt, no_tan_hts, n_t_zeta, 'd2x_dxdt', ModuleName )
d914 1
a914 7
 
!       call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2), &
!         &  one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf), &
!         &  tan_dh_dt(1,:), temp%template%surfs(:,1), &
!         &  temp%template%geodLat(1,:)*Deg2Rad, one_tan_temp(1), &
!         &  fwdModelConf%tangentGrid%surfs,dx_dt,d2x_dxdt)
 
d1231 1
a1231 1
                   do surface = 1, n_t_zeta
d1247 1
a1247 1
                   do surface = 1, n_t_zeta
a1589 3
! Revision 1.5.2.37  2001/09/11 08:13:33  zvi
! Fixing bugs, adding printing code
!
@


1.5.2.39
log
@Added dump and stop statement
@
text
@a49 5


  ! DIAGNOSTICS ONLY ***********
  use Dump_0, only: DUMP
  use Molecules, only: L_H2O
d59 1
a59 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.38 2001/09/11 20:48:22 zvi Exp $"
d695 1
a698 23

    ! ***********************************************
    ! All sorts of print statements.
    call dump ( temp%template%phi, "Temp phi basis", clean=.true. )
    call dump ( temp%template%surfs, "Temp Zeta basis", clean=.true. )
    call dump ( temp%template%geodLat, "Temp geod lat", clean=.true. )
    call dump ( temp%values, "Temperature values", clean=.true. )

    f => GetVectorQuantityByType ( fwdModelIn, quantityType=l_vmr, &
      molecule=l_h2o )

    call dump ( f%template%phi, "h2o phi basis", clean=.true. )
    call dump ( f%template%surfs, "h2o zeta basis", clean=.true. )
    call dump ( f%template%geodLat, "h2o geod lat", clean=.true. )
    call dump ( f%values )

    call dump ( ptan%values(:,maf) , "ptan values", clean=.true. )
   
    call dump ( scGeocAlt%values/1e3, "SC geoc altitude / km", clean=.true. )
    stop

    ! ***********************************************
 
a1591 3
! Revision 1.5.2.38  2001/09/11 20:48:22  zvi
! Develop.
!
@


1.5.2.40
log
@Interim version
@
text
@d64 1
a64 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.39 2001/09/11 20:48:04 livesey Exp $"
d706 4
d711 2
a712 2
!     call output ( "Line of sight velocity / kms-1: " )
!     call output ( losVel%values(1,1)/1e3, advance='yes')
d714 4
a717 2
!     call output ( "Phi tan " )
!     call output ( ptan%template%phi(1,1), advance='yes')
d719 4
a722 18
!     call dump ( ptan%values(:,maf) , "ptan values", clean=.true. )
  
!     call output ( "SC geoc altitude / km: " )
!     call output ( scGeocAlt%values(1,1)/1e3, advance='yes' )

!     call dump ( temp%template%phi, "Temp phi basis", clean=.true. )
!     call dump ( temp%template%surfs, "Temp Zeta basis", clean=.true. )
!     call dump ( temp%template%geodLat, "Temp geod lat", clean=.true. )
!     call dump ( temp%values, "Temperature values", clean=.true. )

!     f => GetVectorQuantityByType ( fwdModelIn, quantityType=l_vmr, &
!       molecule=l_h2o )

!     call dump ( f%template%phi, "h2o phi basis", clean=.true. )
!     call dump ( f%template%surfs, "h2o zeta basis", clean=.true. )
!     call dump ( f%template%geodLat, "h2o geod lat", clean=.true. )
!     call dump ( f%values )
!     stop
a814 2

      print*,'Frequencies:',frequencies
a1566 6

    if ( maf == noMAFs ) fmStat%finished = .true.

    call dump ( firstRadiance%values(1:firstRadiance%template%instanceLen:25,1), &
      & 'Radiance output' )

a1618 3
! Revision 1.5.2.39  2001/09/11 20:48:04  livesey
! Added dump and stop statement
!
@


1.5.2.41
log
@Single channel no convolution, derivatives or frequency averaging works
@
text
@d52 4
d64 1
a64 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.40 2001/09/11 21:24:27 livesey Exp $"
d549 1
a549 1
    p_glgrid = 10.0_rp**(-z_glgrid)
d561 1
a561 1

d563 1
a563 1
      &  temp%template%phi(1,:)*Deg2Rad,  &
d570 1
a570 1

d703 31
d824 2
d850 3
a852 2
          neg_tan_ht = temp%values(1,mafTInstance) * &
            &  (fwdModelConf%tangentGrid%surfs(ptg_i) - z_glgrid(1)) / 14.8_rp
d870 1
a870 1
              &  Z_BASIS = temp%template%surfs(:,1),                         &
d900 1
a900 1
              &  Z_BASIS = temp%template%surfs(:,1),                         &
d915 1
a915 1

d935 1
a935 1

d957 2
a958 2
        
        ! This only needs to be computed on the gl (not coarse) grid thus there is
d1492 1
a1492 1

d1580 3
d1605 1
a1605 1
901     format ( 'ptan\ ',i3.3)
d1631 1
a1631 1

a1634 3
! Revision 1.5.2.40  2001/09/11 21:24:27  livesey
! Interim version
!
@


1.5.2.42
log
@Put printing stmt. back
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.41 2001/09/12 00:12:03 livesey Exp $"
d1569 1
d1574 3
a1576 2
          print 905, &
           & firstRadiance%values(1:firstRadiance%template%InstanceLen:25,maf)
a1593 3
! Revision 1.5.2.41  2001/09/12 00:12:03  livesey
! Single channel no convolution, derivatives or frequency averaging works
!
@


1.5.2.43
log
@Fixed printing
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.42 2001/09/12 00:30:00 zvi Exp $"
d1574 1
a1574 1
           & firstRadiance%values(i:firstRadiance%template%InstanceLen:25,maf)
a1591 3
! Revision 1.5.2.42  2001/09/12 00:30:00  zvi
! Put printing stmt. back
!
@


1.5.2.44
log
@Fixed problem with vmr derivatives
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.43 2001/09/12 00:32:36 livesey Exp $"
a658 4

    if ( FwdModelConf%atmos_der ) then
      call Allocate_test ( dRad_df, f_len, 'dRad_df', ModuleName )
    end if
d1309 2
a1310 1
           if ( fwdModelConf%spect_der ) then
a1591 3
! Revision 1.5.2.43  2001/09/12 00:32:36  livesey
! Fixed printing
!
@


1.5.2.45
log
@Fixing Conv. bug
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.44 2001/09/12 01:00:34 livesey Exp $"
a1508 1
             center_angle = ptg_angles(surfaceTangentIndex,maf)
a1594 3
! Revision 1.5.2.44  2001/09/12 01:00:34  livesey
! Fixed problem with vmr derivatives
!
@


1.5.2.46
log
@Bug fix
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.45 2001/09/12 04:42:32 zvi Exp $"
a794 2
        print*,'ptg_i=',ptg_i

d816 1
d835 1
a835 1
              &  DHIDTLM=dh_dt_glgrid, DHITDTLM=dh_dt_path,                  &
d865 1
a865 1
              &  DHITDTLM=dh_dt_path,                                        &
d1449 2
a1457 1

a1543 3
    ! A whole load of deallocate statements need to go here!!!!!!!


a1595 3
! Revision 1.5.2.45  2001/09/12 04:42:32  zvi
! Fixing Conv. bug
!
@


1.5.2.47
log
@Put dimension limit back on dh_dt_path
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.46 2001/09/12 22:38:25 livesey Exp $"
d836 1
a836 1
              &  DHIDTLM=dh_dt_glgrid, DHITDTLM=dh_dt_path(1:no_ele,:),      &
d866 1
a866 1
              &  DHITDTLM=dh_dt_path(1:no_ele,:),                            &
a1598 3
! Revision 1.5.2.46  2001/09/12 22:38:25  livesey
! Bug fix
!
@


1.5.2.48
log
@Got rid of print statement.
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.47 2001/09/12 22:46:26 livesey Exp $"
d795 2
a1598 3
! Revision 1.5.2.47  2001/09/12 22:46:26  livesey
! Put dimension limit back on dh_dt_path
!
@


1.5.2.49
log
@Fixed bug with calling sequence for metrics
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.48 2001/09/12 22:56:05 livesey Exp $"
d832 1
a832 2
              &  Req,TAN_PHI_H_GRID=one_tan_ht,                              &
              &  TAN_PHI_T_GRID=one_tan_temp,                                &
a1596 3
! Revision 1.5.2.48  2001/09/12 22:56:05  livesey
! Got rid of print statement.
!
@


1.5.2.50
log
@Fixed memory leak
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.49 2001/09/12 23:44:18 livesey Exp $"
a794 1
        print*,'ptg_i=',ptg_i
a850 1

a1597 3
! Revision 1.5.2.49  2001/09/12 23:44:18  livesey
! Fixed bug with calling sequence for metrics
!
@


1.5.2.51
log
@Added lots of deallocates, slight problem with temperature derivatives
and convolution.
@
text
@d8 1
a8 1
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT, ALLOCATEONESLABS, DESTROYCOMPLETESLABS
d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.50 2001/09/13 00:42:18 livesey Exp $"
d79 1
a79 1

d83 1
a83 1

d86 1
a86 1

d148 1
a148 1

d151 1
a151 1

d167 1
a167 1

d170 1
a170 1

d173 1
a173 1

d180 1
a180 1

d183 1
a183 1

d194 1
a194 1

d232 1
a232 1

d265 1
a265 1

d267 1
a267 1

d281 1
a281 1

d283 1
a283 1

d287 1
a287 1

d289 2
a290 2


d293 1
a293 1

d300 2
a301 2


d304 1
a304 1

d306 1
a306 1

d308 1
a308 1

d324 1
a324 1

d333 1
a333 1

d335 1
a335 1

d339 1
a339 1

d350 1
a350 1

d354 1
a354 1

d367 1
a367 1

d369 1
a369 1

d391 1
a391 1

d396 1
a396 1

d411 1
a411 1

d420 1
a420 1

d422 1
a422 1

d428 1
a428 1

d454 1
a454 1

d461 1
a461 1

d466 1
a466 1

d471 1
a471 1

d474 1
a474 1

d476 1
a476 1

d479 1
a479 1

d481 1
a481 1
      & windowStart:windowFinish), stat=ier )
d483 1
a483 1
      & MLSMSG_Allocate//'k_temp' )
d485 1
a485 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d487 1
a487 1
      & MLSMSG_Allocate//'k_atmos' )
d489 1
a489 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d491 1
a491 1
      & MLSMSG_Allocate//'k_spect_dw' )
d493 1
a493 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d495 1
a495 1
      & MLSMSG_Allocate//'k_spect_dn' )
d497 1
a497 1
      & windowStart:windowFinish, noSpecies), stat=ier )
d499 2
a500 2
      & MLSMSG_Allocate//'k_spect_dv' )

d508 1
a508 1

d513 1
a513 1

d516 1
a516 1

d521 1
a521 1

d524 1
a524 1

d529 2
a530 2
      &  'dh_dt_glgrid', ModuleName )

d546 1
a546 1

d550 1
a550 1

d552 1
a552 1

d572 1
a572 1

d574 1
a574 1

d576 2
a577 2
      &  ModuleName )

d579 3
a581 3

    ! First, Allocate gl_slab arrays....

d583 1
a583 1

d588 1
a588 1

d593 1
a593 1
        call AllocateOneSlabs ( gl_slabs(j,i), nl )
d596 1
a596 1

d599 1
a599 1
        &  gl_slabs_m(no_ele,NOSPECIES), STAT=ier)
d602 1
a602 1

d608 2
a609 2
          call AllocateOneSlabs ( gl_slabs_p(j,i), nl )
          call AllocateOneSlabs ( gl_slabs_m(j,i), nl )
d613 1
a613 1

d615 1
a615 1

d618 3
a620 3

    ! This can be put outside the mmaf loop

d628 1
a628 1

d638 1
a638 1

d643 1
a643 1

d645 3
a647 3

      ! Allocation for metrics routine when Temp. derivative is needed:

d649 1
a649 1

d657 1
a657 1

d663 1
a663 1

d665 7
a671 10

      ! Allocation when spectaral derivative are needed:

      call Allocate_test ( dbeta_dw_path_c, npc, noSpecies, &
        & 'dbeta_dw_path_c', ModuleName )
      call Allocate_test ( dbeta_dn_path_c, npc, noSpecies, &
        & 'dbeta_dn_path_c', ModuleName )
      call Allocate_test ( dbeta_dv_path_c, npc, noSpecies, &
        & 'dbeta_dv_path_c', ModuleName )

d677 2
a678 2
            &     eta_zxp_dw(1:no_ele,1:sv_dw_len), &
            &     drad_dw(1:sv_dw_len))
d683 2
a684 2
            &     eta_zxp_dn(1:no_ele,1:sv_dn_len), &
            &     drad_dn(1:sv_dn_len))
d689 2
a690 2
            &     eta_zxp_dv(1:no_ele,1:sv_dv_len), &
            &     drad_dv(1:sv_dv_len))
d693 1
a693 1

d695 1
a695 1

d697 1
a697 1
      &    ModuleName )
d699 1
a699 1
      & 'radiances', ModuleName )
d702 1
a702 1

d705 1
a705 1

d708 1
a708 1

d712 1
a712 1

d721 1
a721 1

d729 1
a729 1

d734 1
a734 1

d747 1
a747 1

d749 1
a749 1

d751 1
a751 1
          &   ModuleName )
d773 1
a773 1

d775 1
a775 1

d778 2
a779 2
        &  ModuleName )

d782 2
a783 2
        &   ModuleName )

d796 1
a796 1

d801 1
a801 1

d807 1
a807 1

d813 1
a813 1

d815 1
a815 1

d821 3
a823 3

          ! *** This is where we will interpolate Phi_tan

a825 4
            print*,eta_zxp_t(1,1)
            print*,do_calc_t(1,1)
            print*,do_calc_hyd(1,1)

d853 1
a853 1
          ! Tan heights for a negative tan height from metrics is not correctly working.
d897 1
a897 1

d912 1
a912 1

d915 7
a921 7

        !       call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2), &
        !         &  one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf), &
        !         &  tan_dh_dt(1,:), temp%template%surfs(:,1), &
        !         &  temp%template%geodLat(1,:)*Deg2Rad, one_tan_temp(1), &
        !         &  fwdModelConf%tangentGrid%surfs,dx_dt,d2x_dxdt)

d925 1
a925 1

d929 1
a929 1
          &   Req+one_tan_ht(1))
d931 2
a932 2
          &          Req+one_tan_ht(1))

d935 1
a935 1

d940 1
a940 1

d950 1
a950 1

d953 1
a953 1

d958 1
a958 1
            &   PointingGrids(whichPointingGrid)%oneGrid(grids(ptg_i))%frequencies
d961 1
a961 1

d963 1
a963 1

d965 8
a972 8

          Frq = frequencies(frq_i)

          ! Setup path quantities --------------------------------------

          if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
d980 4
a983 4

          else if(FwdModelConf%temp_der) then

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),     &
d988 4
a991 4

          else if(FwdModelConf%spect_der) then

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),    &
d996 49
a1044 55

          else

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &   my_Catalog,gl_slabs,ext_ind_c(1:npc),  &
              &   beta_path_c(1:npc,:))

          endif

          alpha_path_c(1:npc) = sum(sps_path(ext_ind_c(1:npc),:) &
            &    * beta_path_c(1:npc,:),DIM=2)
          call path_contrib(alpha_path_c(1:npc),del_s(1:npc),e_rflty, &
            &  fwdModelConf%tolerance,tau(1:npc),        &
            &  incoptdepth(1:npc),do_gl(1:npc))

          ! ALLOCATE gl grid beta

          no_gl_ndx = count(do_gl(1:npc))
          j = Ng * no_gl_ndx
          allocate(gl_inds(1:j),beta_path_f(1:j,1:NOSPECIES), &
            gl_indgen(1:Ng,1:no_gl_ndx),gl_ndx(1:no_gl_ndx,1:2))
          gl_ndx(:,1) = pack((/(i,i=1,npc)/),do_gl(1:npc))

          ! Make (/(j-Ng-1,j=1,Ng)/), (/(j,j=1,Ng)/) parameter variables later on

          do i = 1 , no_gl_ndx
            if(gl_ndx(i,1) > npc/2) then
              gl_ndx(i,2) = 1 - Ng + Ngp1 * (gl_ndx(i,1) - 1)
              gl_indgen(:,i) = (/(j,j=1,Ng)/)
            else
              gl_ndx(i,2) = 1 +      Ngp1 * (gl_ndx(i,1) - 1)
              gl_indgen(:,i) = (/(j-Ng-1,j=1,Ng)/)
            endif
          enddo

          ! compute the gl indicies

          gl_inds = reshape(spread(gl_ndx(1:no_gl_ndx,2),1,Ng) +  &
            &  gl_indgen,(/Ng*no_gl_ndx/))

          j = Ng*no_gl_ndx
          if(FwdModelConf%temp_der  .and. FwdModelConf%spect_der) then

            nullify ( dbeta_dt_path_f, dbeta_dw_path_f,&
              & dbeta_dn_path_f, dbeta_dv_path_f )
            call Allocate_test ( dbeta_dt_path_f, j, noSpecies, &
              & 'dbeta_dt_path_f', ModuleName )
            call Allocate_test ( dbeta_dw_path_f, j, noSpecies, &
              & 'dbeta_dw_path_f', ModuleName )
            call Allocate_test ( dbeta_dn_path_f, j, noSpecies, &
              & 'dbeta_dn_path_f', ModuleName )
            call Allocate_test ( dbeta_dv_path_f, j, noSpecies, &
              & 'dbeta_dv_path_f', ModuleName )

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1050 5
a1054 7

          else if(FwdModelConf%temp_der) then

            nullify ( dbeta_dt_path_f )
            call Allocate_test ( dbeta_dt_path_f, j, noSpecies, &
              & 'dbeta_dt_path_f', ModuleName )
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1059 7
a1065 11

          else if(FwdModelConf%spect_der) then

            nullify ( dbeta_dw_path_f, dbeta_dn_path_f, dbeta_dv_path_f )
            call Allocate_test ( dbeta_dw_path_f, j, noSpecies, &
              & 'dbeta_dw_path_f', ModuleName )
            call Allocate_test ( dbeta_dn_path_f, j, noSpecies, &
              & 'dbeta_dn_path_f', ModuleName )
            call Allocate_test ( dbeta_dv_path_f, j, noSpecies, &
              & 'dbeta_dv_path_f', ModuleName )
            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele),      &
d1069 11
a1079 11

          else

            call get_beta_path(Frq,p_path(1:no_ele),t_path(1:no_ele), &
              &    my_Catalog,gl_slabs,gl_inds,beta_path_f)

          endif

          ! Compute radiative transfer ---------------------------------------

          call rad_tran(Frq,spaceRadiance%values(1,1),e_rflty,             &
d1085 87
a1171 94

          RadV(frq_i) = Rad

          ! Compute derivatives if needed ----------------------------------

          if(FwdModelConf%atmos_der) then

            call drad_tran_df(z_path(ext_ind_c(1:npc)),no_z,no_phi,lin_log,&
              &  sps_values,beta_path_c(1:npc,:),eta_zxp(ext_ind_c(1:npc),:), &
              &  sps_path(ext_ind_c(1:npc),:),do_calc(ext_ind_c(1:npc),:),    &
              &  beta_path_f,eta_zxp(gl_inds,:),sps_path(gl_inds,:),          &
              &  do_calc(gl_inds,:),do_gl(1:npc),del_s(1:npc),                &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_df,ptg_i,frq_i)

            k_atmos_frq(frq_i,:) = drad_df

          endif

          if(FwdModelConf%temp_der) then

            call drad_tran_dt(z_path(ext_ind_c(1:npc)),                    &
              & Req + h_path(ext_ind_c(1:npc)),                              &
              & t_path(ext_ind_c(1:npc)),dh_dt_path(ext_ind_c(1:npc),:),     &
              & alpha_path_c(1:npc),sum(sps_path(ext_ind_c(1:npc),:)         &
              & * dbeta_dt_path_c(1:npc,:) * beta_path_c(1:npc,:),DIM=2),    &
              & eta_zxp_t(ext_ind_c(1:npc),:),do_calc_t(ext_ind_c(1:npc),:), &
              & do_calc_hyd(ext_ind_c(1:npc),:),del_s(1:npc),ref_corr(1:npc),&
              & Req + one_tan_ht(1),dh_dt_path(brkpt,:),frq,do_gl(1:npc),    &
              & req + h_path(gl_inds),t_path(gl_inds),dh_dt_path(gl_inds,:), &
              & sum(sps_path(gl_inds,:)*beta_path_f,DIM=2),                  &
              & sum(sps_path(gl_inds,:)*beta_path_f*dbeta_dt_path_f,DIM=2),  &
              & eta_zxp_t(gl_inds,:),do_calc_t(gl_inds,:),path_dsdh(gl_inds),&
              & dhdz_path(gl_inds),t_script(1:npc),tau(1:npc),i_stop,drad_dt,&
              & ptg_i,frq_i)

            k_temp_frq(frq_i,:) = drad_dt

          endif

          if(FwdModelConf%spect_der) then

            ! Spectrrrroscopic derivative  wrt: W

            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dw,no_phi_dw,  &
              &  dbeta_dw_path_c(1:npc,:),eta_zxp_dw(ext_ind_c(1:npc),:),    &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dw(ext_ind_c(1:npc),:),&
              &  dbeta_dw_path_f,eta_zxp_dw(gl_inds,:),sps_path(gl_inds,:),  &
              &  do_calc_dw(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dw,ptg_i,frq_i)

            k_spect_dw_frq(frq_i,:) = drad_dw

            ! Spectroscopic derivative  wrt: N

            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dn,no_phi_dn,   &
              &  dbeta_dn_path_c(1:npc,:),eta_zxp_dn(ext_ind_c(1:npc),:),     &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dn(ext_ind_c(1:npc),:), &
              &  dbeta_dn_path_f,eta_zxp_dn(gl_inds,:),sps_path(gl_inds,:),   &
              &  do_calc_dn(gl_inds,:),do_gl(1:npc),del_s(1:npc),             &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),       &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dn,ptg_i,frq_i)

            k_spect_dn_frq(frq_i,:) = drad_dn

            ! Spectroscopic derivative  wrt: Nu0

            call drad_tran_dx(z_path(ext_ind_c(1:npc)),no_z_dv,no_phi_dv,  &
              &  dbeta_dv_path_c(1:npc,:),eta_zxp_dv(ext_ind_c(1:npc),:),    &
              &  sps_path(ext_ind_c(1:npc),:),do_calc_dv(ext_ind_c(1:npc),:),&
              &  dbeta_dv_path_f,eta_zxp_dv(gl_inds,:),sps_path(gl_inds,:),  &
              &  do_calc_dv(gl_inds,:),do_gl(1:npc),del_s(1:npc),            &
              &  ref_corr(1:npc),path_dsdh(gl_inds),dhdz_path(gl_inds),      &
              &  t_script(1:npc),tau(1:npc),i_stop,drad_dv,ptg_i,frq_i)

            k_spect_dv_frq(frq_i,:) = drad_dv

          endif

          call Deallocate_test ( gl_inds, 'gl_inds', ModuleName )
          call Deallocate_test ( beta_path_f, 'beta_path_f', ModuleName )
          call Deallocate_test ( gl_ndx, 'gl_ndx', ModuleName )
          if(FwdModelConf%temp_der) &
            & call Deallocate_test (dbeta_dt_path_f, 'dbeta_dt_path_f', &
            & ModuleName )
          if(FwdModelConf%spect_der) then
            call Deallocate_test ( dbeta_dw_path_f, 'dbeta_dw_path_f', ModuleName )
            call Deallocate_test ( dbeta_dn_path_f, 'dbeta_dn_path_f', ModuleName )
            call Deallocate_test ( dbeta_dv_path_f, 'dbeta_dv_path_f', ModuleName )
          end if

          ! End of frequency loop ----------------------------------------------

d1173 1
a1173 1

d1175 1
a1175 1

d1177 1
a1177 1

d1180 40
a1219 40

        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_begin ( 'ForwardModel.FrequencyAvg' )
        if ( fwdModelConf%do_freq_avg ) then
          do i = 1, noUsedChannels
            sigInd = usedSignals(i)
            channel = usedChannels(i)
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Channel = ' )
              call output ( i )
              call output ( ' ( ' )
              call output ( sigInd )
              call output ( ':' )
              call output ( channel )
              call output ( ' )', advance='yes' )
            end if
            centerFreq = firstSignal%lo + &
              & thisSideband * fwdModelConf%signals(sigInd)%centerFrequency
            shapeInd = MatchSignal ( filterShapes%signal, &
              & fwdModelConf%signals(sigInd), sideband = thisSideband )
            if ( shapeInd == 0 ) &
              & call MLSMessage ( MLSMSG_Error, ModuleName, &
              &    "No matching channel shape information" )
            if ( toggle(emit) .and. levels(emit) > 2 ) then
              call output ( 'Using filter shape:' )
              call output ( shapeInd, advance='yes' )
            endif

            call Freq_Avg ( frequencies, &
              & centerFreq+thisSideband * &
              & FilterShapes(shapeInd)%FilterGrid(channel,:), &
              & FilterShapes(shapeInd)%FilterShape(channel,:),&
              & RadV, noFreqs,  &
              & size(FilterShapes(shapeInd)%FilterGrid(channel,:)), &
              & Radiances(ptg_i,i) )
          end do
        else
          Radiances(ptg_i,1:noFreqs) = RadV(1:noFreqs)
        end if

d1221 233
a1453 233

        ! Frequency Average the temperature derivatives with the appropriate
        ! filter shapes
        !??? Do we need to do this if there's no Jacobian ???

        if ( fwdModelConf%temp_der ) then
          if ( fwdModelConf%do_freq_avg ) then
            do i = 1, noUsedChannels
              sigInd = usedSignals(i)
              channel = usedChannels(i)
              centerFreq = firstSignal%lo + thisSideband * &
                & fwdModelConf%signals(sigInd)%centerFrequency
              shapeInd = MatchSignal ( filterShapes%signal, &
                & fwdModelConf%signals(sigInd), &
                & sideband = thisSideband, channel=channel )
              sv_i = 1
              do instance = 1, n_t_phi
                do surface = 1, n_t_zeta
                  call Freq_Avg ( frequencies,                        &
                    & centerFreq+thisSideband* &
                    & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                    & FilterShapes(shapeInd)%FilterShape(channel,:),&
                    & k_temp_frq(:,sv_i), noFreqs, &
                    & size(FilterShapes(shapeInd)%FilterGrid(channel,:)),r)
                  k_temp(i,ptg_i,surface,instance) = r
                  sv_i = sv_i + 1
                end do                  ! Surface loop
              end do                    ! Instance loop
            end do                      ! Channel loop
          else
            do i = 1, noUsedChannels
              sv_i = 1
              do instance = 1, n_t_phi
                do surface = 1, n_t_zeta
                  k_temp(i,ptg_i,surface,instance) = k_temp_frq(1,sv_i)
                  sv_i = sv_i + 1
                end do
              end do
            end do
          end if
        end if

        ! Frequency Average the atmospheric derivatives with the appropriate
        ! filter shapes
        !??? Do we need to do this if there's no Jacobian ???

        if ( fwdModelConf%atmos_der ) then

          do specie = 1, noSpecies
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channel )
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi(specie)
                    do surface = 1, no_z(specie)
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_atmos_frq(:,sv_i), noFreqs, j, r )
                      k_atmos(i,ptg_i,surface,instance,specie) = r
                      sv_i = sv_i + 1
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! Else not frequency averaging
                do i = 1, noUsedChannels
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi(specie)
                    do surface = 1, no_z(specie)
                      k_atmos(i,ptg_i,surface,instance,specie) = &
                        k_atmos_frq(1,sv_i)
                      sv_i = sv_i + 1
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over species

        end if                          ! Want derivatives for atmos

        ! Frequency Average the spectroscopic derivatives with the appropriate
        ! filter shapes
        !??? Do we need to do this if there's no Jacobian ???

        if ( fwdModelConf%spect_der ) then

          !  *** dI/dW

          do specie = 1, noSpecies
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channel )
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dw(specie)
                    do surface = 1, no_z_dw(specie)
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dw_frq(:,sv_i), noFreqs, j, r )
                      k_spect_dw(i,ptg_i,surface,instance,specie) = r
                      sv_i = sv_i + 1
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! Else not frequency averaging
                do i = 1, noUsedChannels
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dw(specie)
                    do surface = 1, no_z_dw(specie)
                      k_spect_dw(i,ptg_i,surface,instance,specie) = &
                        k_spect_dw_frq(1,sv_i)
                      sv_i = sv_i + 1
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over species

          !  *** dI/dN

          do specie = 1, noSpecies
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channel )
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dn(specie)
                    do surface = 1, no_z_dn(specie)
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dn_frq(:,sv_i), noFreqs, j, r )
                      k_spect_dn(i,ptg_i,surface,instance,specie) = r
                      sv_i = sv_i + 1
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! Else not frequency averaging
                do i = 1, noUsedChannels
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dn(specie)
                    do surface = 1, no_z_dn(specie)
                      k_spect_dn(i,ptg_i,surface,instance,specie) = &
                        k_spect_dn_frq(1,sv_i)
                      sv_i = sv_i + 1
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over species

          !  *** dI/dV

          do specie = 1, noSpecies
            ! ** ZEBUG     if ( fwdModelConf%moleculeSpectDerivatives(specie) ) then
            if ( fwdModelConf%moleculeDerivatives(specie) ) then
              if ( fwdModelConf%do_freq_avg ) then
                do i = 1, noUsedChannels
                  sigInd = usedSignals(i)
                  channel = usedChannels(i)
                  j = Size(FilterShapes(shapeInd)%FilterGrid(channel,:))
                  centerFreq = firstSignal%lo + thisSideband * &
                    & fwdModelConf%signals(sigInd)%centerFrequency
                  shapeInd = MatchSignal ( filterShapes%signal, &
                    & fwdModelConf%signals(sigInd), &
                    & sideband = thisSideband, channel=channel )
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dv(specie)
                    do surface = 1, no_z_dv(specie)
                      call Freq_Avg ( frequencies,                      &
                        & centerFreq+thisSideband * &
                        & FilterShapes(shapeInd)%FilterGrid(channel,:), &
                        & FilterShapes(shapeInd)%FilterShape(channel,:), &
                        & k_spect_dv_frq(:,sv_i), noFreqs, j, r)
                      k_spect_dv(i,ptg_i,surface,instance,specie) = r
                      sv_i = sv_i + 1
                    end do                ! Surface loop
                  end do                  ! Instance loop
                end do                    ! Channel loop
              else                        ! Else not frequency averaging
                do i = 1, noUsedChannels
                  if(specie == 1) sv_i = 1
                  do instance = 1, no_phi_dv(specie)
                    do surface = 1, no_z_dv(specie)
                      k_spect_dv(i,ptg_i,surface,instance,specie) = &
                        k_spect_dv_frq(1,sv_i)
                      sv_i = sv_i + 1
                    end do
                  end do
                end do
              end if                      ! Frequency averaging or not
            end if                        ! Want derivatives for this
          end do                          ! Loop over species

        end if                        ! Want derivatives for spect

        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_end ( 'ForwardModel.FrequencyAvg' )

        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call trace_end ( 'ForwardModel.Pointing' )

d1455 1
a1455 1

d1460 4
a1463 4

      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_begin ( 'ForwardModel.Convolution' )

d1465 79
d1545 1
a1545 2
      call allocate_test ( superset, size(antennaPatterns), &
        & 'superset', ModuleName )
a1546 1
      do i = 1, noUsedChannels
d1548 1
a1548 6
        channel = usedChannels(i)
        sigInd = usedSignals(i)
        thisRadiance =>  &
          GetVectorQuantityByType (fwdModelOut, quantityType=l_radiance, &
          & signal=fwdModelConf%signals(sigInd)%index, &
          & sideband=firstSignal%sideband )
d1550 9
a1558 5
        if ( sidebandStart /= sidebandStop ) then   ! We're folding
          thisRatio = sidebandRatio%values(channel,1)
          if ( thisSideband == 1 ) thisRatio = 1.0 - thisRatio
        else                  ! Otherwise, want just unfolded signal
          thisRatio = 1.0
d1560 7
a1566 47

        ! Here comes the Convolution codes

        if ( FwdModelConf%do_conv ) then

          do j = 1, size(antennaPatterns)
            superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
              & fwdModelConf%signals, sideband=thisSideband, &
              & channel=channel )
          end do

          if ( all( superset < 0 ) ) &
            call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "No matching antenna patterns." )

          maxSuperset = maxval ( superset )
          where ( superset < 0 )
            superset = maxSuperset + 1
          end where
          whichPatternAsArray = minloc ( superset )
          whichPattern = whichPatternAsArray(1)
          if ( toggle(emit) .and. levels(emit) > 2 ) then
            call output ( 'Using antenna pattern: ' )
            call output ( whichPattern, advance='yes' )
          end if

          center_angle = ptg_angles(surfaceTangentIndex,maf)
          call convolve_all ( fwdModelConf, fwdModelIn, maf, channel, &
            &  windowStart, windowFinish, mafTInstance-windowStart+1, &
            &  temp, ptan, thisRadiance,FwdModelConf%tangentGrid%surfs,&
            &  ptg_angles(:,maf), tan_temp(:,maf), dx_dt, d2x_dxdt,  &
            &  surfaceTangentIndex, center_angle, &
            &  Radiances(:, i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &  thisRatio, Jacobian, fmStat%rows,  &
            &  antennaPatterns(whichPattern), ier )
          !??? Need to choose some index other than 1 for AntennaPatterns ???
          if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'convolve_all failed' )

        else          ! No convolution needed ..

          call no_conv_at_all ( fwdModelConf, fwdModelIn, maf, channel,  &
            &     windowStart, windowFinish, temp, ptan, thisRadiance, &
            &     FwdModelConf%tangentGrid%surfs, &
            &     Radiances(:,i), k_temp(i,:,:,:), k_atmos(i,:,:,:,:), &
            &     thisRatio, Jacobian, fmStat%rows )

d1568 18
a1585 22

      end do                            ! Channel loop

      call deallocate_test ( superset, 'superset', ModuleName )
      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.Convolution' )

      if ( toggle(emit) .and. levels(emit) > 0 ) &
        & call trace_end ( 'ForwardModel.sideband' )

      ! End of loop over sidebands ---------------------------------------------
    end do


    !  **** DEBUG Printing cycle ...

    if ( index(switches,'rad') /= 0 ) then
      ! *** DEBUG Print
      if ( FwdModelConf%do_conv ) then
        print *,'Convolution: ON'
      else
        print *,'Convolution: OFF'
d1587 5
a1591 58

      if ( FwdModelConf%do_freq_avg ) then
        print *,'Frequency Averaging: ON'
      else
        Frq = Frequencies(1)
        print *,'Frequency Averaging: OFF'
        print '(A,f12.4,a)', ' (All computations done at Frq =',Frq,')'
      end if

      print *
      k=ptan%template%noSurfs
      print 901, k
901   format ( 'ptan\ ',i3.3)
      Print 902,Ptan%values(1:k,maf)
902   format ( 4(4x, f10.7))

      print *
      do i = 1, noUsedChannels
        channel = usedChannels(i)
        print 903, channel, char(92), ptan%template%noSurfs
903     format ( 'ch', i2.2, '_pfa_rad', a1, i3.3 )
        print 905, &
          & firstRadiance%values(i:firstRadiance%template%InstanceLen:25,maf)
905     format ( 4(2x, 1pg15.8) )
      end do

    end if

    !  **** End of Printing cycle ...


    ! Now deallocate lots of stuff
    call Deallocate_test ( usedChannels, 'usedChannels', ModuleName )
    call Deallocate_test ( usedSignals, 'usedSignals', ModuleName )
    deallocate ( my_catalog, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'my_catalog' )
    call Deallocate_test ( one_tan_ht, 'one_tan_ht', ModuleName )
    call Deallocate_test ( one_tan_temp, 'one_tan_temp', ModuleName )

    deallocate ( k_temp, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_temp' )
    deallocate ( k_atmos, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_atmos' )
    deallocate ( k_spect_dw, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dw' )
    deallocate ( k_spect_dn, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dn' )
    deallocate ( k_spect_dv, stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'k_spect_dv' )

    ! DESTROY THE SPS DATA STUFF

d1594 1
a1594 68

    call Deallocate_test ( h_glgrid, 'h_glgrid', ModuleName )
    call Deallocate_test ( t_glgrid, 't_glgrid', ModuleName )
    call Deallocate_test ( dhdz_glgrid, 'dhdz_glgrid', ModuleName )
    call Deallocate_test ( dh_dt_glgrid, 'dh_dt_glgrid', ModuleName )

    call Deallocate_test ( tan_inds, 'tan_inds', ModuleName )
    call Deallocate_test ( tan_temp, 'tan_temp', ModuleName )

    call DestroyCompleteSlabs ( gl_slabs )
    call DestroyCompleteSlabs ( gl_slabs_p )
    call DestroyCompleteSlabs ( gl_slabs_m )

    call Deallocate_test ( dhdz_path, 'dhdz_path', ModuleName )
    call Deallocate_test ( h_path,    'h_path',    ModuleName )
    call Deallocate_test ( p_path,    'p_path',    ModuleName )
    call Deallocate_test ( path_dsdh, 'path_dsdh', ModuleName )
    call Deallocate_test ( phi_path,  'phi_path',  ModuleName )
    call Deallocate_test ( t_path,    't_path',    ModuleName )
    call Deallocate_test ( z_path,    'z_path',    ModuleName )

    call Deallocate_test ( alpha_path_c, 'alpha_path_c', ModuleName )
    call Deallocate_test ( incoptdepth,  'incoptdept',   ModuleName )
    call Deallocate_test ( t_script,     't_script',     ModuleName )
    call Deallocate_test ( tau,          'tau',          ModuleName )
    call Deallocate_test ( del_s,        'del_s',        ModuleName )
    call Deallocate_test ( do_gl,        'do_gl',        ModuleName )
    call Deallocate_test ( ext_ind_c,    'ext_ind_c',    ModuleName )
    call Deallocate_test ( n_path,       'n_path',       ModuleName )
    call Deallocate_test ( ref_corr,     'ref_corr',     ModuleName )

    call Deallocate_test ( beta_path_c, 'beta_path_c', ModuleName )
    call Deallocate_test ( do_calc, 'do_calc', ModuleName )
    call Deallocate_test ( eta_zxp, 'eta_zxp', ModuleName )
    call Deallocate_test ( sps_path, 'sps_path', ModuleName )

    if(FwdModelConf%temp_der) then
      call Deallocate_test ( dRad_dt, 'dRad_dt', ModuleName )
      call Deallocate_test ( dbeta_dt_path_c, 'dbeta_dt_path_c', ModuleName )
      call Deallocate_test ( dh_dt_path, 'dh_dt_path', ModuleName )
      call Deallocate_test ( do_calc_hyd, 'do_calc_hyd', ModuleName )
      call Deallocate_test ( do_calc_t, 'do_calc_t', ModuleName )
      call Deallocate_test ( eta_zxp_t, 'eta_zxp_t', ModuleName )
      call Deallocate_test ( tan_dh_dt, 'tan_dh_dt', ModuleName )
    endif

    if ( FwdModelConf%atmos_der ) then
      call Deallocate_test ( dRad_df, 'dRad_df', ModuleName )
    end if

    if(FwdModelConf%spect_der) then
      call Deallocate_test ( dbeta_dw_path_c, 'dbeta_dw_path_c', ModuleName )
      call Deallocate_test ( dbeta_dn_path_c, 'dbeta_dn_path_c', ModuleName )
      call Deallocate_test ( dbeta_dv_path_c, 'dbeta_dv_path_c', ModuleName )

      ! MORE STUFF TO COME I SUSPECT 
    endif

    call Deallocate_test ( ptg_angles, 'ptg_angles', ModuleName )
    call Deallocate_test ( radiances, 'radiances', ModuleName )
    call Deallocate_test ( dx_dt, 'dx_dt', ModuleName )
    call Deallocate_test ( d2x_dxdt, 'd2x_dxdt', ModuleName )

    ! Deallocate all variables allocated earlier -----------------------------

    if ( maf == noMAFs ) fmStat%finished = .true.


a1599 3
! Revision 1.5.2.50  2001/09/13 00:42:18  livesey
! Fixed memory leak

d1602 1
a1602 1

d1605 1
a1605 1

d1608 1
a1608 1

d1611 1
a1611 1

d1614 1
a1614 1

d1617 1
a1617 1

d1620 1
a1620 1

d1623 1
a1623 1

d1626 1
a1626 1

d1629 1
a1629 1

d1632 1
a1632 1

d1635 1
a1635 1

d1638 1
a1638 1

d1641 1
a1641 1

d1644 1
a1644 1

d1647 1
a1647 1

d1650 1
a1650 1

d1653 1
a1653 1

d1656 1
a1656 1

d1659 1
a1659 1

d1662 1
a1662 1

d1665 1
a1665 1

d1668 1
a1668 1

d1671 1
a1671 1

d1674 1
a1674 1

d1677 1
a1677 1

d1680 1
a1680 1

d1683 1
a1683 1

d1686 1
a1686 1

d1689 1
a1689 1

d1692 1
a1692 1

d1695 1
a1695 1

d1698 1
a1698 1

d1701 1
a1701 1

d1704 1
a1704 1

d1707 1
a1707 1

d1710 1
a1710 1

d1713 1
a1713 1

d1716 1
a1716 1

d1719 1
a1719 1

d1722 1
a1722 1

d1725 1
a1725 1

d1728 1
a1728 1

d1731 1
a1731 1

d1734 1
a1734 1

d1737 1
a1737 1

d1740 1
a1740 1

d1743 1
a1743 1

d1746 1
a1746 1

d1749 1
a1749 1

d1752 1
a1752 1

d1755 1
a1755 1

@


1.5.2.52
log
@Left a print statement in by mistake
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.51 2001/09/13 01:48:39 livesey Exp $"
d829 4
d1187 1
a1187 2

          if ( FwdModelConf%temp_der ) &
d1190 1
a1190 2

          if ( FwdModelConf%spect_der ) then
a1200 1
        
a1713 4
! Revision 1.5.2.51  2001/09/13 01:48:39  livesey
! Added lots of deallocates, slight problem with temperature derivatives
! and convolution.
!
@


1.5.2.53
log
@Fix temp. derv. bug
@
text
@d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.52 2001/09/13 02:03:08 livesey Exp $"
d675 21
a695 15
      sv_dw_len = SUM(no_z_dw(:) * no_phi_dw(:))
      sv_dn_len = SUM(no_z_dn(:) * no_phi_dn(:))
      sv_dv_len = SUM(no_z_dv(:) * no_phi_dv(:))

      call Allocate_test ( do_calc_dw, no_ele, sv_dw_len, 'do_calc_dw', ModuleName )
      call Allocate_test ( do_calc_dn, no_ele, sv_dn_len, 'do_calc_dn', ModuleName )
      call Allocate_test ( do_calc_dv, no_ele, sv_dv_len, 'do_calc_dv', ModuleName )

      call Allocate_test ( eta_zxp_dw, no_ele, sv_dw_len, 'eta_zxp_dw', ModuleName )
      call Allocate_test ( eta_zxp_dn, no_ele, sv_dn_len, 'eta_zxp_dn', ModuleName )
      call Allocate_test ( eta_zxp_dv, no_ele, sv_dv_len, 'eta_zxp_dv', ModuleName )

      call Allocate_test ( drad_dw, sv_dw_len, 'drad_dw', ModuleName )
      call Allocate_test ( drad_dn, sv_dn_len, 'drad_dn', ModuleName )
      call Allocate_test ( drad_dv, sv_dv_len, 'drad_dv', ModuleName )
a795 1

d798 1
a798 2

!       print*,'ptg_i=',ptg_i
d916 8
a923 11
        if(FwdModelConf%temp_der) then
          call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2),    &
          &    one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf), &
          &    tan_dh_dt(1,:), temp%template%surfs(:,1),                    &
          &    temp%template%geodLat(1,:)*Deg2Rad, one_tan_temp(1),         &
          &    fwdModelConf%tangentGrid%surfs(ptg_i),dx_dt(ptg_i,:),        &
          &    d2x_dxdt(ptg_i,:))
        else
          call get_chi_angles(0.001*scGeocAlt%values(1,1),n_path(npc/2), &
          &    one_tan_ht(1),phi_tan,Req,elev_offset,ptg_angles(ptg_i,maf))
        endif
d1142 1
a1142 1
            ! Spectroscopic derivative  wrt: W
a1605 3
933   format ( 5(2x, 1pg13.6) )
934   format (A,i2.2,A1,i5.5)

d1610 1
a1690 1

d1695 1
a1695 12
      call Deallocate_test ( do_calc_dw, 'do_calc_dw', ModuleName )
      call Deallocate_test ( do_calc_dn, 'do_calc_dn', ModuleName )
      call Deallocate_test ( do_calc_dv, 'do_calc_dv', ModuleName )

      call Deallocate_test ( eta_zxp_dw, 'eta_zxp_dw', ModuleName )
      call Deallocate_test ( eta_zxp_dn, 'eta_zxp_dn', ModuleName )
      call Deallocate_test ( eta_zxp_dv, 'eta_zxp_dv', ModuleName )

      call Deallocate_test ( drad_dw, 'drad_dw', ModuleName )
      call Deallocate_test ( drad_dn, 'drad_dn', ModuleName )
      call Deallocate_test ( drad_dv, 'drad_dv', ModuleName )

a1712 3
! Revision 1.5.2.52  2001/09/13 02:03:08  livesey
! Left a print statement in by mistake
!
@


1.5.2.54
log
@Added some more useful diagnotics/trace statements
@
text
@a49 1
  use Trace_M, only: Trace_begin, Trace_end
d60 1
a60 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.53 2001/09/13 11:18:15 zvi Exp $"
d305 1
a305 2
    if ( toggle(emit) ) &
      & call trace_begin ( 'ForwardModel, MAF=', index=fmstat%maf )
a557 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_Begin ( 'ForwardModel.Hydrostatic' )
a699 6
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_End ( 'ForwardModel.Hydrostatic' )

    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_Begin ( 'ForwardModel.SidebandLoop' )

a701 3
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call Trace_Begin ( 'ForwardModel.Sideband ', index=thisSideband )

d727 5
a789 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call Trace_Begin ( 'ForwardModel.PointingLoop' )
d793 2
a794 2
        if ( toggle(emit) .and. levels(emit) > 3 ) &
          & call Trace_Begin ( 'ForwardModel.Pointing ', index=ptg_i )
a814 3
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.MetricsEtc' )

a964 5
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_End ( 'ForwardModel.MetricsEtc' )

        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_Begin ( 'ForwardModel.FrequencyLoop' )
a966 2
          if ( toggle(emit) .and. levels(emit) > 5 ) &
            & call Trace_Begin ('ForwardModel.Frequency ',index=frq_i)
d1017 2
a1018 7
          
          nullify ( gl_inds, beta_path_f, gl_indgen, gl_ndx )
          call Allocate_test ( gl_inds, j, 'gl_inds', ModuleName )
          call Allocate_test ( beta_path_f, j, noSpecies, 'beta_path_f', ModuleName )
          call Allocate_test ( gl_indgen, Ng, no_gl_ndx, 'gl_indgen', ModuleName )
          call Allocate_test ( gl_ndx, no_gl_ndx, 2, 'gl_ndx', ModuleName )

a1181 1
          call Deallocate_Test ( gl_indgen, 'gl_indgen', ModuleName )
a1194 2
          if ( toggle(emit) .and. levels(emit) > 5 ) &
            & call Trace_End ('ForwardModel.Frequency ',index=frq_i)
a1196 3
        if ( toggle(emit) .and. levels(emit) > 4 ) &
          & call Trace_End ( 'ForwardModel.FrequencyLoop' )

d1205 1
a1205 1
        if ( toggle(emit) .and. levels(emit) > 4 ) &
d1211 9
d1227 5
d1472 1
a1472 1
        if ( toggle(emit) .and. levels(emit) > 4 ) &
d1475 2
a1476 2
        if ( toggle(emit) .and. levels(emit) > 3 ) &
          & call trace_end ( 'ForwardModel.Pointing ', index=ptg_i )
d1479 1
a1481 2
      if ( toggle(emit) .and. levels(emit) > 2 ) &
        & call Trace_End ( 'ForwardModel.PointingLoop' )
d1485 1
a1485 1
      if ( toggle(emit) .and. levels(emit) > 2 ) &
d1529 4
d1560 1
a1560 1
      if ( toggle(emit) .and. levels(emit) > 2 ) &
d1563 2
a1564 2
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call trace_end ( 'ForwardModel.sideband ',index=thisSideband )
d1568 1
a1568 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &
      & call Trace_End ( 'ForwardModel.SidebandLoop' )
d1651 2
a1652 4
    if ( fwdModelConf%temp_der ) then
      call DestroyCompleteSlabs ( gl_slabs_p )
      call DestroyCompleteSlabs ( gl_slabs_m )
    end if
a1719 3
    if ( toggle(emit) ) then
      call trace_end ( 'ForwardModel MAF=',fmStat%maf )
    end if
a1725 3
! Revision 1.5.2.53  2001/09/13 11:18:15  zvi
! Fix temp. derv. bug
!
@


1.5.2.55
log
@Fixed a small memory leak
@
text
@d61 1
a61 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.54 2001/09/13 19:36:27 livesey Exp $"
d1038 1
d1066 2
d1086 1
d1097 1
a1576 16

      ! Deallocate maxNoFreqs stuff
      call Deallocate_test ( radv, 'radV', ModuleName )

      if ( fwdModelConf%temp_der ) &
        & call Deallocate_test ( k_temp_frq, 'k_temp_frq', ModuleName )

      if (fwdModelConf%atmos_der) &
        & call Deallocate_test ( k_atmos_frq, 'k_atmos_frq', ModuleName )

      if (fwdModelConf%spect_der) then
        call Deallocate_test ( k_spect_dw_frq, 'k_spect_dw_frq', ModuleName )
        call Deallocate_test ( k_spect_dn_frq, 'k_spect_dn_frq', ModuleName )
        call Deallocate_test ( k_spect_dv_frq, 'k_spect_dv_frq', ModuleName )
      endif

a1745 3
! Revision 1.5.2.54  2001/09/13 19:36:27  livesey
! Added some more useful diagnotics/trace statements
!
@


1.5.2.56
log
@Fixed bug with sv_i in frequency averaging of k_atmos_frq
@
text
@a51 1
  use Dump_0, only: DUMP
d61 1
a61 1
    & "$Id: FullForwardModel_m.f90,v 1.5.2.55 2001/09/13 19:57:43 livesey Exp $"
a145 1
    integer :: SV_START                 ! Temporary sv_i
d1304 1
a1304 2
          
          sv_i = 1
a1307 1
                sv_start = sv_i
a1308 1
                  sv_i = sv_start
d1317 1
d1324 1
a1324 1
                        & k_atmos_frq(1:noFreqs,sv_i), noFreqs, j, r )
a1330 1
                sv_start = sv_i
d1332 1
a1332 1
                  sv_i = sv_start
a1756 3
! Revision 1.5.2.55  2001/09/13 19:57:43  livesey
! Fixed a small memory leak
!
@


1.4
log
@Fixing some memory leaks..
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.3 2001/06/21 15:05:42 livesey Exp $"
d878 1
a878 2
              &  ifm%z_path(k,maf),ifm%h_path(k,maf),&
              &  ifm%t_path(k,maf),ifm%phi_path(k,maf),                  &
d883 1
a883 1
              &  midval_delta,Sps_zeta_loop(:,k),Sps_phi_loop(:,k),Rad,Ier)
d1295 3
@


1.3
log
@Gets tolerance from fwdModelConf
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.2 2001/06/21 13:07:08 zvi Exp $"
d196 1
a196 1
    real(r8), dimension(:,:),  pointer :: midval_delta   ! (N2lvl,Nsps)
d294 1
a294 1
    max_nl = 1 
d538 2
a539 1
          thisRadiance%values( ch + (j-1)*thisRadiance%template%noChans, fmStat%maf) = 0.0
a558 1

d849 2
a850 2
            Call path_contrib(tau, brkpt, no_ele, fwdModelConf%tolerance, mid, midval_ndx, &
              &  no_midval_ndx, gl_ndx, no_gl_ndx, Ier)
d1039 34
d1074 4
d1162 1
a1173 12
      if ( associated(beta_path) ) then
        do i = 1, size(beta_path,1)
          do j = 1, size(beta_path,2)
            deallocate ( beta_path(i,j)%values, beta_path(i,j)%t_power, &
              & beta_path(i,j)%dbeta_dw, beta_path(i,j)%dbeta_dn, &
              & beta_path(i,j)%dbeta_dnu, STAT=k )
          end do
        end do
      end if

      deallocate ( beta_path, STAT=k )

d1256 1
d1296 3
a1303 1
!
@


1.2
log
@Speed enhancement MAJOR update
@
text
@d62 1
a62 1
    & "$Id: FullForwardModel_m.f90,v 1.1 2001/05/29 22:53:51 livesey Exp $"
a193 1
    real(r8) :: tol
a346 3
    tol = +0.2
!   tol = -0.2

d359 1
a359 1
      print*,'tol:',tol
d849 1
a849 1
            Call path_contrib(tau, brkpt, no_ele, tol, mid, midval_ndx, &
d1268 3
@


1.1
log
@First version, taken from old ForwardModelInterface.f90
@
text
@d6 1
a6 1
  use GL6P, only: NG
d8 1
a8 1
  use L2PC_PFA_STRUCTURES, only: K_MATRIX_INFO
d14 1
a14 1
    PATH_DERIVATIVE, PATH_VECTOR_2D
d17 1
a17 1
  use GET_BETA_PATH_M, only: GET_BETA_PATH
d19 2
d23 1
d29 2
a30 2
  use VectorsModule, only: VECTOR_T, VECTORVALUE_T, VALIDATEVECTORQUANTITY,&
    & GETVECTORQUANTITYBYTYPE
d32 2
a33 1
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, FORWARDMODELSTATUS_T
d41 3
a43 3
  use Intrinsic, only: L_TEMPERATURE, L_VMR, L_RADIANCE, L_PTAN, L_ELEVOFFSET, &
    & L_ORBITINCLINATION, L_SPACERADIANCE, L_EARTHREFL, L_REFGPH, L_LOSVEL, &
    & L_SCGEOCALT, L_SIDEBANDRATIO, L_NONE, L_CHANNEL
d60 1
a60 1
  !---------------------------- RCS Ident Info ------------------------------- 
d62 1
a62 1
    & "$Id: ForwardModelInterface.f90,v 2.136 2001/05/25 20:25:56 livesey Exp $"
d65 1
a65 1
    & "$RCSfile: ForwardModelInterface.f90,v $"
a95 4
    !    real(r4) :: K_STAR_ALL(25,20,mxco,mnp,Nptg)
    !    type(k_matrix_info) :: K_star_info(20)


d182 1
a182 1
    integer, dimension(1) :: WHICHPATTERNASARRAY ! Result of minloc
d188 13
d216 1
a216 1
      & tau, usedChannels, usedSignals )
d295 1
d301 3
a303 1
          exit
a341 1
    maxVert = 2 * (NG+1) * size(FwdModelConf%integrationGrid%surfs)
d344 2
d348 3
d363 1
d478 1
a478 1
        &  temp%template%phi(1,:)*Deg2Rad, noMAFs, phiWindow, ifm%elvar, Ier )
d504 3
d522 7
d672 2
a673 2
          &  ifm%z_path(:,maf), ifm%t_path(:,maf), ifm%phi_path(:,maf), n_path, &
          &  spsfunc_path, Ier )
d756 11
d770 1
d775 1
d779 4
d784 1
a784 1
          ! Compute the beta's along the path, for this tanget hight and this mmaf:
d786 1
d788 7
d803 8
a810 6
          call get_beta_path ( frequencies, my_Catalog, no_ele, &
            &                  ifm%z_path(ptg_i,maf), ifm%t_path(ptg_i,maf), &
            &                  beta_path, 0.001*losVel%values(1,maf), &
            &                  fwdModelConf%frqGap,             &
            &                  fwdModelConf%temp_der,           &
            &                  fwdModelConf%spect_der, Ier)
d812 13
a824 2
            & 'get_beta_path failed' )

d852 13
a864 1

d870 7
a876 8

            Call Rad_Tran ( ifm%elvar(maf), Frq, &
              & fwdModelConf%integrationGrid%noSurfs, h_tan, &
              & noSpecies, ifm%ndx_path(k,maf), ifm%z_path(k,maf), &
              & ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
              & ifm%dHdz_path(k,maf), earthRefl%values(1,1), beta_path(:,frq_i), &
              & spsfunc_path(:,k), ref_corr(:,k), spaceRadiance%values(1,1), &
              & brkpt, no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier )
d878 12
d897 13
a909 10
            Call Rad_Tran_WD ( FwdModelConf, FwdModelExtra, FwdModelIn, &
              &  ifm%elvar(maf), frq_i, Frq, noSpecies, ifm%z_path(k,maf), &
              &  ifm%h_path(k,maf), ifm%t_path(k,maf), ifm%phi_path(k,maf), &
              &  ifm%dHdz_path(k,maf), beta_path(:,frq_i), spsfunc_path(:, &
              &  k), temp%template%surfs(:,1), temp%template%noSurfs, &
              &  ref_corr(:,k), temp%template%noInstances, &
              &  temp%template%phi(1,:)*Deg2Rad, dh_dt_path, k_temp_frq, &
              &  k_atmos_frq, brkpt, no_ele, mid, ilo, ihi, t_script, tau, &
              &  max_zeta_dim, max_phi_dim, ier )
            if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d914 1
d1155 1
a1155 1
          call deallocate_test ( k_atmos_frq(j)%values, "k_atmos_frq(j)%values", &
d1171 1
d1173 1
a1173 1
          print '(A,f12.4,a)', ' (All computations done at Frq =',Frequencies(1),')'
d1175 1
d1177 5
d1183 1
d1202 6
d1219 7
d1258 1
a1258 1
    
d1271 4
a1274 1
! $Log$
@

