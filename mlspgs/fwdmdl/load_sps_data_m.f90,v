head	2.122;
access;
symbols
	v5-02-NRT-19:2.122
	v6-00:2.122
	v5-02-NRT-18:2.122
	v5-02:2.122
	v5-01-NRT-17:2.122
	v5-01-NRT-16:2.122
	v5-01-NRT-15:2.122
	v5-01-NRT-14:2.122
	neuralnetworks-1-0:2.122.0.10
	cfm-single-freq-0-1:2.122.0.8
	v5-01:2.122
	v5-00:2.122
	v4-23-TA133:2.122.0.6
	mus-emls-1-70:2.122.0.4
	rel-1-0-englocks-work:2.122.0.2
	VUMLS1-00:2.119
	VPL1-00:2.113
	V4-22-NRT-08:2.110
	VAM1-00:2.104
	V4-21:2.92.0.2
	V4-13:2.92
	V4-12:2.91
	V4-11:2.90
	V4-10:2.90
	V3-43:2.75
	M4-00:2.88
	V3-41:2.75
	V3-40-PlusGM57:2.75.0.2
	V2-24-NRT-04:2.68
	V3-33:2.80
	V2-24:2.68
	V3-31:2.80
	V3-30-NRT-05:2.76
	cfm-01-00:2.76
	V3-30:2.75
	V3-20:2.75
	V3-10:2.74
	V2-23-NRT-02:2.68
	V2-23:2.68
	V2-22-NRT-01:2.68
	V2-22:2.68
	V2-21:2.67
	V2-20:2.67
	V2-11:2.67
	V2-10:2.67
	V2-00:2.66
	V1-51:2.61
	V1-50:2.61
	V1-45:2.60
	V1-44:2.60
	V1-43:2.58
	V1-32:2.53
	V1-31:2.53
	V1-30:2.53
	V1-13:2.44
	V1-12:2.44
	V1-11:2.44
	V1-10:2.38
	newfwm-feb03:2.42.0.2
	V1-04:2.15
	V1-03:2.15
	V1-02:2.15
	JointForwardModel:2.19.0.2
	V1-00:2.15
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.122
date	2018.01.30.02.52.57;	author vsnyder;	state Exp;
branches;
next	2.121;

2.121
date	2017.11.03.20.57.45;	author pwagner;	state Exp;
branches;
next	2.120;

2.120
date	2017.03.11.00.57.54;	author vsnyder;	state Exp;
branches;
next	2.119;

2.119
date	2017.03.02.00.31.58;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2017.02.04.02.13.56;	author vsnyder;	state Exp;
branches;
next	2.117;

2.117
date	2017.01.21.03.09.39;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2016.11.02.01.30.46;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2016.09.21.00.14.20;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2016.08.30.20.29.36;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2016.08.23.00.43.11;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2016.06.03.23.44.05;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2016.05.27.01.26.01;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2016.05.16.23.22.30;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2016.05.12.15.20.50;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2016.05.10.00.11.33;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2016.05.10.00.00.32;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2016.05.02.23.31.32;	author vsnyder;	state Exp;
branches;
next	2.105;

2.105
date	2015.10.28.00.32.12;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2015.09.22.23.18.23;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2015.08.25.18.42.03;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2015.07.27.22.37.22;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2015.07.08.01.25.35;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2015.06.02.23.50.21;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2015.05.28.23.21.38;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2015.05.28.23.12.37;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2015.05.15.23.40.02;	author vsnyder;	state Exp;
branches;
next	2.96;

2.96
date	2015.05.12.20.53.07;	author vsnyder;	state Exp;
branches;
next	2.95;

2.95
date	2015.05.01.02.08.10;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2015.04.11.01.26.44;	author vsnyder;	state Exp;
branches;
next	2.93;

2.93
date	2015.03.28.02.10.58;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2014.08.01.01.03.45;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2014.07.18.23.16.28;	author pwagner;	state Exp;
branches;
next	2.90;

2.90
date	2014.04.22.00.08.27;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2013.08.08.02.36.03;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2012.08.08.20.08.43;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2011.11.11.00.40.17;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2011.08.25.22.37.36;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2011.08.20.02.07.34;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2011.08.20.00.45.33;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2011.07.29.01.50.20;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2011.07.08.20.58.18;	author yanovsky;	state Exp;
branches;
next	2.81;

2.81
date	2011.04.28.00.14.24;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2011.02.12.03.02.04;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2011.02.05.01.17.17;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2010.12.07.01.06.24;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2010.09.25.01.13.35;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2010.06.07.23.22.53;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2009.12.22.02.13.38;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.73;

2.73
date	2009.05.13.20.03.02;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2009.01.16.23.38.32;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2008.10.03.16.30.31;	author livesey;	state Exp;
branches;
next	2.70;

2.70
date	2008.06.06.22.51.44;	author pwagner;	state Exp;
branches;
next	2.69;

2.69
date	2008.05.20.00.15.07;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2006.12.04.21.17.28;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2006.07.21.00.18.09;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2006.04.05.21.46.44;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2006.01.05.03.26.09;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2005.09.16.23.41.45;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2005.08.03.18.04.09;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2004.11.01.20.26.36;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2004.08.03.02.24.21;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2004.07.08.21.00.23;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2004.03.30.00.55.30;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2004.03.20.01.15.29;	author jonathan;	state Exp;
branches;
next	2.56;

2.56
date	2004.03.01.19.21.46;	author jonathan;	state Exp;
branches;
next	2.55;

2.55
date	2004.02.03.02.46.39;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2004.01.23.19.13.10;	author jonathan;	state Exp;
branches;
next	2.53;

2.53
date	2003.05.19.19.58.07;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2003.05.16.23.52.26;	author livesey;	state Exp;
branches;
next	2.51;

2.51
date	2003.05.16.02.47.12;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2003.05.08.23.42.50;	author livesey;	state Exp;
branches;
next	2.49;

2.49
date	2003.05.06.23.36.59;	author dwu;	state Exp;
branches;
next	2.48;

2.48
date	2003.05.06.20.35.34;	author livesey;	state Exp;
branches;
next	2.47;

2.47
date	2003.05.06.20.23.21;	author livesey;	state Exp;
branches;
next	2.46;

2.46
date	2003.05.05.23.00.25;	author livesey;	state Exp;
branches;
next	2.45;

2.45
date	2003.04.22.00.14.20;	author dwu;	state Exp;
branches;
next	2.44;

2.44
date	2003.02.14.17.53.34;	author pwagner;	state Exp;
branches;
next	2.43;

2.43
date	2003.02.13.01.26.55;	author dwu;	state Exp;
branches;
next	2.42;

2.42
date	2003.02.13.00.42.46;	author dwu;	state Exp;
branches
	2.42.2.1;
next	2.41;

2.41
date	2003.02.13.00.07.22;	author jonathan;	state Exp;
branches;
next	2.40;

2.40
date	2003.02.12.23.50.49;	author jonathan;	state Exp;
branches;
next	2.39;

2.39
date	2003.02.11.00.48.25;	author jonathan;	state Exp;
branches;
next	2.38;

2.38
date	2003.02.07.18.47.47;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2003.02.07.18.06.23;	author jonathan;	state Exp;
branches;
next	2.36;

2.36
date	2003.02.07.18.01.20;	author jonathan;	state Exp;
branches;
next	2.35;

2.35
date	2003.02.07.03.30.37;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2003.02.07.02.00.48;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2003.02.07.01.07.53;	author jonathan;	state Exp;
branches;
next	2.32;

2.32
date	2003.02.06.20.00.06;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2003.01.26.04.42.42;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2002.11.23.02.49.33;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2002.10.08.17.08.05;	author pwagner;	state Exp;
branches;
next	2.28;

2.28
date	2002.10.03.05.37.53;	author livesey;	state Exp;
branches;
next	2.27;

2.27
date	2002.10.02.22.42.39;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2002.09.26.18.02.10;	author livesey;	state Exp;
branches;
next	2.25;

2.25
date	2002.09.24.21.37.01;	author livesey;	state Exp;
branches;
next	2.24;

2.24
date	2002.09.05.20.48.59;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2002.08.22.23.13.45;	author livesey;	state Exp;
branches;
next	2.22;

2.22
date	2002.08.20.22.37.34;	author livesey;	state Exp;
branches;
next	2.21;

2.21
date	2002.07.08.17.45.41;	author zvi;	state Exp;
branches;
next	2.20;

2.20
date	2002.07.05.07.52.49;	author zvi;	state Exp;
branches;
next	2.19;

2.19
date	2002.06.19.11.00.34;	author zvi;	state Exp;
branches;
next	2.18;

2.18
date	2002.06.14.22.51.38;	author bill;	state Exp;
branches;
next	2.17;

2.17
date	2002.06.13.22.39.12;	author bill;	state Exp;
branches;
next	2.16;

2.16
date	2002.06.04.10.28.03;	author zvi;	state Exp;
branches;
next	2.15;

2.15
date	2002.02.20.22.19.46;	author zvi;	state Exp;
branches;
next	2.14;

2.14
date	2002.02.16.20.43.54;	author zvi;	state Exp;
branches;
next	2.13;

2.13
date	2002.02.16.10.32.17;	author zvi;	state Exp;
branches;
next	2.12;

2.12
date	2002.02.16.06.37.34;	author zvi;	state Exp;
branches;
next	2.11;

2.11
date	2002.02.08.00.46.04;	author zvi;	state Exp;
branches;
next	2.10;

2.10
date	2002.01.30.01.11.20;	author zvi;	state Exp;
branches;
next	2.9;

2.9
date	2002.01.27.08.37.49;	author zvi;	state Exp;
branches;
next	2.8;

2.8
date	2002.01.09.00.30.48;	author zvi;	state Exp;
branches;
next	2.7;

2.7
date	2002.01.08.01.02.54;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2001.12.14.23.43.24;	author zvi;	state Exp;
branches;
next	2.5;

2.5
date	2001.11.15.01.21.59;	author zvi;	state Exp;
branches;
next	2.4;

2.4
date	2001.11.10.00.46.40;	author zvi;	state Exp;
branches;
next	2.3;

2.3
date	2001.11.08.09.56.59;	author zvi;	state Exp;
branches;
next	2.2;

2.2
date	2001.11.08.00.10.13;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.11.02.10.48.39;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.07.19.56.41;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

2.42.2.1
date	2003.02.13.18.33.18;	author dwu;	state Exp;
branches;
next	2.42.2.2;

2.42.2.2
date	2003.02.14.18.11.43;	author pwagner;	state Exp;
branches;
next	2.42.2.3;

2.42.2.3
date	2003.03.06.21.53.09;	author vsnyder;	state Exp;
branches;
next	2.42.2.4;

2.42.2.4
date	2003.03.08.00.03.08;	author vsnyder;	state Exp;
branches;
next	2.42.2.5;

2.42.2.5
date	2003.03.20.01.42.26;	author vsnyder;	state Exp;
branches;
next	2.42.2.6;

2.42.2.6
date	2003.03.20.19.21.05;	author vsnyder;	state Exp;
branches;
next	2.42.2.7;

2.42.2.7
date	2003.03.21.02.48.54;	author vsnyder;	state Exp;
branches;
next	;

1.1.2.1
date	2001.09.07.19.56.41;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.07.20.16.28;	author livesey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.07.20.41.42;	author livesey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.09.08.18.30.49;	author zvi;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.09.08.20.19.48;	author zvi;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.09.08.20.22.00;	author zvi;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2001.09.08.22.37.11;	author zvi;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2001.09.08.22.43.37;	author zvi;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2001.09.08.23.11.41;	author zvi;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2001.09.12.21.38.51;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.122
log
@Add L_ZP component
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Load_SPS_Data_M

  use ForwardModelConfig, only: QtyStuff_T
  use MLSCommon, only: R8, RP

  implicit NONE

  private
  public :: Load_Sps_Data, Load_One_Item_Grid, Load_Grid_From_Vector
  public :: Modify_Values_For_Supersat
  public :: Create_Grids_1, Create_Grids_2, Fill_Grids_1, Fill_Grids_2
  public :: FindInGrid, Get_SPS_Bounds
  public :: EmptyGrids_t, Destroygrids_t, Dump, Dump_Grids

  type, public :: C_t ! "Contents" type, to get an array of pointers
    real(rp), pointer, contiguous :: V1(:) => NULL()      ! Frq * Zeta * Phi * Cross
    real(rp), pointer, contiguous :: V4(:,:,:,:) => NULL() ! Frq X Zeta X Phi X Cross
    logical, pointer, contiguous :: L1(:) => NULL()       ! Frq * Zeta * Phi * Cross
    logical, pointer, contiguous :: L4(:,:,:,:) => NULL() ! Frq X Zeta X Phi X Cross
  end type C_t

  type, public :: Grids_T                 ! Fit all Gridding categories
    type(qtyStuff_t), pointer :: QtyStuff(:) => null()
    integer,  pointer :: l_f(:) => null() ! Last entry in frq_basis per sps
    integer,  pointer :: l_p(:) => null() ! Last entry in phi_basis per sps
    integer,  pointer :: l_v(:) => null() ! Last entry in values per sps
    integer,  pointer :: l_x(:) => null() ! Last entry in cross angles per sps
    integer,  pointer :: l_z(:) => null() ! Last entry in zet_basis per sps
    integer,  pointer :: l_zp(:) => null() ! Last entry in Zeta x Phi per sps;
                                          ! Not the same if l_v if there is an
                                          ! earlier frequency-dependent species
    integer :: P_Len = 0 ! \sum_{i=1}^n (l_z(i)-l_z(i-1))*(l_p(i)-l_p(i-1))*
                         !              (l_x(i)-l_x(i-1))
    integer,  pointer :: windowstart(:) => null()! horizontal starting index
                                          ! from l2gp for 2D, or 1 for QTM
    integer,  pointer :: windowfinish(:) => null()! horizontal ending index
                                          ! from l2gp for 2D per sps, or the
                                          ! number of vertices adjacent to the
                                          ! path for QTM
    integer,  pointer :: mol(:) => null()       ! Qty molecule, l_...
    integer,  pointer :: Z_coord(:) => null()   ! l_geo[cd]Altitude, l_zeta
    logical,  pointer :: Coherent(:) => null()  ! From each Qty template
    logical,  pointer :: Stacked(:) => null()   ! From each Qty template
    ! Which column of dBeta_path_df to use for each molecule.
    ! Molecule beta is not dependent upon mixing ratio if zero.
    ! Only nonzero where derivatives for molecules with mixing-ratio-dependent
    ! beta are selected.
    integer,  pointer :: where_dBeta_df(:) => null()
    integer,  pointer :: qty(:) => null() ! Qty type, l_...
    integer,  pointer :: s_ind(:) => null()     ! Indexed by mol, gives index
    ! in l_f etc if qty=l_vmr.
    logical,  pointer :: lin_log(:) => null()   ! true for log representation
                                                ! basis
    real(r8), pointer :: min_val(:) => null()   ! Minimum value
    real(r8), pointer :: frq_basis(:) => null() ! frq  grid entries for all
                                                ! molecules
    real(rp), pointer :: zet_basis(:) => null() ! zeta grid entries for all
                                                ! molecules
    real(rp), pointer :: phi_basis(:) => null() ! phi  grid entries for all
                                                ! molecules, radians
    real(rp), pointer :: cross_angles(:) => null() ! cross-angles grid entries
                                                ! for all molecules, degrees
    real(rp), pointer :: values(:) => null()    ! species values (eg vmr).
    ! For 2D, this is really a four-dimensional quantity dimensioned frequency
    ! (or 1) X zeta (or 1) X phi (or 1) X Cross, taken in Fortran's column-
    ! major array-element order.  For 3D, this is a three-dimensional quantity
    ! dimensioned frequency (or 1) X zeta (or 1) X QTM index, taken in
    ! Fortran's column-major array-element order.
    logical,  pointer :: deriv_flags(:) => null() ! flags to do derivatives,
                                                ! corresponding to the values
    type(c_t), pointer :: C(:) => null()        ! Contents pointers, associated
                                                ! with parts of Values(:) and
                                                ! Deriv_Flags(:).
  contains
    procedure :: IsQTM
  end type Grids_T

  interface Dump
    module procedure Dump_Grids
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: load_sps_data_m.f90,v $"
  private :: not_used_here
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------

  ! ----------------------------------------------  Load_SPS_Data  -----

  subroutine Load_Sps_Data ( FwdModelConf, Phitan, MAF, Grids_x, &
                           & QtyStuffIn, Subset, Short )

    use ForwardModelConfig, only: ForwardModelConfig_t, QtyStuff_T
    use Toggles, only: Emit, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End
    use VectorsModule, only: VectorValue_T

    type (forwardModelConfig_T), intent(in) :: fwdModelConf
    type (vectorValue_T), intent(in) ::  Phitan  ! Tangent geodAngle
    integer, intent(in) :: MAF

    type (Grids_T), intent(out) :: Grids_x     ! All the coordinates

    type (qtyStuff_t), intent(in), optional , target :: QtyStuffIn(:)
    integer, intent(in), optional :: Subset(:) ! Subset of horizontal basis,
                                               ! primarily for QTM
    logical, intent(in), optional :: Short     ! Don't do Fill_Grids_2

    ! Local variables:

    logical :: Long      ! true if short is absent, else .not. short
    integer :: Me = -1   ! String index cache for tracing
    integer :: Mol, No_Mol

    type (qtyStuff_t), pointer :: QtyStuff(:)

    ! Begin code:

    call trace_begin ( me, 'Load_Sps_Data', &
      & cond=toggle(emit) .and. levels(emit) > 2 ) ! set by -f command-line switch

    qtyStuff => fwdModelConf%beta_group%qty
    if ( present(qtyStuffIn) ) qtyStuff => qtyStuffIn

    no_mol = size( qtyStuff )

    ! Stuff that doesn't depend on the numbers of values or lengths of bases
    call create_grids_1 ( Grids_x, no_mol )

    do mol = 1, no_mol

      grids_x%qtyStuff(mol) = qtyStuff(mol)

      if ( .not. associated(qtyStuff(mol)%qty) ) then
        grids_x%l_f(mol) = grids_x%l_f(mol-1)
        grids_x%l_p(mol) = grids_x%l_p(mol-1)
        grids_x%l_v(mol) = grids_x%l_v(mol-1)
        grids_x%l_z(mol) = grids_x%l_z(mol-1)
        grids_x%s_ind(mol) = 0
      else
        call fill_grids_1 ( grids_x, mol, maf, phitan, fwdModelConf, subset )
      end if

    end do

    ! Allocate space for the zeta, phi, freq. basis and value components.

    call create_grids_2 ( Grids_x )

    long = .true.
    if ( present(short) ) long = .not. short
    if ( long ) then
      do mol = 1, no_mol
        ! Fill the zeta, phi, freq. basis and value components.
        if ( associated(qtyStuff(mol)%qty) ) &
          & call fill_grids_2 ( grids_x, mol, qtyStuff(mol)%qty, &
            & fwdModelConf%moleculeDerivatives(mol) .and. &
            & qtyStuff(mol)%derivOK, subset=subset )
      end do
    end if

! ** ZEBUG - Simulate qty%values for EXTINCTION, using the N2 function
!  (Some code here ...)
! ** END ZEBUG

    call trace_end ( 'Load_Species_Data', &
      & cond=toggle(emit) .and. levels(emit) > 2 )

  end subroutine Load_Sps_Data

  ! --------------------------------------  Load_Grid_From_Vector  -----
  subroutine Load_Grid_From_Vector ( Grids_X, Vector, Phitan, Maf, &
    & FwdModelConf, SetDerivFlags )

    use ForwardModelConfig, only: ForwardModelConfig_t
    use VectorsModule, only: Vector_T, VectorValue_t

    type(grids_t), intent(out) :: Grids_X
    type(vector_t), intent(in) :: Vector
    type(vectorValue_t), intent(in), optional :: Phitan
    integer, intent(in), optional :: Maf
    type(forwardModelConfig_t), intent(in), optional :: FwdModelConf
    logical, intent(in), optional :: SetDerivFlags(:) ! size(vector%quantities)

    integer :: I_Qty

    call create_grids_1 ( Grids_x, size(vector%quantities) )
    do i_qty = 1, size(vector%quantities)

     grids_x%qtyStuff(i_qty)%qty => vector%quantities(i_qty)

      if ( present(phitan) ) then
        call fill_grids_1 ( grids_x, i_qty, maf, phitan, fwdModelConf )
      else
        ! Use the whole phi space for the window
        call fill_grids_1 ( grids_x, i_qty, maf )
      end if
    end do

    ! Allocate space for the zeta, phi, freq. basis and value components.
    call create_grids_2 ( Grids_x )

    do i_qty = 1, size(vector%quantities)
      ! Fill the zeta, phi, freq. basis and value components.
      call fill_grids_2 ( grids_x, i_qty, vector%quantities(i_qty), setDerivFlags(i_qty) )
    end do

  end subroutine Load_Grid_From_Vector

  ! -----------------------------------------  Load_One_Item_Grid  -----
  subroutine Load_One_Item_Grid ( Grids_X, Qty, Maf, Phitan, FwdModelConf, &
    & SetDerivFlags, SetTscatFlag, Across, Subset, Short )
  ! A simplification of Load_Sps_Data to load a grid that has only one
  ! quantity in it.

    use ForwardModelConfig, only: ForwardModelConfig_t
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use VectorsModule, only: VectorValue_T

    type(grids_t), intent(out) :: Grids_X
    type(vectorValue_t), intent(in), target :: Qty ! Assumes actual argument
                                                   ! is a pointer or target
    integer, intent(in) :: Maf
    type(vectorValue_t), intent(in), optional :: Phitan
    type(forwardModelConfig_t), intent(in), optional :: FwdModelConf
    logical, intent(in), optional :: SetDerivFlags
    logical, intent(in), optional :: SetTscatFlag
    logical, intent(in), optional :: Across ! Viewing angle is not in orbit plane
    integer, intent(in), optional :: Subset(:) ! Subset of horizontal basis,
                                               ! primarily for QTM
    logical, intent(in), optional :: Short     ! Don't do Fill_Grids_2

    type(vectorValue_t) :: QtyStuff
    logical :: Long      ! true if short is absent, else .not. short
    logical :: MyAcross, MyFlag
    integer :: II, No_Ang

    if ( .not. qty%template%stacked .or. .not. qty%template%coherent ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
         & 'Cannot load a quantity that is unstacked or incoherent' )

    myAcross = .false.
    if ( present(across) ) myAcross = across
    myFlag = .false.
    if ( present(SetTscatFlag) ) myFlag = SetTscatFlag

    if ( myFlag ) then

       no_ang = FwdModelConf%num_scattering_angles

       qtyStuff%template = qty%template     ! having same template as temp

       call create_grids_1 ( grids_x, no_ang )


       do ii = 1, no_ang
         grids_x%qtyStuff(ii)%qty => qty
         call fill_grids_1 ( grids_x, ii, maf, phitan, fwdModelConf )
       end do

       call create_grids_2 ( grids_x )

       do ii = 1, no_ang
         ! ??? Can this work?  In Fill_Grids_2, the second subscript   ???
         ! ??? range for qtyStuff%values is grids_x%windowStart:       ???
         ! ??? grids_x%windowFinish, but qtyStuff%values will have a   ???
         ! ??? shape of [ size(qty%values,1), 1 ].  Perhaps in the     ???
         ! ??? call to Fill_Grids_1 above, WS and WF should have been  ???
         ! ??? specified with the value II, and then all of qty%values ???
         ! ??? should be passed to Fill_Grids_2 here.                  ???
         qtyStuff%values => qty%values(:,ii:ii)
         call fill_grids_2 ( grids_x, ii, qtyStuff, setDerivFlags )
       end do

    else

       call create_grids_1 ( grids_x, 1 )

       grids_x%qtyStuff(1)%qty => qty
       if ( present(phitan) ) then
         call fill_grids_1 ( grids_x, 1, maf, phitan, fwdModelConf, subset )
       else if ( myAcross ) then
         call MLSMessage ( MLSMSG_Error, moduleName, &
         & 'Cross-track viewing needs PhiTan quantity' )
       else
         ! Use the whole phi space for the window
         call fill_grids_1 ( grids_x, 1, maf, subset=subset )
       end if

       call create_grids_2 ( grids_x )

       long = .true.
       if ( present(short) ) long = .not. short
       if ( long ) &
         & call fill_grids_2 ( grids_x, 1, qty, setDerivFlags, subset=subset )

    end if

  end subroutine Load_One_Item_Grid

  ! ---------------------------------  Modify_Values_For_Supersat  -----

  subroutine Modify_Values_For_Supersat ( FwdModelConf, &
    & Grids_f, H2O_Ind, Grids_Tmp, BoundaryPressure )

    use Constants, only: Deg2Rad
    use ForwardModelConfig, only: ForwardModelConfig_t
    use Intrinsic, only: L_Clear_110RH_Below_Top, L_Clear_0RH
    use HyperSlabs, only: EssentiallyEqual
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: Hunt
    use RHIFromH2O, only: RHIFromH2O_Factor
    use VectorsModule, only: VectorValue_T

    type (forwardModelConfig_T) ,intent(in) :: FwdModelConf
    type (grids_T), intent(inout) :: Grids_F   ! All the vmrs
    integer, intent(in) :: H2O_Ind             ! Where is H2O in Grids_f?
    type (grids_T), intent(in) :: Grids_Tmp    ! All the temperatures
    type (vectorValue_T), intent(in) :: BoundaryPressure

    integer :: KF, KZ, KP
    real(r8) :: RHI
    integer :: Supersat_Index
    integer :: WF1, WF2
    integer :: V0               ! One before starting point in Values array
    integer :: Z_index
    integer :: Z0, P, P0
    logical :: Failed

    kf = Grids_f%l_f(h2o_ind) - Grids_f%l_f(h2o_ind-1)
    kz = Grids_f%l_z(h2o_ind) - Grids_f%l_z(h2o_ind-1)
    kp = grids_f%l_p(h2o_ind) - grids_f%l_p(h2o_ind-1)

    v0 = Grids_f%l_v(h2o_ind-1)
    wf1 = Grids_f%windowStart(h2o_ind)
    wf2 = Grids_f%windowFinish(h2o_ind)
    z0 = Grids_f%l_z(h2o_ind-1)
    p0 = Grids_f%l_p(h2o_ind-1)

    ! Here, we have to assert that temperature, h2o and boundarypressure share
    ! the same horizontal and vertical (except boundary pressure) grids.
    failed =  kf /= 1
    failed = failed .or. kf /= grids_tmp%l_f(1) - grids_tmp%l_f(0)
    failed = failed .or. kz /= grids_tmp%l_z(1) - grids_tmp%l_z(0)
    failed = failed .or. &
      & grids_tmp%windowStart(1) /= wf1 .or. grids_tmp%windowFinish(1) /= wf2
    if ( failed ) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'When overwriting H2O, it must share dimensions with temperature' )
    else
      ! Do more checks
      failed = .not. all ( EssentiallyEqual ( &
        & grids_f%zet_basis(z0+1:z0+kz), grids_tmp%zet_basis ) )
      failed = failed .or. .not. all ( EssentiallyEqual ( &
        & grids_f%phi_basis(p0+1:p0+kp), grids_tmp%phi_basis ) )
      if ( failed ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'When overwriting H2O, it must share coordinates with temperature' )
    end if
    ! Check the boundary pressure
    failed = wf1 < 1 .or. wf2 > boundaryPressure%template%noInstances
    if ( .not. failed ) then
      failed = .not. all ( EssentiallyEqual ( &
        & boundaryPressure%template%phi(1,wf1:wf2)*Deg2Rad, grids_tmp%phi_basis ) )
    end if
    if ( failed ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'When overwriting H2O, boundary pressure must share coordinates with temperature' )

    ! To get height index h, profile index p the values are in:
    ! h2o: grids_f%values ( v0 + h + kz*p )
    ! temperature: grids_tmp%values ( h + kz*p )
    ! tpPres: boundaryPressure%values ( 1, p )
    ! zetas (-log pressure) are given by grids_tmp%zet_basis

    select case (FwdModelConf%i_saturation)
      case (l_clear_110RH_below_top)
        RHi = 110._r8              ! 110% supersaturation
      case (l_clear_0RH)
        RHi = 1.e-9_r8             ! 0% dry saturation
      case default
        call MLSMessage(MLSMSG_Error, ModuleName,'invalid i_saturation')
    end select

    ! H2O may have log basis functions
    do p = 1, kp
      ! find the index for the top of saturation levels
      call Hunt (Grids_f%zet_basis(z0+1:z0+kz), -log10(boundaryPressure%values(1,p)), &
        & supersat_Index, 1, nearest=.true.)

      if (supersat_Index < 1 .or. supersat_Index > kz) then
        call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'the top for supersaturation is out of range' )
      else
        if ( Grids_f%lin_log(h2o_ind) ) then
          do z_index = 1, supersat_Index
            Grids_f%values(v0 + z_index + kz*(p-1)) = &
              & log ( RHIFromH2O_Factor ( grids_tmp%values(z_index + kz*(p-1)), &
              &   grids_f%zet_basis(z0+z_index), 0, .true. ) * RHI )
          end do
        else
          do z_index = 1, supersat_Index
            Grids_f%values(v0 + z_index + kz*(p-1)) = &
              & RHIFromH2O_Factor ( grids_tmp%values(z_index + kz*(p-1)), &
              &   grids_f%zet_basis(z0+z_index), 0, .true. ) * RHI
          end do
        end if   ! linear or log basis
      end if     ! check supersat_index
    end do

  end subroutine Modify_Values_For_Supersat

  ! ---------------------------------------------  Create_Grids_1  -----
  subroutine Create_Grids_1 ( Grids_x, N )
  ! Create the part of the Grids_T structure that doesn't depend on the
  ! number of values or lengths of bases

    use Allocate_Deallocate, only: Allocate_test, Test_Allocate
    use Molecules, only: First_Molecule, Last_Molecule

    type (Grids_T), intent(inout) :: Grids_X
    integer, intent(in) :: N

    integer :: Stat

    allocate ( Grids_x%qtyStuff(n), stat=stat )
    call test_allocate ( stat, moduleName, 'Grids_x%QtyStuff' )
    call allocate_test ( Grids_x%l_f, n, 'Grids_x%l_f', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_p, n, 'Grids_x%l_p', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_v, n, 'Grids_x%l_v', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_x, n, 'Grids_x%l_x', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_z, n, 'Grids_x%l_z', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_zp, n, 'Grids_x%l_zp', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%mol, n, 'Grids_x%mol', moduleName )
    call allocate_test ( Grids_x%qty, n, 'Grids_x%qty', moduleName )
    call allocate_test ( Grids_x%where_dBeta_df, n, 'Grids_x%where_dBeta_df', ModuleName )
    call allocate_test ( Grids_x%s_ind, last_molecule, &
      & 'Grids_x%S_ind', moduleName, lowBound=first_molecule, fill=0 )
    grids_x%l_f(0) = 0
    grids_x%l_p(0) = 0
    grids_x%l_v(0) = 0
    grids_x%l_x(0) = 0
    grids_x%l_z(0) = 0
    grids_x%l_zp(0) = 0
    grids_x%p_len = 0
    grids_x%mol = 0
    grids_x%qty = 0
    grids_x%where_dBeta_df = 0
    call allocate_test ( Grids_x%windowstart, n, 'Grids_x%windowstart', &
                       & ModuleName )
    call allocate_test ( Grids_x%windowfinish, n, 'Grids_x%windowfinish',&
                       & ModuleName )
    call allocate_test ( Grids_x%lin_log, n, 'lin_log', ModuleName )
    call allocate_test ( Grids_x%min_val, n, 'min_val', ModuleName )
    call allocate_test ( Grids_x%z_coord, n, 'Grids_x%z_coord', ModuleName )
    call allocate_test ( Grids_x%coherent, n, 'Grids_x%coherent', ModuleName )
    call allocate_test ( Grids_x%stacked, n, 'Grids_x%stacked', ModuleName )

    grids_x%min_val = -huge(0.0_r8)

  end subroutine Create_Grids_1

  ! ---------------------------------------------  Create_Grids_2  -----
  subroutine Create_Grids_2 ( Grids_x )
  ! Create the part of the Grids_T structure that depends on the
  ! number of values and lengths of bases

    use Allocate_Deallocate, only: Allocate_Test, Test_Allocate

    type (Grids_T), intent(inout) :: Grids_X

    integer :: N, Stat
    character(127) :: ERMSG

    n = ubound(grids_x%l_z,1)

    call allocate_test ( Grids_x%zet_basis, Grids_x%l_z(n), 'Grids_x%zet_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%phi_basis, Grids_x%l_p(n), 'Grids_x%phi_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%frq_basis, Grids_x%l_f(n), 'Grids_x%frq_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%cross_angles, Grids_x%l_x(n), 'Grids_x%cross_angles', &
                       & ModuleName )
    call allocate_test ( Grids_x%values, Grids_x%l_v(n), 'Grids_x%values', &
                       & ModuleName )
    call allocate_test ( Grids_x%deriv_flags, Grids_x%l_v(n), 'Grids_x%deriv_flags', &
                       & ModuleName )
    allocate ( Grids_x%c(n), stat=stat, errmsg=ermsg )
    call test_allocate ( stat, moduleName, 'Grids_x%C', ermsg=ermsg )

  end subroutine Create_Grids_2

  ! -----------------------------------------------  Fill_Grids_1  -----
  subroutine Fill_Grids_1 ( Grids_x, II, Maf, Phitan, FwdModelConf, Subset )
  ! Fill in the size information for the II'th element of Grids_x

    use ForwardModelConfig, only: ForwardModelConfig_t
    use Intrinsic, only: L_Vmr
    use ManipulateVectorQuantities, only: FindInstanceWindow
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use VectorsModule, only: VectorValue_T

    type(grids_T), intent(inout) :: Grids_x
    integer, intent(in) :: II
    integer, intent(in) :: MAF
    type (vectorValue_T), intent(in), optional :: PHITAN  ! Tangent geodAngle
    type(forwardModelConfig_T), intent(in), optional :: FwdModelConf
    integer, intent(in), optional :: Subset(:) ! Subset of horizontal basis,
                                               ! primarily for QTM

    integer :: KF ! Number of frequencies
    integer :: KP ! Number of horizontal coordinates
    integer :: KX ! Number of cross-track coordinates
    integer :: KZ ! Number of vertical coordinates

    associate ( qty => grids_x%qtyStuff(ii)%qty )
 
      if ( .not. qty%template%stacked .or. .not. qty%template%coherent ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
           & 'Cannot load a quantity that is unstacked or incoherent' )

      if ( present(subset) ) then
        grids_x%windowStart(ii) = 1
        grids_x%windowFinish(ii) = size(subset)
      else if ( qty%template%isQTM() ) then
        grids_x%windowStart(ii) = 1
        grids_x%windowFinish(ii) = size(qty%template%the_hGrid%QTM_tree%geo_in)
      else if ( present(phitan) ) then
        call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
          & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
      else ! Use the whole phi space for the window
        grids_x%windowStart(ii) = 1
        grids_x%windowFinish(ii) = size(qty%template%phi,2)
      end if
      if ( grids_x%windowStart(ii) > grids_x%windowFinish(ii) ) &
        & call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Why is windowStart greater than windowFinish?' )

      kz = qty%template%noSurfs

      kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1

      kx = qty%template%noCrossTrack ! kx >= 1 even if there is no cross track

      if ( associated(qty%template%frequencies) ) then
        kf = size(qty%template%frequencies)
      else
        kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
      end if

      grids_x%l_f(ii) = grids_x%l_f(ii-1) + kf
      grids_x%l_p(ii) = grids_x%l_p(ii-1) + &
                      &   kp * merge(1,kz,qty%template%stacked) * kx
      grids_x%l_x(ii) = grids_x%l_x(ii-1) + kx
      grids_x%l_v(ii) = grids_x%l_v(ii-1) + kf * kz * kp * kx
      grids_x%z_coord(ii) = qty%template%verticalCoordinate
      grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz * merge(1,kx,qty%template%stacked)
      grids_x%l_zp(ii) = grids_x%l_zp(ii-1) + kz * kp
      grids_x%p_len = grids_x%p_len + kz * kp * kx
      grids_x%mol(ii) = qty%template%molecule
      grids_x%qty(ii) = qty%template%quantityType
      grids_x%coherent(ii) = qty%template%coherent
      grids_x%stacked(ii) = qty%template%stacked

      ! Remember positions of molecules in grids_x
      if ( qty%template%quantityType == l_vmr ) &
        & grids_x%s_ind(qty%template%molecule) = ii
        ! Note the ambiguity here as to whether it's extinction or extinctionv2:
        ! the last one wins.
        ! Also note, however, that s_ind(l_*extinction*) are never actually used.
    end associate

  end subroutine Fill_Grids_1

  ! -----------------------------------------------  Fill_Grids_2  -----
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags, Phi_Offset, Subset )
  ! Fill the zeta, phi, freq. basis and value components for the II'th
  ! "molecule" in Grids_x.

    use Constants, only: Deg2Rad
    use Geometry, only: To_XYZ, XYZ_to_Geod
    use Intrinsic, only: L_Channel, L_geocAltitude, L_geodAltitude, &
      & L_IntermediateFrequency, L_Zeta
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Molecules, only: L_CloudIce, L_H2O
    use MoreMessage, only: MLSMessage
    use To_Log_Basis_m, only: To_Log_Basis
    use VectorsModule, only: M_FullDerivatives, VectorValue_T

    ! For which molecules do we compute dBeta_df?
    !integer, parameter :: Which_dBeta_df(2) = (/ L_CloudIce, L_H2O /)
    integer, parameter :: Which_dBeta_df(1) = (/ L_CloudIce /)

    type(grids_t), intent(inout) :: Grids_x
    integer, intent(in) :: II
    real(r8), pointer :: P3(:,:,:) ! Rank 3 pointer to grids_x%phi_basis(pp+1:qp)
    type(vectorValue_T), intent(in) :: QTY     ! An arbitrary vector quantity
    logical, intent(in), optional :: SetDerivFlags
    real(rp), intent(in), optional :: Phi_Offset ! Radians
    integer, intent(in), optional :: Subset(:) ! Subset of horizontal basis,
                                               ! primarily for QTM

    integer :: H, I, J, K, KF, KP, KX, KZ, L, N, PF, PP, PV, PX, PZ
    integer :: QF, QP, QV, QX, QZ, WF, WS
    integer :: InstOr1
    logical :: PackFrq ! Need to pack the frequency "dimension"
    real(rp) :: Geod(3)   ! Geodetic coordinates lat (deg), lon(deg), alt (m)
    
    pf = Grids_x%l_f(ii-1)
    pp = Grids_x%l_p(ii-1)
    pv = Grids_x%l_v(ii-1)
    px = grids_x%l_x(ii-1)
    pz = Grids_x%l_z(ii-1)

    qf = Grids_x%l_f(ii)
    qp = Grids_x%l_p(ii)
    qv = Grids_x%l_v(ii)
    qx = Grids_x%l_x(ii)
    qz = Grids_x%l_z(ii)

    kf = qf - pf
    kx = qx - px
    kz = qz - pz
    ws = Grids_x%windowStart(ii)
    wf = Grids_x%windowFinish(ii)
    kp = wf - ws + 1

    ! Associate components of Grids_x%c with parts of Grids_x%Values
    ! and Grids_x%Deriv_Flags.

    Grids_x%c(ii)%v1 => Grids_x%values(pv+1:qv)
    Grids_x%c(ii)%v4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%c(ii)%v1
    Grids_x%c(ii)%l1 => Grids_x%deriv_flags(pv+1:qv)
    Grids_x%c(ii)%l4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%c(ii)%l1

    select case ( qty%template%verticalCoordinate )
    case ( l_geocAltitude ) ! This will be used for interpolation with
                            ! H_Path, which is in geodetic height measured
                            ! from the center of the equivalent circular
                            ! Earth, in kilometers, not meters.  We don't add
                            ! the equivalent circular Earth radius here, not
                            ! least because we don't know it yet.
      n = pz
      ! The order for zet_basis is surfs (fastest), instances, cross angles
      do k = px+1, qx
        h = k
        if ( present(subset) ) h = subset(k)
        do j = ws, wf
          instOr1 = merge(1,j,qty%template%coherent)
          do i = 1, qty%template%noSurfs
            l = merge(1,i,qty%template%stacked)
            n = n + 1
            ! Get geodetic coordinates equivalent to geocentric coordinates
            geod = xyz_to_geod ( to_xyz ( qty%template%geodLat3(l,j,h), &
                                        & qty%template%lon3(l,j,h) ) * &
                                        & qty%template%surfs(i,instOr1) )
            ! Get height above the geoid in kilometers
            Grids_x%zet_basis(n) = geod(3)/1000.0
          end do
        end do
      end do
    case ( l_geodAltitude ) ! This will be used for interpolation with
                            ! H_Path, which is in kilometers, not meters
      Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1) / 1000.0
    case ( l_zeta )
      Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1)
    case default
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unexpected vertical coordinate for quantity $S', &
        & datum=[qty%template%name] )
    end select

    p3(1:size(qty%template%phi,1),1:kp,1:kx) => Grids_x%phi_basis(pp+1:qp)

    do i = 1, kx ! kx >= 1 even if there are no crossAngles, and
                 ! qty%template%crossAngles == 0 if there are none.
      p3(:,:,i) = (qty%template%phi(:,ws:wf) + qty%template%crossAngles(i)) * Deg2Rad
    end do

    if ( present(phi_offset) ) &
      & Grids_x%phi_basis(pp+1:qp) = Grids_x%phi_basis(pp+1:qp) + phi_offset

    grids_x%cross_angles(px+1:qx) = qty%template%crossAngles

    if ( associated ( qty%template%frequencies ) ) then
      if ( qty%template%frequencyCoordinate /= l_intermediateFrequency .and. &
         & qty%template%frequencyCoordinate /= l_channel ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unexpected frequency coordinate for quantity $S', &
        & datum=[qty%template%name] )
      Grids_x%frq_basis(pf+1:qf) = qty%template%frequencies
    else
      Grids_x%frq_basis(pf+1:qf) = 0.0
    end if

    packFrq = .false.
    if ( associated(qty%template%frequencies) ) &
      & packFrq = size(qty%template%frequencies) /= qty%template%noChans

    if ( packFrq ) then ! Only the values for which we have frequencies
      if ( present(subset) ) then
        Grids_x%c(ii)%v4 = qty%value4(qty%template%chanInds,1:kz,subset,1:kx)
      else
        Grids_x%c(ii)%v4 = qty%value4(qty%template%chanInds,1:kz,ws:wf,1:kx)
      end if
    else ! All the values
      ! kz = noSurfs * noCrossTrack here
      ! shape(qty%value4) = [ freqs, zetas, instances, cross-angles ]
      if ( present(subset) ) then
        Grids_x%c(ii)%v4 = qty%value4(1:kf,1:kz,subset,1:kx)
      else
        Grids_x%c(ii)%v4 = qty%value4(1:kf,1:kz,ws:wf,1:kx)
      end if
    end if

    !  mixing ratio values are manipulated if it's log basis
    Grids_x%lin_log(ii) = qty%template%logBasis
    if ( qty%template%logBasis ) then
      Grids_x%min_val(ii) = qty%template%minValue
      call to_log_basis ( Grids_x%c(ii)%v1, qty%template%minValue )
    end if

    ! set 'do derivative' flags

    if ( present(setDerivFlags) ) then
      if ( setDerivFlags ) then
        ! We set grids_x%where_dBeta_df here instead of in Fill_Grids_1
        ! because we have setDerivFlags here, but not there.
        if ( any(qty%template%molecule == Which_dBeta_df) ) &
          grids_x%where_dBeta_df(ii) = count(grids_x%where_dBeta_df /= 0) + 1
        if ( associated(qty%mask) ) then
          if ( present(subset) ) then
            Grids_x%c(ii)%l4 = &
              & iand( M_FullDerivatives, ichar(qty%mask4(1:kf,1:kz,subset,1:kx) ) ) == 0
          else
            Grids_x%c(ii)%l4 = &
              & iand( M_FullDerivatives, ichar(qty%mask4(1:kf,1:kz,ws:wf,1:kx) ) ) == 0
          end if
        else
          Grids_x%deriv_flags(pv+1:qv) = .true.
        end if
      else
        grids_x%deriv_flags(pv+1:qv) = .false.
      end if
    else
      grids_x%deriv_flags(pv+1:qv) = .false.
    end if

  end subroutine Fill_Grids_2

  ! -------------------------------------------------  FindInGrid  -----
  integer function FindInGrid ( Grids_x, Phi, Zeta, Sps )
    ! Find the index in l_v for Sps, Phi, Zeta if Sps is present.
    ! Find the index in l_v for Phi, Zeta otherwise, assuming Grids_x is temperature.
    ! Assume no frequency dependence.
    ! Return zero if no data for Sps.

    use Constants, only: Pi
    use MLSKinds, only: RP

    type (Grids_T), intent(in) :: Grids_x
    real(rp), intent(in) :: Phi             ! Radians
    real(rp), intent(in) :: Zeta
    integer, intent(in), optional :: Sps    ! A molecule index

    real(rp), parameter :: Pi2 = 2.0*Pi
    integer :: I_Phi, I_Zeta, P0, P1, V0, V1, Z0, Z1

    ! Get bounds in phi, zeta, values, for sps
    if ( present(sps) ) then
      findInGrid = grids_x%s_ind(sps) ! findInGrid is convenient temp here
      if ( findInGrid == 0 ) return
    else
      findInGrid = 1
    end if
    z0 = grids_x%l_z(findInGrid-1)    ! First zeta - 1 for Sps
    z1 = grids_x%l_z(findInGrid)      ! Last zeta for Sps
    p0 = grids_x%l_p(findInGrid-1)    ! First phi - 1 for Sps
    p1 = grids_x%l_p(findInGrid)      ! Last phi for Sps
    v0 = grids_x%l_v(findInGrid-1)    ! First value - 1 for Sps
    v1 = grids_x%l_v(findInGrid)      ! Last value for Sps

    ! Compute location of (phi,zeta) in values
    i_zeta = minloc(abs(grids_x%zet_basis(z0+1:z1)-zeta),1)
    i_phi = minloc(abs(mod(grids_x%phi_basis(p0+1:p1),pi2)-phi),1)
    findInGrid = v0 + i_zeta + (z1-z0) * (i_phi-1)
    if ( findInGrid > v1 ) then
      findInGrid = 0
    else if ( abs(grids_x%zet_basis(i_zeta+z0)-zeta) > 0.25 * &
       & max(abs(grids_x%zet_basis(min(i_zeta+z0+1,z1)) - &
              &  grids_x%zet_basis(i_zeta+z0)), &
         &   abs(grids_x%zet_basis(i_zeta+z0) - &
              &  grids_x%zet_basis(max(i_zeta+z0-1,z0+1)))) ) then
      findInGrid = 0 ! Zeta too far from grid point
    else if ( abs(mod(grids_x%phi_basis(i_phi+p0),pi2)-phi) > 0.25 * &
       & max(abs(grids_x%phi_basis(min(i_phi+p0+1,p1)) - &
              &  grids_x%phi_basis(i_phi+p0)), &
         &   abs(grids_x%phi_basis(i_phi+p0) - &
              &  grids_x%phi_basis(max(i_phi+p0-1,p0+1)))) ) then
      findInGrid = 0 ! Phi too far from grid point
    end if
  end function FindInGrid

! --------------------------------------------------------  IsQTM  -----
  pure logical function IsQTM ( Grid, I )
    class(grids_t), intent(in) :: Grid
    integer, intent(in) :: I
    IsQTM = grid%qtyStuff(i)%qty%template%isQTM()
  end function IsQTM

  ! -----------------------------------------------  EmptyGrids_t  -----
  subroutine EmptyGrids_t ( Grids_x )
    ! Create a grids structure with all empty grids
    use Allocate_Deallocate, only: Allocate_test, Test_Allocate

    type (Grids_T), intent(inout) :: Grids_x

    integer :: Stat

    grids_x%p_len = 0
    allocate ( Grids_x%qtyStuff(0), stat=stat )
    call test_allocate ( stat, moduleName, 'Grids_x%QtyStuff' )
    call allocate_test(grids_x%l_f,0,'grids_x%l_f',modulename)
    call allocate_test(grids_x%l_z,0,'grids_x%l_z',modulename)
    call allocate_test(grids_x%l_p,0,'grids_x%l_p',modulename)
    call allocate_test(grids_x%l_x,0,'grids_x%l_x',modulename)
    call allocate_test(grids_x%l_v,0,'grids_x%l_v',modulename)
    call allocate_test(grids_x%windowstart,0,'grids_x%windowstart',modulename)
    call allocate_test(grids_x%windowfinish,0,'grids_x%windowfinish',modulename)
    call allocate_test(grids_x%mol,0,'grids_x%mol',modulename)
    call allocate_test(grids_x%where_dBeta_df,0,'grids_x%where_dBeta_df',modulename)
    call allocate_test(grids_x%qty,0,'grids_x%qty',modulename)
    call allocate_test(grids_x%s_ind,0,'grids_x%s_ind',modulename)
    call allocate_test(grids_x%lin_log,0,'grids_x%lin_log',modulename)
    call allocate_test(grids_x%min_val,0,'grids_x%min_val',modulename)
    call allocate_test(grids_x%frq_basis,0,'grids_x%frq_basis',modulename)
    call allocate_test(grids_x%zet_basis,0,'grids_x%zet_basis',modulename)
    call allocate_test(grids_x%phi_basis,0,'grids_x%phi_basis',modulename)
    call allocate_test(grids_x%cross_angles,0,'grids_x%cross_angles',modulename)
    call allocate_test(grids_x%values,0,'grids_x%values',modulename)
    call allocate_test(grids_x%deriv_flags,0,'grids_x%deriv_flags',modulename)
    call allocate_test(grids_x%z_coord,0,'grids_x%z_coord',modulename)
    call allocate_test(grids_x%coherent,0,'grids_x%coherent',modulename)
    call allocate_test(grids_x%stacked,0,'grids_x%stacked',modulename)
    allocate ( Grids_x%c(0), stat=stat )
    call test_allocate ( stat, moduleName, 'Grids_x%C' )

  end subroutine EmptyGrids_t

  ! ---------------------------------------------  Get_SPS_Bounds  -----
  subroutine Get_SPS_Bounds ( Grids_x, SPS, V1, V2 )

    ! Get the bounds in grids_x%values, etc., for SPS

    type (Grids_T), intent(in) :: Grids_x
    integer, intent(in) :: SPS
    integer, intent(out) :: V1, V2

    v1 = grids_x%l_v(sps-1)+1
    v2 = grids_x%l_v(sps)

  end subroutine Get_SPS_Bounds

  ! ---------------------------------------------  DestroyGrids_t  -----
  subroutine DestroyGrids_t ( grids_x )
    use Allocate_Deallocate, only: Deallocate_Test, Test_Deallocate

    type (Grids_T), intent(inout) :: Grids_x

    character(127) :: ERMSG
    integer :: Stat

    grids_x%p_len = 0
    if ( associated(Grids_x%qtyStuff) ) then
      deallocate ( Grids_x%qtyStuff, stat=stat, errmsg=ermsg )
      call test_deallocate ( stat, moduleName, 'Grids_x%QtyStuff', ermsg=ermsg )
    end if
    call deallocate_test(grids_x%l_f,'Grids_x%l_f',modulename)
    call deallocate_test(grids_x%l_z,'Grids_x%l_z',modulename)
    call deallocate_test(grids_x%l_p,'Grids_x%l_p',modulename)
    call deallocate_test(grids_x%l_x,'Grids_x%l_x',modulename)
    call deallocate_test(grids_x%l_v,'Grids_x%l_v',modulename)
    call deallocate_test(grids_x%windowstart,'Grids_x%windowstart',modulename)
    call deallocate_test(grids_x%windowfinish,'Grids_x%windowfinish',modulename)
    call deallocate_test(Grids_x%mol,'Grids_x%mol',modulename)
    call deallocate_test(Grids_x%where_dBeta_df,'Grids_x%where_dBeta_df',modulename)
    call deallocate_test(Grids_x%qty,'Grids_x%qty',modulename)
    call deallocate_test(Grids_x%s_ind,'Grids_x%s_ind',modulename)
    call deallocate_test(grids_x%lin_log,'Grids_x%lin_log',modulename)
    call deallocate_test(grids_x%min_val,'Grids_x%min_val',modulename)
    call deallocate_test(grids_x%frq_basis,'Grids_x%frq_basis',modulename)
    call deallocate_test(grids_x%zet_basis,'Grids_x%zet_basis',modulename)
    call deallocate_test(grids_x%phi_basis,'Grids_x%phi_basis',modulename)
    call deallocate_test(grids_x%cross_angles,'Grids_x%cross_angles',modulename)
    call deallocate_test(grids_x%values,'Grids_x%values',modulename)
    call deallocate_test(grids_x%deriv_flags,'Grids_x%deriv_flags',modulename)
    call deallocate_test(grids_x%z_coord,'Grids_x%z_coord',modulename)
    call deallocate_test(grids_x%coherent,'Grids_x%coherent',modulename)
    call deallocate_test(grids_x%stacked,'Grids_x%stacked',modulename)
    if ( associated(Grids_x%c) ) then
      deallocate ( Grids_x%c, stat=stat, errmsg=ermsg )
      call test_deallocate ( stat, moduleName, 'Grids_x%C', ermsg=ermsg )
    end if

  end subroutine DestroyGrids_t

  ! -------------------------------------------------  Dump_Grids  -----
  subroutine Dump_Grids ( The_Grid, Name, Details, OneGrid )
  ! Dump The_Grid

    use Constants, only: Rad2Deg
    use Dump_0, only: Dump
    use Intrinsic, only: Lit_Indices
    use Output_M, only: NewLine, Output
    use String_Table, only: Display_String

    type(grids_t), intent(in) :: The_Grid
    character(len=*), intent(in), optional :: Name
    integer, intent(in), optional :: Details ! <= 0 => don't dump bases (default)
                                             ! <= 1 => don't dump values
    integer, intent(in), optional :: OneGrid ! Only dump this grid

    integer :: I, I1, IN, KX, L1, MyDetails, NZG, NZV, W

    myDetails = 0
    if ( present(details) ) myDetails = details

    call output ( 'Dump of Grids_T structure', advance='no' )
    if ( present(name) ) then
      call output ( ' ', advance='no' )
      call output ( name, advance='no' )
    end if
    call output ( the_grid%p_len, before = ', P_Len = ', advance='yes' )
    call output ( 'Molecules:', advance='yes' )
    i1 = 1
    in = size(the_grid%qtyStuff)
    if ( present(oneGrid) ) then
      i1 = oneGrid
      in = oneGrid
    end if
    l1 = max(i1-1,1)
    do i = i1, in
      call output ( i )
      if ( the_grid%qtyStuff(i)%qty%template%name > 0 ) then
        call display_string ( the_grid%qtyStuff(i)%qty%template%name, before=': ' )
      else
        call output ( ': ?' )
      end if
      if ( the_grid%mol(i) > 0 ) then
        call display_string ( lit_indices(the_grid%mol(i)), &
          & before=' molecule: ' )
      end if
      if ( the_grid%qty(i) > 0 ) then
        call display_string ( lit_indices(the_grid%qty(i)), &
          & before=' quantity: ' )
      end if
      call display_string ( lit_indices(the_grid%z_coord(i)), &
        & before=' vertical coordinate: ' )
      if ( the_grid%where_dBeta_df(i) > 0 ) then
        call output ( the_grid%where_dBeta_df(i), before=' dBeta_df at ' )
      end if
      call newLine
    end do
    call dump ( the_grid%l_f(l1:in), 'The_grid%l_f' )
    call dump ( the_grid%l_z(l1:in), 'The_grid%l_z' )
    call dump ( the_grid%l_p(l1:in), 'The_grid%l_p' )
    call dump ( the_grid%l_x(l1:in), 'The_grid%l_x' )
    call dump ( the_grid%l_v(l1:in), 'The_grid%l_v' )
    call dump ( the_grid%l_zp(l1:in), 'The_grid%l_zp' )
    call dump ( the_grid%windowStart(i1:in), 'The_grid%WindowStart' )
    call dump ( the_grid%windowFinish(i1:in), 'The_grid%WindowFinish' )
    call dump ( the_grid%lin_log(i1:in), 'The_grid%Lin_Log' )
    if ( myDetails > 0 ) then
      call dump ( the_grid%min_val(i1:in), 'The_grid%Min_Val' )
      call dump ( the_grid%frq_basis(the_grid%l_f(l1)+1:the_grid%l_f(in)), &
        & 'The_grid%Frq_Basis' )
      call dump ( the_grid%coherent(i1:in), 'The_grid%Coherent' )
      call dump ( the_grid%stacked(i1:in), 'The_grid%Stacked' )
      do i = i1, in
        kx = the_grid%l_x(i) - the_grid%l_x(i-1)
        ! NZ for geolocation fields:
        nzg = merge(1,(the_grid%l_z(i)-the_grid%l_z(i-1))/kx,the_grid%stacked(i))
        ! NZ for values fields:
        nzv = (the_grid%l_z(i)-the_grid%l_z(i-1))/merge(1,kx,the_grid%stacked(i))
        w = the_grid%windowFinish(i) - the_grid%windowStart(i) + 1
        call output ( i, before='The_grid%Phi_Basis(' )
        call dump_what
        call output ( nzg, before=') surfs,insts,cross (' )
        call output ( w, before=',' )
        call output ( the_grid%l_x(i)-the_grid%l_x(i-1), before=',', &
                    & after=') (degrees)', advance='yes' )
        call dump ( rad2deg*the_grid%phi_basis(the_grid%l_p(i-1)+1: &
                                             & the_grid%l_p(i)), &
                  & lbound=the_grid%l_p(i-1)+1 )
        call output ( i, before='The_grid%Cross_Angles(' )
        call dump_what
        call output ( kx, before=') cross (', after=') (degrees)', advance='yes' )
        call dump ( the_grid%cross_angles(the_grid%l_x(i-1)+1:the_grid%l_x(i)), &
                  & lbound=the_grid%l_x(i-1)+1 )
        call output ( i, before='The_grid%Zet_Basis(' )
        call dump_what
        call output ( nzv, before=') surfs,insts,cross (' )
        call output ( w, before=',' )
        call output ( merge(1,kx,the_grid%stacked(i)), before=',', after=')', advance='yes' )
        call dump ( the_grid%zet_basis(the_grid%l_z(i-1)+1:the_grid%l_z(i)), &
          & lbound=the_grid%l_z(i-1)+1 )
        if ( myDetails > 1 ) then
           call output ( i, before='The_grid%Values(' )
           call dump_what
           call output ( the_grid%l_f(i)-the_grid%l_f(i-1), &
             & before=') freqs,surfs,insts,cross (' )
           call output ( nzv, before=',' )
           call output ( w, before=',' )
           call output ( kx, before=',', after=')', advance='yes' )
           call dump ( the_grid%values(the_grid%l_v(i-1)+1:the_grid%l_v(i)), &
             lbound=the_grid%l_v(i-1)+1 )
           call output ( i, before='The_grid%deriv_flags(' )
           call dump_what
           call output ( the_grid%l_f(i)-the_grid%l_f(i-1), &
             & before=') freqs,surfs,insts,cross (' )
           call output ( nzv, before=',' )
           call output ( w, before=',' )
           call output ( kx, before=',', after=')', advance='yes' )
           call dump ( the_grid%deriv_flags(the_grid%l_v(i-1)+1:the_grid%l_v(i)), &
             lbound=the_grid%l_v(i-1)+1 )
        end if
      end do
    end if

  contains
    subroutine Dump_What
      if ( the_grid%qtyStuff(i)%qty%template%name > 0 ) then
        call display_string ( the_grid%qtyStuff(i)%qty%template%name, &
          & before='=' )
      else if ( the_grid%mol(i) > 0 ) then
        call display_string ( lit_indices(the_grid%mol(i)), before='=' )
      else if ( the_grid%qty(i) > 0 ) then
        call display_string ( lit_indices(the_grid%qty(i)), &
          & before='=' )
      end if
    end subroutine Dump_What

  end subroutine Dump_Grids

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: load_sps_data_m.f90,v 2.121 2017/11/03 20:57:45 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module LOAD_SPS_DATA_M

! $Log: load_sps_data_m.f90,v $
! Revision 2.121  2017/11/03 20:57:45  pwagner
! Most array gymnastics moved from MLSFillValues to HyperSlabs module
!
! Revision 2.120  2017/03/11 00:57:54  vsnyder
! Make components of C_t contiguous.  Add Subset and Short arguments.  Use
! components of C_t in more places.
!
! Revision 2.119  2017/03/02 00:31:58  vsnyder
! Add %L1, %V1 components of C_t, add Get_SPS_Bounds
!
! Revision 2.118  2017/02/04 02:13:56  vsnyder
! Add type C_t and component C of that type, having components V4 and L4 to
! view sections of Values and Deriv_Flags as rank-4 objects.
! Use To_Log_Basis.
!
! Revision 2.117  2017/01/21 03:09:39  vsnyder
! Spiff the dump
!
! Revision 2.116  2016/11/02 01:30:46  vsnyder
! Remove unused USE name
!
! Revision 2.115  2016/09/21 00:14:20  vsnyder
! Use IsQTM function
!
! Revision 2.114  2016/08/30 20:29:36  vsnyder
! Add IsQTM type-bound function
!
! Revision 2.113  2016/08/23 00:43:11  vsnyder
! Components within or adjacent to the polygon are now within the QTM_Tree_t
! structure instead of the HGrid_t structure.
!
! Revision 2.112  2016/06/03 23:44:05  vsnyder
! Eliminate QTM_Geo component.  Make sure grids_x%qtyStuff(:)%qty is
! associated with the quantity.  Correct some labels in DestroyGrids_t.
! Allow to dump only grid.
!
! Revision 2.111  2016/05/27 01:26:01  vsnyder
! Cannonball polishing
!
! Revision 2.110  2016/05/16 23:22:30  vsnyder
! Check for stacked and coherent always, not just for QTM
!
! Revision 2.108  2016/05/10 00:11:33  vsnyder
! Copy qtyStuff into Grids_x, simplify Create_Grids_1
!
! Revision 2.107  2016/05/10 00:00:32  vsnyder
! Test Grids_x%qtyStuff before deallocating it
!
! Revision 2.106  2016/05/02 23:31:32  vsnyder
! Add QtyStuff, horizontal grid type (phi or QTM), some cannonball polishing
!
! Revision 2.105  2015/10/28 00:32:12  vsnyder
! Check that windowStart is not after windowFinish
!
! Revision 2.104  2015/09/22 23:18:23  vsnyder
! Add a cross-track horizontal coordinate; spiff the dump
!
! Revision 2.103  2015/08/25 18:42:03  vsnyder
! Filling zet_basis and values was still getting subscript bounds errors.
! Hopefully, that's repaired now.  The Grids_t dump is improved.
!
! Revision 2.102  2015/07/27 22:37:22  vsnyder
! Store crossAngles in grids_t instead of conflating with phi.  Use absence
! of PhiTan to indicate the phi window is all available phi's.  Remove the
! assumption that if there are cross angles, there's only one profile.  Do
! not fake using WS and WF for crossAngles bounds.
!
! Revision 2.101  2015/07/08 01:25:35  vsnyder
! Repair? problem with values being shifted
!
! Revision 2.92  2014/08/01 01:03:45  vsnyder
! Eliminate unreferenced USE name
!
! Revision 2.91  2014/07/18 23:16:28  pwagner
! Aimed for consistency in names passed to allocate_test
!
! Revision 2.90  2014/04/22 00:08:27  vsnyder
! Add tracing
!
! Revision 2.89  2013/08/08 02:36:03  vsnyder
! Use derivOK instead of foundInFirst to set deriv_flags
!
! Revision 2.88  2012/08/08 20:08:43  vsnyder
! Insert some comments about potential problems in Load_One_Item_Grid
!
! Revision 2.87  2011/11/11 00:40:17  vsnyder
! Update a comment about extinction
!
! Revision 2.86  2011/08/25 22:37:36  vsnyder
! Delete s_ind dummy argument, since it is never used.  The s_ind component
! of grids_x is used instead.  Move filling grids_x%s_ind to fill_grids_1,
! instead of doing it at some of the calls to fill_grids_1.
!
! Revision 2.85  2011/08/20 02:07:34  vsnyder
! Allocate %s_ind with bounds wide enough to accomodate l_RHi, which is not a molecule
!
! Revision 2.84  2011/08/20 00:45:33  vsnyder
! Remove unused USE statements and declarations for unused variables
!
! Revision 2.83  2011/07/29 01:50:20  vsnyder
! Add the s_ind field.  Make CloudIce a molecule.  Add the FindInGrid function.
!
! Revision 2.82  2011/07/08 20:58:18  yanovsky
! Remove L_H2O from Which_dBeta_df
!
! Revision 2.81  2011/04/28 00:14:24  vsnyder
! Give default value to P_Len component
!
! Revision 2.80  2011/02/12 03:02:04  vsnyder
! Calculate which column of dBeta_df to use
!
! Revision 2.79  2011/02/05 01:17:17  vsnyder
! Add mol component, some cannonball polishing
!
! Revision 2.78  2010/12/07 01:06:24  vsnyder
! Many changes for TScat.  Mostly making irrelevant arguments optional, and
! providing other stuff explicitly.  Also added the qty component.
!
! Revision 2.77  2010/09/25 01:13:35  vsnyder
! Add Load_Grid_From_Vector, Pack_Frq
!
! Revision 2.76  2010/06/07 23:22:53  vsnyder
! Replaced H2O_ind with S_Ind
!
! Revision 2.75  2009/12/22 02:13:38  vsnyder
! Add species names
!
! Revision 2.74  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.73  2009/05/13 20:03:02  vsnyder
! Get constants from Constants, kinds from MLSKinds
!
! Revision 2.72  2009/01/16 23:38:32  vsnyder
! Correct problem with absent molecules.  Dump angles in degrees.  Add
! PRINT statement to not_used_here.
!
! Revision 2.71  2008/10/03 16:30:31  livesey
! Added EXTINCTIONV2
!
! Revision 2.70  2008/06/06 22:51:44  pwagner
! EssentiallyEqual moved to MLSFillValues
!
! Revision 2.69  2008/05/20 00:15:07  vsnyder
! Change GRIDS_TMP to INTENT(IN)
!
! Revision 2.68  2006/12/04 21:17:28  vsnyder
! Reorganize FullForwardModel to use automatic arrays instead of allocating
! pointer arrays.  Requires testing for zero size instead of testing for
! associated in several subsidiary procedures.
!
! Revision 2.67  2006/07/21 00:18:09  vsnyder
! Remove unused USEs
!
! Revision 2.66  2006/04/05 21:46:44  vsnyder
! Allow state vector not to include all molecules
!
! Revision 2.65  2006/01/05 03:26:09  vsnyder
! Remove unused variable
!
! Revision 2.64  2005/09/16 23:41:45  vsnyder
! Spiff up a dump
!
! Revision 2.63  2005/08/03 18:04:09  vsnyder
! Some spectroscopy derivative stuff
!
! Revision 2.62  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.61  2004/11/01 20:26:36  vsnyder
! Reorganization of representation for molecules and beta groups; PFA may be broken for now
!
! Revision 2.60  2004/08/03 02:24:21  vsnyder
! Polish up dump a little bit
!
! Revision 2.59  2004/07/08 21:00:23  vsnyder
! Inching toward PFA
!
! Revision 2.58  2004/03/30 00:55:30  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.57  2004/03/20 01:15:29  jonathan
!  minor changes
!
! Revision 2.56  2004/03/01 19:21:46  jonathan
! modify load_one_item for scat source function
!
! Revision 2.55  2004/02/03 02:46:39  vsnyder
! Make ScatFlag argument optional
!
! Revision 2.54  2004/01/23 19:13:10  jonathan
! add SetTscatFlag and related changes
!
! Revision 2.53  2003/05/19 19:58:07  vsnyder
! Remove USEs for unreferenced symbols, remove unused local variables
!
! Revision 2.52  2003/05/16 23:52:26  livesey
! Now uses molecule indices rather than spectags
!
! Revision 2.51  2003/05/16 02:47:12  vsnyder
! Removed USE's for unreferenced symbols
!
! Revision 2.50  2003/05/08 23:42:50  livesey
! Bug fix for requesting derivatives etc.
!
! Revision 2.49  2003/05/06 23:36:59  dwu
! fix a bug in modify_h2o
!
! Revision 2.48  2003/05/06 20:35:34  livesey
! Another bug fix
!
! Revision 2.47  2003/05/06 20:23:21  livesey
! Bug fixes and cosmetic changes, renamed some variables etc.
!
! Revision 2.46  2003/05/05 23:00:25  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.42.2.7  2003/03/21 02:48:54  vsnyder
! Get QtyStuff_T from ForwardModelVectorTools, embellish some comments
!
! Revision 2.42.2.6  2003/03/20 19:21:05  vsnyder
! More futzing with grids_t and stuff that uses it
!
! Revision 2.42.2.5  2003/03/20 01:42:26  vsnyder
! Revise Grids_T structure
!
! Revision 2.42.2.4  2003/03/08 00:03:08  vsnyder
! Split some cloud stuff into a separate routine
!
! Revision 2.42.2.3  2003/03/06 21:53:09  vsnyder
! Cosmetic changes
!
! Revision 2.42.2.2  2003/02/14 18:11:43  pwagner
! Non-supersat bug fixed
!
! Revision 2.42.2.1  2003/02/13 18:33:18  dwu
! a clean up
!
! Revision 2.42  2003/02/13 00:42:46  dwu
! fix bugs and add comments for i_saturation
!
! Revision 2.41  2003/02/13 00:07:22  jonathan
! another bug fix
!
! Revision 2.40  2003/02/12 23:50:49  jonathan
! add optional to i_supersat and temp_supersat
!
! Revision 2.39  2003/02/11 00:48:25  jonathan
! fix index bug
!
! Revision 2.38  2003/02/07 18:47:47  vsnyder
! Back to 2.35
!
! Revision 2.35  2003/02/07 03:30:37  vsnyder
! Correct i_supersat test?
!
! Revision 2.34  2003/02/07 02:00:48  vsnyder
! Move some USE statements down
!
! Revision 2.33  2003/02/07 01:07:53  jonathan
! add in option to compute dry and super-saturation case in load_sps
!
! Revision 2.32  2003/02/06 20:00:06  vsnyder
! Make Load_One_Grid a public module procedure instead of internal
!
! Revision 2.31  2003/01/26 04:42:42  livesey
! Added profiles/angle options for phiWindow
!
! Revision 2.30  2002/11/23 02:49:33  vsnyder
! Cosmetic changes
!
! Revision 2.29  2002/10/08 17:08:05  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.28  2002/10/03 05:37:53  livesey
! Minor efficiency improvement in derivative selection
!
! Revision 2.27  2002/10/02 22:42:39  vsnyder
! Move USE statements from module scope to procedure scope.  Make Load_One_Grid
! an internal subroutine of Load_SPS_Data.  Cosmetic changes.
!
! Revision 2.26  2002/09/26 18:02:10  livesey
! Now uses GetQuantityForForwardModel.
!
! Revision 2.25  2002/09/24 21:37:01  livesey
! Added min_val stuff
!
! Revision 2.24  2002/09/05 20:48:59  livesey
! Added moleculeDerivatives info into deriv_flags
!
! Revision 2.23  2002/08/22 23:13:45  livesey
! New frequency basis on IF
!
! Revision 2.22  2002/08/20 22:37:34  livesey
! Minor change in handling of frequency coordinate
!
! Revision 2.21  2002/07/08 17:45:41  zvi
! Updated spectroscopy handling
!
! Revision 2.20  2002/07/05 07:52:49  zvi
! Some cosmetic changes
!
! Revision 2.19  2002/06/19 11:00:34  zvi
! Removing unused variables, some cosmetic changes
!
! Revision 2.17  2002/06/13 22:39:12  bill
! fixed phi window selection--wgr
!
! Revision 2.16  2002/06/04 10:28:03  zvi
! Adding comments, fixing a bug with species ruuning index
!
! Revision 2.15  2002/02/20 22:19:46  zvi
! Reversing the subset logic ..
!
! Revision 2.14  2002/02/16 20:43:54  zvi
! Changing the code for Log of Neg. VMR
!
! Revision 2.13  2002/02/16 10:32:17  zvi
! Guaranties against taking Log(0.0)
!
! Revision 2.12  2002/02/16 06:37:34  zvi
! New code for derivative flags..
!
! Revision 2.11  2002/02/08 00:46:04  zvi
! Fixing a bug in the t_deriv_flag code
!
! Revision 2.10  2002/01/30 01:11:20  zvi
! Fix bug in user selectable coeff. code
!
! Revision 2.9  2002/01/27 08:37:49  zvi
! Adding Users selected coefficients for derivatives
!
! Revision 2.8  2002/01/09 00:30:48  zvi
! Fix a bug with skip_eta_frq
!
! Revision 2.7  2002/01/08 01:02:54  livesey
! Made my_catalog intent(in) rather than pointer, also 'fixed'
! problem with frequency coordinate?
!
! Revision 2.6  2001/12/14 23:43:24  zvi
! Modification for Grouping concept
!
! Revision 2.5  2001/11/15 01:21:59  zvi
! Extiction debug fix
!
! Revision 2.4  2001/11/10 00:46:40  zvi
! Adding the EXTINCTION capabilitis
!
! Revision 2.3  2001/11/08 09:56:59  zvi
! Fixing a bug..
!
! Revision 2.2  2001/11/08 00:10:13  livesey
! Interim version for extinction
!
! Revision 2.1  2001/11/02 10:48:39  zvi
! Implementing frequecy grid
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.1.2.10  2001/09/12 21:38:51  zvi
! Added CVS stuff
!
! Revision 1.1.2.9  2001/09/08 23:11:41  zvi
! Bug fixed..
!
! Revision 1.1.2.8  2001/09/08 22:43:37  zvi
! Bug fixed..
!
! Revision 1.1.2.7  2001/09/08 22:37:11  zvi
! Eliminatin molecule coeff. stuff
!
! Revision 1.1.2.6  2001/09/08 20:22:00  zvi
! Fixing a bug..
!
! Revision 1.1.2.5  2001/09/08 20:19:48  zvi
! Developing code..
!
! Revision 1.1.2.4  2001/09/08 18:30:49  zvi
! Working on developement version
!
! Revision 1.1.2.3  2001/09/07 20:41:42  livesey
! Messing around.
!
! Revision 1.1.2.2  2001/09/07 20:16:28  livesey
! Changed stuff to lower case
!
! Revision 1.1.2.1  2001/09/07 19:56:41  zvi
! New module..
!
! Revision 1.0  2001/09/06 13:07:09  zvi
@


2.121
log
@Most array gymnastics moved from MLSFillValues to HyperSlabs module
@
text
@d40 3
d444 1
d450 1
a450 1
    grids_x%l_z(0) = 0
d452 1
a452 1
    grids_x%l_f(0) = 0
d454 2
a455 1
    grids_x%l_v(0) = 0
d570 1
d935 1
a935 1
    integer :: I, I1, IN, KX, MyDetails, NZG, NZV, W
d953 1
d976 6
a981 5
    call dump ( the_grid%l_f(i1-1:in), 'The_grid%l_f' )
    call dump ( the_grid%l_z(i1-1:in), 'The_grid%l_z' )
    call dump ( the_grid%l_p(i1-1:in), 'The_grid%l_p' )
    call dump ( the_grid%l_x(i1-1:in), 'The_grid%l_x' )
    call dump ( the_grid%l_v(i1-1:in), 'The_grid%l_v' )
d987 1
a987 1
      call dump ( the_grid%frq_basis(the_grid%l_f(i1-1)+1:the_grid%l_f(in)), &
d1060 1
a1060 1
       "$Id: load_sps_data_m.f90,v 2.120 2017/03/11 00:57:54 vsnyder Exp $"
d1070 3
@


2.120
log
@Make components of C_t contiguous.  Add Subset and Short arguments.  Use
components of C_t in more places.
@
text
@d319 1
a319 1
    use MLSFillValues, only: EssentiallyEqual
d917 1
a917 1
    use Constants, only: rad2deg
d919 1
a919 1
    use Intrinsic, only: lit_indices
d1052 1
a1052 1
       "$Id: load_sps_data_m.f90,v 2.119 2017/03/02 00:31:58 vsnyder Exp $"
d1062 4
@


2.119
log
@Add %L1, %V1 components of C_t, add Get_SPS_Bounds
@
text
@d27 4
a30 4
    real(rp), pointer :: V1(:) => NULL()      ! Frq * Zeta * Phi * Cross
    real(rp), pointer :: V4(:,:,:,:) => NULL() ! Frq X Zeta X Phi X Cross
    logical, pointer :: L1(:) => NULL()       ! Frq * Zeta * Phi * Cross
    logical, pointer :: L4(:,:,:,:) => NULL() ! Frq X Zeta X Phi X Cross
d100 2
a101 2
  subroutine Load_Sps_Data ( FwdModelConf, Phitan, MAF, &
                           & Grids_x, QtyStuffIn )
d112 1
a112 1
    type (Grids_T), intent(out) :: Grids_x   ! All the coordinates
d115 3
d121 1
d123 1
a123 1
    integer :: mol, no_mol
d137 1
d151 1
a151 1
        call fill_grids_1 ( grids_x, mol, maf, phitan, fwdModelConf )
d160 11
a170 7
    do mol = 1, no_mol
      ! Fill the zeta, phi, freq. basis and value components.
      if ( associated(qtyStuff(mol)%qty) ) &
        & call fill_grids_2 ( grids_x, mol, qtyStuff(mol)%qty, &
          & fwdModelConf%moleculeDerivatives(mol) .and. &
          & qtyStuff(mol)%derivOK )
    end do
d222 1
a222 1
    & SetDerivFlags, SetTscatFlag, Across )
d239 3
d244 1
d291 1
a291 1
         call fill_grids_1 ( grids_x, 1, maf, phitan, fwdModelConf )
d297 1
a297 1
         call fill_grids_1 ( grids_x, 1, maf )
d302 4
a305 1
       call fill_grids_2 ( grids_x, 1, qty, setDerivFlags )
d501 1
a501 1
  subroutine Fill_Grids_1 ( Grids_x, II, Maf, Phitan, FwdModelConf )
d515 2
d529 4
a532 1
      if ( qty%template%isQTM() ) then
d582 1
a582 1
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags, Phi_Offset )
d606 2
d609 1
a609 1
    integer :: I, J, K, KF, KP, KX, KZ, L, N, PF, PP, PV, PX, PZ
d634 8
d652 2
d660 2
a661 2
            geod = xyz_to_geod ( to_xyz ( qty%template%geodLat3(l,j,k), &
                                        & qty%template%lon3(l,j,k) ) * &
d707 5
a711 5
      Grids_x%values(pv+1:qv) = &
        & reshape(qty%values( pack( (/ ( i, i = 1, kf*kz ) /), &
          &                         (/ ( qty%template%channels, i = 1, kz ) /) ), &
          &                   ws:wf ), &
          &       (/qv-pv/) )
a712 1
      ! qv - pv == (wf - ws + 1) * kf * kz here
d715 5
a719 2
      Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz,ws:wf,1:kx), &
                                      & (/qv-pv/))
d726 1
a726 1
      call to_log_basis ( Grids_x%values(pv+1:qv), qty%template%minValue )
d738 7
a744 2
          Grids_x%deriv_flags(pv+1:qv) = reshape(( iand (M_FullDerivatives, &
            & ichar(qty%mask)) == 0),(/qv-pv/))
a754 8
    ! Associate components of Grids_x%c with parts of Grids_x%Values
    ! and Grids_x%Deriv_Flags.

    Grids_x%c(ii)%v1 => Grids_x%values(pv+1:qv)
    Grids_x%c(ii)%v4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%c(ii)%v1
    Grids_x%c(ii)%l1 => Grids_x%deriv_flags(pv+1:qv)
    Grids_x%c(ii)%l4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%c(ii)%l1

d1052 1
a1052 1
       "$Id: load_sps_data_m.f90,v 2.118 2017/02/04 02:13:56 vsnyder Exp $"
d1062 3
@


2.118
log
@Add type C_t and component C of that type, having components V4 and L4 to
view sections of Values and Deriv_Flags as rank-4 objects.
Use To_Log_Basis.
@
text
@d23 1
a23 1
  public :: FindInGrid
d27 1
d29 1
d81 1
a81 1
                                                ! Deriv_Flags.
d109 1
a109 1
    type (vectorValue_T), intent(in) ::  PHITAN  ! Tangent geodAngle component of
d717 5
a721 3
    
    Grids_x%c(ii)%v4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%values(pv+1:qv)
    Grids_x%c(ii)%l4(1:kf,1:kz,ws:wf,1:kx) => Grids_x%deriv_flags(pv+1:qv)
d786 1
a786 1
  subroutine EmptyGrids_t ( grids_x )
d824 14
d1020 1
a1020 1
       "$Id: load_sps_data_m.f90,v 2.117 2017/01/21 03:09:39 vsnyder Exp $"
d1030 5
@


2.117
log
@Spiff the dump
@
text
@d26 5
d43 3
a45 1
                                          ! from l2gp for 2D per sps
d67 1
a67 1
    real(rp), pointer :: cross_angles(:) => null() ! cross-angles  grid entries
d77 3
a79 1
                                                ! component.
d456 1
a456 1
    use Allocate_Deallocate, only: Allocate_test
d460 2
a461 1
    integer :: N
d477 2
d570 1
d684 1
d689 1
a689 3
      where ( Grids_x%values(pv+1:qv) <= grids_x%min_val(ii) ) &
           & Grids_x%values(pv+1:qv) = grids_x%min_val(ii)
      Grids_x%values(pv+1:qv) = log(Grids_x%values(pv+1:qv))
d713 6
d815 2
d856 4
d1002 1
a1002 1
       "$Id: load_sps_data_m.f90,v 2.116 2016/11/02 01:30:46 vsnyder Exp $"
d1012 3
@


2.116
log
@Remove unused USE name
@
text
@d895 8
a902 8
    call dump ( the_grid%l_f(i1:in), 'The_grid%l_f' )
    call dump ( the_grid%l_z(i1:in), 'The_grid%l_z' )
    call dump ( the_grid%l_p(i1:in), 'The_grid%l_p' )
    call dump ( the_grid%l_x(i1:in), 'The_grid%l_x' )
    call dump ( the_grid%l_v(i1:in), 'The_grid%l_v' )
    call dump ( the_grid%windowStart, 'The_grid%WindowStart' )
    call dump ( the_grid%windowFinish, 'The_grid%WindowFinish' )
    call dump ( the_grid%lin_log, 'The_grid%Lin_Log' )
d904 5
a908 4
      call dump ( the_grid%min_val, 'The_grid%Min_Val' )
      call dump ( the_grid%frq_basis, 'The_grid%Frq_Basis' )
      call dump ( the_grid%coherent, 'The_grid%Coherent' )
      call dump ( the_grid%stacked, 'The_grid%Stacked' )
d978 1
a978 1
       "$Id: load_sps_data_m.f90,v 2.115 2016/09/21 00:14:20 vsnyder Exp $"
d988 3
@


2.115
log
@Use IsQTM function
@
text
@d475 1
a475 1
    use Intrinsic, only: L_QTM, L_Vmr
d977 1
a977 1
       "$Id: load_sps_data_m.f90,v 2.114 2016/08/30 20:29:36 vsnyder Exp $"
d987 3
@


2.114
log
@Add IsQTM type-bound function
@
text
@a489 1
    logical :: UsingQTM
d497 1
a497 3
      usingQTM = associated(qty%template%the_hGrid)
      if ( usingQTM ) usingQTM = qty%template%the_hGrid%type == l_QTM 
      if ( usingQTM ) then
d977 1
a977 1
       "$Id: load_sps_data_m.f90,v 2.113 2016/08/23 00:43:11 vsnyder Exp $"
d987 3
@


2.113
log
@Components within or adjacent to the polygon are now within the QTM_Tree_t
structure instead of the HGrid_t structure.
@
text
@d67 1
a67 1
    ! Fortran's column- major array-element order.
d71 2
a72 1

d759 7
d980 1
a980 1
       "$Id: load_sps_data_m.f90,v 2.112 2016/06/03 23:44:05 vsnyder Exp $"
d990 4
@


2.112
log
@Eliminate QTM_Geo component.  Make sure grids_x%qtyStuff(:)%qty is
associated with the quantity.  Correct some labels in DestroyGrids_t.
Allow to dump only grid.
@
text
@d501 1
a501 1
        grids_x%windowFinish(ii) = size(qty%template%the_hGrid%QTM_geo)
d972 1
a972 1
       "$Id: load_sps_data_m.f90,v 2.111 2016/05/27 01:26:01 vsnyder Exp $"
d982 5
@


2.111
log
@Cannonball polishing
@
text
@d29 3
a32 4
    integer,  pointer :: l_p(:) => null() ! Last entry in phi_basis or QTM_Geo
                                          ! per sps
    integer,  pointer :: l_x(:) => null() ! Last entry in cross angles per sps
    integer,  pointer :: l_v(:) => null() ! Last entry in values per sps
d38 1
a38 2
                                          ! from l2gp for 2D, or size(QTM_geo)
                                          ! per sps
a57 1
    integer, pointer :: QTM_Geo(:) => null()    ! QTM vertex geolocation
d264 1
a265 1
         grids_x%qtyStuff(1)%qty => qty
d408 1
a408 1
    call allocate_test ( Grids_x%l_z, n, 'Grids_x%l_z', moduleName, lowBound=0 )
a409 2
    call allocate_test ( Grids_x%l_f, n, 'Grids_x%l_f', moduleName, lowBound=0 )
    call allocate_test ( Grids_x%l_x, n, 'Grids_x%l_f', moduleName, lowBound=0 )
d411 2
d451 1
d497 2
a498 2
      usingQTM = associated(qty%template%the_HGrid)
      if ( usingQTM ) usingQTM = qty%template%the_HGrid%type == l_QTM 
d501 1
a501 1
        grids_x%windowFinish(ii) = size(qty%template%the_HGrid%QTM_geo)
d517 1
a517 1
      kx = qty%template%noCrossTrack
d635 2
a636 1
    do i = 1, kx
d812 1
a812 1
    call deallocate_test(grids_x%l_x,'Grids_x%l_p',modulename)
d835 1
a835 1
  subroutine Dump_Grids ( The_Grid, Name, Details )
d848 1
d850 1
a850 1
    integer :: I, KX, MyDetails, NZG, NZV, W
d862 7
a868 1
    do i = 1, size(the_grid%qtyStuff)
d890 5
a894 5
    call dump ( the_grid%l_f(1:), 'The_grid%l_f' )
    call dump ( the_grid%l_z(1:), 'The_grid%l_z' )
    call dump ( the_grid%l_p(1:), 'The_grid%l_p' )
    call dump ( the_grid%l_x(1:), 'The_grid%l_x' )
    call dump ( the_grid%l_v(1:), 'The_grid%l_v' )
d903 1
a903 1
      do i = 1, size(the_grid%qtyStuff)
d972 1
a972 1
       "$Id: load_sps_data_m.f90,v 2.110 2016/05/16 23:22:30 vsnyder Exp $"
d982 3
@


2.110
log
@Check for stacked and coherent always, not just for QTM
@
text
@d37 1
a37 1
                                                 ! from l2gp
d39 6
a44 5
                                                  !from l2gp
    integer,  pointer :: mol(:) => null() ! Qty molecule, l_...
    integer,  pointer :: Z_coord(:) => null()  ! l_geo[cd]Altitude, l_zeta
    logical,  pointer :: Coherent(:) => null() ! From each Qty template
    logical,  pointer :: Stacked(:) => null()  ! From each Qty template
d66 1
a66 1
    ! This is really a four-dimensional quantity dimensioned frequency
d68 3
a70 1
    ! major array-element order.
d487 4
a490 1
    integer :: KF, KP, KX, KZ
d966 1
a966 1
       "$Id: load_sps_data_m.f90,v 2.108 2016/05/10 00:11:33 vsnyder Exp $"
d976 3
@


2.109
log
@Avoid referring to unassociated the_HGrid
@
text
@a488 2
    UsingQTM = associated(qty%template%the_HGrid)
    if ( UsingQTM ) UsingQTM = ( qty%template%the_HGrid%type == l_QTM )
d493 3
a495 1
      if ( UsingQTM ) then
d498 1
a498 1
      elseif ( present(phitan) ) then
@


2.108
log
@Copy qtyStuff into Grids_x, simplify Create_Grids_1
@
text
@d485 1
d489 2
d495 1
a495 1
      if ( qty%template%the_HGrid%type == l_QTM ) then
d498 1
a498 1
      else if ( present(phitan) ) then
d960 1
a960 1
       "$Id: load_sps_data_m.f90,v 2.106 2016/05/02 23:31:32 vsnyder Exp $"
d970 3
@


2.107
log
@Test Grids_x%qtyStuff before deallocating it
@
text
@a25 6
  integer, public, parameter :: L_Phi_Based = 1 ! Two-dimensional grid with
                                                ! orbit angle being the
                                                ! horizontal coordinate
  integer, public, parameter :: L_QTM_Based = 2 ! Three-dimensional grid with
                                                ! the horizontal grid being QTM

a26 1
    integer,  pointer :: Grid_Type(:) => null() ! l_Phi_Based or l_QTM_Based
a27 1
    integer,  pointer :: names(:) => null() ! for each sps, from Qty template
d125 2
d134 1
a134 2
        call fill_grids_1 ( grids_x, mol, qtyStuff(mol)%qty, maf, phitan, &
          &                 fwdModelConf )
d174 1
a174 1
    integer :: Qty
d177 4
a180 1
    do qty = 1, size(vector%quantities)
d182 1
a182 2
        call fill_grids_1 ( grids_x, qty, vector%quantities(qty), maf, phitan, &
          &                 fwdModelConf )
d185 1
a185 1
        call fill_grids_1 ( grids_x, qty, vector%quantities(qty), maf )
d192 1
a192 1
    do qty = 1, size(vector%quantities)
d194 1
a194 1
      call fill_grids_2 ( grids_x, qty, vector%quantities(qty), setDerivFlags(qty) )
d210 2
a211 1
    type(vectorValue_t), intent(in) :: Qty
d240 1
d242 2
a243 1
         call fill_grids_1 ( grids_x, ii, qtyStuff, maf, phitan, fwdModelConf )
d265 2
a266 1
         call fill_grids_1 ( grids_x, 1, qty, maf, phitan, fwdModelConf )
d272 1
a272 1
         call fill_grids_1 ( grids_x, 1, qty, maf )
d277 1
a277 1
       call fill_grids_2 ( grids_x, 1, qty, setDerivFlags, phitan=phitan )
a405 1
    call allocate_test ( Grids_x%grid_Type, n, 'Grids_x%grid_Type', ModuleName )
a407 1
    call allocate_test ( Grids_x%names, n, 'Grids_x%names', moduleName )
d469 1
a469 1
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Maf, Phitan, FwdModelConf )
d473 1
a473 1
    use Intrinsic, only: L_Vmr
a479 1
    type (vectorValue_T), intent(in) :: QTY     ! An arbitrary vector quantity
d486 19
a504 5
    if ( .not. qty%template%stacked .or. .not. qty%template%coherent ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
         & 'Cannot load a quantity that is unstacked or incoherent' )

    grids_x%names(ii) = qty%template%name
d506 1
a506 10
    if ( present(phitan) ) then
      call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
        & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
    else ! Use the whole phi space for the window
      grids_x%windowStart(ii) = 1
      grids_x%windowFinish(ii) = size(qty%template%phi,2)
    end if
    if ( grids_x%windowStart(ii) > grids_x%windowStart(ii) ) &
      & call MLSMessage ( MLSMSG_Error, moduleName, &
        & 'Why is windowStart greater than windowFinish?' )
d508 1
a508 1
    kz = qty%template%noSurfs
d510 1
a510 1
    kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1
d512 5
a516 7
    kx = qty%template%noCrossTrack

    if ( associated(qty%template%frequencies) ) then
      kf = size(qty%template%frequencies)
    else
      kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
    end if
d518 20
a537 19
    grids_x%l_f(ii) = grids_x%l_f(ii-1) + kf
    grids_x%l_p(ii) = grids_x%l_p(ii-1) + &
                    &   kp * merge(1,kz,qty%template%stacked) * kx
    grids_x%l_x(ii) = grids_x%l_x(ii-1) + kx
    grids_x%l_v(ii) = grids_x%l_v(ii-1) + kf * kz * kp * kx
    grids_x%z_coord(ii) = qty%template%verticalCoordinate
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz * merge(1,kx,qty%template%stacked)
    grids_x%p_len = grids_x%p_len + kz * kp * kx
    grids_x%mol(ii) = qty%template%molecule
    grids_x%qty(ii) = qty%template%quantityType
    grids_x%coherent(ii) = qty%template%coherent
    grids_x%stacked(ii) = qty%template%stacked

    ! Remember positions of molecules in grids_x
    if ( qty%template%quantityType == l_vmr ) &
      & grids_x%s_ind(qty%template%molecule) = ii
      ! Note the ambiguity here as to whether it's extinction or extinctionv2:
      ! the last one wins.
      ! Also note, however, that s_ind(l_*extinction*) are never actually used.
d542 1
a542 2
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags, Phi_Offset, &
    & PhiTan )
a564 1
    type (vectorValue_T), intent(in), optional :: PHITAN  ! Tangent geodAngle
a761 2
    call allocate_test(Grids_x%grid_Type,0,'grids_x%qtyStuff',modulename)
    call allocate_test(Grids_x%names,0,'grids_x%names',modulename)
d793 1
a796 1
    call deallocate_test(Grids_x%grid_Type,'Grids_x%Grid_Type',modulename)
a800 1
    call deallocate_test(Grids_x%names,'Grids_x%names',modulename)
d853 1
a853 1
    do i = 1, size(the_grid%names)
d855 2
a856 2
      if ( the_grid%names(i) > 0 ) then
        call display_string ( the_grid%names(i), before=': ' )
d888 1
a888 1
      do i = 1, size(the_grid%names)
d941 3
a943 2
      if ( the_grid%names(i) > 0 ) then
        call display_string ( the_grid%names(i), before='=' )
d967 3
@


2.106
log
@Add QtyStuff, horizontal grid type (phi or QTM), some cannonball polishing
@
text
@d801 4
a804 2
    deallocate ( Grids_x%qtyStuff, stat=stat )
    call test_deallocate ( stat, moduleName, 'Grids_x%QtyStuff' )
d961 1
a961 1
       "$Id: load_sps_data_m.f90,v 2.105 2015/10/28 00:32:12 vsnyder Exp $"
d971 3
@


2.105
log
@Check that windowStart is not after windowFinish
@
text
@d14 1
d26 6
d33 2
d38 2
a39 1
    integer,  pointer :: l_p(:) => null() ! Last entry in phi_basis per sps
d45 1
a45 1
!                                                  from l2gp
d47 1
a47 1
!                                                  from l2gp
d60 2
a61 1
    logical,  pointer :: lin_log(:) => null()   ! true for log representation basis
d64 1
a64 1
!                                                 molecules
d66 2
a67 1
!                                                 molecules
d69 1
a69 1
!                                                 molecules, radians
d71 1
a71 1
!                                                 for all molecules, degrees
d73 3
a75 3
!     This is really a four-dimensional quantity dimensioned frequency
!     (or 1) X zeta (or 1) X phi (or 1) X Cross, taken in Fortran's column-
!     major array-element order.
d77 2
a78 1
!     corresponding to the values component.
d97 1
a97 1
    & Grids_x, QtyStuffIn )
d105 1
a105 1
    type (VectorValue_T), intent(in) ::  PHITAN  ! Tangent geodAngle component of
d139 3
a141 1
        cycle
a143 3
      call fill_grids_1 ( grids_x, mol, qtyStuff(mol)%qty, maf, phitan, &
        &                 fwdModelConf )

d172 1
a172 1
    use VectorsModule, only: Vector_T, VectorValue_T
d286 2
a287 2
  subroutine Modify_Values_For_Supersat ( fwdModelConf, &
    & grids_f, h2o_ind, grids_tmp, boundaryPressure )
d289 4
a292 1
    use Intrinsic, only: l_clear_110RH_below_top, l_clear_0RH
a295 1
    use ForwardModelConfig, only: ForwardModelConfig_t
a296 2
    use MLSFillValues, only: EssentiallyEqual
    use Constants, only: Deg2Rad
d298 5
a302 5
    type (ForwardModelConfig_T) ,intent(in) :: FWDMODELCONF
    type (Grids_T), intent(inout) :: GRIDS_F   ! All the vmrs
    integer, intent(in) :: H2O_IND             ! Where is H2O in Grids_f?
    type (Grids_T), intent(in) :: GRIDS_TMP    ! All the temperatures
    type (VectorValue_T), intent(in) :: BOUNDARYPRESSURE
d311 1
a311 1
    logical :: FAILED
d358 6
a363 6
       case (l_clear_110RH_below_top)
          RHi = 110._r8              ! 110% supersaturation
       case (l_clear_0RH)
          RHi = 1.e-9_r8             ! 0% dry saturation
       case default
          call MLSMessage(MLSMSG_Error, ModuleName,'invalid i_saturation')
d399 1
a399 1
    use Allocate_Deallocate, only: Allocate_test
d405 13
a417 8
    call allocate_test ( Grids_x%names, n, 'Grids_x%names', ModuleName )
    call allocate_test ( Grids_x%l_z, n, 'Grids_x%l_z', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_p, n, 'Grids_x%l_p', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_f, n, 'Grids_x%l_f', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_x, n, 'Grids_x%l_f', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_v, n, 'Grids_x%l_v', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%mol, n, 'Grids_x%mol', ModuleName )
    call allocate_test ( Grids_x%qty, n, 'Grids_x%qty', ModuleName )
d554 1
a554 1
    use VectorsModule, only: VectorValue_T, M_FullDerivatives
d755 1
a755 1
    use Allocate_Deallocate, only: Allocate_test
d759 2
d762 3
d793 1
a793 1
    use Allocate_Deallocate, only: Deallocate_test
d797 2
d800 3
d959 1
a959 1
       "$Id: load_sps_data_m.f90,v 2.104 2015/09/22 23:18:23 vsnyder Exp $"
d969 3
@


2.104
log
@Add a cross-track horizontal coordinate; spiff the dump
@
text
@d486 3
d932 1
a932 1
       "$Id: load_sps_data_m.f90,v 2.103 2015/08/25 18:42:03 vsnyder Exp $"
d942 3
@


2.103
log
@Filling zet_basis and values was still getting subscript bounds errors.
Hopefully, that's repaired now.  The Grids_t dump is improved.
@
text
@d32 2
a33 1
    integer :: P_Len = 0 ! \sum_{i=1}^n (l_z(i)-l_z(i-1))*(l_p(i)-l_p(i-1))
d39 3
a41 1
    integer,  pointer :: Z_coord(:) => null() ! l_geo[cd]Altitude, l_zeta
d57 1
a57 1
!                                                 molecules
d59 1
a59 1
!                                                 for all molecules
d61 3
a63 3
!     This is really a three-dimensional quantity dimensioned frequency
!     (or 1) X zeta (or 1) X phi (or 1), taken in Fortran's column-major
!     array-element order.
d215 4
d266 1
a266 2
       call fill_grids_2 ( grids_x, 1, qty, setDerivFlags, across=across, &
         & phitan=phitan )
d420 3
a422 1
 
d461 1
d473 4
d487 2
d490 1
a498 2
    kz = qty%template%noSurfs

d500 2
a501 1
    grids_x%l_p(ii) = grids_x%l_p(ii-1) + kp
d503 1
a503 1
    grids_x%l_v(ii) = grids_x%l_v(ii-1) + kz * kp * kf * kx
d505 2
a506 2
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz * kx
    grids_x%p_len = grids_x%p_len + kz * kp
d509 2
d523 1
a523 1
    & Across, PhiTan )
d542 1
a545 1
    logical, intent(in), optional :: Across ! Viewing angle is not in orbit plane
d548 1
a548 1
    integer :: I, J, K,  KF, KV, KX, KZ, L, N, PF, PP, PV, PX, PZ
a550 1
    logical :: MyAcross
a567 1
    kv = qv - pv
d571 1
a571 3

    myAcross = .false.
    if ( present(across) ) myAcross = across
d608 9
a616 22
    if ( myAcross ) then
      if ( phitan%template%noInstances == 1 ) then
        Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles + &
                                     phitan%template%phi(1,1)
      else if ( phitan%template%noInstances == phitan%template%noCrossTrack ) then
        Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles + &
                                     phitan%template%phi(1,:)
      else if ( qty%template%noCrossTrack == 1 ) then
        Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles(1) + &
                                     phitan%template%phi(1,:)
      else
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'Number of instances of PhiTan /= number of cross angles ' // &
          & 'number of cross angles /= 1' )
      end if
    else
      if ( present(phi_offset) ) then
        Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,ws:wf)*Deg2Rad + phi_offset
      else
        Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,ws:wf)*Deg2Rad
      end if
    end if
d644 1
a644 1
      Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz/kx,ws:wf,1:kx), &
d761 2
d794 2
d807 1
a807 1
    use String_Table, only: Display_String, String_Length
d811 2
a812 2
    integer, intent(in), optional :: Details ! <= 0 => don't dump bases
                                             ! <= 1 => don't dump values, default 0
d814 1
a814 1
    integer :: I, MyDetails
d859 2
a860 2
      call dump ( rad2deg*the_grid%phi_basis, 'The_grid%Phi_Basis (degrees)' )
      call dump ( the_grid%cross_angles, 'The_grid%Cross_Angles' )
d862 20
d883 4
a886 13
        if ( the_grid%names(i) > 0 ) then
          call display_string ( the_grid%names(i), before='=' )
        else if ( the_grid%mol(i) > 0 ) then
          call display_string ( lit_indices(the_grid%mol(i)), before='=' )
        else if ( the_grid%qty(i) > 0 ) then
          call display_string ( lit_indices(the_grid%qty(i)), before='=' )
        end if
        call output ( (the_grid%l_z(i)-the_grid%l_z(i-1))/ &
                      (the_grid%l_x(i)-the_grid%l_x(i-1)), &
          & before=') surfs,insts,cross (' )
        call output ( the_grid%l_p(i)-the_grid%l_p(i-1), before=',' )
        call output ( the_grid%l_x(i)-the_grid%l_x(i-1), before=',', &
                    & after=')', advance='yes' )
d889 20
d910 11
a920 22
      if ( myDetails > 1 ) then
        do i = 1, size(the_grid%names)
          call output ( i, before='The_grid%Values(' )
          if ( the_grid%names(i) > 0 ) then
            call display_string ( the_grid%names(i), before='=' )
          else if ( the_grid%mol(i) > 0 ) then
            call display_string ( lit_indices(the_grid%mol(i)), before='=' )
          else if ( the_grid%qty(i) > 0 ) then
            call display_string ( lit_indices(the_grid%qty(i)), &
              & before='=' )
          end if
          call output ( the_grid%l_f(i)-the_grid%l_f(i-1), &
            & before=') freqs,surfs,insts,cross (' )
          call output ( (the_grid%l_z(i)-the_grid%l_z(i-1))/ &
                        (the_grid%l_x(i)-the_grid%l_x(i-1)), before=',' )
          call output ( the_grid%l_p(i)-the_grid%l_p(i-1), before=',' )
          call output ( the_grid%l_x(i)-the_grid%l_x(i-1), before=',', &
                      & after=')', advance='yes' )
          call dump ( the_grid%values(the_grid%l_v(i-1)+1:the_grid%l_v(i)), &
            lbound=the_grid%l_v(i-1)+1 )
        end do
        call dump ( the_grid%deriv_flags, 'The_grid%Deriv_Flags' )
d922 1
a922 1
    end if
d929 1
a929 1
       "$Id: load_sps_data_m.f90,v 2.102 2015/07/27 22:37:22 vsnyder Exp $"
d939 4
@


2.102
log
@Store crossAngles in grids_t instead of conflating with phi.  Use absence
of PhiTan to indicate the phi window is all available phi's.  Remove the
assumption that if there are cross angles, there's only one profile.  Do
not fake using WS and WF for crossAngles bounds.
@
text
@d490 1
a490 1
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz
d568 2
a569 2
      do i = 1, qty%template%noSurfs
        l = merge(1,i,qty%template%stacked)
d572 2
a573 1
          do k = px+1, qx
d642 1
d644 1
a644 1
      Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz,ws:wf,1:kx), &
d810 1
a810 1
    integer :: I, L, MyDetails, W
d821 1
a821 2
    call output ( 'Molecules:' )
    w = len('Molecules:')
d823 1
d825 1
a825 1
        l = string_length(the_grid%names(i)) + 1
d827 1
a827 11
        l = 2
      end if
      if ( w + l > 100 ) then ! Will the line be overly filled?
        call newLine
        w = 0
      end if
      w = w + l
      if ( the_grid%names(i) > 0 ) then
        call display_string ( the_grid%names(i), before=' ' )
      else
        call output ( ' ?' )
a831 1
        w = w + string_length(lit_indices(the_grid%mol(i))) + len(' molecule: ')
a835 1
        w = w + string_length(lit_indices(the_grid%qty(i))) + len(' quantity: ')
a838 1
      w = w + string_length(lit_indices(the_grid%z_coord(i))) + len(' vertical coordinate:: ')
a840 1
        w = w + 2 + len(' dBeta_df at ')
d842 1
a843 1
    call newLine
a854 1
      call dump ( the_grid%zet_basis, 'The_grid%Zet_Basis' )
d857 18
d876 20
a895 1
        call dump ( the_grid%values, 'The_grid%Values' )
d905 1
a905 1
       "$Id: load_sps_data_m.f90,v 2.101 2015/07/08 01:25:35 vsnyder Exp $"
d915 6
@


2.101
log
@Repair? problem with values being shifted
@
text
@d30 1
d55 2
d175 1
a175 2
        call fill_grids_1 ( grids_x, qty, vector%quantities(qty), &
          & maf, ws=1, wf=size(vector%quantities(qty)%template%phi,2) )
d210 1
a210 1
    integer :: ii, no_ang
d248 1
a248 2
         call fill_grids_1 ( grids_x, 1, qty, maf, phitan, fwdModelConf, &
           & across=across )
d254 1
a254 2
         call fill_grids_1 ( grids_x, 1, qty, maf, &
           & ws=1, wf=size(qty%template%phi,2) )
d391 1
d401 1
d437 2
d447 1
a447 2
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Maf, Phitan, FwdModelConf, &
                          & Ws, Wf, Across )
a460 2
    integer, intent(in), optional :: Ws, Wf ! Explicit window start, finish
    logical, intent(in), optional :: Across ! Viewing angle is not in orbit plane
d462 1
a462 2
    integer :: KF, KP, KZ
    logical :: MyAcross
d466 4
a469 4
    myAcross = .false.
    if ( present(across) ) myAcross = across

    if ( myAcross ) then
d471 1
a471 9
      grids_x%windowFinish(ii) = qty%template%noCrossTrack
    else 
      if ( present(ws) ) then ! assume present(wf) as well
        grids_x%windowStart(ii) = ws
        grids_x%windowFinish(ii) = wf
      else
        call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
          & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
      end if
d475 1
d487 2
a488 1
    grids_x%l_v(ii) = grids_x%l_v(ii-1) + kz * kp * kf
d531 2
a532 2
    integer :: I, J, J1, J2, K, K1, K2, KF, KV, KZ, L, N, PF, PP, PV, PZ
    integer :: QF, QP, QV, QZ, WF, WS
d541 1
d547 1
d551 1
a567 17
      if ( myAcross ) then
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !!!!!                                                              !!!!!
      !!!!! There is an implicit assumption here that if we are doing    !!!!!
      !!!!! Cross-track viewing, there's only one MAF in the window!     !!!!!
      !!!!!                                                              !!!!!
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        j1 = 1
        j2 = 1
        k1 = ws
        k2 = wf
      else
        j1 = ws
        j2 = wf
        k1 = 1
        k2 = 1
      end if
d570 1
a570 1
        do j = j1, j2
d572 1
a572 1
          do k = k1, k2
d595 9
a603 11
      if ( associated(qty%template%crossAngles) ) then
        if ( phitan%template%noInstances == 1 ) then
          Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles + &
                                       phitan%template%phi(1,1)
        else if ( phitan%template%noInstances == phitan%template%noCrossTrack ) then
          Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles + &
                                       phitan%template%phi(1,:)
        else
          call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'Number of instances of PhiTan /= number of cross angles' )
        end if
d605 3
a607 2
        ! Assume qty%template%crossAngles would have been zero
        Grids_x%phi_basis(pp+1:qp) = phitan%template%phi(1,1)
d616 1
a638 9
    else if ( myAcross ) then
      ! qv - pv == (wf - ws + 1) * kf * kz here
!       ????? I don't know why this doesn't work ?????
!       ????? Something different might be       ?????
!       ????? needed in the "across" case anyway ?????
!       Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz,1,ws:wf), &
!                                       & (/qv-pv/))
        Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,ws:wf), &
                                         & (/qv-pv/))
d641 2
a642 4
!       ????? I don't know why this doesn't work ?????
!       Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz,1,ws:wf), &
!                                       & (/qv-pv/))
      Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,ws:wf), &
d742 1
d755 1
d773 1
d786 1
d859 1
d869 1
d881 1
a881 1
       "$Id: load_sps_data_m.f90,v 2.92 2014/08/01 01:03:45 vsnyder Exp $"
d891 3
@


2.100
log
@Pass phitan from load_one_item_grid into fill_grids_2
@
text
@a111 4
    grids_x%min_val = -huge(0.0_r8)

    grids_x%p_len = 0

a221 2
       grids_x%min_val = -huge(0.0_r8)
       grids_x%p_len = 0
d250 1
a250 1
           & 'Cross-track viewing needs PhiTan quantity' )
d273 1
a273 1
    use MLSNumerics, only: HUNT
d276 2
a277 2
    use VectorsModule, only: VECTORVALUE_T
    use MLSFillValues, only: ESSENTIALLYEQUAL
d412 2
d472 1
a472 1
    else
d516 1
d521 1
a522 2
    use Molecules, only: L_CloudIce, L_H2O
    use Constants, only: Deg2Rad
d541 1
a541 1
    logical :: PackFrq    ! Need to pack the frequency "dimension"
d543 1
a543 1

d660 8
a667 3
      kz = kz / ( wf - ws + 1 ) ! Z and cross-angles conflated if myAcross
      Grids_x%values(pv+1:qv) = reshape(qty%value4(1:kf,1:kz,1,ws:wf), &
                                      & (/qv-pv/))
d670 5
a674 1
      Grids_x%values(pv+1:qv) = qty%value1(1:kv)
d906 1
a906 1
       "$Id: load_sps_data_m.f90,v 2.99 2015/05/28 23:21:38 vsnyder Exp $"
d913 1
a913 1
end module Load_SPS_Data_M
a915 26
! Revision 2.99  2015/05/28 23:21:38  vsnyder
! Remove unreferenced USE name
!
! Revision 2.98  2015/05/28 23:12:37  vsnyder
! Finish removing assumption that geodetic-height magnetic field will be
! unstacked.  Add some checking.  Convert geocentric height in meters
! to geodetic height in km, and convert geodetic height in meters to km,
! because that's what's used for interpolation in the full forward model.
!
! Revision 2.97  2015/05/15 23:40:02  vsnyder
! More work on cross-track indexing kludges
!
! Revision 2.96  2015/05/12 20:53:07  vsnyder
! Default initialize Z_Coord component to NULL
!
! Revision 2.95  2015/05/01 02:08:10  vsnyder
! Compute dimensions correctly for geodetic-altitude magnetic fields
!
! Revision 2.94  2015/04/11 01:26:44  vsnyder
! Convert altitudes to geocentric km if not zeta
!
! Revision 2.93  2015/03/28 02:10:58  vsnyder
! Changed order of arguments to Fill_Grids_1 and Load_One_Item_Grid.
! Added "across" argument to Fill_Grids_1 and Fill_Grids_2 for cross-track
! viewing.
!
@


2.99
log
@Remove unreferenced USE name
@
text
@d12 1
a12 1
module LOAD_SPS_DATA_M
d265 2
a266 1
       call fill_grids_2 ( grids_x, 1, qty, setDerivFlags, across=across )
d901 1
a901 1
       "$Id: load_sps_data_m.f90,v 2.98 2015/05/28 23:12:37 vsnyder Exp $"
d908 1
a908 1
end module LOAD_SPS_DATA_M
d911 3
@


2.98
log
@Finish removing assumption that geodetic-height magnetic field will be
unstacked.  Add some checking.  Convert geocentric height in meters
to geodetic height in km, and convert geodetic height in meters to km,
because that's what's used for interpolation in the full forward model.
@
text
@d451 1
a451 1
    use Intrinsic, only: L_GeodAltitude, L_Vmr
d900 1
a900 1
       "$Id: load_sps_data_m.f90,v 2.97 2015/05/15 23:40:02 vsnyder Exp $"
d910 6
@


2.97
log
@More work on cross-track indexing kludges
@
text
@d198 1
d211 1
a211 1
    logical :: MyFlag
d214 2
d254 3
d260 1
a260 1
           & ws=1, wf=size(qty%template%phi,2), across=across )
d459 1
a459 1
    type (vectorValue_T), intent(in), optional :: PHITAN  ! Tangent geodAngle component of
d499 1
a499 7
    if ( grids_x%z_coord(ii) == l_geodAltitude ) then
      ! geodetic altitude will be converted to geocentric, which will
      ! have a different altitude for each latitude
      grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz * kp
    else
      grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz
    end if
d514 2
a515 1
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags, Phi_Offset, Across )
d519 1
a519 1
    use Geometry, only: To_Cart
d538 1
d544 2
a545 2
    logical :: PackFrq ! Need to pack the frequency "dimension"
    real(rp) :: XYZ(3)   ! Geocentric Cartesian coordinates (km)
d568 5
a572 4
                            ! H_Path, which is in kilometers, not meters
      Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1) / 1000.0
    case ( l_geodAltitude ) ! This will be used for interpolation with
                            ! H_Path, which is in kilometers, not meters
d597 6
a602 3
            call to_cart ( [ qty%template%geodLat3(l,j,k), qty%template%lon3(l,j,k), &
                           & qty%template%surfs(i,instOr1)/1000.0 ], xyz, km=.true. )
            Grids_x%zet_basis(n) = norm2(xyz)
d606 3
d619 10
a628 1
        Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles
d630 2
a631 1
        Grids_x%phi_basis(pp+1:qp) = 0
d900 1
a900 1
       "$Id: load_sps_data_m.f90,v 2.96 2015/05/12 20:53:07 vsnyder Exp $"
d910 3
@


2.96
log
@Default initialize Z_Coord component to NULL
@
text
@d538 2
a539 1
    integer :: I, J, K, KF, KV, KZ, L, N, PF, PP, PV, PZ, QF, QP, QV, QZ, WF, WS
d571 17
d589 2
a590 2
        l = min(i,size(qty%template%geodLat3,1))
        do j = ws, wf
d592 1
a592 1
          do k = 1, qty%template%noCrossTrack
d609 5
a613 1
      Grids_x%phi_basis(pp+1:qp) = qty%template%crossAngles
d644 1
d881 1
a881 1
       "$Id: load_sps_data_m.f90,v 2.95 2015/05/01 02:08:10 vsnyder Exp $"
d891 3
@


2.95
log
@Compute dimensions correctly for geodetic-altitude magnetic fields
@
text
@d37 1
a37 1
    integer,  pointer :: Z_coord(:)       ! l_geo[cd]Altitude, l_zeta
d858 1
a858 1
       "$Id: load_sps_data_m.f90,v 2.94 2015/04/11 01:26:44 vsnyder Exp $"
d868 3
@


2.94
log
@Convert altitudes to geocentric km if not zeta
@
text
@d37 1
d258 1
d410 1
d487 1
a487 3
    kz = qty%template%noSurfs * &
       & merge(1,size(qty%template%lon), &
              &  qty%template%verticalCoordinate /= l_geodAltitude )
d492 8
a499 1
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz
d538 2
a539 1
    integer :: I, J, K, KF, KZ, L, N, PF, PP, PV, PZ, QF, QP, QV, QZ, WF, WS
d554 2
a556 1
    kf = qf - pf
d572 2
a573 1
        do j = 1, qty%template%noInstances
d577 1
a577 1
                           & qty%template%surfs(i,j)/1000.0 ], xyz, km=.true. )
d626 1
a626 2
      Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,ws:wf), &
                                      & (/qv-pv/))
d739 1
d768 1
d826 3
d839 3
a842 3
      call dump ( the_grid%windowStart, 'The_grid%WindowStart' )
      call dump ( the_grid%windowFinish, 'The_grid%WindowFinish' )
      call dump ( the_grid%lin_log, 'The_grid%Lin_Log' )
d858 1
a858 1
       "$Id: load_sps_data_m.f90,v 2.93 2015/03/28 02:10:58 vsnyder Exp $"
d868 3
@


2.93
log
@Changed order of arguments to Fill_Grids_1 and Load_One_Item_Grid.
Added "across" argument to Fill_Grids_1 and Fill_Grids_2 for cross-track
viewing.
@
text
@d442 1
a442 1
    use Intrinsic, only: l_Vmr
d484 3
a486 1
    kz = qty%template%noSurfs
d510 3
a512 1
    use Intrinsic, only: L_Channel, L_IntermediateFrequency
d514 1
d530 1
a530 1
    integer :: I, KF, KZ, PF, PP, PV, PZ, QF, QP, QV, QZ, WF, WS
d533 1
d553 26
a578 1
    Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1)
d593 2
a594 1
        & 'Unexpected frequency coordinate for quantity' )
d843 1
a843 1
       "$Id: load_sps_data_m.f90,v 2.92 2014/08/01 01:03:45 vsnyder Exp $"
d853 5
@


2.92
log
@Eliminate unreferenced USE name
@
text
@d126 1
a126 1
      call fill_grids_1 ( grids_x, mol, qtyStuff(mol)%qty, phitan, maf, &
d171 1
a171 1
        call fill_grids_1 ( grids_x, qty, vector%quantities(qty), phitan, maf, &
d176 1
a176 1
          & ws=1, wf=size(vector%quantities(qty)%template%phi,2) )
d191 2
a192 2
  subroutine Load_One_Item_Grid ( Grids_X, Qty, Phitan, Maf, FwdModelConf, &
    & SetDerivFlags, SetTscatFlag )
d201 1
a202 1
    integer, intent(in), optional :: Maf
d206 1
d226 1
a226 1
         call fill_grids_1 ( grids_x, ii, qtyStuff, phitan, maf, fwdModelConf )
d248 2
a249 1
         call fill_grids_1 ( grids_x, 1, qty, phitan, maf, fwdModelConf )
d252 2
a253 1
         call fill_grids_1 ( grids_x, 1, qty, ws=1, wf=size(qty%template%phi,2) )
d257 1
a257 1
       call fill_grids_2 ( grids_x, 1, qty, setDerivFlags )
d437 2
a438 2
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Phitan, Maf, FwdModelConf, &
                          & Ws, Wf )
d449 1
a450 1
    integer, intent(in), optional :: MAF
d453 1
d456 1
d460 6
a465 3
    if ( present(ws) ) then ! assume present(wf) as well
      grids_x%windowStart(ii) = ws
      grids_x%windowFinish(ii) = wf
d467 7
a473 2
      call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
        & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
d475 1
d504 1
a504 1
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags, Phi_Offset )
d523 1
d526 1
d544 3
d548 2
a549 2
    if ( present(phi_offset) ) then
      Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,ws:wf)*Deg2Rad + phi_offset
d551 5
a555 1
      Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,ws:wf)*Deg2Rad
d557 1
d578 3
d811 1
a811 1
       "$Id: load_sps_data_m.f90,v 2.91 2014/07/18 23:16:28 pwagner Exp $"
d821 3
@


2.91
log
@Aimed for consistency in names passed to allocate_test
@
text
@d80 1
a80 1
    use Toggles, only: Emit, Levels, Switches, Toggle
d784 1
a784 1
       "$Id: load_sps_data_m.f90,v 2.90 2014/04/22 00:08:27 vsnyder Exp $"
d794 3
@


2.90
log
@Add tracing
@
text
@d680 18
a697 18
    call deallocate_test(Grids_x%names,'grids_x%names',modulename)
    call deallocate_test(grids_x%l_f,'grids_x%l_f',modulename)
    call deallocate_test(grids_x%l_z,'grids_x%l_z',modulename)
    call deallocate_test(grids_x%l_p,'grids_x%l_p',modulename)
    call deallocate_test(grids_x%l_v,'grids_x%l_v',modulename)
    call deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
    call deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
    call deallocate_test(Grids_x%mol,'grids_x%mol',modulename)
    call deallocate_test(Grids_x%where_dBeta_df,'grids_x%where_dBeta_df',modulename)
    call deallocate_test(Grids_x%qty,'grids_x%qty',modulename)
    call deallocate_test(Grids_x%s_ind,'grids_x%s_ind',modulename)
    call deallocate_test(grids_x%lin_log,'grids_x%lin_log',modulename)
    call deallocate_test(grids_x%min_val,'grids_x%min_val',modulename)
    call deallocate_test(grids_x%frq_basis,'grids_x%frq_basis',modulename)
    call deallocate_test(grids_x%zet_basis,'grids_x%zet_basis',modulename)
    call deallocate_test(grids_x%phi_basis,'grids_x%phi_basis',modulename)
    call deallocate_test(grids_x%values,'grids_x%values',modulename)
    call deallocate_test(grids_x%deriv_flags,'grids_x%deriv_flags',modulename)
d784 1
a784 1
       "$Id: load_sps_data_m.f90,v 2.89 2013/08/08 02:36:03 vsnyder Exp $"
d794 3
@


2.89
log
@Use derivOK instead of foundInFirst to set deriv_flags
@
text
@d80 2
d94 1
d101 3
d147 3
d784 1
a784 1
       "$Id: load_sps_data_m.f90,v 2.88 2012/08/08 20:08:43 vsnyder Exp $"
d794 3
@


2.88
log
@Insert some comments about potential problems in Load_One_Item_Grid
@
text
@d134 1
a134 1
          & qtyStuff(mol)%foundInFirst )
d775 1
a775 1
       "$Id: load_sps_data_m.f90,v 2.87 2011/11/11 00:40:17 vsnyder Exp $"
d785 3
@


2.87
log
@Update a comment about extinction
@
text
@d53 1
a53 1
    real(rp), pointer :: values(:) => null()    ! species values (eg vmr). 
d69 1
a69 1
  private :: not_used_here 
d196 1
a196 1
    logical, intent(in), optional :: SetTscatFlag 
d200 2
a201 2
    integer :: ii, no_ang, max_ele
 
d206 2
a207 3
  
       max_ele = size (Qty%values,1)
       no_ang=FwdModelConf%num_scattering_angles
d214 3
a216 4
       
       do ii=1, no_ang
          qtyStuff%values => qty%values(1:max_ele,ii:ii)
          call fill_grids_1 ( grids_x, ii, qtyStuff, phitan, maf, fwdModelConf )
d221 9
a229 2
       do ii=1, no_ang
         qtyStuff%values => qty%values(1:max_ele,ii:ii)
d234 1
a234 1
       
d272 1
a272 1
    real(r8) :: RHI 
d292 1
a292 1
    failed =  kf /= 1 
d317 1
a317 1
      
d338 2
a339 2
      
      if (supersat_Index < 1 .or. supersat_Index > kz) then        
d775 1
a775 1
       "$Id: load_sps_data_m.f90,v 2.86 2011/08/25 22:37:36 vsnyder Exp $"
d785 3
@


2.86
log
@Delete s_ind dummy argument, since it is never used.  The s_ind component
of grids_x is used instead.  Move filling grids_x%s_ind to fill_grids_1,
instead of doing it at some of the calls to fill_grids_1.
@
text
@d471 1
a471 1
      ! Also note, however, that s_ind(l_extinction) is never actually used
d770 1
a770 1
       "$Id: load_sps_data_m.f90,v 2.85 2011/08/20 02:07:34 vsnyder Exp $"
d780 5
@


2.85
log
@Allocate %s_ind with bounds wide enough to accomodate l_RHi, which is not a molecule
@
text
@d44 1
a44 1
    ! in l_f etc if qty=l_vmr, else not associated.
d77 1
a77 1
    & Grids_x, S_Ind, QtyStuffIn )
a79 2
    use Intrinsic, only: l_Vmr
    use Molecules, only: First_Molecule, Last_Molecule
a87 3
    ! Indices of species in Grids_x
    integer, intent(out), optional :: S_Ind(First_Molecule:Last_Molecule)

a100 2
    if ( present(s_ind) ) s_ind = 0 ! zero means molecule not in grids_x

d116 1
a119 7
      ! Remember positions of molecules in grids_x
      if ( qtyStuff(mol)%qty%template%quantityType == l_vmr ) &
        & grids_x%s_ind(qtyStuff(mol)%qty%template%molecule) = mol
        ! Note the ambiguity here as to whether it's extinction or extinctionv2:
        ! the last one wins.
        ! Also note, however, that s_ind(l_extinction) is never actually used

d145 1
a145 1
    & FwdModelConf, SetDerivFlags, S_Ind )
a147 2
    use Intrinsic, only: l_Vmr
    use Molecules, only: First_Molecule, Last_Molecule
a156 3
    ! Indices of species in Grids_x
    integer, intent(out), optional :: S_ind(First_Molecule:Last_Molecule)

a158 2
    if ( present(s_ind) ) s_ind = 0 ! Indicate molecule not present in the vector

a176 7

      ! Remember positions of molecules in grids_x
      if ( vector%quantities(qty)%template%quantityType == l_vmr ) &
        & grids_x%s_ind(vector%quantities%template%molecule) = qty
        ! Note the ambiguity here as to whether it's extinction or extinctionv2:
        ! the last one wins.
        ! Also note, however, that s_ind(l_extinction) is never actually used
d362 1
a362 1
    use Molecules, only: First_Molecule, Last_Molecule, L_RHi
d375 2
a376 2
    call allocate_test ( Grids_x%s_ind, last_molecule, 'Grids_x%S_ind', &
      & moduleName, lowBound=min(first_molecule,l_rhi), fill=0 )
d425 1
d466 7
d770 1
a770 1
       "$Id: load_sps_data_m.f90,v 2.84 2011/08/20 00:45:33 vsnyder Exp $"
d780 3
@


2.84
log
@Remove unused USE statements and declarations for unused variables
@
text
@d389 1
a389 1
    use Molecules, only: First_Molecule, Last_Molecule
d403 1
a403 1
      & moduleName, lowBound=first_molecule, fill=0 )
d789 1
a789 1
       "$Id: load_sps_data_m.f90,v 2.83 2011/07/29 01:50:20 vsnyder Exp $"
d799 3
@


2.83
log
@Add the s_ind field.  Make CloudIce a molecule.  Add the FindInGrid function.
@
text
@a78 1
    use Allocate_Deallocate, only: Allocate_test
a159 1
    use Allocate_Deallocate, only: Allocate_test
d175 1
a175 1
    integer :: Lbnd, Qty, Ubnd
a604 1
    use MLSNumerics, only: HUNT
d789 1
a789 1
       "$Id: load_sps_data_m.f90,v 2.82 2011/07/08 20:58:18 yanovsky Exp $"
d799 3
@


2.82
log
@Remove L_H2O from Which_dBeta_df
@
text
@d22 1
d39 1
a39 1
    ! Only set where derivatives for molecules with mixing-ratio-dependent
d43 3
a45 1
    logical,  pointer :: lin_log(:) => null()   ! type of representation basis
d57 1
a57 1
    logical,  pointer :: deriv_flags(:) => null() ! do derivatives flags
d79 1
d81 1
d128 2
a129 1
      if ( present(s_ind) ) s_ind(qtyStuff(mol)%qty%template%molecule) = mol
d161 1
d163 1
d177 1
a177 1
    integer :: Qty
d201 2
a202 1
      if ( present(s_ind) ) s_ind(vector%quantities%template%molecule) = qty
d391 1
d404 2
d503 1
a503 1
    use Molecules, only: L_Cloud_a, L_Cloud_s, L_H2O
d508 2
a509 3
    !integer, parameter :: Which_dBeta_df(3) = (/ L_Cloud_a, L_Cloud_s, L_H2O /)
    integer, parameter :: Which_dBeta_df(2) = (/ L_Cloud_a, L_Cloud_s /)

d598 54
d665 2
a666 1
    call allocate_test(Grids_x%names,0,'grids_x%names',modulename)
d668 1
d670 1
a670 1
    call allocate_test(grids_x%where_dBeta_df,0,'grids_x%where_dBeta_df',modulename)
d676 1
a677 2
    call allocate_test(grids_x%windowstart,0,'grids_x%windowstart',modulename)
    call allocate_test(grids_x%windowfinish,0,'grids_x%windowfinish',modulename)
d687 1
d693 2
d696 1
d698 1
a698 2
    call deallocate_test(Grids_x%where_dBeta_df,'grids_x%where_dBeta_df',modulename)
    call deallocate_test(grids_x%values,'grids_x%values',modulename)
d704 1
a705 2
    call deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
    call deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
d792 1
a792 1
       "$Id: load_sps_data_m.f90,v 2.81 2011/04/28 00:14:24 vsnyder Exp $"
d802 3
@


2.81
log
@Give default value to P_Len component
@
text
@d496 3
a498 1
    integer, parameter :: Which_dBeta_df(3) = (/ L_Cloud_a, L_Cloud_s, L_H2O /)
d724 1
a724 1
       "$Id: load_sps_data_m.f90,v 2.80 2011/02/12 03:02:04 vsnyder Exp $"
d734 3
@


2.80
log
@Calculate which column of dBeta_df to use
@
text
@d30 1
a30 1
    integer :: P_Len ! \sum_{i=1}^n (l_z(i)-l_z(i-1))*(l_p(i)-l_p(i-1))
d722 1
a722 1
       "$Id: load_sps_data_m.f90,v 2.79 2011/02/05 01:17:17 vsnyder Exp $"
d732 3
@


2.79
log
@Add mol component, some cannonball polishing
@
text
@d36 5
d393 1
d401 1
d491 1
d495 3
d566 4
d601 1
d626 1
d683 2
a684 2
      if ( the_grid%mol(i) > 0 ) &
        & call display_string ( lit_indices(the_grid%mol(i)), &
d686 4
a689 2
      if ( the_grid%qty(i) > 0 ) &
        & call display_string ( lit_indices(the_grid%qty(i)), &
d691 6
d722 1
a722 1
       "$Id: load_sps_data_m.f90,v 2.78 2010/12/07 01:06:24 vsnyder Exp $"
d732 3
@


2.78
log
@Many changes for TScat.  Mostly making irrelevant arguments optional, and
providing other stuff explicitly.  Also added the qty component.
@
text
@d26 4
a29 4
    integer,  pointer :: l_f(:) => null() ! Last entry in frq. grid per sps
    integer,  pointer :: l_z(:) => null() ! Last entry in zeta grid per sps
    integer,  pointer :: l_p(:) => null() ! Last entry in phi  grid per sps
    integer,  pointer :: l_v(:) => null() ! Last entry in values grid per sps
d35 1
d386 1
d393 1
d472 1
d584 1
d608 1
d666 3
d697 1
a697 1
       "$Id: load_sps_data_m.f90,v 2.77 2010/09/25 01:13:35 vsnyder Exp $"
d707 4
@


2.77
log
@Add Load_Grid_From_Vector, Pack_Frq
@
text
@d35 1
d68 1
a68 1
    & Grids_x, s_ind, QtyStuffIn )
d81 1
a81 1
    integer, intent(out), optional :: S_ind(First_Molecule:Last_Molecule)
d117 3
a119 4
      if ( present(s_ind) .and. .not. present(qtyStuffIn) ) &
        & s_ind(FwdModelConf%molecules(mol)) = mol
        ! Note the ambiguity here as to whether it's extinction or extinctionv2 with whoever
        ! is last winning.
d147 1
a147 1
    & FwdModelConf, SetDerivFlags )
d150 1
d155 7
a161 4
    type(vectorValue_t), intent(in) :: Phitan
    integer, intent(in) :: Maf
    type(forwardModelConfig_t), intent(in) :: FwdModelConf
    logical, intent(in) :: SetDerivFlags(:) ! size(vector%quantities)
d165 2
d169 8
a176 2
      call fill_grids_1 ( grids_x, qty, vector%quantities(qty), phitan, maf, &
        &                 fwdModelConf )
d185 6
d205 5
a209 4
    type(vectorValue_t), intent(in) :: Qty, Phitan
    integer, intent(in) :: Maf
    type(forwardModelConfig_t), intent(in) :: FwdModelConf
    logical, intent(in) :: SetDerivFlags
d245 8
a252 1
       call fill_grids_1 ( grids_x, 1, qty, phitan, maf, fwdModelConf )
d256 1
a256 1
    endif
d385 5
a389 4
    Grids_x%l_z(0) = 0
    Grids_x%l_p(0) = 0
    Grids_x%l_f(0) = 0
    Grids_x%l_v(0) = 0
d391 1
d427 2
a428 1
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Phitan, Maf, FwdModelConf )
d438 4
a441 3
    type (vectorValue_T), intent(in) :: PHITAN  ! Tangent geodAngle component of
    integer, intent(in) :: MAF
    type(forwardModelConfig_T), intent(in) :: FwdModelConf
d447 8
a454 2
    call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
      & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
a461 2
    kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1

d469 1
d474 1
a474 1
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags )
d486 2
a487 1
    logical, intent(in) :: SetDerivFlags
d508 5
a512 1
    Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,ws:wf)*Deg2Rad
d549 8
a556 4
    if ( setDerivFlags ) then
      if ( associated(qty%mask) ) then
        Grids_x%deriv_flags(pv+1:qv) = reshape(( iand (M_FullDerivatives, &
          & ichar(qty%mask)) == 0),(/qv-pv/))
d558 1
a558 1
        Grids_x%deriv_flags(pv+1:qv) = .true.
d579 2
a580 1
    call allocate_test(grids_x%values,0,'grids_x%values',modulename)
d603 1
d622 1
d660 3
d688 1
a688 1
       "$Id: load_sps_data_m.f90,v 2.76 2010/06/07 23:22:53 vsnyder Exp $"
d698 3
@


2.76
log
@Replaced H2O_ind with S_Ind
@
text
@d19 2
a20 1
  public :: Load_Sps_Data, Load_One_Item_Grid, Modify_Values_For_Supersat
d145 32
a416 1
    kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
d420 6
d429 1
d443 1
a443 1
    use Intrinsic, only: L_IntermediateFrequency
d453 2
a454 1
    integer :: KF, KZ, PF, PP, PV, PZ, QF, QP, QV, QZ, WF1, WF2
d468 2
a469 2
    wf1 = Grids_x%windowStart(ii)
    wf2 = Grids_x%windowFinish(ii)
d472 1
a472 1
    Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,wf1:wf2)*Deg2Rad
d474 2
a475 1
      if ( qty%template%frequencyCoordinate /= l_intermediateFrequency ) &
d483 15
a497 3
    ! qv - pv == (wf2 - wf1 + 1) * kf * kz here
    Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,wf1:wf2), &
                                    & (/qv-pv/))
d638 1
a638 1
       "$Id: load_sps_data_m.f90,v 2.75 2009/12/22 02:13:38 vsnyder Exp $"
d648 3
@


2.75
log
@Add species names
@
text
@d66 1
a66 1
    & Grids_x, h2o_ind, ext_ind, QtyStuffIn )
d69 1
a69 1
    use Molecules, only: l_extinction, l_h2o
d78 2
a79 2
    integer, intent(out), optional :: H2O_IND
    integer, intent(out), optional :: EXT_IND
a81 1
! Local variables:
d83 3
a85 1
    integer :: kk, mol, my_ext_ind, my_h2o_ind, no_mol, no_qty
d89 1
a89 1
! Begin code:
d94 2
a97 6
    ! Get number of molecules that appear in the state vector
    no_qty = 0
    do mol = 1, no_mol
      if ( associated(qtyStuff(mol)%qty) ) no_qty = no_qty + 1
    end do

a102 2
    my_ext_ind = 0
    my_h2o_ind = 0
d114 3
a116 4
      if ( .not. present(qtyStuffIn) ) then
        kk = FwdModelConf%molecules(mol)
        if ( kk == l_h2o ) my_h2o_ind = mol        ! memorize h2o index
        if ( kk == l_extinction ) my_ext_ind = mol ! memorize extiction ix
d119 1
a119 2
        ! Also note, however, this option is never actually invoked
      end if
a141 3
    if ( present(ext_ind) ) ext_ind = my_ext_ind
    if ( present(h2o_ind) ) h2o_ind = my_h2o_ind

d585 1
a585 1
       "$Id: load_sps_data_m.f90,v 2.74 2009/06/23 18:26:11 pwagner Exp $"
d595 3
@


2.74
log
@Prevent Intel from optimizing ident string away
@
text
@d24 1
d57 1
a57 1
       "$RCSfile: $"
d331 1
d392 2
d487 1
d510 1
d533 2
a534 1
    use Output_M, only: Output
d541 1
a541 1
    integer :: myDetails
d552 20
d595 1
a595 1
       "$Id: read_apriori.f90 is it here $"
d605 3
@


2.73
log
@Get constants from Constants, kinds from MLSKinds
@
text
@d56 1
a56 1
       "$RCSfile: load_sps_data_m.f90,v $"
d565 1
a566 1
!---------------------------- RCS Ident Info -------------------------------
d568 2
a569 3
       "$Id: load_sps_data_m.f90,v 2.72 2009/01/16 23:38:32 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d571 1
a571 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d573 1
d578 3
@


2.72
log
@Correct problem with absent molecules.  Dump angles in degrees.  Add
PRINT statement to not_used_here.
@
text
@d222 1
a222 1
    use Units, only: Deg2Rad
d412 1
a412 1
    use Units, only: Deg2Rad
d568 1
a568 1
       "$Id: load_sps_data_m.f90,v 2.71 2008/10/03 16:30:31 livesey Exp $"
d578 4
@


2.71
log
@Added EXTINCTIONV2
@
text
@d68 1
a68 1
    use Molecules, only: l_extinction, l_extinctionv2, l_h2o
d110 7
a116 1
      if ( .not. associated(qtyStuff(mol)%qty) ) cycle
d195 1
a195 1
          qtyStuff%values => qty%values(1:max_ele,ii:ii)
d525 1
d556 1
a556 1
      call dump ( the_grid%phi_basis, 'The_grid%Phi_Basis' )
d568 1
a568 1
       "$Id: load_sps_data_m.f90,v 2.70 2008/06/06 22:51:44 pwagner Exp $"
d572 1
d576 1
d578 3
@


2.70
log
@EssentiallyEqual moved to MLSFillValues
@
text
@d68 1
a68 1
    use Molecules, only: l_extinction, l_h2o
d116 3
d561 1
a561 1
       "$Id: load_sps_data_m.f90,v 2.69 2008/05/20 00:15:07 vsnyder Exp $"
d569 3
@


2.69
log
@Change GRIDS_TMP to INTENT(IN)
@
text
@d212 1
a212 1
    use MLSNumerics, only: ESSENTIALLYEQUAL
d558 1
a558 1
       "$Id: load_sps_data_m.f90,v 2.68 2006/12/04 21:17:28 vsnyder Exp $"
d566 3
@


2.68
log
@Reorganize FullForwardModel to use automatic arrays instead of allocating
pointer arrays.  Requires testing for zero size instead of testing for
associated in several subsidiary procedures.
@
text
@d218 1
a218 1
    type (Grids_T), intent(inout) :: GRIDS_TMP ! All the temperatures
d558 1
a558 1
       "$Id: load_sps_data_m.f90,v 2.67 2006/07/21 00:18:09 vsnyder Exp $"
d566 5
@


2.67
log
@Remove unused USEs
@
text
@d21 1
a21 1
  public :: Destroygrids_t, Dump, Dump_Grids
d466 24
d510 1
a510 1
  end subroutine Destroygrids_t
d558 1
a558 1
       "$Id: load_sps_data_m.f90,v 2.66 2006/04/05 21:46:44 vsnyder Exp $"
d566 3
@


2.66
log
@Allow state vector not to include all molecules
@
text
@a67 4
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Intrinsic, only: L_Phitan, L_VMR
    use MLSMessageModule, only: MLSMessage, MLSMSG_Deallocate, &
      & MLSMSG_Error
d69 1
a69 1
    use VectorsModule, only: Vector_T, VectorValue_T
d534 1
a534 1
       "$Id: load_sps_data_m.f90,v 2.65 2006/01/05 03:26:09 vsnyder Exp $"
d542 3
@


2.65
log
@Remove unused variable
@
text
@d87 1
a87 1
    integer :: kk, no_mol, mol, my_ext_ind, my_h2o_ind
d98 6
d114 2
d133 4
a136 4
      call fill_grids_2 ( grids_x, mol, qtyStuff(mol)%qty, &
        & fwdModelConf%moleculeDerivatives(mol) .and. &
        & qtyStuff(mol)%foundInFirst )

d538 1
a538 1
       "$Id: load_sps_data_m.f90,v 2.64 2005/09/16 23:41:45 vsnyder Exp $"
d546 3
@


2.64
log
@Spiff up a dump
@
text
@d87 1
a87 1
    integer :: ii, kk, no_mol, mol, my_ext_ind, my_h2o_ind
d530 1
a530 1
       "$Id: load_sps_data_m.f90,v 2.63 2005/08/03 18:04:09 vsnyder Exp $"
d538 3
@


2.63
log
@Some spectroscopy derivative stuff
@
text
@d506 1
a506 1
    call output ( the_grid%p_len, before = ', P_Len = ' )
d530 1
a530 1
       "$Id: load_sps_data_m.f90,v 2.62 2005/06/22 18:08:19 pwagner Exp $"
d538 3
@


2.62
log
@Reworded Copyright statement, moved rcs id
@
text
@d28 1
a28 1
    integer :: P_Len ! \sum_i=1^n (l_z(i)-l_z(i-1))*(l_p(i)-l_p(i-1))
d41 1
a41 1
    real(rp), pointer :: values(:) => null()    ! species values (ie vmr). 
d56 1
a56 1
       "$RCSfile: $"
d64 2
a65 2
  subroutine Load_Sps_Data ( FwdModelConf, fwdModelIn, fwdModelExtra, MAF, &
       &    radiometer, QuantityType, Grids_x, h2o_ind, ext_ind )
d70 1
a70 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
d76 1
a76 1
    type (vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
a78 4
    integer, intent(in) :: RADIOMETER       

    integer, intent(in) :: QuantityType      ! L_vmr, L_dv, etc.

d84 1
a88 2
    type (VectorValue_T), pointer :: PHITAN  ! Tangent geodAngle component of

d93 2
a94 1
    no_mol = size( fwdModelConf%molecules )
d96 1
a96 7
    if ( quantityType == l_vmr ) then ! fill the one in the fwdModelConf
      qtyStuff => fwdModelConf%beta_group%qty
    else ! Need a temp; don't clobber the one in the fwdModelConf
      allocate ( qtyStuff( no_mol ), stat = ii )
      if ( ii /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_Allocate // 'qtyStuff' )
    end if
a105 4
    phitan => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, config=fwdModelConf, &
      & instrumentModule=FwdModelConf%signals(1)%instrumentModule )

d108 5
a112 10
      kk = FwdModelConf%molecules(mol)
      if ( kk == l_h2o ) my_h2o_ind = mol        ! memorize h2o index
      if ( kk == l_extinction ) my_ext_ind = mol ! memorize extiction ix

      if ( quantityType /= l_vmr ) &
        & qtyStuff(mol)%qty => GetQuantityforForwardModel ( &
          & fwdModelIn, fwdModelExtra, &
          & quantityType=quantityType, molIndex=mol, &
          & radiometer=radiometer, config=fwdModelConf, &
          & foundInFirst=qtyStuff(mol)%foundInFirst )
a134 6
    if ( quantityType /= l_vmr ) then
      deallocate ( qtyStuff, stat = ii )
      if ( ii /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
        & MLSMSG_DeAllocate // 'qtyStuff' )
    end if

d377 3
a379 3
      kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
      call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
        & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
d381 1
a381 1
      kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1
d530 1
a530 1
       "$Id: $"
d538 3
@


2.61
log
@Reorganization of representation for molecules and beta groups; PFA may be broken for now
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d54 4
a57 7
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: load_sps_data_m.f90,v 2.60 2004/08/03 02:24:21 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: load_sps_data_m.f90,v $"
  private :: NOT_USED_HERE 
d552 6
a557 1
  logical function NOT_USED_HERE()
d559 1
a559 1
  end function NOT_USED_HERE
d563 3
@


2.60
log
@Polish up dump a little bit
@
text
@a15 2
    integer :: LastNonPFA                 ! Index in l_* of last non-pfa sps
                                          ! Assumes all PFA come after all non-PFA
d48 1
a48 1
    & "$Id: load_sps_data_m.f90,v 2.59 2004/07/08 21:00:23 vsnyder Exp $"
d60 1
a60 2
       &    radiometer, mol_cat_index, QuantityType, Grids_x,              &
       &    Qtys, h2o_ind, ext_ind )
d62 3
a64 3
    use ForwardModelConfig, only: ForwardModelConfig_t
    use ForwardModelVectorTools, only: GetQuantityForForwardModel, QtyStuff_T
    use Intrinsic, only: L_Phitan
a74 1
    integer, intent(in) :: MOL_CAT_INDEX(:) 
a79 1
    type (qtyStuff_t), intent(in), target, optional :: Qtys(:)
d93 1
a93 1
    no_mol = size( mol_cat_index )
d95 3
a97 4
    if ( present(qtys) ) then
      ! Assumes qtys corresponds to mol_cat_index
      qtyStuff => qtys
    else
d115 1
a115 1
    do ii = 1, no_mol
a116 3
      mol = mol_cat_index(ii)
      if ( mol >= fwdModelConf%firstPFA ) & ! Assumes all PFA after all non-PFA
        & grids_x%lastNonPFA = min(grids_x%lastNonPFA, ii-1)
d118 2
a119 2
      if ( kk == l_h2o ) my_h2o_ind = ii        ! memorize h2o index
      if ( kk == l_extinction ) my_ext_ind = ii ! memorize extiction ix
d121 2
a122 2
      if ( .not. present(qtys) ) &
        & qtyStuff(ii)%qty => GetQuantityforForwardModel ( &
d126 1
a126 1
          & foundInFirst=qtyStuff(ii)%foundInFirst )
d128 1
a128 1
      call fill_grids_1 ( grids_x, ii, qtyStuff(ii)%qty, phitan, maf, &
d137 1
a137 1
    do ii = 1, no_mol
d139 3
a141 3
      call fill_grids_2 ( grids_x, ii, qtyStuff(ii)%qty, &
        & fwdModelConf%moleculeDerivatives(mol_cat_index(ii)) .and. &
        & qtyStuff(ii)%foundInFirst )
d149 1
a149 1
    if ( .not. present(qtys) ) then
a336 1
    grids_x%lastNonPFA = n ! gets reduced later
a526 1
    call output ( the_grid%lastNonPfa, before =', Last Non-PFA = ', advance='yes' )
d553 3
@


2.59
log
@Inching toward PFA
@
text
@d50 1
a50 1
    & "$Id: load_sps_data_m.f90,v 2.58 2004/03/30 00:55:30 vsnyder Exp $"
d515 1
a515 1
  subroutine Dump_Grids ( The_Grid, Name )
d523 7
d536 1
d538 17
a554 9
    call dump ( the_grid%windowStart, 'The_grid%WindowStart' )
    call dump ( the_grid%windowFinish, 'The_grid%WindowFinish' )
    call dump ( the_grid%lin_log, 'The_grid%Lin_Log' )
    call dump ( the_grid%min_val, 'The_grid%Min_Val' )
    call dump ( the_grid%frq_basis, 'The_grid%Frq_Basis' )
    call dump ( the_grid%zet_basis, 'The_grid%Zet_Basis' )
    call dump ( the_grid%phi_basis, 'The_grid%Phi_Basis' )
    call dump ( the_grid%values, 'The_grid%Values' )
    call dump ( the_grid%deriv_flags, 'The_grid%Deriv_Flags' )
d564 3
@


2.58
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d16 2
d29 1
a29 1
    real(r8), pointer :: frq_basis(:) => null() ! frq grid entries for all
d36 2
a37 2
!     This is really a three-dimensional quantity dimensioned frequency (or
!     1) X zeta (or 1) X phi (or 1), taken in Fortran's column-major
d41 1
d50 1
a50 1
    & "$Id: load_sps_data_m.f90,v 2.57 2004/03/20 01:15:29 jonathan Exp $"
d61 3
a63 3
  subroutine Load_Sps_Data ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, QuantityType, Grids_x,      &
       &    h2o_ind, ext_ind )
a65 1
    use ForwardModelIntermediate, only: ForwardModelStatus_t
d68 2
d73 3
a75 3
    type(forwardModelConfig_T), intent(in) :: fwdModelConf
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    type(forwardModelStatus_t), intent(in) :: FmStat ! Reverse comm. stuff
d84 1
a89 1

d94 1
a94 1
    type(qtyStuff_t) :: QtyStuff( size( mol_cat_index ) )
d100 9
d124 2
a128 6
      
      qtyStuff(ii)%qty => GetQuantityforForwardModel ( &
        & fwdModelIn, fwdModelExtra, &
        & quantityType=quantityType, molIndex=mol, &
        & radiometer=radiometer, config=fwdModelConf, &
        & foundInFirst=qtyStuff(ii)%foundInFirst )
d130 8
a137 1
      call fill_grids_1 ( grids_x, ii, qtyStuff(ii)%qty, phitan, fmStat%maf, &
d158 6
d346 1
d524 6
a529 3
    call output ( 'Dump of Grids_T structure ', advance='no' )
    if ( present(name) ) call output ( name, advance='no' )
    call output ( '', advance='yes' )
d548 3
@


2.57
log
@ minor changes
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.56 2004/03/01 19:21:46 jonathan Exp $"
a154 1
    use ForwardModelVectorTools, only: GetQuantityForForwardModel, QtyStuff_T
a164 1
    logical :: AbFlag
d191 1
a191 1
       enddo
d522 3
@


2.56
log
@modify load_one_item for scat source function
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.55 2004/02/03 02:46:39 vsnyder Exp $"
d166 1
d168 1
a168 2

    
d171 1
a171 1
    
d173 1
d196 1
a196 1

d524 3
@


2.55
log
@Make ScatFlag argument optional
@
text
@d24 1
a24 1
!                                                   from l2gp
d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.54 2004/01/23 19:13:10 jonathan Exp $"
d122 1
a122 1
        &                 fwdModelConf, .false. )
d155 1
d164 38
a201 4
    call create_grids_1 ( grids_x, 1 )
    call fill_grids_1 ( grids_x, 1, qty, phitan, maf, fwdModelConf, SetTscatFlag )
    call create_grids_2 ( grids_x )
    call fill_grids_2 ( grids_x, 1, qty, setDerivFlags )
d365 1
d369 1
a369 1
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Phitan, Maf, FwdModelConf, ScatFlag )
a381 1
    logical, intent(in), optional :: ScatFlag 
a383 12
    logical :: MyScatFlag

    myScatFlag = .false.
    if ( present(scatFlag) ) myScatFlag = scatFlag

    if ( myScatFlag) then

      kp=FwdModelConf%num_scattering_angles
      grids_x%windowStart(ii) = 1
      grids_x%windowFinish(ii)= kp

    else
a390 2
    end if

d523 3
@


2.54
log
@add SetTscatFlag and related changes
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.53 2003/05/19 19:58:07 vsnyder Exp $"
d161 1
a161 1
    logical, intent(in) :: SetTscatFlag 
d346 1
a346 1
    logical, intent(in) :: ScatFlag 
d349 1
d351 4
a355 1
    IF (ScatFlag) then
a358 1
    ELSE
d360 5
a364 3
    kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
    call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
      & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
d367 2
a368 1
    ENDIF
d502 3
@


2.53
log
@Remove USEs for unreferenced symbols, remove unused local variables
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.52 2003/05/16 23:52:26 livesey Exp $"
d122 1
a122 1
        &                 fwdModelConf )
d149 1
a149 1
    & SetDerivFlags )
d161 1
d164 1
a164 1
    call fill_grids_1 ( grids_x, 1, qty, phitan, maf, fwdModelConf )
d333 1
a333 1
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Phitan, Maf, FwdModelConf )
d346 1
d350 7
d360 4
a363 1
    kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1
d496 3
@


2.52
log
@Now uses molecule indices rather than spectags
@
text
@d47 1
a47 1
    & "$Id$"
d50 1
a50 1
    & "$RCSfile$"
a65 1
    use ManipulateVectorQuantities, only: FindInstanceWindow
d483 4
a486 1
! $Log$
@


2.51
log
@Removed USE's for unreferenced symbols
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.50 2003/05/08 23:42:50 livesey Exp $"
d50 1
a50 1
    & "$RCSfile: load_sps_data_m.f90,v $"
d66 2
a67 1
    use Molecules, only: Spec_tags, SP_Extinction, SP_H2O
d113 2
a114 2
      if ( spec_tags(kk) == sp_h2o ) my_h2o_ind = ii        ! memorize h2o index
      if ( spec_tags(kk) == sp_extinction ) my_ext_ind = ii ! memorize extiction ix
d484 4
a487 1
! $Log: load_sps_data_m.f90,v $
@


2.50
log
@Bug fix for requesting derivatives etc.
@
text
@d47 1
a47 1
    & "$Id$"
d50 1
a50 1
    & "$RCSfile$"
a65 1
    use ManipulateVectorQuantities, only: FindInstanceWindow
d483 4
a486 1
! $Log$
@


2.49
log
@fix a bug in modify_h2o
@
text
@d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.48 2003/05/06 20:35:34 livesey Exp $"
d50 1
a50 1
    & "$RCSfile: load_sps_data_m.f90,v $"
a131 1

d134 2
a135 1
        & fwdModelConf%moleculeDerivatives(mol) .and. qtyStuff(ii)%foundInFirst )
d484 4
a487 1
! $Log: load_sps_data_m.f90,v $
@


2.48
log
@Another bug fix
@
text
@d47 1
a47 1
    & "$Id$"
d50 1
a50 1
    & "$RCSfile$"
d182 1
d232 1
a232 1
        & boundaryPressure%template%phi(1,wf1:wf2), grids_tmp%phi_basis ) )
d484 4
a487 1
! $Log$
@


2.47
log
@Bug fixes and cosmetic changes, renamed some variables etc.
@
text
@d228 1
a228 1
    failed = size ( grids_tmp%phi_basis, 1 ) /= boundaryPressure%template%noInstances
d484 3
@


2.46
log
@Merged in feb03 newfwm branch
@
text
@d189 1
a189 1
    integer :: KF, KZ
d192 2
a193 2
    integer :: Wf, Wf1, Wf2
    integer :: V1               ! One before starting point in Values array
d195 1
a195 1
    integer :: Zet1, Zet2       ! Zeta_basis range is zet1+1:zet2
d200 3
a202 1
    v1 = Grids_f%l_v(h2o_ind-1)
d205 2
a206 2
    zet1 = Grids_f%l_z(h2o_ind-1)
    zet2 = Grids_f%l_z(h2o_ind)
d221 1
a221 1
        & grids_f%zet_basis(zet1:zet2), grids_tmp%zet_basis ) )
d223 1
a223 1
        & grids_f%phi_basis(wf1:wf2), grids_tmp%phi_basis(wf1:wf2) ) )
d231 1
a231 1
        & grids_tmp%phi_basis(wf1:wf2),  boundaryPressure%template%phi(1,wf1:wf2) ) )
d237 1
a237 1
    ! h2o: grids_f%values ( v1 + h + kz*p )
d252 8
a259 16
    do wf = wf1, wf2
  ! find the index for the top of saturation levels
    call Hunt (Grids_f%zet_basis(zet1+1:zet2), -log10(boundaryPressure%values(1,wf)), &
      & supersat_Index, 1, nearest=.true.)

    if (supersat_Index < 1 .or. supersat_Index > kz) then        
       call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'the top for supersaturation is out of range' )
    else

      if ( Grids_f%lin_log(h2o_ind) ) then
        do z_index = 1, supersat_Index
          Grids_f%values(v1 + z_index + kz*(wf-wf1)) = &
            & log ( RHIFromH2O_Factor ( grids_tmp%values(z_index + kz*(wf-wf1)), &
            &   grids_f%zet_basis(zet1+z_index), 0, .true. ) * RHI )
        end do
d261 15
a275 9
        do z_index = 1, supersat_Index
          Grids_f%values(v1 + z_index + kz*(wf-wf1)) = &
            & RHIFromH2O_Factor ( grids_tmp%values(z_index + kz*(wf-wf1)), &
            &   grids_f%zet_basis(zet1+z_index), 0, .true. ) * RHI
        end do
      end if   ! linear or log basis
    end if     ! check supersat_index
    end do          

d484 3
@


2.45
log
@add a new option (clear_110RH_below_tropopause) to i_saturation
@
text
@d11 10
a20 6
  public :: Load_SPS_Data, Destroygrids_t

  type, public :: Grids_T             ! Fit all Gridding categories
    integer,  pointer :: no_f(:) => null()! No. of entries in frq. grid per sps
    integer,  pointer :: no_z(:) => null()! No. of entries in zeta grid per sps
    integer,  pointer :: no_p(:) => null()! No. of entries in phi  grid per sps
d33 6
a38 2
    real(rp), pointer :: values(:) => null() ! species values (ie vmr) in lvf
    logical,  pointer :: deriv_flags(:) => null() ! do derivatives flags in lvf
d41 4
d47 1
a47 1
    & "$Id: load_sps_data_m.f90,v 2.44 2003/02/14 17:53:34 pwagner Exp $"
d50 1
a50 1
    & "$RCSfile: load_sps_data_m.f90,v $"
d58 3
a60 67
  subroutine Load_SPS_Data ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, p_len, f_len, h2o_ind, ext_ind,        &
       &    Grids_f, f_len_dw, Grids_dw, f_len_dn, Grids_dn, f_len_dv,        &
       &    Grids_dv, RHi, temp_supersat, refPressure )

    use ForwardModelConfig, only: ForwardModelConfig_t
    use ForwardModelIntermediate, only: ForwardModelStatus_t
    use Intrinsic, only: L_DN, L_DV, L_DW, L_VMR
    use VectorsModule, only: Vector_T

    type(forwardModelConfig_T), intent(in) :: fwdModelConf
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    type(forwardModelStatus_t), intent(in) :: FmStat ! Reverse comm. stuff

    integer, intent(in)  :: RADIOMETER
    integer, intent(in)  :: MOL_CAT_INDEX(:)

    integer, intent(out) :: P_LEN, F_LEN
    integer, intent(out) :: H2O_IND
    integer, intent(out) :: EXT_IND

    integer, optional, intent(out) :: F_LEN_DW, F_LEN_DN, F_LEN_DV

! All the VMR coordinates
    type (Grids_T), intent(out) :: Grids_f

! All the spectroscopy(W) coordinates
    type (Grids_T), optional, intent(out) :: Grids_dw

! All the spectroscopy(N) coordinates
    type (Grids_T), optional, intent(out) :: Grids_dn

! All the spectroscopy(V) coordinates
    type (Grids_T), optional, intent(out) :: Grids_dv

    real(r8), optional, intent(in)  :: RHi     ! refRHi %
    real(r8), optional, dimension(:), intent(in) :: temp_supersat  
                                          ! temperatures to use for supersaturation
    real(r8), optional, intent(in) :: refPRESSURE   ! mb
                                          ! the top pressure where supersaturation is set
! Begin execution
    call load_one_grid ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       & radiometer, mol_cat_index, f_len, l_vmr, Grids_f, p_len, h2o_ind,&
       & ext_ind, RHi, temp_supersat, refPressure )

! ** When the spectroscopy flags are properly introduced into the database,
!    un-comment the following codes:

!   if ( PRESENT ( Grids_dw ) ) &
!   & Call load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
!        & radiometer, mol_cat_index, f_len_dw, l_dw, Grids_dw)

!   if ( PRESENT ( Grids_dn ) ) &
!   & Call load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
!        & radiometer, mol_cat_index, f_len_dn, l_dn, Grids_dn)

!   if ( PRESENT ( Grids_dv ) ) &
!   & Call load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
!        & radiometer, mol_cat_index, f_len_dv, l_dv, Grids_dv)

  end subroutine Load_Sps_Data

  !  ---------------------------------------------  Load_One_Grid  -----

  subroutine Load_One_Grid ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, f_len, QuantityType, Grids_x, p_len,      &
       &    h2o_ind, ext_ind, RHi, temp_supersat, refPressure )
a61 1
    use Allocate_Deallocate, only: Allocate_test
d64 2
a65 2
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use Intrinsic, only: L_IntermediateFrequency, L_None, L_Phitan
d67 2
a68 6
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: HUNT
    use Molecules, only: Spec_tags, SP_H2O
    use RHIFromH2O, only: RHIFromH2O_Factor
    use Units, only: Deg2Rad
    use VectorsModule, only: Vector_T, VectorValue_T, M_FullDerivatives
a76 2
    integer, intent(out) :: F_LEN

d81 3
a83 8
    integer, intent(out) :: P_LEN
    integer, intent(out) :: H2O_IND
    integer, intent(out) :: EXT_IND
    real(r8), optional, intent(in)  :: RHi     ! refRHi in %
    real(r8), optional, dimension(:), intent(in) :: temp_supersat  
                                          ! What temperatures to use for supersaturation
    real(r8), optional, intent(in) :: refPRESSURE 
                                          ! the top pressure where supersaturation is set
a85 3
    integer :: i, j, k, l, m, n, r, s, kz, kp, kf
    integer :: n_f_phi, n_f_zet, n_f_frq, no_mol
    integer :: ii, kk, wf1, wf2
d87 2
a88 1
    type (VectorValue_T), pointer :: F       ! An arbitrary species
d91 1
a91 8
    logical :: FoundInFirst                  ! Flag
    integer :: supersat_Index
    integer :: wf
    integer :: f_index
    integer :: z_index
    integer :: values_index
    real(rp), dimension(:), pointer :: Grids_x_values
    real :: diff, pct_diff, max_value
a93 7
    if ( RHi > 0._r8 ) then
      if ( size(temp_supersat) < 1 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'temp_supersat must be allocated for supersaturation' )
    endif

    !******************* LOAD SPECIES DATA ************
d97 1
a97 9
    call allocate_test ( Grids_x%no_z,no_mol,'Grids_x%no_z',ModuleName )
    call allocate_test ( Grids_x%no_p,no_mol,'Grids_x%no_p',ModuleName )
    call allocate_test ( Grids_x%no_f,no_mol,'Grids_x%no_f',ModuleName )
    call allocate_test ( Grids_x%windowstart,no_mol,'Grids_x%windowstart', &
                       & ModuleName )
    call allocate_test ( Grids_x%windowfinish,no_mol,'Grids_x%windowfinish',&
                       & ModuleName )
    call Allocate_test ( Grids_x%lin_log, no_mol, 'lin_log', ModuleName )
    call Allocate_test ( Grids_x%min_val, no_mol, 'min_val', ModuleName )
a98 3
    Grids_x%no_z = 0
    Grids_x%no_p = 0
    Grids_x%no_f = 0
d101 3
a103 5
    f_len = 0

     p_len=0
     ext_ind = 0
     h2o_ind = 0
d110 5
a114 2
      kk = FwdModelConf%molecules(mol_cat_index(ii))
      if ( spec_tags(kk) == sp_h2o ) h2o_ind = ii        ! memorize h2o index
d116 117
a232 4
      f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=quantityType, molIndex=mol_cat_index(ii), &
        & radiometer=radiometer, config=fwdModelConf )
      kz = f%template%noSurfs
d234 32
a265 7
      if ( RHi > 0._r8 ) then
        if ( kz /= size(temp_supersat) ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'template for this molecule on different vertical grid' )
      endif
      if ( f%template%frequencyCoordinate == l_none ) then
        kf = 1
d267 46
a312 19
        kf = f%template%noChans
      end if
      call FindInstanceWindow ( f, phitan, fmStat%maf, FwdModelConf%phiWindow, &
        & FwdModelConf%windowUnits, wf1, wf2 )
      Grids_x%windowStart(ii) = wf1
      Grids_x%windowFinish(ii) = wf2
      kp = wf2 - wf1 + 1
      Grids_x%no_f(ii) = kf
      Grids_x%no_z(ii) = kz
      Grids_x%no_p(ii) = kp
      p_len = p_len + kz * kp
      f_len = f_len + kz * kp * kf
      if ( f%template%logBasis ) then
        Grids_x%lin_log(ii) = .true.
        Grids_x%min_val(ii) = f%template%minValue
      else
        Grids_x%lin_log(ii) = .false.
      end if
    end do
d314 1
a314 3
    n_f_zet = sum(Grids_x%no_z)
    n_f_phi = sum(Grids_x%no_p)
    n_f_frq = sum(Grids_x%no_f)
d316 2
a317 1
! Allocate space for the zeta, phi & freq. basis componenets
d319 1
a319 1
    call allocate_test ( Grids_x%zet_basis,n_f_zet,'Grids_x%zet_basis', &
d321 1
a321 1
    call allocate_test ( Grids_x%phi_basis,n_f_phi,'Grids_x%phi_basis', &
d323 1
a323 1
    call allocate_test ( Grids_x%frq_basis,n_f_frq,'Grids_x%frq_basis', &
d325 1
a325 1
    call allocate_test ( Grids_x%values,f_len,'Grids_x%values', &
d327 1
a327 1
    call allocate_test ( Grids_x%deriv_flags,f_len,'Grids_x%deriv_flags',&
d329 1
d331 3
a333 27
    j = 1
    l = 1
    s = 1
    f_len = 1
    do ii = 1, no_mol
      i = mol_cat_index(ii)
      f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=quantityType, molIndex=i, radiometer=radiometer, &
        & config=fwdModelConf, foundInFirst=foundInFirst )
      kz = Grids_x%no_z(ii)
      kp = Grids_x%no_p(ii)
      kf = Grids_x%no_f(ii)
      n = l + kz
      m = s + kf
      k = j + kp
      wf1 = Grids_x%windowStart(ii)
      wf2 = Grids_x%windowFinish(ii)
      Grids_x%zet_basis(l:n-1) = f%template%surfs(1:kz,1)
      Grids_x%phi_basis(j:k-1) = f%template%phi(1,wf1:wf2)*Deg2Rad
      if ( associated ( f%template%frequencies ) ) then
        if ( f%template%frequencyCoordinate /= l_intermediateFrequency ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unexpected frequency coordinate for quantity' )
        Grids_x%frq_basis(s:m-1) = f%template%frequencies
      else
        Grids_x%frq_basis(s:m-1) = 0.0
      end if
d335 3
a337 3
! ** ZEBUG - Simulate f%values for EXTINCTION, using the N2 function
!  (Some code here ...)
! ** END ZEBUG
d339 26
a364 9
      r = f_len + kf * kz * kp
      Grids_x%values(f_len:r-1) = reshape(f%values(1:kf*kz,wf1:wf2), &
                                      & (/kf*kz*kp/))
!  mixing ratio values are manipulated if it's log basis
      if ( Grids_x%lin_log(ii) ) then
        where ( Grids_x%values(f_len:r-1) <= grids_x%min_val(ii) ) &
             & Grids_x%values(f_len:r-1) = grids_x%min_val(ii)
        Grids_x%values(f_len:r-1) = log(Grids_x%values(f_len:r-1))
      end if
d366 4
a369 1
! set 'do derivative' flags
d371 51
a421 7
      if ( fwdModelConf%moleculeDerivatives(i) .and. foundInFirst ) then
        if ( associated(f%mask) ) then
          Grids_x%deriv_flags(f_len:r-1) = reshape(( iand (M_FullDerivatives,&
            & ichar(f%mask)) == 0),(/kf*kz*kp/))
        else
          Grids_x%deriv_flags(f_len:r-1) = .true.
        end if
d423 1
a423 1
        grids_x%deriv_flags(f_len:r-1) = .false.
d425 3
d429 1
a429 46
! modify h2o mixing ratio if a special supersaturation /= 0
      if ( RHi > 0._r8 .and. ii == h2o_ind ) then
        ! find the index for the top of saturation levels
        call Hunt (Grids_x%zet_basis(l:n-1), -log10(refPRESSURE), supersat_Index, &
           & 1, nearest=.true.)
        if (supersat_Index < 1) then        
           call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Could not find value of Zeta in Grid_T; returned index too small' )

        else if (supersat_Index > size(Grids_x%values) ) then
           call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Could not find value of Zeta in Grid_T; returned index too BIG' )
        else
        
        ! H2O may have log basis functions
          if ( Grids_x%lin_log(ii) ) then
          do wf = wf1, wf2
            do f_index = 1, kf
              do z_index = 1, supersat_Index
                values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
                Grids_x%values(values_index) = &
                 & log(RHIFromH2O_Factor (temp_supersat(z_index), &
                 & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI)
              end do
            end do
          end do
          else
          do wf = wf1, wf2
            do f_index = 1, kf
              do z_index = 1, supersat_Index
                values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
                Grids_x%values(values_index) = &
                 & RHIFromH2O_Factor (temp_supersat(z_index), &
                 & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI
              end do
            end do
          end do          
          endif   ! linear or log basis

         end if      ! check supersat_index
      end if      ! RH

      j = k
      l = n
      s = m
      f_len = r
d431 2
a432 8
    end do

    f_len = f_len - 1

  end subroutine Load_One_Grid

!----------------------------------------------------------------
  subroutine DestroyGrids_t( grids_x )
d435 1
a435 1
    type(Grids_T), intent(inout) :: Grids_x
d437 4
a440 3
    call deallocate_test(grids_x%no_f,'grids_x%no_f',modulename)
    call deallocate_test(grids_x%no_z,'grids_x%no_z',modulename)
    call deallocate_test(grids_x%no_p,'grids_x%no_p',modulename)
d453 25
d483 17
a499 2
! $Log: load_sps_data_m.f90,v $
! Revision 2.44  2003/02/14 17:53:34  pwagner
d502 2
a503 2
! Revision 2.43  2003/02/13 01:26:55  dwu
! another cleanup
@


2.44
log
@Non-supersat bug fixed
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.43 2003/02/13 01:26:55 dwu Exp $"
d49 1
a49 1
       &    Grids_dv, i_supersat, temp_supersat )
d81 5
a85 8
    integer, optional, intent(in)  :: i_supersat     ! Do the suprsaturation calculation?
!-----------------------------------------------------------------------------
! i_supersat indicates different clear and cloudy sky combinations:
!        i_supersat =-1 is for clear-sky radiance limit assuming 110%RHi
!        i_supersat =-2 is for clear-sky radiance limit assuming 0%RHi
!-----------------------------------------------------------------------------
    real(r8), dimension(:), optional, intent(in) :: &
                                    & temp_supersat  ! What temperatures to use for supersaturation
d89 1
a89 1
       & ext_ind, i_supersat, temp_supersat )
d112 1
a112 1
       &    h2o_ind, ext_ind, i_supersat, temp_supersat )
d143 5
a147 8
    integer, optional, intent(in)  :: i_supersat     ! Do the suprsaturation calculation?
!-----------------------------------------------------------------------------
! i_supersat indicates different clear and cloudy sky combinations:
!        i_supersat =-1 is for clear-sky radiance limit assuming 110%RHi
!        i_supersat =-2 is for clear-sky radiance limit assuming 0%RHi
!-----------------------------------------------------------------------------
    real(r8), optional, dimension(:), intent(in) :: &
                                    & temp_supersat  ! What temperatures to use for supersaturation
a162 2
    real(r8), parameter :: refPRESSURE = 100._r8
    real(r8) :: RHI 
d167 1
a167 1
    if ( i_supersat /= 0 ) then
d210 2
a211 1
      if ( i_supersat /= 0 ) then
d312 2
a313 9
      if ( i_supersat /= 0 .and. ii == h2o_ind ) then
        select case ( i_supersat )
        case ( -1 )
          RHI=110.0_r8
        case ( -2 )
          RHI=1.0e-9_r8
        end select

      ! find the index for the top of saturation levels
d315 1
a315 2
        & 1, nearest=.true.)

d351 1
a351 1
      end if      ! i_supersat
d391 3
@


2.43
log
@another cleanup
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.42 2003/02/13 00:42:46 dwu Exp $"
a173 4

! Local variables
    integer :: my_supersat

d175 2
a176 4
    my_supersat = 0
    if ( present( i_supersat) ) my_supersat = i_supersat
    if ( my_supersat /= 0 ) then
      if ( .not. present(temp_supersat) ) &
d178 1
a178 1
        & 'temp_supersat must be supplied for supersaturation' )
d218 1
a218 1
      if ( present(temp_supersat) ) then
d318 3
a320 3
! modify h2o mixing ratio if a special supersaturation request is present
      if ( my_supersat /= 0 .and. ii == h2o_ind ) then
        select case ( my_supersat )
d366 1
a366 1
      end if      ! my_supersat
d406 3
@


2.42
log
@fix bugs and add comments for i_saturation
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.41 2003/02/13 00:07:22 jonathan Exp $"
a331 1
        values_index = f_len - 1 + 1 + kf*(supersat_Index-1)
d412 3
@


2.42.2.1
log
@a clean up
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.42 2003/02/13 00:42:46 dwu Exp $"
d332 1
a412 3
! Revision 2.42  2003/02/13 00:42:46  dwu
! fix bugs and add comments for i_saturation
!
@


2.42.2.2
log
@Non-supersat bug fixed
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.44 2003/02/14 17:53:34 pwagner Exp $"
d174 4
d179 4
a182 2
    if ( i_supersat /= 0 ) then
      if ( size(temp_supersat) < 1 ) &
d184 1
a184 1
        & 'temp_supersat must be allocated for supersaturation' )
d224 1
a224 1
      if ( i_supersat /= 0 ) then
d324 3
a326 3
! modify h2o mixing ratio if a special supersaturation /= 0
      if ( i_supersat /= 0 .and. ii == h2o_ind ) then
        select case ( i_supersat )
d372 1
a372 1
      end if      ! i_supersat
a411 3
! Revision 2.42.2.1  2003/02/13 18:33:18  dwu
! a clean up
!
@


2.42.2.3
log
@Cosmetic changes
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.42.2.2 2003/02/14 18:11:43 pwagner Exp $"
d164 6
a169 6
    integer :: Supersat_Index
    integer :: Wf
    integer :: F_index
    integer :: Z_index
    integer :: Values_index
    real(r8), parameter :: refPRESSURE = 100.0_r8
d171 2
a174 2

!??? Could this be tested where the L2CF is analyzed?
d179 1
a179 1
    end if
d192 2
a193 2
    call allocate_test ( Grids_x%lin_log, no_mol, 'lin_log', ModuleName )
    call allocate_test ( Grids_x%min_val, no_mol, 'min_val', ModuleName )
d222 1
a222 1
      end if
d305 13
d328 2
a329 2
        call Hunt (Grids_x%zet_basis(l:n-1), -log10(refPRESSURE), &
          & supersat_Index, 1, nearest=.true.)
d342 7
a348 10
!??? Can we eliminate this branch if we do this BEFORE the previous
!??? test for Grids_x%lin_log(ii) ???
            do wf = wf1, wf2
              do f_index = 1, kf
                do z_index = 1, supersat_Index
                  values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
                  Grids_x%values(values_index) = &
                   & log(RHIFromH2O_Factor (temp_supersat(z_index), &
                   & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI)
                end do
d351 1
d353 7
a359 8
            do wf = wf1, wf2
              do f_index = 1, kf
                do z_index = 1, supersat_Index
                  values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
                  Grids_x%values(values_index) = &
                   & RHIFromH2O_Factor (temp_supersat(z_index), &
                   & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI
                end do
d361 3
a363 7
            end do          
          end if   ! linear or log basis

        end if     ! check supersat_index
      end if       ! i_supersat

! set 'do derivative' flags
d365 2
a366 10
      if ( fwdModelConf%moleculeDerivatives(i) .and. foundInFirst ) then
        if ( associated(f%mask) ) then
          Grids_x%deriv_flags(f_len:r-1) = reshape(( iand (M_FullDerivatives, &
            & ichar(f%mask)) == 0),(/kf*kz*kp/))
        else
          Grids_x%deriv_flags(f_len:r-1) = .true.
        end if
      else
        grids_x%deriv_flags(f_len:r-1) = .false.
      end if
a405 3
! Revision 2.42.2.2  2003/02/14 18:11:43  pwagner
! Non-supersat bug fixed
!
@


2.42.2.4
log
@Split some cloud stuff into a separate routine
@
text
@d11 1
a11 1
  public :: Load_SPS_Data, Destroygrids_t, Load_One_Grid, Modify_Values_For_Supersat
d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.42.2.3 2003/03/06 21:53:09 vsnyder Exp $"
d124 3
a126 1
    use Molecules, only: Spec_tags, SP_Extinction, SP_H2O
d156 1
a156 1
    integer :: j, k, l, m, mol, n, r, s, kz, kp, kf
d164 7
d175 4
a178 6
    if ( present(i_supersat) ) then
      if ( i_supersat /= 0 ) then
        if ( size(temp_supersat) < 1 ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'temp_supersat must be allocated for supersaturation' )
      end if
d202 3
a204 3
    p_len=0
    ext_ind = 0
    h2o_ind = 0
d211 1
a211 2
      mol = mol_cat_index(ii)
      kk = FwdModelConf%molecules(mol)
a212 1
      if ( spec_tags(kk) == sp_extinction ) ext_ind = ii ! memorize extiction ix
d215 1
a215 1
        & quantityType=quantityType, molIndex=mol, &
d218 4
a221 8
!??? Could this be tested where the L2CF is analyzed ???
!??? Do we want to do this for all molecules, or just H2O ???
      if ( present(i_supersat) ) then
        if ( i_supersat /= 0 ) then
          if ( kz /= size(temp_supersat) ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'template for this molecule on different vertical grid' )
        end if
d252 1
a252 1
    call allocate_test ( Grids_x%zet_basis, n_f_zet, 'Grids_x%zet_basis', &
d254 1
a254 1
    call allocate_test ( Grids_x%phi_basis, n_f_phi, 'Grids_x%phi_basis', &
d256 1
a256 1
    call allocate_test ( Grids_x%frq_basis, n_f_frq, 'Grids_x%frq_basis', &
d258 1
a258 1
    call allocate_test ( Grids_x%values, f_len, 'Grids_x%values', &
d260 1
a260 1
    call allocate_test ( Grids_x%deriv_flags, f_len, 'Grids_x%deriv_flags', &
d268 1
a268 1
      mol = mol_cat_index(ii)
d270 1
a270 1
        & quantityType=quantityType, molIndex=mol, radiometer=radiometer, &
d306 50
a355 6
      if ( present(i_supersat) ) then
        if ( i_supersat /= 0 .and. ii == h2o_ind ) then
          call modify_values_for_supersat ( grids_x, h2o_ind, i_supersat, &
                                          & temp_supersat, l, n, f_len )
        end if       ! i_supersat /= 0 .and. ii == h2o_ind
      end if         ! present(i_supersat)
d359 1
a359 1
      if ( fwdModelConf%moleculeDerivatives(mol) .and. foundInFirst ) then
d381 2
a382 86
  !  --------------------------------  Modify_Values_For_Supersat  -----

  subroutine Modify_Values_For_Supersat ( Grids_X, H2O_ind, I_Supersat, &
                                        & Temp_Supersat, Zet1, Zet2, V1 )

    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use MLSNumerics, only: HUNT
    use RHIFromH2O, only: RHIFromH2O_Factor

    type (Grids_T), intent(inout) :: Grids_x   ! All the coordinates
    integer, intent(in) :: H2O_ind             ! Where is H2O in Grids_X?
    integer, intent(in) :: I_Supersat          ! Do the suprsaturation calculation?
    !-----------------------------------------------------------------------------
    ! i_supersat indicates different clear and cloudy sky combinations:
    !        i_supersat =-1 is for clear-sky radiance limit assuming 110%RHi
    !        i_supersat =-2 is for clear-sky radiance limit assuming 0%RHi
    !-----------------------------------------------------------------------------
    real(r8), intent(in) :: Temp_Supersat(:)   ! What temperatures to use for supersaturation
    integer, intent(in) :: Zet1, Zet2          ! Zeta_basis range is zet1:zet2-1
    integer, intent(in) :: V1                  ! Starting point in Values array

    integer :: F_index
    integer :: KF, KZ
    real(r8), parameter :: refPRESSURE = 100.0_r8
    real(r8) :: RHI 
    integer :: Supersat_Index
    integer :: Values_index
    integer :: Wf, Wf1, Wf2
    integer :: Z_index

    kf = Grids_x%no_f(h2o_ind)
    kz = Grids_x%no_z(h2o_ind)
    wf1 = Grids_x%windowStart(h2o_ind)
    wf2 = Grids_x%windowFinish(h2o_ind)

    select case ( i_supersat )
    case ( -1 )
      RHI=110.0_r8
    case ( -2 )
      RHI=1.0e-9_r8
    end select

  ! find the index for the top of saturation levels
    call Hunt (Grids_x%zet_basis(zet1:zet2-1), -log10(refPRESSURE), &
      & supersat_Index, 1, nearest=.true.)

    if (supersat_Index < 1) then        
       call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Could not find value of Zeta in Grid_T; returned index too small' )

    else if (supersat_Index > size(Grids_x%values) ) then
       call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Could not find value of Zeta in Grid_T; returned index too BIG' )
    else

    ! H2O may have log basis functions
      if ( Grids_x%lin_log(h2o_ind) ) then
        do wf = wf1, wf2
          do f_index = 1, kf
            do z_index = 1, supersat_Index
              values_index = v1 - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
              Grids_x%values(values_index) = &
                & log(RHIFromH2O_Factor (temp_supersat(z_index), &
                & grids_x%zet_basis(zet1+z_index-1), 0, .true.)*RHI)
            end do
          end do
        end do
      else
        do wf = wf1, wf2
          do f_index = 1, kf
            do z_index = 1, supersat_Index
              values_index = v1 - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
              Grids_x%values(values_index) = &
                & RHIFromH2O_Factor (temp_supersat(z_index), &
                & grids_x%zet_basis(zet1+z_index-1), 0, .true.)*RHI
            end do
          end do
        end do          
      end if   ! linear or log basis

    end if     ! check supersat_index

  end subroutine Modify_Values_For_Supersat

  !  --------------------------------------------  DestroyGrids_t  -----
  subroutine DestroyGrids_t ( grids_x )
d385 1
a385 1
    type (Grids_T), intent(inout) :: Grids_x
a407 3
! Revision 2.42.2.3  2003/03/06 21:53:09  vsnyder
! Cosmetic changes
!
@


2.42.2.5
log
@Revise Grids_T structure
@
text
@d11 1
a11 3
  public :: Load_SPS_Data, Modify_Values_For_Supersat
  public :: Create_Grids_1, Create_Grids_2, Destroygrids_t
  public :: Dump, Dump_Grids
d14 3
a16 5
    integer,  pointer :: l_f(:) => null() ! Last entry in frq. grid per sps
    integer,  pointer :: l_z(:) => null() ! Last entry in zeta grid per sps
    integer,  pointer :: l_p(:) => null() ! Last entry in phi  grid per sps
    integer,  pointer :: l_v(:) => null() ! Last entry in values grid per sps
    integer :: P_Len ! \sum_i=1^n (l_z(i)-l_z(i-1))*(l_p(i)-l_p(i-1))
a32 4
  interface Dump
    module procedure Dump_Grids
  end interface

d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.42.2.4 2003/03/08 00:03:08 vsnyder Exp $"
d47 12
a58 2
       &    radiometer, mol_cat_index, QuantityType, Grids_x,      &
       &    h2o_ind, ext_ind )
d60 58
d135 2
d141 11
a151 3
    integer, intent(out), optional :: H2O_IND
    integer, intent(out), optional :: EXT_IND

d154 2
a155 1

a156 2
    integer :: no_mol, mol, my_ext_ind, my_h2o_ind
    integer :: pf, qf, pp, qp, pv, qv, pz, qz, kf, kp, kz
d158 1
a158 1
    type (VectorValue_T), pointer :: QTY     ! An arbitrary vector quantity
d165 9
d178 9
a186 1
    call create_grids_1 ( Grids_x, no_mol )
d188 3
d193 5
a197 3
    grids_x%p_len = 0
    my_ext_ind = 0
    my_h2o_ind = 0
d206 2
a207 2
      if ( spec_tags(kk) == sp_h2o ) my_h2o_ind = ii        ! memorize h2o index
      if ( spec_tags(kk) == sp_extinction ) my_ext_ind = ii ! memorize extiction ix
d209 1
a209 1
      qty => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d212 32
d245 3
a247 2
      call fill_grids_1 ( grids_x, ii, qty, phitan, fmStat%maf, fwdModelConf )
    end do
d251 10
a260 1
    call create_grids_2 ( Grids_x )
d262 4
a265 4
    pp = 0
    pz = 0
    pf = 0
    pv = 0
d268 1
a268 1
      qty => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
d271 6
a276 6
      qz = Grids_x%l_z(ii)
      qp = Grids_x%l_p(ii)
      qf = Grids_x%l_f(ii)
      kz = qz - pz
      kp = qp - pp
      kf = qf - pf
d279 4
a282 4
      Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1)
      Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,wf1:wf2)*Deg2Rad
      if ( associated ( qty%template%frequencies ) ) then
        if ( qty%template%frequencyCoordinate /= l_intermediateFrequency ) &
d285 1
a285 1
        Grids_x%frq_basis(pf+1:qf) = qty%template%frequencies
d287 1
a287 1
        Grids_x%frq_basis(pf+1:qf) = 0.0
d290 1
a290 1
! ** ZEBUG - Simulate qty%values for EXTINCTION, using the N2 function
d294 3
a296 4
      qv = Grids_x%l_v(ii)
      ! kp == wf2 - wf1 + 1 and qv - pv == kp * kf * kz here
      Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,wf1:wf2), &
                                      & (/qv-pv/))
d298 4
a301 6
      Grids_x%lin_log(ii) = qty%template%logBasis
      if ( qty%template%logBasis ) then
        Grids_x%min_val(ii) = qty%template%minValue
        where ( Grids_x%values(pv+1:qv) <= grids_x%min_val(ii) ) &
             & Grids_x%values(pv+1:qv) = grids_x%min_val(ii)
        Grids_x%values(pv+1:qv) = log(Grids_x%values(pv+1:qv))
d304 8
d315 3
a317 3
        if ( associated(qty%mask) ) then
          Grids_x%deriv_flags(pv+1:qv) = reshape(( iand (M_FullDerivatives, &
            & ichar(qty%mask)) == 0),(/qv-pv/))
d319 1
a319 1
          Grids_x%deriv_flags(pv+1:qv) = .true.
d322 1
a322 1
        grids_x%deriv_flags(pv+1:qv) = .false.
d325 4
a328 4
      pp = qp
      pz = qz
      pf = qf
      pv = qv
d332 1
a332 2
    if ( present(ext_ind) ) ext_ind = my_ext_ind
    if ( present(h2o_ind) ) h2o_ind = my_h2o_ind
d334 1
a334 1
  end subroutine Load_SPS_Data
d339 1
a339 1
                                        & Temp_Supersat )
d354 2
a363 1
    integer :: V1                              ! Starting point in Values array
a364 1
    integer :: Zet1, Zet2                      ! Zeta_basis range is zet1:zet2-1
d366 2
a367 3
    kf = Grids_x%l_f(h2o_ind) - Grids_x%l_f(h2o_ind-1)
    kz = Grids_x%l_z(h2o_ind) - Grids_x%l_z(h2o_ind-1)
    v1 = Grids_x%l_z(h2o_ind-1) + 1
a369 2
    zet1 = Grids_x%l_z(h2o_ind-1)
    zet2 = Grids_x%l_z(h2o_ind)
d379 1
a379 1
    call Hunt (Grids_x%zet_basis(zet1+1:zet2), -log10(refPRESSURE), &
d398 2
a399 2
                & log ( RHIFromH2O_Factor ( temp_supersat(z_index), &
                &   grids_x%zet_basis(zet1+z_index), 0, .true. ) * RHI )
d409 2
a410 2
                & RHIFromH2O_Factor ( temp_supersat(z_index), &
                &   grids_x%zet_basis(zet1+z_index), 0, .true. ) * RHI
a419 82
  !  --------------------------------------------  Create_Grids_1  -----
  subroutine Create_Grids_1 ( Grids_x, N )
  ! Create the part of the Grids_T structure that doesn't depend on the
  ! number of values or lengths of bases

    use Allocate_Deallocate, only: Allocate_test

    type (Grids_T), intent(inout) :: Grids_X
    integer, intent(in) :: N

    call allocate_test ( Grids_x%l_z, n, 'Grids_x%l_z', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_p, n, 'Grids_x%l_p', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_f, n, 'Grids_x%l_f', ModuleName, lowBound=0 )
    call allocate_test ( Grids_x%l_v, n, 'Grids_x%l_v', ModuleName, lowBound=0 )
    Grids_x%l_z(0) = 0
    Grids_x%l_p(0) = 0
    Grids_x%l_f(0) = 0
    Grids_x%l_v(0) = 0
    grids_x%p_len = 0
    call allocate_test ( Grids_x%windowstart, n, 'Grids_x%windowstart', &
                       & ModuleName )
    call allocate_test ( Grids_x%windowfinish, n, 'Grids_x%windowfinish',&
                       & ModuleName )
    call allocate_test ( Grids_x%lin_log, n, 'lin_log', ModuleName )
    call allocate_test ( Grids_x%min_val, n, 'min_val', ModuleName )

  end subroutine Create_Grids_1

  !  --------------------------------------------  Create_Grids_2  -----
  subroutine Create_Grids_2 ( Grids_x )
  ! Create the part of the Grids_T structure that depends on the
  ! number of values and lengths of bases

    use Allocate_Deallocate, only: Allocate_test

    type (Grids_T), intent(inout) :: Grids_X

    integer :: N
    n = ubound(grids_x%l_z,1)

    call allocate_test ( Grids_x%zet_basis, Grids_x%l_z(n), 'Grids_x%zet_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%phi_basis, Grids_x%l_p(n), 'Grids_x%phi_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%frq_basis, Grids_x%l_f(n), 'Grids_x%frq_basis', &
                       & ModuleName )
    call allocate_test ( Grids_x%values, Grids_x%l_v(n), 'Grids_x%values', &
                       & ModuleName )
    call allocate_test ( Grids_x%deriv_flags, Grids_x%l_v(n), 'Grids_x%deriv_flags', &
                       & ModuleName )
  end subroutine Create_Grids_2

  ! -----------------------------------------------  Fill_Grids_1  -----
  subroutine Fill_Grids_1 ( Grids_x, II, Qty, Phitan, Maf, FwdModelConf )
  ! Fill in the size information for the II'th element of Grids_x

    use ForwardModelConfig, only: ForwardModelConfig_t
    use ManipulateVectorQuantities, only: FindInstanceWindow
    use VectorsModule, only: VectorValue_T

    type(grids_T), intent(inout) :: Grids_x
    integer, intent(in) :: II
    type (vectorValue_T), intent(in) :: QTY     ! An arbitrary vector quantity
    type (vectorValue_T), intent(in) :: PHITAN  ! Tangent geodAngle component of
    integer, intent(in) :: MAF
    type(forwardModelConfig_T), intent(in) :: FwdModelConf

    integer :: KF, KP, KZ

    kf = qty%template%noChans ! == 1 if qty%template%frequencyCoordinate == l_none
    call FindInstanceWindow ( qty, phitan, maf, fwdModelConf%phiWindow, &
      & fwdModelConf%windowUnits, grids_x%windowStart(ii), grids_x%windowFinish(ii) )
    kp = grids_x%windowFinish(ii) - grids_x%windowStart(ii) + 1
    kz = qty%template%noSurfs
    grids_x%l_f(ii) = grids_x%l_f(ii-1) + kf
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz
    grids_x%l_p(ii) = grids_x%l_p(ii-1) + kp
    grids_x%p_len = grids_x%p_len + kz * kp
    grids_x%l_v(ii) = grids_x%l_v(ii-1) + kz * kp * kf

  end subroutine Fill_Grids_1

d426 3
a428 4
    call deallocate_test(grids_x%l_f,'grids_x%l_f',modulename)
    call deallocate_test(grids_x%l_z,'grids_x%l_z',modulename)
    call deallocate_test(grids_x%l_p,'grids_x%l_p',modulename)
    call deallocate_test(grids_x%l_v,'grids_x%l_v',modulename)
a440 25
  ! -------------------------------------------------  Dump_Grids  -----
  subroutine Dump_Grids ( The_Grid, Name )
  ! Dump The_Grid

    use Dump_0, only: Dump
    use Output_M, only: Output

    type(grids_t), intent(in) :: The_Grid
    character(len=*), intent(in), optional :: Name

    call output ( 'Dump of Grids_T structure ', advance='no' )
    if ( present(name) ) call output ( name, advance='no' )
    call output ( '', advance='yes' )
    call dump ( the_grid%windowStart, 'The_grid%WindowStart' )
    call dump ( the_grid%windowFinish, 'The_grid%WindowFinish' )
    call dump ( the_grid%lin_log, 'The_grid%Lin_Log' )
    call dump ( the_grid%min_val, 'The_grid%Min_Val' )
    call dump ( the_grid%frq_basis, 'The_grid%Frq_Basis' )
    call dump ( the_grid%zet_basis, 'The_grid%Zet_Basis' )
    call dump ( the_grid%phi_basis, 'The_grid%Phi_Basis' )
    call dump ( the_grid%values, 'The_grid%Values' )
    call dump ( the_grid%deriv_flags, 'The_grid%Deriv_Flags' )

  end subroutine Dump_Grids

a446 3
! Revision 2.42.2.4  2003/03/08 00:03:08  vsnyder
! Split some cloud stuff into a separate routine
!
@


2.42.2.6
log
@More futzing with grids_t and stuff that uses it
@
text
@d11 3
a13 3
  public :: Load_Sps_Data, Load_One_Item_Grid, Modify_Values_For_Supersat
  public :: Create_Grids_1, Create_Grids_2, Fill_Grids_1, Fill_Grids_2
  public :: Destroygrids_t, Dump, Dump_Grids
d15 1
a15 1
  type, public :: Grids_T                 ! Fit all Gridding categories
d43 1
a43 1
    & "$Id: load_sps_data_m.f90,v 2.42.2.5 2003/03/20 01:42:26 vsnyder Exp $"
d54 1
a54 1
  subroutine Load_Sps_Data ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
d61 1
a61 1
    use Intrinsic, only: L_Phitan
d63 1
d65 2
a66 1
    use VectorsModule, only: Vector_T, VectorValue_T
d85 3
a87 1
    integer :: ii, kk, no_mol, mol, my_ext_ind, my_h2o_ind
d89 1
d92 1
a92 4
    type QtyStuff_T ! So we can have an array of pointers to QTY's
      type (VectorValue_T), pointer :: QTY
      logical :: FoundInFirst
    end type QtyStuff_T
d94 1
a94 1
    type(qtyStuff_t) :: QtyStuff( size( mol_cat_index ) )
d96 1
a96 1
! Begin code:
a112 1

d118 1
a118 2
      qtyStuff(ii)%qty => GetQuantityforForwardModel ( &
        & fwdModelIn, fwdModelExtra, &
d120 1
a120 5
        & radiometer=radiometer, config=fwdModelConf, &
        & foundInFirst=qtyStuff(ii)%foundInFirst )

      call fill_grids_1 ( grids_x, ii, qtyStuff(ii)%qty, phitan, fmStat%maf, &
        &                 fwdModelConf )
d122 1
d125 1
a125 1
    ! Allocate space for the zeta, phi, freq. basis and value components.
d129 4
d134 22
a155 6

      ! Fill the zeta, phi, freq. basis and value components.
      call fill_grids_2 ( grids_x, ii, qtyStuff(ii)%qty, &
        & fwdModelConf%moleculeDerivatives(mol) .and. qtyStuff(ii)%foundInFirst )

    end do
d161 12
a172 2
    if ( present(ext_ind) ) ext_ind = my_ext_ind
    if ( present(h2o_ind) ) h2o_ind = my_h2o_ind
d174 1
a174 1
  end subroutine Load_Sps_Data
d176 10
a185 5
  ! -----------------------------------------  Load_One_Item_Grid  -----
  subroutine Load_One_Item_Grid ( Grids_X, Qty, Phitan, Maf, FwdModelConf, &
    & SetDerivFlags )
  ! A simplification of Load_Sps_Data to load a grid that has only one
  ! quantity in it.
d187 4
a190 2
    use ForwardModelConfig, only: ForwardModelConfig_t
    use VectorsModule, only: VectorValue_T
d192 1
a192 10
    type(grids_t), intent(out) :: Grids_X
    type(vectorValue_t), intent(in) :: Qty, Phitan
    integer, intent(in) :: Maf
    type(forwardModelConfig_t), intent(in) :: FwdModelConf
    logical, intent(in) :: SetDerivFlags

    call create_grids_1 ( grids_x, 1 )
    call fill_grids_1 ( grids_x, 1, qty, phitan, maf, fwdModelConf )
    call create_grids_2 ( grids_x )
    call fill_grids_2 ( grids_x, 1, qty, setDerivFlags )
d194 4
a197 1
  end subroutine Load_One_Item_Grid
d199 1
a199 1
  ! ---------------------------------  Modify_Values_For_Supersat  -----
d223 1
d225 1
a225 1
    integer :: V1               ! One before starting point in Values array
d227 1
a227 1
    integer :: Zet1, Zet2       ! Zeta_basis range is zet1+1:zet2
d231 1
a231 1
    v1 = Grids_x%l_z(h2o_ind-1)
d262 2
a263 1
              Grids_x%values(v1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)) = &
d273 2
a274 1
              Grids_x%values(v1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)) = &
d286 1
a286 1
  ! ---------------------------------------------  Create_Grids_1  -----
d314 1
a314 1
  ! ---------------------------------------------  Create_Grids_2  -----
d361 1
d363 1
a364 2
    grids_x%l_z(ii) = grids_x%l_z(ii-1) + kz
    grids_x%p_len = grids_x%p_len + kz * kp
d368 1
a368 71
  ! -----------------------------------------------  Fill_Grids_2  -----
  subroutine Fill_Grids_2 ( Grids_x, II, Qty, SetDerivFlags )
  ! Fill the zeta, phi, freq. basis and value components for the II'th
  ! "molecule" in Grids_x.

    use Intrinsic, only: L_IntermediateFrequency
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Units, only: Deg2Rad
    use VectorsModule, only: VectorValue_T, M_FullDerivatives

    type(grids_t), intent(inout) :: Grids_x
    integer, intent(in) :: II
    type(vectorValue_T), intent(in) :: QTY     ! An arbitrary vector quantity
    logical, intent(in) :: SetDerivFlags

    integer :: KF, KZ, PF, PP, PV, PZ, QF, QP, QV, QZ, WF1, WF2

    pf = Grids_x%l_f(ii-1)
    pp = Grids_x%l_p(ii-1)
    pv = Grids_x%l_v(ii-1)
    pz = Grids_x%l_z(ii-1)

    qf = Grids_x%l_f(ii)
    qp = Grids_x%l_p(ii)
    qv = Grids_x%l_v(ii)
    qz = Grids_x%l_z(ii)

    kz = qz - pz
    kf = qf - pf
    wf1 = Grids_x%windowStart(ii)
    wf2 = Grids_x%windowFinish(ii)

    Grids_x%zet_basis(pz+1:qz) = qty%template%surfs(1:kz,1)
    Grids_x%phi_basis(pp+1:qp) = qty%template%phi(1,wf1:wf2)*Deg2Rad
    if ( associated ( qty%template%frequencies ) ) then
      if ( qty%template%frequencyCoordinate /= l_intermediateFrequency ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Unexpected frequency coordinate for quantity' )
      Grids_x%frq_basis(pf+1:qf) = qty%template%frequencies
    else
      Grids_x%frq_basis(pf+1:qf) = 0.0
    end if

    ! qv - pv == (wf2 - wf1 + 1) * kf * kz here
    Grids_x%values(pv+1:qv) = reshape(qty%values(1:kf*kz,wf1:wf2), &
                                    & (/qv-pv/))
    !  mixing ratio values are manipulated if it's log basis
    Grids_x%lin_log(ii) = qty%template%logBasis
    if ( qty%template%logBasis ) then
      Grids_x%min_val(ii) = qty%template%minValue
      where ( Grids_x%values(pv+1:qv) <= grids_x%min_val(ii) ) &
           & Grids_x%values(pv+1:qv) = grids_x%min_val(ii)
      Grids_x%values(pv+1:qv) = log(Grids_x%values(pv+1:qv))
    end if

    ! set 'do derivative' flags

    if ( setDerivFlags ) then
      if ( associated(qty%mask) ) then
        Grids_x%deriv_flags(pv+1:qv) = reshape(( iand (M_FullDerivatives, &
          & ichar(qty%mask)) == 0),(/qv-pv/))
      else
        Grids_x%deriv_flags(pv+1:qv) = .true.
      end if
    else
      grids_x%deriv_flags(pv+1:qv) = .false.
    end if

  end subroutine Fill_Grids_2

  ! ---------------------------------------------  DestroyGrids_t  -----
a420 3
! Revision 2.42.2.5  2003/03/20 01:42:26  vsnyder
! Revise Grids_T structure
!
@


2.42.2.7
log
@Get QtyStuff_T from ForwardModelVectorTools, embellish some comments
@
text
@d33 2
a34 6
    real(rp), pointer :: values(:) => null()    ! species values (ie vmr). 
!     This is really a three-dimensional quantity dimensioned frequency (or
!     1) X zeta (or 1) X phi (or 1), taken in Fortran's column-major
!     array-element order.
    logical,  pointer :: deriv_flags(:) => null() ! do derivatives flags
!     corresponding to the values component.
d43 1
a43 1
    & "$Id: load_sps_data_m.f90,v 2.42.2.6 2003/03/20 19:21:05 vsnyder Exp $"
d60 1
a60 1
    use ForwardModelVectorTools, only: GetQuantityForForwardModel, QtyStuff_T
d87 5
a459 3
! Revision 2.42.2.6  2003/03/20 19:21:05  vsnyder
! More futzing with grids_t and stuff that uses it
!
@


2.41
log
@another bug fix
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.40 2003/02/12 23:50:49 jonathan Exp $"
a163 1
    logical :: is_h2o
d218 2
a219 1
      if ( spec_tags(kk) == sp_h2o ) h2o_ind = ii
a268 2
    allocate(Grids_x_values(size(Grids_x%values)))
    Grids_x_values = Grids_x%values
a273 2
      kk = FwdModelConf%molecules(mol_cat_index(ii))
      is_h2o = ( spec_tags(kk) == sp_h2o ) 
d304 1
d324 2
a325 1
      if ( my_supersat /= 0 .and. is_h2o ) then
d334 1
d346 14
d364 2
a365 1
                Grids_x%values(values_index) = RHIFromH2O_Factor (temp_supersat(z_index), &
d369 2
a370 2
          end do
        end if
d372 2
a373 3
        values_index = f_len - 1 + 1 + kf*(supersat_Index-1)

      end if
a381 8
    diff = sum(abs(Grids_x_values - Grids_x%values))
    max_value = 0.
    do i=1, size(Grids_x%values)
      max_value = max(max_value, abs(Grids_x_values(i)))
    enddo

    deallocate(Grids_x_values)

d413 3
@


2.40
log
@add optional to i_supersat and temp_supersat
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.39 2003/02/11 00:48:25 jonathan Exp $"
d164 1
d276 2
d327 1
a327 1
      if ( my_supersat /= 0 ) then
d408 3
@


2.39
log
@fix index bug
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.38 2003/02/07 18:47:47 vsnyder Exp $"
d89 1
a89 2
! Begin code:

d146 1
a146 1
    integer, intent(in)  :: i_supersat     ! Do the suprsaturation calculation?
d152 1
a152 1
    real(r8), dimension(:), intent(in) :: &
d171 6
d178 8
d223 2
a224 1
      if ( kz /= size(temp_supersat) ) &
d227 1
d268 2
d324 2
a325 7
      j = k
      l = n
      s = m
      f_len = r

      if ( i_supersat /= 0 ) then
        select case ( i_supersat )
d330 2
a331 1
        end select  
d333 2
a334 2
        call Hunt (Grids_x%zet_basis(1:n-1), -log(refPRESSURE), supersat_Index, &
        & l, nearest=.true.)
d354 3
d359 5
d366 8
d405 3
@


2.38
log
@Back to 2.35
@
text
@d11 1
a11 1
  public :: Load_SPS_Data, Load_One_Grid, Destroygrids_t
d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.35 2003/02/07 03:30:37 vsnyder Exp $"
d144 4
a147 4
    integer, optional, intent(out) :: P_LEN
    integer, optional, intent(out) :: H2O_IND
    integer, optional, intent(out) :: EXT_IND
    integer, optional, intent(in)  :: i_supersat     ! Do the suprsaturation calculation?
d153 1
a153 1
    real(r8), dimension(:), optional, intent(in) :: &
d195 3
a197 3
    if ( present(p_len) ) p_len=0
    if ( present(ext_ind) ) ext_ind = 0
    if ( present(h2o_ind) ) h2o_ind = 0
d205 1
a205 1
      if ( present(h2o_ind) .and. spec_tags(kk) == sp_h2o ) h2o_ind = ii
d210 3
d226 1
a226 1
      if ( present(p_len) ) p_len = p_len + kz * kp
d376 3
@


2.37
log
@remove ===== at line 341 from the merge
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.36 2003/02/07 18:01:20 jonathan Exp $"
a308 37
      ! do the following only if i_supersat not equal to 0

      IF ( i_supersat .ne. 0 ) THEN
            select case ( i_supersat )
            case ( -1 )
              RHI=110.0_r8
            case ( -2 )
              RHI=1.0e-9_r8
            end select  

      call Hunt (Grids_x%zet_basis(1:n-1), -log(refPRESSURE), supersat_Index, &
      & l, nearest=.true.)
      
      If (supersat_Index < 1) Then        
         call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Could not find value of Zeta in Grid_T; returned index too small' )
      
      Else If (supersat_Index > size(Grids_x%values) ) Then
         call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Could not find value of Zeta in Grid_T; returned index too BIG' )
      Else
       do wf=wf1, wf2
         do f_index=1, kf
           do z_index=1, supersat_Index
             values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
             Grids_x%values(values_index) = RHIFromH2O_Factor (temp_supersat(z_index), &
              & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI
           end do
         end do
       end do
      Endif
      ENDIF

!??? The next line is almost surely wrong.  It is inconsistent with the
!??? above comment, and it leads to using RHI without it having a value
!??? about twenty lines down from here.
!     if ( i_supersat .eq. 0 ) then
a372 3
! Revision 2.36  2003/02/07 18:01:20  jonathan
! change  IF ( i_supersat .eq. 0 ) to .ne. 0
!
@


2.36
log
@change  IF ( i_supersat .eq. 0 ) to .ne. 0
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.35 2003/02/07 03:30:37 vsnyder Exp $"
d341 1
a341 1
=======
d410 3
@


2.35
log
@Correct i_supersat test?
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.34 2003/02/07 02:00:48 vsnyder Exp $"
d310 32
d410 3
@


2.34
log
@Move some USE statements down
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.33 2003/02/07 01:07:53 jonathan Exp $"
a308 2


d310 34
a343 30
      IF ( i_supersat .eq. 0 ) THEN
            select case ( i_supersat )
            case ( -1 )
              RHI=110.0_r8
            case ( -2 )
              RHI=1.0e-9_r8
            end select  

      call Hunt (Grids_x%zet_basis(1:n-1), -log(refPRESSURE), supersat_Index, &
      & l, nearest=.true.)
      
      If (supersat_Index < 1) Then        
         call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Could not find value of Zeta in Grid_T; returned index too small' )
      
      Else If (supersat_Index > size(Grids_x%values) ) Then
         call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'Could not find value of Zeta in Grid_T; returned index too BIG' )
      Else
       do wf=wf1, wf2
         do f_index=1, kf
           do z_index=1, supersat_Index
             values_index = f_len - 1 + f_index + kf*(z_index-1) + kf*kz*(wf-wf1)
             Grids_x%values(values_index) = RHIFromH2O_Factor (temp_supersat(z_index), &
              & grids_x%zet_basis(l+z_index-1), 0, .true.)*RHI
           end do
         end do
       end do
      Endif
      ENDIF
d378 3
@


2.33
log
@add in option to compute dry and super-saturation case in load_sps
@
text
@a6 2
  use MLSNumerics, only: HUNT
  use RHIFromH2O, only: RHIFromH2O_Factor
d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.32 2003/02/06 20:00:06 vsnyder Exp $"
d125 1
d127 1
d376 3
@


2.32
log
@Make Load_One_Grid a public module procedure instead of internal
@
text
@d7 2
d37 1
a37 1
    & "$Id: load_sps_data_m.f90,v 2.31 2003/01/26 04:42:42 livesey Exp $"
d51 1
a51 1
       &    Grids_dv )
d83 8
d95 1
a95 1
       & ext_ind )
d118 1
a118 1
       &    h2o_ind, ext_ind )
d147 8
a154 1

d165 7
d309 34
d376 3
@


2.31
log
@Added profiles/angle options for phiWindow
@
text
@d11 1
a11 1
  public :: Load_SPS_Data, Destroygrids_t
d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.30 2002/11/23 02:49:33 vsnyder Exp $"
d42 3
a44 1
!-------------------------------------------------------------------
d46 3
a48 3
 subroutine Load_SPS_Data ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, p_len, f_len, h2o_ind, ext_ind,       &
       &    Grids_f, f_len_dw, Grids_dw, f_len_dn, Grids_dn, f_len_dv,       &
a50 1
    use Allocate_Deallocate, only: Allocate_test
d53 2
a54 7
    use ForwardModelVectorTools, only: GetQuantityForForwardModel
    use intrinsic, only: L_VMR, L_NONE, L_PHITAN, L_IntermediateFrequency
    use ManipulateVectorQuantities, only: FindInstanceWindow
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
    use Molecules, only: Spec_tags
    use Units, only: Deg2Rad
    use VectorsModule, only: Vector_T, VectorValue_T, M_FullDerivatives
d84 1
a84 1
       & radiometer, mol_cat_index, f_len, 'f', Grids_f, p_len, h2o_ind,&
d92 1
a92 1
!        & radiometer, mol_cat_index, f_len_dw, 'w', Grids_dw)
d96 1
a96 1
!        & radiometer, mol_cat_index, f_len_dn, 'n', Grids_dn)
d100 1
a100 1
!        & radiometer, mol_cat_index, f_len_dv, 'v', Grids_dv)
d102 1
a102 2
  contains
    !  ...........................................  Load_One_Grid  .....
d104 1
a104 3
    subroutine Load_One_Grid ( FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
         &    radiometer, mol_cat_index, f_len, Grid_type, Grids_x, p_len,      &
         &    h2o_ind, ext_ind )
d106 3
a108 3
      type(forwardModelConfig_T), intent(in) :: fwdModelConf
      type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
      type(forwardModelStatus_t), intent(in) :: FmStat ! Reverse comm. stuff
d110 10
a119 2
      integer, intent(in) :: RADIOMETER       
      integer, intent(in) :: MOL_CAT_INDEX(:) 
d121 3
a123 9
      integer, intent(out) :: F_LEN

      character(len=1), intent(in) :: Grid_type

      type (Grids_T), intent(out) :: Grids_x   ! All the coordinates

      integer, optional, intent(out) :: P_LEN
      integer, optional, intent(out) :: H2O_IND
      integer, optional, intent(out) :: EXT_IND
d125 2
a126 2
  !** ZEBUG: When Intrinsic has (l_dw, l_dn & l_dv), get rid of the following 
  !   4 lines of code
d128 1
a128 3
      integer, parameter :: l_dw = 1
      integer, parameter :: l_dn = 2
      integer, parameter :: l_dv = 3
d130 1
a130 1
  ! Local variables:
d132 1
a132 3
      integer :: i, j, k, l, m, n, r, s, kz, kp, kf
      integer :: n_f_phi, n_f_zet, n_f_frq, no_mol, l_x
      integer :: ii, kk, wf1, wf2
d134 139
a272 49
      type (VectorValue_T), pointer :: F             ! An arbitrary species
      type (VectorValue_T), pointer :: PHITAN ! Tangent geodAngle component of

      logical :: FoundInFirst           ! Flag


      !******************* LOAD SPECIES DATA ************

      no_mol = size( mol_cat_index )

      call allocate_test ( Grids_x%no_z,no_mol,'Grids_x%no_z',ModuleName )
      call allocate_test ( Grids_x%no_p,no_mol,'Grids_x%no_p',ModuleName )
      call allocate_test ( Grids_x%no_f,no_mol,'Grids_x%no_f',ModuleName )
      call allocate_test ( Grids_x%windowstart,no_mol,'Grids_x%windowstart', &
                         & ModuleName )
      call allocate_test ( Grids_x%windowfinish,no_mol,'Grids_x%windowfinish',&
                         & ModuleName )
      call Allocate_test ( Grids_x%lin_log, no_mol, 'lin_log', ModuleName )
      call Allocate_test ( Grids_x%min_val, no_mol, 'min_val', ModuleName )

      Grids_x%no_z = 0
      Grids_x%no_p = 0
      Grids_x%no_f = 0
      grids_x%min_val = -huge(0.0_r8)

      f_len = 0

      if ( present(p_len) ) p_len=0
      if ( present(ext_ind) ) ext_ind = 0
      if ( present(h2o_ind) ) h2o_ind = 0

      phitan => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_phitan, config=fwdModelConf, &
        & instrumentModule=FwdModelConf%signals(1)%instrumentModule )

      l_x = l_vmr
      if ( Grid_type == 'W' .or. Grid_type == 'w' ) l_x = l_dw
      if ( Grid_type == 'N' .or. Grid_type == 'n' ) l_x = l_dn
      if ( Grid_type == 'V' .or. Grid_type == 'v' ) l_x = l_dv

      do ii = 1, no_mol
        kk = FwdModelConf%molecules(mol_cat_index(ii))
        if ( present(h2o_ind) .and. spec_tags(kk) == 18003 ) h2o_ind = ii
        f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_x, molIndex=mol_cat_index(ii), &
          & radiometer=radiometer, config=fwdModelConf )
        kz = f%template%noSurfs
        if ( f%template%frequencyCoordinate == l_none ) then
          kf = 1
d274 1
a274 1
          kf = f%template%noChans
d276 3
a278 17
        call FindInstanceWindow ( f, phitan, fmStat%maf, FwdModelConf%phiWindow, &
          & FwdModelConf%windowUnits, wf1, wf2 )
        Grids_x%windowStart(ii) = wf1
        Grids_x%windowFinish(ii) = wf2
        kp = wf2 - wf1 + 1
        Grids_x%no_f(ii) = kf
        Grids_x%no_z(ii) = kz
        Grids_x%no_p(ii) = kp
        if ( present(p_len) ) p_len = p_len + kz * kp
        f_len = f_len + kz * kp * kf
        if ( f%template%logBasis ) then
          Grids_x%lin_log(ii) = .true.
          Grids_x%min_val(ii) = f%template%minValue
        else
          Grids_x%lin_log(ii) = .false.
        end if
      end do
d280 4
a283 44
      n_f_zet = sum(Grids_x%no_z)
      n_f_phi = sum(Grids_x%no_p)
      n_f_frq = sum(Grids_x%no_f)

  ! Allocate space for the zeta, phi & freq. basis componenets

      call allocate_test ( Grids_x%zet_basis,n_f_zet,'Grids_x%zet_basis', &
                         & ModuleName )
      call allocate_test ( Grids_x%phi_basis,n_f_phi,'Grids_x%phi_basis', &
                         & ModuleName )
      call allocate_test ( Grids_x%frq_basis,n_f_frq,'Grids_x%frq_basis', &
                         & ModuleName )
      call allocate_test ( Grids_x%values,f_len,'Grids_x%values', &
                         & ModuleName )
      call allocate_test ( Grids_x%deriv_flags,f_len,'Grids_x%deriv_flags',&
                         & ModuleName )

      j = 1
      l = 1
      s = 1
      f_len = 1
      do ii = 1, no_mol
        i = mol_cat_index(ii)
        f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_x, molIndex=i, radiometer=radiometer, config=fwdModelConf, &
          & foundInFirst=foundInFirst )
        kz = Grids_x%no_z(ii)
        kp = Grids_x%no_p(ii)
        kf = Grids_x%no_f(ii)
        n = l + kz
        m = s + kf
        k = j + kp
        wf1 = Grids_x%windowStart(ii)
        wf2 = Grids_x%windowFinish(ii)
        Grids_x%zet_basis(l:n-1) = f%template%surfs(1:kz,1)
        Grids_x%phi_basis(j:k-1) = f%template%phi(1,wf1:wf2)*Deg2Rad
        if ( associated ( f%template%frequencies ) ) then
          if ( f%template%frequencyCoordinate /= l_intermediateFrequency ) &
            & call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'Unexpected frequency coordinate for quantity' )
          Grids_x%frq_basis(s:m-1) = f%template%frequencies
        else
          Grids_x%frq_basis(s:m-1) = 0.0
        end if
d285 1
a285 12
  ! ** ZEBUG - Simulate f%values for EXTINCTION, using the N2 function
  !  (Some code here ...)
  ! ** END ZEBUG

        r = f_len + kf * kz * kp
        Grids_x%values(f_len:r-1) = reshape(f%values(1:kf*kz,wf1:wf2), &
                                        & (/kf*kz*kp/))
        if ( Grids_x%lin_log(ii) ) then
          where ( Grids_x%values(f_len:r-1) <= grids_x%min_val(ii) ) &
               & Grids_x%values(f_len:r-1) = grids_x%min_val(ii)
          Grids_x%values(f_len:r-1) = log(Grids_x%values(f_len:r-1))
        end if
d287 1
a287 1
  ! set 'do derivative' flags
d289 1
a289 22
        if ( fwdModelConf%moleculeDerivatives(i) .and. foundInFirst ) then
          if ( associated(f%mask) ) then
            Grids_x%deriv_flags(f_len:r-1) = reshape(( iand (M_FullDerivatives,&
              & ichar(f%mask)) == 0),(/kf*kz*kp/))
          else
            Grids_x%deriv_flags(f_len:r-1) = .true.
          end if
        else
          grids_x%deriv_flags(f_len:r-1) = .false.
        end if

        j = k
        l = n
        s = m
        f_len = r

      end do

      f_len = f_len - 1

    end subroutine Load_One_Grid
  end subroutine Load_Sps_Data
d318 3
@


2.30
log
@Cosmetic changes
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.29 2002/10/08 17:08:05 pwagner Exp $"
d196 1
a196 1
                                & wf1, wf2 )
d323 3
@


2.29
log
@Added idents to survive zealous Lahey optimizer
@
text
@d6 1
a6 1
  use MLSCommon, only: R8, RP, IP
d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.28 2002/10/03 05:37:53 livesey Exp $"
d37 1
a37 1
  character (LEN=*), parameter :: ModuleName= &
d39 1
a39 1
  private :: not_used_here 
d317 1
a317 1
  logical function not_used_here()
d319 1
a319 1
  end function not_used_here
d323 3
@


2.28
log
@Minor efficiency improvement in derivative selection
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.27 2002/10/02 22:42:39 vsnyder Exp $"
d39 1
d317 4
d323 3
@


2.27
log
@Move USE statements from module scope to procedure scope.  Make Load_One_Grid
an internal subroutine of Load_SPS_Data.  Cosmetic changes.
@
text
@d35 1
a35 1
    & "$Id: load_sps_data_m.f90,v 2.26 2002/09/26 18:02:10 livesey Exp $"
d145 2
d236 2
a237 1
          & quantityType=l_x, molIndex=i, radiometer=radiometer, config=fwdModelConf )
d272 1
a272 1
        if ( fwdModelConf%moleculeDerivatives(i) ) then
d318 4
@


2.26
log
@Now uses GetQuantityForForwardModel.
@
text
@d5 1
a6 12
  use Units, only: Deg2Rad
  use ForwardModelConfig, only: FORWARDMODELCONFIG_T
  use ForwardModelIntermediate, only: FORWARDMODELSTATUS_T
  use ForwardModelVectorTools, only: GetQuantityForForwardModel
  use intrinsic, only: L_VMR, L_NONE, L_PHITAN, L_INTERMEDIATEFREQUENCY
  use VectorsModule, only: Vector_T, VectorValue_T, M_FullDerivatives
  use Molecules, only: spec_tags, L_EXTINCTION
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error

  use SpectroscopyCatalog_m, only: CATALOG_T
  use manipulatevectorquantities, only: FindInstanceWindow
d8 1
a8 1
  implicit none
d11 1
a11 1
  public :: load_sps_data, Destroygrids_t
d34 3
a36 2
  character (LEN=256) :: Id = &
   "$Id: load_sps_data_m.f90,v 2.25 2002/09/24 21:37:01 livesey Exp $"
d38 1
a38 1
   "$RCSfile: load_sps_data_m.f90,v $"
d43 15
a57 4
 subroutine load_sps_data(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, p_len, f_len, h2o_ind, ext_ind,     &
       &    Grids_f, f_len_dw, Grids_dw, f_len_dn, Grids_dn, f_len_dv,     &
       &    Grids_dv)
d83 1
a83 1
!
d85 2
a86 2
!
    call load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
d89 1
a89 1
!
d92 2
a93 2
!
!   if( PRESENT ( Grids_dw ) ) &
d96 2
a97 2
!
!   if( PRESENT ( Grids_dn ) ) &
d100 2
a101 2
!
!   if( PRESENT ( Grids_dv ) ) &
a103 7
!
 end subroutine load_sps_data
!-------------------------------------------------------------------
!
 subroutine load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
       &    radiometer, mol_cat_index, f_len, Grid_type, Grids_x, p_len,   &
       &    h2o_ind, ext_ind)
d105 39
a143 3
    type(forwardModelConfig_T), intent(in) :: fwdModelConf
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    type(forwardModelStatus_t), intent(in) :: FmStat ! Reverse comm. stuff
a144 2
    integer, intent(in)  :: RADIOMETER
    integer, intent(in)  :: MOL_CAT_INDEX(:)
d146 1
a146 1
    integer, intent(out) :: F_LEN
d148 1
a148 3
    integer, optional, intent(out) :: P_LEN
    integer, optional, intent(out) :: H2O_IND
    integer, optional, intent(out) :: EXT_IND
d150 9
a158 1
    type (Grids_T), intent(out) :: Grids_x   ! All the coordinates
d160 4
a163 8
    character(LEN=1), intent(in) :: Grid_type
!
!** ZEBUG: When Intrinsic has (l_dw, l_dn & l_dv), get rid of the following 
!   4 lines of code
!
    integer, parameter :: l_dw = 1
    integer, parameter :: l_dn = 2
    integer, parameter :: l_dv = 3
d165 1
a165 1
! Local variables:
d167 3
a169 2
    integer :: i,j,k,l,m,n,r,s,kz,kp,kf,n_f_phi,n_f_zet,n_f_frq,no_mol,l_x, &
            &  ii, kk, wf1, wf2
d171 3
a173 2
    type (VectorValue_T), pointer :: F             ! An arbitrary species
    type (VectorValue_T), pointer :: PHITAN ! Tangent geodAngle component of
d175 4
a178 2
!
    !******************* LOAD SPECIES DATA ************
d180 73
a252 1
    no_mol = size( mol_cat_index )
d254 22
a275 123
    call allocate_test ( Grids_x%no_z,no_mol,'Grids_x%no_z',ModuleName )
    call allocate_test ( Grids_x%no_p,no_mol,'Grids_x%no_p',ModuleName )
    call allocate_test ( Grids_x%no_f,no_mol,'Grids_x%no_f',ModuleName )
    call allocate_test ( Grids_x%windowstart,no_mol,'Grids_x%windowstart', &
                       & ModuleName )
    call allocate_test ( Grids_x%windowfinish,no_mol,'Grids_x%windowfinish',&
                       & ModuleName )
    call Allocate_test ( Grids_x%lin_log, no_mol, 'lin_log', ModuleName )
    call Allocate_test ( Grids_x%min_val, no_mol, 'min_val', ModuleName )

    Grids_x%no_z = 0
    Grids_x%no_p = 0
    Grids_x%no_f = 0
    grids_x%min_val = -huge(0.0_r8)

    f_len = 0

    if( present(p_len) ) p_len=0
    if( present(ext_ind) ) ext_ind = 0
    if( present(h2o_ind) ) h2o_ind = 0

    phitan => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, config=fwdModelConf, &
      & instrumentModule=FwdModelConf%signals(1)%instrumentModule )

    l_x = l_vmr
    if(Grid_type == 'W' .or. Grid_type == 'w') l_x = l_dw
    if(Grid_type == 'N' .or. Grid_type == 'n') l_x = l_dn
    if(Grid_type == 'V' .or. Grid_type == 'v') l_x = l_dv

    do ii = 1, no_mol
      kk = FwdModelConf%molecules(mol_cat_index(ii))
      if(present(h2o_ind) .and. spec_tags(kk) == 18003) h2o_ind = ii
      f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_x, molIndex=mol_cat_index(ii), &
        & radiometer=radiometer, config=fwdModelConf )
      kz = f%template%noSurfs
      if ( f%template%frequencyCoordinate == l_none ) then
        kf = 1
      else
        kf = f%template%noChans
      endif
      call FindInstanceWindow(f,phitan,fmStat%maf,FwdModelConf%phiWindow, &
                            & wf1, wf2)
      Grids_x%windowStart(ii) = wf1
      Grids_x%windowFinish(ii) = wf2
      kp = wf2 - wf1 + 1
      Grids_x%no_f(ii) = kf
      Grids_x%no_z(ii) = kz
      Grids_x%no_p(ii) = kp
      if( present(p_len) ) p_len = p_len + kz * kp
      f_len = f_len + kz * kp * kf
      if (f%template%logBasis) then
        Grids_x%lin_log(ii) = .true.
        Grids_x%min_val(ii) = f%template%minValue
      else
        Grids_x%lin_log(ii) = .false.
      endif
   end do
!
    n_f_zet = sum(Grids_x%no_z)
    n_f_phi = sum(Grids_x%no_p)
    n_f_frq = sum(Grids_x%no_f)
!
! Allocate space for the zeta, phi & freq. basis componenets
!
    call allocate_test ( Grids_x%zet_basis,n_f_zet,'Grids_x%zet_basis', &
                       & ModuleName)
    call allocate_test ( Grids_x%phi_basis,n_f_phi,'Grids_x%phi_basis', &
                       & ModuleName)
    call allocate_test ( Grids_x%frq_basis,n_f_frq,'Grids_x%frq_basis', &
                       & ModuleName)
    call allocate_test ( Grids_x%values,f_len,'Grids_x%values', &
                       & ModuleName)
    call allocate_test ( Grids_x%deriv_flags,f_len,'Grids_x%deriv_flags',&
                       & ModuleName)
!
    j = 1
    l = 1
    s = 1
    f_len = 1
    do ii = 1, no_mol
      i = mol_cat_index(ii)
      f => GetQuantityforForwardModel ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_x, molIndex=i, radiometer=radiometer, config=fwdModelConf )
      kz = Grids_x%no_z(ii)
      kp = Grids_x%no_p(ii)
      kf = Grids_x%no_f(ii)
      n = l + kz
      m = s + kf
      k = j + kp
      wf1 = Grids_x%windowStart(ii)
      wf2 = Grids_x%windowFinish(ii)
      Grids_x%zet_basis(l:n-1) = f%template%surfs(1:kz,1)
      Grids_x%phi_basis(j:k-1) = f%template%phi(1,wf1:wf2)*Deg2Rad
      if ( associated ( f%template%frequencies ) ) then
        if ( f%template%frequencyCoordinate /= l_intermediateFrequency ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & 'Unexpected frequency coordinate for quantity' )
        Grids_x%frq_basis(s:m-1) = f%template%frequencies
      else
        Grids_x%frq_basis(s:m-1) = 0.0
      endif
!
! ** ZEBUG - Simulate f%values for EXTINCTION, using the N2 function
!  (Some code here ...)
! ** END ZEBUG
!
      r = f_len + kf * kz * kp
      Grids_x%values(f_len:r-1) = reshape(f%values(1:kf*kz,wf1:wf2), &
                                      & (/kf*kz*kp/))
      if (Grids_x%lin_log(ii)) then
        where (Grids_x%values(f_len:r-1) <= grids_x%min_val(ii)) &
             & Grids_x%values(f_len:r-1) = grids_x%min_val(ii)
        Grids_x%values(f_len:r-1) = log(Grids_x%values(f_len:r-1))
      endif
!
! set 'do derivative' flags
!
      if ( fwdModelConf%moleculeDerivatives(i) ) then
        if (associated(f%mask)) then
          Grids_x%deriv_flags(f_len:r-1) = reshape(( iand (M_FullDerivatives,&
            & ichar(f%mask)) == 0),(/kf*kz*kp/))
d277 15
a291 17
          Grids_x%deriv_flags(f_len:r-1) = .true.
        endif
      else
        grids_x%deriv_flags(f_len:r-1) = .false.
      end if
!
      j = k
      l = n
      s = m
      f_len = r
!
    end do
!
    f_len = f_len - 1
!
 end subroutine load_one_grid
!
d293 17
a309 16
 subroutine DestroyGrids_t( grids_x )
!
  type(Grids_T), intent(inout) :: Grids_x
!
  call deallocate_test(grids_x%no_f,'grids_x%no_f',modulename)
  call deallocate_test(grids_x%no_z,'grids_x%no_z',modulename)
  call deallocate_test(grids_x%no_p,'grids_x%no_p',modulename)
  call deallocate_test(grids_x%values,'grids_x%values',modulename)
  call deallocate_test(grids_x%lin_log,'grids_x%lin_log',modulename)
  call deallocate_test(grids_x%min_val,'grids_x%min_val',modulename)
  call deallocate_test(grids_x%frq_basis,'grids_x%frq_basis',modulename)
  call deallocate_test(grids_x%zet_basis,'grids_x%zet_basis',modulename)
  call deallocate_test(grids_x%phi_basis,'grids_x%phi_basis',modulename)
  call deallocate_test(grids_x%deriv_flags,'grids_x%deriv_flags',modulename)
  call deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
  call deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
d311 1
a311 1
 end subroutine Destroygrids_t
d315 3
@


2.25
log
@Added min_val stuff
@
text
@d9 1
d11 1
a11 2
  use VectorsModule, only: Vector_T, VectorValue_T, GetVectorQuantityByType, &
                        &  M_FullDerivatives
d46 1
a46 1
   "$Id: load_sps_data_m.f90,v 2.24 2002/09/05 20:48:59 livesey Exp $"
d169 2
a170 2
    phitan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_phitan, &
d181 3
a183 8
      if ( kk == l_extinction ) then
        if( present(ext_ind) ) ext_ind = ii
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_extinction, radiometer=radiometer)
      else
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_x, molecule=kk)
      endif
d231 2
a232 8
      kk = FwdModelConf%molecules(i)
      if ( kk == l_extinction ) then
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_extinction, radiometer=radiometer )
      else
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_x, molecule=kk )
      endif
d311 3
@


2.24
log
@Added moleculeDerivatives info into deriv_flags
@
text
@d33 1
d46 1
a46 1
   "$Id: load_sps_data_m.f90,v 2.23 2002/08/22 23:13:45 livesey Exp $"
d156 1
d161 1
d207 1
d271 2
a272 2
        where (Grids_x%values(f_len:r-1) <= 1.0e-16_rp) &
             & Grids_x%values(f_len:r-1) = 1.0e-16_rp
d310 1
d322 3
@


2.23
log
@New frequency basis on IF
@
text
@d17 1
a17 1
  USE manipulatevectorquantities, only: FindInstanceWindow
d21 2
a22 2
  Private
  PUBLIC :: load_sps_data, Destroygrids_t
d28 1
a28 1
    INTEGER,  pointer :: windowstart(:) => null()! horizontal starting index
d30 1
a30 1
    INTEGER,  pointer :: windowfinish(:) => null()! horizontal ending index
d32 1
a32 1
    LOGICAL,  pointer :: lin_log(:) => null()   ! type of representation basis
d39 2
a40 2
    REAL(rp), pointer :: values(:) => null() ! species values (ie vmr) in lvf
    LOGICAL,  pointer :: deriv_flags(:) => null() ! do derivatives flags in lvf
d45 1
a45 1
   "$Id: load_sps_data_m.f90,v 2.22 2002/08/20 22:37:34 livesey Exp $"
d49 1
a49 1
CONTAINS
d52 1
a52 1
 SUBROUTINE load_sps_data(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
d57 3
a59 10
    Type(forwardModelConfig_T), intent(in) :: fwdModelConf
    Type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    Type(forwardModelStatus_t), intent(in) :: FmStat ! Reverse comm. stuff

    Integer, intent(in)  :: RADIOMETER
    Integer, intent(in)  :: MOL_CAT_INDEX(:)

    Integer, intent(out) :: P_LEN, F_LEN
    Integer, intent(out) :: H2O_IND
    Integer, intent(out) :: EXT_IND
d61 8
a68 1
    Integer, optional, intent(out) :: F_LEN_DW, F_LEN_DN, F_LEN_DV
d71 1
a71 1
    Type (Grids_T), intent(out) :: Grids_f
d74 1
a74 1
    Type (Grids_T), optional, intent(out) :: Grids_dw
d77 1
a77 1
    Type (Grids_T), optional, intent(out) :: Grids_dn
d80 1
a80 1
    Type (Grids_T), optional, intent(out) :: Grids_dv
d84 1
a84 1
    Call load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
d103 1
a103 1
 END SUBROUTINE load_sps_data
d106 1
a106 1
 SUBROUTINE load_one_grid(FwdModelConf, fwdModelIn, fwdModelExtra, FmStat, &
d125 1
a125 1
    Character(LEN=1), intent(in) :: Grid_type
d130 3
a132 3
    Integer, parameter :: l_dw = 1
    Integer, parameter :: l_dn = 2
    Integer, parameter :: l_dv = 3
d136 1
a136 1
    Integer :: i,j,k,l,m,n,r,s,kz,kp,kf,n_f_phi,n_f_zet,n_f_frq,no_mol,l_x, &
d147 4
a150 4
    Call allocate_test ( Grids_x%no_z,no_mol,'Grids_x%no_z',ModuleName )
    Call allocate_test ( Grids_x%no_p,no_mol,'Grids_x%no_p',ModuleName )
    Call allocate_test ( Grids_x%no_f,no_mol,'Grids_x%no_f',ModuleName )
    Call allocate_test ( Grids_x%windowstart,no_mol,'Grids_x%windowstart', &
d152 1
a152 1
    Call allocate_test ( Grids_x%windowfinish,no_mol,'Grids_x%windowfinish',&
d154 1
a154 1
    Call Allocate_test ( Grids_x%lin_log, no_mol, 'lin_log', ModuleName )
d162 3
a164 3
    if( PRESENT(p_len) ) p_len=0
    if( PRESENT(ext_ind) ) ext_ind = 0
    if( PRESENT(h2o_ind) ) h2o_ind = 0
d171 3
a173 3
    if(Grid_type == 'W' .OR. Grid_type == 'w') l_x = l_dw
    if(Grid_type == 'N' .OR. Grid_type == 'n') l_x = l_dn
    if(Grid_type == 'V' .OR. Grid_type == 'v') l_x = l_dv
d177 1
a177 1
      if(PRESENT(h2o_ind) .AND. spec_tags(kk) == 18003) h2o_ind = ii
d179 1
a179 1
        if( PRESENT(ext_ind) ) ext_ind = ii
d192 1
a192 1
      Call FindInstanceWindow(f,phitan,fmStat%maf,FwdModelConf%phiWindow, &
d200 1
a200 1
      if( PRESENT(p_len) ) p_len = p_len + kz * kp
d203 1
a203 1
        Grids_x%lin_log(ii) = .TRUE.
d205 1
a205 1
        Grids_x%lin_log(ii) = .FALSE.
d209 3
a211 3
    n_f_zet = SUM(Grids_x%no_z)
    n_f_phi = SUM(Grids_x%no_p)
    n_f_frq = SUM(Grids_x%no_f)
d215 1
a215 1
    Call allocate_test ( Grids_x%zet_basis,n_f_zet,'Grids_x%zet_basis', &
d217 1
a217 1
    Call allocate_test ( Grids_x%phi_basis,n_f_phi,'Grids_x%phi_basis', &
d219 1
a219 1
    Call allocate_test ( Grids_x%frq_basis,n_f_frq,'Grids_x%frq_basis', &
d221 1
a221 1
    Call allocate_test ( Grids_x%values,f_len,'Grids_x%values', &
d223 1
a223 1
    Call allocate_test ( Grids_x%deriv_flags,f_len,'Grids_x%deriv_flags',&
d264 1
a264 1
      Grids_x%values(f_len:r-1) = RESHAPE(f%values(1:kf*kz,wf1:wf2), &
d267 1
a267 1
        WHERE (Grids_x%values(f_len:r-1) <= 1.0e-16_rp) &
d269 1
a269 1
        Grids_x%values(f_len:r-1) = LOG(Grids_x%values(f_len:r-1))
d274 10
a283 6
      IF (ASSOCIATED(f%mask)) THEN
        Grids_x%deriv_flags(f_len:r-1) = RESHAPE(( iand (M_FullDerivatives,&
                          & ICHAR(f%mask)) == 0),(/kf*kz*kp/))
      ELSE
        Grids_x%deriv_flags(f_len:r-1) = .TRUE.
      ENDIF
d294 1
a294 1
 END subroutine load_one_grid
d297 1
a297 1
 Subroutine DestroyGrids_t( grids_x )
d299 1
a299 1
  TYPE(Grids_T), intent(inout) :: Grids_x
d301 11
a311 11
  Call deallocate_test(grids_x%no_f,'grids_x%no_f',modulename)
  Call deallocate_test(grids_x%no_z,'grids_x%no_z',modulename)
  Call deallocate_test(grids_x%no_p,'grids_x%no_p',modulename)
  Call deallocate_test(grids_x%values,'grids_x%values',modulename)
  Call deallocate_test(grids_x%lin_log,'grids_x%lin_log',modulename)
  Call deallocate_test(grids_x%frq_basis,'grids_x%frq_basis',modulename)
  Call deallocate_test(grids_x%zet_basis,'grids_x%zet_basis',modulename)
  Call deallocate_test(grids_x%phi_basis,'grids_x%phi_basis',modulename)
  Call deallocate_test(grids_x%deriv_flags,'grids_x%deriv_flags',modulename)
  Call deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
  Call deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
d313 1
a313 1
 End subroutine Destroygrids_t
d317 3
@


2.22
log
@Minor change in handling of frequency coordinate
@
text
@d9 1
a9 2
  USE INTRINSIC, ONLY: L_VMR, L_FREQUENCY, L_NONE, L_PHITAN
! USE INTRINSIC, ONLY: L_VMR, L_FREQUENCY, L_NONE, L_PHITAN, L_DW, L_DN, L_DV
d45 1
a45 1
   "$Id: load_sps_data_m.f90,v 2.21 2002/07/08 17:45:41 zvi Exp $"
d251 3
d313 3
@


2.21
log
@Updated spectroscopy handling
@
text
@d46 1
a46 1
   "$Id: load_sps_data_m.f90,v 2.20 2002/07/05 07:52:49 zvi Exp $"
d251 1
a251 1
      IF (Grids_x%no_f(ii) > 1) THEN
d253 1
a253 1
      ELSE
d255 1
a255 1
      ENDIF
d311 3
@


2.20
log
@Some cosmetic changes
@
text
@d10 1
d46 1
a46 1
   "$Id: load_sps_data_m.f90,v 2.19 2002/06/19 11:00:34 zvi Exp $"
d50 1
a50 1
contains
d54 56
a109 2
       &    radiometer, mol_cat_index, p_len, f_len, h2o_ind, ext_ind, &
       &    Grids_f, Grids_dw, Grids_dn, Grids_dv, temp, MyCatalog)
a118 25
    integer, intent(out) :: P_LEN
    integer, intent(out) :: H2O_IND
    integer, intent(out) :: EXT_IND

    type (Grids_T), intent(out) :: Grids_f   ! All the coordinates
    type (Grids_T), intent(out) :: Grids_dw  ! All the spectroscopy(W)
!                                              coordinates
    type (Grids_T), intent(out) :: Grids_dn  ! All the spectroscopy(N)
!                                              coordinates
    type (Grids_T), intent(out) :: Grids_dv  ! All the spectroscopy(V)
!                                              coordinates

    TYPE (VectorValue_T), POINTER :: temp
    type (CATALOG_T), dimension(:), intent(in) :: MyCatalog

    character(LEN=3), parameter :: WNV='+++'

!   character(LEN=*), optional, intent(in) :: WNV
!   type(Spect_der_T), optional, intent(in) :: ZSpect_Der(:)

    ! Local variables:

    Character(len=1) :: CA
    integer :: i,j,k,l,m,n,r,s,kz,kp,kf,Spectag,j_dw,j_dn,l_dn,j_dv, &
           &   l_dw,l_dv,n_f_phi,n_f_zet,n_f_frq,no_mol,s_dw,s_dn,s_dv
d120 19
a138 2
    integer :: accum_z_dw,accum_p_dw,accum_z_dn,accum_p_dn,accum_z_dv, &
           &   accum_p_dv,accum_f_dw,accum_f_dn,accum_f_dv
a142 1
    Integer :: ii, kk, wf1, wf2
d148 12
a159 12
    Call allocate_test ( Grids_f%no_z,no_mol,'Grids_f%no_z',modulename )
    Call allocate_test ( Grids_f%no_p,no_mol,'Grids_f%no_p',modulename )
    Call allocate_test ( Grids_f%no_f,no_mol,'Grids_f%no_f',modulename )
    Call allocate_test ( Grids_f%windowstart,no_mol,'Grids_f%windowstart', &
                       & modulename )
    Call allocate_test ( Grids_f%windowfinish,no_mol,'Grids_f%windowfinish',&
                       & modulename )
    Call Allocate_test ( Grids_f%lin_log, no_mol, 'lin_log', ModuleName )

    Grids_f%no_z = 0
    Grids_f%no_p = 0
    Grids_f%no_f = 0
d161 5
a166 4
    f_len = 0
    p_len = 0
    h2o_ind = 0
    ext_ind = 0
d169 6
a174 1
      & instrumentModule=fwdModelConf%signals(1)%instrumentModule )
d177 2
a178 2
      kk = fwdmodelconf%molecules(mol_cat_index(ii))
      if(spec_tags(kk) == 18003) h2o_ind = ii
d180 1
a180 1
        ext_ind = ii
d185 1
a185 1
          & quantityType=l_vmr, molecule=kk)
d193 1
a193 1
      Call FindInstanceWindow(f,phitan,fmStat%maf,fwdModelConf%phiWindow, &
d195 2
a196 2
      Grids_f%windowStart(ii) = wf1
      Grids_f%windowFinish(ii) = wf2
d198 4
a201 4
      Grids_f%no_f(ii) = kf
      Grids_f%no_z(ii) = kz
      Grids_f%no_p(ii) = kp
      p_len = p_len + kz * kp
d204 1
a204 1
        Grids_f%lin_log(ii) = .TRUE.
d206 1
a206 1
        Grids_f%lin_log(ii) = .FALSE.
a208 1

d210 3
a212 3
    n_f_zet = SUM(Grids_f%no_z)
    n_f_phi = SUM(Grids_f%no_p)
    n_f_frq = SUM(Grids_f%no_f)
d216 1
a216 1
    Call allocate_test ( Grids_f%zet_basis,n_f_zet,'Grids_f%zet_basis', &
d218 1
a218 1
    Call allocate_test ( Grids_f%phi_basis,n_f_phi,'Grids_f%phi_basis', &
d220 1
a220 1
    Call allocate_test ( Grids_f%frq_basis,n_f_frq,'Grids_f%frq_basis', &
d222 1
a222 1
    Call allocate_test ( Grids_f%values,f_len,'Grids_f%values', &
d224 1
a224 1
    Call allocate_test ( Grids_f%deriv_flags,f_len,'Grids_f%deriv_flags',&
d233 1
a233 1
      kk = fwdmodelconf%molecules(i)
d239 1
a239 1
          & quantityType=l_vmr, molecule=kk )
d241 3
a243 3
      kz = Grids_f%no_z(ii)
      kp = Grids_f%no_p(ii)
      kf = Grids_f%no_f(ii)
d247 6
a252 6
      wf1 = Grids_f%windowStart(ii)
      wf2 = Grids_f%windowFinish(ii)
      Grids_f%zet_basis(l:n-1) = f%template%surfs(1:kz,1)
      Grids_f%phi_basis(j:k-1) = f%template%phi(1,wf1:wf2)*Deg2Rad
      IF (Grids_f%no_f(ii) > 1) THEN
        Grids_f%frq_basis(s:m-1) = f%template%frequencies
d254 1
a254 1
        Grids_f%frq_basis(s:m-1) = 0.0
a255 11
!      if ( f%template%frequencyCoordinate /= l_none ) then
!        if ( f%template%frequencyCoordinate /= l_frequency ) &
!          & Call MLSMessage ( MLSMSG_Error, ModuleName, &
!          & "Inappropriate frequency coordinate for a species" )
!        if ( associated(f%template%frequencies ) ) then
!          Grids_f%frq_basis(s:m-1) = f%template%frequencies
!        else
!          Call MLSMessage ( MLSMSG_Error, ModuleName, &
!            & "Unable to deal with frequency coordinate for a species" )
!        endif
!      end if
d262 1
a262 1
      Grids_f%values(f_len:r-1) = RESHAPE(f%values(1:kf*kz,wf1:wf2), &
d264 4
a267 4
      if (Grids_f%lin_log(ii)) then
        WHERE (Grids_f%values(f_len:r-1) <= 1.0e-16_rp) &
             & Grids_f%values(f_len:r-1) = 1.0e-16_rp
        Grids_f%values(f_len:r-1) = LOG(Grids_f%values(f_len:r-1))
d273 1
a273 1
        Grids_f%deriv_flags(f_len:r-1) = RESHAPE(( iand (M_FullDerivatives,&
d276 1
a276 1
        Grids_f%deriv_flags(f_len:r-1) = .TRUE.
a286 59

!*** ZEBUG
!   Print *,' f_len =',f_len
!   Print *,' Grids_f%deriv_flags(1...f_len):'
!   Print 932,Grids_f%deriv_flags(1:f_len)
!932 format(37(1x,l1))
!   if (f_len > 0) Call MLSMessage(MLSMSG_Error,ModuleName,'DEBUG STOP' )
!*** END ZEBUG
!
    !******************* LOAD SPECTRAL SPECIES DATA ****************
!
    !*** if (.not. associated(ZSpect_der) ) return
    if(j > -10000) RETURN       ! *** ZEBUG, bypass Spectroscopy
!
    if(index(WNV,'W') > 0) then
      allocate ( Grids_dw%no_z(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%no_z' )
      allocate ( Grids_dw%no_p(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%no_p' )
      allocate ( Grids_dw%no_f(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%no_f' )
    endif
!
    if(index(WNV,'N') > 0) then
      allocate ( Grids_dn%no_z(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%no_z' )
      allocate ( Grids_dn%no_p(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%no_p' )
      allocate ( Grids_dn%no_f(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%no_f' )
    endif
!
    if(index(WNV,'V') > 0) then
      allocate ( Grids_dv%no_z(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%no_z' )
      allocate ( Grids_dv%no_p(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%no_p' )
      allocate ( Grids_dv%no_f(no_mol), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%no_f' )
    endif
!
    accum_z_dw = 0
    accum_p_dw = 0
    accum_f_dw = 0
    accum_z_dn = 0
    accum_p_dn = 0
    accum_f_dn = 0
    accum_z_dv = 0
    accum_p_dv = 0
    accum_f_dv = 0
d288 1
a288 157
    do ii = 1, no_mol
      m = 0
      kk = fwdmodelconf%molecules(mol_cat_index(ii))
      Spectag = spec_tags(kk)
      do
        m = m + 1
        !  *** if(ZSpect_Der(m)%Spectag == Spectag) exit
        if(m > -100) exit    ! ** ZEBUG
        if(m == 3*no_mol) exit
      end do
      !  *** if(ZSpect_Der(m)%Spectag /= Spectag) cycle
      CA = '@@' ! *** ZSpect_Der(m)%type
      kz = 1   ! ZSpect_Der(m)%no_zeta_values
      kp = 1   ! ZSpect_Der(m)%no_phi_values
      kf = 1   ! ZSpect_Der(m)%no_frq_values
      select case ( CA )
        case ( 'W' )
          Grids_dw%no_z(ii) = kz
          Grids_dw%no_p(ii) = kp
          Grids_dw%no_f(ii) = kf
          accum_z_dw = accum_z_dw + kz
          accum_p_dw = accum_p_dw + kp
          accum_f_dw = accum_f_dw + kf
        case ( 'N' )
          Grids_dn%no_z(ii) = kz
          Grids_dn%no_p(ii) = kp
          Grids_dn%no_f(ii) = kf
          accum_z_dn = accum_z_dn + kz
          accum_p_dn = accum_p_dn + kp
          accum_f_dn = accum_f_dn + kf
        case ( 'V' )
          Grids_dv%no_z(ii) = kz
          Grids_dv%no_p(ii) = kp
          Grids_dv%no_f(ii) = kf
          accum_z_dv = accum_z_dv + kz
          accum_p_dv = accum_p_dv + kp
          accum_f_dv = accum_f_dv + kf
      end select
    end do
!
    if(index(WNV,'W') > 0) then
      allocate ( Grids_dw%zet_basis(accum_z_dw), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%zet_basis' )
      allocate ( Grids_dw%phi_basis(accum_p_dw), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%phi_basis' )
      allocate ( Grids_dw%frq_basis(accum_f_dw), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dw%frq_basis' )
    endif
!
    if(index(WNV,'N') > 0) then
      allocate ( Grids_dn%zet_basis(accum_z_dn), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%zet_basis' )
      allocate ( Grids_dn%phi_basis(accum_p_dn), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%phi_basis' )
      allocate ( Grids_dn%frq_basis(accum_f_dn), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dn%frq_basis' )
    endif
!
    if(index(WNV,'V') > 0) then
      allocate ( Grids_dv%zet_basis(accum_z_dv), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%zet_basis' )
      allocate ( Grids_dv%phi_basis(accum_p_dv), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%phi_basis' )
      allocate ( Grids_dv%frq_basis(accum_f_dv), stat=j )
      if ( j /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'Grids_dv%frq_basis' )
    endif
!
    j_dw = 1
    l_dw = 1
    s_dw = 1
    j_dn = 1
    l_dn = 1
    s_dn = 1
    j_dv = 1
    l_dv = 1
    s_dv = 1
!
    do ii = 1, no_mol
      m = 0
      kk = fwdmodelconf%molecules(mol_cat_index(ii))
      Spectag = spec_tags(kk)
      do
        m = m + 1
        !  *** if(ZSpect_Der(m)%Spectag == Spectag) exit
        if(m > -100) exit    ! ** ZEBUG
        if(m == 3*no_mol) exit
      end do
      !  *** if(ZSpect_Der(m)%Spectag /= Spectag) cycle
      CA = '@@' ! *** ZSpect_Der(m)%type
      select case ( CA )
        case ( 'W' )
          kz = Grids_dw%no_z(ii)
          kp = Grids_dw%no_p(ii)
          kf = Grids_dw%no_f(ii)
          if(kp*kz*kf > 0) then
            k = j_dw + kp
            n = l_dw + kz
            j = s_dw + kf
      !     Grids_dw%zet_basis(l_dw:n-1) = &
      !                         &  ZSpect_Der(m)%zeta_basis(1:kz)
      !     Grids_dw%phi_basis(j_dw:k-1) = &
      !                         &  ZSpect_Der(m)%phi_basis(1:kp)
      !     Grids_dw%frq_basis(s_dw:j-1) = &
      !                         &  ZSpect_Der(m)%frq_basis(1:kf)
            j_dw = k
            l_dw = n
            s_dw = j
          endif
        case ( 'N' )
          kz = Grids_dn%no_z(ii)
          kp = Grids_dn%no_p(ii)
          kf = Grids_dn%no_f(ii)
          if(kp*kz*kf > 0) then
            k = j_dn + kp
            n = l_dn + kz
            j = s_dn + kf
      !     Grids_dn%zet_basis(l_dn:n-1) = &
      !                         &  ZSpect_Der(m)%zeta_basis(1:kz)
      !     Grids_dn%phi_basis(j_dn:k-1) = &
      !                         &  ZSpect_Der(m)%phi_basis(1:kp)
      !     Grids_dn%frq_basis(s_dn:j-1) = &
      !                         &  ZSpect_Der(m)%frq_basis(1:kf)
            j_dn = k
            l_dn = n
            s_dn = j
          endif
        case ( 'V' )
          kz = Grids_dv%no_z(ii)
          kp = Grids_dv%no_p(ii)
          kf = Grids_dv%no_f(ii)
          if(kp*kz*kf > 0) then
            k = j_dv + kp
            n = l_dv + kz
            j = s_dv + kf
      !     Grids_dv%zet_basis(l_dv:n-1) = &
      !                         &  ZSpect_Der(m)%zeta_basis(1:kz)
      !     Grids_dv%phi_basis(j_dv:k-1) = &
      !                         &  ZSpect_Der(m)%phi_basis(1:kp)
      !     Grids_dv%frq_basis(s_dv:j-1) = &
      !                         &  ZSpect_Der(m)%frq_basis(1:kf)
            j_dv = k
            l_dv = n
            s_dn = j
          endif
      end select
    end do
!
 end subroutine load_sps_data
d290 1
d311 3
@


2.19
log
@Removing unused variables, some cosmetic changes
@
text
@d45 1
a45 1
   "$Id: load_sps_data_m.f90,v 2.17 2002/06/13 22:39:12 bill Exp $"
d69 1
a69 1
    type (Grids_T), intent(out) :: Grids_dw  ! All the spectroscopy(W) 
d71 1
a71 1
    type (Grids_T), intent(out) :: Grids_dn  ! All the spectroscopy(N) 
d73 1
a73 1
    type (Grids_T), intent(out) :: Grids_dv  ! All the spectroscopy(V) 
d82 1
a82 1
!   type(Spect_der_T), optional, intent(in) :: Spect_Der(:)
d102 4
a105 4
    CALL allocate_test ( Grids_f%no_z,no_mol,'Grids_f%no_z',modulename )
    CALL allocate_test ( Grids_f%no_p,no_mol,'Grids_f%no_p',modulename )
    CALL allocate_test ( Grids_f%no_f,no_mol,'Grids_f%no_f',modulename )
    CALL allocate_test ( Grids_f%windowstart,no_mol,'Grids_f%windowstart', &
d107 1
a107 1
    CALL allocate_test ( Grids_f%windowfinish,no_mol,'Grids_f%windowfinish',&
d109 1
a109 1
    call Allocate_test ( Grids_f%lin_log, no_mol, 'lin_log', ModuleName )
d141 1
a141 1
      CALL FindInstanceWindow(f,phitan,fmStat%maf,fwdModelConf%phiWindow, &
d165 1
a165 1
    CALL allocate_test ( Grids_f%zet_basis,n_f_zet,'Grids_f%zet_basis', &
d167 1
a167 1
    CALL allocate_test ( Grids_f%phi_basis,n_f_phi,'Grids_f%phi_basis', &
d169 1
a169 1
    CALL allocate_test ( Grids_f%frq_basis,n_f_frq,'Grids_f%frq_basis', &
d171 1
a171 1
    CALL allocate_test ( Grids_f%values,f_len,'Grids_f%values', &
d173 1
a173 1
    CALL allocate_test ( Grids_f%deriv_flags,f_len,'Grids_f%deriv_flags',&
d207 1
a207 1
!          & call MLSMessage ( MLSMSG_Error, ModuleName, &
d212 1
a212 1
!          call MLSMessage ( MLSMSG_Error, ModuleName, &
d230 1
a230 1
! set do derivative flags
d253 1
a253 1
!   if (f_len > 0) call MLSMessage(MLSMSG_Error,ModuleName,'DEBUG STOP' )
d258 1
a258 1
    !*** if (.not. associated(Spect_der) ) return
d263 1
a263 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d266 1
a266 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d269 1
a269 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d275 1
a275 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d278 1
a278 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d281 1
a281 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d287 1
a287 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d290 1
a290 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d293 1
a293 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d313 1
a313 1
        !  *** if(Spect_Der(m)%Spectag == Spectag) exit
d317 5
a321 5
      !  *** if(Spect_Der(m)%Spectag /= Spectag) cycle
      CA = '@@' ! *** Spect_Der(m)%type
      kz = 1   ! Spect_Der(m)%no_zeta_values
      kp = 1   ! Spect_Der(m)%no_phi_values
      kf = 1   ! Spect_Der(m)%no_frq_values
d349 1
a349 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d352 1
a352 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d355 1
a355 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d361 1
a361 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d364 1
a364 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d367 1
a367 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d373 1
a373 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d376 1
a376 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d379 1
a379 1
      if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d399 1
a399 1
        !  *** if(Spect_Der(m)%Spectag == Spectag) exit
d403 2
a404 2
      !  *** if(Spect_Der(m)%Spectag /= Spectag) cycle
      CA = '@@' ! *** Spect_Der(m)%type
d415 1
a415 1
      !                         &  Spect_Der(m)%zeta_basis(1:kz)
d417 1
a417 1
      !                         &  Spect_Der(m)%phi_basis(1:kp)
d419 1
a419 1
      !                         &  Spect_Der(m)%frq_basis(1:kf)
d433 1
a433 1
      !                         &  Spect_Der(m)%zeta_basis(1:kz)
d435 1
a435 1
      !                         &  Spect_Der(m)%phi_basis(1:kp)
d437 1
a437 1
      !                         &  Spect_Der(m)%frq_basis(1:kf)
d451 1
a451 1
      !                         &  Spect_Der(m)%zeta_basis(1:kz)
d453 1
a453 1
      !                         &  Spect_Der(m)%phi_basis(1:kp)
d455 1
a455 1
      !                         &  Spect_Der(m)%frq_basis(1:kf)
d469 11
a479 11
  CALL deallocate_test(grids_x%no_f,'grids_x%no_f',modulename)
  CALL deallocate_test(grids_x%no_z,'grids_x%no_z',modulename)
  CALL deallocate_test(grids_x%no_p,'grids_x%no_p',modulename)
  CALL deallocate_test(grids_x%values,'grids_x%values',modulename)
  CALL deallocate_test(grids_x%lin_log,'grids_x%lin_log',modulename)
  CALL deallocate_test(grids_x%frq_basis,'grids_x%frq_basis',modulename)
  CALL deallocate_test(grids_x%zet_basis,'grids_x%zet_basis',modulename)
  CALL deallocate_test(grids_x%phi_basis,'grids_x%phi_basis',modulename)
  CALL deallocate_test(grids_x%deriv_flags,'grids_x%deriv_flags',modulename)
  CALL deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
  CALL deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
d485 3
@


2.18
log
@fixing bugs--wgr
@
text
@d17 1
a17 1
  USE manipulatevectorquantities, only: findinstancewindow
d22 1
a22 1
  PUBLIC :: load_sps_data, destroygrids_t
d87 1
a87 1
    integer :: i,j,k,l,m,n,r,s,kz,kp,kf,mf,Spectag,j_dw,j_dn,l_dn,j_dv, &
a91 1
    integer :: MAF                      ! MAF under consideration
a94 1
    Logical :: mask
d96 1
a96 2
    Integer :: mp, mz, ii, jj, kk
    Real(r8) :: Tmp, Frq, P, w, v
d106 1
a106 1
    & modulename )
d108 2
a109 2
    & modulename )
    call Allocate_test ( grids_f%lin_log, no_mol, 'lin_log', ModuleName )
d141 5
a145 3
      CALL findinstancewindow(f,phitan,fmStat%maf,fwdModelConf%phiWindow, &
      & grids_f%windowStart(ii), grids_f%windowFinish(ii))
      kp = grids_f%windowFinish(ii) - grids_f%windowStart(ii) + 1
d152 1
a152 1
        grids_f%lin_log(ii) = .TRUE.
d154 1
a154 1
        grids_f%lin_log(ii) = .FALSE.
d166 1
a166 1
    & ModuleName)
d168 1
a168 1
    & ModuleName)
d170 1
a170 1
    & ModuleName)
d172 3
a174 3
    & ModuleName)
    CALL allocate_test ( Grids_f%deriv_flags,f_len,'Grids_f%deriv_flags', &
    & ModuleName)
d190 3
a192 3
      kz = grids_f%no_z(ii)
      kp = grids_f%no_p(ii)
      kf = grids_f%no_f(ii)
d196 6
a201 5
      Grids_f%zet_basis(l:n-1) = f%template%surfs(:,1)
      Grids_f%phi_basis(j:k-1) = f%template%phi(1, &
      & grids_f%windowstart(ii):grids_f%windowfinish(ii)) * Deg2Rad
      IF (grids_f%no_f(ii) > 1) THEN
        grids_f%frq_basis(s:m-1) = f%template%frequencies
d218 1
a218 2
!
!
d222 6
a227 6
      grids_f%values(f_len:r-1)=RESHAPE(f%values(1:kf*kz, &
      & grids_f%windowstart(ii):grids_f%windowfinish(ii)),(/kf*kz*kp/))
      if (grids_f%lin_log(ii)) then
        WHERE (grids_f%values(f_len:r-1) <= 1.0e-16_rp) &
        & grids_f%values(f_len:r-1) = 1.0e-16_rp
        grids_f%values(f_len:r-1) = LOG(grids_f%values(f_len:r-1))
d229 1
d231 1
d233 2
a234 2
        grids_f%deriv_flags(f_len:r-1) = RESHAPE((iand(M_FullDerivatives, &
        & ICHAR(f%mask)) == 0),(/kf*kz*kp/))
d236 1
a236 1
        grids_f%deriv_flags(f_len:r-1) = .true.
a247 1

d249 3
a251 3
!   Print *,' f_len, m = ',f_len,m
!   Print *,' Grids_f%deriv_flags(1...m):'
!   Print 932,Grids_f%deriv_flags(1:m)
d253 1
a253 1
!   if (m > 0) call MLSMessage (MLSMSG_Error,ModuleName,'DEBUG Stop' )
a254 1

d259 1
a259 1
    if(j > -10000) return
d464 3
a466 1
  subroutine DestroyGrids_t( grids_x )
d468 1
d472 1
a472 2
  CALL deallocate_test(grids_x%windowstart,'grids_x%windowstart',modulename)
  CALL deallocate_test(grids_x%windowfinish,'grids_x%windowfinish',modulename)
a476 1
  CALL deallocate_test(grids_x%values,'grids_x%values',modulename)
d478 5
a482 1
  end subroutine destroygrids_t
@


2.17
log
@fixed phi window selection--wgr
@
text
@d45 1
a45 1
   "$Id: load_sps_data_m.f90,v 2.16 2002/06/04 10:28:03 zvi Exp $"
d198 2
a199 1
      Grids_f%phi_basis(j:k-1) = f%template%phi(1,:) * Deg2Rad
d481 3
@


2.16
log
@Adding comments, fixing a bug with species ruuning index
@
text
@d7 3
a9 1
  use Intrinsic, only: L_VMR, L_FREQUENCY, L_NONE
d17 1
a17 1
  use ABS_CS_N2_CONT_M, only: ABS_CS_N2_CONT
d22 1
a22 1
  Public :: load_sps_data
d25 16
a40 7
    integer,  pointer :: no_f(:)      ! No. of entries in frq. grid per sps
    integer,  pointer :: no_z(:)      ! No. of entries in zeta grid per sps
    integer,  pointer :: no_p(:)      ! No. of entries in phi  grid per sps
    real(r8), pointer :: frq_basis(:) ! frq  grid entries for all
    real(rp), pointer :: zet_basis(:) ! zeta grid entries for all
    real(rp), pointer :: phi_basis(:) ! phi  grid entries for all
    Logical,  pointer :: deriv_flags(:) ! derivatives flags
d45 1
a45 1
   "$Id: load_sps_data_m.f90,v 2.15 2002/02/20 22:19:46 zvi Exp $"
d52 3
a54 4
 subroutine load_sps_data(fwdModelIn, fwdModelExtra, molecules, radiometer, &
       &    mol_cat_index, p_len, f_len, h2o_ind, ext_ind, lin_log, &
       &    sps_values, Grids_f, Grids_dw, Grids_dn, Grids_dv, temp, &
       &    MyCatalog,skip_eta_frq)
d56 1
d58 1
a59 1
    integer, intent(in)  :: MOLECULES(:)
d68 7
a74 1
    logical, intent(out) :: SKIP_ETA_FRQ(:)
d76 1
a76 10
    type (Grids_T) :: Grids_f   ! All the coordinates
    type (Grids_T) :: Grids_dw  ! All the spectroscopy(W) coordinates
    type (Grids_T) :: Grids_dn  ! All the spectroscopy(N) coordinates
    type (Grids_T) :: Grids_dv  ! All the spectroscopy(V) coordinates

    logical, pointer :: lin_log(:)

    real(rp), pointer :: sps_values(:)

    type (VectorValue_T), pointer :: temp
d92 1
d95 1
a95 1

a96 1
    Logical, allocatable :: deriv_flag(:)
d105 8
a112 9
    allocate ( Grids_f%no_z(no_mol), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%no_z' )
    allocate ( Grids_f%no_p(no_mol), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%no_p' )
    allocate ( Grids_f%no_f(no_mol), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%no_f' )
a117 1
    call Allocate_test ( lin_log, no_mol, 'lin_log', ModuleName )
d123 3
a125 1
    skip_eta_frq = .FALSE.
d128 1
a128 1
      kk = molecules(mol_cat_index(ii))
a138 1
      kp = f%template%noInstances
a140 1
        skip_eta_frq(ii) = .TRUE.
d144 3
d152 6
a157 3
    end do

    call Allocate_test ( sps_values, f_len, 'sps_values', ModuleName )
a158 3
    allocate ( Grids_f%deriv_flags(f_len), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%deriv_flags' )
d166 10
a175 9
    allocate ( Grids_f%zet_basis(n_f_zet), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%zet_basis' )
    allocate ( Grids_f%phi_basis(n_f_phi), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%phi_basis' )
    allocate ( Grids_f%frq_basis(n_f_frq), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'Grids_f%frq_basis' )
d183 1
a183 1
      kk = molecules(i)
d191 3
a193 7
      kz = f%template%noSurfs
      kp = f%template%noInstances
      if ( f%template%frequencyCoordinate == l_none ) then
        kf = 1
      else
        kf = f%template%noChans
      endif
d199 16
a214 12
      Grids_f%frq_basis(s:m-1) = 0.0
      if ( f%template%frequencyCoordinate /= l_none ) then
        if ( f%template%frequencyCoordinate /= l_frequency ) &
          & call MLSMessage ( MLSMSG_Error, ModuleName, &
          & "Inappropriate frequency coordinate for a species" )
        if ( associated(f%template%frequencies ) ) then
          Grids_f%frq_basis(s:m-1) = f%template%frequencies
        else
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & "Unable to deal with frequency coordinate for a species" )
        endif
      end if
a217 17
      if(ext_ind == ii) then
        do mp = 1, kp
          jj = 0
          do mz = 1, kz
            P = 10.0_rp**(-f%template%surfs(mz,1))
            Tmp = temp%values(mz,mp)
            do mf = 1, kf
              jj = jj + 1
              Frq = f%template%frequencies(mf)
              v = 0.8061 * abs_cs_n2_cont(MyCatalog(i)%continuum,Tmp,P,Frq)
              w = 1.0
!             w = 1.0+0.1*(2*mf-3)
              f%values(jj,mp) = w * v
            end do
          end do
        end do
      endif
d221 7
a227 7
      r = f_len + kz * kp * kf
      sps_values(f_len:r-1)=RESHAPE(f%values(1:kz*kf,1:kp),(/kz*kf*kp/))
      if (f%template%logBasis) then
        lin_log(ii) = .TRUE.
        sps_values(f_len:r-1) = LOG(max(1.0e-16_rp,sps_values(f_len:r-1)))
      else
        lin_log(ii) = .FALSE.
d229 7
a245 35
! *** Load the derivatives flags for each species according to L2CF
!
    allocate (deriv_flag(f_len), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
                                  & MLSMSG_Allocate//'deriv_flag array' )
    m = 0
    do ii = 1, no_mol
      kk = molecules(mol_cat_index(ii))
      if ( kk == l_extinction ) then
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_extinction, radiometer=radiometer )
      else
        f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_vmr, molecule=kk )
      endif
      kp = Grids_f%no_p(ii)
      kz = Grids_f%no_z(ii)
      kf = Grids_f%no_f(ii)
      j = kp * kz * kf
      deriv_flag(1:j) = .TRUE.     ! ** Initialize to ALL derivatives
      IF(associated(f%mask)) THEN
        j = 0
        do mp = 1, kp
          do mz = 1, kz
            mask = (iand(M_FullDerivatives,ichar(f%mask(mz,mp))) == 0)
            deriv_flag(j+1:j+kf) = mask
            j = j + kf
          end do
        end do
      ENDIF
      Grids_f%deriv_flags(m+1:m+j) = deriv_flag(1:j)
      m = m + j
    end do

    deallocate (deriv_flag, stat=j )
d251 1
a251 1
932 format(37(1x,l1))
d309 1
a309 1
      kk = molecules(mol_cat_index(ii))
d395 1
a395 1
      kk = molecules(mol_cat_index(ii))
d464 14
a477 1

d480 3
@


2.15
log
@Reversing the subset logic ..
@
text
@d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.14 2002/02/16 20:43:54 zvi Exp $"
d107 4
d118 1
d120 2
a121 2
      i = mol_cat_index(ii)
      kk = abs(molecules(i))
d123 1
d125 1
a125 2
          & quantityType=l_extinction, radiometer=radiometer )
        ext_ind = ii
d128 1
a128 1
          & quantityType=l_vmr, molecule=kk )
a142 1
      if(spec_tags(kk) == 18003) h2o_ind = ii
d173 1
a173 1
      kk = abs(molecules(i))
d253 1
a253 2
      i = mol_cat_index(ii)
      kk = abs(molecules(i))
d344 1
a344 2
      i = mol_cat_index(ii)
      kk = abs(molecules(i))
d430 1
a430 2
      i = mol_cat_index(ii)
      kk = abs(molecules(i))
d502 3
@


2.14
log
@Changing the code for Log of Neg. VMR
@
text
@d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.13 2002/02/16 10:32:17 zvi Exp $"
d262 1
a262 1
      deriv_flag(1:j) = .FALSE.     ! ** Initialize to NO derivatives
d267 1
a267 1
            mask = (iand(M_FullDerivatives,ichar(f%mask(mz,mp))) /= 0)
a271 3
! *** ZEBUG: Until Van changes the Subset logic, we will invert it here ***
        deriv_flag(1:j) = (.NOT. deriv_flag(1:j))
! *** END ZEBUG ***
d501 3
@


2.13
log
@Guaranties against taking Log(0.0)
@
text
@d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.12 2002/02/16 06:37:34 zvi Exp $"
d228 1
a228 3
        do jj = f_len, r-1
          if(sps_values(jj) > 0.0) sps_values(jj)=LOG(sps_values(jj))
        end do
d504 3
@


2.12
log
@New code for derivative flags..
@
text
@d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.11 2002/02/08 00:46:04 zvi Exp $"
d228 3
a230 1
        sps_values(f_len:r-1) = LOG(sps_values(f_len:r-1))
d506 3
@


2.11
log
@Fixing a bug in the t_deriv_flag code
@
text
@d8 2
a9 1
  use VectorsModule, only: Vector_T, VectorValue_T, GetVectorQuantityByType
d20 1
a20 2
! Public :: load_sps_data
  Public :: load_sps_data, load_deriv_flag    ! ** ZEBUG
d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.10 2002/01/30 01:11:20 zvi Exp $"
d87 1
a87 1
    Character(len=78) :: ErrMsg
d113 1
a113 1
    skip_eta_frq = .false.
d129 1
a129 1
        skip_eta_frq(ii) = .true.
a145 2

    Grids_f%deriv_flags(1:f_len) = .TRUE.   ! ** Initialize all values to TRUE
d227 1
a227 1
        lin_log(ii) = .true.
d230 1
a230 1
        lin_log(ii) = .false.
d242 1
a242 3
!   if(f_len > -100) return    ! ** By-pass the tempoprary code below ..
!
! *** ZEBUG: Temporary code to load the derivatives flags for each species
a246 1

d251 7
a257 2
      if ( kk == l_extinction ) CYCLE
      Spectag = spec_tags(kk)
d261 15
a275 2
      Call load_deriv_flag(Spectag,kp,kz,kf,deriv_flag,ErrMsg,j)
      if(j < 0) EXIT
d281 2
d288 2
a289 2
!
! *** End of Temporary code
a501 165
! *********************  ZEBUG  ******************
! A temporary routine to load data from ASCII file into the deriv_flag array
!
 Subroutine load_deriv_flag(Spectag,kp,kz,kf,deriv_flag,ErrMsg,ier)
!
  Integer, intent(in) :: Spectag, kp,kz,kf

  Logical, intent(out) :: deriv_flag(:)

  Integer, intent(out) :: ier
  Character(LEN=*), intent(out) :: ErrMsg
!
! ** Local variables
!
  Integer :: j,k,m
  Integer, allocatable :: dum_phi(:),dum_zet(:),dum_frq(:)
!
! ** Begin executable code
!
    ier = 0
    ErrMsg(1:) = ' '
    deriv_flag = .TRUE.     ! Initialized to .TRUE.

    Close(31,iostat=j)
    Open(31,file='der_flags.dat',status='OLD',action='READ',iostat=j)
    if ( j /= 0 ) then
      ier = -1
      ErrMsg = 'Could not open der_flags.dat file'
      Return
    endif

    Allocate(dum_phi(1:kp),STAT=j)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Could not allocate dum_phi array'
      goto 99
    endif

    Allocate(dum_zet(1:kz),STAT=j)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Could not allocate dum_zet array'
      goto 99
    endif

    Allocate(dum_frq(1:kf),STAT=j)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Could not allocate dum_frq array'
      goto 99
    endif
!
    do
      Read(31,*,iostat=j) m
      if(j == 0) then
        if(Spectag == m) EXIT
      else if(j < 0) then
        j = -1
        ErrMsg = 'Requeted Spectag not found in in der_flags.dat file'
        goto 99
      else
        j = -1
        ErrMsg = 'Error reading der_flags.dat file'
        goto 99
      endif
    end do

    read(31,*,iostat=j) k
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    if(k /= kp) then
      j = -1
      Print *,'** Spectag:',Spectag,' Inputs: phi deriv. flags ..'
      ErrMsg = 'Incosistent number of entries in der_flags.dat file'
      goto 99
    endif

    dum_phi = 0
    Backspace(31,iostat=m)
    read(31,*,iostat=j) k,dum_phi(1:k)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    read(31,*,iostat=j) k
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    if(k /= kz) then
      j = -1
      Print *,'** Spectag:',Spectag,' Inputs: phi deriv. flags ..'
      ErrMsg = 'Incosistent number of entries in der_flags.dat file'
      goto 99
    endif

    dum_zet = 0
    Backspace(31,iostat=m)
    read(31,*,iostat=j) k,dum_zet(1:k)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    read(31,*,iostat=j) k
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    if(k /= kf) then
      j = -1
      Print *,'** Spectag:',Spectag,' Inputs: phi deriv. flags ..'
      ErrMsg = 'Incosistent number of entries in der_flags.dat file'
      goto 99
    endif

    dum_frq = 0
    Backspace(31,iostat=m)
    read(31,*,iostat=j) k,dum_frq(1:k)
    if ( j /= 0 ) then
      j = -1
      ErrMsg = 'Error reading der_flags.dat file'
      goto 99
    endif

    m = 0
    do k = 1, kp
      if(dum_phi(k) < 1) then
        m = m + kz * kf
      else
        do j = 1, kz
          if(dum_zet(j) > 0) then
            deriv_flag(m+1:m+kf) =  (dum_frq(1:kf) > 0)
          endif
          m = m + kf
        end do
      endif
    end do
    j = m

!   Print *,'** Spectag:',Spectag
!   Print *,' m =',m,' deriv_flag(1...m):'
!   Print 934,deriv_flag(1:m)
934 format(37(1x,l1))
!   if (m > 0) call MLSMessage (MLSMSG_Error,ModuleName,'DEBUG Stop' )

 99 ier = j
    Close(31,iostat=j)
    deallocate ( dum_phi, dum_zet, dum_frq, stat=j )
!
 End Subroutine load_deriv_flag

! *********************  END ZEBUG  ******************

d504 3
@


2.10
log
@Fix bug in user selectable coeff. code
@
text
@d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.9 2002/01/27 08:37:49 zvi Exp $"
d147 1
a147 1
    Grids_f%deriv_flags = .true.   ! ** Initialize all values to TRUE
d262 1
a262 5
      if(j < 0) then
        Print *,ErrMsg(1:Len_Trim(ErrMsg))
        Print *,'** Setting all Grids_f%deriv_flags = .TRUE.'
        EXIT
      endif
d508 1
a508 1
    deriv_flag = .false.
d654 3
@


2.9
log
@Adding Users selected coefficients for derivatives
@
text
@d19 2
a20 1
  Public :: load_sps_data
d34 1
a34 1
   "$Id: load_sps_data_m.f90,v 2.8 2002/01/09 00:30:48 zvi Exp $"
d41 4
a44 4
  subroutine load_sps_data(fwdModelIn, fwdModelExtra, molecules, radiometer, &
        &    mol_cat_index, p_len, f_len, h2o_ind, ext_ind, lin_log, &
        &    sps_values, Grids_f, Grids_dw, Grids_dn, Grids_dv, temp, &
        &    MyCatalog,skip_eta_frq)
d87 2
a88 1
    Integer, allocatable :: dum_phi(:),dum_zet(:),dum_frq(:)
d244 1
a244 1
    if(f_len > -100) return    ! ** By-pass the tempoprary code below ..
d248 1
a248 17
    Close(31,iostat=j)
    Open(31,file='der_flags.dat',status='OLD',action='READ',iostat=j)
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'Could not open der_flags.dat file' )
!
    n = Maxval(Grids_f%no_p(:))
    allocate ( dum_phi(n), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'dum_phi' )

    n = Maxval(Grids_f%no_z(:))
    allocate ( dum_zet(n), stat=j )
    if ( j /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'dum_zet' )

    n = Maxval(Grids_f%no_f(:))
    allocate ( dum_frq(n), stat=j )
d250 1
a250 1
      & MLSMSG_Allocate//'dum_frq' )
a257 14
      Rewind(31,iostat=j)
      do
        Read(31,*,iostat=j) n
        if(j == 0) then
          if(Spectag == n) EXIT
        else if(j < 0) then
          Print *,'** Spectag:',Spectag
          Print *,'   Not found in in der_flags.dat file'
          Call MLSMessage ( MLSMSG_Error, ModuleName, ' ')
        else
          call MLSMessage ( MLSMSG_Error, ModuleName, &
         &                  'Error reading der_flags.dat file' )
        endif
      end do
d261 5
a265 20
      dum_phi = 0
      read(31,*,iostat=j) k,dum_phi(1:k)
      if(k /= kp) then
        Print *,'** Spectag:',Spectag,' Inputs: phi deriv. flags ..'
        Print *,'   Incosistent number of entries in der_flags.dat file'
        Call MLSMessage ( MLSMSG_Error, ModuleName, ' ')
      endif
      dum_zet = 0
      read(31,*,iostat=j) k,dum_zet(1:k)
      if(k /= kz) then
        Print *,'** Spectag:',Spectag,' Inputs: zet deriv. flags ..'
        Print *,'   Incosistent number of entries in der_flags.dat file'
        Call MLSMessage ( MLSMSG_Error, ModuleName, ' ')
      endif
      dum_frq = 0
      read(31,*,iostat=j) k,dum_frq(1:k)
      if(k /= kf) then
        Print *,'** Spectag:',Spectag,' Inputs: frq deriv. flags ..'
        Print *,'   Incosistent number of entries in der_flags.dat file'
        Call MLSMessage ( MLSMSG_Error, ModuleName, ' ')
d267 2
a268 12
      do i = 1, kp
        if(dum_phi(i) < 1) then
          m = m + kz * kf
        else
          do j = 1, kz
            if(dum_zet(j) > 0) then
              Grids_f%deriv_flags(m+1:m+kf) =  (dum_frq(1:kf) > 0)
            endif
            m = m + kf
          end do
        endif
      end do
d271 1
a271 2
    Close(31,iostat=j)
    deallocate ( dum_phi, dum_zet, dum_frq, stat=j )
d489 166
a654 1
  end subroutine load_sps_data
d658 3
@


2.8
log
@Fix a bug with skip_eta_frq
@
text
@d21 1
a21 4
  type, public :: Grids_T              ! Fit all Gridding categories
    integer :: tot_no_frq             ! Total No. of entries in frequency grid
    integer :: tot_no_zet             ! Total No. of entries in zeta grid
    integer :: tot_no_phi             ! Total No. of entries in phi  grid
d25 4
a28 3
    real(r8), pointer :: frq_basis(:) ! frq  grid entries (dim: tot_no_frq)
    real(rp), pointer :: zet_basis(:) ! zeta grid entries (dim: tot_no_zet)
    real(rp), pointer :: phi_basis(:) ! phi  grid entries (dim: tot_no_phi)
d33 1
a33 1
 "$Id: load_sps_data_m.f90,v 2.7 2002/01/08 01:02:54 livesey Exp $"
d35 1
a35 1
 "$RCSfile: load_sps_data_m.f90,v $"
d86 2
d140 6
d150 3
a152 5

    Grids_f%tot_no_zet = n_f_zet
    Grids_f%tot_no_phi = n_f_phi
    Grids_f%tot_no_frq = n_f_frq

d187 2
a188 1
      r = f_len + kz * kp * kf
a189 1
      Grids_f%zet_basis(l:n-1) = f%template%surfs(:,1)
a200 1
      Grids_f%phi_basis(j:k-1) = f%template%phi(1,:) * Deg2Rad
d224 1
d242 91
d398 3
a400 3
      kz = 0   ! Spect_Der(m)%no_zeta_values
      kp = 0   ! Spect_Der(m)%no_phi_values
      kf = 0   ! Spect_Der(m)%no_frq_values
a426 3
      Grids_dw%tot_no_zet = accum_z_dw
      Grids_dw%tot_no_phi = accum_p_dw
      Grids_dw%tot_no_frq = accum_f_dw
a438 3
      Grids_dn%tot_no_zet = accum_z_dn
      Grids_dn%tot_no_phi = accum_p_dn
      Grids_dn%tot_no_frq = accum_f_dn
a450 3
      Grids_dv%tot_no_zet = accum_z_dv
      Grids_dv%tot_no_phi = accum_p_dv
      Grids_dv%tot_no_frq = accum_f_dv
d547 3
@


2.7
log
@Made my_catalog intent(in) rather than pointer, also 'fixed'
problem with frequency coordinate?
@
text
@d35 1
a35 1
 "$Id: load_sps_data_m.f90,v 2.6 2001/12/14 23:43:24 zvi Exp $"
d45 1
a45 1
        &    MyCatalog)
d48 1
d52 1
d58 2
d111 1
a125 1
        mf = 1
d127 1
a128 1
        mf = 1
d131 1
a131 1
      Grids_f%no_f(ii) = kf * mf
d461 4
@


2.6
log
@Modification for Grouping concept
@
text
@d35 1
a35 1
 "$Id: load_sps_data_m.f90,v 2.5 2001/11/15 01:21:59 zvi Exp $"
d66 1
a66 1
    type (CATALOG_T), dimension(:), pointer :: MyCatalog
d121 1
a121 1
        mf = 0
d457 3
@


2.5
log
@Extiction debug fix
@
text
@d35 1
a35 1
 "$Id: load_sps_data_m.f90,v 2.4 2001/11/10 00:46:40 zvi Exp $"
d43 3
a45 2
        &    p_len, f_len, h2o_ind, ext_ind, lin_log, sps_values, Grids_f,   &
        &    Grids_dw, Grids_dn, Grids_dv, temp, MyCatalog)
d50 1
d77 1
a77 1
           &   l_dw,l_dv,n_f_phi,n_f_zet,n_f_frq,n_sps,s_dw,s_dn,s_dv
d84 2
a85 3
    Integer :: mp, mz, jj
    Real(r8) :: Tmp, Frq, P

d89 1
a89 1
    n_sps = size ( molecules )
d91 1
a91 1
    allocate ( Grids_f%no_z(n_sps), stat=j )
d94 1
a94 1
    allocate ( Grids_f%no_p(n_sps), stat=j )
d97 1
a97 1
    allocate ( Grids_f%no_f(n_sps), stat=j )
d101 1
a101 1
    call Allocate_test ( lin_log, n_sps, 'lin_log', ModuleName )
d107 4
a110 2
    do i = 1 , n_sps
      if ( molecules(i) == l_extinction ) then
d113 1
a113 1
        ext_ind = i
d116 1
a116 1
          & quantityType=l_vmr, molecule=molecules(i) )
d127 3
a129 3
      Grids_f%no_f(i) = kf * mf
      Grids_f%no_z(i) = kz
      Grids_f%no_p(i) = kp
d132 1
a132 1
      if(spec_tags(molecules(i)) == 18003) h2o_ind = i
d159 4
a162 2
    do i = 1 , n_sps
      if ( molecules(i) == l_extinction ) then
d167 1
a167 1
          & quantityType=l_vmr, molecule=molecules(i) )
d197 1
a197 1
      if(ext_ind == i) then
d206 4
a209 2
              f%values(jj,mp) = &
             &  0.8061 * abs_cs_n2_cont(MyCatalog(i)%continuum,Tmp,P,Frq)
d219 1
a219 1
        lin_log(i) = .true.
d222 1
a222 1
        lin_log(i) = .false.
d224 1
d229 1
d231 1
d233 1
a233 1
    
d241 1
a241 1
      allocate ( Grids_dw%no_z(n_sps), stat=j )
d244 1
a244 1
      allocate ( Grids_dw%no_p(n_sps), stat=j )
d247 1
a247 1
      allocate ( Grids_dw%no_f(n_sps), stat=j )
d253 1
a253 1
      allocate ( Grids_dn%no_z(n_sps), stat=j )
d256 1
a256 1
      allocate ( Grids_dn%no_p(n_sps), stat=j )
d259 1
a259 1
      allocate ( Grids_dn%no_f(n_sps), stat=j )
d265 1
a265 1
      allocate ( Grids_dv%no_z(n_sps), stat=j )
d268 1
a268 1
      allocate ( Grids_dv%no_p(n_sps), stat=j )
d271 1
a271 1
      allocate ( Grids_dv%no_f(n_sps), stat=j )
d286 1
a286 1
    do i = 1, n_sps
d288 3
a290 1
      Spectag = spec_tags(molecules(i))
d295 1
a295 1
        if(m == 3*n_sps) exit
d304 3
a306 3
          Grids_dw%no_z(i) = kz
          Grids_dw%no_p(i) = kp
          Grids_dw%no_f(i) = kf
d311 3
a313 3
          Grids_dn%no_z(i) = kz
          Grids_dn%no_p(i) = kp
          Grids_dn%no_f(i) = kf
d318 3
a320 3
          Grids_dv%no_z(i) = kz
          Grids_dv%no_p(i) = kp
          Grids_dv%no_f(i) = kf
d382 1
a382 1
    do i = 1, n_sps
d384 3
a386 1
      Spectag = spec_tags(molecules(i))
d391 1
a391 1
        if(m == 3*n_sps) exit
d397 3
a399 3
          kz = Grids_dw%no_z(i)
          kp = Grids_dw%no_p(i)
          kf = Grids_dw%no_f(i)
d415 3
a417 3
          kz = Grids_dn%no_z(i)
          kp = Grids_dn%no_p(i)
          kf = Grids_dn%no_f(i)
d433 3
a435 3
          kz = Grids_dv%no_z(i)
          kp = Grids_dv%no_p(i)
          kf = Grids_dv%no_f(i)
d457 3
@


2.4
log
@Adding the EXTINCTION capabilitis
@
text
@d12 4
d35 1
a35 1
 "$Id: load_sps_data_m.f90,v 2.3 2001/11/08 09:56:59 zvi Exp $"
d44 1
a44 1
        &    Grids_dw, Grids_dn, Grids_dv)
d63 3
d74 5
a78 4
    integer :: i,j,k,l,m,n,r,s,kz,kp,kf,Spectag,accum_z_dw,accum_p_dw,j_dw, &
           &   j_dn,l_dn,j_dv,l_dw,l_dv,n_f_phi,n_f_zet,n_f_frq,n_sps,s_dw, &
           &   s_dn,s_dv,accum_z_dn,accum_p_dn,accum_z_dv,accum_p_dv,&
           &   accum_f_dw,accum_f_dn,accum_f_dv
d81 4
d118 1
d121 1
d124 1
a126 1
      Grids_f%no_f(i) = kf
d175 1
a187 1
      Grids_f%frq_basis(s:m-1) = 0.0
d189 21
d213 1
a213 1
        sps_values(f_len:r-1) = log(sps_values(f_len:r-1))
d221 1
a221 1
    enddo
d443 3
@


2.3
log
@Fixing a bug..
@
text
@d31 1
a31 1
 "$Id: load_sps_data_m.f90,v 2.2 2001/11/08 00:10:13 livesey Exp $"
d38 3
a40 3
  subroutine load_sps_data(fwdModelIn, fwdModelExtra, molecules, radiometer, p_len, &
        &    f_len, h2o_ind, lin_log, sps_values, Grids_f, Grids_dw,    &
        &    Grids_dn, Grids_dv)
d48 1
d93 1
d98 1
d408 3
@


2.2
log
@Interim version for extinction
@
text
@d31 1
a31 1
 "$Id: load_sps_data_m.f90,v 2.1 2001/11/02 10:48:39 zvi Exp $"
d100 3
a102 1
      if ( f%template%frequencyCoordinate /= l_none ) then
a106 2
      kz = f%template%noSurfs
      kp = f%template%noInstances
d147 3
a149 1
      if ( f%template%frequencyCoordinate /= l_none ) then
a153 3
      kz = f%template%noSurfs
      kp = f%template%noInstances
      k = j + kp
d156 1
a163 1
          print*,'s,m-1,size(frequencies)',s,m-1,size(f%template%frequencies)
d190 1
a190 1
    return
d244 1
a244 1
        exit
d338 1
a338 1
        exit
d405 3
@


2.1
log
@Implementing frequecy grid
@
text
@d5 1
a5 1
  use MLSCommon, only: RP, IP
d7 1
a7 1
  use Intrinsic, only: L_VMR
d9 1
a9 1
  use Molecules, only: spec_tags
d24 1
a24 1
    real(rp), pointer :: frq_basis(:) ! frq  grid entries (dim: tot_no_frq)
d31 1
a31 1
 "$Id: load_sps_data_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d38 1
a38 1
  subroutine load_sps_data(fwdModelIn, fwdModelExtra, molecules, p_len, &
d43 5
a47 5
    integer, intent(in)    :: molecules(:)

    integer, intent(out) :: f_len
    integer, intent(out) :: p_len
    integer, intent(out) :: h2o_ind
d93 12
a104 4
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=molecules(i) )
!     kf = f%template%noChans        ! ** ZEBUG
      kf = 1                         ! ** ZEBUG
d140 12
a151 4
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=molecules(i) )
!     kf = f%template%noChans        ! ** ZEBUG
      kf = 1                         ! ** ZEBUG
d159 12
a170 2
! *** ZEBUG: f%template%%frequencies(:) does not exist yet ..
!     Grids_f%frq_basis(s:m-1) = f%template%%frequencies(:)
d186 1
d406 3
@


2.0
log
@New forward model
@
text
@d11 1
d16 13
d31 1
a31 1
 "$Id: load_sps_data_m.f90,v 1.1.2.10 2001/09/12 21:38:51 zvi Exp $"
d38 3
a40 7
  subroutine load_sps_data(fwdModelIn,fwdModelExtra,molecules,        &
    &   f_len,n_f_phi,n_f_zeta,h2o_ind,       &
    &   no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,             &
    &   n_dw_phi,n_dw_zeta,n_dn_phi,n_dn_zeta,        &
    &   n_dv_phi,n_dv_zeta,no_z_dw,no_phi_dw,no_z_dn,no_phi_dn, &
    &   no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,z_basis_dn,         &
    &   phi_basis_dn,z_basis_dv,phi_basis_dv)
d46 1
a47 2
    integer, intent(out) :: n_f_phi
    integer, intent(out) :: n_f_zeta
d49 4
a52 1
    integer, pointer :: no_z(:), no_phi(:)
d56 1
a56 1
    real(rp), pointer :: z_basis(:), phi_basis(:), sps_values(:)
a62 12
    integer, intent(out) :: n_dw_phi, n_dw_zeta
    integer, intent(out) :: n_dn_phi, n_dn_zeta
    integer, intent(out) :: n_dv_phi, n_dv_zeta

    integer, pointer :: no_z_dw(:), no_phi_dw(:)
    integer, pointer :: no_z_dn(:), no_phi_dn(:)
    integer, pointer :: no_z_dv(:), no_phi_dv(:)

    real(rp), pointer :: z_basis_dw(:), phi_basis_dw(:)
    real(rp), pointer :: z_basis_dn(:), phi_basis_dn(:)
    real(rp), pointer :: z_basis_dv(:), phi_basis_dv(:)

d66 4
a69 3
    integer :: i,j,k,l,m,n,kz,kp,Spectag,n_sps,accum_z_dw,accum_p_dw, &
           &   accum_z_dn,accum_p_dn,accum_z_dv,accum_p_dv,j_dw,l_dw,&
           &   j_dn,l_dn,j_dv,l_dv
d76 11
a86 2
    call Allocate_test ( no_z, n_sps, 'no_z', ModuleName )
    call Allocate_test ( no_phi, n_sps, 'no_phi', ModuleName )
d89 2
d95 9
a103 2
      no_phi(i) = f%template%noInstances
      no_z(i) = f%template%noSurfs
d106 2
d109 17
a125 6
    f_len = sum(no_z * no_phi)
    n_f_phi = sum(no_phi)
    n_f_zeta = sum(no_z)
    call Allocate_test ( sps_values, f_len, 'sps_values', ModuleName )
    call Allocate_test ( z_basis, n_f_zeta, 'z_basis', ModuleName )
    call Allocate_test ( phi_basis, n_f_phi, 'phi_basis', ModuleName )
d129 1
d134 14
a147 7
      k = j + no_phi(i)
      n = l + no_z(i)
      m = f_len + no_z(i) * no_phi(i)
      z_basis(l:n-1) = f%template%surfs(:,1)
      phi_basis(j:k-1) = f%template%phi(1,:) * Deg2Rad
      sps_values(f_len:m-1) = reshape(f%values(1:no_z(i),1:no_phi(i)), &
        &  (/no_z(i)*no_phi(i)/))
d150 1
a150 1
        sps_values(f_len:m-1) = log(sps_values(f_len:m-1))
d156 2
a157 1
      f_len = m
d167 9
a175 4
      call Allocate_test ( no_z_dw, n_sps, 'no_z_dw', ModuleName )
      call Allocate_test ( no_phi_dw, n_sps, 'no_phi_dw', ModuleName )
      no_z_dw = 0
      no_phi_dw = 0
d179 9
a187 4
      call Allocate_test ( no_z_dn, n_sps, 'no_z_dn', ModuleName )
      call Allocate_test ( no_phi_dn, n_sps, 'no_phi_dn', ModuleName )
      no_z_dn = 0
      no_phi_dn = 0
d191 9
a199 4
      call Allocate_test ( no_z_dv, n_sps, 'no_z_dv', ModuleName )
      call Allocate_test ( no_phi_dv, n_sps, 'no_phi_dv', ModuleName )
      no_z_dv = 0
      no_phi_dv = 0
d204 1
d207 1
d210 1
d223 3
a225 2
      kz = 0 ! Spect_Der(m)%no_zeta_values
      kp = 0 ! Spect_Der(m)%no_phi_values
d228 3
a230 2
          no_z_dw(i) = kz
          no_phi_dw(i) = kp
d233 1
d235 3
a237 2
          no_z_dn(i) = kz
          no_phi_dn(i) = kp
d240 1
d242 3
a244 2
          no_z_dv(i) = kz
          no_phi_dv(i) = kp
d247 1
d251 13
a263 8
    if(accum_z_dw * accum_p_dw < 1) then
      call Deallocate_test ( no_z_dw, 'no_z_dw', ModuleName )
      call Deallocate_test ( no_phi_dw, 'no_phi_dw' ,ModuleName )
    else
      n_dw_phi = accum_p_dw
      n_dw_zeta = accum_z_dw
      call Allocate_test(z_basis_dw,n_dw_zeta,'z_basis_dw',ModuleName)
      call Allocate_test(phi_basis_dw,n_dw_phi,'phi_basis_dw',ModuleName)
d266 13
a278 8
    if(accum_z_dn * accum_p_dn < 1) then
      call Deallocate_test ( no_z_dn, 'no_z_dn', ModuleName )
      call Deallocate_test ( no_phi_dn, 'no_phi_dn' ,ModuleName )
    else
      n_dn_phi = accum_p_dn
      n_dn_zeta = accum_z_dn
      call Allocate_test(z_basis_dn,n_dn_zeta,'z_basis_dn',ModuleName)
      call Allocate_test(phi_basis_dn,n_dn_phi,'phi_basis_dn',ModuleName)
d281 13
a293 8
    if(accum_z_dv * accum_p_dv < 1) then
      call Deallocate_test ( no_z_dv, 'no_z_dv', ModuleName )
      call Deallocate_test ( no_phi_dv, 'no_phi_dv' ,ModuleName )
    else
      n_dv_phi = accum_p_dv
      n_dv_zeta = accum_z_dv
      call Allocate_test(z_basis_dv,n_dv_zeta,'z_basis_dv',ModuleName)
      call Allocate_test(phi_basis_dv,n_dv_phi,'phi_basis_dv',ModuleName)
d298 1
d301 1
d304 1
d319 4
a322 3
          kz = no_z_dw(i)
          kp = no_phi_dw(i)
          if(kp*kz > 0) then
d325 7
a331 2
            !** z_basis_dw(l_dw:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dw(j_dw:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
d334 1
d337 4
a340 3
          kz = no_z_dn(i)
          kp = no_phi_dn(i)
          if(kp*kz > 0) then
d343 7
a349 2
            !** z_basis_dn(l_dn:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dn(j_dn:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
d352 1
d355 4
a358 3
          kz = no_z_dv(i)
          kp = no_phi_dv(i)
          if(kp*kz > 0) then
d361 7
a367 2
            !** z_basis_dv(l_dv:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dv(j_dv:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
d370 1
d379 3
@


1.1
log
@file load_sps_data_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 304
@


1.1.2.1
log
@New module..
@
text
@a0 270
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module LOAD_SPS_DATA_M
  use SET_PRECISION_M
  use Units, only: Deg2Rad
  use VectorsModule, only: Vector_T, VectorValue_T, GetVectorQuantityByType
  use Molecules, only: spec_tags
  Implicit None
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
 "$Id: load_sps_data_m.f90,v 1.9 2001/06/21 13:07:09 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
 "$RCSfile: load_sps_data_m.f90,v $"
!---------------------------------------------------------------------------
contains

!-------------------------------------------------------------------

 SUBROUTINE load_sps_data(fwdModelIn,fwdModelExtra,molecules,n_sps,       &
        &   no_coeffs_f,no_phi_f,sv_len,n_sv_phi,n_sv_zeta,h2o_ind,       &
        &   no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,Spect_Der,   &
        &   WNV,n_sv_phi_dw,n_sv_zeta_dw,n_sv_phi_dn,n_sv_zeta_dn,        &
        &   n_sv_phi_dv,n_sv_zeta_dv,no_z_dw,no_phi_dw,no_z_dn,no_phi_dn, &
        &   no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,z_basis_dn,         &
        &   phi_basis_dn,z_basis_dv,phi_basis_dv)

  type(vector_T), INTENT(in) ::  FwdModelIn, FwdModelExtra
  Integer(ip), INTENT(in)    :: molecules(:)

  Integer(ip), INTENT(in) :: n_sps
  Integer(ip), INTENT(in) :: no_coeffs_f(:),no_phi_f(:)

  Integer(ip), INTENT(out) :: sv_len
  Integer(ip), INTENT(out) :: h2o_ind
  Integer(ip), INTENT(out) :: n_sv_phi
  Integer(ip), INTENT(out) :: n_sv_zeta

  Integer(ip), INTENT(out) :: no_z(:), no_phi(:)

  Logical, INTENT(out) :: lin_log(:)

  Real(rp), INTENT(out) :: z_basis(:), phi_basis(:), sps_values(:)

  Character(LEN=*), OPTIONAL, INTENT(in) :: WNV
  type(Spect_der_T), OPTIONAL, INTENT(in) :: Spect_Der(:)

  Integer(ip), OPTIONAL, INTENT(out) :: n_sv_phi_dw, n_sv_zeta_dw
  Integer(ip), OPTIONAL, INTENT(out) :: n_sv_phi_dn, n_sv_zeta_dn
  Integer(ip), OPTIONAL, INTENT(out) :: n_sv_phi_dv, n_sv_zeta_dv

  Integer(ip), OPTIONAL, INTENT(out) :: no_z_dw(:), no_phi_dw(:)
  Integer(ip), OPTIONAL, INTENT(out) :: no_z_dn(:), no_phi_dn(:)
  Integer(ip), OPTIONAL, INTENT(out) :: no_z_dv(:), no_phi_dv(:)

  Real(rp), OPTIONAL, INTENT(out) :: z_basis_dw(:), phi_basis_dw(:)
  Real(rp), OPTIONAL, INTENT(out) :: z_basis_dn(:), phi_basis_dn(:)
  Real(rp), OPTIONAL, INTENT(out) :: z_basis_dv(:), phi_basis_dv(:)

! Local variables:

  Integer(ip) :: i,j,k,l,m,n,kk,kz,ht_i,Spectag

  type (VectorValue_T), pointer :: F             ! An arbitrary species
!
!******************* LOAD SPECIES DATA ************
!
  sv_len = SUM(no_coeffs_f * no_phi_f)
  n_sv_phi = SUM(no_phi_f)
  n_sv_zeta = SUM(no_coeffs_f)
  ALLOCATE(sps_values(1:sv_len),no_z(1:n_sps),no_phi(1:n_sps), &
      &    lin_log(1:n_sps), z_basis(1:n_sv_zeta),phi_basis(1:n_sv_phi))
!
  j = 1
  l = 1
  sv_len = 1
  h2o_ind = 0
  DO i = 1 , n_sps
    f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=molecules(i) )
    no_phi(i) = f%template%noInstances
    no_z(i) = f%template%noSurfs
    IF(spec_tags(molecules(i)) == 18003) h2o_ind = i
    k = j + no_phi(i)
    n = l + no_z(i)
    m = sv_len + no_z(i) * no_phi(i)
    z_basis(l:n-1) = f%template%surfs(:,1)
    phi_basis(j:k-1) = f%template%phi(1,:) * Deg2Rad
    sps_values(sv_len:m-1) = RESHAPE(f%values(1:no_z(i),1:no_phi(i)), &
                          &  (/no_z(i)*no_phi(i)/))
    if (f%template%logBasis) then
      lin_log(i) = .true.
      sps_values(sv_len:m-1) = LOG(sps_values(sv_len:m-1))
    ELSE
      lin_log(i) = .false.
    ENDIF
    j = k
    l = n
    sv_len = m
  ENDDO
  sv_len = sv_len - 1
!
!******************* LOAD SPECTRAL SPECIES DATA ****************
!
  if (.not. associated(Spect_der) ) Return

  IF(Index(WNV,'W') > 0) THEN
    n_sv_phi_dw = 0
    n_sv_zeta_dw = 0
    ALLOCATE(no_z_dw(1:n_sps),no_phi_dw(1:n_sps))
    no_z_dw(1:) = 0
    no_phi_dw(1:) = 0
    DO i = 1, n_sps
      m = 0
      Spectag = spec_tags(molecules(i))
      DO
        m = m + 1
        if(Spect_Der(m)%Spectag == Spectag) EXIT
        if(m == 3*n_sps) EXIT
      END DO
      if(Spect_Der(m)%Spectag /= Spectag) CYCLE
      if(Spect_Der(m)%type /= 'W') CYCLE
      no_z_dw(i) = Spect_Der(m)%no_zeta_values
      no_phi_dw(i) = Spect_Der(m)%no_phi_values
      n_sv_phi_dw = n_sv_phi_dw + no_phi_dw(i)
      n_sv_zeta_dw = n_sv_zeta_dw + no_z_dw(i)
    END DO
    k = n_sv_zeta_dw * n_sv_phi_dw
    if(k < 1) THEN
      DEALLOCATE(no_z_dw,no_phi_dw)
    ELSE
      j = 1
      l = 1
      ALLOCATE(z_basis_dw(1:n_sv_zeta_dw),phi_basis_dw(1:n_sv_phi_dw))
      DO i = 1, n_sps
        m = 0
        Spectag = spec_tags(molecules(i))
        DO
          m = m + 1
          if(Spect_Der(m)%Spectag == Spectag) EXIT
          if(m == 3*n_sps) EXIT
        END DO
        if(Spect_Der(m)%Spectag /= Spectag) CYCLE
        if(Spect_Der(m)%type /= 'W') CYCLE
        ht_i = no_z_dw(i)
        kz = no_phi_dw(i)
        IF(kz*ht_i > 0) THEN
          k = j + kz
          n = l + ht_i
          z_basis_dw(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
          phi_basis_dw(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
          j = k
          l = n
        ENDIF
      END DO
      phi_basis_dw(1:) = Deg2Rad * phi_basis_dw(1:)
    ENDIF
  ENDIF
!
  IF(Index(WNV,'N') > 0) THEN
    n_sv_phi_dn = 0
    n_sv_zeta_dn = 0
    ALLOCATE(no_z_dn(1:n_sps),no_phi_dn(1:n_sps))
    no_z_dn(1:) = 0
    no_phi_dn(1:) = 0
    DO i = 1, n_sps
      m = 0
      Spectag = spec_tags(molecules(i))
      DO
        m = m + 1
        if(Spect_Der(m)%Spectag == Spectag) EXIT
        if(m == 3*n_sps) EXIT
      END DO
      if(Spect_Der(m)%Spectag /= Spectag) CYCLE
      if(Spect_Der(m)%type /= 'N') CYCLE
      no_z_dn(i) = Spect_Der(m)%no_zeta_values
      no_phi_dn(i) = Spect_Der(m)%no_phi_values
      n_sv_phi_dn = n_sv_phi_dn + no_phi_dn(i)
      n_sv_zeta_dn = n_sv_zeta_dn + no_z_dn(i)
    END DO
    k = n_sv_zeta_dn * n_sv_phi_dn
    if(k < 1) THEN
      DEALLOCATE(no_z_dn,no_phi_dn)
    ELSE
      j = 1
      l = 1
      ALLOCATE(z_basis_dn(1:n_sv_zeta_dn),phi_basis_dn(1:n_sv_phi_dn))
      DO i = 1, n_sps
        m = 0
        Spectag = spec_tags(molecules(i))
        DO
          m = m + 1
          if(Spect_Der(m)%Spectag == Spectag) EXIT
          if(m == 3*n_sps) EXIT
        END DO
        if(Spect_Der(m)%Spectag /= Spectag) CYCLE
        if(Spect_Der(m)%type /= 'N') CYCLE
        ht_i = no_z_dn(i)
        kz = no_phi_dn(i)
        IF(kz*ht_i > 0) THEN
          k = j + kz
          n = l + ht_i
          z_basis_dn(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
          phi_basis_dn(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
          j = k
          l = n
        ENDIF
      END DO
      phi_basis_dn(1:) = Deg2Rad * phi_basis_dn(1:)
    ENDIF
  ENDIF
!
  IF(Index(WNV,'V') > 0) THEN
    n_sv_phi_dv = 0
    n_sv_zeta_dv = 0
    ALLOCATE(no_z_dv(1:n_sps),no_phi_dv(1:n_sps))
    no_z_dv(1:) = 0
    no_phi_dv(1:) = 0
    DO i = 1, n_sps
      m = 0
      Spectag = spec_tags(molecules(i))
      DO
        m = m + 1
        if(Spect_Der(m)%Spectag == Spectag) EXIT
        if(m == 3*n_sps) EXIT
      END DO
      if(Spect_Der(m)%Spectag /= Spectag) CYCLE
      if(Spect_Der(m)%type /= 'V') CYCLE
      no_z_dv(i) = Spect_Der(m)%no_zeta_values
      no_phi_dv(i) = Spect_Der(m)%no_phi_values
      n_sv_phi_dv = n_sv_phi_dv + no_phi_dv(i)
      n_sv_zeta_dv = n_sv_zeta_dv + no_z_dv(i)
    END DO
    k = n_sv_zeta_dv * n_sv_phi_dv
    if(k < 1) THEN
      DEALLOCATE(no_z_dv,no_phi_dv)
    ELSE
      j = 1
      l = 1
      ALLOCATE(z_basis_dv(1:n_sv_zeta_dv),phi_basis_dv(1:n_sv_phi_dv))
      DO i = 1, n_sps
        m = 0
        Spectag = spec_tags(molecules(i))
        DO
          m = m + 1
          if(Spect_Der(m)%Spectag == Spectag) EXIT
          if(m == 3*n_sps) EXIT
        END DO
        if(Spect_Der(m)%Spectag /= Spectag) CYCLE
        if(Spect_Der(m)%type /= 'V') CYCLE
        ht_i = no_z_dv(i)
        kz = no_phi_dv(i)
        IF(kz*ht_i > 0) THEN
          k = j + kz
          n = l + ht_i
          z_basis_dv(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
          phi_basis_dv(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
          j = k
          l = n
        ENDIF
      END DO
      phi_basis_dv(1:) = Deg2Rad * phi_basis_dv(1:)
    ENDIF
  ENDIF
!
 END SUBROUTINE load_sps_data
!
END module LOAD_SPS_DATA_M
! $Log: load_sps_data_m.f90,v $
! Revision 1.0  2001/09/06 13:07:09  zvi
@


1.1.2.2
log
@Changed stuff to lower case
@
text
@d9 1
a9 1
  implicit none
d11 3
a13 3
  character (LEN=256) :: Id = &
 "$Id: load_sps_data_m.f90,v 1.1.2.1 2001/09/07 19:56:41 zvi Exp $"
  character (LEN=*), parameter :: ModuleName= &
d20 1
a20 1
 subroutine load_sps_data(fwdModelIn,fwdModelExtra,molecules,n_sps,       &
d28 2
a29 2
  type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
  integer(ip), intent(in)    :: molecules(:)
d31 2
a32 2
  integer(ip), intent(in) :: n_sps
  integer(ip), intent(in) :: no_coeffs_f(:),no_phi_f(:)
d34 4
a37 4
  integer(ip), intent(out) :: sv_len
  integer(ip), intent(out) :: h2o_ind
  integer(ip), intent(out) :: n_sv_phi
  integer(ip), intent(out) :: n_sv_zeta
d39 1
a39 1
  integer(ip), intent(out) :: no_z(:), no_phi(:)
d41 1
a41 1
  logical, intent(out) :: lin_log(:)
d43 1
a43 1
  real(rp), intent(out) :: z_basis(:), phi_basis(:), sps_values(:)
d45 2
a46 2
  character(LEN=*), optional, intent(in) :: WNV
  type(Spect_der_T), optional, intent(in) :: Spect_Der(:)
d48 3
a50 3
  integer(ip), optional, intent(out) :: n_sv_phi_dw, n_sv_zeta_dw
  integer(ip), optional, intent(out) :: n_sv_phi_dn, n_sv_zeta_dn
  integer(ip), optional, intent(out) :: n_sv_phi_dv, n_sv_zeta_dv
d52 3
a54 3
  integer(ip), optional, intent(out) :: no_z_dw(:), no_phi_dw(:)
  integer(ip), optional, intent(out) :: no_z_dn(:), no_phi_dn(:)
  integer(ip), optional, intent(out) :: no_z_dv(:), no_phi_dv(:)
d56 3
a58 3
  real(rp), optional, intent(out) :: z_basis_dw(:), phi_basis_dw(:)
  real(rp), optional, intent(out) :: z_basis_dn(:), phi_basis_dn(:)
  real(rp), optional, intent(out) :: z_basis_dv(:), phi_basis_dv(:)
d62 1
a62 1
  integer(ip) :: i,j,k,l,m,n,kk,kz,ht_i,Spectag
d68 4
a71 4
  sv_len = sum(no_coeffs_f * no_phi_f)
  n_sv_phi = sum(no_phi_f)
  n_sv_zeta = sum(no_coeffs_f)
  allocate(sps_values(1:sv_len),no_z(1:n_sps),no_phi(1:n_sps), &
d78 1
a78 1
  do i = 1 , n_sps
d83 1
a83 1
    if(spec_tags(molecules(i)) == 18003) h2o_ind = i
d89 1
a89 1
    sps_values(sv_len:m-1) = reshape(f%values(1:no_z(i),1:no_phi(i)), &
d93 2
a94 2
      sps_values(sv_len:m-1) = log(sps_values(sv_len:m-1))
    else
d96 1
a96 1
    endif
d100 1
a100 1
  enddo
d105 1
a105 1
  if (.not. associated(Spect_der) ) return
d107 1
a107 1
  if(index(WNV,'W') > 0) then
d110 1
a110 1
    allocate(no_z_dw(1:n_sps),no_phi_dw(1:n_sps))
d113 1
a113 1
    do i = 1, n_sps
d116 1
a116 1
      do
d118 5
a122 5
        if(Spect_Der(m)%Spectag == Spectag) exit
        if(m == 3*n_sps) exit
      end do
      if(Spect_Der(m)%Spectag /= Spectag) cycle
      if(Spect_Der(m)%type /= 'W') cycle
d127 1
a127 1
    end do
d129 3
a131 3
    if(k < 1) then
      deallocate(no_z_dw,no_phi_dw)
    else
d134 2
a135 2
      allocate(z_basis_dw(1:n_sv_zeta_dw),phi_basis_dw(1:n_sv_phi_dw))
      do i = 1, n_sps
d138 1
a138 1
        do
d140 5
a144 5
          if(Spect_Der(m)%Spectag == Spectag) exit
          if(m == 3*n_sps) exit
        end do
        if(Spect_Der(m)%Spectag /= Spectag) cycle
        if(Spect_Der(m)%type /= 'W') cycle
d147 1
a147 1
        if(kz*ht_i > 0) then
d154 2
a155 2
        endif
      end do
d157 2
a158 2
    endif
  endif
d160 1
a160 1
  if(index(WNV,'N') > 0) then
d163 1
a163 1
    allocate(no_z_dn(1:n_sps),no_phi_dn(1:n_sps))
d166 1
a166 1
    do i = 1, n_sps
d169 1
a169 1
      do
d171 5
a175 5
        if(Spect_Der(m)%Spectag == Spectag) exit
        if(m == 3*n_sps) exit
      end do
      if(Spect_Der(m)%Spectag /= Spectag) cycle
      if(Spect_Der(m)%type /= 'N') cycle
d180 1
a180 1
    end do
d182 3
a184 3
    if(k < 1) then
      deallocate(no_z_dn,no_phi_dn)
    else
d187 2
a188 2
      allocate(z_basis_dn(1:n_sv_zeta_dn),phi_basis_dn(1:n_sv_phi_dn))
      do i = 1, n_sps
d191 1
a191 1
        do
d193 5
a197 5
          if(Spect_Der(m)%Spectag == Spectag) exit
          if(m == 3*n_sps) exit
        end do
        if(Spect_Der(m)%Spectag /= Spectag) cycle
        if(Spect_Der(m)%type /= 'N') cycle
d200 1
a200 1
        if(kz*ht_i > 0) then
d207 2
a208 2
        endif
      end do
d210 2
a211 2
    endif
  endif
d213 1
a213 1
  if(index(WNV,'V') > 0) then
d216 1
a216 1
    allocate(no_z_dv(1:n_sps),no_phi_dv(1:n_sps))
d219 1
a219 1
    do i = 1, n_sps
d222 1
a222 1
      do
d224 5
a228 5
        if(Spect_Der(m)%Spectag == Spectag) exit
        if(m == 3*n_sps) exit
      end do
      if(Spect_Der(m)%Spectag /= Spectag) cycle
      if(Spect_Der(m)%type /= 'V') cycle
d233 1
a233 1
    end do
d235 3
a237 3
    if(k < 1) then
      deallocate(no_z_dv,no_phi_dv)
    else
d240 2
a241 2
      allocate(z_basis_dv(1:n_sv_zeta_dv),phi_basis_dv(1:n_sv_phi_dv))
      do i = 1, n_sps
d244 1
a244 1
        do
d246 5
a250 5
          if(Spect_Der(m)%Spectag == Spectag) exit
          if(m == 3*n_sps) exit
        end do
        if(Spect_Der(m)%Spectag /= Spectag) cycle
        if(Spect_Der(m)%type /= 'V') cycle
d253 1
a253 1
        if(kz*ht_i > 0) then
d260 2
a261 2
        endif
      end do
d263 2
a264 2
    endif
  endif
d266 1
a266 1
 end subroutine load_sps_data
d268 1
a268 1
end module LOAD_SPS_DATA_M
a269 3
! Revision 1.1.2.1  2001/09/07 19:56:41  zvi
! New module..
!
@


1.1.2.3
log
@Messing around.
@
text
@d12 1
a12 1
 "$Id: load_sps_data_m.f90,v 1.1.2.2 2001/09/07 20:16:28 livesey Exp $"
d20 7
a26 7
  subroutine load_sps_data(fwdModelIn,fwdModelExtra,molecules,        &
    &   no_coeffs_f,no_phi_f,sv_len,n_sv_phi,n_sv_zeta,h2o_ind,       &
    &   no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,Spect_Der,   &
    &   WNV,n_sv_phi_dw,n_sv_zeta_dw,n_sv_phi_dn,n_sv_zeta_dn,        &
    &   n_sv_phi_dv,n_sv_zeta_dv,no_z_dw,no_phi_dw,no_z_dn,no_phi_dn, &
    &   no_z_dv,no_phi_dv,z_basis_dw,phi_basis_dw,z_basis_dn,         &
    &   phi_basis_dn,z_basis_dv,phi_basis_dv)
d28 2
a29 2
    type(vector_T), intent(in) ::  FwdModelIn, FwdModelExtra
    integer(ip), intent(in)    :: molecules(:)
d31 2
a32 1
    integer(ip), intent(in) :: no_coeffs_f(:),no_phi_f(:)
d34 4
a37 4
    integer(ip), intent(out) :: sv_len
    integer(ip), intent(out) :: h2o_ind
    integer(ip), intent(out) :: n_sv_phi
    integer(ip), intent(out) :: n_sv_zeta
d39 1
a39 1
    integer(ip), intent(out) :: no_z(:), no_phi(:)
d41 1
a41 1
    logical, intent(out) :: lin_log(:)
d43 1
a43 1
    real(rp), intent(out) :: z_basis(:), phi_basis(:), sps_values(:)
d45 2
a46 2
    character(LEN=*), optional, intent(in) :: WNV
    type(Spect_der_T), optional, intent(in) :: Spect_Der(:)
d48 3
a50 3
    integer(ip), optional, intent(out) :: n_sv_phi_dw, n_sv_zeta_dw
    integer(ip), optional, intent(out) :: n_sv_phi_dn, n_sv_zeta_dn
    integer(ip), optional, intent(out) :: n_sv_phi_dv, n_sv_zeta_dv
d52 3
a54 3
    integer(ip), optional, intent(out),pointer :: no_z_dw(:), no_phi_dw(:)
    integer(ip), optional, intent(out),pointer :: no_z_dn(:), no_phi_dn(:)
    integer(ip), optional, intent(out),pointer :: no_z_dv(:), no_phi_dv(:)
d56 3
a58 3
    real(rp), optional, intent(out), pointer :: z_basis_dw(:), phi_basis_dw(:)
    real(rp), optional, intent(out), pointer :: z_basis_dn(:), phi_basis_dn(:)
    real(rp), optional, intent(out), pointer :: z_basis_dv(:), phi_basis_dv(:)
d60 1
a60 1
    ! Local variables:
d62 1
a62 2
    integer(ip) :: i,j,k,l,m,n,kk,kz,ht_i,Spectag
    integer(ip) :: n_sps
d64 1
a64 1
    type (VectorValue_T), pointer :: F             ! An arbitrary species
d66 1
a66 1
    !******************* LOAD SPECIES DATA ************
d68 5
a72 10
    sv_len = sum(no_coeffs_f * no_phi_f)
    n_sv_phi = sum(no_phi_f)
    n_sv_zeta = sum(no_coeffs_f)
    n_sps = size ( molecules )
    call Allocate_test ( sps_values, sv_len, 'sps_values', ModuleName )
    call Allocate_test ( no_z, n_sps, 'no_z', ModuleName )
    call Allocate_test ( no_phi, n_sps, 'no_phi', ModuleName )
    call Allocate_test ( lin_log, n_sps, 'lin_log', ModuleName )
    call Allocate_test ( z_basis, n_sv_zeta, 'z_basis', ModuleName )
    call Allocate_test ( phi_basis, n_sv_phi, 'phi_basis', ModuleName )
d74 6
a79 6
    j = 1
    l = 1
    sv_len = 1
    h2o_ind = 0
    do i = 1 , n_sps
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d81 54
a134 33
      no_phi(i) = f%template%noInstances
      no_z(i) = f%template%noSurfs
      if(spec_tags(molecules(i)) == 18003) h2o_ind = i
      k = j + no_phi(i)
      n = l + no_z(i)
      m = sv_len + no_z(i) * no_phi(i)
      z_basis(l:n-1) = f%template%surfs(:,1)
      phi_basis(j:k-1) = f%template%phi(1,:) * Deg2Rad
      sps_values(sv_len:m-1) = reshape(f%values(1:no_z(i),1:no_phi(i)), &
        &  (/no_z(i)*no_phi(i)/))
      if (f%template%logBasis) then
        lin_log(i) = .true.
        sps_values(sv_len:m-1) = log(sps_values(sv_len:m-1))
      else
        lin_log(i) = .false.
      endif
      j = k
      l = n
      sv_len = m
    enddo
    sv_len = sv_len - 1
!
    !******************* LOAD SPECTRAL SPECIES DATA ****************
!
    if (.not. associated(Spect_der) ) return

    if(index(WNV,'W') > 0) then
      n_sv_phi_dw = 0
      n_sv_zeta_dw = 0
      call Allocate_test ( no_z_dw, n_sps, 'no_z_dw', ModuleName )
      call Allocate_test ( no_phi_dw, n_sps, 'no_phi_dw', ModuleName )
      no_z_dw(1:) = 0
      no_phi_dw(1:) = 0
d145 10
a154 4
        no_z_dw(i) = Spect_Der(m)%no_zeta_values
        no_phi_dw(i) = Spect_Der(m)%no_phi_values
        n_sv_phi_dw = n_sv_phi_dw + no_phi_dw(i)
        n_sv_zeta_dw = n_sv_zeta_dw + no_z_dw(i)
d156 1
a156 32
      k = n_sv_zeta_dw * n_sv_phi_dw
      if(k < 1) then
        call Deallocate_test ( no_z_dw, 'no_z_dw', ModuleName )
        call Deallocate_test ( no_phi_dw, 'no_phi_dw' ,ModuleName )
      else
        j = 1
        l = 1
        call Allocate_test ( z_basis_dw, n_sv_zeta_dw, 'z_basis_dw', ModuleName )
        call Allocate_test ( phi_basis_dw, n_sv_phi_dw, 'phi_basis_dw', ModuleName )
        do i = 1, n_sps
          m = 0
          Spectag = spec_tags(molecules(i))
          do
            m = m + 1
            if(Spect_Der(m)%Spectag == Spectag) exit
            if(m == 3*n_sps) exit
          end do
          if(Spect_Der(m)%Spectag /= Spectag) cycle
          if(Spect_Der(m)%type /= 'W') cycle
          ht_i = no_z_dw(i)
          kz = no_phi_dw(i)
          if(kz*ht_i > 0) then
            k = j + kz
            n = l + ht_i
            z_basis_dw(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            phi_basis_dw(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
            j = k
            l = n
          endif
        end do
        phi_basis_dw(1:) = Deg2Rad * phi_basis_dw(1:)
      endif
d158 1
d160 28
a187 7
    if(index(WNV,'N') > 0) then
      n_sv_phi_dn = 0
      n_sv_zeta_dn = 0
      call Allocate_test ( no_z_dn, n_sps, 'no_z_dn', ModuleName )
      call Allocate_test ( no_phi_dn, n_sps, 'no_phi_dn', ModuleName )
      no_z_dn(1:) = 0
      no_phi_dn(1:) = 0
d198 10
a207 4
        no_z_dn(i) = Spect_Der(m)%no_zeta_values
        no_phi_dn(i) = Spect_Der(m)%no_phi_values
        n_sv_phi_dn = n_sv_phi_dn + no_phi_dn(i)
        n_sv_zeta_dn = n_sv_zeta_dn + no_z_dn(i)
d209 1
a209 32
      k = n_sv_zeta_dn * n_sv_phi_dn
      if(k < 1) then
        call Deallocate_test ( no_z_dn, 'no_z_dn', ModuleName )
        call Deallocate_test ( no_phi_dn, 'no_phi_dn' ,ModuleName )
      else
        j = 1
        l = 1
        call Allocate_test ( z_basis_dn, n_sv_zeta_dn, 'z_basis_dn', ModuleName )
        call Allocate_test ( phi_basis_dn, n_sv_phi_dn, 'phi_basis_dn', ModuleName )
        do i = 1, n_sps
          m = 0
          Spectag = spec_tags(molecules(i))
          do
            m = m + 1
            if(Spect_Der(m)%Spectag == Spectag) exit
            if(m == 3*n_sps) exit
          end do
          if(Spect_Der(m)%Spectag /= Spectag) cycle
          if(Spect_Der(m)%type /= 'N') cycle
          ht_i = no_z_dn(i)
          kz = no_phi_dn(i)
          if(kz*ht_i > 0) then
            k = j + kz
            n = l + ht_i
            z_basis_dn(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            phi_basis_dn(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
            j = k
            l = n
          endif
        end do
        phi_basis_dn(1:) = Deg2Rad * phi_basis_dn(1:)
      endif
d211 1
d213 28
a240 7
    if(index(WNV,'V') > 0) then
      n_sv_phi_dv = 0
      n_sv_zeta_dv = 0
      call Allocate_test ( no_z_dv, n_sps, 'no_z_dv', ModuleName )
      call Allocate_test ( no_phi_dv, n_sps, 'no_phi_dv', ModuleName )
      no_z_dv(1:) = 0
      no_phi_dv(1:) = 0
d251 10
a260 4
        no_z_dv(i) = Spect_Der(m)%no_zeta_values
        no_phi_dv(i) = Spect_Der(m)%no_phi_values
        n_sv_phi_dv = n_sv_phi_dv + no_phi_dv(i)
        n_sv_zeta_dv = n_sv_zeta_dv + no_z_dv(i)
d262 1
a262 30
      k = n_sv_zeta_dv * n_sv_phi_dv
      if(k < 1) then
        deallocate(no_z_dv,no_phi_dv)
      else
        j = 1
        l = 1
        allocate(z_basis_dv(1:n_sv_zeta_dv),phi_basis_dv(1:n_sv_phi_dv))
        do i = 1, n_sps
          m = 0
          Spectag = spec_tags(molecules(i))
          do
            m = m + 1
            if(Spect_Der(m)%Spectag == Spectag) exit
            if(m == 3*n_sps) exit
          end do
          if(Spect_Der(m)%Spectag /= Spectag) cycle
          if(Spect_Der(m)%type /= 'V') cycle
          ht_i = no_z_dv(i)
          kz = no_phi_dv(i)
          if(kz*ht_i > 0) then
            k = j + kz
            n = l + ht_i
            z_basis_dv(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            phi_basis_dv(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
            j = k
            l = n
          endif
        end do
        phi_basis_dv(1:) = Deg2Rad * phi_basis_dv(1:)
      endif
d264 1
d266 1
a266 18
  end subroutine load_sps_data

! Later on, it might make sense to do this as follows:
! do item = 1, 3

!   if appropriate then allocate ( stuff)

!    .
!    .

!    case item of
!    1: wStuff => stuff
!    2: nStuff => stuff
!    3: vStuff => stuff
! enddo



a269 3
! Revision 1.1.2.2  2001/09/07 20:16:28  livesey
! Changed stuff to lower case
!
a273 3



@


1.1.2.4
log
@Working on developement version
@
text
@d5 1
a5 1
  use MLSCommon, only: RP, IP
a6 1
  use Intrinsic, only: L_VMR
a8 1
  use Allocate_Deallocate, only: Allocate_test, Deallocate_test
d12 1
a12 1
 "$Id: load_sps_data_m.f90,v 1.1.2.3 2001/09/07 20:41:42 livesey Exp $"
d22 1
a22 1
    &   no_z,no_phi,lin_log,z_basis,phi_basis,sps_values,             &
d29 1
a29 1
    integer, intent(in)    :: molecules(:)
d31 1
a31 1
    integer, intent(in) :: no_coeffs_f(:),no_phi_f(:)
d33 4
a36 4
    integer, pointer :: sv_len
    integer, pointer :: h2o_ind
    integer, pointer :: n_sv_phi
    integer, pointer :: n_sv_zeta
d38 1
a38 1
    integer, pointer :: no_z(:), no_phi(:)
d40 1
a40 1
    logical, pointer :: lin_log(:)
d42 1
a42 1
    real(rp), pointer :: z_basis(:), phi_basis(:), sps_values(:)
d45 1
a45 1
!   type(Spect_der_T), optional, intent(in) :: Spect_Der(:)
d47 11
a57 11
    integer, intent(out) :: n_sv_phi_dw, n_sv_zeta_dw
    integer, intent(out) :: n_sv_phi_dn, n_sv_zeta_dn
    integer, intent(out) :: n_sv_phi_dv, n_sv_zeta_dv

    integer, pointer :: no_z_dw(:), no_phi_dw(:)
    integer, pointer :: no_z_dn(:), no_phi_dn(:)
    integer, pointer :: no_z_dv(:), no_phi_dv(:)

    real(rp), pointer :: z_basis_dw(:), phi_basis_dw(:)
    real(rp), pointer :: z_basis_dn(:), phi_basis_dn(:)
    real(rp), pointer :: z_basis_dv(:), phi_basis_dv(:)
d61 2
a62 2
    integer :: i,j,k,l,m,n,kk,kz,ht_i,Spectag
    integer :: n_sps
d110 1
a110 2
    !*** if (.not. associated(Spect_der) ) return
    return
d124 1
a124 2
          !*** if(Spect_Der(m)%Spectag == Spectag) exit
          exit
d127 4
a130 6
        !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
        cycle
        !*** if(Spect_Der(m)%type /= 'W') cycle
        cycle
        no_z_dw(i) = 0 ! Spect_Der(m)%no_zeta_values
        no_phi_dw(i) = 0 ! Spect_Der(m)%no_phi_values
d148 1
a148 2
            !*** if(Spect_Der(m)%Spectag == Spectag) exit
            exit
d151 2
a152 3
          !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
          !*** if(Spect_Der(m)%type /= 'W') cycle
          cycle
d158 2
a159 2
            !z_basis_dw(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            !phi_basis_dw(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
d180 1
a180 2
          !*** if(Spect_Der(m)%Spectag == Spectag) exit
          exit
d183 4
a186 5
        !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
        !*** if(Spect_Der(m)%type /= 'N') cycle
        cycle
        no_z_dn(i) = 0 ! Spect_Der(m)%no_zeta_values
        no_phi_dn(i) = 0 ! Spect_Der(m)%no_phi_values
d204 1
a204 2
            !*** if(Spect_Der(m)%Spectag == Spectag) exit
            exit
d207 2
a208 3
          !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
          !*** if(Spect_Der(m)%type /= 'N') cycle
          cycle
d214 2
a215 2
            !*** z_basis_dn(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            !*** phi_basis_dn(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
d236 1
a236 1
          !*** if(Spect_Der(m)%Spectag == Spectag) exit
a237 1
          exit
d239 4
a242 5
        !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
        !*** if(Spect_Der(m)%type /= 'V') cycle
        cycle
        no_z_dv(i) = 0 ! Spect_Der(m)%no_zeta_values
        no_phi_dv(i) = 0 ! Spect_Der(m)%no_phi_values
d248 1
a248 2
        call Deallocate_test ( no_z_dv, 'no_z_dv', ModuleName)
        call Deallocate_test ( no_phi_dv, 'no_phi_dv', ModuleName)
d252 1
a252 2
        call Allocate_test ( z_basis_dv, n_sv_zeta_dv, 'z_basis_dv', ModuleName )
        call Allocate_test ( phi_basis_dv, n_sv_phi_dv, 'phi_basis_dv', ModuleName )
d258 1
a258 2
            !*** if(Spect_Der(m)%Spectag == Spectag) exit
            exit
d261 2
a262 3
          !*** if(Spect_Der(m)%Spectag /= Spectag) cycle
          !*** if(Spect_Der(m)%type /= 'V') cycle
          cycle
d268 2
a269 2
            !z_basis_dv(l:n-1)=Spect_Der(m)%zeta_basis(1:ht_i)
            !phi_basis_dv(j:k-1)=Spect_Der(m)%phi_basis(1:kz)
a298 3
! Revision 1.1.2.3  2001/09/07 20:41:42  livesey
! Messing around.
!
@


1.1.2.5
log
@Developing code..
@
text
@d3 1
a3 1
 
d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.4 2001/09/08 18:30:49 zvi Exp $"
d19 1
a19 1
 
d21 1
a21 1
 
d29 1
a29 1
 
d32 1
a32 1
 
d34 1
a34 1
 
d39 1
a39 1
 
d41 1
a41 1
 
d43 1
a43 1
 
d45 1
a45 1
 
d48 1
a48 1
 
d52 1
a52 1
 
d56 1
a56 1
 
d60 1
a60 1
 
d62 4
a65 6
 
    Character(len=1) :: CA
    integer :: i,j,k,l,m,n,kz,kp,Spectag,n_sps,accum_z_dw,accum_p_dw, &
           &   accum_z_dn,accum_p_dn,accum_z_dv,accum_p_dv,j_dw,l_dw,&
           &   j_dn,l_dn,j_dv,l_dv
 
d114 1
a114 1
!
d116 2
d120 54
a173 2
      no_z_dw = 0
      no_phi_dw = 0
d177 2
d181 53
a233 2
      no_z_dn = 0
      no_phi_dn = 0
d237 2
d241 18
a258 19
      no_z_dv = 0
      no_phi_dv = 0
    endif
!
    accum_z_dw = 0
    accum_p_dw = 0
    accum_z_dn = 0
    accum_p_dn = 0
    accum_z_dv = 0
    accum_p_dv = 0
!
    do i = 1, n_sps
      m = 0
      Spectag = spec_tags(molecules(i))
      do
        m = m + 1
        !  *** if(Spect_Der(m)%Spectag == Spectag) exit
        exit
        if(m == 3*n_sps) exit
d260 34
a293 51
      !  *** if(Spect_Der(m)%Spectag /= Spectag) cycle
      CA = ! *** Spect_Der(m)%type
      kz = 0 ! Spect_Der(m)%no_zeta_values
      kp = 0 ! Spect_Der(m)%no_phi_values
      select case ( CA )
        case ( 'W' )
          no_z_dw(i) = kz
          no_phi_dw(i) = kp
          accum_z_dw = accum_z_dw + kz
          accum_p_dw = accum_p_dw + kp
        case ( 'N' )
          no_z_dn(i) = kz
          no_phi_dn(i) = kp
          accum_z_dn = accum_z_dn + kz
          accum_p_dn = accum_p_dn + kp
        case ( 'V' )
          no_z_dv(i) = kz
          no_phi_dv(i) = kp
          accum_z_dv = accum_z_dv + kz
          accum_p_dv = accum_p_dv + kp
      end select
    end do
!
    if(accum_z_dw * accum_p_dw < 1) then
      call Deallocate_test ( no_z_dw, 'no_z_dw', ModuleName )
      call Deallocate_test ( no_phi_dw, 'no_phi_dw' ,ModuleName )
    else
      n_sv_phi_dw = accum_p_dw
      n_sv_zeta_dw = accum_z_dw
      call Allocate_test(z_basis_dw,n_sv_zeta_dw,'z_basis_dw',ModuleName)
      call Allocate_test(phi_basis_dw,n_sv_phi_dw,'phi_basis_dw',ModuleName)
    endif
!
    if(accum_z_dn * accum_p_dn < 1) then
      call Deallocate_test ( no_z_dn, 'no_z_dn', ModuleName )
      call Deallocate_test ( no_phi_dn, 'no_phi_dn' ,ModuleName )
    else
      n_sv_phi_dn = accum_p_dn
      n_sv_zeta_dn = accum_z_dn
      call Allocate_test(z_basis_dn,n_sv_zeta_dn,'z_basis_dn',ModuleName)
      call Allocate_test(phi_basis_dn,n_sv_phi_dn,'phi_basis_dn',ModuleName)
    endif
!
    if(accum_z_dv * accum_p_dv < 1) then
      call Deallocate_test ( no_z_dv, 'no_z_dv', ModuleName )
      call Deallocate_test ( no_phi_dv, 'no_phi_dv' ,ModuleName )
    else
      n_sv_phi_dv = accum_p_dv
      n_sv_zeta_dv = accum_z_dv
      call Allocate_test(z_basis_dv,n_sv_zeta_dv,'z_basis_dv',ModuleName)
      call Allocate_test(phi_basis_dv,n_sv_phi_dv,'phi_basis_dv',ModuleName)
a295 55
    j_dw = 1
    l_dw = 1
    j_dn = 1
    l_dn = 1
    j_dv = 1
    l_dv = 1
!
    do i = 1, n_sps
      m = 0
      Spectag = spec_tags(molecules(i))
      do
        m = m + 1
        !  *** if(Spect_Der(m)%Spectag == Spectag) exit
        exit
        if(m == 3*n_sps) exit
      end do
      !  *** if(Spect_Der(m)%Spectag /= Spectag) cycle
      CA = ! *** Spect_Der(m)%type
      select case ( CA )
        case ( 'W' )
          kz = no_z_dw(i)
          kp = no_phi_dw(i)
          if(kp*kz > 0) then
            k = j_dw + kp
            n = l_dw + kz
            !** z_basis_dw(l_dw:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dw(j_dw:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
            j_dw = k
            l_dw = n
          endif
        case ( 'N' )
          no_z_dn(i) = kz
          no_phi_dn(i) = kp
          if(kp*kz > 0) then
            k = j_dn + kp
            n = l_dn + kz
            !** z_basis_dn(l_dn:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dn(j_dn:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
            j_dn = k
            l_dn = n
          endif
        case ( 'V' )
          no_z_dv(i) = kz
          no_phi_dv(i) = kp
          if(kp*kz > 0) then
            k = j_dv + kp
            n = l_dv + kz
            !** z_basis_dv(l_dv:n-1)=Spect_Der(m)%zeta_basis(1:kz)
            !** phi_basis_dv(j_dv:k-1)=Spect_Der(m)%phi_basis(1:kp)*Deg2Rad
            j_dv = k
            l_dv = n
          endif
      end select
    end do
!
d297 1
a297 1
 
d300 1
a300 1
 
d302 1
a302 1
 
d305 1
a305 1
 
d311 3
a313 3
 
 
 
a316 3
! Revision 1.1.2.4  2001/09/08 18:30:49  zvi
! Working on developement version
!
d327 3
@


1.1.2.6
log
@Fixing a bug..
@
text
@d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.5 2001/09/08 20:19:48 zvi Exp $"
d238 2
a239 2
          kz = no_z_dn(i)
          kp = no_phi_dn(i)
d249 2
a250 2
          kz = no_z_dv(i)
          kp = no_phi_dv(i)
a282 3
! Revision 1.1.2.5  2001/09/08 20:19:48  zvi
! Developing code..
!
@


1.1.2.7
log
@Eliminatin molecule coeff. stuff
@
text
@d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.6 2001/09/08 20:22:00 zvi Exp $"
d23 1
a23 1
    &   sv_len,n_sv_phi,n_sv_zeta,h2o_ind,       &
d33 6
a38 4
    integer, intent(out) :: sv_len
    integer, intent(out) :: h2o_ind
    integer, intent(out) :: n_sv_phi
    integer, intent(out) :: n_sv_zeta
d71 4
a74 1

d76 1
a79 14

    h2o_ind = 0
    do i = 1 , n_sps
      f => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType=l_vmr, molecule=molecules(i) )
      no_phi(i) = f%template%noInstances
      no_z(i) = f%template%noSurfs
      if(spec_tags(molecules(i)) == 18003) h2o_ind = i
    end do
!
    sv_len = sum(no_z * no_phi)
    n_sv_phi = sum(no_phi)
    n_sv_zeta = sum(no_z)
    call Allocate_test ( sps_values, sv_len, 'sps_values', ModuleName )
d86 1
d90 3
a282 3
! Revision 1.1.2.6  2001/09/08 20:22:00  zvi
! Fixing a bug..
!
@


1.1.2.8
log
@Bug fixed..
@
text
@d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.7 2001/09/08 22:37:11 zvi Exp $"
d159 1
a159 1
      CA = '@@' ! *** Spect_Der(m)%type
d228 1
a228 1
      CA = '@@' ! *** Spect_Der(m)%type
a286 3
! Revision 1.1.2.7  2001/09/08 22:37:11  zvi
! Eliminatin molecule coeff. stuff
!
@


1.1.2.9
log
@Bug fixed..
@
text
@d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.8 2001/09/08 22:43:37 zvi Exp $"
d23 1
a23 1
    &   f_len,n_f_phi,n_f_zeta,h2o_ind,       &
d25 2
a26 2
    &   n_dw_phi,n_dw_zeta,n_dn_phi,n_dn_zeta,        &
    &   n_dv_phi,n_dv_zeta,no_z_dw,no_phi_dw,no_z_dn,no_phi_dn, &
d33 1
a33 1
    integer, intent(out) :: f_len
d35 2
a36 2
    integer, intent(out) :: n_f_phi
    integer, intent(out) :: n_f_zeta
d44 1
a44 3
    character(LEN=3), parameter :: WNV='+++'

!   character(LEN=*), optional, intent(in) :: WNV
d47 3
a49 3
    integer, intent(out) :: n_dw_phi, n_dw_zeta
    integer, intent(out) :: n_dn_phi, n_dn_zeta
    integer, intent(out) :: n_dv_phi, n_dv_zeta
d84 6
a89 6
    f_len = sum(no_z * no_phi)
    n_f_phi = sum(no_phi)
    n_f_zeta = sum(no_z)
    call Allocate_test ( sps_values, f_len, 'sps_values', ModuleName )
    call Allocate_test ( z_basis, n_f_zeta, 'z_basis', ModuleName )
    call Allocate_test ( phi_basis, n_f_phi, 'phi_basis', ModuleName )
d93 1
a93 1
    f_len = 1
d99 1
a99 1
      m = f_len + no_z(i) * no_phi(i)
d102 1
a102 1
      sps_values(f_len:m-1) = reshape(f%values(1:no_z(i),1:no_phi(i)), &
d106 1
a106 1
        sps_values(f_len:m-1) = log(sps_values(f_len:m-1))
d112 1
a112 1
      f_len = m
d114 1
a114 1
    f_len = f_len - 1
d185 4
a188 4
      n_dw_phi = accum_p_dw
      n_dw_zeta = accum_z_dw
      call Allocate_test(z_basis_dw,n_dw_zeta,'z_basis_dw',ModuleName)
      call Allocate_test(phi_basis_dw,n_dw_phi,'phi_basis_dw',ModuleName)
d195 4
a198 4
      n_dn_phi = accum_p_dn
      n_dn_zeta = accum_z_dn
      call Allocate_test(z_basis_dn,n_dn_zeta,'z_basis_dn',ModuleName)
      call Allocate_test(phi_basis_dn,n_dn_phi,'phi_basis_dn',ModuleName)
d205 4
a208 4
      n_dv_phi = accum_p_dv
      n_dv_zeta = accum_z_dv
      call Allocate_test(z_basis_dv,n_dv_zeta,'z_basis_dv',ModuleName)
      call Allocate_test(phi_basis_dv,n_dv_phi,'phi_basis_dv',ModuleName)
a286 3
! Revision 1.1.2.8  2001/09/08 22:43:37  zvi
! Bug fixed..
!
@


1.1.2.10
log
@Added CVS stuff
@
text
@d3 1
a3 1

a11 3

  Private
  Public :: load_sps_data
d14 1
a14 1
 "$Id: load_sps_data_m.f90,v 1.1.2.9 2001/09/08 23:11:41 zvi Exp $"
d19 1
d21 1
a21 1

d29 1
a29 1

d32 1
a32 1

d37 1
a37 1

d39 1
a39 1

d41 1
a41 1

d43 1
a43 1

d48 1
a48 1

d52 1
a52 1

d56 1
a56 1

d60 1
a60 1

d62 1
a62 1

d67 1
a67 1

d269 18
a286 1

a288 3
! Revision 1.1.2.9  2001/09/08 23:11:41  zvi
! Bug fixed..
!
@


