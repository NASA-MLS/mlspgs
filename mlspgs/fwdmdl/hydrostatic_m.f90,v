head	2.33;
access;
symbols
	v5-02-NRT-19:2.33
	v6-00:2.33
	v5-02-NRT-18:2.33
	v5-02:2.33
	v5-01-NRT-17:2.33
	v5-01-NRT-16:2.33
	v5-01-NRT-15:2.33
	v5-01-NRT-14:2.33
	neuralnetworks-1-0:2.33.0.6
	cfm-single-freq-0-1:2.33.0.4
	v5-01:2.33
	v5-00:2.33
	v4-23-TA133:2.33.0.2
	mus-emls-1-70:2.32.0.2
	rel-1-0-englocks-work:2.31.0.2
	VUMLS1-00:2.30
	VPL1-00:2.26
	V4-22-NRT-08:2.26
	VAM1-00:2.25
	V4-21:2.24.0.2
	V4-13:2.24
	V4-12:2.23
	V4-11:2.23
	V4-10:2.23
	V3-43:2.21
	M4-00:2.21
	V3-41:2.21
	V3-40-PlusGM57:2.21.0.2
	V2-24-NRT-04:2.20
	V3-33:2.21
	V2-24:2.20
	V3-31:2.21
	V3-30-NRT-05:2.21
	cfm-01-00:2.21
	V3-30:2.21
	V3-20:2.21
	V3-10:2.21
	V2-23-NRT-02:2.20
	V2-23:2.20
	V2-22-NRT-01:2.20
	V2-22:2.20
	V2-21:2.18
	V2-20:2.18
	V2-11:2.18
	V2-10:2.18
	V2-00:2.18
	V1-51:2.13
	V1-50:2.13
	V1-45:2.13
	V1-44:2.13
	V1-43:2.13
	V1-32:2.12
	V1-31:2.12
	V1-30:2.9
	V1-13:2.9
	V1-12:2.9
	V1-11:2.9
	V1-10:2.6
	newfwm-feb03:2.9.0.2
	V1-04:2.1
	V1-03:2.1
	V1-02:2.1
	JointForwardModel:2.2.0.2
	V1-00:2.1
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.33
date	2018.08.21.01.52.44;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2018.05.14.23.36.36;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2017.08.28.20.28.08;	author livesey;	state Exp;
branches;
next	2.30;

2.30
date	2017.01.14.02.57.11;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2016.12.02.02.04.50;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2016.11.29.00.29.18;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2016.11.23.20.10.59;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2016.04.28.18.04.12;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2015.04.11.00.45.03;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2014.09.05.21.12.31;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2013.06.12.02.26.27;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2013.05.02.19.45.33;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.20;

2.20
date	2007.01.17.23.50.15;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2006.11.30.23.28.29;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2005.12.29.01.12.47;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2005.12.22.20.57.10;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2005.12.10.01.53.10;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2005.12.07.00.32.21;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.13;

2.13
date	2004.03.20.04.06.13;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2003.09.16.18.43.47;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2003.09.16.18.31.02;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2003.09.16.00.21.32;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2003.02.12.20.52.38;	author bill;	state Exp;
branches;
next	2.8;

2.8
date	2003.02.10.23.41.27;	author bill;	state Exp;
branches;
next	2.7;

2.7
date	2003.02.08.00.59.16;	author bill;	state Exp;
branches;
next	2.6;

2.6
date	2003.02.07.00.04.54;	author bill;	state Exp;
branches;
next	2.5;

2.5
date	2002.10.08.17.08.04;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2002.09.27.01.48.36;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2002.09.25.22.52.54;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2002.06.25.17.01.08;	author bill;	state Exp;
branches;
next	2.1;

2.1
date	2002.02.02.11.20.08;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.10.09.39;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.10.10.09.39;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.12.21.38.50;	author zvi;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.13.22.51.22;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.33
log
@Convert to sparse interpolators
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Hydrostatic_m

  implicit none

  private
  public :: Hydrostatic

  interface Hydrostatic
    module procedure Hydrostatic_All, Hydrostatic_All_ZZ, Hydrostatic_No_Der
  end interface

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: hydrostatic_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
  contains
!---------------------------------------------------------------------------

  ! --------------------------------------------  Hydrostatic_All  -----
  subroutine Hydrostatic_All ( lat, t_basis, t_coeffs, z_grid, z_ref, h_ref, &
                      &    t_grid, h_grid, dhidzi, dhidtq, ddhdhdtq, z_surface )

! Compute a hydrostatic function per L2PC method and return
! geometric heights. Reference height is now an input

    use MLSKinds, only: RP, IP
    use Geometry, only: EarthRadA, EarthRadB, GM, J2, J4, W
    use Piq_Int_m, only: Piq_Int
    use Physics, only: BoltzMeters => Boltz ! Avogadro * k * ln10 / mmm m^2/(K s^2)
    use Sparse_eta_m, only: Sparse_Eta_t
    use Toggles, only: Emit, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

! Inputs

    real(rp), intent(in) :: lat         ! geocentric latitude in radians
    real(rp), intent(in) :: t_basis(:)  ! vertical temperature basis, zeta
    real(rp), intent(in) :: t_coeffs(:) ! temperature values
    real(rp), intent(in) :: z_grid(:)   ! zeta = -log10(P) pressures for which
!                                         heights are needed
    real(rp), intent(in) :: z_ref       ! reference pressure in zeta = -log10(P)
    real(rp), intent(in) :: h_ref       ! reference geopotential height in km

! Outputs

    real(rp), intent(out) :: t_grid(:)  ! temperatures on z_grid
    real(rp), intent(out) :: h_grid(:)  ! heights on z_grid (km)
    real(rp), intent(out) :: dhidzi(:)  ! dh/dz on z_grid

    real(rp), optional, intent(out) :: dhidtq(:,:) ! dh/dt on z_grid assuming
      ! dh/dt = 0.0 at the reference ellipse surface  equivalent to h_ref = 0.0
    real(rp), optional, intent(out) :: ddhdhdtq(:,:) ! ddh/dhdt on z_grid,
      ! needs dhidtq
    real(rp), optional, intent(out) :: z_surface

! Internal stuff

    real(rp), parameter :: ERadAsq = EarthRadA**2, ERadBsq = EarthRadB**2
    ! Boltzmann constant in kilometers:
    real(rp), parameter :: Boltz = boltzMeters/1.0e6_rp ! = kln10/m km^2/(K sec^2)

    integer :: Me = -1          ! String index for trace
    integer(ip) :: n_coeffs,iter

!   real(rp) :: cl, sl ! for derivatives of Legendre polynomials dp2 and dp4
    real(rp) :: Clsq, G_ref, GHB
    real(rp) :: R_e, R_eisq, R_eff, Slsq, Z_surf
    real(rp) :: P2, P4    ! Legendre polynomials, for oblateness model
!   real(rp) :: dp2, dp4  ! Derivatives of P2 and P4
    real(rp) :: dh_dz_S, H_calc, Z_old
    real(rp), dimension(size(h_grid),size(t_basis)) :: Piq
    real(rp), dimension(1,size(t_coeffs)) :: Piqa, Piqb
    real(rp), dimension(size(z_grid)) :: Mass_corr
    type(sparse_eta_t) :: Eta

! begin the code

    call trace_begin ( me, 'Hydrostatic_All', &
      & cond=toggle(emit) .and. levels(emit) > 2 )

    n_coeffs = size(t_basis)

    where ( z_grid > 2.5_rp )
!     mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)

!{ A series expansion about z\_grid = 5/2 of
!  $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
!  $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
!  first two terms.
      mass_corr = 1.0_rp + 0.02_rp*(z_grid - 2.5_rp)**2
    elsewhere
      mass_corr = 1.0_rp
    end where

! compute Eta (interpolation coefficients) from T_Basis to Z_Grid, and
! use them to compute t_grid
    call eta%eta_1d ( t_basis, z_grid, create=.true., sorted=.false. )
    call eta%sparse_dot_vec ( t_coeffs, t_grid )

!{ Compute surface acceleration and effective earth radius.  First,
!  evaluate the Legendre polynomials $P_2(\sin\lambda) = \frac32 \sin^2\lambda
!  - \frac12$ and $P_4(\sin\lambda) = \frac{35}8 \sin^4\lambda
!  - \frac{15}4 \sin^2\lambda + \frac38$.

    slsq = sin(lat) ** 2
    clsq = 1.0_rp - slsq
    p2 = (3.0_rp * slsq - 1.0_rp) * 0.5_rp
    p4 = (35.0_rp * slsq**2 - 30.0_rp * slsq + 3.0_rp) * 0.125_rp
!   dp2 = 3.0_rp * sl * cl
!   dp4 = 2.5_rp * sl * cl * ( 7.0_rp * slsq - 3.0_rp )

!{ Compute radius at geoid having potential = $W_0$ (see Geometry module):
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \lambda + b^2 \cos^2 \lambda}$ in meters.
!  First compute $r_e^{-2}$ in $m^{-2}$.  The parenthesization used here
!  avoids potential overflow; $a^2 b^2 \approx 1.64 \times 10^{27}$, but
!  the inner factor is $\approx 1$ and $a^2 \approx 4 \times 10^{13}$.

    r_eisq = ( (eRadAsq*slsq + eRadBsq*clsq) / eRadBsq ) / eRadAsq ! (r_e)^{-2}

    r_e = sqrt(1.0_rp / r_eisq) ! in meters

!{ Radial surface acceleration at latitude $\lambda$, k$m/s^2$:
!  \begin{equation*}
!   g_{\text{ref}} = 0.001 \left ( G m
!                     \frac{1 - 3 J_2 P_2(\sin \lambda)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \lambda) (a/r_e)^4 }{r_e^2}
!                       - \omega^2 \cos^2 \lambda \, r_e \right )
!  \end{equation*}

    g_ref = 0.001_rp * (gm * (1.0_rp - 3.0_rp*j2*p2*eRadAsq*r_eisq &
        & - 5.0_rp*j4*p4*(eRadAsq*r_eisq)**2)*r_eisq - w**2 * clsq * r_e)

!{ Better effective Earth radius:
!  compute $-2\, g_{\text{ref}} / ( d g_{\text{ref}} / d r)$, kilometers:
!  \begin{equation*}
!   r_{\text{eff}} =
!    \frac{2\, g_{\text{ref}}}
!         { 2\, G m \frac{1 - 6 J_2 P_2 (\sin \lambda) (a/r_e)^2
!                         - 15 J_4 P_4 (\sin \lambda) (a/r_e)^4}{r_e^3}
!                          + \omega^2 \cos^2 \lambda }
!  \end{equation*}
!  $d g_{\text{ref}} / d r$ has units $s^{-2}$, because we compute
!  $d g_{\text{ref}}(\text{meters}) / d r$(meters), thereby canceling
!  the factor of 0.001 you might have been expecting in the denominator.
!  The entire expression has units (k$ms^{-2})/s^{-2} = $ k$m$.

    r_eff = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
        & * eRadAsq*r_eisq - 15.0_rp*j4*p4*(eRadAsq*r_eisq)**2) &
        & / r_e**3 + w**2 * clsq)

! find the surface pressure

    ghb = g_ref * h_ref / boltz
    z_old = z_grid(1) ! This is a guess

    iter = 0
    do
!{ Newton iteration for $z_{\text{surf}}$ at $h_{\text{calc}} = -h_{\text{ref}}$:
!  $z_{n+1} = z_n - (h_{\text{ref}} + h_{\text{calc}}) /
!             \left . \frac{\text{d} h}{\text{d} z} \right |_{z=z_n}$

      call piq_int ( (/z_old/), t_basis, z_ref, piqa )
      h_calc = dot_product(piqa(1,:), t_coeffs)

      call piq_int ( (/z_old+0.01_rp/), t_basis, z_ref, piqa )
      call piq_int ( (/z_old-0.01_rp/), t_basis, z_ref, piqb )
      dh_dz_s = dot_product((piqa(1,:) - piqb(1,:)), t_coeffs) * 50.0_rp
      z_surf = z_old - (ghb + h_calc) / dh_dz_s

      iter = iter + 1
      if ( abs(z_surf - z_old) < 0.0001_rp .or. iter == 10 ) exit
      z_old = z_surf

    end do

    if (present(z_surface)) z_surface = z_surf

!{ Compute the {\tt piq} integrals with mass reduction compensation relative to the
!  surface.  Here, {\tt piq} = $P_l(\zeta) = P(\zeta_l,\phi_m)$.

    call piq_int ( z_grid, t_basis, z_surf, piq, Z_MASS=2.5_rp, C_MASS=0.02_rp )

! compute the height vector

! geopotential height * g_ref

!{ Equation (5.27) in the 19 August 2004 ATBD is
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{g_0 \stackrel{\star}{R_0^2}}
!         {g_0 \stackrel{\star}{R_0} - k\, \ln 10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!           ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!    -\stackrel{\star}{R_0} + R_0 - R^\oplus
!  \end{equation*}
!  The last two terms, i.e., $R_0-R^\oplus$, are handled in {\tt metrics}.
!  Putting what remains over a common denominator, we have
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{\stackrel{\star}{R_0} k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!         {g_0 \stackrel{\star}{R_0} - k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!  \end{equation*}
!  Notice that $g_0$ here is not the average or equatorial surface
!  acceleration.  Rather, it is $g_\text{ref}$, which is corrected for
!  latitude, the Earth's figure (up to fourth order zonal harmonics), and
!  centripetal acceleration.
    h_grid = boltz * matmul(piq,t_coeffs)
    h_grid = r_eff * h_grid / (r_eff * g_ref - h_grid)

!{ \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\text{d}h(\zeta,\phi)}{\text{d}\zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!   \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} f^T_{lm} \eta^T_m(\phi)
!    \frac{\partial P_l(\zeta)}{\partial \zeta}\,.
!  \end{equation*}
!
!  Because
!  \begin{equation*}
!  P_l(\zeta) = \int_{\zeta_0}^\zeta \frac{\eta^T_l(z)}{\mathcal{M}(z)}
!                 \text{d}z\,\text{, then }
!  \frac{\partial P_l(\zeta)}{\partial \zeta} =
!  \frac{\eta^T_l(\zeta)}{\mathcal{M}(\zeta)}\, \text{. Therefore,}
!  \end{equation*}
!  \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\partial h(\zeta,\phi)}{\partial \zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!  \frac1{\mathcal{M}(\zeta)} \left(
!   \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} f^T_{lm} \eta^T_m(\phi)
!    \eta^T_l(\zeta) \right)\,.
!  \end{equation*}
!  The factor in parentheses is simply $T(\zeta,\phi)$.  Therefore,
!  \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\partial h(\zeta,\phi)}{\partial \zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!  \frac{T(\zeta,\phi)}{\mathcal{M}(\zeta)}\,.
!  \end{equation*}
!  The variable {\tt Boltz} is $k \ln 10$.  Therefore
!  \begin{equation*}
!  \frac{\partial h(\zeta,\phi)}{\partial \zeta} = \left(
!  h(\zeta,\phi)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \right) \,\frac{T(\zeta,\phi)}{\mathcal{M}(\zeta)}\,.
!  \end{equation*}
!  At first, {\tt dhidzi} is only the factor in parentheses, which is
!  used to compute {\tt dhidtq}.

    dhidzi = (h_grid+r_eff)**2 * boltz / (g_ref * r_eff**2)

    if ( present(dhidtq) ) then

!{ \begin{equation*}
!  \frac{\partial h(\zeta,\phi)}{\partial f^T_{lm}} =
!  h(\zeta,\phi)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} P_l(\zeta) \eta^T_m(\phi)
!  \end{equation*}

      dhidtq = spread(dhidzi,2,n_coeffs) * piq
! this derivative is useful for antenna derivatives
      if ( present(ddhdhdtq) ) then
        ddhdhdtq = (2.0_rp/(spread(h_grid,2,n_coeffs)+r_eff)) * dhidtq
        block
          integer :: i, j, k
          do k = 1, eta%ne
            i = eta%e(k)%r
            j = eta%e(k)%c
            ddhdhdtq(i,j) = ddhdhdtq(i,j) + eta%e(k)%v / t_grid(i)
          end do
        end block
      end if
    end if

!{ \begin{equation*}
!  \frac{\partial h_{lm}}{\partial \zeta_{\,l}} =
!  h(\zeta_{\,l},\phi_m)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \frac{f^T_{lm}}{\mathcal{M}(\zeta_{\,l})}\,.
!  \end{equation*}

    dhidzi = dhidzi * t_grid * mass_corr

!{ If we ever need it:
!  \begin{equation*}\begin{split}
!  \frac{\partial^2 h_{lm}}{\partial \zeta_l \partial f^T_{lm}} = \,&
!  2 h(\zeta_{\,l},\phi_m) \frac{\partial h_{lm}}{\partial \zeta_{\,l}}
!  \text{\tt Boltz} \frac{T_{lm}}{\mathcal{M}(\zeta_{\,l})} +
!  h(\zeta_{\,l},\phi_m)^2\, \frac{\partial T(\zeta,\phi)}{\partial f^T_{lm}}
!  \text{\tt boltz}\,\frac1{\mathcal{M}(\zeta_{\,l})} \\
!  = \,&
!  2 h(\zeta_{\,l},\phi_m) \frac{\partial h_{lm}}{\partial \zeta_{\,l}}
!  \text{\tt Boltz} \frac{T_{lm}}{\mathcal{M}(\zeta_{\,l})} +
!  h(\zeta_{\,l},\phi_m)^2\, \text{\tt boltz}\,
!   \frac{\eta^T_{lm}}{\mathcal{M}(\zeta_{\,l})} \\
!  \end{split}\end{equation*}

    call trace_end ( 'Hydrostatic_All', &
      & cond=toggle(emit) .and. levels(emit) > 2 )

  end subroutine Hydrostatic_All

  ! -----------------------------------------  Hydrostatic_All_ZZ  -----
  subroutine Hydrostatic_All_ZZ ( Lat, T_Basis, T_Coeffs, Z_Grid, Z_Ref, H_Ref, &
    &              Eta_ZZ, T_Grid, H_Grid, dHidZi, dHidTq, ddHdHdTq, Z_Surface )

! Compute a hydrostatic function per L2PC method and return
! geometric heights. Reference height is now an input

    use Geometry, only: EarthRadA, EarthRadB, GM, J2, J4, W
    use MLSKinds, only: RP, IP
    use Physics, only: BoltzMeters => Boltz ! Avogadro * k * ln10 / mmm m^2/(K s^2)
    use Piq_int_m, only: piq_int
    use Sparse_m, only: Sparse_t
    use Toggles, only: Emit, Levels, Toggle
    use Trace_m, only: Trace_Begin, Trace_End

! Inputs

    real(rp), intent(in) :: Lat         ! geocentric latitude in radians
    real(rp), intent(in) :: T_Basis(:)  ! vertical temperature basis, zeta
    real(rp), intent(in) :: T_Coeffs(:) ! temperature values
    real(rp), intent(in) :: Z_Grid(:)   ! zeta = -log10(P) pressures for which
!                                         heights are needed
    real(rp), intent(in) :: Z_Ref       ! reference pressure in zeta = -log10(P)
    real(rp), intent(in) :: H_Ref       ! reference geopotential height in km
    class(sparse_t), intent(in) :: Eta_ZZ ! Interpolation coefficients
                                        ! from T_Basis to Z_Grid

! Outputs

    real(rp), intent(out) :: T_Grid(:)  ! temperatures on z_grid
    real(rp), intent(out) :: H_Grid(:)  ! heights on z_grid (km)
    real(rp), intent(out) :: dHidZi(:)  ! dh/dz on z_grid

    real(rp), optional, intent(out) :: dHidTq(:,:) ! dH/dT on z_grid assuming
      ! dH/dT = 0.0 at the reference ellipse surface equivalent to H_Ref = 0.0
    real(rp), optional, intent(out) :: ddHdHdTq(:,:) ! ddH/dHdT on Z_Grid,
      ! needs dHidTq
    real(rp), optional, intent(out) :: Z_Surface

! Internal stuff

    real(rp), parameter :: ERadAsq = EarthRadA**2, ERadBsq = EarthRadB**2
    ! Boltzmann constant in kilometers:
    real(rp), parameter :: Boltz = boltzMeters/1.0e6_rp ! = kln10/m km^2/(K sec^2)

    integer :: I, J, K
    integer :: Me = -1          ! String index for trace
    integer(ip) :: N_Coeffs, Iter

!   real(rp) :: cl, sl ! for derivatives of Legendre polynomials dp2 and dp4
    real(rp) :: Clsq, G_ref, GHB
    real(rp) :: R_e, R_eisq, R_eff, Slsq, Z_surf
    real(rp) :: P2, P4    ! Legendre polynomials, for oblateness model
!   real(rp) :: dp2, dp4  ! Derivatives of P2 and P4
    real(rp) :: dH_dz_S, H_calc, Z_old
    real(rp), dimension(size(h_grid),size(t_basis)) :: Piq
    real(rp), dimension(1,size(t_coeffs)) :: Piqa, Piqb
    real(rp), dimension(size(z_grid)) :: Mass_corr

! begin the code

    call trace_begin ( me, 'Hydrostatic_All_ZZ', &
      & cond=toggle(emit) .and. levels(emit) > 2 )

    n_coeffs = size(t_basis)

    where ( z_grid > 2.5_rp )
!     mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)

!{ A series expansion about z\_grid = 5/2 of
!  $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
!  $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
!  first two terms.
      mass_corr = 1.0_rp + 0.02_rp*(z_grid - 2.5_rp)**2
    elsewhere
      mass_corr = 1.0_rp
    end where

! compute t_grid using a sparse matrix-vector multiply
    call eta_zz%sparse_dot_vec ( t_coeffs, t_grid )

!{ Compute surface acceleration and effective earth radius.  First,
!  evaluate the Legendre polynomials $P_2(\sin\lambda) = \frac32 \sin^2\lambda
!  - \frac12$ and $P_4(\sin\lambda) = \frac{35}8 \sin^4\lambda
!  - \frac{15}4 \sin^2\lambda + \frac38$.

    slsq = sin(lat) ** 2
    clsq = 1.0_rp - slsq
    p2 = (3.0_rp * slsq - 1.0_rp) * 0.5_rp
    p4 = (35.0_rp * slsq**2 - 30.0_rp * slsq + 3.0_rp) * 0.125_rp
!   dp2 = 3.0_rp * sl * cl
!   dp4 = 2.5_rp * sl * cl * ( 7.0_rp * slsq - 3.0_rp )

!{ Compute radius at geoid having potential = $W_0$ (see Geometry module):
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \lambda + b^2 \cos^2 \lambda}$ in meters.
!  First compute $r_e^{-2}$ in $m^{-2}$.  The parenthesization used here
!  avoids potential overflow; $a^2 b^2 \approx 1.64 \times 10^{27}$, but
!  the inner factor is $\approx 1$ and $a^2 \approx 4 \times 10^{13}$.

    r_eisq = ( (eRadAsq*slsq + eRadBsq*clsq) / eRadBsq ) / eRadAsq ! (r_e)^{-2}

    r_e = sqrt(1.0_rp / r_eisq) ! in meters

!{ Radial surface acceleration at latitude $\lambda$, k$m/s^2$:
!  \begin{equation*}
!   g_{\text{ref}} = 0.001 \left ( G m
!                     \frac{1 - 3 J_2 P_2(\sin \lambda)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \lambda) (a/r_e)^4 }{r_e^2}
!                       - \omega^2 \cos^2 \lambda \, r_e \right )
!  \end{equation*}

    g_ref = 0.001_rp * (gm * (1.0_rp - 3.0_rp*j2*p2*eRadAsq*r_eisq &
        & - 5.0_rp*j4*p4*(eRadAsq*r_eisq)**2)*r_eisq - w**2 * clsq * r_e)

!{ Better effective Earth radius:
!  compute $-2\, g_{\text{ref}} / ( d g_{\text{ref}} / d r)$, kilometers:
!  \begin{equation*}
!   r_{\text{eff}} =
!    \frac{2\, g_{\text{ref}}}
!         { 2\, G m \frac{1 - 6 J_2 P_2 (\sin \lambda) (a/r_e)^2
!                         - 15 J_4 P_4 (\sin \lambda) (a/r_e)^4}{r_e^3}
!                          + \omega^2 \cos^2 \lambda }
!  \end{equation*}
!  $d g_{\text{ref}} / d r$ has units $s^{-2}$, because we compute
!  $d g_{\text{ref}}(\text{meters}) / d r$(meters), thereby canceling
!  the factor of 0.001 you might have been expecting in the denominator.
!  The entire expression has units (k$ms^{-2})/s^{-2} = $ k$m$.

    r_eff = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
        & * eRadAsq*r_eisq - 15.0_rp*j4*p4*(eRadAsq*r_eisq)**2) &
        & / r_e**3 + w**2 * clsq)

! find the surface pressure

    ghb = g_ref * h_ref / boltz
    z_old = z_grid(1) ! This is a guess

    iter = 0
    do
!{ Newton iteration for $z_{\text{surf}}$ at $h_{\text{calc}} = -h_{\text{ref}}$:
!  $z_{n+1} = z_n - (h_{\text{ref}} + h_{\text{calc}}) /
!             \left . \frac{\text{d} h}{\text{d} z} \right |_{z=z_n}$

      call piq_int ( (/z_old/), t_basis, z_ref, piqa )
      h_calc = dot_product(piqa(1,:), t_coeffs)

      call piq_int ( (/z_old+0.01_rp/), t_basis, z_ref, piqa )
      call piq_int ( (/z_old-0.01_rp/), t_basis, z_ref, piqb )
      dh_dz_s = dot_product((piqa(1,:) - piqb(1,:)), t_coeffs) * 50.0_rp
      z_surf = z_old - (ghb + h_calc) / dh_dz_s

      iter = iter + 1
      if ( abs(z_surf - z_old) < 0.0001_rp .or. iter == 10 ) exit
      z_old = z_surf

    end do

    if (present(z_surface)) z_surface = z_surf

!{ Compute the {\tt piq} integrals with mass reduction compensation relative to the
!  surface.  Here, {\tt piq} = $P_l(\zeta) = P(\zeta_l,\phi_m)$.

    call piq_int ( z_grid, t_basis, z_surf, piq, Z_MASS=2.5_rp, C_MASS=0.02_rp )

! compute the height vector

! geopotential height * g_ref

!{ Equation (5.27) in the 19 August 2004 ATBD is
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{g_0 \stackrel{\star}{R_0^2}}
!         {g_0 \stackrel{\star}{R_0} - k\, \ln 10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!           ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!    -\stackrel{\star}{R_0} + R_0 - R^\oplus
!  \end{equation*}
!  The last two terms, i.e., $R_0-R^\oplus$, are handled in {\tt metrics}.
!  Putting what remains over a common denominator, we have
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{\stackrel{\star}{R_0} k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!         {g_0 \stackrel{\star}{R_0} - k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!  \end{equation*}
!  Notice that $g_0$ here is not the average or equatorial surface
!  acceleration.  Rather, it is $g_\text{ref}$, which is corrected for
!  latitude, the Earth's figure (up to fourth order zonal harmonics), and
!  centripetal acceleration.
    h_grid = boltz * matmul(piq,t_coeffs)
    h_grid = r_eff * h_grid / (r_eff * g_ref - h_grid)

!{ \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\text{d}h(\zeta,\phi)}{\text{d}\zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!   \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} f^T_{lm} \eta^T_m(\phi)
!    \frac{\partial P_l(\zeta)}{\partial \zeta}\,.
!  \end{equation*}
!
!  Because
!  \begin{equation*}
!  P_l(\zeta) = \int_{\zeta_0}^\zeta \frac{\eta^T_l(z)}{\mathcal{M}(z)}
!                 \text{d}z\,\text{, then }
!  \frac{\partial P_l(\zeta)}{\partial \zeta} =
!  \frac{\eta^T_l(\zeta)}{\mathcal{M}(\zeta)}\, \text{. Therefore,}
!  \end{equation*}
!  \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\partial h(\zeta,\phi)}{\partial \zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!  \frac1{\mathcal{M}(\zeta)} \left(
!   \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} f^T_{lm} \eta^T_m(\phi)
!    \eta^T_l(\zeta) \right)\,.
!  \end{equation*}
!  The factor in parentheses is simply $T(\zeta,\phi)$.  Therefore,
!  \begin{equation*}
!  \frac1{h(\zeta,\phi)^2} \frac{\partial h(\zeta,\phi)}{\partial \zeta} =
!  \frac{k \ln 10}{g_0 \stackrel{\star}{R_0^2}}
!  \frac{T(\zeta,\phi)}{\mathcal{M}(\zeta)}\,.
!  \end{equation*}
!  The variable {\tt Boltz} is $k \ln 10$.  Therefore
!  \begin{equation*}
!  \frac{\partial h(\zeta,\phi)}{\partial \zeta} = \left(
!  h(\zeta,\phi)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \right) \,\frac{T(\zeta,\phi)}{\mathcal{M}(\zeta)}\,.
!  \end{equation*}
!  At first, {\tt dhidzi} is only the factor in parentheses, which is
!  used to compute {\tt dhidtq}.

    dhidzi = (h_grid+r_eff)**2 * boltz / (g_ref * r_eff**2)

    if ( present(dhidtq) ) then

!{ \begin{equation*}
!  \frac{\partial h(\zeta,\phi)}{\partial f^T_{lm}} =
!  h(\zeta,\phi)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T} P_l(\zeta) \eta^T_m(\phi)
!  \end{equation*}

      dhidtq = spread(dhidzi,2,n_coeffs) * piq
! this derivative is useful for antenna derivatives
      if ( present(ddhdhdtq) ) then
        ddHdHdTq = (2.0_rp/(spread(h_grid,2,n_coeffs)+r_eff)) * dhidtq
        do k = 1, eta_zz%ne ! All the nonzero elements
            i = eta_zz%e(k)%r
            j = eta_zz%e(k)%c
            ddHdHdTq(i,j) = ddHdHdTq(i,j) + eta_zz%e(k)%v / t_grid(i)
        end do
      end if
    end if

!{ \begin{equation*}
!  \frac{\partial h_{lm}}{\partial \zeta_{\,l}} =
!  h(\zeta_{\,l},\phi_m)^2\, \frac{\text{\tt Boltz}}{g_0 \stackrel{\star}{R_0^2}}
!  \frac{f^T_{lm}}{\mathcal{M}(\zeta_{\,l})}\,.
!  \end{equation*}

    dhidzi = dhidzi * t_grid * mass_corr

!{ If we ever need it:
!  \begin{equation*}\begin{split}
!  \frac{\partial^2 h_{lm}}{\partial \zeta_l \partial f^T_{lm}} = \,&
!  2 h(\zeta_{\,l},\phi_m) \frac{\partial h_{lm}}{\partial \zeta_{\,l}}
!  \text{\tt Boltz} \frac{T_{lm}}{\mathcal{M}(\zeta_{\,l})} +
!  h(\zeta_{\,l},\phi_m)^2\, \frac{\partial T(\zeta,\phi)}{\partial f^T_{lm}}
!  \text{\tt boltz}\,\frac1{\mathcal{M}(\zeta_{\,l})} \\
!  = \,&
!  2 h(\zeta_{\,l},\phi_m) \frac{\partial h_{lm}}{\partial \zeta_{\,l}}
!  \text{\tt Boltz} \frac{T_{lm}}{\mathcal{M}(\zeta_{\,l})} +
!  h(\zeta_{\,l},\phi_m)^2\, \text{\tt boltz}\,
!   \frac{\eta^T_{lm}}{\mathcal{M}(\zeta_{\,l})} \\
!  \end{split}\end{equation*}

    call trace_end ( 'Hydrostatic_All_ZZ', &
      & cond=toggle(emit) .and. levels(emit) > 2 )

  end subroutine Hydrostatic_All_ZZ

  ! -----------------------------------------  Hydrostatic_No_Der  -----
  subroutine Hydrostatic_No_Der ( lat, t_basis, t_coeffs, z_grid, z_ref, h_ref, &
                               &  h_grid )

! Compute a hydrostatic function per L2PC method and return
! geometric heights. Reference height is now an input

    use MLSCommon, only: RP, IP
    use Geometry, only: EarthRadA, EarthRadB, GM, J2, J4, W
    use Piq_int_m, only: piq_int
    use Physics, only: BoltzMeters => Boltz

! Inputs

    real(rp), intent(in) :: lat         ! geocentric latitude in radians
    real(rp), intent(in) :: t_basis(:)  ! vertical temperature basis, zeta
    real(rp), intent(in) :: t_coeffs(:) ! temperature values
    real(rp), intent(in) :: z_grid(:)   ! zeta = -log10(P) pressures for which
!                                         heights are needed
    real(rp), intent(in) :: z_ref       ! reference pressure in zeta = -log10(P)
    real(rp), intent(in) :: h_ref       ! reference geopotential height in km

! Outputs

    real(rp), intent(out) :: h_grid(:)  ! heights on z_grid (km)

! Internal stuff

    real(rp), parameter :: ERadAsq = EarthRadA**2, ERadBsq = EarthRadB**2
    ! Boltzmann constant in kilometers:
    real(rp), parameter :: Boltz = boltzMeters/1.0e6_rp ! = kln10/m km^2/(K sec^2)

    integer(ip) :: iter

!   real(rp) :: cl, sl ! for derivatives of Legendre polynomials dp2 and dp4
    real(rp) :: Clsq, G_ref, GHB
    real(rp) :: R_e, R_eisq, R_eff, Slsq, Z_surf
    real(rp) :: P2, P4    ! Legendre polynomials, for oblateness model
!   real(rp) :: dp2, dp4  ! Derivatives of P2 and P4
    real(rp) :: dh_dz_S, H_calc, Z_old
    real(rp), dimension(size(z_grid),size(t_basis)) :: Piq
    real(rp), dimension(1,size(t_basis)) :: Piqa, Piqb
!   real(rp), dimension(size(z_grid)) :: Mass_corr

! begin the code


!     where ( z_grid > 2.5_rp )
! !     mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)

!{ A series expansion about z\_grid = 5/2 of
!  $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
!  $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
!  first two terms.

!       mass_corr = 1.0_rp + 0.02_rp*(z_grid - 2.5_rp)**2
!     elsewhere
!       mass_corr = 1.0_rp
!     end where

!{ Compute surface acceleration and effective earth radius.  First,
!  evaluate the Legendre polynomials $P_2(\sin\lambda) = \frac32 \sin^2\lambda
!  - \frac12$ and $P_4(\sin\lambda) = \frac{35}8 \sin^4\lambda
!  - \frac{15}4 \sin^2\lambda + \frac38$.

    slsq = sin(lat) ** 2
    clsq = 1.0_rp - slsq
    p2 = (3.0_rp * slsq - 1.0_rp) * 0.5_rp
    p4 = (35.0_rp * slsq**2 - 30.0_rp * slsq + 3.0_rp) * 0.125_rp
!   dp2 = 3.0_rp * sl * cl
!   dp4 = 2.5_rp * sl * cl * ( 7.0_rp * slsq - 3.0_rp )

!{ Compute radius at geoid having potential = $W_0$ (see Geometry module):
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \lambda + b^2 \cos^2 \lambda}$ in meters.
!  First compute $r_e^{-2}$ in $m^{-2}$.  The parenthesization used here
!  avoids potential overflow; $a^2 b^2 \approx 1.64 \times 10^{27}$, but
!  the inner factor is $\approx 1$ and $a^2 \approx 4 \times 10^{13}$.

    r_eisq = ( (eRadAsq*slsq + eRadBsq*clsq) / eRadBsq ) / eRadAsq ! (r_e)^{-2}

    r_e = sqrt(1.0_rp / r_eisq) ! in meters

!{ Radial surface acceleration at latitude $\lambda$, k$m/s^2$:
!  \begin{equation*}
!   g_{\text{ref}} = 0.001 \left ( G m
!                     \frac{1 - 3 J_2 P_2(\sin \lambda)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \lambda) (a/r_e)^4 }{r_e^2}
!                       - \omega^2 \cos^2 \lambda \, r_e \right )
!  \end{equation*}

    g_ref = 0.001_rp * (gm * (1.0_rp - 3.0_rp*j2*p2*eRadAsq*r_eisq &
        & - 5.0_rp*j4*p4*(eRadAsq*r_eisq)**2)*r_eisq - w**2 * clsq * r_e)

!{ Better effective Earth radius:
!  compute $-2\, g_{\text{ref}} / ( d g_{\text{ref}} / d r)$, kilometers:
!  \begin{equation*}
!   r_{\text{eff}} =
!    \frac{2\, g_{\text{ref}}}
!         { 2\, G m \frac{1 - 6 J_2 P_2 (\sin \lambda) (a/r_e)^2
!                         - 15 J_4 P_4 (\sin \lambda) (a/r_e)^4}{r_e^3}
!                          + \omega^2 \cos^2 \lambda }
!  \end{equation*}
!  $d g_{\text{ref}} / d r$ has units $s^{-2}$, because we compute
!  $d g_{\text{ref}}(\text{meters}) / d r$(meters), thereby canceling
!  the factor of 0.001 you might have been expecting in the denominator.
!  The entire expression has units (k$ms^{-2})/s^{-2} = $ k$m$.

    r_eff = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
        & * eRadAsq*r_eisq - 15.0_rp*j4*p4*(eRadAsq*r_eisq)**2) &
        & / r_e**3 + w**2 * clsq)

! find the surface pressure

    ghb = g_ref * h_ref / boltz
    z_old = z_grid(1) ! This is a guess

    iter = 0
    do
!{ Newton iteration for $z_{\text{surf}}$ at $h_{\text{calc}} = -h_{\text{ref}}$:
!  $z_{n+1} = z_n - (h_{\text{ref}} + h_{\text{calc}}) /
!             \left . \frac{\text{d} h}{\text{d} z} \right |_{z=z_n}$

      call piq_int ( (/z_old/), t_basis, z_ref, piqa )
      h_calc = dot_product(piqa(1,:), t_coeffs)

      call piq_int ( (/z_old+0.01_rp/), t_basis, z_ref, piqa )
      call piq_int ( (/z_old-0.01_rp/), t_basis, z_ref, piqb )
      dh_dz_s = dot_product((piqa(1,:) - piqb(1,:)), t_coeffs) * 50.0_rp
      z_surf = z_old - (ghb + h_calc) / dh_dz_s

      iter = iter + 1
      if ( abs(z_surf - z_old) < 0.0001_rp .or. iter == 10 ) exit
      z_old = z_surf

    end do

!{ Compute the {\tt piq} integrals with mass reduction compensation relative to the
!  surface.  Here, {\tt piq} = $P_l(\zeta) = P(\zeta_l,\phi_m)$.

    call piq_int ( z_grid, t_basis, z_surf, piq, Z_MASS=2.5_rp, C_MASS=0.02_rp )

! compute the height vector

! geopotential height * g_ref


!{ Equation (5.27) in the 19 August 2004 ATBD is
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{g_0 \stackrel{\star}{R_0^2}}
!         {g_0 \stackrel{\star}{R_0} - k\, \ln 10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!           ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!    -\stackrel{\star}{R_0} + R_0 - R^\oplus
!  \end{equation*}
!  The last two terms, i.e., $R_0-R^\oplus$, are handled in {\tt metrics}.
!  Putting what remains over a common denominator, we have
!  \begin{equation*}
!   h(\zeta,\phi) =
!    \frac{\stackrel{\star}{R_0} k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!         {g_0 \stackrel{\star}{R_0} - k \, \ln10
!          \sum_{l=1}^{\text{NH}^T} \sum_{m=1}^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l(\zeta))}
!  \end{equation*}
!  Notice that $g_0$ here is not the average or equatorial surface
!  acceleration.  Rather, it is $g_\text{ref}$, which is corrected for
!  latitude, the Earth's figure (up to fourth order zonal harmonics), and
!  centripetal acceleration.
    h_grid = boltz * matmul(piq,t_coeffs)
    h_grid = r_eff * h_grid / (r_eff * g_ref - h_grid)

  end subroutine Hydrostatic_No_Der

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: hydrostatic_m.f90,v 2.32 2018/05/14 23:36:36 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Hydrostatic_m
!---------------------------------------------------
! $Log: hydrostatic_m.f90,v $
! Revision 2.32  2018/05/14 23:36:36  vsnyder
! Change to sparse eta representation
!
! Revision 2.31  2017/08/28 20:28:08  livesey
! Changed the n,nf,np,nz elements to j,jf,...
!
! Revision 2.30  2017/01/14 02:57:11  vsnyder
! Make Eta_ZZ polymorphic
!
! Revision 2.29  2016/12/02 02:04:50  vsnyder
! Use 'P' Eta list for Eta_ZZ
!
! Revision 2.28  2016/11/29 00:29:18  vsnyder
! Use interpolator in Indexed_Values_m
!
! Revision 2.27  2016/11/23 20:10:59  vsnyder
! Add Hydrostatic_All_ZZ, which uses an Eta list instead of computing it anew
!
! Revision 2.26  2016/04/28 18:04:12  vsnyder
! More TeXnicalities
!
! Revision 2.25  2015/04/11 00:45:03  vsnyder
! Add units (km) in h_grid comment
!
! Revision 2.24  2014/09/05 21:12:31  vsnyder
! Get kinds from MLSKinds instead of MLSCommon.  Add more tracing.
!
! Revision 2.23  2013/06/12 02:26:27  vsnyder
! Cruft removal
!
! Revision 2.22  2013/05/02 19:45:33  vsnyder
! Simplify r_eisq calculation, add a lot of LaTeX
!
! Revision 2.21  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.20  2007/01/17 23:50:15  vsnyder
! Exchange dhidzi, dhidtq, make dhidtq optional
!
! Revision 2.19  2006/11/30 23:28:29  vsnyder
! Correct some local array sizes
!
! Revision 2.18  2005/12/29 01:12:47  vsnyder
! Move some misplaced comments to correct places
!
! Revision 2.17  2005/12/22 20:57:10  vsnyder
! Added Hydrostatic_No_Der, some cannonball polishing
!
! Revision 2.16  2005/12/10 01:53:10  vsnyder
! Use get_eta_matrix_m instead of get_eta_matrix
!
! Revision 2.15  2005/12/07 00:32:21  vsnyder
! Cannonball polishing
!
! Revision 2.14  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.13  2004/03/20 04:06:13  vsnyder
! Moved Boltz from units to physics
!
! Revision 2.12  2003/09/16 18:43:47  vsnyder
! Might as well TeX-ify the comment about the approximation
!
! Revision 2.11  2003/09/16 18:31:02  vsnyder
! Put in a better comment about an approximation
!
! Revision 2.10  2003/09/16 00:21:32  vsnyder
! Remove unused arguments to get_eta
!
! Revision 2.9  2003/02/12 20:52:38  bill
! fixed serious bug in mass correction polynomial
!
! Revision 2.8  2003/02/10 23:41:27  bill
! got rid of a spread statement
!
! Revision 2.7  2003/02/08 00:59:16  bill
! uses latest piq int
!
! Revision 2.6  2003/02/07 00:04:54  bill
! mass function bug fix
!
! Revision 2.5  2002/10/08 17:08:04  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.4  2002/09/27 01:48:36  vsnyder
! Simplify iteration for z_surf
!
! Revision 2.3  2002/09/25 22:52:54  vsnyder
! Move USE from module scope to procedure scope.  Convert allocatable arrays
! to automatic arrays.  Replace sum(reshape(a...)*b) by dot_product.  Make
! constants consistently kind(rp) -- which caused a 1.5 epsilon relative
! change in output radiances.  Simplify Newton iteration.  Do some comments
! with LaTeX.
!
! Revision 2.2  2002/06/25 17:01:08  bill
! added more digits to J2 and added pressure dependent mass--wgr
!
! Revision 2.1  2002/02/02 11:20:08  zvi
! Some cosmetic changes
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.1.2.3  2001/09/13 22:51:22  zvi
! Separating allocation stmts
!
! Revision 1.1.2.2  2001/09/12 21:38:50  zvi
! Added CVS stuff
!
@


2.32
log
@Change to sparse eta representation
@
text
@a39 1
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
d42 1
d71 1
a82 1
    real(rp), dimension(size(t_grid),size(t_basis)) :: Eta
d86 1
d107 4
a110 3
! compute t_grid
    call get_eta_sparse ( t_basis, z_grid, eta )
    t_grid = matmul(eta,t_coeffs)
d193 1
a193 1
    call piq_int ( z_grid,t_basis,z_surf,piq,Z_MASS=2.5_rp,C_MASS=0.02_rp )
d274 11
a284 3
      if ( present(ddhdhdtq) ) &
        & ddhdhdtq = (2.0_rp/(spread(h_grid,2,n_coeffs)+r_eff)) * dhidtq &
                 & + eta / spread(t_grid,2,n_coeffs)
d356 1
d476 1
a476 1
    call piq_int ( z_grid,t_basis,z_surf,piq,Z_MASS=2.5_rp,C_MASS=0.02_rp )
d623 1
d733 1
a733 1
    call piq_int ( z_grid,t_basis,z_surf,piq,Z_MASS=2.5_rp,C_MASS=0.02_rp )
d772 1
a772 1
       "$Id: hydrostatic_m.f90,v 2.31 2017/08/28 20:28:08 livesey Exp $"
d782 3
@


2.31
log
@Changed the n,nf,np,nz elements to j,jf,...
@
text
@a311 2
    use Indexed_Values_m, only: Interpolate_Polymorphic, Value_List, &
      & Value_1D_List_t, Value_1D_p_t
d315 1
d328 1
a328 1
    class(value_list), intent(in) :: Eta_ZZ(:) ! Interpolation coefficients
d381 2
a382 2
! compute t_grid using what is effectively a sparse matrix multiply
    call interpolate_polymorphic ( t_coeffs, eta_zz, t_grid )
d548 5
a552 15
        select type ( eta_zz )
        type is ( value_1d_p_t )
          do k = 1, size(eta_zz)
            i = eta_zz(k)%p
            j = eta_zz(k)%j
            ddHdHdTq(i,j) = ddHdHdTq(i,j) + eta_zz(k)%v / t_grid(i)
          end do
        type is ( value_1d_list_t )
          do k = 1, size(eta_zz) ! Assumed to be same size as T_Grid
            do i = 1, eta_zz(k)%n
              j = eta_zz(k)%v(i)%j
              ddHdHdTq(k,j) = ddHdHdTq(k,j) + eta_zz(k)%v(i)%v / t_grid(k)
            end do
          end do
        end select
d760 1
a760 1
       "$Id: hydrostatic_m.f90,v 2.30 2017/01/14 02:57:11 vsnyder Exp $"
d770 3
@


2.30
log
@Make Eta_ZZ polymorphic
@
text
@d553 1
a553 1
            j = eta_zz(k)%n
d559 1
a559 1
              j = eta_zz(k)%v(i)%n
d771 1
a771 1
       "$Id: hydrostatic_m.f90,v 2.29 2016/12/02 02:04:50 vsnyder Exp $"
d781 3
@


2.29
log
@Use 'P' Eta list for Eta_ZZ
@
text
@d312 2
a313 1
    use Indexed_Values_m, only: Interpolate, Value_1D_p_t
d329 1
a329 1
    type(value_1D_p_t), intent(in) :: Eta_ZZ(:) ! Interpolation coefficients
d383 1
a383 1
    call interpolate ( t_coeffs, eta_zz, t_grid )
d549 15
a563 5
        do k = 1, size(eta_zz) ! Assumed to be same size as T_Grid
          i = eta_zz(k)%p
          j = eta_zz(k)%n
          ddHdHdTq(i,j) = ddHdHdTq(i,j) + eta_zz(k)%v / t_grid(i)
        end do
d771 1
a771 1
       "$Id: hydrostatic_m.f90,v 2.28 2016/11/29 00:29:18 vsnyder Exp $"
d781 3
@


2.28
log
@Use interpolator in Indexed_Values_m
@
text
@d312 1
a312 1
    use Indexed_Values_m, only: Interpolate, Value_1D_List_t
d328 1
a328 1
    type(value_1D_list_t), intent(in) :: Eta_ZZ(:) ! Interpolation coefficients
d548 4
a551 5
        do i = 1, size(eta_zz) ! Assumed to be same size as T_Grid
          do k = 1, eta_zz(i)%n ! 1 or 2
            j = eta_zz(i)%v(k)%n
            ddHdHdTq(i,j) = ddHdHdTq(i,j) + eta_zz(i)%v(k)%v / t_grid(i)
          end do
d760 1
a760 1
       "$Id: hydrostatic_m.f90,v 2.27 2016/11/23 20:10:59 vsnyder Exp $"
d770 3
@


2.27
log
@Add Hydrostatic_All_ZZ, which uses an Eta list instead of computing it anew
@
text
@d312 1
a312 1
    use Indexed_Values_m, only: Value_1D_List_t
d364 1
a364 1
    call trace_begin ( me, 'Hydrostatic_All', &
d382 1
a382 5
    do i = 1, size(t_grid)
      t_grid(i) = eta_zz(i)%v(1)%v * t_coeffs(eta_zz(i)%v(1)%n)
      if ( eta_zz(i)%n == 2 ) t_grid(i) = t_grid(i) + &
                & eta_zz(i)%v(2)%v * t_coeffs(eta_zz(i)%v(2)%n)
    end do
d579 1
a579 1
    call trace_end ( 'Hydrostatic_All', &
d761 1
a761 1
       "$Id: hydrostatic_m.f90,v 2.26 2016/04/28 18:04:12 vsnyder Exp $"
d771 3
@


2.26
log
@More TeXnicalities
@
text
@d20 1
a20 1
    module procedure Hydrostatic_All, Hydrostatic_No_Der
d40 2
a41 2
    use Get_eta_matrix_m, only: get_eta_sparse
    use Piq_int_m, only: piq_int
d304 284
d765 1
a765 1
       "$Id: hydrostatic_m.f90,v 2.25 2015/04/11 00:45:03 vsnyder Exp $"
d775 3
@


2.25
log
@Add units (km) in h_grid comment
@
text
@d49 1
a49 1
    real(rp), intent(in) :: t_basis(:)  ! vertical temperature basis
d51 3
a53 3
    real(rp), intent(in) :: z_grid(:)   ! -log10(P) pressures for which heights
!                                         are needed
    real(rp), intent(in) :: z_ref       ! reference pressure in -log10(P)
d55 1
d97 4
a100 4
!{A series expansion about z\_grid = 5/2 of
! $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
! $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
! first two terms.
d110 4
a113 1
! compute surface acceleration and effective earth radius
d123 1
a123 1
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$ in meters.
d132 1
a132 1
!{ Radial surface acceleration at latitude $\beta$, k$m/s^2$:
d135 3
a137 3
!                     \frac{1 - 3 J_2 P_2(\sin \beta)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \beta) (a/r_e)^4 }{r_e^2}
!                       - \omega^2 \cos^2 \beta \, r_e \right )
d148 3
a150 3
!         { 2\, G m \frac{1 - 6 J_2 P_2 (\sin \beta) (a/r_e)^2
!                         - 15 J_4 P_4 (\sin \beta) (a/r_e)^4}{r_e^3}
!                          + \omega^2 \cos^2 \beta }
d188 2
a189 2
! compute the piq integrals with mass reduction compensation relative to the
! surface
d200 1
a200 1
!    \frac{g_0 \stackrel{\star}{R_0}^2}
d202 2
a203 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!           ( f^T_{lm} \eta^T_m(\phi) P_l)}
d207 1
a207 1
!  Putting the remainder over a common denominator, we have
d211 2
a212 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l)}
d214 2
a215 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l)}
d223 37
d263 7
d277 6
d285 14
d319 1
a319 1
    real(rp), intent(in) :: t_basis(:)  ! vertical temperature basis
d321 3
a323 3
    real(rp), intent(in) :: z_grid(:)   ! -log10(P) pressures for which heights
!                                         are needed
    real(rp), intent(in) :: z_ref       ! reference pressure in -log10(P)
d325 1
d353 5
a357 4
! !{A series expansion about z\_grid = 5/2 of
! ! $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
! ! $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
! ! first two terms.
d363 4
a366 1
! compute surface acceleration and effective earth radius
d376 1
a376 1
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$ in meters.
d385 1
a385 1
!{ Radial surface acceleration at latitude $\beta$, k$m/s^2$:
d388 3
a390 3
!                     \frac{1 - 3 J_2 P_2(\sin \beta)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \beta) (a/r_e)^4 }{r_e^2}
!                       - \omega^2 \cos^2 \beta \, r_e \right )
d401 3
a403 3
!         { 2\, G m \frac{1 - 6 J_2 P_2 (\sin \beta) (a/r_e)^2
!                         - 15 J_4 P_4 (\sin \beta) (a/r_e)^4}{r_e^3}
!                          + \omega^2 \cos^2 \beta }
d439 2
a440 2
! compute the piq integrals with mass reduction compensation relative to the
! surface
d452 1
a452 1
!    \frac{g_0 \stackrel{\star}{R_0}^2}
d454 2
a455 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!           ( f^T_{lm} \eta^T_m(\phi) P_l)}
d459 1
a459 1
!  Putting the remainder over a common denominator, we have
d463 2
a464 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l)}
d466 2
a467 2
!          \sum_l^{\text{NH}^T} \sum_m^{\text{NP}^T}
!          ( f^T_{lm} \eta^T_m(\phi) P_l)}
d481 1
a481 1
       "$Id: hydrostatic_m.f90,v 2.24 2014/09/05 21:12:31 vsnyder Exp $"
d491 3
@


2.24
log
@Get kinds from MLSKinds instead of MLSCommon.  Add more tracing.
@
text
@d58 1
a58 1
    real(rp), intent(out) :: h_grid(:)  ! heights on z_grid
d259 1
a259 1
    real(rp), intent(out) :: h_grid(:)  ! heights on z_grid
d408 1
a408 1
       "$Id: hydrostatic_m.f90,v 2.23 2013/06/12 02:26:27 vsnyder Exp $"
d418 3
@


2.23
log
@Cruft removal
@
text
@d38 1
a38 1
    use MLSCommon, only: RP, IP
d43 2
d72 1
d85 1
a85 1
!
d87 4
a90 1
!
d108 1
a108 1
!
d110 1
a110 1
!
d231 3
d277 1
a277 1
!
d279 1
a279 1
!
d283 1
a283 1
! 
d292 1
a292 1
!
d294 1
a294 1
!
d408 1
a408 1
       "$Id: hydrostatic_m.f90,v 2.22 2013/05/02 19:45:33 vsnyder Exp $"
d418 3
@


2.22
log
@Simplify r_eisq calculation, add a lot of LaTeX
@
text
@d70 1
a70 1
    integer(ip) :: n_lvls,n_coeffs,iter
a84 1
    n_lvls = size(z_grid)
d257 1
a257 1
    integer(ip) :: n_lvls,n_coeffs,iter
d267 1
a267 1
    real(rp), dimension(size(z_grid)) :: Mass_corr
a270 2
    n_lvls = size(z_grid)
    n_coeffs = size(t_basis)
d272 11
a282 11
    where ( z_grid > 2.5_rp )
!     mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)

!{A series expansion about z\_grid = 5/2 of
! $\frac1{\frac78 + \frac1{10}z - \frac1{50}z^2}$ is
! $\sum_{k=0}^{\infty} \left( \frac{(z-\frac52)^2}{50}\right)^k$.  Use the
! first two terms.
      mass_corr = 1.0_rp + 0.02_rp*(z_grid - 2.5_rp)**2
    elsewhere
      mass_corr = 1.0_rp
    end where
d399 1
a399 1
       "$Id: hydrostatic_m.f90,v 2.21 2009/06/23 18:26:11 pwagner Exp $"
d409 3
@


2.21
log
@Prevent Intel from optimizing ident string away
@
text
@d25 1
a25 1
       "$RCSfile: $"
d42 1
a42 1
    use Physics, only: BoltzMeters => Boltz
d74 1
a74 1
    real(rp) :: R_e, R_eisq, R_eisq_A, R_eff, Slsq, Z_surf
d113 5
a117 4
!{ compute earth radius having potential = 62636858.0 $m/s^2$:
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$

    r_eisq_a = (eRadAsq*slsq + eRadBsq*clsq) / eRadBsq ! m^{-1}
d119 1
a119 1
    r_eisq = r_eisq_a / eRadAsq ! (r_e)^{-2} in m^{-2}
d123 7
a129 4
!{ radial surface acceleration, k$m/s^2$:\\
!  $g_{\text{ref}} = 0.001 \left ( G m ( 1 - 3 J_2 P_2(\sin \beta)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \beta) (a/r_e)^4 ) / r_e^2
!                       - \omega^2 \cos^2 \beta \, r_e \right )$
d134 13
a146 5
!{ better effective Earth radius: compute $-d g_{\text{ref}} / d r$, kilometers:\\
!  $r_{\text{eff}} = 2 g_{\text{ref}} / \left ( 2 G m (
!                      ( 1 - 6 J_2 P_2 (\sin \beta) (a/r_e)^2
!                          - 15 J_4 P_4 (\sin \beta) (a/r_e)^4 ) / r_e^3
!                          + \omega^2 \cos^2 \beta \right )$
d187 25
d262 1
a262 1
    real(rp) :: R_e, R_eisq, R_eisq_A, R_eff, Slsq, Z_surf
d296 5
a300 4
!{ compute earth radius having potential = 62636858.0 $m/s^2$:
!  $r_e^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$

    r_eisq_a = (eRadAsq*slsq + eRadBsq*clsq) / eRadBsq ! m^{-1}
d302 1
a302 1
    r_eisq = r_eisq_a / eRadAsq ! (r_e)^{-2} in m^{-2}
d306 7
a312 4
!{ radial surface acceleration, k$m/s^2$:\\
!  $g_{\text{ref}} = 0.001 \left ( G m ( 1 - 3 J_2 P_2(\sin \beta)
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \beta) (a/r_e)^4 ) /r_e^2
!                       - \omega^2 \cos^2 \beta \, r_e \right )$
d317 13
a329 5
!{ better effective Earth radius: compute $-d g_{\text{ref}} / d r$, kilometers:\\
!  $r_{\text{eff}} = 2 g_{\text{ref}} / \left ( 2 G m (
!                      ( 1 - 6 J_2 P_2 (\sin \beta) (a/r_e)^2
!                          - 15 J_4 P_4 (\sin \beta) (a/r_e)^4 ) / r_e^3
!                          + \omega^2 \cos^2 \beta \right )$
d368 26
d402 1
a402 1
       "$Id: read_apriori.f90 is it here $"
d412 3
@


2.20
log
@Exchange dhidzi, dhidtq, make dhidtq optional
@
text
@d25 1
a25 1
       "$RCSfile: hydrostatic_m.f90,v $"
d324 1
a325 1
!---------------------------- RCS Ident Info -------------------------------
d327 2
a328 3
       "$Id: hydrostatic_m.f90,v 2.19 2006/11/30 23:28:29 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d330 1
d332 1
d337 3
@


2.19
log
@Correct some local array sizes
@
text
@d33 1
a33 1
                      &    t_grid, h_grid, dhidtq, dhidzi, ddhdhdtq, z_surface )
a56 2
    real(rp), intent(out) :: dhidtq(:,:) ! dh/dt on z_grid assuming dh/dt = 0.0
!                 at the reference ellipse surface  equivalent to h_ref = 0.0
d59 4
a62 1
    real(rp), optional, intent(out) :: ddhdhdtq(:,:) ! ddh/dhdt on z_grid
a177 2
    dhidtq = spread(dhidzi,2,n_coeffs) * piq
    dhidzi = dhidzi * t_grid * mass_corr
d179 2
d182 4
d187 1
a187 3
    if ( present(ddhdhdtq) ) &
      & ddhdhdtq = (2.0_rp/(spread(h_grid,2,n_coeffs)+r_eff)) * dhidtq &
               & + eta / spread(t_grid,2,n_coeffs)
d327 1
a327 1
       "$Id: hydrostatic_m.f90,v 2.18 2005/12/29 01:12:47 vsnyder Exp $"
d336 3
@


2.18
log
@Move some misplaced comments to correct places
@
text
@d77 3
a79 2
    real(rp), dimension(size(z_grid),size(t_basis)) :: Eta, Piq
    real(rp), dimension(1,size(t_basis)) :: Piqa, Piqb
d324 1
a324 1
       "$Id: hydrostatic_m.f90,v 2.17 2005/12/22 20:57:10 vsnyder Exp $"
d333 3
@


2.17
log
@Added Hydrostatic_No_Der, some cannonball polishing
@
text
@d50 1
a52 1
!                                         are needed
d189 1
a189 1
                      &  h_grid )
d205 1
a207 1
!                                         are needed
d323 1
a323 1
       "$Id: hydrostatic_m.f90,v 2.16 2005/12/10 01:53:10 vsnyder Exp $"
d332 3
@


2.16
log
@Use get_eta_matrix_m instead of get_eta_matrix
@
text
@d19 4
d30 3
a32 1
  subroutine Hydrostatic ( lat, t_basis, t_coeffs, z_grid, z_ref, h_ref, &
a36 1
! This is for EOS prototyping
d46 2
a47 4
    real(rp), intent(in) :: lat ! geocentric latitude in radians
    real(rp), intent(in) :: z_ref ! reference pressure in -log10(P)
    real(rp), intent(in) :: h_ref ! reference geopotential height in km
    real(rp), intent(in) :: t_basis(:) ! vertical temperature basis
d49 4
a52 2
    real(rp), intent(in) :: z_grid(:) ! -log10(P) pressures for which heights
!                                  are needed
d55 2
a56 3
    real(rp), intent(out) :: h_grid(:) ! heights on z_grid
    real(rp), intent(out) :: t_grid(:) ! temperatures on z_grid
    real(rp), intent(out) :: dhidzi(:) ! dh/dz on z_grid
d59 1
d61 1
a61 1
    real(rp), optional, intent(out) :: ddhdhdtq(:,:) !ddh/dhdt on z_grid
d122 1
a122 1
!                       (a/r_e)^2 - 5 J_4 P_4(\sin \beta) (a/r_e)^4 ) /r_e^2
d185 134
a318 1
  end subroutine Hydrostatic
d323 1
a323 1
       "$Id: hydrostatic_m.f90,v 2.15 2005/12/07 00:32:21 vsnyder Exp $"
d332 3
@


2.15
log
@Cannonball polishing
@
text
@d35 1
a35 1
    use Get_eta_m, only: get_eta
d94 1
a94 2

    call get_eta ( z_grid, t_basis, eta )
d185 1
a185 1
       "$Id: hydrostatic_m.f90,v 2.14 2005/06/22 18:08:19 pwagner Exp $"
d194 3
@


2.14
log
@Reworded Copyright statement, moved rcs id
@
text
@d21 1
a21 1
       "$RCSfile: $"
d57 1
a57 1
    real(rp), optional :: z_surface
d83 1
d164 1
a164 1
    CALL piq_int ( z_grid,t_basis,z_surf,piq,Z_MASS=2.5_rp,C_MASS=0.02_rp )
d181 1
a181 1
 end subroutine Hydrostatic
d186 1
a186 1
       "$Id: $"
d195 3
@


2.13
log
@Moved Boltz from units to physics
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology. ALL RIGHTS RESERVED.
! U.S. Government sponsorship under NASA Contract NAS7407 is acknowledged.
d19 3
a21 6
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: hydrostatic_m.f90,v 2.12 2003/09/16 18:43:47 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = &
    & "$RCSfile: hydrostatic_m.f90,v $"
d183 5
d194 3
@


2.12
log
@Might as well TeX-ify the comment about the approximation
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.11 2003/09/16 18:31:02 vsnyder Exp $"
d32 1
a32 1
    use Units, only: BoltzMeters => Boltz
d184 3
@


2.11
log
@Put in a better comment about an approximation
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.10 2003/09/16 00:21:32 vsnyder Exp $"
d78 4
a81 1
! This is a second order Taylor series expansion about z_grid = 5/2 of the above
d184 3
@


2.10
log
@Remove unused arguments to get_eta
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.9 2003/02/12 20:52:38 bill Exp $"
d77 2
a78 2
!      mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)
! This is a second order approximation to the above
d181 3
@


2.9
log
@fixed serious bug in mass correction polynomial
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.8 2003/02/10 23:41:27 bill Exp $"
d86 1
a86 1
    call get_eta ( z_grid, t_basis, n_lvls, n_coeffs, eta )
d181 3
@


2.8
log
@got rid of a spread statement
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.7 2003/02/08 00:59:16 bill Exp $"
d79 1
a79 1
      mass_corr = 1.0_rp * 0.02_rp*(z_grid - 2.5_rp)**2
d181 3
@


2.7
log
@uses latest piq int
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.6 2003/02/07 00:04:54 bill Exp $"
d164 1
a164 1
    dhidzi = dhidzi * MATMUL(eta * SPREAD(mass_corr,2,n_coeffs),t_coeffs)
d181 3
@


2.6
log
@mass function bug fix
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.5 2002/10/08 17:08:04 pwagner Exp $"
d69 1
a69 1
    real(rp), dimension(size(t_basis)) :: Mass_corr
d76 4
a79 2
    where ( t_basis > 2.5_rp )
      mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*t_basis - 0.02_rp*t_basis**2)
d152 2
a153 1
! compute the piq integrals relative to the surface
d155 1
a155 7
    call piq_int ( z_grid, t_basis, z_surf, piq )

! compensate piq for mass reduction. Note this is not the
! most rigourous code because it assumes the mass is constant
! across a coefficient.

    piq = piq * SPREAD(mass_corr,1,n_lvls)
d164 1
a164 1
    dhidzi = dhidzi * t_grid
d181 3
@


2.5
log
@Added idents to survive zealous Lahey optimizer
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.4 2002/09/27 01:48:36 vsnyder Exp $"
d69 1
a69 1
    real(rp), dimension(size(z_grid)) :: Mass_corr
d76 2
a77 2
    where ( z_grid > 2.5_rp )
      mass_corr = 1.0_rp / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)
d154 6
d163 1
a163 1
    h_grid = boltz * mass_corr * matmul(piq,t_coeffs)
d165 1
a165 1
    dhidzi = (h_grid+r_eff)**2 * boltz/g_ref * mass_corr / r_eff**2
d184 3
@


2.4
log
@Simplify iteration for z_surf
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.3 2002/09/25 22:52:54 vsnyder Exp $"
d17 1
d171 4
d178 3
@


2.3
log
@Move USE from module scope to procedure scope.  Convert allocatable arrays
to automatic arrays.  Replace sum(reshape(a...)*b) by dot_product.  Make
constants consistently kind(rp) -- which caused a 1.5 epsilon relative
change in output radiances.  Simplify Newton iteration.  Do some comments
with LaTeX.
@
text
@d13 1
a13 1
    & "$Id: hydrostatic_m.f90,v 2.2 2002/06/25 17:01:08 bill Exp $"
d31 1
d56 1
a56 1
    real(rp), parameter :: Boltz = 0.000660988_rp ! = kln10/m km^2/(K sec^2)
d61 1
a61 1
    real(rp) :: Boltzg, Clsq, G_ref
d65 1
a65 1
    real(rp) :: dh_dz_S, H_calc, Z_new
d124 2
a125 2
    boltzg = boltz / g_ref
    z_surf = z_grid(1) ! This is a guess
d133 2
a134 2
      call piq_int ( (/z_surf/), t_basis, z_ref, piqa )
      h_calc = boltzg * dot_product(piqa(1,:), t_coeffs)
d136 4
a139 4
      call piq_int ( (/z_surf+0.01_rp/), t_basis, z_ref, piqa )
      call piq_int ( (/z_surf-0.01_rp/), t_basis, z_ref, piqb )
      dh_dz_s = boltzg * dot_product((piqa(1,:) - piqb(1,:)), t_coeffs) * 50.0_rp
      z_new = z_surf - (h_ref + h_calc) / dh_dz_s
d142 2
a143 2
      if ( abs(z_new - z_surf) < 0.0001_rp .or. iter == 10 ) exit
      z_surf = z_new
a146 1
    z_surf = z_new
d158 1
a158 1
    dhidzi = (h_grid+r_eff)**2 * boltzg * mass_corr / r_eff**2
d173 7
@


2.2
log
@added more digits to J2 and added pressure dependent mass--wgr
@
text
@d1 10
a10 15
MODULE hydrostatic_m
!
! This computes a hydrostatic function per L2PC method and returns 
! geometric heights reference height is now an input
! This is for EOS prototyping
!
  use MLSCommon, only: RP, IP
  USE Geometry, ONLY: earthrada,earthradb
  USE get_eta_m, only: get_eta
  USE piq_int_m, only: piq_int
!
  IMPLICIT NONE
!
  Private
  Public :: hydrostatic
d12 5
a16 4
  CHARACTER (LEN=256) :: Id = &
   "$Id: hydrostatic_m.f90,v 2.1 2002/02/02 11:20:08 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
   "$RCSfile: hydrostatic_m.f90,v $"
d18 1
a18 1
  CONTAINS
d20 12
a31 3
  SUBROUTINE hydrostatic(lat,t_basis,t_coeffs,z_grid,z_ref,h_ref,t_grid, &
                      &  h_grid,dhidtq,dhidzi,ddhdhdtq,z_surface)
!
d33 7
a39 7
!
  REAL(rp), INTENT(in) :: lat ! geocentric latitude in radians
  REAL(rp), INTENT(in) :: z_ref ! reference pressure in -log10(P)
  REAL(rp), INTENT(in) :: h_ref ! reference geopotential height in km
  REAL(rp), INTENT(in) :: t_basis(:) ! vertical temperature basis
  REAL(rp), INTENT(in) :: t_coeffs(:) ! temperature values
  REAL(rp), INTENT(in) :: z_grid(:) ! -log10(P) pressures for which heights
d42 5
a46 5
!
  REAL(rp), INTENT(out) :: h_grid(:) ! heights on z_grid
  REAL(rp), INTENT(out) :: t_grid(:) ! temperatures on z_grid
  REAL(rp), INTENT(out) :: dhidzi(:) ! dh/dz on z_grid
  REAL(rp), INTENT(out) :: dhidtq(:,:) ! dh/dt on z_grid assuming dh/dt = 0.0
d49 3
a51 3
  REAL(rp), OPTIONAL, INTENT(out) :: ddhdhdtq(:,:) !ddh/dhdt on z_grid
  REAL(rp), OPTIONAL :: z_surface
!
d53 15
a67 16
! These are the 1980 reference geoid values these should be later
! moved to a separate module (preferably Geometry.f90)
!
  REAL(rp), PARAMETER :: gm = 3.986005e14_rp ! m^3/sec^2
  REAL(rp), PARAMETER :: j2 = 0.0010826256_rp
  REAL(rp), PARAMETER :: j4 = -.0000023709122_rp
!
! earth rotational velocity
!
  REAL(rp), PARAMETER :: w = 7.292115e-05_rp ! rad/sec
!
  INTEGER(ip) :: n_lvls,n_coeffs,iter
!
  REAL(rp) :: sl,cl,p2,p4,dp2,dp4,g_ref,r_eff,boltz,r_e,z_surf
  REAL(rp) :: z_new,h_calc,dh_dz_s
  REAL(rp), ALLOCATABLE :: eta(:,:),piq(:,:),piqa(:,:),piqb(:,:),mass_corr(:)
d71 9
a79 9
  n_lvls = SIZE(z_grid)
  n_coeffs = SIZE(t_basis)
  ALLOCATE(eta(1:n_lvls,1:n_coeffs))
  ALLOCATE(piq(1:n_lvls,1:n_coeffs))
  ALLOCATE(mass_corr(1:n_lvls))
  mass_corr = 1.0_rp
  WHERE(z_grid > 2.5) mass_corr = 1.0_rp &
  & / (0.875_rp + 0.1_rp*z_grid - 0.02_rp*z_grid**2)
!
d81 3
a83 3
!
  CALL get_eta(z_grid,t_basis,n_lvls,n_coeffs,eta)
  t_grid = MATMUL(eta,t_coeffs)
d87 34
a120 23
  sl = SIN(lat)
  cl = COS(lat)
  p2 = (3.0_rp * sl**2 - 1.0_rp) / 2.0_rp
  p4 = (35.0_rp * sl**4 - 30.0_rp * sl**2 + 3.0_rp) / 8.0_rp
  dp2 = 3.0_rp * sl * cl
  dp4 = 5.0_rp * (7.0_rp * sl**3 * cl - 3.0_rp * sl * cl) / 2.0_rp
!
! compute earth radius having potential = 62636858.0 m/sec^2
!
  r_e = earthrada*earthradb &
      / SQRT((earthrada*sl)**2+(earthradb*cl)**2) !in meters
!
! radial surface acceleration, km/sec^2
!
  g_ref = 0.001 * (gm * (1.0_rp - 3.0_rp*j2*p2*(earthrada/r_e)**2 &
        - 5.0_rp*j4*p4*(earthrada/r_e)**4)/r_e**2 - (w*cl)**2 * r_e)
!
! better effective Earth radius compute -d g_ref / d r, kilometers
!
  r_eff = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
        * (earthrada/r_e)**2 - 15.0_rp*j4*p4*(earthrada/r_e)**4) &
        / r_e**3 + (w*cl)**2)
!
a121 3
!
  boltz = 0.000660988_rp ! = kln10/m km^2/(K sec^2)
  z_surf = z_grid(1) ! This is a guess
d123 2
a124 2
  ALLOCATE(piqa(1:1,1:n_coeffs))
  ALLOCATE(piqb(1:1,1:n_coeffs))
d126 17
a142 7
  CALL piq_int((/z_surf/),t_basis,z_ref,piqa)
  h_calc = boltz*SUM(RESHAPE(piqa,(/n_coeffs/)) * t_coeffs) / g_ref
!
! correct
!
  CALL piq_int((/z_surf+0.01_rp/),t_basis,z_ref,piqa)
  CALL piq_int((/z_surf-0.01_rp/),t_basis,z_ref,piqb)
d144 1
a144 3
  dh_dz_s = boltz*SUM((RESHAPE(piqa,(/n_coeffs/))-RESHAPE(piqb,(/n_coeffs/))) &
          * t_coeffs) / (0.02_rp*g_ref)
  z_new = z_surf - (h_ref + h_calc) / dh_dz_s
d146 2
a147 2
  iter = 0
  DO
d149 1
a149 13
    iter = iter + 1
    IF(ABS(z_new - z_surf) < 0.0001_rp .OR. iter == 10) EXIT
    z_surf = z_new
    CALL piq_int((/z_surf/),t_basis,z_ref,piqa)
    h_calc = boltz*SUM(RESHAPE(piqa,(/n_coeffs/)) * t_coeffs) / g_ref
!
! correct
!
    CALL piq_int((/z_surf+0.01_rp/),t_basis,z_ref,piqa)
    CALL piq_int((/z_surf-0.01_rp/),t_basis,z_ref,piqb)
    dh_dz_s = boltz*SUM((RESHAPE(piqa,(/n_coeffs/)) &
            - RESHAPE(piqb,(/n_coeffs/))) * t_coeffs) / (0.02_rp*g_ref)
    z_new = z_surf - (h_ref + h_calc) / dh_dz_s
d151 1
a151 4
  END DO
!
  DEALLOCATE(piqb)
  DEALLOCATE(piqa)
a152 7
  z_surf = z_new
  IF (PRESENT(z_surface)) z_surface = z_surf
!
! compute the piq integrals relative to the surface
!
  CALL piq_int(z_grid,t_basis,z_surf,piq)
!
d154 1
a154 1
!
d156 6
a161 6
  h_grid = boltz * mass_corr * MATMUL(piq,t_coeffs)
  h_grid = r_eff * h_grid / (r_eff * g_ref - h_grid)
  dhidzi = (h_grid+r_eff)**2 * boltz * mass_corr / (g_ref * r_eff**2)
  dhidtq = SPREAD(dhidzi,2,n_coeffs) * piq
  dhidzi = dhidzi * t_grid
!
d163 8
a170 12
!
  IF(PRESENT(ddhdhdtq)) &
  ddhdhdtq = (2.0_rp/(SPREAD(h_grid,2,n_coeffs)+r_eff)) * dhidtq &
           + eta / SPREAD(t_grid,2,n_coeffs)

  DEALLOCATE(piq)
  DEALLOCATE(eta)
  DEALLOCATE(mass_corr)
!
 END SUBROUTINE hydrostatic
!
END MODULE hydrostatic_m
d173 3
@


2.1
log
@Some cosmetic changes
@
text
@d18 1
a18 1
   "$Id: hydrostatic_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d52 1
a52 1
  REAL(rp), PARAMETER :: j2 = 0.00108263_rp
d63 1
a63 1
  REAL(rp), ALLOCATABLE :: eta(:,:),piq(:,:),piqa(:,:),piqb(:,:)
d71 4
d157 2
a158 1
  h_grid = boltz * MATMUL(piq,t_coeffs) ! geopotential height * g_ref
d160 1
a160 1
  dhidzi = (h_grid+r_eff)**2 * boltz / (g_ref * r_eff**2)
d172 1
d179 3
@


2.0
log
@New forward model
@
text
@d3 2
a4 3
! This computes a hydrostatic function per L2PC method
! and returns geometric heights
! reference height is now an input
d11 1
d18 1
a18 1
   "$Id: hydrostatic_m.f90,v 1.1.2.3 2001/09/13 22:51:22 zvi Exp $"
d25 1
a25 1
                  h_grid,dhidtq,dhidzi,ddhdhdtq,z_surface)
d43 1
d117 1
d121 2
a122 1
  iter = 1
d124 2
d138 1
a138 1
    iter = iter + 1
d173 3
@


1.1
log
@file hydrostatic_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 173
@


1.1.2.1
log
@Major Design change..
@
text
@a0 110
  MODULE hydrostatic_m
! This computes a hydrostatic function per L2PC method
! and returns geometric heights
! reference height is now an input
! This is for EOS prototyping
  use MLSCommon, only: RP, IP
  USE Geometry, ONLY: earthrada,earthradb
  USE get_eta_m
  USE piq_int_m
  IMPLICIT NONE
  CONTAINS
  SUBROUTINE hydrostatic(lat,t_basis,t_coeffs,z_grid,z_ref,h_ref,t_grid, &
                  h_grid,dhidtq,dhidzi,ddhdhdtq,z_surface)
! Inputs
  REAL(rp), INTENT(in) :: lat ! geocentric latitude in radians
  REAL(rp), INTENT(in) :: z_ref ! reference pressure in -log10(P)
  REAL(rp), INTENT(in) :: h_ref ! reference geopotential height in km
  REAL(rp), INTENT(in) :: t_basis(:) ! vertical temperature basis
  REAL(rp), INTENT(in) :: t_coeffs(:) ! temperature values
  REAL(rp), INTENT(in) :: z_grid(:) ! -log10(P) pressures for which heights are
!                                  are needed
! Outputs
  REAL(rp), INTENT(out) :: h_grid(:) ! heights on z_grid
  REAL(rp), INTENT(out) :: t_grid(:) ! temperatures on z_grid
  REAL(rp), INTENT(out) :: dhidzi(:) ! dh/dz on z_grid
  REAL(rp), INTENT(out) :: dhidtq(:,:) ! dh/dt on z_grid assuming dh/dt = 0.0
!                                  at the reference ellipse surface
!                                  equivalent to h_ref = 0.0
  REAL(rp), OPTIONAL, INTENT(out) :: ddhdhdtq(:,:) !ddh/dhdt on z_grid
  REAL(rp), OPTIONAL :: z_surface
! Internal stuff
! These are the 1980 reference geoid values these should be later
! moved to a separate module (preferably Geometry.f90)
  REAL(rp), PARAMETER :: gm = 3.986005e14_rp ! m^3/sec^2
  REAL(rp), PARAMETER :: j2 = 0.00108263_rp
  REAL(rp), PARAMETER :: j4 = -.0000023709122_rp
! earth rotational velocity
  REAL(rp), PARAMETER :: w = 7.292115e-05_rp ! rad/sec
  INTEGER(ip) :: n_lvls,n_coeffs,iter
  REAL(rp) :: sl,cl,p2,p4,dp2,dp4,g_ref,r_eff,boltz,r_e,z_surf
  REAL(rp) :: z_new,h_calc,dh_dz_s
  REAL(rp), ALLOCATABLE :: eta(:,:),piq(:,:),piqa(:,:),piqb(:,:)
! begin the code
  n_lvls = SIZE(z_grid)
  n_coeffs = SIZE(t_basis)
  ALLOCATE(eta(1:n_lvls,1:n_coeffs),piq(1:n_lvls,1:n_coeffs))
! compute t_grid
  CALL get_eta(z_grid,t_basis,n_lvls,n_coeffs,eta)
  t_grid = MATMUL(eta,t_coeffs)
! compute surface acceleration and effective earth radius
  sl = SIN(lat)
  cl = COS(lat)
  p2 = (3.0_rp * sl**2 - 1.0_rp) / 2.0_rp
  p4 = (35.0_rp * sl**4 - 30.0_rp * sl**2 + 3.0_rp) / 8.0_rp
  dp2 = 3.0_rp * sl * cl
  dp4 = 5.0_rp * (7.0_rp * sl**3 * cl - 3.0_rp * sl * cl) / 2.0_rp
! compute earth radius having potential = 62636858.0 m/sec^2
  r_e = earthrada*earthradb &
      / SQRT((earthrada*sl)**2+(earthradb*cl)**2) !in meters
! radial surface acceleration, km/sec^2
  g_ref = 0.001 * (gm * (1.0_rp - 3.0_rp*j2*p2*(earthrada/r_e)**2 &
        - 5.0_rp*j4*p4*(earthrada/r_e)**4)/r_e**2 - (w*cl)**2 * r_e)
! better effective Earth radius compute -d g_ref / d r, kilometers
  r_eff = 2.0_rp * g_ref / (2.0_rp * gm * (1.0_rp-6.0_rp*j2*p2 &
        * (earthrada/r_e)**2 - 15.0_rp*j4*p4*(earthrada/r_e)**4) &
        / r_e**3 + (w*cl)**2)
! find the surface pressure
  boltz = 0.000660988_rp ! = kln10/m km^2/(K sec^2)
  z_surf = z_grid(1) ! This is a guess
  ALLOCATE(piqa(1:1,1:n_coeffs),piqb(1:1,1:n_coeffs))
  CALL piq_int((/z_surf/),t_basis,z_ref,piqa)
  h_calc = boltz*SUM(RESHAPE(piqa,(/n_coeffs/)) * t_coeffs) / g_ref
! correct
  CALL piq_int((/z_surf+0.01_rp/),t_basis,z_ref,piqa)
  CALL piq_int((/z_surf-0.01_rp/),t_basis,z_ref,piqb)
  dh_dz_s = boltz*SUM((RESHAPE(piqa,(/n_coeffs/))-RESHAPE(piqb,(/n_coeffs/))) &
          * t_coeffs) / (0.02_rp*g_ref)
  z_new = z_surf - (h_ref + h_calc) / dh_dz_s
  iter = 1
  DO
    IF(ABS(z_new - z_surf) < 0.0001_rp .OR. iter == 10) EXIT
    z_surf = z_new
    CALL piq_int((/z_surf/),t_basis,z_ref,piqa)
    h_calc = boltz*SUM(RESHAPE(piqa,(/n_coeffs/)) * t_coeffs) / g_ref
! correct
    CALL piq_int((/z_surf+0.01_rp/),t_basis,z_ref,piqa)
    CALL piq_int((/z_surf-0.01_rp/),t_basis,z_ref,piqb)
    dh_dz_s = boltz*SUM((RESHAPE(piqa,(/n_coeffs/)) &
            - RESHAPE(piqb,(/n_coeffs/))) * t_coeffs) / (0.02_rp*g_ref)
    z_new = z_surf - (h_ref + h_calc) / dh_dz_s
    iter = iter + 1
  END DO
  DEALLOCATE(piqa,piqb)
  z_surf = z_new
  IF (PRESENT(z_surface)) z_surface = z_surf
! compute the piq integrals relative to the surface
  CALL piq_int(z_grid,t_basis,z_surf,piq)
! compute the height vector
  h_grid = boltz * MATMUL(piq,t_coeffs) ! geopotential height * g_ref
  h_grid = r_eff * h_grid / (r_eff * g_ref - h_grid)
  dhidzi = (h_grid+r_eff)**2 * boltz / (g_ref * r_eff**2)
  dhidtq = SPREAD(dhidzi,2,n_coeffs) * piq
  dhidzi = dhidzi * t_grid
! this derivative is useful for antenna derivatives
  IF(PRESENT(ddhdhdtq)) &
  ddhdhdtq = (2.0_rp/(SPREAD(h_grid,2,n_coeffs)+r_eff)) * dhidtq &
           + eta / SPREAD(t_grid,2,n_coeffs)
  DEALLOCATE(eta,piq)
  END SUBROUTINE hydrostatic
  END MODULE hydrostatic_m
@


1.1.2.2
log
@Added CVS stuff
@
text
@d1 1
a1 1
MODULE hydrostatic_m
d8 2
a9 2
  USE get_eta_m, only: get_eta
  USE piq_int_m, only: piq_int
a10 8
  Private
  Public :: hydrostatic
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
   "$Id: two_d_hydrostatic_m.f90,v 1.9.2.1 2001/09/10 10:02:32 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
   "$RCSfile: two_d_hydrostatic_m.f90,v $"
!---------------------------------------------------------------------------
a11 1
!---------------------------------------------------------------------------
d110 1
a110 4
END MODULE hydrostatic_m
!---------------------------------------------------
! $Log$
!
@


1.1.2.3
log
@Separating allocation stmts
@
text
@a1 1
!
a5 1
!
a10 1
!
d15 1
a15 1
   "$Id: hydrostatic_m.f90,v 1.1.2.2 2001/09/12 21:38:50 zvi Exp $"
d17 1
a17 1
   "$RCSfile: hydrostatic_m.f90,v $"
a22 1
!
a23 1
!
d29 1
a29 1
  REAL(rp), INTENT(in) :: z_grid(:) ! -log10(P) pressures for which heights
a31 1
!
d36 2
a37 1
!                 at the reference ellipse surface  equivalent to h_ref = 0.0
a39 1
!
a42 1
!
a45 1
!
a46 1
!
a47 1
!
a48 1
!
a51 1
!
a52 1
!
d55 1
a55 3
  ALLOCATE(eta(1:n_lvls,1:n_coeffs))
  ALLOCATE(piq(1:n_lvls,1:n_coeffs))
!
a56 1
!
a58 1
!
a59 1
!
a65 1
!
a66 1
!
a68 1
!
a69 1
!
a71 1
!
a72 1
!
a75 1
!
a76 1
!
d79 1
a79 4

  ALLOCATE(piqa(1:1,1:n_coeffs))
  ALLOCATE(piqb(1:1,1:n_coeffs))

a81 1
!
a82 1
!
a93 1
!
a94 1
!
d102 1
a102 4
!
  DEALLOCATE(piqb)
  DEALLOCATE(piqa)

a104 1
!
a105 1
!
a106 1
!
a107 1
!
a112 1
!
a113 1
!
d117 2
a118 6

  DEALLOCATE(piq)
  DEALLOCATE(eta)
!
 END SUBROUTINE hydrostatic
!
d121 1
a121 3
! $Log: hydrostatic_m.f90,v $
! Revision 1.1.2.2  2001/09/12 21:38:50  zvi
! Added CVS stuff
@


