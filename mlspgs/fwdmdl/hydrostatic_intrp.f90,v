head	2.7;
access;
symbols
	v5-02-NRT-19:2.7
	v6-00:2.7
	v5-02-NRT-18:2.7
	v5-02:2.7
	v5-01-NRT-17:2.7
	v5-01-NRT-16:2.7
	v5-01-NRT-15:2.7
	v5-01-NRT-14:2.7
	neuralnetworks-1-0:2.7.0.12
	cfm-single-freq-0-1:2.7.0.10
	v5-01:2.7
	v5-00:2.7
	v4-23-TA133:2.7.0.8
	mus-emls-1-70:2.7.0.6
	rel-1-0-englocks-work:2.7.0.4
	VUMLS1-00:2.7
	VPL1-00:2.7
	V4-22-NRT-08:2.7
	VAM1-00:2.7
	V4-21:2.7.0.2
	V4-13:2.7
	V4-12:2.7
	V4-11:2.7
	V4-10:2.7
	V3-43:2.6
	M4-00:2.7
	V3-41:2.6
	V3-40-PlusGM57:2.6.0.2
	V2-24-NRT-04:2.5
	V3-33:2.6
	V2-24:2.5
	V3-31:2.6
	V3-30-NRT-05:2.6
	cfm-01-00:2.6
	V3-30:2.6
	V3-20:2.6
	V3-10:2.6
	V2-23-NRT-02:2.5
	V2-23:2.5
	V2-22-NRT-01:2.5
	V2-22:2.5
	V2-21:2.4
	V2-20:2.4
	V2-11:2.4
	V2-10:2.4
	V2-00:2.4
	V1-51:2.3
	V1-50:2.3
	V1-45:2.3
	V1-44:2.3
	V1-43:2.3
	V1-32:2.3
	V1-31:2.3
	V1-30:2.3
	V1-13:2.3
	V1-12:2.3
	V1-11:2.3
	V1-10:2.3
	newfwm-feb03:2.3.0.2
	V1-04:2.2
	V1-03:2.2
	V1-02:2.2
	JointForwardModel:2.2.0.2
	V1-00:2.2
	newfwm-sep01:1.6.0.2
	V0-7:1.6
	V0-5-Level2:1.5
	V0-5-SIPS:1.5
	V0_1:1.1;
locks; strict;
comment	@# @;


2.7
date	2011.08.26.17.54.48;	author pwagner;	state Exp;
branches;
next	2.6;

2.6
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.5;

2.5
date	2006.11.30.23.20.57;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.3;

2.3
date	2002.10.08.17.08.04;	author pwagner;	state Exp;
branches;
next	2.2;

2.2
date	2002.02.16.06.50.00;	author zvi;	state Exp;
branches;
next	2.1;

2.1
date	2002.02.16.00.04.39;	author bill;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.07.23.39.31;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.08.51.01;	author zvi;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.23.10.03;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.22.23.07.27;	author zvi;	state dead;
branches;
next	1.1;

1.1
date	2000.05.04.18.12.05;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.7
log
@purehunt recovers optimized functionality of fwdmdls own hunt
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module HYDROSTATIC_INTRP
  use MLSKINDS, only: I4, R8
  use MLSNUMERICS, only: PUREHUNT
  implicit NONE
  private
  public :: GET_HEIGHTS, GET_PRESSURES
!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: hydrostatic_intrp.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!---------------------------------------------     GET_HEIGHTS     -----
! Given an array of pressures, get set of pointing angles or heights:
!
  Subroutine GET_HEIGHTS ( ha, v_grid, t_grid, z_grid, n_i, p_out, v_out, &
 &                         n_o, ier )
!
! Given that: T(z)*dz = m*G*dh/K           (z=-Log(P))
! Given that: h =  D*Sin(a)   (Where D=Rs/(1 + ngrid), constant)
!             dh = D*Cos(a)*da
! Thus      : T(z)*dz = m*G*D*Cos(a)*da/K
! Assume that in the in the interval (z1,z2) we have:
!             T(z) = T1+w*(z-z1)     (w=(T2-T1)/(z2-z1))
! Then integrating the above over (z1,z2) gives (for delz=z2-z1):
!            delz*(T1+0.5*w*delz) = C*(Sin(a2)-Sin(a1))
! Where C=m*G*D/K, assume constant over the interval. Solving for C gives:
!       C=delz*(T1+0.5*w*delz)/(Sin(a2)-Sin(a1))
! Or:   C=delz*(T1+0.5*w*delz)/(h2-h1)
! Now, given 'z' inside (z1,z2), what is the 'a' ('a' inside (a1,a2)) ?
! let delz=z-z1, given C for that interval (z1,z2),
! Compute the integral: vl = delz*(T1+0.5*w*delz)/C
! And now h = h1 + vl   Or: a = a1 + vl
    character, intent(in) :: HA         ! ha='h' if v_grid=h_grid
                                        ! ha='a' if v_grid=ptg_angles
    real(r8), intent(in) :: V_GRID(:)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(:)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(:)   ! Input grid Log pressures
    integer(i4), intent(in) :: N_I      ! Number of input points
    real(r8), intent(in) :: P_OUT(:)    ! Output grid Log pressures
    real(r8), intent(out) :: V_OUT(:)   ! Output grid Angles or Heights
    integer(i4), intent(in) :: N_O      ! Number of output points
    integer(i4), intent(out) :: IER     ! Error flag
!
    character :: CH
    real(r8) :: COEFF(N_I), DZ
    real(r8), parameter :: EPS = 1.0e-5_r8
    integer :: I, KHI, KLO
    real(r8) :: P, RR, SA, T, V, VL, VR, W
!
    ier = 0
    ch = '@@'
    if (ha == 'h' .or. ha == 'H') ch = 'h'
    if (ha == 'a' .or. ha == 'A') ch = 'a'
    if (ch == '@@') then
      ier = 1
      Print *,'** Error in get_heights subroutine ..'
      Print *,'   variable: ha must be: "h" or "a"'
      Return
    end if
!
    call compute_coeff ( ch, n_i, v_grid, z_grid, t_grid, coeff )
!
    klo = -1
    do i = 1, n_o
      rr = p_out(i)
      call purehunt ( rr, z_grid, n_i, klo, khi )
      p = z_grid(klo)
      v = v_grid(klo)
      if (abs(rr-p) < eps) then
        v_out(i) = v
      else if (abs(rr-z_grid(khi)) < eps) then
        v_out(i) = v_grid(khi)
      else
        t = t_grid(klo)
        sa = v
        if (ch == 'a') sa = Sin(v)
        dz = z_grid(khi) - p
        w = (t_grid(khi) - t) / dz
        dz = rr - p
        vl = dz * (t + 0.5 * w * dz) / coeff(klo)
        vr = sa + vl
        if (ch == 'a') then
          if (abs(vr) <= 1.0) then
            vr = Asin(vr)
          else
            ier = 1
            Print *,'** Error in get_heights subroutine ..'
            Print *,'   Asking for ArcSin(arg) when abs(arg) > 1.0'
            Return
          end if
        end if
        v_out(i) = vr
      end if
    end do
!
    Return
  End Subroutine GET_HEIGHTS
!
!-------------------------------------------     GET_PRESSURES     -----
! Get an array of pressures from a given set of pointing angles or heights:
!
  Subroutine GET_PRESSURES ( ha, v_grid, t_grid, z_grid, n_i, v_out, p_out, &
 &                           n_o, ier )
!
! Given that: T(z)*dz = m*G*dh/K           (z=-Log(P))
! Given that: h =  H*Sin(a)   (Where H=Rs/(1 + ngrid), constant)
!             dh = H*Cos(a)*da
! Thus      : T(z)*dz = m*G*H*Cos(a)*da/K
! Assume that in the in the interval (z1,z2) we have:
!             T(z) = T1+w*(z-z1)     (w=(T2-T1)/(z2-z1))
! Then integrating the above over (z1,z2) gives (for delz=z2-z1):
!            delz*(T1+0.5*w*delz) = C*(Sin(a2)-Sin(a1))
! Where C=m*G*H/K, assume constant over the interval. Solving for C gives:
!       C=delz*(T1+0.5*w*delz)/(Sin(a2)-Sin(a1))
! Now, given a inside (a1,a2), what is the z (z inside (z1,z2)) ?
! let delz=z-z1, given C for that interval (z1,z2),
! solve the quadratic in delz: 0.5*w*delz*delz+T1*delz-C*(Sin(a)-Sin(a1))
! and get z=z1+delz which goes with the given a.

    use D_SOLVE_QUAD_M, only: SOLVE_QUAD

    character, intent(in) :: HA         ! ha='h' if v_grid=h_grid
                                        ! ha='a' if v_grid=ptg_angles
    real(r8), intent(in) :: V_GRID(:)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(:)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(:)   ! Input grid Log pressures
    integer(i4), intent(in) :: N_I      ! Number of input points
    real(r8), intent(in) :: V_OUT(:)    ! Output grid Angles or Heights
    real(r8), intent(out) :: P_OUT(:)   ! Output grid Log pressures
    integer(i4), intent(in) :: N_O      ! Number of output points
    integer(i4), intent(out) :: IER     ! Error flag
!
    real(r8) :: A, C
    character :: CH
    real(r8) :: COEFF(N_I)
    real(r8), parameter :: EPS = 1.0e-5_r8
    integer :: I, KHI, KLO
    real(r8) :: P, RR, S4, SA
    real(r8) :: T
    real(r8) :: V, W
    real(r8) :: X1, X2
!
    ier = 0
    ch = '@@'
    if (ha == 'h' .or. ha == 'H') ch = 'h'
    if (ha == 'a' .or. ha == 'A') ch = 'a'
    if (ch == '@@') then
      ier = 1
      Print *,'** Error in get_pressures subroutine ..'
      Print *,'   variable: ha must be: "h" or "a"'
      Return
    end if
!
    call compute_coeff ( ch, n_i, v_grid, z_grid, t_grid, coeff )
!
! For each output angle, solve for the zeta.
! In solving the quadratic equation, choose the smaller root always.
!
    klo = -1
    do i = 1, n_o
      rr = v_out(i)
      call purehunt ( rr, v_grid, n_i, klo, khi )
      v = v_grid(klo)
      p = z_grid(klo)
      if (abs(rr-v) < eps) then
        p_out(i) = p
      else if (abs(rr-v_grid(khi)) < eps) then
        p_out(i) = z_grid(khi)
      else
        t = t_grid(klo)
        sa = v
        if (ch == 'a') sa = Sin(sa)
        w = (t_grid(khi) - t) / (z_grid(khi) - p)
        a = 0.5 * w
        s4 = rr
        if (ch == 'a') s4 = Sin(rr)
        c = -coeff(klo) * (s4 - sa)
        Call Solve_Quad ( a, t, c, x1, x2 )
        p_out(i) = p + x2            ! Take the smaller root always
      end if
    end do
!
    Return
  End Subroutine GET_PRESSURES
! *****     Private procedure     **************************************
! ------------------------------------------     COMPUTE_COEFF     -----
  subroutine COMPUTE_COEFF ( ch, n_i, v_grid, z_grid, t_grid, coeff )

    Character, intent(in) :: CH         ! ch='h' if v_grid=h_grid
                                        ! ch='a' if v_grid=ptg_angles
    Integer(i4), intent(in) :: N_I      ! Number of input points
    Real(r8), intent(in) :: V_GRID(:)   ! Input grid Angles or Heights
    Real(r8), intent(in) :: T_GRID(:)   ! Input grid temperatures
    Real(r8), intent(in) :: Z_GRID(:)   ! Input grid Log pressures
    Real(r8), intent(out) :: COEFF(N_I)

    Integer :: I
    Real(r8) :: SAI, SAIP1
!
! Computes the coefficients (C) for each sub-interval
!
    saip1 = v_grid(1)
    if (ch == 'a') saip1 = Sin(saip1)

    do i = 1, n_i - 1
      sai = saip1
      saip1 = v_grid(i+1)
      if (ch == 'a') saip1 = Sin(saip1)
      coeff(i) = 0.5 * (z_grid(i+1) - z_grid(i))*(t_grid(i+1) + t_grid(i)) / &
                     & (saip1 - sai)
    end do

  end subroutine COMPUTE_COEFF

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: hydrostatic_intrp.f90,v 2.6 2009/06/23 18:26:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module HYDROSTATIC_INTRP
! $Log: hydrostatic_intrp.f90,v $
! Revision 2.6  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.5  2006/11/30 23:20:57  vsnyder
! Move a USE from module scope to subprogram scope
!
! Revision 2.4  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.3  2002/10/08 17:08:04  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.2  2002/02/16 06:50:00  zvi
! Some cosmetic code changes..get rid of unused varaibles
!
! Revision 2.1  2002/02/16 00:04:39  bill
! tweaked the calc a bit--wgr
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.6  2001/06/07 23:39:31  pwagner
! Added Copyright statement
!
! Revision 1.5  2001/03/29 08:51:01  zvi
! Changing the (*) toi (:) everywhere
!
! Revision 1.4  2001/01/31 01:08:48  zvi
! New version of forward model
!
! Revision 1.1  2000/05/04 18:12:05  vsnyder
! Initial conversion to Fortran 90
!
@


2.6
log
@Prevent Intel from optimizing ident string away
@
text
@d13 2
a14 2
  use MLSCommon, only: I4, R8
  use D_HUNT_M, only: HUNT
d20 1
a20 1
       "$RCSfile: $"
d78 1
a78 1
      Call hunt ( rr, z_grid, n_i, klo, khi )
d174 1
a174 1
      Call hunt ( rr, v_grid, n_i, klo, khi )
d230 1
a230 1
       "$Id: read_apriori.f90 is it here $"
d239 3
@


2.5
log
@Move a USE from module scope to subprogram scope
@
text
@d20 1
a20 1
       "$RCSfile: hydrostatic_intrp.f90,v $"
d227 1
a228 1
!---------------------------- RCS Ident Info -------------------------------
d230 2
a231 3
       "$Id: hydrostatic_intrp.f90,v 2.4 2005/06/22 18:08:19 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d233 1
d235 1
d239 3
@


2.4
log
@Reworded Copyright statement, moved rcs id
@
text
@a12 1
  use D_SOLVE_QUAD_M, only: SOLVE_QUAD
d20 1
a20 1
       "$RCSfile: $"
d131 3
d230 1
a230 1
       "$Id: $"
d238 3
@


2.3
log
@Added idents to survive zealous Lahey optimizer
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d19 3
a21 5
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id: hydrostatic_intrp.f90,v 2.2 2002/02/16 06:50:00 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
       "$RCSfile: hydrostatic_intrp.f90,v $"
d226 5
d236 3
@


2.2
log
@Some cosmetic code changes..get rid of unused varaibles
@
text
@d13 1
a13 1
       "$Id: hydrostatic_intrp.f90,v 2.1 2002/02/16 00:04:39 bill Exp $"
d16 1
d219 4
d225 3
@


2.1
log
@tweaked the calc a bit--wgr
@
text
@d13 1
a13 1
       "$Id: hydrostatic_intrp.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d191 2
a192 1
    character, intent(in) :: CH         ! ch='h' if v_grid=h_grid
d194 8
a201 8
    integer(i4), intent(in) :: N_I      ! Number of input points
    real(r8), intent(in) :: V_GRID(:)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(:)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(:)   ! Input grid Log pressures
    real(r8), intent(out) :: COEFF(N_I)
    real(r8) :: DZ
    integer :: I
    real(r8) :: SAI, SAIP1, VL, W
d207 1
d212 2
a213 6
      coeff(i) = 0.5 * (z_grid(i+1) - z_grid(i))*(t_grid(i+1) + t_grid(i)) &
               / (saip1 - sai)
!      dz = z_grid(i+1) - z_grid(i)
!      w =  (t_grid(i+1) - t_grid(i)) / dz  ! ??? Do we really want to divide
!      vl = dz * (t_grid(i) + 0.5 * w * dz) ! ??? by DZ, and then multiply?
!      coeff(i) = vl / (saip1 - sai)
d215 1
d217 1
d220 3
@


2.0
log
@New forward model
@
text
@d13 1
a13 1
       "$Id: hydrostatic_intrp.f90,v 1.6 2001/06/07 23:39:31 pwagner Exp $"
d210 6
a215 4
      dz = z_grid(i+1) - z_grid(i)
      w = (t_grid(i+1) - t_grid(i)) / dz   ! ??? Do we really want to divide
      vl = dz * (t_grid(i) + 0.5 * w * dz) ! ??? by DZ, and then multiply?
      coeff(i) = vl / (saip1 - sai)
d220 3
@


1.6
log
@Added Copyright statement
@
text
@d13 1
a13 1
       "$Id: hydrostatic_intrp.f90,v 1.5 2001/03/29 08:51:01 zvi Exp $"
d218 3
@


1.5
log
@Changing the (*) toi (:) everywhere
@
text
@d1 3
d13 1
a13 1
       "$Id: hydrostatic_intrp.f90,v 1.4 2001/01/31 01:08:48 zvi Exp $"
d218 3
@


1.4
log
@New version of forward model
@
text
@d10 1
a10 1
       "$Id: hydrostatic_intrp.f90,v 1.1 2000/05/04 18:12:05 vsnyder Exp $"
d38 3
a40 3
    real(r8), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
d42 2
a43 2
    real(r8), intent(in) :: P_OUT(*)    ! Output grid Log pressures
    real(r8), intent(out) :: V_OUT(*)   ! Output grid Angles or Heights
d124 3
a126 3
    real(r8), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
d128 2
a129 2
    real(r8), intent(in) :: V_OUT(*)    ! Output grid Angles or Heights
    real(r8), intent(out) :: P_OUT(*)   ! Output grid Log pressures
d191 3
a193 3
    real(r8), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r8), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r8), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
d215 3
@


1.3
log
@Re-add basic stuff
@
text
@@


1.2
log
@New version
@
text
@d3 2
a4 2
  use MLSCommon, only: I4, R4, R8
  use S_HUNT_M, only: HUNT
a7 1

a13 1

a35 1

d38 3
a40 3
    real(r4), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r4), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r4), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
d42 2
a43 2
    real(r4), intent(in) :: P_OUT(*)    ! Output grid Log pressures
    real(r4), intent(out) :: V_OUT(*)   ! Output grid Angles or Heights
d51 1
a51 1
    real(r4) :: P, RR, SA, T, V, VL, VR, W
a121 1

d124 3
a126 3
    real(r4), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r4), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r4), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
d128 2
a129 2
    real(r4), intent(in) :: V_OUT(*)    ! Output grid Angles or Heights
    real(r4), intent(out) :: P_OUT(*)   ! Output grid Log pressures
d135 1
a135 1
    real(r8) :: COEFF(N_I), DZ
d138 1
a138 1
    real(r4) :: P, RR, S4, SA
d140 1
a140 1
    real(r4) :: V, VL, W
a184 1

a185 1

d191 3
a193 3
    real(r4), intent(in) :: V_GRID(*)   ! Input grid Angles or Heights
    real(r4), intent(in) :: T_GRID(*)   ! Input grid temperatures
    real(r4), intent(in) :: Z_GRID(*)   ! Input grid Log pressures
a194 1

d197 1
a197 1
    real(r4) :: SAI, SAIP1, VL, W
a213 1

@


1.1
log
@Initial conversion to Fortran 90
@
text
@d11 1
a11 1
       "$Id: HYDROSTATIC_INTRP,v 1.12 2000/02/08 19:54:57 vsnyder Exp $"
d222 4
a225 1
! $Log: HYDROSTATIC_INTRP,v $
@

