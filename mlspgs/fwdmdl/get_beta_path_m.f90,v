head	2.121;
access;
symbols
	v5-02-NRT-19:2.121
	v6-00:2.121
	v5-02-NRT-18:2.121
	v5-02:2.121
	v5-01-NRT-17:2.121
	v5-01-NRT-16:2.121
	v5-01-NRT-15:2.121
	v5-01-NRT-14:2.121
	neuralnetworks-1-0:2.121.0.10
	cfm-single-freq-0-1:2.121.0.8
	v5-01:2.121
	v5-00:2.121
	v4-23-TA133:2.121.0.6
	mus-emls-1-70:2.121.0.4
	rel-1-0-englocks-work:2.121.0.2
	VUMLS1-00:2.120
	VPL1-00:2.120
	V4-22-NRT-08:2.120
	VAM1-00:2.120
	V4-21:2.120.0.2
	V4-13:2.120
	V4-12:2.120
	V4-11:2.120
	V4-10:2.120
	V3-43:2.101
	M4-00:2.112
	V3-41:2.101
	V3-40-PlusGM57:2.101.0.2
	V2-24-NRT-04:2.91
	V3-33:2.102
	V2-24:2.91
	V3-31:2.102
	V3-30-NRT-05:2.101
	cfm-01-00:2.101
	V3-30:2.101
	V3-20:2.101
	V3-10:2.97
	V2-23-NRT-02:2.91
	V2-23:2.91
	V2-22-NRT-01:2.91
	V2-22:2.91
	V2-21:2.89
	V2-20:2.89
	V2-11:2.89
	V2-10:2.89
	V2-00:2.87
	V1-51:2.69
	V1-50:2.69
	V1-45:2.61
	V1-44:2.61
	V1-43:2.58
	V1-32:2.48
	V1-31:2.48
	V1-30:2.47
	V1-13:2.26
	V1-12:2.26
	V1-11:2.26
	V1-10:2.24
	newfwm-feb03:2.25.0.2
	V1-04:2.7
	V1-03:2.7
	V1-02:2.7
	JointForwardModel:2.7.0.2
	V1-00:2.7
	newfwm-sep01:1.22.0.2
	V0-7:1.22
	V0-5-Level2:1.18
	V0-5-SIPS:1.16;
locks; strict;
comment	@# @;


2.121
date	2018.01.31.21.26.35;	author vsnyder;	state Exp;
branches;
next	2.120;

2.120
date	2014.04.22.00.09.01;	author vsnyder;	state Exp;
branches;
next	2.119;

2.119
date	2014.04.04.19.43.10;	author vsnyder;	state Exp;
branches;
next	2.118;

2.118
date	2014.04.02.17.04.53;	author wgread;	state Exp;
branches;
next	2.117;

2.117
date	2013.08.30.03.56.23;	author vsnyder;	state Exp;
branches;
next	2.116;

2.116
date	2013.07.26.22.19.05;	author vsnyder;	state Exp;
branches;
next	2.115;

2.115
date	2013.06.12.02.25.18;	author vsnyder;	state Exp;
branches;
next	2.114;

2.114
date	2013.05.22.00.08.43;	author vsnyder;	state Exp;
branches;
next	2.113;

2.113
date	2013.05.17.22.52.32;	author vsnyder;	state Exp;
branches;
next	2.112;

2.112
date	2011.11.22.00.40.40;	author vsnyder;	state Exp;
branches;
next	2.111;

2.111
date	2011.11.11.00.40.41;	author vsnyder;	state Exp;
branches;
next	2.110;

2.110
date	2011.11.09.00.15.40;	author vsnyder;	state Exp;
branches;
next	2.109;

2.109
date	2011.08.26.17.54.15;	author pwagner;	state Exp;
branches;
next	2.108;

2.108
date	2011.08.25.18.17.46;	author vsnyder;	state Exp;
branches;
next	2.107;

2.107
date	2011.07.29.01.57.47;	author vsnyder;	state Exp;
branches;
next	2.106;

2.106
date	2011.05.09.17.56.27;	author pwagner;	state Exp;
branches;
next	2.105;

2.105
date	2011.03.31.19.53.55;	author vsnyder;	state Exp;
branches;
next	2.104;

2.104
date	2011.03.04.03.42.48;	author vsnyder;	state Exp;
branches;
next	2.103;

2.103
date	2011.03.02.02.06.59;	author vsnyder;	state Exp;
branches;
next	2.102;

2.102
date	2011.02.12.03.57.40;	author vsnyder;	state Exp;
branches;
next	2.101;

2.101
date	2010.02.09.21.04.18;	author vsnyder;	state Exp;
branches;
next	2.100;

2.100
date	2010.02.05.03.29.09;	author vsnyder;	state Exp;
branches;
next	2.99;

2.99
date	2010.02.04.23.10.38;	author vsnyder;	state Exp;
branches;
next	2.98;

2.98
date	2010.01.23.01.20.15;	author vsnyder;	state Exp;
branches;
next	2.97;

2.97
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.96;

2.96
date	2009.06.16.17.37.47;	author pwagner;	state Exp;
branches;
next	2.95;

2.95
date	2009.06.13.01.10.01;	author vsnyder;	state Exp;
branches;
next	2.94;

2.94
date	2008.10.03.16.29.56;	author livesey;	state Exp;
branches;
next	2.93;

2.93
date	2008.04.18.22.51.30;	author vsnyder;	state Exp;
branches;
next	2.92;

2.92
date	2008.02.29.01.59.39;	author vsnyder;	state Exp;
branches;
next	2.91;

2.91
date	2007.05.23.22.44.24;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2006.12.04.21.17.28;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2006.07.19.22.30.17;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2006.06.29.01.44.42;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2006.04.11.18.32.41;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2006.04.05.19.16.49;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2006.02.23.01.00.17;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2006.02.10.21.50.33;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2006.02.08.21.38.18;	author vsnyder;	state Exp;
branches;
next	2.82;

2.82
date	2006.02.08.01.02.22;	author vsnyder;	state Exp;
branches;
next	2.81;

2.81
date	2005.10.24.20.19.35;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2005.07.06.02.17.21;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2005.06.09.02.34.16;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2005.06.03.01.58.53;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2005.05.24.01.55.18;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2005.05.02.23.05.01;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2005.03.29.01.58.17;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2005.03.26.01.26.29;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2005.03.25.21.04.57;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2005.03.03.02.07.10;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2005.02.17.02.35.13;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2005.02.16.23.16.50;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2004.12.13.20.47.52;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2004.11.04.03.42.09;	author vsnyder;	state Exp;
branches;
next	2.67;

2.67
date	2004.11.01.20.26.36;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2004.10.06.21.21.21;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2004.09.04.01.50.31;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2004.09.02.18.14.29;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2004.09.01.01.48.13;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2004.08.31.18.32.17;	author vsnyder;	state Exp;
branches;
next	2.61;

2.61
date	2004.08.05.20.59.02;	author vsnyder;	state Exp;
branches;
next	2.60;

2.60
date	2004.08.03.22.06.45;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2004.07.08.21.00.23;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2004.04.19.21.03.29;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2004.04.17.00.37.00;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2004.04.02.00.59.24;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2004.03.27.03.35.27;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2004.03.20.04.08.55;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2004.03.20.01.15.23;	author jonathan;	state Exp;
branches;
next	2.52;

2.52
date	2004.03.19.04.07.31;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2004.03.19.00.47.02;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2004.02.27.22.47.32;	author bill;	state Exp;
branches;
next	2.49;

2.49
date	2004.01.26.21.57.00;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2003.12.07.19.46.10;	author jonathan;	state Exp;
branches;
next	2.47;

2.47
date	2003.08.20.21.12.39;	author bill;	state Exp;
branches;
next	2.46;

2.46
date	2003.07.15.17.50.30;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2003.07.14.22.45.09;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2003.07.11.22.43.37;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2003.07.09.22.47.43;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2003.07.07.19.53.51;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2003.07.07.19.08.38;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2003.07.07.16.47.01;	author pwagner;	state Exp;
branches;
next	2.39;

2.39
date	2003.07.04.02.47.50;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2003.06.27.22.09.19;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2003.06.18.17.23.40;	author bill;	state Exp;
branches;
next	2.36;

2.36
date	2003.06.18.14.44.53;	author bill;	state Exp;
branches;
next	2.35;

2.35
date	2003.06.02.22.41.33;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2003.05.16.23.51.51;	author livesey;	state Exp;
branches;
next	2.33;

2.33
date	2003.05.15.03.28.52;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2003.05.10.00.48.09;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2003.05.09.20.07.07;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.05.09.19.24.38;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2003.05.05.23.00.25;	author livesey;	state Exp;
branches;
next	2.28;

2.28
date	2003.04.24.16.47.47;	author dwu;	state Exp;
branches;
next	2.27;

2.27
date	2003.04.22.00.16.16;	author dwu;	state Exp;
branches;
next	2.26;

2.26
date	2003.02.13.23.06.01;	author jonathan;	state Exp;
branches;
next	2.25;

2.25
date	2003.02.11.00.48.18;	author jonathan;	state Exp;
branches
	2.25.2.1;
next	2.24;

2.24
date	2003.02.07.01.57.19;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2003.02.07.01.08.34;	author jonathan;	state Exp;
branches;
next	2.22;

2.22
date	2003.02.06.22.12.49;	author jonathan;	state Exp;
branches;
next	2.21;

2.21
date	2003.02.06.00.20.16;	author jonathan;	state Exp;
branches;
next	2.20;

2.20
date	2003.02.04.22.03.33;	author jonathan;	state Exp;
branches;
next	2.19;

2.19
date	2003.02.04.21.46.27;	author jonathan;	state Exp;
branches;
next	2.18;

2.18
date	2003.02.03.22.56.58;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2003.01.31.18.45.09;	author jonathan;	state Exp;
branches;
next	2.16;

2.16
date	2003.01.31.17.53.48;	author jonathan;	state Exp;
branches;
next	2.15;

2.15
date	2003.01.31.17.16.08;	author jonathan;	state Exp;
branches;
next	2.14;

2.14
date	2003.01.30.17.43.04;	author jonathan;	state Exp;
branches;
next	2.13;

2.13
date	2003.01.30.00.17.42;	author jonathan;	state Exp;
branches;
next	2.12;

2.12
date	2003.01.14.21.49.33;	author jonathan;	state Exp;
branches;
next	2.11;

2.11
date	2003.01.08.00.17.29;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2002.12.13.02.06.51;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.10.08.17.08.03;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2002.09.12.23.00.04;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2001.12.23.23.30.42;	author zvi;	state Exp;
branches;
next	2.6;

2.6
date	2001.12.14.23.43.15;	author zvi;	state Exp;
branches;
next	2.5;

2.5
date	2001.11.15.01.22.01;	author zvi;	state Exp;
branches;
next	2.4;

2.4
date	2001.11.10.00.46.40;	author zvi;	state Exp;
branches;
next	2.3;

2.3
date	2001.11.07.22.24.45;	author zvi;	state Exp;
branches;
next	2.2;

2.2
date	2001.11.07.21.13.48;	author livesey;	state Exp;
branches;
next	2.1;

2.1
date	2001.10.16.15.07.18;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.21.13.07.08;	author zvi;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.05.16.00.42.10;	author livesey;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.15.03.47.26;	author zvi;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.14.23.14.54;	author zvi;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.03.22.17.32;	author vsnyder;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.02.20.49.23;	author zvi;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.05.21.58.47;	author zvi;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.03.07.32.45;	author zvi;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.31.23.40.55;	author zvi;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.29.08.51.01;	author zvi;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.20.23.22.40;	author zvi;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.20.11.03.16;	author zvi;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.20.02.29.26;	author livesey;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.15.12.18.03;	author zvi;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.09.02.26.11;	author vsnyder;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.02.11.28;	author vsnyder;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.05.21.37.20;	author zvi;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.19.22.20.40;	author zvi;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.19.22.14.21;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.03.02.07.01;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.23.07.27;	author zvi;	state Exp;
branches;
next	;

2.25.2.1
date	2003.02.13.17.34.27;	author bill;	state Exp;
branches;
next	2.25.2.2;

2.25.2.2
date	2003.02.13.22.26.30;	author jonathan;	state Exp;
branches;
next	2.25.2.3;

2.25.2.3
date	2003.02.14.00.21.42;	author jonathan;	state Exp;
branches;
next	2.25.2.4;

2.25.2.4
date	2003.02.24.23.40.38;	author jonathan;	state Exp;
branches;
next	2.25.2.5;

2.25.2.5
date	2003.02.27.23.19.23;	author vsnyder;	state Exp;
branches;
next	2.25.2.6;

2.25.2.6
date	2003.03.01.03.16.15;	author vsnyder;	state Exp;
branches;
next	2.25.2.7;

2.25.2.7
date	2003.03.12.21.35.44;	author vsnyder;	state Exp;
branches;
next	2.25.2.8;

2.25.2.8
date	2003.03.22.04.03.04;	author vsnyder;	state Exp;
branches;
next	2.25.2.9;

2.25.2.9
date	2003.03.24.21.50.44;	author jonathan;	state Exp;
branches;
next	;

1.22.2.1
date	2001.09.10.10.02.32;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.121
log
@Cosmetic changes
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module GET_BETA_PATH_M

  implicit NONE
  private
  public :: Create_Beta, Create_Beta_Path, Create_Beta_Path_PFA
  public :: Get_Beta_Path, Get_Beta_Path_Cloud, Get_Beta_Path_PFA
  public :: Get_Beta_Path_Polarized, Get_Beta_Path_Scalar

  interface Get_Beta_Path
    module procedure Get_Beta_Path_Scalar, Get_Beta_Path_Polarized
  end interface

  ! RHi = H2O * exp(RHa - RHb/T) / P
  real, parameter, private :: RHa = 19.6783
  real, parameter, private :: RHb = 6140.4

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: ModuleName= &
    &  "$RCSfile: get_beta_path_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains

! ---------------------------------------  Get_Beta_Path_Scalar  -----
  subroutine Get_Beta_Path_Scalar ( frq, Flo, p_path, t_path, tanh_path, &
        & beta_group, SX, NoPolarized, gl_slabs, path_inds,         &
        & beta_path, t_der_path_flags, dTanh_dT, VelCor,            &
        & dBeta_dt_path, dBeta_dw_path, dBeta_dn_path, dBeta_dv_path, &
        & dBeta_df_path, Where_dBeta_df, Sps_Path )

    use Dump_0, only: Dump
    use ForwardModelConfig, only: Beta_Group_T, LineCenter, LineWidth, &
      & LineWidth_Tdep
    use Intrinsic, only: Lit_Indices
    use MLSKinds, only: R8, RP, IP
    use MLSStringLists, only: SwitchDetail
    use Molecules, only: L_RHI
    use Output_M, only: Output
    use SLABS_SW_M, only: SLABS_Struct
    use String_Table, only: Display_String
    use Toggles, only: Emit, Levels, Switches, Toggle
    use Trace_M, only: Trace_Begin, Trace_End

! Inputs:

    real(r8), intent(in) :: Frq          ! frequency in MHz
    real(r8), intent(in) :: Flo          ! LO frequency in MHz
    real(rp), intent(in) :: P_path(:)    ! pressures on combined coarse & fine
                                         ! path in hPa.  Use the subset
                                         ! selected by path_inds.
    real(rp), intent(in) :: T_path(:)    ! path temperatures, already selected
                                         ! from combined coarse & fine path by
                                         ! path_inds.
    real(rp), intent(in) :: Tanh_path(:) ! tanh(0.5*h_over_k*frq / t_path)
    type (slabs_struct), dimension(:,:), intent(in) :: Gl_slabs ! Single-line
                                         ! absorption data on the combined
                                         ! coarse & fine path.  Use the subset
                                         ! selected by path_inds.
    integer(ip), intent(in) :: Path_inds(:) ! indices in combined coarse & fine
                                         ! path for reading p_path and gl_slabs.

    type (beta_group_t), intent(in), dimension(:) :: beta_group
    integer, intent(in) :: SX            ! Sideband index, 1 or 2.

    logical, intent(in) :: NoPolarized   ! "Don't work on Zeeman-split lines"

! Optional inputs.

    logical, intent(in) :: t_der_path_flags(:) ! where temperature derivatives
!                               are needed. Only useful for subsetting.
    real(rp), intent(in) :: dTanh_dT(:)    ! dTanh( (-h nu) / (k T) ) / dT on path

! Input for spectroscopy derivatives
    real(rp), intent(in) :: VelCor

! Input for H2O continuum.  Optional so PFA table generation can leave it off.
    real(rp), intent(in), optional :: Sps_Path(:,:) ! Mixing ratios, Path X Species

! Outputs

    real(rp), intent(out) :: beta_path(:,:) ! path beta for each species, km^{-1}

! Optional outputs.  We use size(.)>0 instead of PRESENT so that the
! caller doesn't need multiple branches.

    real(rp), target, intent(out) :: dBeta_dT_path(:,:) ! Temperature
    real(rp), target, intent(out) :: dBeta_dw_path(:,:) ! line width
    real(rp), target, intent(out) :: dBeta_dn_path(:,:) ! line width t dep.
    real(rp), target, intent(out) :: dBeta_dv_path(:,:) ! line position
    real(rp), target, intent(out) :: dBeta_df_path(:,:) ! mixing ratio
    ! Which column of dBeta_df_path to use for a molecule.  Do not compute if
    ! zero.
    integer, intent(in) :: Where_dBeta_df(:)

! Local variables.

    character(len=4), save :: clean
    real(rp), pointer :: dBdf(:), dBdn(:), dBdT(:), dBdv(:), dBdw(:) ! slices of dBeta_d*_path
    integer, save :: DumpLevel ! units digit of lblb switch
                               ! >0 dump beta, >1 dump T, Tanh
    logical, save :: DumpStop  ! hundreds digit of lblb switch > 0
    logical, save :: DumpZeta  ! tens digit of lblb switch > 0, dump Zeta
                               ! instead of P
    real(rp) :: ES(size(t_path)) ! Used for RHi calculation
    logical, save :: First = .true. ! Fist-time flag
    real(rp) :: Sps(size(t_path))
    integer(ip) :: I, N, NP
    integer :: Me = -1         ! String index for trace

! begin the code

    if ( first ) then
      first = .false.
      dumpLevel = switchDetail(switches,'lblb')
      dumpStop = dumpLevel > 99
      dumpZeta = mod(dumpLevel/10,10) > 0
      if ( dumpLevel >= 0 ) dumpLevel = mod(dumpLevel,10)
      ! clean = switchDetail(switches,'clean') > -1
      clean = ' '
      if ( switchDetail(switches,'clean') > -1 ) clean = 'c'
    end if

    call Trace_Begin ( me, 'ForwardModel.Get_Beta_Path_Scalar', &
      & cond=toggle(emit) .and. levels(emit) > 6 )

    nullify ( dBdf, dBdn, dBdT, dBdv, dBdw ) ! Disassociated means "Don't compute it"

    np = size(beta_path,1)

    do i = 1, size(beta_group)
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineWidth_tDep) /= 0 .and. size(dBeta_dn_path) > 0 ) then
        dBdn => dBeta_dn_path(:np,beta_group(i)%lbl(sx)%spect_der_ix(lineWidth_tDep))
        dBdn = 0.0_rp
      end if
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineCenter) /= 0 .and. size(dBeta_dv_path) > 0 ) then
        dBdv => dBeta_dv_path(:np,beta_group(i)%lbl(sx)%spect_der_ix (lineCenter))
        dBdv = 0.0_rp
      end if
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineWidth) /= 0 .and. size(dBeta_dw_path) > 0 ) then
        dBdw => dBeta_dw_path(:np,beta_group(i)%lbl(sx)%spect_der_ix(lineWidth))
        dBdw = 0.0_rp
      end if

      beta_path(:,i) = 0.0_rp
      if ( size(dBeta_dt_path) > 0 ) then
        dBdT => dBeta_dt_path(:np,i)
        dBdT = 0.0_rp
      end if

      if ( size(dBeta_df_path) > 0 ) then
        if ( where_dBeta_df(i) > 0 ) then
          dBdf => dBeta_df_path(:np,where_dBeta_df(i))
          dBdf = 0.0
        end if
      end if

      if ( present(sps_path) ) sps = sps_path(path_inds,i)
      if ( beta_group(i)%molecule == l_rhi ) then
        !{ Get ready for RHi conversion
        ! \begin{equation}\begin{split}
        ! e_s =\,& \frac1P \exp\left(19.6783-\frac{6140.4}T\right)\\
        ! \beta^{\text{RHi}} =\,& \beta^{\text{H}_2\text{O}} e_s\\
        ! \frac{\partial \beta^{\text{RHi}}}{\partial T} =\,&
        !  e_s \frac{\partial \beta^{\text{H}_2\text{O}}}{\partial T} +
        !  \frac{6140.4}{T^2} \beta^{\text{RHi}}
        ! \end{split}\end{equation}
        es = exp(RHa - RHb/t_path) / p_path(path_inds)
        if ( present(sps_path) ) then
          sps = es * sps
          where ( p_path(path_inds) < 50.0 ) sps = 0.0
        end if
      end if

      do n = 1, size(beta_group(i)%lbl(sx)%cat_index)
        if ( present(sps_path) ) then
          call create_beta_path ( path_inds, p_path, t_path, frq, flo,  &
            & beta_group(i)%lbl(sx)%ratio(n),                       &
            & gl_slabs(:,beta_group(i)%lbl(sx)%cat_index(n)),       &
            & tanh_path, noPolarized, velCor,                       &
            & beta_path(:,i), dTanh_dT, t_der_path_flags,           &
            & dBdT, dBdw, dBdn, dBdv, dBdf, sps_path=sps )
        else
          call create_beta_path ( path_inds, p_path, t_path, frq, flo,  &
            & beta_group(i)%lbl(sx)%ratio(n),                       &
            & gl_slabs(:,beta_group(i)%lbl(sx)%cat_index(n)),       &
            & tanh_path, noPolarized, velCor,                       &
            & beta_path(:,i), dTanh_dT, t_der_path_flags,           &
            & dBdT, dBdw, dBdn, dBdv, dBdf )
        end if

        if ( dumpLevel > 0 ) then
          call display_string ( lit_indices(beta_group(i)%lbl(sx)%molecules(1:n)), &
            & before='LBL Betas for' )
          call output ( frq, before=', FRQ = ', advance='yes' )
          call dump ( beta_path(:,i), name='beta', options=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', options=clean )
          if ( associated(dBdf) ) call dump ( dBdf, name='dBdf', options=clean )
        end if
      end do

      if ( beta_group(i)%molecule == l_rhi ) then
        ! Convert specific humidity to relative humidity?
        beta_path(:,i) = beta_path(:,i) * es
        if ( associated(dBdT) ) &
          & dBdT = es * dBdT + RHb / t_path**2 * beta_path(:,i)

        if ( dumpLevel > 0 ) then
          call display_string ( lit_indices(l_rhi), before='LBL Betas for ' )
          call display_string ( lit_indices(beta_group(i)%lbl(sx)%molecules), &
            & before=' using' )
          call dump ( beta_path(:,i), options=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', options=clean )
        end if
      end if

    end do ! i = 1, size(beta_group)

    call Trace_End ( 'ForwardModel.Get_Beta_Path_Scalar', &
      & cond=toggle(emit) .and. levels(emit) > 6 )

    if ( dumpLevel > 1 ) then
      if ( dumpZeta ) then
        call dump ( -log10(p_path(path_inds)), name='Zetas', options=clean )
      else
        call dump ( p_path(path_inds), name='Pressures', options=clean )
      end if
      call dump ( t_path, name='Temperatures', options=clean )
      call dump ( tanh_path, name='tanh(h nu / k T)', options=clean )
    end if
    if ( dumpStop ) stop

  end subroutine Get_Beta_Path_Scalar

  ! ------------------------------------------  Get_Beta_Path_PFA  -----
  subroutine Get_Beta_Path_PFA ( Frq, Frq_i, P_Path, Path_Inds, T_Path, &
    & Beta_Group, SX, Vel_Rel, Sps_Path, Beta_Path, T_Der_Path_Flags, &
    & dBeta_dT_Path, dBeta_dw_Path, dBeta_dn_Path, dBeta_dv_Path, &
    & dBeta_dIWC_Path )

    use Dump_0, only: Dump
    use ForwardModelConfig, only: Beta_Group_T
    use Intrinsic, only: Lit_Indices
    use MLSKinds, only: RP, R8
    use MLSStringLists, only: SwitchDetail
    use Molecules, only: L_Cloudice, L_RHI
    use Output_M, only: Output
    use PFADatabase_M, only: PFAData
    use Read_Mie_M, only: Beta_C_A, DBeta_DIWC_C_A, DBeta_DT_C_A, &
                        & Beta_C_S, DBeta_DIWC_C_S, DBeta_DT_C_S
    use String_Table, only: Display_String
    use Toggles, only: Switches

! Inputs
    real(r8), intent(in) :: Frq         ! Channel center frequency in MHz
    integer, intent(in) :: Frq_i        ! Channel index
    real(rp), intent(in) :: P_path(:)   ! path pressures in hPa!
    integer, intent(in) :: Path_inds(:) ! indicies for reading P_path
    real(rp), intent(in) :: T_path(:)   ! path temperatures
    type(beta_group_t), intent(in) :: Beta_Group(:) ! PFA stuff for the beta group
    integer, intent(in) :: SX           ! Sideband index, 1 or 2.
    real(rp), intent(in) :: Vel_Rel     ! LOS Vel / C
    real(rp), intent(in) :: Sps_Path(:,:) ! VMR's, for nonlinear species

! Output
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each species, km^{-1}

! Optional input.

    logical, intent(in) :: T_Der_Path_Flags(:) ! where temperature derivatives
!                               are needed. Only useful for subsetting.

! Optional outputs.  We use size(...)/=0 instead of PRESENT so that the
! caller doesn't need multiple branches.

    real(rp), target, intent(out) :: dBeta_dT_path(:,:)   ! Temperature
    real(rp), target, intent(out) :: dBeta_dw_path(:,:)   ! line width
    real(rp), target, intent(out) :: dBeta_dn_path(:,:)   ! line width t dep.
    real(rp), target, intent(out) :: dBeta_dv_path(:,:)   ! line position
    real(rp), target, intent(out) :: dBeta_dIWC_path(:,:) ! IWC

    real(rp), pointer :: dBdIWC(:), dBdn(:), dBdT(:), dBdv(:), dBdw(:) ! slices of dBeta_d*_path
    real(rp) :: ES(size(t_path)) ! Used for RHi calculation
    integer :: I, J, NP
    character(len=4), save :: clean
    logical, save :: DumpAll, DumpBeta, DumpStop
    logical, save :: First = .true. ! First-time flag
    integer :: PFAB ! Dump level 0 => Beta, 1 => Temperature + pressure, 2 => stop

    if ( first ) then
      first = .false.
      pfab = switchDetail(switches,'pfab')
      dumpStop = pfab > 1
      dumpAll = pfab > 0
      dumpBeta = pfab >= 0
      ! clean = switchDetail(switches,'clean') > -1
      clean = ' '
      if ( switchDetail(switches,'clean') > -1 ) clean = 'c'
    end if

    nullify ( dBdIWC, dBdT, dBdn, dBdv, dBdw )

    np = size(t_path)

    do i = 1, size(beta_group)
      if ( size(dBeta_dt_path) > 0 ) then
        dBdT => dBeta_dt_path(:np,i)
        dBdT = 0.0_rp
      end if
      if ( size(dBeta_dn_path) > 0 ) then
        dBdn => dBeta_dn_path(:np,i)
        dBdn = 0.0_rp
      end if
      if ( size(dBeta_dv_path) > 0 ) then
        dBdv => dBeta_dv_path(:np,i)
        dBdv = 0.0_rp
      end if
      if ( size(dBeta_dw_path) > 0 ) then
        dBdw => dBeta_dw_path(:np,i)
        dBdw = 0.0_rp
      end if
      if ( size(dBeta_dIWC_path) > 0 ) then
        dBdIWC => dBeta_dIWC_path(:np,i)
        dBdIWC = 0.0_rp
      end if

      beta_path(:,i) = 0.0_rp

      select case ( beta_group(i)%molecule )
      case ( l_cloudIce )
        call create_beta_path_Mie ( frq, t_path, sps_path(:,i), path_inds, &
          & beta_c_a, dBeta_dIWC_c_a, dBeta_dT_c_a, beta_path(:,i), &
          & dBdT, dBdIWC )
        call create_beta_path_Mie ( frq, t_path, sps_path(:,i), path_inds, &
          & beta_c_s, dBeta_dIWC_c_s, dBeta_dT_c_s, beta_path(:,i), &
          & dBdT, dBdIWC )
      case default
        do j = 1, size(beta_group(i)%pfa(sx)%molecules)
          if ( beta_group(i)%pfa(sx)%data(frq_i,j)/= 0 ) then
            call create_beta_path_PFA ( frq, p_path, path_inds, t_path, vel_rel, &
              & PFAData(beta_group(i)%pfa(sx)%data(frq_i,j)),   &
              & beta_group(i)%pfa(sx)%ratio(j), beta_path(:,i), &
              & t_der_path_flags, dBdT, dBdw, dBdn, dBdv )

            if ( dumpBeta ) then
              call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules(1:j)), &
              & before='PFA Betas for' )
              call output ( frq, before=', FRQ = ', advance='yes' )
              call dump ( beta_path(:,i), name='Beta', options=clean )
              if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', options=clean )
            end if
          end if
        end do ! j = 1, size(beta_group(i)%pfa(sx)%molecules)

        if ( beta_group(i)%molecule == l_rhi ) then
          !{ Convert specific humidity to relative humidity
          ! \begin{equation}\begin{split}
          ! e_s =\,& \frac1P \exp\left(19.6783-\frac{6140.4}T\right)\\
          ! \beta^{\text{RHi}} =\,& \beta^{\text{H}_2\text{O}} e_s\\
          ! \frac{\partial \beta^{\text{RHi}}}{\partial T} =\,&
          !  e_s \frac{\partial \beta^{\text{H}_2\text{O}}}{\partial T} +
          !  \frac{6140.4}{T^2} \beta^{\text{RHi}}
          ! \end{split}\end{equation}
          es = exp(RHa - RHb/t_path) / p_path(path_inds)
          beta_path(:,i) = beta_path(:,i) * es
          if ( associated(dBdT) ) &
            & dBdT = es * dBdT + RHb / t_path**2 * beta_path(:,i)

          if ( dumpBeta ) then
            call display_string ( lit_indices(l_rhi), before='PFA Betas for ' )
            call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules), &
              & before=' using' )
            call dump ( beta_path(:,i), name='Beta', options=clean )
            if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', options=clean )
          end if
        end if
      end select

    end do ! i = 1, size(beta_group)

    if ( dumpAll ) then
      call dump ( p_path(path_inds), name='Pressures', options=clean )
      call dump ( t_path, name='Temperatures', options=clean )
    end if
    if ( dumpStop ) stop

  end subroutine Get_Beta_Path_PFA

  ! ------------------------------------  Get_Beta_Path_Polarized  -----
  subroutine Get_Beta_Path_Polarized ( Frq, H, Beta_group, GL_slabs, &
                                     & Path_inds, Beta_path, dBeta_path_dT )

    use Dump_0, only: Dump
    use ForwardModelConfig, only: LBL_T
    use Intrinsic, only: Lit_Indices
    use MLSKinds, only: R8, RP, IP
    use MLSStringLists, only: SwitchDetail
    use O2_ABS_CS_M, only: O2_ABS_CS, D_O2_ABS_CS_DT
    use Output_M, only: Output
    use SLABS_SW_M, only: SLABS_Struct
    use String_Table, only: Display_String
    use Toggles, only: Switches

! Inputs:

    real(r8), intent(in) :: Frq       ! Frequency in MHz
    real(rp), intent(in) :: H(:)      ! Magnetic field component in instrument
                                      ! polarization on the path
    type (slabs_struct), dimension(:,:), intent(in) :: GL_slabs
    integer(ip), intent(in) :: Path_inds(:) ! indicies for reading gl_slabs
    type (LBL_T), dimension(:), intent(in) :: Beta_group

! Outputs

!{ The variable {\tt Beta\_Path} isn't really $\beta$.  It lacks a factor of
!  $\tanh\left( \frac{h \nu}{2 k T}\right)$.  This is put in after we
!  compute the weighted average over species, saving as many multiplies as
!  there are species.

    complex(rp), intent(out) :: Beta_path(-1:,:,:) ! path beta for each speciess, km^{-1}
    ! beta_path(-1,:,:) is Sigma_m, beta_path(0,:,:) is Pi,
    ! beta_path(+1,:,:) is Sigma_p

    complex(rp), intent(out) :: dBeta_path_dT(-1:,:,:)

! Local variables..

    integer(ip) :: I, IB, J, K, N, N_PATH
    real(rp) :: RATIO ! Isotope ratio, not mixing ratio
    complex(rp) :: Sigma_m, Pi, Sigma_p
    complex(rp) :: dSigma_m_dT, dPi_dT, dSigma_p_dT
    character(len=4), save :: clean
    logical, save :: DumpBeta, DumpStop
    logical, save :: First = .true. ! First-time flag

    if ( first ) then
      first = .false.
      dumpStop = switchDetail(switches,'POLB') > -1
      dumpBeta = dumpStop .or. ( switchDetail(switches,'polb') > -1 )
      ! clean = switchDetail(switches,'clean') > -1
      clean = ' '
      if ( switchDetail(switches,'clean') > -1 ) clean = 'c'
    end if

! begin the code

    n_path = size(path_inds)

    beta_path = 0.0
    if ( size(dBeta_path_dT) > 0 ) dBeta_path_dT = 0.0

    do i = 1, size(beta_group)
      do n = 1, size(beta_group(i)%cat_index)
        ratio = beta_group(i)%ratio(n)
        ib = beta_group(i)%cat_index(n)

        ! Get beta everywhere on the path
        do j = 1, n_path
          k = path_inds(j)

          if ( size(dBeta_path_dT) == 0 ) then
            call o2_abs_cs ( frq, h(k), gl_slabs(k,ib), &
                           & sigma_p, pi, sigma_m )
          else
            call d_o2_abs_cs_dT ( frq, h(k), gl_slabs(k,ib),    &
                                & sigma_p,     pi,     sigma_m, &
                                & dSigma_p_dT, dPi_dT, dSigma_m_dT )
            dBeta_path_dT(-1,j,i) = dBeta_path_dT(-1,j,i) + ratio * dSigma_m_dT
            dBeta_path_dT( 0,j,i) = dBeta_path_dT( 0,j,i) + ratio * dPi_dT
            dBeta_path_dT(+1,j,i) = dBeta_path_dT(+1,j,i) + ratio * dSigma_p_dT
          end if
          beta_path(-1,j,i) = beta_path(-1,j,i) + ratio * sigma_m
          beta_path( 0,j,i) = beta_path( 0,j,i) + ratio * pi
          beta_path(+1,j,i) = beta_path(+1,j,i) + ratio * sigma_p
        end do ! j

        if ( dumpBeta ) then
          call display_string ( lit_indices(beta_group(i)%molecules(1:n)), &
            & before='Polarized Betas for' )
          call output ( frq, before=', FRQ = ', advance='yes' )
          call dump ( beta_path(:,:,i), name='Beta', options=clean )
          if ( size(dBeta_path_dT) > 0 ) then
            call dump ( real(dBeta_path_dT), name='real(dBeta_path_dT)', options=clean )
            call dump ( aimag(dBeta_path_dT), name='aimag(dBeta_path_dT)', options=clean )
          end if
        end if
      end do ! n
    end do ! i
    if ( dumpStop ) stop

  end subroutine Get_Beta_Path_Polarized

  ! ----------------------------------------  Get_Beta_Path_Cloud  -----
  subroutine Get_Beta_Path_Cloud ( Frq, t_path, tt_path, path_inds, &
        & beta_path_cloud, w0_path, tt_path_c, IPSD, WC, fwdModelConf  )

    use ForwardModelConfig, only: ForwardModelConfig_T
    use Cloud_Extinction, only: Get_Beta_Cloud
    use MLSKinds, only: R8, RP, IP

! Inputs:

    real(r8), intent(in) :: Frq             ! Frequency in MHz
    real(rp), intent(in) :: T_path(:)       ! Path temperatures
    real(rp), intent(in) :: tt_path(:,:)    ! Scating source func on gl grids


    integer(ip), intent(in) :: Path_inds(:) ! indices for reading T_PATH

    type (ForwardModelConfig_T) ,intent(in) :: FWDMODELCONF

    integer, intent(in) :: IPSD(:)
    real(rp), intent(in)  :: WC(:,:)
    real(rp) :: W0       ! SINGLE SCATTERING ALBEDO
    real(rp) :: PHH(fwdModelConf%num_scattering_angles)   ! PHASE FUNCTION

! Outputs

    real(rp), intent(out) :: beta_path_cloud(:) ! cloud extinction, km^{-1}
    real(rp), intent(out) :: w0_path(:)         ! single scattering albedo
    real(rp), intent(out) :: tt_path_c(:)       ! scattering source func coarse grids

! Local variables..

    integer :: NC, NU, NUA, NAB, NR
    integer(ip) :: j, k, n_path
    real(rp) :: cld_ext

! begin the code

    NU  = fwdModelConf%Num_Scattering_Angles
    NUA = fwdModelConf%Num_Azimuth_Angles
    NAB = fwdModelConf%Num_AB_Terms
    NR  = fwdModelConf%Num_Size_Bins

    n_path = size(path_inds)

    beta_path_cloud = 0.0_rp
    w0_path         = 0.0_rp
    tt_path_c       = 0.0_rp

    do j = 1, n_path
      k = path_inds(j)

      call get_beta_cloud ( Frq, t_path(k),                         &
                        &   WC(:,k), IPSD(k), NC, NU, NUA, NAB, NR, &
                        &   cld_ext, W0, PHH                )      

      beta_path_cloud(j) = beta_path_cloud(j) + cld_ext 
      w0_path(j)         = w0_path(j)         + W0 
      tt_path_c(j)       = tt_path_c(j)       + tt_path(k,1)            

    end do

  end subroutine Get_Beta_Path_Cloud

! ----------------------------------------------  Create_beta  ---------

  subroutine Create_beta ( pressure, Temp, Fgr, Flo, slabs_0, tanh1, &
         &                 Beta_Value, NoPolarized, dTanh_dT,   &
         &                 dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv, Sps, &
         &                 dBeta_df )

!  For a given frequency and height, compute beta_value function.
!  This routine should be called for primary and image separately.

!  If you change Create_Beta, change Create_Beta_Path the same way!
!  Create_Beta and Create_Beta_Path should do the same thing.

!  The reason for the existence of Create_Beta_Path is that by moving the
!  loop for the path down into Create_Beta a substantial improvement in
!  running time was achieved.  Create_Beta is in the inner loop of the
!  forward model.

    use MLSKinds, only: RP, R8, IP
    use Molecules, only: L_N2, L_Extinction, L_ExtinctionV2, L_H2O, &
      & L_MIFExtinction, L_O2
    use SLABS_SW_M, only: DVoigt_Spectral, Voigt_Lorentz, &
      & SLABS_Lines, SLABS_Lines_DT, SLABS_Struct, &
      & SLABSWint_Lines, SLABSWint_Lines_DT
    use SpectroscopyCatalog_M, only: Catalog_T, Lines

! Inputs:
    real(rp), intent(in) :: pressure   ! pressure in hPa
    real(rp), intent(in) :: temp       ! temperature in K
    real(r8), intent(in) :: fgr        ! frequency in MHz
    real(r8), intent(in) :: Flo        ! LO frequency in MHz
    type(slabs_struct), intent(in) :: slabs_0 ! contains, among others:

!    catalog        ! Pointer to spectroscopy catalog
!    v0s(:)         ! pressure shifted line centers
!    x1(:)          ! Doppler width
!    y(:)           ! ratio Pressure to Doppler widths
!    yi(:)          ! Interference coefficients
!    slabs1(:)      ! strengths
!    dslabs1_dv0(:) ! strength derivative wrt line position

    real(rp), intent(in) :: tanh1      ! tanh(h*frq/(2*k*T))

    ! "Don't do line(L) if slabs%catalog%polarized(L)"
    logical, intent(in) :: NoPolarized

! Optional inputs for temperature derivatives
    ! -(h frq) / (2 k T^2) ( tanh( (2 h frq) / (k T) ) - 1/tanh( (h frq) / (2 k T) ) ):
    real(rp), intent(in), optional :: dTanh_dT ! 1/tanh d/dT tanh
! Outputs
    real(rp), intent(out) :: beta_value         ! km^{-1}
! Optional outputs
    real(rp), optional, intent(out) :: DBeta_DT ! Temperature derivative
    real(rp), optional, intent(out) :: DBeta_DW ! line width derivative
    real(rp), optional, intent(out) :: DBeta_DN ! temperature dependence deriv
    real(rp), optional, intent(out) :: DBeta_DV ! line position derivative
! Optional for H2O -- Optional so PFA table generation can ignore it
    real(rp), optional, intent(in) :: SPS       ! Mixing ratio
    real(rp), optional, intent(out) :: DBeta_DF ! mixing ratio derivative

! -----     Local variables     ----------------------------------------

    type(catalog_t), pointer :: Catalog
    real(rp), pointer :: Cont(:)    ! Continuum parameters
    integer(ip) :: LN_I             ! Line index
    integer(ip) :: NL               ! no of lines
    logical :: Spect_Der

    real(rp) :: bv, dNu, dw, dn, ds, dbdt, dbdw, dbdn, dbdv

!----------------------------------------------------------------------------

    spect_der = present(dBeta_dw) .or. present(dBeta_dn) .or. present(dBeta_dv)
    if ( spect_der ) then
      dbdw = 0.0_rp
      dbdn = 0.0_rp
      dbdv = 0.0_rp
    end if

!  Setup absorption coefficients function
!  Now get the beta_value:

    catalog => slabs_0%catalog
    cont => catalog%continuum
    nl = size(catalog%lines)
    select case ( catalog%molecule )
    case ( l_n2 ) ! ...........................................  Dry Air

      if ( present(dBeta_dT) ) then
        call abs_cs_n2_cont_dT ( cont, temp, pressure, fgr, beta_value, dBeta_dT )
      else
        beta_value = abs_cs_n2_cont(cont,Temp,Pressure,Fgr)
      end if

    case ( l_extinction, l_MIFextinction ) ! ...............  Extinction

      beta_value = 1.0_rp
      if ( present(dBeta_dT) ) dBeta_dT = 0.0_rp
      return

    case ( l_extinctionv2 ) ! ............................  ExtinctionV2

      beta_value = ( fgr / flo ) ** 2.0_rp
      if ( present(dBeta_dT) ) dBeta_dT = 0.0_rp
      return

    case ( l_o2 ) ! ................................................  O2

      if ( present(dBeta_dT) ) then
        call abs_cs_o2_cont_dT ( cont, temp, pressure, fgr, beta_value, dBeta_dT )
      else
        beta_value = abs_cs_o2_cont(cont,Temp,Pressure,Fgr)
      end if

    case ( l_h2o ) ! ..............................................  H2O

      if ( present(dBeta_dT) ) then
        call abs_cs_h2o_cont_dT ( cont, temp, pressure, fgr, sps, &
          & beta_value, dBeta_dT, dBeta_df )
      else
        if ( present(dBeta_df) ) then
          call abs_cs_h2o_cont_df ( cont, temp, pressure, fgr, sps, &
          & beta_value, dBeta_df )
        else
          beta_value = abs_cs_h2o_cont(cont,Temp,Pressure,Fgr,sps)
        end if
      end if

    case default ! ..............................................  Other

      if ( present(dBeta_dT) ) then
        call abs_cs_cont_dT ( cont, temp, pressure, fgr, beta_value, dBeta_dT )
      else
        beta_value = abs_cs_cont(cont,Temp,Pressure,Fgr)
      end if

    end select

    if ( nl < 1 ) then
      if ( present(dBeta_dw)) dBeta_dw = 0.0_rp
      if ( present(dBeta_dn)) dBeta_dn = 0.0_rp
      if ( present(dBeta_dv)) dBeta_dv = 0.0_rp
      return
    end if

    if ( spect_der ) then

      do ln_i = 1, nl

        if ( noPolarized ) then
          if ( catalog%polarized(ln_i) ) cycle
        end if

        dNu = Fgr - slabs_0%s(ln_i)%v0s

        if ( abs(slabs_0%s(ln_i)%y)+0.666666_rp*abs(slabs_0%s(ln_i)%x1*dNu) &
        & > 100.0_rp ) then
          call Voigt_Lorentz ( dNu, slabs_0%s(ln_i)%v0s, slabs_0%s(ln_i)%x1,         &
            &  slabs_0%s(ln_i)%yi, slabs_0%s(ln_i)%y, lines(catalog%lines(ln_i))%w,  &
            &  Temp, tanh1, slabs_0%s(ln_i)%slabs1, bv, slabs_0%s(ln_i)%dslabs1_dv0, &
            &  dw, dn, ds )
        else
          call DVoigt_Spectral ( dNu, slabs_0%s(ln_i)%v0s, slabs_0%s(ln_i)%x1,       &
            &  slabs_0%s(ln_i)%yi, slabs_0%s(ln_i)%y, lines(catalog%lines(ln_i))%w,  &
            &  Temp, tanh1, slabs_0%s(ln_i)%slabs1, bv, slabs_0%s(ln_i)%dslabs1_dv0, &
            &  dw, dn, ds )
        end if

        beta_value = beta_value + bv
        dbdw = dbdw + dw
        dbdn = dbdn + dn
        dbdv = dbdv + ds

      end do

      if ( present(dBeta_dw)) dBeta_dw = dbdw
      if ( present(dBeta_dn)) dBeta_dn = dbdn
      if ( present(dBeta_dv)) dBeta_dv = dbdv

    else ! No spectroscopy derivatives required

      if ( .not. present(dBeta_dT) ) then
        if ( slabs_0%useYi ) then
          bv = slabswint_lines ( Fgr, slabs_0, tanh1, noPolarized )
        else
          bv = slabs_lines ( Fgr, slabs_0, tanh1, noPolarized )
        end if
      else ! Temperature derivatives needed
        if ( slabs_0%useYi ) then
          call slabswint_lines_dT ( fgr, slabs_0, tanh1, dTanh_dT, &
            & bv, dbdt, noPolarized )
        else
          call slabs_lines_dT ( fgr, slabs_0, tanh1, dTanh_dT, &
            & bv, dbdt, noPolarized )
        end if
        dBeta_dT = dBeta_dT + dbdt
      end if
      beta_value = beta_value + bv

    end if

  end Subroutine Create_beta

! -----------------------------------------  Create_beta_path  ---------

  pure &
  subroutine Create_beta_path ( Path_inds, Pressure, Temp, Fgr, Flo, Ratio,  &
         &   Slabs_0, Tanh1, NoPolarized, VelCor, Beta_value, dTanh_dT, &
         &   Path_flags, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv,        &
         &   dBeta_df, Sps_Path )

!  For a given frequency and height, compute beta_value function. This routine
!  should be called for primary and image separately. Compute dBeta_dT if it's
!  associated.  Compute dBeta_dw, dBeta_dn, dBeta_dv if they're associated. 

    use MLSKinds, only: RP, R8
    use Molecules, only: L_N2, L_Extinction, L_ExtinctionV2, L_H2O, &
      & L_MIFExtinction, L_O2
    use SLABS_SW_M, only: SLABS_Struct, &
      & SLABS_Lines, SLABS_Lines_Dall, SLABS_Lines_DSpectral, SLABS_Lines_DT, &
      & SLABSWint_Lines, &
      & SLABSWint_Lines_Dall, SLABSWint_Lines_DSpectral, SLABSWint_Lines_DT

! Inputs:
    integer, intent(in) :: Path_inds(:)! Which Pressures to use
    real(rp), intent(in) :: Pressure(:)! pressure in hPa on the fine path grid
    real(rp), intent(in) :: Temp(:)    ! temperature in K along the path
    real(r8), intent(in) :: Fgr        ! frequency in MHz
    real(r8), intent(in) :: Flo        ! LO frequency
    real(rp), intent(in) :: Ratio      ! Isotope ratio
    type(slabs_struct), intent(in) :: Slabs_0(:) ! contains, among others:

!    Catalog        ! Pointer to catalog
!    v0s(:)         ! pressure shifted line centers
!    x1(:)          ! Doppler width
!    y(:)           ! ratio Pressure to Doppler widths
!    yi(:)          ! Interference coefficients
!    slabs1(:)      ! strengths
!    dslabs1_dv0(:) ! strength derivative wrt line position

    real(rp), intent(in) :: Tanh1(:)   ! tanh(h*frq/(2*k*T))

    ! "Don't do line L if slabs_0(k)%catalog%Polarized(L)"
    logical, intent(in) :: NoPolarized

    ! For spectroscopy derivatives:
    real(rp), intent(in) :: VelCor

! Outputs
    real(rp), intent(inout) :: Beta_value(:) ! km^{-1}

! Optional inputs for temperature derivatives:
    real(rp), intent(in) :: dTanh_dT(:) ! -h nu / (2 k T^2) 1/tanh(...) dTanh(...)/dT
    logical, intent(in) :: Path_Flags(:) ! to do on fine path -- default true

! Optional outputs.  Disassociated means "do not compute"
    real(rp), pointer :: dBeta_dT(:) ! temperature derivative
    real(rp), pointer :: dBeta_dw(:) ! line width derivative
    real(rp), pointer :: dBeta_dn(:) ! temperature dependence deriv
    real(rp), pointer :: dBeta_dv(:) ! line position derivative
    real(rp), pointer :: dBeta_df(:) ! mixing ratio derivative

! Optional inputs for H2O -- optional so PFA table generation can ignore it
    real(rp), intent(in), optional :: Sps_Path(:) ! Mixing ratios on the
                                     ! current part of the path -- as for
                                     ! temperature, not pressure

! -----     Local variables     ----------------------------------------

    integer :: J, K              ! Subscript, loop inductor
    integer :: NL                ! no of lines
    logical :: Spect_Der         ! Spectroscopy derivatives required
    logical :: Temp_Der          ! Temperature derivatives required

    real(rp) :: bv, dBdf, dBdT, dBdw, dBdn, dBdv

!----------------------------------------------------------------------------

    if ( associated(dBeta_dw) .or. associated(dBeta_dn) .or. associated(dBeta_dv) ) then
      dBdw = 0.0_rp
      dBdn = 0.0_rp
      dBdv = 0.0_rp
    end if

    nl = size(slabs_0(1)%catalog%lines) ! All of the slabs have the same catalog
    spect_der = associated(dBeta_dw) .or. associated(dBeta_dn) .or. &
              & associated(dBeta_dv)

    !ocl temp(k,temp_der,bv,dBdT)
    do j = 1, size(path_inds)
      k = path_inds(j)
      temp_der = associated(dBeta_dT)
      if ( temp_der .and. size(path_flags) > 0 ) temp_der = path_flags(k)

      select case ( slabs_0(k)%catalog%molecule )
      case ( l_n2 ) ! .........................................  Dry Air

        ! This nominally gets multiplied by "ratio**2" but in practice this
        ! function is for all isotopic forms of N2 hence the ratio is one.

        if ( temp_der ) then
          call abs_cs_n2_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
            & pressure(k), fgr, bv, dBdT )
          beta_value(j) = beta_value(j) + bv
          dBeta_dT(j) = dBeta_dT(j) + dBdT
        else
          beta_value(j) = beta_value(j) + &
            & abs_cs_n2_cont(slabs_0(k)%catalog%continuum,Temp(j),Pressure(k),Fgr)
        end if

      case ( l_extinction, l_MIFextinction ) ! .............  Extinction

        beta_value(j) = beta_value(j) + ratio
!       if ( temp_der ) dBeta_dT(j) = dBeta_dT(j) + ratio * 0.0
        cycle ! we know there are no spectral lines

      case ( l_extinctionv2 ) ! ............................  Extinction

        beta_value(j) = beta_value(j) + ratio * ( fgr / flo ) ** 2
!       if ( temp_der ) dBeta_dT(j) = dBeta_dT(j) + ratio * 0.0
        cycle ! we know there are no spectral lines

      case ( l_o2 ) ! ..............................................  O2

        if ( temp_der ) then
          call abs_cs_o2_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
            & pressure(k), fgr, bv, dBdT )
          beta_value(j) = beta_value(j) + ratio * bv
          dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
        else
          beta_value(j) = beta_value(j) + ratio * &
            & abs_cs_o2_cont(slabs_0(k)%catalog%continuum,Temp(j),Pressure(k),Fgr)
        end if

      case ( l_h2o ) ! ............................................  H2O

        if ( present(sps_path) ) then
          if ( temp_der ) then
            if ( associated(dBeta_df) ) then
              call abs_cs_h2o_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
                & pressure(k), fgr, ratio*sps_path(j), bv, dBdT, dBdf )
              beta_value(j) = beta_value(j) + ratio * bv
              dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
              dBeta_df(j) = dBeta_df(j) + ratio * dBdf
            else
              call abs_cs_h2o_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
                & pressure(k), fgr, ratio*sps_path(j), bv, dBdT )
              beta_value(j) = beta_value(j) + ratio * bv
              dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
            end if
          else if ( associated(dBeta_df) ) then
            call Abs_CS_H2O_Cont_df ( slabs_0(k)%catalog%continuum, temp(j), &
              & pressure(k), fgr, ratio*sps_path(j), bv, dBdf )
            beta_value(j) = beta_value(j) + ratio * bv
            dBeta_df(j) = dBeta_df(j) + ratio * dBdf
          else
            beta_value(j) = beta_value(j) + ratio * &
              & abs_cs_h2o_cont(slabs_0(k)%catalog%continuum,Temp(j), &
              & Pressure(k),Fgr,ratio*sps_path(j))
          end if
        else ! Same as case default for slabs_0(k)%catalog%molecule
          if ( temp_der ) then
            call abs_cs_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
              & pressure(k), fgr, bv, dBdT )
            beta_value(j) = beta_value(j) + ratio * bv
            dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
          else
            beta_value(j) = beta_value(j) + ratio * &
              & abs_cs_cont(slabs_0(k)%catalog%continuum,Temp(j),Pressure(k),Fgr)
          end if
        end if

      case default ! ............................................  Other

        if ( temp_der ) then
          call abs_cs_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
            & pressure(k), fgr, bv, dBdT )
          beta_value(j) = beta_value(j) + ratio * bv
          dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
        else
          beta_value(j) = beta_value(j) + ratio * &
            & abs_cs_cont(slabs_0(k)%catalog%continuum,Temp(j),Pressure(k),Fgr)
        end if

      end select

      if ( nl < 1 ) then
        if ( associated(dBeta_dw) ) dBeta_dw(j) = 0.0_rp
        if ( associated(dBeta_dn) ) dBeta_dn(j) = 0.0_rp
        if ( associated(dBeta_dv) ) dBeta_dv(j) = 0.0_rp
        cycle
      end if

      if ( .not. temp_der .and. .not. spect_der ) then

        ! Add in sum of betas for all the lines
        if ( slabs_0(k)%useYi ) then
          beta_value(j) = beta_value(j) + &
            & ratio * slabswint_lines ( Fgr, slabs_0(k), tanh1(j), noPolarized )
        else
          beta_value(j) = beta_value(j) + &
            & ratio * slabs_lines ( Fgr, slabs_0(k), tanh1(j), noPolarized )
        end if

      else if ( temp_der .and. .not. spect_der ) then

        if ( slabs_0(k)%useYi ) then
          call slabswint_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
            & bv, dBdT, noPolarized )
        else
          call slabs_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
            & bv, dBdT, noPolarized )
        end if

        beta_value(j) = beta_value(j) + ratio * bv
        dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT

      else if ( .not. temp_der .and. spect_der ) then

        if ( slabs_0(k)%useYi ) then
          call slabswint_lines_dSpectral ( Fgr, slabs_0(k), temp(j), tanh1(j), &
            & velCor, noPolarized, bv, dBdw, dBdn, dBdv )
        else
          call slabs_lines_dSpectral ( Fgr, slabs_0(k), temp(j), tanh1(j), &
            & velCor, noPolarized, bv, dBdw, dBdn, dBdv )
        end if

        beta_value(j) = beta_value(j) + ratio * bv

        if ( associated(dBeta_dw) ) dBeta_dw(j) = dBeta_dw(j) + ratio * dBdw
        if ( associated(dBeta_dn) ) dBeta_dn(j) = dBeta_dn(j) + ratio * dBdn
        if ( associated(dBeta_dv) ) dBeta_dv(j) = dBeta_dv(j) + ratio * dBdv

      else if ( temp_der .and. spect_der ) then

        if ( slabs_0(k)%useYi ) then
          call slabswint_lines_dAll ( Fgr, slabs_0(k), temp(j), tanh1(j), &
            & dTanh_dT(j), velCor, noPolarized, bv, dBdT, dBdw, dBdn, dBdv )
        else
          call slabs_lines_dAll ( Fgr, slabs_0(k), temp(j), tanh1(j), &
            & dTanh_dT(j), velCor, noPolarized, bv, dBdT, dBdw, dBdn, dBdv )
        end if

        beta_value(j) = beta_value(j) + ratio * bv
        dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT

        if ( associated(dBeta_dw) ) dBeta_dw(j) = dBeta_dw(j) + ratio * dBdw
        if ( associated(dBeta_dn) ) dBeta_dn(j) = dBeta_dn(j) + ratio * dBdn
        if ( associated(dBeta_dv) ) dBeta_dv(j) = dBeta_dv(j) + ratio * dBdv

      end if

    end do ! j = 1, size(path_inds)

  end Subroutine Create_beta_path

  ! ---------------------------------------  Create_Beta_Path_Mie  -----
  pure &
  subroutine Create_Beta_Path_Mie ( Frq, T_Path, IWC_Path, Path_Inds, &
    & Beta_Tab, dBeta_dIWC_tab, dBeta_dT_tab, Beta_Path, dBdT, dBdIWC )

  !{Interpolate in Beta\_c\_a and its derivatives to the T and IWC along the
  ! path.
  !
  ! Let $\xi_1 = \frac{x-x_0}{x_1-x_0}$, $\xi_0 = \frac{x_1-x}{x_1-x_0} =
  ! 1-\xi_1$,
  ! $\eta_1 = \frac{y-y_0}{y_1-y_0}$, $\eta_0 = \frac{y_1-y}{y_1-y_0} =
  ! 1-\eta_1$,
  ! $\xi = [\xi_0,\xi_1]^T$, $\eta = [\eta_0,\eta_1]^T$, and
  ! $Z = \left| \begin{array}{cc} z_{00} & z_{01} \\ z_{10} & z_{11}\\
  !             \end{array} \right|$.
  !
  ! The interpolation can be done either by interpolating in $x$ to
  ! $z_c = \xi_0 z_{00} + \xi_1 z_{10}$ and $z_d = \xi_0 z_{01} +
  ! \xi_1 z_{11}$ and then in $y$ to $z = \eta_0 z_c + \eta_1 z_d$,
  ! or interpolating in $y$ to $z_a = \eta_0 z_{00} + \eta_1 z_{01}$
  ! and $z_b = \eta_0 z_{10} + \eta_1 z_{11}$ and then in $x$ to $z =
  ! \xi_0 z_a + \xi_1 z_b$.  The two orders of interpolation are
  ! equivalent, and when expanded give
  !%
  ! $
  ! z(x,y) = \xi_0 \eta_0 z_{00} + \xi_1 \eta_0 z_{10} +
  ! \xi_0 \eta_1 z_{10} + \xi_1 \eta_1 z_{11},
  ! $
  !%
  ! which can be expressed in matrix-vector form as $\xi^T Z \eta$.

    use MLSNumerics, only: PureHunt
    use MLSKinds, only: RP, R8
    use Read_Mie_M, only: F_S, IWC_S, T_S

! Inputs:
    real(r8), intent(in) :: Frq         ! Channel center frequency in MHz
    real(rp), intent(in) :: T_Path(:)   ! Temperature in K along the path
    real(rp), intent(in) :: IWC_Path(:) ! Ice water content along the path
    integer, intent(in) :: Path_Inds(:) ! Which IWC_Path to use
    real(r8), intent(in) :: Beta_Tab(:,:,:)       ! T x IWC x F
    real(r8), intent(in) :: dBeta_dIWC_Tab(:,:,:) ! T x IWC x F
    real(r8), intent(in) :: dBeta_dT_Tab(:,:,:)   ! T x IWC x F

! Outputs:
    real(rp), intent(inout) :: Beta_Path(:)  ! Beta along the path, km^{-1}

! Optional outputs.  These are pointers instead of optional.  Null means
! "don't compute it."  We do this so the caller doesn't need four branches.
    real(rp), pointer :: dBdT(:)       ! dBeta_dT along the path
    real(rp), pointer :: dBdIWC(:)     ! dBeta_dIWC along the path

! -----     Local variables     ----------------------------------------

    real(rp) :: Eta(2,2)  ! Interpolating factors for T x IWC
    integer :: F_I(2)     ! Indices for F_s
    real(rp) :: I_Fac     ! Interpolating factor for IWC
    integer :: I_I(2)     ! Indices in IWC_s
    integer :: J
    real(rp) :: Log10_IWC ! log10(IWC_path(j))
    integer :: N_F        ! Frequency index (3rd) for Beta_c_a etc.
                          ! F_I(1) or F_I(2), whichever is closest to Frq
    real(rp) :: T_Fac     ! Interpolating factor for T
    integer :: T_I(2)     ! Indices in T_s

    f_i = 0 ! Initialize for Hunt
    i_i = 0
    t_i = 0

    call purehunt ( frq, f_s, size(f_s), f_i(1), f_i(2) )
    n_f = merge(f_i(1), f_i(2), frq-f_s(f_i(1)) < frq-f_s(f_i(2)))

    !ocl independent
    !ocl temp
    do j = 1, size(beta_path)
      if ( iwc_path(path_inds(j)) <= tiny(iwc_path(path_inds(j))) ) then
        beta_path(j) = 0.0
        if ( associated(dBdIWC) ) dBdIWC(j) = 0.0
        if ( associated(dBdT) ) dBdT(j) = 0.0
      else
        log10_IWC = log10(iwc_path(path_inds(j)))
        call purehunt ( log10_IWC, iwc_s, size(iwc_s), i_i(1), i_i(2) )
        call purehunt ( t_path(j), t_s, size(t_s), t_i(1), t_i(2) )
        i_fac = (log10_IWC - iwc_s(i_i(1))) / (iwc_s(i_i(2)) - iwc_s(i_i(1)))
        t_fac = (t_path(j) - t_s(t_i(1))) / (t_s(t_i(2)) - t_s(t_i(1)))
        eta = reshape( (/ (1.0 - t_fac) * (1.0 - i_fac), &
                          t_fac         * (1.0 - i_fac), &
                          (1.0 - t_fac) * i_fac        , &
                          t_fac         * i_fac         /), (/ 2, 2 /) )
        beta_path(j) = sum(eta * beta_tab(t_i,i_i,n_f))
        if ( associated(dBdIWC) ) &
          & dBdIWC(j) = sum(eta * dBeta_dIWC_tab(t_i,i_i,n_f))
        if ( associated(dBdT) ) &
          & dBdT(j) = sum(eta * dBeta_dT_tab(t_i,i_i,n_f))
      end if
    end do

  end subroutine Create_Beta_Path_Mie

  ! ---------------------------------------  Create_Beta_Path_PFA  -----
  pure &
  subroutine Create_Beta_Path_PFA ( Frq, P_Path, Path_Inds, T_Path, Vel_Rel, &
    & PFAD, Ratio, Beta_Path, T_Der_Path, dBdT, dBdw, dBdn, dBdv )

    use MLSNumerics, only: PureHunt
    use MLSKinds, only: RP, R8
    use PFADatabase_M, only: PFAData_T

! Inputs:
    real(r8), intent(in) :: Frq         ! Channel center frequency in MHz
    real(rp), intent(in) :: P_Path(:)   ! Log10 ( Pressure in hPa _)
                                        ! on the fine path grid
    integer, intent(in) :: Path_inds(:) ! Which Pressures to use
    real(rp), intent(in) :: T_Path(:)   ! Temperature in K along the path
    real(rp), intent(in) :: Vel_Rel     ! LOS vel/c
    type(PFAData_t), intent(in) :: PFAD ! PFA datum from PFA Database
    real(rp), intent(in) :: Ratio       ! Isotope ratio
    
! Outputs
    real(rp), intent(inout) :: Beta_Path(:)  ! km^{-1}

! Optional inputs for temperature derivatives:
    logical, intent(in) :: T_Der_Path(:)   ! To do on fine path -- default true

! Optional outputs
    real(rp), pointer :: dBdT(:) ! Temperature derivative
    real(rp), pointer :: dBdw(:) ! Line width derivative
    real(rp), pointer :: dBdn(:) ! Temperature dependence deriv
    real(rp), pointer :: dBdv(:) ! Line position derivative

! -----     Local variables     ----------------------------------------

    real(kind(beta_path)) :: BP  ! Temp for one cell of beta_path
    real(rp) :: dBdNu            ! d log Beta / d nu, for Doppler correction
    real(rp) :: Del_T            ! Log Temperature step in tGrid
    real(r8) :: Doppler          ! Doppler corrected frequency offset, MHz
    integer :: J, K
    real(rp) :: LogT             ! Ln ( temperature )
    integer :: P_I1, P_I2        ! Indices in PFAData%vGrid%surfs
    real(rp) :: P_Fac            ! Interpolating factor for Pressure
    logical :: Temp_Der          ! Temperature derivatives required
    integer :: T_I1, T_I2        ! Indices in PFAData%tGrid%surfs
    real(rp) :: T_Fac            ! Interpolating factor for Temperature

    !{ Doppler correction = $\nu_0 \left[ \left( 1 - \frac{v}c \right) -
    !                                     \left( 1 - \frac{v_l}c \right) \right] =
    !                        \nu_0 \left[ \frac{v_l}c - \frac{v}c \right] $

    doppler = frq * ( PFAD%vel_rel - vel_rel )

    p_i1 = 0 ! Initialize for Hunt
    t_i1 = 0

    !ocl independent
    !ocl temp
    do j = 1, size(path_inds)

      k = path_inds(j)
      temp_der = associated(dBdT)
      if ( temp_der .and. size(t_der_path) > 0 ) temp_der = t_der_path(k)

      ! Get interpolating factors
      logT = log(t_path(j))
      call purehunt ( logT, PFAD%tGrid%surfs(:,1), PFAD%tGrid%noSurfs, &
        & t_i1, t_i2 )
      del_t = PFAD%tGrid%surfs(t_i2,1) - PFAD%tGrid%surfs(t_i1,1)
      t_fac = (logT - PFAD%tGrid%surfs(t_i1,1)) / del_t
      call purehunt ( p_path(k), PFAD%vGrid%surfs(:,1), PFAD%vGrid%noSurfs, &
        & p_i1, p_i2 )
      p_fac = (p_path(k) - PFAD%vGrid%surfs(p_i1,1)) / &
        & (PFAD%vGrid%surfs(p_i2,1) - PFAD%vGrid%surfs(p_i1,1))

      ! Interpolate to get d log Beta / d nu.  We need this to Doppler-correct
      ! Beta even if dBdv is not associated.
      dBdNu = &
        & PFAD%dAbsDnu(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & PFAD%dAbsDnu(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & PFAD%dAbsDnu(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & PFAD%dAbsDnu(t_i1+1,p_i1+1) * t_fac * p_fac

      ! Interpolate to get log Beta at the linearization velocity, then
      ! exponentiate to get Beta
      bp = ratio * ( 1.0 + doppler * dBdNu ) * exp( &
        & PFAD%absorption(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & PFAD%absorption(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & PFAD%absorption(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & PFAD%absorption(t_i1+1,p_i1+1) * t_fac * p_fac )
      beta_path(j) = beta_path(j) + bp

      !{ \raggedright 
      !  $\frac{\partial \beta}{\partial T} \approx
      !   \left. \frac{\partial \beta}{\partial T} \right|_{\nu=\nu_l} +
      !   (\nu-\nu_l)
      !    \left. \frac{\partial^2  \beta}{\partial T \partial \nu}
      !    \right|_{\nu=\nu_l}$;
      !  $\frac{\partial \beta}{\partial T} = \frac\beta{T}
      !   \frac{\partial \log \beta}{\partial \log T}$;
      !  $\frac{\partial^2 \beta}{\partial T \partial \nu} =
      !   \beta \frac{\partial^2 \log \beta}{\partial T \partial \nu} =
      !   \frac\beta{T}
      !    \frac{\partial^2 \log \beta}{\partial \log T \partial \nu}$;
      !  $\frac{\partial \beta}{\partial T} \approx
      !   \beta \left[\frac1T
      !    \left.
      !     \frac{\partial \log \beta}{\partial \log T}
      !    \right|_{\nu=\nu_l} +
      !    (\nu-\nu_l)
      !    \left.
      !     \frac{\partial^2 \log \beta}{\partial T \partial \nu}
      !    \right|_{\nu=\nu_l}
      !   \right] $;
      !  $\frac{\partial \log \beta}{\partial \log T} \approx
      !   \frac{\nabla_T \log \beta}{\Delta \log T}$;
      !  $\frac{\partial^2 \log \beta}{\partial T \partial \nu} \approx
      !   \nabla_T \left(\frac{\partial \log \beta}{\partial \nu} \right)
      !    \frac1{T \Delta \log T}$;
      !  $\frac{\partial \beta}{\partial T} \approx
      !   \frac\beta{T \Delta \log T} \left[
      !    \nabla_T \log \left. \beta \right|_{\nu=\nu_l} +
      !     (\nu-\nu_l) \nabla_T \left(
      !      \left. \frac{\partial \log \beta}{\partial \nu}\right|_{\nu=\nu_l}
      !      \right)
      !   \right]$.\\
      !  $\nabla_T$ means ``Differences in $T$ coordinate, interpolated in
      !  $P$ coordinate.''

      ! Now the derivatives.  Remember that bp includes ratio, so we don't
      ! need to weight by ratio here.

      if ( temp_der ) then
        ! Interpolate to get d^2 log Beta / d log T d Nu, to Doppler-correct
        ! d log Beta d log T.
        ! Interpolate to get d log Beta / d log T, then Doppler correct
        ! and multiply by Beta / T to get dBeta / dT
        dBdT(j) = dBdT(j) + bp / (del_t * t_path(j)) * ( &
          & ( PFAD%absorption(t_i1+1,p_i1  ) - &
          &   PFAD%absorption(t_i1,  p_i1  ) ) * (1.0-p_fac) + &
          & ( PFAD%absorption(t_i1+1,p_i1+1) - &
          &   PFAD%absorption(t_i1,  p_i1+1) ) * p_fac + &
          & doppler * ( ( PFAD%dAbsDnu(t_i1+1,p_i1  ) - &
          &               PFAD%dAbsDnu(t_i1,  p_i1  ) ) * (1.0-p_fac) + &
          &             ( PFAD%dAbsDnu(t_i1+1,p_i1+1) - &
          &               PFAD%dAbsDnu(t_i1,  p_i1+1) ) * p_fac ) )
      end if

      ! Interpolate to get d log Beta / d*, then multiply by Beta to get
      ! dBeta / d*.  We can't Doppler correct these because we don't have
      ! the second partials with respect to d* dNu.
      if ( associated(dBdw) ) dBdw(j) = dBdw(j) + bp * ( &
        & PFAD%dAbsDwc(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & PFAD%dAbsDwc(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & PFAD%dAbsDwc(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & PFAD%dAbsDwc(t_i1+1,p_i1+1) * t_fac * p_fac )

      if ( associated(dBdn) ) dBdn(j) = dBdn(j) + bp * ( &
        & PFAD%dAbsDnc(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & PFAD%dAbsDnc(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & PFAD%dAbsDnc(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & PFAD%dAbsDnc(t_i1+1,p_i1+1) * t_fac * p_fac )

      if ( associated(dBdv) ) dBdv(j) = dBdv(j) + bp * dBdNu

    end do ! j

  end subroutine Create_Beta_Path_PFA

!     =====     Private Procedures     =================================

  ! ------------------------------------------------  Abs_CS_Cont  -----

  ! Compute the general continuum contribution
  pure &
  function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_Cont_r)
  ! real(rp) function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp) :: Abs_CS_Cont_r

    Abs_CS_Cont_r = cont(1) * pressure * pressure * frequency * frequency * &
      & ( (300.0_rp / temperature)**cont(2) )

  end function Abs_CS_Cont

  ! ---------------------------------------------  Abs_CS_Cont_dT  -----

  ! Compute the general continuum contribution and its temperature derivative
  pure &
  subroutine Abs_CS_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
    & Beta, dBeta_dT )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(out) :: Beta, dBeta_dT ! km^{-1}, km^{-1}/K

    real(rp) :: Onedt ! 1/T

!{ Let $\theta = \frac{300}T$.  Then the general continuum contribution is
!  $\beta = c_1 p^2 \nu^2 \theta^{c_2}$.  Noticing that
!  $\frac{\partial \theta}{\partial T} = -\frac{\theta}T$, we have
!  $\frac{\partial \beta}{\partial T} = -\beta \frac{c_2}T$.

    onedt = 1.0 / temperature
    beta = cont(1) * pressure * pressure * frequency * frequency * &
      & ( (300.0_rp * onedt)**cont(2) )

    dBeta_dT = -beta * cont(2) * onedt

  end subroutine Abs_CS_Cont_dT

  ! --------------------------------------------  Abs_CS_H2O_Cont  -----

  ! Compute the general continuum contribution
  pure &
  function Abs_CS_H2O_Cont ( Cont, Temperature, Pressure, Frequency, Sps ) &
    & result(Beta)

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(in), optional :: SPS ! Mixing ratio
    real(rp) :: Beta                    ! km^{-1}
    real(rp) :: dBdf
    real(rp) :: Psq_Fsq                 ! pressure**2 * frequency**2
    real(rp) :: Temp_Ratio              ! log(300/T)

    !{ Ignoring vmr dependence,
    !  $\beta = c_1 p^2 \nu^2 \left( \frac{300}T \right)^{c_2}$.
    !
    !  With vmr dependence,
    !  $\beta = c_1 p^2 \nu^2 \left( \frac{300}T \right)^{c_2}
    !   + c_3 f p^2 \nu^2 \left( \frac{300}T \right)^{c_4}$.

    psq_fsq = pressure*pressure * frequency*frequency
    temp_ratio = log(300.0_rp / temperature)
    beta = cont(1) * psq_fsq * exp(cont(2) * temp_ratio)
    if ( present(sps) ) then
      dBdf = cont(3) * psq_fsq * exp(cont(4) * temp_ratio)
      beta = beta + dBdf * sps
    end if

  end function Abs_CS_H2O_Cont

  ! -----------------------------------------  Abs_CS_H2O_Cont_df  -----

  ! Compute the general continuum contribution
  pure &
  subroutine Abs_CS_H2O_Cont_df ( Cont, Temperature, Pressure, Frequency, &
    & Sps, Beta, dBeta_df )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(in) :: SPS         ! Mixing ratio
    real(rp), intent(out) :: Beta       ! km^{-1}
    real(rp), intent(out) :: dBeta_df
    real(rp) :: Psq_Fsq                 ! pressure**2 * frequency**2
    real(rp) :: Temp_Ratio              ! log(300/T)

    !{ With vmr dependence,
    !  $\beta = c_1 p^2 \nu^2 \left( \frac{300}T \right)^{c_2}
    !   + c_3 f p^2 \nu^2 \left( \frac{300}T \right)^{c_4}$.
    !  $\frac{\partial \beta}{\partial f} =
    !   c_3 p^2 \nu^2 \left( \frac{300}T \right)^{c_4}$.

    psq_fsq = pressure*pressure * frequency*frequency
    temp_ratio = log(300.0_rp / temperature)
    dBeta_df = cont(3) * psq_fsq * exp(cont(4) * temp_ratio )
    beta = cont(1) * psq_fsq * exp(cont(2) * temp_ratio ) + dBeta_df * sps

  end subroutine Abs_CS_H2O_Cont_df

  ! -----------------------------------------  Abs_CS_H2O_Cont_dT  -----

  ! Compute the general continuum contribution and its temperature derivative
  pure &
  subroutine Abs_CS_H2O_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
    & SPS, Beta, dBeta_dT, dBeta_df )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(in), optional :: SPS ! Mixing ratio
    real(rp), intent(out) :: Beta, dBeta_dT ! km^{-1}, km^{-1}/K
    real(rp), intent(out), optional :: dBeta_df ! Derivative w.r.t SPS

    real(rp) :: dBdf                    ! Derivative of beta w.r.t SPS
    real(rp) :: Onedt                   ! 1/T
    real(rp) :: Psq_Fsq                 ! pressure**2 * frequency**2
    real(rp) :: Temp_Ratio              ! log(300/T)

!{ Let $\theta = \frac{300}T$.  Then the general continuum contribution
!  (ignoring vmr dependence) is
!  $\beta = \beta_0 = c_1 p^2 \nu^2 \theta^{c_2}$.  Noticing that
!  $\frac{\partial \theta}{\partial T} = -\frac{\theta}T$, we have
!  $\frac{\partial \beta}{\partial T} = -\beta \frac{c_2}T$ and
!  $\frac{\partial \beta}{\partial f} = 0$.
!
!  With vmr dependence,
!  $\beta = c_1 p^2 \nu^2 \theta^{c_2} + f c_3 p^2 \nu^2 \theta^{c_4}$.
!
!  In this case, $\frac{\partial \beta}{\partial T} = -\frac1T \left(
!  c_2 \beta_0 + f c_3 c_4 p^2 \nu^2 \theta^{c_4} \right)$ and
!  $\frac{\partial \beta}{\partial f} = c_3 p^2 \nu^2 \theta^{c_4}$.


    psq_fsq = pressure*pressure * frequency*frequency
    onedt = 1.0 / temperature
    temp_ratio = log(300.0 * onedt)
    beta = cont(1) * psq_fsq * exp(cont(2) * temp_ratio)
    dBeta_dT = cont(2) * beta
    if ( present(sps) ) then
      dBdf = cont(3) * psq_fsq * exp(cont(4) * temp_ratio)
      if ( present(dBeta_df) ) dBeta_df = dBdf
      dBdf = dBdf * sps
      beta = beta + dBdf
      dBeta_dT = dBeta_dT + cont(4) * dBdf
    end if
    dBeta_dT = - dBeta_dT * onedt

  end subroutine Abs_CS_H2O_Cont_dT

  ! ---------------------------------------------  Abs_CS_N2_Cont  -----

  ! Compute the N2 continuum contribution
  pure &
  function Abs_CS_N2_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_N2_Cont_r)
  ! real(rp) Function Abs_CS_N2_cont ( Cont, Temperature, Pressure, Frequency )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp) :: Abs_CS_N2_Cont_r

    REAL(rp) :: Theta, Fsqr, FSXT

!{ Let $\theta = \frac{300}T$ and $f = p^2 \nu^2 \theta^{c_2}$. Then the N2
!  continuum contribution to $\beta$ is\\
!  $\beta = f ( c_1 e^{-c_3 \nu^2 \theta} +
!   c_4 e^{-c_5  \nu^2 \theta} (c_6^2 + \nu^2) )$.

    theta = 300.0_rp / temperature
    fsqr = frequency * frequency
    fsxt = fsqr * theta
    Abs_CS_N2_Cont_r = pressure * pressure * fsqr * (theta**cont(2)) * &
                   & ( cont(1) * exp(-cont(3) * fsxt) + &
                   &   cont(4) * exp(-cont(5) * fsxt) * &
                   & (cont(6)**2 + fsqr))

  end function Abs_CS_N2_Cont

  ! ------------------------------------------  Abs_CS_N2_Cont_dT  -----

  ! Compute the N2 continuum contribution and its temperature derivative
  pure &
  subroutine Abs_CS_N2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
    & Beta, dBeta_dT )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(out) :: Beta, dBeta_dT ! km^{-1}, km^{-1}/K

    real(rp) :: E1, E2, F, Fsqr, FSXT, OneDT, Theta

!{ Let $\theta = \frac{300}T$ and $f = p^2 \nu^2 \theta^{c_2}$. Then the N2
!  continuum contribution to $\beta$ is\\
!  $\beta = f ( c_1 e^{-c_3 \nu^2 \theta} +
!   c_4 e^{-c_5  \nu^2 \theta} (c_6^2 + \nu^2) )$.  Noticing that
!  $\frac{\partial \theta}{\partial T} = -\frac{\theta}T$, we have\\
!  $\frac{\partial \beta}{\partial T} = \frac1T \left ( -\beta c_2 +
!   f \nu^2 \theta \left( c_3 c_1 e^{-c_3 \nu^2 \theta} +
!    c_5 c_4 (c_6^2 + \nu^2) e^{-c_5  \nu^2 \theta} \right) \right)$.

    onedt = 1.0 / temperature
    theta = 300.0_rp * onedt
    fsqr = frequency * frequency
    fsxt = fsqr * theta
    f = pressure * pressure * fsqr * (theta**cont(2))
    e1 = cont(1) * exp(-cont(3) * fsxt)
    e2 = cont(4) * exp(-cont(5) * fsxt) * (cont(6)**2 + fsqr)
    beta = f * ( e1 + e2 )

    dBeta_dT = onedt * ( f * fsxt * ( cont(3) * e1 + cont(5) * e2 ) &
      &                  - beta * cont(2) )

  end subroutine Abs_CS_N2_Cont_dT

  ! ---------------------------------------------  Abs_CS_O2_Cont  -----

  ! Compute the O2 continuum contribution
  pure &
  function Abs_CS_O2_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_O2_Cont_r)
  ! real(rp) Function ABS_CS_O2_CONT ( Cont, Temperature, Pressure, Frequency )

    use MLSKinds, only: RP

!{ Let $\theta = \frac{300}T$, $f = (c_3 p \exp({c_4} \theta))^2$ and
!  $D = \frac1{\nu^2 + f}$.
!  Then the O2 continuum contribution to beta
!  is $\beta = c_1 p^2 \nu^2 \exp({c_2} \theta) D$.

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp) :: Abs_CS_O2_Cont_r

    real(rp) :: Theta, Fsqr

    theta = log ( 300.0_rp / temperature )
    fsqr = frequency * frequency
    Abs_CS_O2_Cont_r = cont(1) * pressure * pressure * fsqr * exp(theta*cont(2)) &
                   & / (fsqr + (cont(3) * pressure * exp(theta*cont(4)) )**2 )

  end function Abs_CS_O2_Cont

  ! ------------------------------------------  Abs_CS_O2_Cont_dT  -----

  ! Compute the O2 continuum contribution
  pure &
  subroutine Abs_CS_O2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
      & Beta, dBeta_dT )

    use MLSKinds, only: RP

    real(rp), intent(in) :: Cont(:)     ! Continuum parameters
    real(rp), intent(in) :: Temperature ! in Kelvin
    real(rp), intent(in) :: Pressure    ! in mbar
    real(rp), intent(in) :: Frequency   ! in MegaHertz
    real(rp), intent(out) :: Beta, dBeta_dT ! km^{-1}, km^{-1}/K

    real(rp) :: D, F, Fsqr, Onedt, Theta

!{ Let $\theta = \frac{300}T$, $f = (c_3 p \theta^{c_4})^2$ and
!  $D = \frac1{\nu^2 + f}$.
!  Then the O2 continuum contribution to beta
!  is $\beta = c_1 p^2 \nu^2 \theta^{c_2} D$. Noticing that
!  $\frac{\partial \theta}{\partial T} = -\frac{\theta}T$, we have
!  $\frac{\partial \beta}{\partial T} = \frac{\beta}T
!   ( 2 c_4 f D - c_2)$.

    onedt = 1.0 / temperature
    theta = log( 300.0_rp * onedt )
    fsqr = frequency * frequency
    f = ( cont(3) * pressure * exp(cont(4)*theta) )**2
    d = 1.0 / (fsqr + f)
    beta = cont(1) * pressure * pressure * fsqr * exp(cont(2)*theta) * d

    dBeta_dT = beta * onedt * ( 2.0 * cont(4) * f * d - cont(2) )

  end subroutine Abs_CS_O2_Cont_dT

!-----------------------------------------------------------------------
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: get_beta_path_m.f90,v 2.120 2014/04/22 00:09:01 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module GET_BETA_PATH_M

! $Log: get_beta_path_m.f90,v $
! Revision 2.120  2014/04/22 00:09:01  vsnyder
! Remove unused identifiers
!
! Revision 2.119  2014/04/04 19:43:10  vsnyder
! Move computation of QN from get_beta_path to o2_abs_cs.  This avoids the
! need for an array temp.
!
! Revision 2.118  2014/04/02 17:04:53  wgread
! added line dependent qn capability for o2-wgr
!
! Revision 2.117  2013/08/30 03:56:23  vsnyder
! Revise use of trace_begin and trace_end
!
! Revision 2.116  2013/07/26 22:19:05  vsnyder
! Fiddle with dump switches
!
! Revision 2.115  2013/06/12 02:25:18  vsnyder
! Cruft removal
!
! Revision 2.114  2013/05/22 00:08:43  vsnyder
! Repair integer-to-logical assign that NAG caught and Intel missed
!
! Revision 2.113  2013/05/17 22:52:32  vsnyder
! Revise dump switch stuff
!
! Revision 2.112  2011/11/22 00:40:40  vsnyder
! Add units km^{-1} in comments about beta
!
! Revision 2.111  2011/11/11 00:40:41  vsnyder
! Treat Extinction and MIFExtinction the same way
!
! Revision 2.110  2011/11/09 00:15:40  vsnyder
! Consolidate USE statements for slabs_sw_m
!
! Revision 2.109  2011/08/26 17:54:15  pwagner
! purehunt recovers optimized functionality of fwdmdls own hunt
!
! Revision 2.108  2011/08/25 18:17:46  vsnyder
! Remove unused use names
!
! Revision 2.107  2011/07/29 01:57:47  vsnyder
! Only IWC instead of IWC_A and IWC_S
!
! Revision 2.106  2011/05/09 17:56:27  pwagner
! Converted to using switchDetail
!
! Revision 2.105  2011/03/31 19:53:55  vsnyder
! Don't use :np for the first bound in sps_path.  sps_path is fine-path X
! sps.  np is the coarse path length.
!
! Revision 2.104  2011/03/04 03:42:48  vsnyder
! Associate dBdf with dBeta_df_path, not dBeta_dT_path!
!
! Revision 2.103  2011/03/02 02:06:59  vsnyder
! Cannonball polishing
!
! Revision 2.102  2011/02/12 03:57:40  vsnyder
! Add mixing-ratio dependence for H2O derivatives
!
! Revision 2.101  2010/02/09 21:04:18  vsnyder
! Specify extents for derivative section pointers
!
! Revision 2.100  2010/02/05 03:29:09  vsnyder
! Remove unused dummy arguments
!
! Revision 2.99  2010/02/04 23:10:38  vsnyder
! Remove USE for unreferenced names
!
! Revision 2.98  2010/01/23 01:20:15  vsnyder
! Allow betas that depend upon mixing ratio, get beta for Cloud_A and
! Cloud_S from the Mie tables, get kinds from MLSKinds instead of MLSCommon
!
! Revision 2.97  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.96  2009/06/16 17:37:47  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.95  2009/06/13 01:10:01  vsnyder
! Label Beta array, option to dump zeta
!
! Revision 2.94  2008/10/03 16:29:56  livesey
! Added EXTINCTIONV2
!
! Revision 2.93  2008/04/18 22:51:30  vsnyder
! Correct self-continuum
!
! Revision 2.92  2008/02/29 01:59:39  vsnyder
! Added a separate H2O continuum routine
!
! Revision 2.91  2007/05/23 22:44:24  vsnyder
! New slabs structure
!
! Revision 2.90  2006/12/04 21:17:28  vsnyder
! Reorganize FullForwardModel to use automatic arrays instead of allocating
! pointer arrays.  Requires testing for zero size instead of testing for
! associated in several subsidiary procedures.
!
! Revision 2.89  2006/07/19 22:30:17  vsnyder
! Cannonball polishing
!
! Revision 2.88  2006/06/29 01:44:42  vsnyder
! Add tracing
!
! Revision 2.87  2006/04/11 18:32:41  vsnyder
! Add more dumps
!
! Revision 2.86  2006/04/05 19:16:49  vsnyder
! Use the 'clean' switch in some dumps
!
! Revision 2.85  2006/02/23 01:00:17  vsnyder
! Give spectroscopy vector pointers correct upper bounds
!
! Revision 2.84  2006/02/10 21:50:33  vsnyder
! Move RHi conversion to correct place, spiff up some dumps
!
! Revision 2.83  2006/02/08 21:38:18  vsnyder
! Add relative humidity (RHi) calculation
!
! Revision 2.82  2006/02/08 01:02:22  vsnyder
! More stuff for spectroscopy derivatives
!
! Revision 2.81  2005/10/24 20:19:35  vsnyder
! Corrections for spectroscopy derivatives
!
! Revision 2.80  2005/07/06 02:17:21  vsnyder
! Revisions for spectral parameter derivatives
!
! Revision 2.79  2005/06/09 02:34:16  vsnyder
! Move stuff from l2pc_pfa_structures to slabs_sw_m
!
! Revision 2.78  2005/06/03 01:58:53  vsnyder
! New copyright notice, move Id to not_used_here to avoid cascades,
! Revise PFA data structures.
!
! Revision 2.77  2005/05/24 01:55:18  vsnyder
! Delete unused symbols
!
! Revision 2.76  2005/05/02 23:05:01  vsnyder
! New data structures for PFA
!
! Revision 2.75  2005/03/29 01:58:17  vsnyder
! Make stuff pure
!
! Revision 2.74  2005/03/26 01:26:29  vsnyder
! Make sure dBeta_dw etc get a value even if there are no lines
!
! Revision 2.73  2005/03/25 21:04:57  vsnyder
! Don't clobber continuum in Create_Beat if there are lines
!
! Revision 2.72  2005/03/03 02:07:10  vsnyder
! Move dumps from Create_Beta_Path... to Get_Beta_Path...
!
! Revision 2.71  2005/02/17 02:35:13  vsnyder
! Remove PFA stuff from Channels part of config
!
! Revision 2.70  2005/02/16 23:16:50  vsnyder
! Revise data structures for split-sideband PFA
!
! Revision 2.69  2004/12/13 20:47:52  vsnyder
! Use Slabs_0%UseYi field instead of MaxVal(Abs(...%yi))
!
! Revision 2.68  2004/11/04 03:42:09  vsnyder
! Provide for both LBL_Ratio and PFA_Ratio in beta_group
!
! Revision 2.67  2004/11/01 20:26:36  vsnyder
! Reorganization of representation for molecules and beta groups; PFA may be broken for now
!
! Revision 2.66  2004/10/06 21:21:21  vsnyder
! Change how dumps are done
!
! Revision 2.65  2004/09/04 01:50:31  vsnyder
! get_beta_path_m.f90
!
! Revision 2.64  2004/09/02 18:14:29  vsnyder
! Doppler correct temperature derivative in PFA
!
! Revision 2.63  2004/09/01 01:48:13  vsnyder
! Closing in on PFA
!
! Revision 2.62  2004/08/31 18:32:17  vsnyder
! Move initialization for temp_der into loop in create_beta_path
!
! Revision 2.61  2004/08/05 20:59:02  vsnyder
! Get rid of beta_group%n_elements
!
! Revision 2.60  2004/08/03 22:06:45  vsnyder
! Inching further toward PFA
!
! Revision 2.59  2004/07/08 21:00:23  vsnyder
! Inching toward PFA
!
! Revision 2.58  2004/04/19 21:03:29  vsnyder
! Remove unused stuff; respect tder_path_flags
!
! Revision 2.57  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.56  2004/04/02 00:59:24  vsnyder
! Get catalog from slabs structure
!
! Revision 2.55  2004/03/27 03:35:27  vsnyder
! Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
! line centers and line widths around.  Write slabs_lines and slabswint_lines
! to get sum of beta over all lines; put slabs_struct instead of its components
! in the calling sequence.
!
! Revision 2.54  2004/03/20 04:08:55  vsnyder
! Steps along the way to analytic temperature derivatives
!
! Revision 2.53  2004/03/20 01:15:23  jonathan
!  minor changes
!
! Revision 2.52  2004/03/19 04:07:31  vsnyder
! Fix some blunders re dNu for spectral derivatives
!
! Revision 2.51  2004/03/19 00:47:02  vsnyder
! Use line center instead of pressure-shifted line center in a few places
!
! Revision 2.50  2004/02/27 22:47:32  bill
! fixed bug in n2 continuum calc
!
! Revision 2.49  2004/01/26 21:57:00  vsnyder
! Improve TeXnicalities
!
! Revision 2.48  2003/12/07 19:46:10  jonathan
! update for use in 2D cloud FWM
!
! Revision 2.47  2003/08/20 21:12:39  bill
! fixed tanh1 bug associated with T-ders
!
! Revision 2.46  2003/07/15 17:50:30  vsnyder
! Callers need t_der_path_flags to be a pointer
!
! Revision 2.45  2003/07/14 22:45:09  vsnyder
! Scale BP, BM by isotope ratio in t_power computation
!
! Revision 2.44  2003/07/11 22:43:37  vsnyder
! Multiply the continuum-derived Beta by the isotope ratio
!
! Revision 2.43  2003/07/09 22:47:43  vsnyder
! Make separate branches for the polarized and nonpolarized cases, so
! we don't need to check "if (present(polarized))" inside the loop.  This
! is the inner loop for the full forward model.
!
! Revision 2.42  2003/07/07 19:53:51  vsnyder
! Move newly-public Create_Beta and Create_Beta_Path above the 'Private
! Procedures' comment
!
! Revision 2.41  2003/07/07 19:08:38  vsnyder
! Make Create_Beta and Create_Beta_Path public
!
! Revision 2.40  2003/07/07 16:47:01  pwagner
! Moved declaration of 3 function results inside body to appease NAG
!
! Revision 2.39  2003/07/04 02:47:50  vsnyder
! Move Create_Beta here, add Create_Beta_Path routine
!
! Revision 2.38  2003/06/27 22:09:19  vsnyder
! Move allocation of LineWidths out of loops; simplify exponent calculation
!
! Revision 2.37  2003/06/18 17:23:40  bill
! fixed NAG associated bug
!
! Revision 2.36  2003/06/18 14:44:53  bill
! added subsetting feature for T-ders
!
! Revision 2.35  2003/06/02 22:41:33  vsnyder
! Remove unused symbols
!
! Revision 2.34  2003/05/16 23:51:51  livesey
! Now uses molecules rather than spectags
!
! Revision 2.33  2003/05/15 03:28:52  vsnyder
! Moved some stuff up to FullForwardModel because Get_d_Deltau_pol_dT needs it
!
! Revision 2.32  2003/05/10 00:48:09  vsnyder
! Add TeXnicalities
!
! Revision 2.31  2003/05/09 20:07:07  vsnyder
! Correct kind parameter for H, specify intent for GL_slabs and Beta_group
!
! Revision 2.30  2003/05/09 19:24:38  vsnyder
! Cosmetic change
!
! Revision 2.29  2003/05/05 23:00:25  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.25.2.9  2003/03/24 21:50:44  jonathan
! remove unused 'pressure' in call to cloud_extinction
!
! Revision 2.25.2.8  2003/03/22 04:03:04  vsnyder
! Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
!
! Revision 2.25.2.7  2003/03/12 21:35:44  vsnyder
! Add Dump_Beta_Group and generic Dump for it
!
! Revision 2.25.2.6  2003/03/01 03:16:15  vsnyder
! Use 'polarized' to specify size of quantum numbers array
!
! Revision 2.25.2.5  2003/02/27 23:19:23  vsnyder
! Add polarized stuff.  Remove unused z_path_c argument of get_beta_path.
! Remove unused p_path argument to get_beta_cloud.  Cosmetics.
!
! Revision 2.25.2.3  2003/02/14 00:21:42  jonathan
! add singl. scat. albedo W0, ph funct PHH
!
! Revision 2.25.2.2  2003/02/13 22:26:30  jonathan
! changes dimension for beta_path_cloud
!
! Revision 2.25.2.1  2003/02/13 17:34:27  bill
! uses new slabs_sw
!
! Revision 2.25  2003/02/11 00:48:18  jonathan
! changes made after adding get_beta_path_cloud
!
! Revision 2.24  2003/02/07 01:57:19  vsnyder
! Delete USE RHIFromH2O because it's not used
!
! Revision 2.23  2003/02/07 01:08:34  jonathan
! remove ICON option for compute super saturation
!
! Revision 2.22  2003/02/06 22:12:49  jonathan
! fix bug
!
! Revision 2.21  2003/02/06 00:20:16  jonathan
! Add in many stuff to deal with clouds CloudIce, iwc_path, etc
!
! Revision 2.20  2003/02/04 22:03:33  jonathan
! ICON now equal to 0 as default
!
! Revision 2.19  2003/02/04 21:46:27  jonathan
! add ICON options for super saturation and dry cases
!
! Revision 2.18  2003/02/03 22:56:58  vsnyder
! Add Get_bata_path_polarized
!
! Revision 2.17  2003/01/31 18:45:09  jonathan
! use cld_ext only if Incl_Cld is ture
!
! Revision 2.16  2003/01/31 17:53:48  jonathan
! change z_path to z_path_c in passing to get_beta_path
!
! Revision 2.15  2003/01/31 17:16:08  jonathan
! add Inc_Cld, and cld_ext
!
! Revision 2.14  2003/01/30 17:43:04  jonathan
! remove RHtoEV
!
! Revision 2.13  2003/01/30 00:17:42  jonathan
! add z_path to get_beta_path & use Paul's RHIFromH2O to compute VMR from RHi
!
! Revision 2.12  2003/01/14 21:49:33  jonathan
! option for saturation below 100mb
!
! Revision 2.11  2003/01/08 00:17:29  vsnyder
! Use "associated" instead of "present" to control optional computations
!
! Revision 2.10  2002/12/13 02:06:51  vsnyder
! Use a SLABS structure for the slabs quantities
!
! Revision 2.9  2002/10/08 17:08:03  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.8  2002/09/12 23:00:04  vsnyder
! Cosmetic changes, move USEs from module scope to procedure scope
!
! Revision 2.7  2001/12/23 23:30:42  zvi
! Fixing a bug in the dbeta_dt computations
!
! Revision 2.6  2001/12/14 23:43:15  zvi
! Modification for Grouping concept
!
! Revision 2.5  2001/11/15 01:22:01  zvi
! Remove Extiction debug
!
! Revision 2.4  2001/11/10 00:46:40  zvi
! Adding the EXTINCTION capabilitis
!
! Revision 2.3  2001/11/07 22:24:45  zvi
! Further modification for the t-power computations
!
! Revision 2.2  2001/11/07 21:13:48  livesey
! Fixed bug with log(0.0/0.0) for molecues with no lines
! or continua
!
! Revision 2.1  2001/10/16 15:07:18  zvi
! Continuum parameters are now part of Catalog
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.22.2.1  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
! Revision 1.8  2001/03/09 02:26:11  vsnyder
! More work on deallocation
!
! Revision 1.7  2001/03/09 02:11:28  vsnyder
! Repair deallocating
!
! Revision 1.6  2001/03/05 21:37:20  zvi
! New filter format
!
! Revision 1.1 2001/02/01 00:08:13  Z.Shippony
! Initial conversion to Fortran 90
@


2.120
log
@Remove unused identifiers
@
text
@d42 12
a53 11
    use DUMP_0, only: DUMP
    use FORWARDMODELCONFIG, only: BETA_GROUP_T, LINECENTER, LINEWIDTH, LINEWIDTH_TDEP
    use INTRINSIC, only: LIT_INDICES
    use MLSKINDS, only: R8, RP, IP
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MOLECULES, only: L_RHI
    use OUTPUT_M, only: OUTPUT
    use SLABS_SW_M, only: SLABS_STRUCT
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: EMIT, LEVELS, SWITCHES, TOGGLE
    use TRACE_M, only: TRACE_BEGIN, TRACE_END
d59 6
a64 2
    real(rp), intent(in) :: P_path(:)    ! path pressures in hPa!
    real(rp), intent(in) :: T_path(:)    ! path temperatures
d66 6
a71 2
    type (slabs_struct), dimension(:,:), intent(in) :: Gl_slabs
    integer(ip), intent(in) :: Path_inds(:) ! indices for reading p_path and gl_slabs
d80 1
a80 1
    logical, intent(in) :: t_der_path_flags(:)     ! where temperature derivatives
d94 10
a103 10
! Optional outputs.  We use ASSOCIATED instead of PRESENT so that the
! caller doesn't need multiple branches.  These would be INTENT(OUT) if
! we could say so.

    real(rp), target :: dBeta_dT_path(:,:) ! Temperature
    real(rp), target :: dBeta_dw_path(:,:) ! line width
    real(rp), target :: dBeta_dn_path(:,:) ! line width t dep.
    real(rp), target :: dBeta_dv_path(:,:) ! line position
    real(rp), target :: dBeta_df_path(:,:) ! mixing ratio
    ! Which column of dBeta_df_path to use for a molecule.  Do not compute if zero.
d251 12
a262 12
    use DUMP_0, only: DUMP
    use FORWARDMODELCONFIG, only: BETA_GROUP_T
    use INTRINSIC, only: LIT_INDICES
    use MLSKINDS, only: RP, R8
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use MOLECULES, only: L_CLOUDICE, L_RHI
    use OUTPUT_M, only: OUTPUT
    use PFADATABASE_M, only: PFADATA
    use READ_MIE_M, only: BETA_C_A, DBETA_DIWC_C_A, DBETA_DT_C_A, &
                        & BETA_C_S, DBETA_DIWC_C_S, DBETA_DT_C_S
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: SWITCHES
d271 1
a271 1
    integer, intent(in) :: SX            ! Sideband index, 1 or 2.
d350 1
a350 1
            call create_beta_path_pfa ( frq, p_path, path_inds, t_path, vel_rel, &
d403 5
a407 5
    use DUMP_0, only: DUMP
    use FORWARDMODELCONFIG, only: LBL_T
    use INTRINSIC, only: LIT_INDICES
    use MLSKINDS, only: R8, RP, IP
    use MLSSTRINGLISTS, only: SWITCHDETAIL
d409 4
a412 4
    use OUTPUT_M, only: OUTPUT
    use SLABS_SW_M, only: SLABS_STRUCT
    use STRING_TABLE, only: DISPLAY_STRING
    use TOGGLES, only: SWITCHES
d416 1
a416 1
    real(r8), intent(in) :: Frq       ! frequency in MHz
d506 4
a509 3
    use FORWARDMODELCONFIG, only: FORWARDMODELCONFIG_T
    use CLOUD_EXTINCTION, only: GET_BETA_CLOUD
    use MLSKINDS, only: R8, RP, IP
d513 3
a515 3
    real(r8), intent(in) :: Frq             ! frequency in MHz
    real(rp), intent(in) :: T_path(:)       ! path temperatures
    real(rp), intent(in) :: tt_path(:,:)    ! scating source func on gl grids
d541 4
a544 4
    NU  = fwdModelConf%NUM_SCATTERING_ANGLES
    NUA = fwdModelConf%NUM_AZIMUTH_ANGLES
    NAB = fwdModelConf%NUM_AB_TERMS
    NR  = fwdModelConf%NUM_SIZE_BINS
d585 7
a591 7
    use MLSKINDS, only: RP, R8, IP
    use MOLECULES, only: L_N2, L_EXTINCTION, L_EXTINCTIONV2, L_H2O, &
      & L_MIFEXTINCTION, L_O2
    use SLABS_SW_M, only: DVOIGT_SPECTRAL, VOIGT_LORENTZ, &
      & SLABS_LINES, SLABS_LINES_DT, SLABS_STRUCT, &
      & SLABSWINT_LINES, SLABSWINT_LINES_DT
    use SPECTROSCOPYCATALOG_M, only: CATALOG_T, LINES
d619 4
a622 4
    real(rp), optional, intent(out) :: DBETA_DT ! Temperature derivative
    real(rp), optional, intent(out) :: DBETA_DW ! line width derivative
    real(rp), optional, intent(out) :: DBETA_DN ! temperature dependence deriv
    real(rp), optional, intent(out) :: DBETA_DV ! line position derivative
d625 1
a625 1
    real(rp), optional, intent(out) :: DBETA_DF ! mixing ratio derivative
d782 7
a788 7
    use MLSKINDS, only: RP, R8
    use MOLECULES, only: L_N2, L_EXTINCTION, L_EXTINCTIONV2, L_H2O, &
      & L_MIFEXTINCTION, L_O2
    use SLABS_SW_M, only: SLABS_STRUCT, &
      & SLABS_LINES, SLABS_LINES_DALL, SLABS_LINES_DSPECTRAL, SLABS_LINES_DT, &
      & SLABSWINT_LINES, &
      & SLABSWINT_LINES_DALL, SLABSWINT_LINES_DSPECTRAL, SLABSWINT_LINES_DT
d1054 3
a1056 3
    use MLSNUMERICS, only: PUREHUNT
    use MLSKINDS, only: RP, R8
    use READ_MIE_M, only: F_S, IWC_S, T_S
d1127 3
a1129 3
    use MLSNUMERICS, only: PUREHUNT
    use MLSKINDS, only: RP, R8
    use PFADATABASE_M, only: PFADATA_T
a1297 1
    use MLSKINDS, only: RP
d1299 6
a1304 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
a1317 1
    use MLSKINDS, only: RP
d1319 6
a1324 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
a1347 1
    use MLSKINDS, only: RP
d1349 6
a1354 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
a1383 1
    use MLSKINDS, only: RP
d1385 6
a1390 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
a1415 1
    use MLSKINDS, only: RP
d1417 6
a1422 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
a1469 1
    use MLSKINDS, only: RP
d1471 6
a1476 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
d1479 1
a1479 1
    REAL(rp) :: THETA, FSQR, FSXT
d1503 1
a1503 1
    use MLSKINDS, only: RP
d1505 4
a1508 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
d1511 1
a1511 1
    real(rp) :: E1, E2, F, FSQR, FSXT, OneDT, THETA
d1543 2
a1544 1
    use MLSKINDS, only: RP
d1551 4
a1554 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
d1557 1
a1557 1
    real(rp) :: THETA, FSQR
d1573 1
a1573 1
    use MLSKINDS, only: RP
d1575 4
a1578 4
    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
d1581 1
a1581 1
    real(rp) :: D, F, FSQR, Onedt, THETA
d1606 1
a1606 1
       "$Id: get_beta_path_m.f90,v 2.119 2014/04/04 19:43:10 vsnyder Exp $"
d1616 3
@


2.119
log
@Move computation of QN from get_beta_path to o2_abs_cs.  This avoids the
need for an array temp.
@
text
@a401 1
    use Spectroscopy_Types, only: Lines ! The lines database
d429 1
a429 1
    integer(ip) :: I, IB, J, K, L, N, N_PATH
d1589 1
a1589 1
       "$Id: get_beta_path_m.f90,v 2.118 2014/04/02 17:04:53 wgread Exp $"
d1599 4
@


2.118
log
@added line dependent qn capability for o2-wgr
@
text
@d430 1
a430 2
    integer(ip) :: I, IB, J, K, L, M, N, N_PATH
    integer :: QN(max_lines(beta_group,GL_slabs))
a458 19
        ! Compute the quantum numbers.  Lines(l)%qn(1) is the format, where L
        ! is the index in the Lines database from gl_slabs%catalog%lines.  The
        ! number of elements is twice the low-order digit of the format, plus
        ! one.  We assume that the set of lines is the same at every point on
        ! the path, so we can hoist this computation out of the path loop.
        m = size(gl_slabs(1,ib)%catalog%lines) ! Number of lines
        do j = 1, m
          ! QN(j) needs to be the second element, with the sign being
          ! the difference between the last pair of quantum numbers, which
          ! are at the middle and end of the list.
          l = gl_slabs(1,ib)%catalog%lines(j)    ! Index in Lines database
          if ( associated(lines(l)%qn) ) then
            k = size(lines(l)%qn)
            qn(j) = sign(lines(l)%qn(2), lines(l)%qn(k) - lines(l)%qn((k+1)/2) )
          else ! No QN field in the spectroscopy catalog, so use -1.
            qn(j) = -1
          end if
        end do

d464 1
a464 1
            call o2_abs_cs ( frq, qn(1:m), h(k), gl_slabs(k,ib), &
d467 1
a467 1
            call d_o2_abs_cs_dT ( frq, qn(1:m), h(k), gl_slabs(k,ib),   &
a1585 18
  ! --------------------------------------------------  Max_Lines  -----
  pure integer function Max_Lines ( Beta_Group, GL_Slabs )
    ! Compute the maximum number of lines in any catalog for any molecule
    ! in the beta group
    use FORWARDMODELCONFIG, only: LBL_T
    use SLABS_SW_M, only: SLABS_STRUCT
    type(LBL_T), intent(in) :: Beta_Group(:)
    type(slabs_struct), intent(in) :: GL_Slabs(:,:)
    integer :: I, IB, N
    max_lines = 0
    do i = 1, size(beta_group)
      do n = 1, size(beta_group(i)%cat_index)
        ib = beta_group(i)%cat_index(n)
        max_lines = max(max_lines,size(gl_slabs(1,ib)%catalog%lines))
      end do
    end do
  end function Max_Lines
    
d1590 1
a1590 1
       "$Id: get_beta_path_m.f90,v 2.117 2013/08/30 03:56:23 vsnyder Exp $"
d1600 3
@


2.117
log
@Revise use of trace_begin and trace_end
@
text
@d402 1
d430 2
a431 1
    integer(ip) :: I, IB, J, K, M, N, N_PATH
d460 20
d484 2
a485 2
            call o2_abs_cs ( frq, (/ ( -1, m=1,size(gl_slabs(k,ib)%catalog%lines) ) /),   &
              & h(k), gl_slabs(k,ib), sigma_p, pi, sigma_m )
d487 3
a489 3
            call d_o2_abs_cs_dT ( frq, (/ ( -1, m=1,size(gl_slabs(k,ib)%catalog%lines) ) /),   &
              & h(k), gl_slabs(k,ib), sigma_p, pi, sigma_m, &
              & dSigma_p_dT, dPi_dT, dSigma_m_dT )
d1606 18
d1628 1
a1628 1
       "$Id: get_beta_path_m.f90,v 2.116 2013/07/26 22:19:05 vsnyder Exp $"
d1638 3
@


2.116
log
@Fiddle with dump switches
@
text
@d99 1
a100 4
    real(rp) :: ES(size(t_path)) ! Used for RHi calculation
    real(rp) :: Sps(size(t_path))
    integer(ip) :: I, N, NP
    character(len=4), save :: clean
d106 1
d108 3
d125 2
a126 2
    if ( toggle(emit) .and. levels(emit) > 6 ) &
      & call Trace_Begin ( 'ForwardModel.Get_Beta_Path_Scalar' )
d220 2
a221 2
    if ( toggle(emit) .and. levels(emit) > 6 ) &
      & call Trace_End ( 'ForwardModel.Get_Beta_Path_Scalar' )
d1588 1
a1588 1
       "$Id: get_beta_path_m.f90,v 2.115 2013/06/12 02:25:18 vsnyder Exp $"
d1598 3
@


2.115
log
@Cruft removal
@
text
@d288 1
d292 4
a295 3
      dumpStop = switchDetail(switches,'PFAB') > -1
      dumpAll = dumpStop .or. switchDetail(switches,'pfaB') > -1
      dumpBeta = dumpAll .or. ( switchDetail(switches,'pfab') > -1 )
d1587 1
a1587 1
       "$Id: get_beta_path_m.f90,v 2.114 2013/05/22 00:08:43 vsnyder Exp $"
d1597 3
@


2.114
log
@Repair integer-to-logical assign that NAG caught and Intel missed
@
text
@d521 1
a521 2
    integer :: NC, NU, NUA, NAB, NR, N
    logical :: Incl_Cld
a526 1
    Incl_Cld  = fwdModelConf%Incl_Cld
a530 1
    N   = fwdModelConf%no_cloud_species
d1585 1
a1585 1
       "$Id: get_beta_path_m.f90,v 2.113 2013/05/17 22:52:32 vsnyder Exp $"
d1595 3
@


2.113
log
@Revise dump switch stuff
@
text
@d117 1
a117 1
      dumpZeta = mod(dumpLevel/10,10)
d1588 1
a1588 1
       "$Id: get_beta_path_m.f90,v 2.112 2011/11/22 00:40:40 vsnyder Exp $"
d1598 3
@


2.112
log
@Add units km^{-1} in comments about beta
@
text
@d104 5
a108 1
    logical, save :: DumpAll, DumpBeta, DumpStop, DumpZeta
d115 4
a118 4
      dumpStop = switchDetail(switches,'LBLB') > -1
      dumpAll = dumpStop .or. switchDetail(switches,'lblB') > -1
      dumpBeta = dumpAll .or. ( switchDetail(switches,'lblb') > -1 )
      dumpZeta = switchDetail(switches,'dbz') > -1
d192 1
a192 1
        if ( dumpBeta ) then
d208 1
a208 1
        if ( dumpBeta ) then
d222 1
a222 1
    if ( dumpAll ) then
d1588 1
a1588 1
       "$Id: get_beta_path_m.f90,v 2.111 2011/11/11 00:40:41 vsnyder Exp $"
d1598 3
@


2.111
log
@Treat Extinction and MIFExtinction the same way
@
text
@d83 1
a83 1
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each specie
d262 1
a262 1
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each specie
d414 1
a414 1
    complex(rp), intent(out) :: Beta_path(-1:,:,:) ! path beta for each species
d511 1
a511 1
    real(rp), intent(out) :: beta_path_cloud(:) ! cloud extinction
d602 1
a602 1
    real(rp), intent(out) :: beta_value
d801 1
a801 1
    real(rp), intent(inout) :: Beta_value(:)
d1053 1
a1053 1
    real(rp), intent(inout) :: Beta_Path(:)  ! Beta along the path
d1127 1
a1127 1
    real(rp), intent(inout) :: Beta_Path(:)
d1308 1
a1308 1
    real(rp), intent(out) :: Beta, dBeta_dT
d1338 1
a1338 1
    real(rp) :: Beta
d1373 1
a1373 1
    real(rp), intent(out) :: Beta
d1404 1
a1404 1
    real(rp), intent(out) :: Beta, dBeta_dT
d1488 1
a1488 1
    real(rp), intent(out) :: Beta, dBeta_dT
d1557 1
a1557 1
    real(rp), intent(out) :: Beta, dBeta_dT
d1584 1
a1584 1
       "$Id: get_beta_path_m.f90,v 2.110 2011/11/09 00:15:40 vsnyder Exp $"
d1594 3
@


2.110
log
@Consolidate USE statements for slabs_sw_m
@
text
@d571 2
a572 1
    use MOLECULES, only: L_N2, L_EXTINCTION, L_EXTINCTIONV2, L_H2O, L_O2
d646 1
a646 1
    case ( l_extinction ) ! ................................  Extinction
d652 1
a652 1
    case ( l_extinctionv2 ) ! ................................  ExtinctionV2
d768 2
a769 1
    use MOLECULES, only: L_N2, L_EXTINCTION, L_EXTINCTIONV2, L_H2O, L_O2
d847 1
a847 1
      case ( l_n2 ) ! ...........................................  Dry Air
d862 1
a862 1
      case ( l_extinction ) ! ................................  Extinction
d868 1
a868 1
      case ( l_extinctionv2 ) ! ................................  Extinction
d874 1
a874 1
      case ( l_o2 ) ! ................................................  O2
d886 1
a886 1
      case ( l_h2o ) ! ..............................................  H2O
d924 1
a924 1
      case default ! ..............................................  Other
d1584 1
a1584 1
       "$Id: get_beta_path_m.f90,v 2.109 2011/08/26 17:54:15 pwagner Exp $"
d1594 3
@


2.109
log
@purehunt recovers optimized functionality of fwdmdls own hunt
@
text
@d573 1
a573 1
      & SLABS_LINES, SLABS_LINES_DT, &
a575 1
    use SLABS_SW_M, only: SLABS_STRUCT
d1582 1
a1582 1
       "$Id: get_beta_path_m.f90,v 2.108 2011/08/25 18:17:46 vsnyder Exp $"
d1592 3
@


2.108
log
@Remove unused use names
@
text
@d1038 1
a1038 1
    use D_HUNT_M, only: HUNT
d1076 1
a1076 1
    call hunt ( frq, f_s, size(f_s), f_i(1), f_i(2) )
d1088 2
a1089 2
        call hunt ( log10_IWC, iwc_s, size(iwc_s), i_i(1), i_i(2) )
        call hunt ( t_path(j), t_s, size(t_s), t_i(1), t_i(2) )
d1111 1
a1111 1
    use D_HUNT_M, only: HUNT
d1170 1
a1170 1
      call hunt ( logT, PFAD%tGrid%surfs(:,1), PFAD%tGrid%noSurfs, &
d1174 1
a1174 1
      call hunt ( p_path(k), PFAD%vGrid%surfs(:,1), PFAD%vGrid%noSurfs, &
d1583 1
a1583 1
       "$Id: get_beta_path_m.f90,v 2.107 2011/07/29 01:57:47 vsnyder Exp $"
d1593 3
@


2.107
log
@Only IWC instead of IWC_A and IWC_S
@
text
@d44 1
a44 1
    use INTRINSIC, only: L_RHI, LIT_INDICES
d47 1
d239 1
a239 1
    use INTRINSIC, only: L_RHI, LIT_INDICES
d242 1
a242 1
    use MOLECULES, only: L_CLOUDICE
d1583 1
a1583 1
       "$Id: get_beta_path_m.f90,v 2.106 2011/05/09 17:56:27 pwagner Exp $"
d1593 3
@


2.106
log
@Converted to using switchDetail
@
text
@d191 1
a191 1
          call dump ( beta_path(:,i), options=clean )
d193 1
d241 1
a241 1
    use MOLECULES, only: L_CLOUD_A, L_CLOUD_S
d323 1
a323 1
      case ( l_cloud_a )
a326 1
      case ( l_cloud_s )
d1370 1
a1370 1
    real(rp), intent(in), optional :: SPS ! Mixing ratio
d1582 1
a1582 1
       "$Id: get_beta_path_m.f90,v 2.105 2011/03/31 19:53:55 vsnyder Exp $"
d1592 3
@


2.105
log
@Don't use :np for the first bound in sps_path.  sps_path is fine-path X
sps.  np is the coarse path length.
@
text
@d42 10
a51 9
    use Dump_0, only: Dump
    use ForwardModelConfig, only: Beta_Group_T, LineCenter, LineWidth, LineWidth_TDep
    use Intrinsic, only: L_RHi, Lit_Indices
    use MLSKinds, only: R8, RP, IP
    use Output_m, only: Output
    use Slabs_SW_m, only: SLABS_STRUCT
    use String_Table, only: Display_String
    use Toggles, only: Emit, Levels, Switches, Toggle
    use Trace_M, only: Trace_begin, Trace_end
d110 5
a114 5
      dumpStop = index(switches,'LBLB') > 0
      dumpAll = dumpStop .or. index(switches,'lblB') > 0
      dumpBeta = dumpAll .or. ( index(switches,'lblb') > 0 )
      dumpZeta = index(switches,'dbz') > 0
      ! clean = index(switches,'clean') > 0
d116 1
a116 1
      if ( index(switches,'clean') > 0 ) clean = 'c'
d235 12
a246 11
    use Dump_0, only: Dump
    use ForwardModelConfig, only: Beta_Group_T
    use Intrinsic, only: L_RHi, Lit_Indices
    use MLSKinds, only: RP, R8
    use Molecules, only: L_Cloud_A, L_Cloud_S
    use Output_m, only: Output
    use PFADataBase_m, only: PFAData
    use Read_Mie_m, only: Beta_c_a, dBeta_dIWC_c_a, dBeta_dT_c_a, &
                        & Beta_c_s, dBeta_dIWC_c_s, dBeta_dT_c_s
    use String_Table, only: Display_String
    use Toggles, only: Switches
d285 4
a288 4
      dumpStop = index(switches,'PFAB') > 0
      dumpAll = dumpStop .or. index(switches,'pfaB') > 0
      dumpBeta = dumpAll .or. ( index(switches,'pfab') > 0 )
      ! clean = index(switches,'clean') > 0
d290 1
a290 1
      if ( index(switches,'clean') > 0 ) clean = 'c'
d386 10
a395 9
    use Dump_0, only: Dump
    use ForwardModelConfig, only: LBL_T
    use Intrinsic, only: Lit_Indices
    use MLSKinds, only: R8, RP, IP
    use O2_Abs_CS_m, only: O2_Abs_CS, D_O2_Abs_CS_dT
    use Output_m, only: Output
    use Slabs_SW_m, only: SLABS_STRUCT
    use String_Table, only: Display_String
    use Toggles, only: Switches
d431 3
a433 3
      dumpStop = index(switches,'POLB') > 0
      dumpBeta = dumpStop .or. ( index(switches,'polb') > 0 )
      ! clean = index(switches,'clean') > 0
d435 1
a435 1
      if ( index(switches,'clean') > 0 ) clean = 'c'
d488 3
a490 3
    use ForwardModelConfig, only: FORWARDMODELCONFIG_T
    use Cloud_extinction, only: get_beta_cloud
    use MLSKinds, only: R8, RP, IP
d569 2
a570 2
    use MLSKinds, only: RP, R8, IP
    use Molecules, only: L_N2, L_Extinction, L_ExtinctionV2, L_H2O, L_O2
d574 2
a575 2
    use SpectroscopyCatalog_m, only: Catalog_T, Lines
    use Slabs_SW_m, only: SLABS_STRUCT
d766 4
a769 4
    use MLSKinds, only: RP, R8
    use Molecules, only: L_N2, L_Extinction, L_ExtinctionV2, L_H2O, L_O2
    use Slabs_SW_m, only: SLABS_STRUCT, &
      & SLABS_LINES, SLABS_LINES_DAll, SLABS_LINES_DSpectral, SLABS_LINES_DT, &
d771 1
a771 1
      & SLABSWINT_LINES_DAll, SLABSWINT_LINES_DSpectral, SLABSWINT_LINES_DT
d1037 3
a1039 3
    use D_Hunt_m, only: Hunt
    use MLSKinds, only: RP, R8
    use Read_Mie_m, only: F_s, IWC_s, T_s
d1110 3
a1112 3
    use D_Hunt_m, only: Hunt
    use MLSKinds, only: RP, R8
    use PFADataBase_m, only: PFAData_t
d1281 1
a1281 1
    use MLSKinds, only: RP
d1300 1
a1300 1
    use MLSKinds, only: RP
d1329 1
a1329 1
    use MLSKinds, only: RP
d1364 1
a1364 1
    use MLSKinds, only: RP
d1395 1
a1395 1
    use MLSKinds, only: RP
d1448 1
a1448 1
    use MLSKinds, only: RP
d1480 1
a1480 1
    use MLSKinds, only: RP
d1520 1
a1520 1
    use MLSKinds, only: RP
d1549 1
a1549 1
    use MLSKinds, only: RP
d1582 1
a1582 1
       "$Id: get_beta_path_m.f90,v 2.104 2011/03/04 03:42:48 vsnyder Exp $"
d1592 4
@


2.104
log
@Associate dBdf with dBeta_df_path, not dBeta_dT_path!
@
text
@d321 1
a321 1
        call create_beta_path_Mie ( frq, t_path, sps_path(:np,i), path_inds, &
d325 1
a325 1
        call create_beta_path_Mie ( frq, t_path, sps_path(:np,i), path_inds, &
d1579 1
a1579 1
       "$Id: get_beta_path_m.f90,v 2.103 2011/03/02 02:06:59 vsnyder Exp $"
d1589 3
@


2.103
log
@Cannonball polishing
@
text
@d147 1
a147 1
          dBdf => dBeta_dt_path(:np,where_dBeta_df(i))
a1369 2
    real(rp) :: Abs_CS_H2O_Cont_r
    real(rp) :: dBdf
d1579 1
a1579 1
       "$Id: get_beta_path_m.f90,v 2.102 2011/02/12 03:57:40 vsnyder Exp $"
d1589 3
@


2.102
log
@Add mixing-ratio dependence for H2O derivatives
@
text
@d1274 2
a1275 1
  pure function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency ) &
d1294 2
a1295 1
  pure subroutine Abs_CS_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1323 3
a1325 3
  pure function Abs_CS_H2O_Cont ( Cont, Temperature, Pressure, Frequency, &
    & Sps ) result(Beta)
  ! real(rp) function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency )
d1341 1
a1341 1
    !  With vmr depencence,
d1358 2
a1359 1
  pure subroutine Abs_CS_H2O_Cont_df ( Cont, Temperature, Pressure, Frequency, &
d1375 1
a1375 1
    !{ With vmr depencence,
d1391 2
a1392 1
  pure subroutine Abs_CS_H2O_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1443 2
a1444 1
  pure function Abs_CS_N2_Cont ( Cont, Temperature, Pressure, Frequency ) &
d1475 2
a1476 1
  pure subroutine Abs_CS_N2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1515 2
a1516 1
  pure function Abs_CS_O2_Cont ( Cont, Temperature, Pressure, Frequency ) &
d1581 1
a1581 1
       "$Id: get_beta_path_m.f90,v 2.101 2010/02/09 21:04:18 vsnyder Exp $"
d1591 3
@


2.101
log
@Specify extents for derivative section pointers
@
text
@d40 1
a40 1
        & Sps_Path )
d91 3
d97 1
a97 1
    real(rp), pointer :: dBdn(:), dBdT(:), dBdv(:), dBdw(:) ! slices of dBeta_d*_path
d121 1
a121 1
    nullify ( dBdn, dBdT, dBdv, dBdw ) ! Disassociated means "Don't compute it"
d145 7
d176 1
a176 1
            & dBdT, dBdw, dBdn, dBdv, sps )
d183 1
a183 1
            & dBdT, dBdw, dBdn, dBdv )
d552 2
a553 1
         &                 dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv, Sps )
d604 1
a604 1
! Optional input for H2O -- Optional so PFA table generation can ignore it
d606 1
d666 1
a666 1
          & beta_value, dBeta_dT )
d668 6
a673 1
        beta_value = abs_cs_h2o_cont(cont,Temp,Pressure,Fgr,sps)
d757 1
a757 1
         &   Sps_Path )
d802 1
a802 1
! Optional outputs
d807 1
d821 1
a821 1
    real(rp) :: bv, dbdT, dbdw, dbdn, dbdv
d885 15
a899 2
            call abs_cs_h2o_cont_dT ( slabs_0(k)%catalog%continuum, temp(j), &
              & pressure(k), fgr, ratio*sps_path(j), bv, dBdT )
d901 1
a901 1
            dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
d1321 2
a1322 2
  pure function Abs_CS_H2O_Cont ( Cont, Temperature, Pressure, Frequency, Sps ) &
    & result(Abs_CS_H2O_Cont_r)
d1331 36
d1368 14
a1381 2
    real(rp) :: Psq, Fsq                ! pressure**2, frequency**2
    real(rp) :: Temp_Ratio              ! 300/T
d1383 1
a1383 9
    psq = pressure*pressure
    fsq = frequency*frequency
    temp_ratio = 300.0_rp / temperature
    Abs_CS_H2O_Cont_r = &
      & cont(1) * psq * fsq * ( temp_ratio**cont(2) )
    if ( present(sps) ) Abs_CS_H2O_Cont_r = Abs_CS_H2O_Cont_r + &
      & cont(3) * psq * fsq * ( temp_ratio**cont(4) ) * sps

  end function Abs_CS_H2O_Cont
d1402 2
a1403 2
    real(rp) :: Psq, Fsq                ! pressure**2, frequency**2
    real(rp) :: Temp_Ratio              ! 300/T
d1405 3
a1407 2
!{ Let $\theta = \frac{300}T$.  Then the general continuum contribution is
!  $\beta = c_1 p^2 \nu^2 \theta^{c_2}$.  Noticing that
d1409 10
a1418 1
!  $\frac{\partial \beta}{\partial T} = -\beta \frac{c_2}T$.
d1420 1
a1420 2
    psq = pressure*pressure
    fsq = frequency*frequency
d1422 2
a1423 2
    temp_ratio = 300.0 * onedt
    beta = cont(1) * psq * fsq * ( temp_ratio**cont(2) )
d1426 1
a1426 1
      dBdf = cont(3) * psq * fsq * ( temp_ratio**cont(4) )
d1452 5
d1514 5
d1537 2
a1538 1
  pure subroutine Abs_CS_O2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1557 1
a1557 1
!   ( c_4 f D - c_2)$.
d1566 1
a1566 1
    dBeta_dT = beta * onedt * ( cont(4) * f * d - cont(2) )
d1574 1
a1574 1
       "$Id: get_beta_path_m.f90,v 2.100 2010/02/05 03:29:09 vsnyder Exp $"
d1584 3
@


2.100
log
@Remove unused dummy arguments
@
text
@d266 1
a266 1
    integer :: I, N
d283 2
d287 1
a287 1
        dBdT => dBeta_dt_path(:,i)
d291 1
a291 1
        dBdn => dBeta_dn_path(:,i)
d295 1
a295 1
        dBdv => dBeta_dv_path(:,i)
d299 1
a299 1
        dBdw => dBeta_dw_path(:,i)
d303 1
a303 1
        dBdIWC => dBeta_dIWC_path(:,i)
d311 1
a311 1
        call create_beta_path_Mie ( frq, t_path, sps_path(:,i), path_inds, &
d315 1
a315 1
        call create_beta_path_Mie ( frq, t_path, sps_path(:,i), path_inds, &
d319 2
a320 2
        do n = 1, size(beta_group(i)%pfa(sx)%molecules)
          if ( beta_group(i)%pfa(sx)%data(frq_i,n)/= 0 ) then
d322 2
a323 2
              & PFAData(beta_group(i)%pfa(sx)%data(frq_i,n)),   &
              & beta_group(i)%pfa(sx)%ratio(n), beta_path(:,i), &
d327 1
a327 1
              call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules(1:n)), &
d334 1
a334 1
        end do ! n = 1, size(beta_group(i)%pfa(sx)%molecules)
d1483 1
a1483 1
       "$Id: get_beta_path_m.f90,v 2.99 2010/02/04 23:10:38 vsnyder Exp $"
d1493 3
@


2.99
log
@Remove USE for unreferenced names
@
text
@d369 1
a369 1
  subroutine Get_Beta_Path_Polarized ( Frq, Flo, H, Beta_group, GL_slabs, &
a384 1
    real(r8), intent(in) :: Flo       ! LO frequency in MHz
d471 1
a471 1
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path,  tt_path, path_inds, &
a480 1
    real(rp), intent(in) :: P_path(:)       ! path pressures in hPa!
d1481 1
a1481 1
       "$Id: get_beta_path_m.f90,v 2.98 2010/01/23 01:20:15 vsnyder Exp $"
d1491 3
@


2.98
log
@Allow betas that depend upon mixing ratio, get beta for Cloud_A and
Cloud_S from the Mie tables, get kinds from MLSKinds instead of MLSCommon
@
text
@d226 1
a226 1
    use Intrinsic, only: L_CloudIce, L_RHi, Lit_Indices
d1483 1
a1483 1
       "$Id: get_beta_path_m.f90,v 2.97 2009/06/23 18:26:11 pwagner Exp $"
d1493 4
@


2.97
log
@Prevent Intel from optimizing ident string away
@
text
@d45 1
a45 1
    use MLSCommon, only: R8, RP, IP
d220 3
a222 2
    & Beta_Group, SX, Vel_Rel, Beta_Path, T_Der_Path_Flags, &
    & dBeta_dT_Path, dBeta_dw_Path, dBeta_dn_Path, dBeta_dv_Path )
d226 3
a228 2
    use Intrinsic, only: L_RHi, Lit_Indices
    use MLSCommon, only: RP, R8
d231 2
d245 1
d255 2
a256 3
! Optional outputs.  We use ASSOCIATED instead of PRESENT so that the
! caller doesn't need multiple branches.  These would be INTENT(OUT) if
! we could say so.
d258 5
a262 4
    real(rp), target :: dBeta_dT_path(:,:) ! Temperature
    real(rp), target :: dBeta_dw_path(:,:) ! line width
    real(rp), target :: dBeta_dn_path(:,:) ! line width t dep.
    real(rp), target :: dBeta_dv_path(:,:) ! line position
d264 1
a264 1
    real(rp), pointer :: dBdn(:), dBdT(:), dBdv(:), dBdw(:) ! slices of dBeta_d*_path
d281 1
a281 1
    nullify ( dBdT, dBdn, dBdv, dBdw )
d300 4
d307 40
a346 6
      do n = 1, size(beta_group(i)%pfa(sx)%molecules)
        if ( beta_group(i)%pfa(sx)%data(frq_i,n)/= 0 ) then
          call create_beta_path_pfa ( frq, p_path, path_inds, t_path, vel_rel, &
            & PFAData(beta_group(i)%pfa(sx)%data(frq_i,n)),   &
            & beta_group(i)%pfa(sx)%ratio(n), beta_path(:,i), &
            & t_der_path_flags, dBdT, dBdw, dBdn, dBdv )
d349 3
a351 3
            call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules(1:n)), &
            & before='PFA Betas for' )
            call output ( frq, before=', FRQ = ', advance='yes' )
d356 1
a356 24
      end do ! n = 1, size(beta_group(i)%pfa(sx)%molecules)

      if ( beta_group(i)%molecule == l_rhi ) then
        !{ Convert specific humidity to relative humidity
        ! \begin{equation}\begin{split}
        ! e_s =\,& \frac1P \exp\left(19.6783-\frac{6140.4}T\right)\\
        ! \beta^{\text{RHi}} =\,& \beta^{\text{H}_2\text{O}} e_s\\
        ! \frac{\partial \beta^{\text{RHi}}}{\partial T} =\,&
        !  e_s \frac{\partial \beta^{\text{H}_2\text{O}}}{\partial T} +
        !  \frac{6140.4}{T^2} \beta^{\text{RHi}}
        ! \end{split}\end{equation}
        es = exp(RHa - RHb/t_path) / p_path(path_inds)
        beta_path(:,i) = beta_path(:,i) * es
        if ( associated(dBdT) ) &
          & dBdT = es * dBdT + RHb / t_path**2 * beta_path(:,i)

        if ( dumpBeta ) then
          call display_string ( lit_indices(l_rhi), before='PFA Betas for ' )
          call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules), &
            & before=' using' )
          call dump ( beta_path(:,i), name='Beta', options=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', options=clean )
        end if
      end if
d375 1
a375 1
    use MLSCommon, only: R8, RP, IP
d476 1
a476 1
    use MLSCommon, only: R8, RP, IP
d555 1
a555 1
    use MLSCommon, only: RP, R8, IP
d746 1
a746 1
    use MLSCommon, only: RP, R8
d972 99
d1077 1
a1077 1
    use MLSCommon, only: RP, R8
d1199 1
a1199 1
      ! beed to weight by ratio here.
d1246 1
a1246 1
    use MLSCommon, only: RP
d1264 1
a1264 1
    use MLSCommon, only: RP
d1293 1
a1293 1
    use MLSCommon, only: RP
d1319 1
a1319 1
    use MLSCommon, only: RP
d1362 1
a1362 1
    use MLSCommon, only: RP
d1388 1
a1388 1
    use MLSCommon, only: RP
d1427 1
a1427 1
    use MLSCommon, only: RP
d1450 1
a1450 1
    use MLSCommon, only: RP
d1483 1
a1483 1
       "$Id: read_apriori.f90 is it here $"
d1493 3
@


2.96
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d1361 1
a1362 1
!---------------------------- RCS Ident Info -------------------------------
d1364 1
a1364 1
    &  "$Id: get_beta_path_m.f90,v 2.95 2009/06/13 01:10:01 vsnyder Exp $"
a1365 1
!---------------------------------------------------------------------------
d1367 1
d1369 1
d1374 3
@


2.95
log
@Label Beta array, option to dump zeta
@
text
@d98 2
a99 1
    logical, save :: Clean, DumpAll, DumpBeta, DumpStop, DumpZeta
d110 3
a112 1
      clean = index(switches,'clean') > 0
d180 2
a181 2
          call dump ( beta_path(:,i), clean=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', clean=clean )
d195 2
a196 2
          call dump ( beta_path(:,i), clean=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', clean=clean )
d207 1
a207 1
        call dump ( -log10(p_path(path_inds)), name='Zetas', clean=clean )
d209 1
a209 1
        call dump ( p_path(path_inds), name='Pressures', clean=clean )
d211 2
a212 2
      call dump ( t_path, name='Temperatures', clean=clean )
      call dump ( tanh_path, name='tanh(h nu / k T)', clean=clean )
d262 2
a263 1
    logical, save :: Clean, DumpAll, DumpBeta, DumpStop
d271 3
a273 1
      clean = index(switches,'clean') > 0
d309 2
a310 2
            call dump ( beta_path(:,i), name='Beta', clean=clean )
            if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', clean=clean )
d333 2
a334 2
          call dump ( beta_path(:,i), name='Beta', clean=clean )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT', clean=clean )
d341 2
a342 2
      call dump ( p_path(path_inds), name='Pressures', clean=clean )
      call dump ( t_path, name='Temperatures', clean=clean )
d391 2
a392 1
    logical, save :: Clean, DumpBeta, DumpStop
d399 3
a401 1
      clean = index(switches,'clean') > 0
d439 1
a439 1
          call dump ( beta_path(:,:,i), name='Beta', clean=clean )
d441 2
a442 2
            call dump ( real(dBeta_path_dT), name='real(dBeta_path_dT)', clean=clean )
            call dump ( aimag(dBeta_path_dT), name='aimag(dBeta_path_dT)', clean=clean )
d1364 1
a1364 1
    &  "$Id: get_beta_path_m.f90,v 2.94 2008/10/03 16:29:56 livesey Exp $"
d1373 3
@


2.94
log
@Added EXTINCTIONV2
@
text
@d98 1
a98 1
    logical, save :: Clean, DumpAll, DumpBeta, DumpStop
d108 1
d177 1
a177 1
          call dump ( beta_path(:,i), name='Beta', clean=clean )
d192 1
a192 1
          call dump ( beta_path(:,i), name='Beta', clean=clean )
d203 5
a207 1
      call dump ( p_path(path_inds), name='Pressures', clean=clean )
d1355 1
a1355 1
    &  "$Id: get_beta_path_m.f90,v 2.93 2008/04/18 22:51:30 vsnyder Exp $"
d1364 3
@


2.93
log
@Correct self-continuum
@
text
@d36 1
a36 1
  subroutine Get_Beta_Path_Scalar ( frq, p_path, t_path, tanh_path, &
d55 1
d157 1
a157 1
          call create_beta_path ( path_inds, p_path, t_path, frq,   &
d164 1
a164 1
          call create_beta_path ( path_inds, p_path, t_path, frq,   &
d338 1
a338 1
  subroutine Get_Beta_Path_Polarized ( Frq, H, Beta_group, GL_slabs, &
d354 1
d506 1
a506 1
  subroutine Create_beta ( pressure, Temp, Fgr, slabs_0, tanh1, &
d522 1
a522 1
    use Molecules, only: L_N2, L_Extinction, L_H2O, L_O2
d533 1
d602 6
d703 1
a703 1
  subroutine Create_beta_path ( Path_inds, Pressure, Temp, Fgr, Ratio,  &
d713 1
a713 1
    use Molecules, only: L_N2, L_Extinction, L_H2O, L_O2
d724 1
d811 6
d1350 1
a1350 1
    &  "$Id: get_beta_path_m.f90,v 2.92 2008/02/29 01:59:39 vsnyder Exp $"
d1359 3
@


2.92
log
@Added a separate H2O continuum routine
@
text
@d95 1
d137 17
d161 1
a161 1
            & dBdT, dBdw, dBdn, dBdv, sps_path(:,i) )
a179 1
      ! Convert specific humidity to relative humidity?
d181 1
a181 1
        es = exp(RHa - RHb/t_path) / p_path(path_inds)
a302 1
      ! Convert specific humidity to relative humidity?
d304 8
d748 3
a750 1
    real(rp), intent(in), optional :: Sps_Path(:) ! Mixing ratios
d818 1
a818 1
              & pressure(k), fgr, sps_path(k), bv, dBdT )
d824 1
a824 1
              & Pressure(k),Fgr,sps_path(k))
d826 1
a826 1
        else ! Same as case default
d1195 1
a1195 1
    dBeta_dT = cont(2)
d1199 3
a1201 2
      beta = beta + dBdf * sps
      dBeta_dT = dBeta_dT + cont(4)
d1203 1
a1203 1
    dBeta_dT = - dBeta_dT * beta * onedt
d1334 1
a1334 1
    &  "$Id: get_beta_path_m.f90,v 2.91 2007/05/23 22:44:24 vsnyder Exp $"
d1343 3
@


2.91
log
@New slabs structure
@
text
@d39 2
a40 1
        & dBeta_dt_path, dBeta_dw_path, dBeta_dn_path, dBeta_dv_path )
d75 3
d137 15
a151 5
        call create_beta_path ( path_inds, p_path, t_path, frq,             &
          & beta_group(i)%lbl(sx)%ratio(n),                                 &
          & gl_slabs(:,beta_group(i)%lbl(sx)%cat_index(n)),                 &
          & tanh_path, noPolarized, velCor,                                 &
          & beta_path(:,i), dTanh_dT, t_der_path_flags, dBdT, dBdw, dBdn, dBdv )
d481 2
a482 2
         &                 Beta_Value, NoPolarized, dTanh_dT,     &
         &                 dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv )
d496 1
a496 1
    use Molecules, only: L_N2, L_Extinction, L_O2
d532 2
d583 9
d670 4
a673 3
  subroutine Create_beta_path ( Path_inds, Pressure, Temp, Fgr, Ratio, &
         &   Slabs_0, Tanh1, NoPolarized, VelCor, Beta_value, dTanh_dT,     &
         &   Path_flags, dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv )
d680 1
a680 1
    use Molecules, only: L_N2, L_Extinction, L_O2
d723 3
d787 25
d1065 1
a1065 1
  ! ----------------------------------------------  Abs_CS_Cont  -----
d1084 1
a1084 1
  ! -------------------------------------------  Abs_CS_Cont_dT  -----
d1112 69
a1180 1
  ! -------------------------------------------  Abs_CS_N2_Cont  -----
d1206 1
a1206 1
  ! ----------------------------------------  Abs_CS_N2_Cont_dT  -----
d1245 1
a1245 1
  ! -------------------------------------------  Abs_CS_O2_Cont  -----
d1268 1
a1268 1
  ! ----------------------------------------  Abs_CS_O2_Cont_dT  -----
d1307 1
a1307 1
    &  "$Id: get_beta_path_m.f90,v 2.90 2006/12/04 21:17:28 vsnyder Exp $"
d1316 3
@


2.90
log
@Reorganize FullForwardModel to use automatic arrays instead of allocating
pointer arrays.  Requires testing for zero size instead of testing for
associated in several subsidiary procedures.
@
text
@d592 1
a592 1
        dNu = Fgr - slabs_0%v0s(ln_i)
d594 1
a594 1
        if ( abs(slabs_0%y(ln_i))+0.666666_rp*abs(slabs_0%x1(ln_i)*dNu) &
d596 3
a598 3
          call Voigt_Lorentz ( dNu, slabs_0%v0s(ln_i), slabs_0%x1(ln_i),         &
            &  slabs_0%yi(ln_i), slabs_0%y(ln_i), lines(catalog%lines(ln_i))%w,  &
            &  Temp, tanh1, slabs_0%slabs1(ln_i), bv, slabs_0%dslabs1_dv0(ln_i), &
d601 3
a603 3
          call DVoigt_Spectral ( dNu, slabs_0%v0s(ln_i), slabs_0%x1(ln_i),       &
            &  slabs_0%yi(ln_i), slabs_0%y(ln_i), lines(catalog%lines(ln_i))%w,  &
            &  Temp, tanh1, slabs_0%slabs1(ln_i), bv, slabs_0%dslabs1_dv0(ln_i), &
d1185 1
a1185 1
    &  "$Id: get_beta_path_m.f90,v 2.89 2006/07/19 22:30:17 vsnyder Exp $"
d1194 5
@


2.89
log
@Cannonball polishing
@
text
@d65 1
a65 3
! Optional inputs.  GL_SLABS_* are pointers because the caller need not
! allocate them if DBETA_D*_PATH aren't allocated.  They would be
! INTENT(IN) if we could say so.
d67 1
a67 1
    logical, pointer :: t_der_path_flags(:)     ! where temperature derivatives
d69 1
a69 1
    real(rp), pointer :: dTanh_dT(:)    ! dTanh( (-h nu) / (k T) ) / dT on path
d82 4
a85 4
    real(rp), pointer :: dBeta_dT_path(:,:) ! Temperature
    real(rp), pointer :: dBeta_dw_path(:,:) ! line width
    real(rp), pointer :: dBeta_dn_path(:,:) ! line width t dep.
    real(rp), pointer :: dBeta_dv_path(:,:) ! line position
d113 1
a113 1
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineWidth_tDep) /= 0 .and. associated(dBeta_dn_path) ) then
d117 1
a117 1
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineCenter) /= 0 .and. associated(dBeta_dv_path) ) then
d121 1
a121 1
      if ( beta_group(i)%lbl(sx)%spect_der_ix(lineWidth) /= 0 .and. associated(dBeta_dw_path) ) then
d127 1
a127 1
      if ( associated(dBeta_dt_path) ) then
d205 1
a205 3
! Optional input.  We use ASSOCIATED instead of PRESENT so that the
! caller doesn't need multiple branches.  This would be INTENT(IN) if
! we could say so.
d207 1
a207 1
    logical, pointer :: T_Der_Path_Flags(:) ! where temperature derivatives
d214 4
a217 4
    real(rp), pointer :: dBeta_dT_path(:,:) ! Temperature
    real(rp), pointer :: dBeta_dw_path(:,:) ! line width
    real(rp), pointer :: dBeta_dn_path(:,:) ! line width t dep.
    real(rp), pointer :: dBeta_dv_path(:,:) ! line position
d236 1
a236 1
      if ( associated(dBeta_dt_path) ) then
d240 1
a240 1
      if ( associated(dBeta_dn_path) ) then
d244 1
a244 1
      if ( associated(dBeta_dv_path) ) then
d248 1
a248 1
      if ( associated(dBeta_dw_path) ) then
d332 1
a332 1
    complex(rp), pointer :: dBeta_path_dT(:,:,:)
d355 1
a355 1
    if ( associated(dBeta_path_dT) ) dBeta_path_dT = 0.0
d365 1
a365 1
          if ( .not. associated(dBeta_path_dT) ) then
d386 1
a386 1
          if ( associated(dBeta_path_dT) ) then
d688 2
a689 2
    real(rp), pointer :: dTanh_dT(:) ! -h nu / (2 k T^2) 1/tanh(...) dTanh(...)/dT
    logical, pointer :: Path_Flags(:) ! to do on fine path -- default true
d722 1
a722 1
      if ( temp_der .and. associated(path_flags) ) temp_der = path_flags(k)
d865 1
a865 1
    logical, pointer :: T_Der_Path(:)   ! To do on fine path -- default true
d902 1
a902 1
      if ( temp_der .and. associated(t_der_path) ) temp_der = t_der_path(k)
d1185 1
a1185 1
    &  "$Id: get_beta_path_m.f90,v 2.88 2006/06/29 01:44:42 vsnyder Exp $"
d1194 3
@


2.88
log
@Add tracing
@
text
@d308 1
a308 1
    use Intrinsic, only: L_RHi, Lit_Indices
d1189 1
a1189 1
    &  "$Id: get_beta_path_m.f90,v 2.87 2006/04/11 18:32:41 vsnyder Exp $"
d1198 3
@


2.87
log
@Add more dumps
@
text
@d48 2
a49 1
    use Toggles, only: Switches
d107 3
d168 3
d1189 1
a1189 1
    &  "$Id: get_beta_path_m.f90,v 2.86 2006/04/05 19:16:49 vsnyder Exp $"
d1198 3
@


2.86
log
@Use the 'clean' switch in some dumps
@
text
@d167 1
d299 1
d301 1
d304 1
d306 2
d311 1
a311 1
    real(r8), intent(in) :: Frq ! frequency in MHz
d337 9
d377 11
d390 2
d1182 1
a1182 1
    &  "$Id: get_beta_path_m.f90,v 2.85 2006/02/23 01:00:17 vsnyder Exp $"
d1191 3
@


2.85
log
@Give spectroscopy vector pointers correct upper bounds
@
text
@d93 1
a93 1
    logical, save :: DumpAll, DumpBeta, DumpStop
d103 1
d139 1
a139 1
            & before='LBL Betas for ' )
d141 2
a142 2
          call dump ( beta_path(:,i), name='Beta' )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT' )
d154 5
a158 5
          call display_string ( lit_indices(beta_group(i)%molecule), &
          & before='LBL Betas for ' )
          call output ( frq, before=', FRQ = ', advance='yes' )
          call dump ( beta_path(:,i), name='Beta' )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT' )
d165 2
a166 2
      call dump ( p_path(path_inds), name='Pressures' )
      call dump ( t_path, name='Temperatures' )
d218 1
a218 1
    logical, save :: DumpAll, DumpBeta, DumpStop
d226 1
d260 1
a260 1
            & before='PFA Betas for ' )
d262 2
a263 2
            call dump ( beta_path(:,i), name='Beta' )
            if ( associated(dBdT) ) call dump ( dBdT, name='dBdT' )
d276 5
a280 5
          call display_string ( lit_indices(beta_group(i)%molecule), &
          & before='PFA Betas for ' )
          call output ( frq, before=', FRQ = ', advance='yes' )
          call dump ( beta_path(:,i), name='Beta' )
          if ( associated(dBdT) ) call dump ( dBdT, name='dBdT' )
d287 2
a288 2
      call dump ( p_path(path_inds), name='Pressures' )
      call dump ( t_path, name='Temperatures' )
d1154 1
a1154 1
    &  "$Id: get_beta_path_m.f90,v 2.84 2006/02/10 21:50:33 vsnyder Exp $"
d1163 3
@


2.84
log
@Move RHi conversion to correct place, spiff up some dumps
@
text
@d92 1
a92 1
    integer(ip) :: I, N
d107 2
d111 1
a111 1
        dBdn => dBeta_dn_path(:,beta_group(i)%lbl(sx)%spect_der_ix(lineWidth_tDep))
d115 1
a115 1
        dBdv => dBeta_dv_path(:,beta_group(i)%lbl(sx)%spect_der_ix (lineCenter))
d119 1
a119 1
        dBdw => dBeta_dw_path(:,beta_group(i)%lbl(sx)%spect_der_ix(lineWidth))
d125 1
a125 1
        dBdT => dBeta_dt_path(:,i)
d1152 1
a1152 1
    &  "$Id: get_beta_path_m.f90,v 2.83 2006/02/08 21:38:18 vsnyder Exp $"
d1161 3
@


2.83
log
@Add relative humidity (RHi) calculation
@
text
@d134 6
a139 6
        ! Convert specific humidity to relative humidity?
        if ( beta_group(i)%molecule == l_rhi ) then
          es = exp(RHa - RHb/t_path) / p_path(path_inds)
          beta_path(:,i) = beta_path(:,i) * es
          if ( associated(dBdT) ) &
            & dBdT = es * dBdT + RHb / t_path**2 * beta_path(:,i)
d141 8
d151 2
a152 2
          call display_string ( lit_indices(beta_group(i)%lbl(sx)%molecules(n)), &
            & before='LBL Betas for ' )
d157 3
a159 2
      end do
    end do
a253 8
          ! Convert specific humidity to relative humidity?
          if ( beta_group(i)%molecule == l_rhi ) then
            es = exp(RHa - RHb/t_path) / p_path(path_inds)
            beta_path(:,i) = beta_path(:,i) * es
            if ( associated(dBdT) ) &
              & dBdT = es * dBdT + RHb / t_path**2 * beta_path(:,i)
          end if

d255 1
a255 1
            call display_string ( lit_indices(beta_group(i)%pfa(sx)%molecules(n)), &
d264 16
d1150 1
a1150 1
    &  "$Id: get_beta_path_m.f90,v 2.82 2006/02/08 01:02:22 vsnyder Exp $"
d1159 3
@


2.82
log
@More stuff for spectroscopy derivatives
@
text
@d24 4
d37 1
a37 1
        & beta_group, NoPolarized, gl_slabs, path_inds,             &
d42 2
a43 2
    use ForwardModelConfig, only: LBL_T, LineCenter, LineWidth, LineWidth_TDep
    use Intrinsic, only: Lit_Indices
d59 2
a60 1
    type (LBL_T), intent(in), dimension(:) :: beta_group
d91 1
d108 2
a109 2
      if ( beta_group(i)%spect_der_ix(lineWidth_tDep) /= 0 .and. associated(dBeta_dn_path) ) then
        dBdn => dBeta_dn_path(:,beta_group(i)%spect_der_ix(lineWidth_tDep))
d112 2
a113 2
      if ( beta_group(i)%spect_der_ix(lineCenter) /= 0 .and. associated(dBeta_dv_path) ) then
        dBdv => dBeta_dv_path(:,beta_group(i)%spect_der_ix (lineCenter))
d116 2
a117 2
      if ( beta_group(i)%spect_der_ix(lineWidth) /= 0 .and. associated(dBeta_dw_path) ) then
        dBdw => dBeta_dw_path(:,beta_group(i)%spect_der_ix(lineWidth))
d127 1
a127 1
      do n = 1, size(beta_group(i)%cat_index)
d129 3
a131 2
          & beta_group(i)%ratio(n), gl_slabs(:,beta_group(i)%cat_index(n)), &
          & tanh_path, noPolarized, velCor, &
d134 8
d143 1
a143 1
          call display_string ( lit_indices(beta_group(i)%molecules(n)), &
d162 1
a162 1
    & Beta_Group, Vel_Rel, Beta_Path, T_Der_Path_Flags, &
d166 2
a167 2
    use ForwardModelConfig, only: PFA_T
    use Intrinsic, only: Lit_Indices
d180 2
a181 1
    type(PFA_t), intent(in) :: Beta_Group(:) ! PFA stuff for the beta group
d204 1
d238 2
a239 2
      do n = 1, size(beta_group(i)%molecules)
        if ( beta_group(i)%data(frq_i,n)/= 0 ) then
d241 11
a251 3
            & PFAData(beta_group(i)%data(frq_i,n)), beta_group(i)%ratio(n), &
            & beta_path(:,i), t_der_path_flags, &
            & dBdT, dBdw, dBdn, dBdv )
d254 1
a254 1
            call display_string ( lit_indices(beta_group(i)%molecules(n)), &
d261 1
a261 1
      end do ! n = 1, size(beta_group(i)%molecules)
d1133 1
a1133 1
    &  "$Id: get_beta_path_m.f90,v 2.81 2005/10/24 20:19:35 vsnyder Exp $"
d1142 3
@


2.81
log
@Corrections for spectroscopy derivatives
@
text
@d38 1
a38 1
    use ForwardModelConfig, only: LBL_T
d99 1
a99 1
    nullify ( dBdn, dBdv, dBdw )
d102 2
a103 2
      if ( associated(dBeta_dn_path) ) then
        dBdn => dBeta_dn_path(:,i)
d106 2
a107 2
      if ( associated(dBeta_dv_path) ) then
        dBdv => dBeta_dv_path(:,i)
d110 2
a111 2
      if ( associated(dBeta_dw_path) ) then
        dBdw => dBeta_dw_path(:,i)
a115 1
      dBdT => null()
d1108 1
a1108 1
    &  "$Id: get_beta_path_m.f90,v 2.80 2005/07/06 02:17:21 vsnyder Exp $"
d1117 3
@


2.80
log
@Revisions for spectral parameter derivatives
@
text
@d568 2
a569 1
  pure subroutine Create_beta_path ( Path_inds, Pressure, Temp, Fgr, Ratio, &
d628 1
a628 1
    real(rp) :: bv, dw, dn, dv, dbdT, dbdw, dbdn, dbdv
d633 3
a635 3
      dbdw = 0.0_rp
      dbdn = 0.0_rp
      dbdv = 0.0_rp
d731 1
a731 1
            & velCor, noPolarized, bv, dw, dn, dv )
d734 1
a734 1
            & velCor, noPolarized, bv, dw, dn, dv )
d739 3
a741 3
        if ( associated(dBeta_dw) ) dBeta_dw(j) = ratio * dw
        if ( associated(dBeta_dn) ) dBeta_dn(j) = ratio * dn
        if ( associated(dBeta_dv) ) dBeta_dv(j) = ratio * dv
d747 1
a747 1
            & dTanh_dT(j), velCor, noPolarized, bv, dBdT, dw, dn, dv )
d750 1
a750 1
            & dTanh_dT(j), velCor, noPolarized, bv, dBdT, dw, dn, dv )
d756 3
a758 3
        if ( associated(dBeta_dw) ) dBeta_dw(j) = ratio * dbdw
        if ( associated(dBeta_dn) ) dBeta_dn(j) = ratio * dbdn
        if ( associated(dBeta_dv) ) dBeta_dv(j) = ratio * dbdv
d1109 1
a1109 1
    &  "$Id: get_beta_path_m.f90,v 2.79 2005/06/09 02:34:16 vsnyder Exp $"
d1118 3
@


2.79
log
@Move stuff from l2pc_pfa_structures to slabs_sw_m
@
text
@d34 2
a35 2
        & beta_path, t_der_path_flags, dTanh_dT, dBeta_dt_path,     &
        & dBeta_dw_path, dBeta_dn_path, dBeta_dv_path )
d67 3
d125 1
a125 1
          & tanh_path, noPolarized, &
d449 1
d455 2
a456 1
    if ( present(dBeta_dw) .or. present(dBeta_dn) .or. present(dBeta_dv) ) then
d508 1
a508 1
    if ( present(dBeta_dw) .or. present(dBeta_dn) .or. present(dBeta_dv) ) then
d569 1
a569 1
         &   Slabs_0, Tanh1, NoPolarized, Beta_value, dTanh_dT,        &
d578 4
a581 4
    use SLABS_SW_M, only: DVOIGT_SPECTRAL, VOIGT_LORENTZ, &
      & SLABS_LINES, SLABS_LINES_DT, SLABSWINT_LINES, SLABSWINT_LINES_DT
    use SpectroscopyCatalog_m, only: LINES
    use Slabs_SW_m, only: SLABS_STRUCT
d604 3
a622 1
    integer :: LN_I              ! Line index
d627 1
a627 1
    real(rp) :: dNu, bv, dw, dn, dv, dbdT, dbdw, dbdn, dbdv
d713 9
a721 1
      else
d723 2
a724 1
        if ( temp_der ) then ! Temperature derivatives required
d726 1
a726 9
          if ( slabs_0(k)%useYi ) then
            call slabswint_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
              & bv, dBdT, noPolarized )
          else
            call slabs_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
              & bv, dBdT, noPolarized )
          end if
          beta_value(j) = beta_value(j) + ratio * bv
          dBeta_dT(j) = dBeta_dT(j) + ratio * dBdT
d728 6
d736 1
a736 2
        if ( spect_der ) then ! Spectroscopy derivatives required
                              ! Will recompute Beta but not use it if temp_der
d738 3
a740 2
          !ocl temp(dNu,dw,dn,dv)
          do ln_i = 1, nl
d742 1
a742 31
            if ( noPolarized ) then
              if ( slabs_0(k)%catalog%polarized(ln_i) ) cycle
            end if

            dNu = Fgr - slabs_0(k)%v0s(ln_i)

            if ( abs(slabs_0(k)%y(ln_i))+0.666666_rp*abs(slabs_0(k)%x1(ln_i)*dNu) &
            & > 100.0_rp ) then
              call Voigt_Lorentz ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), &
                &  lines(slabs_0(k)%catalog%lines(ln_i))%w, temp(j), &
                &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
                &  dw, dn, dv )
            else
              call DVoigt_Spectral ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), &
                &  lines(slabs_0(k)%catalog%lines(ln_i))%w, temp(j), &
                &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
                &  dw, dn, dv )
            end if

            if ( .not. temp_der ) beta_value(j) = beta_value(j) + ratio * bv
            dbdw = dbdw + dw
            dbdn = dbdn + dn
            dbdv = dbdv + dv

          end do

          if ( associated(dBeta_dw) ) dBeta_dw(j) = ratio * dbdw
          if ( associated(dBeta_dn) ) dBeta_dn(j) = ratio * dbdn
          if ( associated(dBeta_dv) ) dBeta_dv(j) = ratio * dbdv
d744 10
a753 1
        end if ! spect_der
d755 5
a759 1
      end if ! neither temp_der nor spect_der
d1108 1
a1108 1
    &  "$Id: get_beta_path_m.f90,v 2.78 2005/06/03 01:58:53 vsnyder Exp $"
d1117 3
@


2.78
log
@New copyright notice, move Id to not_used_here to avoid cascades,
Revise PFA data structures.
@
text
@a39 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d42 1
d52 1
a52 1
    type (slabs_struct), dimension(:,:) :: Gl_slabs
a250 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d253 1
a401 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d408 1
a570 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d576 1
d1111 1
a1111 1
    &  "$Id: get_beta_path_m.f90,v 2.77 2005/05/24 01:55:18 vsnyder Exp $"
d1120 4
@


2.77
log
@Delete unused symbols
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
a24 3
  character (len=*), parameter :: IdParm = &
    &  "$Id: get_beta_path_m.f90,v 2.76 2005/05/02 23:05:01 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
d153 1
d220 1
a220 1
        if ( associated(beta_group(i)%data(frq_i,n)%datum) ) then
d222 1
a222 1
            & beta_group(i)%data(frq_i,n)%datum, beta_group(i)%ratio(n), &
d769 2
a770 1
  pure subroutine Create_Beta_Path_PFA ( Frq, P_Path, Path_Inds, T_Path, Vel_Rel, &
d1109 5
d1120 3
@


2.76
log
@New data structures for PFA
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.75 2005/03/29 01:58:17 vsnyder Exp $"
a147 1
    use PFADataBase_m, only: PFAData
d768 1
a768 1
    use PFADataBase_m, only: PFAData_t, RK
d1108 3
@


2.75
log
@Make stuff pure
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.74 2005/03/26 01:26:29 vsnyder Exp $"
d215 1
a215 1
        if ( beta_group(i)%indices(frq_i,n) /= 0 ) then
d217 1
a217 1
            & PFAData(beta_group(i)%indices(frq_i,n)), beta_group(i)%ratio(n), &
a769 1
    use Physics, only: SpeedOfLight ! M/s
a795 1
    real(r8), parameter :: C = speedOfLight / 1000.0_r8 ! km/s
d1109 3
@


2.74
log
@Make sure dBeta_dw etc get a value even if there are no lines
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.73 2005/03/25 21:04:57 vsnyder Exp $"
d558 1
a558 1
  subroutine Create_beta_path ( Path_inds, Pressure, Temp, Fgr, Ratio, &
a608 1
    real(rp), pointer :: Cont(:) ! continuum parameters
d629 1
a634 1
      cont => slabs_0(k)%catalog%continuum
d642 2
a643 1
          call abs_cs_n2_cont_dT ( cont, temp(j), pressure(k), fgr, bv, dBdT )
d647 2
a648 1
          beta_value(j) = beta_value(j) + abs_cs_n2_cont(cont,Temp(j),Pressure(k),Fgr)
d660 2
a661 1
          call abs_cs_o2_cont_dT ( cont, temp(j), pressure(k), fgr, bv, dBdT )
d665 2
a666 1
          beta_value(j) = beta_value(j) + ratio * abs_cs_o2_cont(cont,Temp(j),Pressure(k),Fgr)
d672 2
a673 1
          call abs_cs_cont_dT ( cont, temp(j), pressure(k), fgr, bv, dBdT )
d677 2
a678 1
          beta_value(j) = beta_value(j) + ratio * abs_cs_cont(cont,Temp(j),Pressure(k),Fgr)
d720 1
d764 1
a764 1
  subroutine Create_Beta_Path_PFA ( Frq, P_Path, Path_Inds, T_Path, Vel_Rel, &
a795 1
    real(rk), pointer :: A(:,:)  ! Absorption from PFAD
a808 2
    a => PFAD%absorption

d818 2
d848 4
a851 4
        & a(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & a(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & a(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & a(t_i1+1,p_i1+1) * t_fac * p_fac )
d900 4
a903 2
          & ( a(t_i1+1,p_i1  ) - a(t_i1,  p_i1  ) ) * (1.0-p_fac) + &
          & ( a(t_i1+1,p_i1+1) - a(t_i1,  p_i1+1) ) * p_fac + &
d955 1
a955 1
  subroutine Abs_CS_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1009 1
a1009 1
  subroutine Abs_CS_N2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1071 1
a1071 1
  subroutine Abs_CS_O2_Cont_dT ( Cont, Temperature, Pressure, Frequency, &
d1111 3
@


2.73
log
@Don't clobber continuum in Create_Beat if there are lines
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.72 2005/03/03 02:07:10 vsnyder Exp $"
d491 6
a496 1
    if ( nl < 1 ) return
d678 6
a683 1
      if ( nl < 1 ) cycle
d1104 3
@


2.72
log
@Move dumps from Create_Beta_Path... to Get_Beta_Path...
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.71 2005/02/17 02:35:13 vsnyder Exp $"
d442 1
a442 1
    real(rp) :: bv, dNu, dw, dn, ds, dbdw, dbdn, dbdv
d531 1
a531 1
          beta_value = slabswint_lines ( Fgr, slabs_0, tanh1, noPolarized )
d533 1
a533 1
          beta_value = slabs_lines ( Fgr, slabs_0, tanh1, noPolarized )
d538 1
a538 1
            & beta_value, dBeta_dT, noPolarized )
d541 1
a541 1
            & beta_value, dBeta_dT, noPolarized )
d543 1
d545 1
d817 1
a817 1
      call hunt ( p_path(k), PFAD%vGrid%surfs(:,1), PFAD%tGrid%noSurfs, &
a838 1

d1094 3
@


2.71
log
@Remove PFA stuff from Channels part of config
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.70 2005/02/16 23:16:50 vsnyder Exp $"
d32 1
d34 1
d37 3
d79 2
d84 7
d119 8
d130 6
d143 1
d145 1
d147 1
d149 2
d182 9
d215 2
a216 2
        if ( beta_group(i)%indices(frq_i,n) /= 0 ) &
          & call create_beta_path_pfa ( frq, p_path, path_inds, t_path, vel_rel, &
d220 9
d233 6
a558 1
    use Dump_0, only: Dump
a561 1
    use Output_m, only: Output
a564 1
    use Toggles, only: Switches
a602 2
    logical, save :: DumpAll, DumpBeta, DumpStop
    logical, save :: First = .true. ! Fist-time flag
a612 7
    if ( first ) then
      first = .false.
      dumpStop = index(switches,'LBLB') > 0
      dumpAll = dumpStop .or. index(switches,'lblB') > 0
      dumpBeta = dumpAll .or. ( index(switches,'lblb') > 0 )
    end if

a742 11
    if ( dumpBeta ) then
      call output ( fgr, before='LBL Betas, FRQ = ', advance='yes' )
      call dump ( beta_value, name='Beta_Value' )
      if ( dumpAll ) then
        call dump ( pressure(path_inds), name='Pressures' )
        call dump ( temp, name='Temperatures' )
      end if
      if ( temp_der ) call dump ( dBeta_dT, name='dBdT' )
      if ( dumpStop ) stop
    end if

a748 1
    use Dump_0, only: Dump
a750 1
    use Output_m, only: Output
a752 1
    use Toggles, only: Switches
a783 2
    logical, save :: DumpAll, DumpBeta, DumpStop
    logical, save :: First = .true. ! First-time flag
a791 7
    if ( first ) then
      first = .false.
      dumpStop = index(switches,'PFAB') > 0
      dumpAll = dumpStop .or. index(switches,'pfaB') > 0
      dumpBeta = dumpAll .or. ( index(switches,'pfab') > 0 )
    end if

a910 12
    if ( dumpBeta ) then
      call output ( frq, before='PFA Betas, FRQ = ' )
      call output ( doppler, before=', Doppler correction = ', advance='yes' )
      call dump ( beta_path, name='Beta_Path' )
      if ( dumpAll ) then
        call dump ( p_path(path_inds), name='Pressures' )
        call dump ( t_path, name='Temperatures' )
      end if
      if ( associated(dBdT) ) call dump ( dBdT, name='dBdT' )
      if ( dumpStop ) stop
    end if

d1093 3
@


2.70
log
@Revise data structures for split-sideband PFA
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.69 2004/12/13 20:47:52 vsnyder Exp $"
d73 1
a73 1
    integer(ip) :: I, N, IB, No_mol
a76 2
    no_mol = size(beta_group)

d79 1
a79 1
    do i = 1, no_mol
a100 1
        ib = beta_group(i)%cat_index(n)
d102 2
a103 1
          & beta_group(i)%ratio(n), gl_slabs(:,ib), tanh_path, noPolarized, &
d111 2
a112 2
  subroutine Get_Beta_Path_PFA ( Frq, P_Path, Path_Inds, T_Path, PFAInds, &
    & BetaInds, Vel_Rel, Beta_Path, T_Der_Path_Flags, &
d115 1
d121 1
d125 1
a125 2
    integer, intent(in) :: PFAInds(:)   ! indices in PFA database
    integer, intent(in) :: BetaInds(:)  ! indices in Beta_path, etc.
d148 1
a148 1
    integer :: I, SV_I
d152 1
a152 2
    do i = 1, size(betaInds)
      sv_i = betaInds(i)
d154 1
a154 1
        dBdT => dBeta_dt_path(:,sv_i)
d158 1
a158 1
        dBdn => dBeta_dn_path(:,sv_i)
d162 1
a162 1
        dBdv => dBeta_dv_path(:,sv_i)
d166 1
a166 1
        dBdw => dBeta_dw_path(:,sv_i)
d170 1
a170 1
      beta_path(:,sv_i) = 0.0_rp
d172 7
a178 4
      if ( PFAInds(i) /= 0 ) &
        & call create_beta_path_pfa ( frq, path_inds, p_path, t_path, vel_rel, &
          & PFAData(PFAInds(i)), beta_path(:,sv_i), t_der_path_flags, &
          & dBdT, dBdw, dBdn, dBdv )
d180 1
a180 1
    end do
d712 2
a713 2
  subroutine Create_Beta_Path_PFA ( Frq, Path_Inds, P_Path, T_Path, Vel_Rel, &
    & PFAD, Beta_Path, T_Der_Path, dBdT, dBdw, dBdn, dBdv )
a724 1
    integer, intent(in) :: Path_inds(:) ! Which Pressures to use
d727 1
d731 1
d748 1
a797 8
      ! Interpolate to get log Beta at the linearization velocity, then
      ! exponentiate to get Beta
      beta_path(j) = exp( &
        & a(t_i1  ,p_i1  ) * (1.0-t_fac) * (1.0-p_fac) + &
        & a(t_i1+1,p_i1  ) * t_fac       * (1.0-p_fac) + &
        & a(t_i1  ,p_i1+1) * (1.0-t_fac) * p_fac       + &
        & a(t_i1+1,p_i1+1) * t_fac * p_fac )

d806 9
a814 2
      ! Now correct beta_path(j) for Doppler
      beta_path(j) = beta_path(j) * ( 1.0 + doppler * dBdNu )
d853 3
d861 1
a861 1
        dBdT(j) = beta_path(j) / (del_t * t_path(j)) * ( &
d873 1
a873 1
      if ( associated(dBdw) ) dBdw(j) = beta_path(j) * ( &
d879 1
a879 1
      if ( associated(dBdn) ) dBdn(j) = beta_path(j) * ( &
d885 1
a885 1
      if ( associated(dBdv) ) dBdv(j) = beta_path(j) * dBdNu
d1083 3
@


2.69
log
@Use Slabs_0%UseYi field instead of MaxVal(Abs(...%yi))
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.68 2004/11/04 03:42:09 vsnyder Exp $"
d32 1
a32 1
    use ForwardModelConfig, only: Beta_Group_T
d45 1
a45 1
    type (beta_group_T), intent(in), dimension(:) :: beta_group
d105 1
a105 1
          & beta_group(i)%lbl_ratio(n), gl_slabs(:,ib), tanh_path, noPolarized, &
d187 1
a187 1
    use ForwardModelConfig, only: Beta_Group_T
d199 1
a199 1
    type (beta_group_T), dimension(:), intent(in) :: Beta_group
d230 1
a230 1
        ratio = beta_group(i)%lbl_ratio(n)
d1078 3
@


2.68
log
@Provide for both LBL_Ratio and PFA_Ratio in beta_group
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.67 2004/11/01 20:26:36 vsnyder Exp $"
a357 1
!    expa(:)        ! exponential argument / frequency (not used)
d361 1
a361 1
    real(rp), intent(in) :: tanh1      ! tanh(frq*expa/2)
d367 1
a367 1
    ! (h frq) / (k T^2) ( tanh( (h frq) / (k T) ) - 1/tanh( (h frq) / (k T) ) ):
a388 1

a391 1

d472 3
a474 1
        if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
a475 2
        else
          beta_value = slabswint_lines ( Fgr, slabs_0, tanh1, noPolarized )
d478 2
a479 2
        if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
          call slabs_lines_dT ( fgr, slabs_0, tanh1, dTanh_dT, &
d482 1
a482 1
          call slabswint_lines_dT ( fgr, slabs_0, tanh1, dTanh_dT, &
a523 1
!    expa(:)        ! exponential argument / frequency (not used)
d527 2
a528 1
    real(rp), intent(in) :: Tanh1(:)   ! tanh(frq*expa/2)
d567 6
d630 1
a630 1
        if ( maxval(ABS(slabs_0(k)%yi)) < 1.0e-06_rp ) then
d632 1
a632 1
            & ratio * slabs_lines ( Fgr, slabs_0(k), tanh1(j), noPolarized )
d635 1
a635 1
            & ratio * slabswint_lines ( Fgr, slabs_0(k), tanh1(j), noPolarized )
d642 2
a643 2
          if ( maxval(ABS(slabs_0(k)%yi)) < 1.0e-06_rp ) then
            call slabs_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
d646 1
a646 1
            call slabswint_lines_dT ( fgr, slabs_0(k), tanh1(j), dTanh_dT(j), &
d1078 3
@


2.67
log
@Reorganization of representation for molecules and beta groups; PFA may be broken for now
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.66 2004/10/06 21:21:21 vsnyder Exp $"
d105 1
a105 1
          & beta_group(i)%ratio(n), gl_slabs(:,ib), tanh_path, noPolarized, &
d230 1
a230 1
        ratio = beta_group(i)%ratio(n)
d1075 3
@


2.66
log
@Change how dumps are done
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.65 2004/09/04 01:50:31 vsnyder Exp $"
d32 1
a32 1
    use Get_Species_Data_m, only: Beta_Group_T
d187 1
a187 1
    use Get_Species_Data_m, only: Beta_Group_T
d256 2
a257 4
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path,  tt_path,       &
        & beta_group, path_inds, beta_path_cloud,                       &
        & w0_path, tt_path_c,                                           & 
        & IPSD, WC, fwdModelConf  )
a259 1
    use Get_Species_Data_m, only: Beta_Group_T
a268 1
    type (beta_group_T), intent(in), dimension(:) :: beta_group
d1075 3
@


2.65
log
@get_beta_path_m.f90
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.64 2004/09/02 18:14:29 vsnyder Exp $"
d174 4
a177 3
      call create_beta_path_pfa ( frq, path_inds, p_path, t_path, vel_rel, &
        & PFAData(PFAInds(i)), beta_path(:,sv_i), t_der_path_flags, &
        & dBdT, dBdw, dBdn, dBdv )
d368 1
a368 1
    ! ! "Don't do line(L) if slabs%catalog%polarized(L)"
d508 1
d512 1
d516 1
d520 1
a520 1
    real(rp), intent(in) :: Pressure(:)! pressure in hPa on the find path grid
d555 2
d567 7
d698 11
d726 2
a727 1
    real(rp), intent(in) :: P_Path(:)   ! Pressure in hPa on the fine path grid
d751 2
d754 1
a754 1
    real(rp) :: LogT             ! Log10 ( temperature )
d761 7
d771 2
a772 1
    !                                     \left( 1 - \frac{v_l}c \right) \right]$
d885 1
a885 1
    if ( index(switches,'pfab') /= 0 .or. index(switches,'pfaB') /= 0 ) then
d889 1
a889 1
      if ( index(switches,'pfaB') /= 0 ) then
d894 1
d1079 3
@


2.64
log
@Doppler correct temperature derivative in PFA
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.63 2004/09/01 01:48:13 vsnyder Exp $"
d114 1
a114 1
    & BetaInds, Vel_Cor, Beta_Path, T_Der_Path_Flags, &
d127 1
a127 1
    real(rp), intent(in) :: Vel_Cor     ! Velocity correction
d174 1
a174 1
      call create_beta_path_pfa ( frq, path_inds, p_path, t_path, vel_cor, &
d688 1
a688 1
  subroutine Create_Beta_Path_PFA ( Frq, Path_Inds, P_Path, T_Path, Vel_Cor, &
d704 1
a704 1
    real(rp), intent(in) :: Vel_Cor     ! Velocity correction, 1.0 - vel_los/c
d739 1
a739 1
    doppler = frq * ( vel_cor - PFAD%vel_cor )
d1043 3
@


2.63
log
@Closing in on PFA
@
text
@d8 1
a8 1
  public :: Create_Beta, Create_Beta_Path
d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.61 2004/08/05 20:59:02 vsnyder Exp $"
d691 1
d694 1
d697 1
d722 1
d724 1
a724 1
    real(rp) :: Del_T            ! Temperature step in tGrid
d735 5
a739 1
    doppler = frq * ( vel_cor - ( 1.0 - PFAD%velLin * 1000.0 / speedOfLight ) )
d780 43
a822 4
      ! Interpolate to get d log Beta / d log T, then multiply by Beta / T
      ! to get dBeta / dT
      if ( temp_der ) &
        & dBdT(j) = beta_path(j) / t_path(j) * ( &
d824 6
a829 1
          & ( a(t_i1+1,p_i1+1) - a(t_i1,  p_i1+1) ) * p_fac )
d832 2
a833 1
      ! dBeta / d*
d850 11
d1043 3
@


2.62
log
@Move initialization for temp_der into loop in create_beta_path
@
text
@d9 2
a10 2
  public :: Get_Beta_Path, Get_Beta_Path_Scalar, Get_Beta_Path_Polarized
  public :: Get_Beta_Path_Cloud
d57 1
a57 1
! outputs
d113 2
a114 2
  subroutine Get_Beta_Path_PFA ( P_Path, Path_Inds, T_Path, PFAInds, &
    & Sps_1, Sps_N, Beta_Path, T_Der_Path_Flags, &
d117 1
a117 1
    use MLSCommon, only: RP
d120 2
d126 2
a127 1
    integer, intent(in) :: Sps_1, Sps_N ! first and last species in Beta_path, etc.
d129 1
d149 1
a149 1
    integer :: I
d153 2
a154 1
    do i = sps_1, sps_n
d156 1
a156 1
        dBdT => dBeta_dt_path(:,i)
d160 1
a160 1
        dBdn => dBeta_dn_path(:,i)
d164 1
a164 1
        dBdv => dBeta_dv_path(:,i)
d168 1
a168 1
        dBdw => dBeta_dw_path(:,i)
d172 6
a177 1
      beta_path(:,i) = 0.0_rp
d200 1
a200 1
! outputs
d282 1
a282 1
! outputs
d370 1
a370 1
! optional inputs for temperature derivatives
d373 1
a373 1
! outputs
d375 1
a375 1
! optional outputs
d535 1
a535 1
! outputs
d542 1
a542 1
! optional outputs
d687 112
d979 3
@


2.61
log
@Get rid of beta_group%n_elements
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.60 2004/08/03 22:06:45 vsnyder Exp $"
a553 1
    temp_der = associated(dBeta_dT)
d557 1
d857 3
@


2.60
log
@Inching further toward PFA
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.59 2004/07/08 21:00:23 vsnyder Exp $"
d102 1
a102 1
      do n = 1, beta_group(i)%n_elements
d218 1
a218 1
      do n = 1, beta_group(i)%n_elements
d857 3
@


2.59
log
@Inching toward PFA
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.58 2004/04/19 21:03:29 vsnyder Exp $"
d43 1
a43 1
    integer(ip), intent(in) :: Path_inds(:) ! indicies for reading gl_slabs
d53 2
a54 3
    logical, pointer :: t_der_path_flags(:)     ! indicies where temperature
!                               derivatives are needed. Only useful for
!                               subsetting.
d113 57
a169 1
  subroutine Get_Beta_Path_PFA
d857 3
@


2.58
log
@Remove unused stuff; respect tder_path_flags
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.57 2004/04/17 00:37:00 vsnyder Exp $"
d28 2
a29 3
        & beta_group, NoPolarized, gl_slabs, path_inds,               &
        & beta_path,    &
        & t_der_path_flags, dTanh_dT, dBeta_dt_path,                &
d113 4
a440 1
!  We can't do both temperature and spectroscopy derivatives.
d802 3
@


2.57
log
@Analytic temperature derivatives
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.56 2004/04/02 00:59:24 vsnyder Exp $"
a35 1
    use Physics, only: H_OVER_K
a66 18
!{ The variable {\tt dBeta\_dT\_path} isn't really
!  $\frac{\partial\beta}{\partial T}$.  First, we evaluate $\beta$ at
!  $T+\delta T$ and $T-\delta T$.  These are called {\tt bp} and {\tt bm}
!  below.  We assume $\beta$ has the form
!
!  $\beta_0 \left(\frac{T}{T_0}\right) ^n$.  Taking logarithms, we have $\ln
!  (\beta / \beta_0) = n ( \ln ( T / T_0 ) )$.  Assuming $n$ doesn't change
!  too quickly as a function of $T$, you can solve for $n$ from estimates of
!  $\beta(T)$ and $\beta(T+\delta T)$ (you need $\beta$ at two temperatures
!  because you don't know $\beta_0$ and $T_0$).  Actually, we use three
!  estimates for $\frac{\partial\beta}{\partial T}$, \emph{viz}.
!  $(\beta(T+\delta T) - \beta(T-\delta T)) / ( 2 \delta T)$,
!  $(\beta(T+\delta T) - \beta(T) ) / \delta T$, and $(\beta(T) - \beta(T -
!  \delta T)) / \delta T$, from which we compute three estimates for $n$. 
!  It's the value of $n$ that's returned in {\tt dBeta\_dT\_path}, not
!  $\frac{\partial\beta}{\partial T}$.  $\frac{\partial\beta}{\partial T}$ is
!  actually assembled in {\tt dRad\_tran\_dT}.

d75 1
a75 3
    integer(ip) :: I, J, K, N, IB, No_mol, N_path
    real(rp) :: BB, BP, BM
    real(rp) :: T
a79 1
    n_path = size(path_inds)
d108 1
a108 1
          & beta_path(:,i), dTanh_dT, dBdT, dBdw, dBdn, dBdv )
d433 1
a433 1
         &   dBeta_dT, dBeta_dw, dBeta_dn, dBeta_dv, Path_flags  )
d471 1
a471 1
! Optional input for temperature derivatives:
d473 1
a480 3
! Optional inputs
    logical, intent(in), optional :: Path_Flags(:) ! to do on fine path -- default true

d501 1
a501 1
      if ( temp_der .and. present(path_flags) ) temp_der = path_flags(k)
d800 3
@


2.56
log
@Get catalog from slabs structure
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.55 2004/03/27 03:35:27 vsnyder Exp $"
d29 1
a29 1
        & beta_path, gl_slabs_m, t_path_m, gl_slabs_p, t_path_p,    &
d31 1
a31 1
        & beta_n_path, dBeta_dw_path, dBeta_dn_path, dBeta_dv_path )
a54 6
    type(slabs_struct), pointer :: gl_slabs_m(:,:) ! reduced strength data
!                               for t_path_m
    real(rp), pointer :: t_path_m(:) ! path temperatures for gl_slabs_m
    type(slabs_struct), pointer :: gl_slabs_p(:,:) ! reduced
!                               strength data for t_path_p
    real(rp), pointer :: t_path_p(:) ! path temperatures for gl_slabs_p
a86 1
    real(rp), pointer :: beta_n_path(:,:)   ! n in beta = beta_0 (T/T_0)^n
a96 2
    real(rp), dimension(size(path_inds)) :: betam, betap
    real(rp), dimension(size(path_inds)) :: tanh1_p, tanh1_m, TM, TP
d118 1
d120 6
a127 3

        dBdT => null()
        if ( associated(dBeta_dt_path) ) dBdT => dBeta_dt_path(:,i)
a133 54
    if ( associated(beta_n_path) ) then

      beta_n_path(1:n_path,:) = 0.0
      tm = t_path_m(path_inds)
      tp = t_path_p(path_inds)
      ! compute path hyperbolic tangents
      tanh1_p = tanh(0.5_rp * h_over_k * frq / tp)
      tanh1_m = tanh(0.5_rp * h_over_k * frq / tm)

      do i = 1, no_mol
        betam = 0.0
        betap = 0.0
        do n = 1, beta_group(i)%n_elements
          ib = beta_group(i)%cat_index(n)
          call create_beta_path ( path_inds, p_path, tm, frq,                 &
            & beta_group(i)%ratio(n), gl_slabs_m(:,ib), tanh1_m, noPolarized, &
            & betam, dTanh_dT=null(), dBeta_dT=null(),                        &
            & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() ,             &
            & path_flags=t_der_path_flags )
          call create_beta_path ( path_inds, p_path, tp, frq,                 &
            & beta_group(i)%ratio(n), gl_slabs_p(:,ib), tanh1_p, noPolarized, &
            & betap, dTanh_dT=null(), dBeta_dT=null(),                        &
            & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null(),              &
            & path_flags=t_der_path_flags )
        end do ! n
        do j = 1 , n_path
          k = path_inds(j)
          t  = t_path(j)
          bm = betam(j)
          bp = betap(j)
          bb = beta_path(j,i)
          n = 0
          if ( bm > 0.0 ) n = 1
          if ( bb > 0.0 ) n = n + 2
          if ( bp > 0.0 ) n = n + 4
          select case ( n )
          case ( 7 ) ! bp > 0.0 .and. bb > 0.0 .and. bm > 0.0
            beta_n_path(j,i) =  0.25 * ( &           ! Weighted average of
              &       Log(bp/bb)/Log(tp(j)/t) + &    ! Estimate over [temp+10,temp]
              & 2.0 * Log(bp/bm)/Log(tp(j)/tm(j))+ & ! Estimate over [temp+10,temp-10]
              &       Log(bb/bm)/Log(t/tm(j)) )      ! Estimate over [temp,temp-10]
          case ( 6 ) ! bp > 0.0 .and. bb > 0.0
            beta_n_path(j,i) = Log(bp/bb)/Log(tp(j)/t) ! Estimate over [temp+10,temp]
          case ( 5 ) ! bm > 0.0 .and. bp > 0.0
            beta_n_path(j,i) = Log(bp/bm)/Log(tp(j)/tm(j)) ! Estimate over [temp+10,temp-10]
          case ( 3 ) ! bm > 0.0 .and. bb > 0.0
            beta_n_path(j,i) = Log(bb/bm)/Log(t/tm(j)) ! Estimate over [temp,temp-10]
          case default
            beta_n_path(j,i) = 0.0
          end select
        end do ! j
      end do ! i
    end if

d138 1
a138 1
                                     & Path_inds, Beta_path )
d143 1
a143 1
    use O2_Abs_CS_m, only: O2_Abs_CS
d165 2
d172 1
d179 1
d189 11
a199 2
          call o2_abs_cs ( frq, (/ ( -1, m=1,size(gl_slabs(k,ib)%catalog%lines) ) /),   &
            & h(k), gl_slabs(k,ib), sigma_p, pi, sigma_m )
d521 1
a524 1
      temp_der = associated(dBeta_dT)
d803 1
a803 1
!   ( 2 c_4 f D - c_2)$.
d812 1
a812 1
    dBeta_dT = beta * onedt * ( 2.0 * cont(4) * f * d - cont(2) )
d824 3
@


2.55
log
@Add pointer to catalog in slabs_struct.  Use it so as not to need to drag
line centers and line widths around.  Write slabs_lines and slabswint_lines
to get sum of beta over all lines; put slabs_struct instead of its components
in the calling sequence.
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.54 2004/03/20 04:08:55 vsnyder Exp $"
d28 1
a28 1
        & beta_group, polarized, gl_slabs, path_inds,               &
a36 1
    use SpectroscopyCatalog_m, only: CATALOG_T, LINES
d47 1
a47 1
    type (beta_group_T), dimension(:) :: beta_group
d49 1
a49 1
    logical, intent(in) :: Polarized     ! "Don't work on Zeeman-split lines"
d100 2
a101 4
    type(catalog_t), pointer :: Catalog
    real(rp), pointer :: dBdn(:), dBdv(:), dBdw(:) ! slices of dBeta_d*_path
    integer(ip) :: I, J, K, N, IB, No_of_lines, &
              &    No_mol, N_path
a113 10
    ! Determine size of the LineWidths array.
    no_of_lines = 0
    do i = 1, no_mol
      do n = 1, beta_group(i)%n_elements
        ib = beta_group(i)%cat_index(n)
        catalog => gl_slabs(1,ib)%catalog ! GL_slabs(:,ib) all have the same catalog
        no_of_lines = max(no_of_lines,size(catalog%lines))
      end do
    end do

a129 2
        catalog => gl_slabs(1,ib)%catalog ! GL_slabs(:,ib) all have the same catalog
        no_of_lines = size(catalog%lines)
d131 5
a135 13
        ! The polarized and nonpolarized calls are split so that Create_Beta_Path
        ! can go to the "don't bother to test polarized" loop.  Create_Beta_Path
        ! is the inner loop of the forward model.  It also avoids construction
        ! of an array temp (polarized .and. catalog%polarized).
        if ( polarized ) then
          call create_beta_path ( path_inds, p_path, t_path, frq,                &
            & beta_group(i)%ratio(n), gl_slabs(:,ib), tanh_path, beta_path(:,i), &
            & catalog%polarized, dBeta_dw=dBdw, dBeta_dn=dBdn, dBeta_dv=dBdv )
        else
          call create_beta_path ( path_inds, p_path, t_path, frq,                &
            & beta_group(i)%ratio(n), gl_slabs(:,ib), tanh_path, beta_path(:,i), &
            & dBeta_dw=dBdw, dBeta_dn=dBdn, dBeta_dv=dBdv )
        end if
d153 10
a162 21
          catalog => gl_slabs(1,ib)%catalog ! GL_slabs(:,ib) all have the same catalog
          no_of_lines = size(catalog%lines)
          if ( polarized ) then
            call create_beta_path ( path_inds, p_path, tm, frq,             &
              & beta_group(i)%ratio(n), gl_slabs_m(:,ib), tanh1_m, betam,   &
              & catalog%polarized, t_der_path_flags,                        &
              & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
            call create_beta_path ( path_inds, p_path, tp, frq,             &
              & beta_group(i)%ratio(n), gl_slabs_p(:,ib), tanh1_p, betap,   &
              & catalog%polarized, t_der_path_flags,                        &
              & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
          else
            call create_beta_path ( path_inds, p_path, tm, frq,                &
              & beta_group(i)%ratio(n), gl_slabs_m(:,ib), tanh1_m, betam,      &
              & path_flags=t_der_path_flags, dBeta_dw=null(), dBeta_dn=null(), &
              & dBeta_dv=null() )
            call create_beta_path ( path_inds, p_path, tp, frq,                &
              & beta_group(i)%ratio(n), gl_slabs_p(:,ib), tanh1_p, betap,      &
              & path_flags=t_der_path_flags, dBeta_dw=null(), dBeta_dn=null(), &
              & dBeta_dv=null() )
          end if
d196 2
a197 2
  subroutine Get_Beta_Path_Polarized ( Frq, H, &
        & Catalog, Beta_group, GL_slabs, Path_inds, Beta_path )
a202 1
    use SpectroscopyCatalog_m, only: CATALOG_T
a208 1
    type(catalog_t), intent(in) :: Catalog(:)
d244 2
a245 4
          call o2_abs_cs ( frq, (/ ( -1, m=1,size(catalog(ib)%polarized) ) /), &
            & h(k), gl_slabs(k,ib), catalog(ib)%polarized,        &
            & catalog(ib)%continuum(1), catalog(ib)%continuum(3), &
            & sigma_p, pi, sigma_m )
a261 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
d266 6
a271 4
    real(r8), intent(in) :: Frq ! frequency in MHz
    real(rp), intent(in) :: T_path(:)   ! path temperatures
    real(rp), intent(in) :: P_path(:)   ! path pressures in hPa!
    real(rp), intent(in) :: tt_path(:,:)   ! scating source func on gl grids
d273 1
a273 1
    integer(ip), intent(in) :: Path_inds(:) ! indicies for reading gl_slabs
a274 1
    type (beta_group_T), dimension(:) :: beta_group
d277 4
a280 4
    INTEGER, intent(in) :: IPSD(:)
    REAL(rp), intent(in)  :: WC(:,:)
    REAL(rp) :: W0       ! SINGLE SCATTERING ALBEDO
    REAL(rp) :: PHH(fwdModelConf%num_scattering_angles)   ! PHASE FUNCTION
a287 4
! Optional outputs.  We use ASSOCIATED instead of PRESENT so that the
! caller doesn't need multiple branches.  These would be INTENT(OUT) if
! we could say so.

d290 1
a290 1
    INTEGER :: NC, NU, NUA, NAB, NR, N
d292 2
a293 2
    integer(ip) :: i, j, k, n_path
    real(rp) :: cld_ext, RHI
d297 6
a302 6
          Incl_Cld  = fwdModelConf%Incl_Cld
          NU  = fwdModelConf%NUM_SCATTERING_ANGLES
          NUA = fwdModelConf%NUM_AZIMUTH_ANGLES
          NAB = fwdModelConf%NUM_AB_TERMS
          NR  = fwdModelConf%NUM_SIZE_BINS
          N   = fwdModelConf%no_cloud_species
d310 2
a311 2
        do j = 1, n_path
          k = path_inds(j)
d313 7
a319 7
          call get_beta_cloud (Frq, t_path(k),                       &
                          &  WC(:,k), IPSD(k), NC, NU, NUA, NAB, NR, &
                          &  cld_ext, W0, PHH                )      

            beta_path_cloud(j) = beta_path_cloud(j) + cld_ext 
            w0_path(j)         = w0_path(j) + W0 
            tt_path_c(j)       = tt_path_c(j)       + tt_path(k,1)            
d321 1
a321 1
         end do
d328 1
a328 1
         &                 Beta_Value, Polarized, dTanh_dT,     &
d346 2
a347 1
      & SLABS_DT, SLABS_LINES, SLABSWINT_DT, SLABSWINT_LINES
d367 2
a368 2
    ! "Don't do this line" -- same size as slabs_0%catalog%lines
    logical, intent(in), optional :: Polarized(:)
a386 1
    integer(ip) :: molecule         ! molecule id
d388 1
a388 1
    real(rp) :: bv, dNu, dT, dw, dn, ds, dbdw, dbdn, dbdv
d445 2
a446 2
        if ( present(polarized) ) then
          if ( polarized(ln_i) ) cycle
d475 1
a475 5
    else if ( present(polarized) ) then  ! No spectroscopy derivatives required

      ! This is split into polarized and unpolarized loops, to avoid
      ! having "if ( present(polarized) )" inside the loop.  This is
      ! the inner loop of the forward model.
d479 1
a479 1
          beta_value = slabs_lines ( Fgr, slabs_0, tanh1, polarized )
d481 1
a481 1
          beta_value = slabswint_lines ( Fgr, slabs_0, tanh1, polarized )
d485 2
a486 10
          do ln_i = 1, nl
            if ( polarized(ln_i) ) cycle
            call slabs_dT ( &
              & Fgr, lines(catalog%lines(ln_i))%v0, slabs_0%v0s(ln_i),          &
              & slabs_0%x1(ln_i), tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i), &
              & slabs_0%dv0s_dT(ln_i), slabs_0%dx1_dT(ln_i), dTanh_dT,          &
              & slabs_0%dslabs1_dT(ln_i), slabs_0%dy_dT(ln_i), bv, dT )
            beta_value = beta_value + bv
            dBeta_dT = dBeta_dT + dT
          end do
d488 2
a489 44
          do ln_i = 1, nl
            if ( polarized(ln_i) ) cycle
            call slabswint_dT ( &
              & Fgr, lines(catalog%lines(ln_i))%v0, slabs_0%v0s(ln_i),          &
              & slabs_0%x1(ln_i), tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i), &
              & slabs_0%yi(ln_i), slabs_0%dv0s_dT(ln_i), slabs_0%dx1_dT(ln_i),  &
              & dTanh_dT, slabs_0%dslabs1_dT(ln_i), slabs_0%dy_dT(ln_i),        &
              & slabs_0%dyi_dT(ln_i), bv, dT )
            beta_value = beta_value + bv
            dBeta_dT = dBeta_dT + dT
          end do
        end if
      end if

    else ! Still no spectroscopy derivatives required

      if ( .not. present(dBeta_dT) ) then
        if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
          beta_value = slabs_lines ( Fgr, slabs_0, tanh1 )
        else
          beta_value = slabswint_lines ( Fgr, slabs_0, tanh1 )
        end if
      else ! Temperature derivatives needed
        if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
          do ln_i = 1, nl
            call slabs_dT ( &
              & Fgr, lines(catalog%lines(ln_i))%v0, slabs_0%v0s(ln_i),          &
              & slabs_0%x1(ln_i), tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i), &
              & slabs_0%dv0s_dT(ln_i), slabs_0%dx1_dT(ln_i), dTanh_dT,          &
              & slabs_0%dslabs1_dT(ln_i), slabs_0%dy_dT(ln_i), bv, dT )
            beta_value = beta_value + bv
            dBeta_dT = dBeta_dT + dT
          end do
        else
          do ln_i = 1, nl
            call slabswint_dT ( &
              & Fgr, lines(catalog%lines(ln_i))%v0, slabs_0%v0s(ln_i),          &
              & slabs_0%x1(ln_i), tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i), &
              & slabs_0%yi(ln_i), slabs_0%dv0s_dT(ln_i), slabs_0%dx1_dT(ln_i),  &
              & dTanh_dT, slabs_0%dslabs1_dT(ln_i), slabs_0%dy_dT(ln_i),        &
              & slabs_0%dyi_dT(ln_i), bv, dT )
            beta_value = beta_value + bv
            dBeta_dT = dBeta_dT + dT
          end do
d500 2
a501 3
         &   Slabs_0, Tanh1, Beta_value, Polarized, Path_flags,        &
         &   Slabs_p, Tanh1_p, Slabs_m, Tanh1_m,                       &
         &   dBeta_dw, dBeta_dn, dBeta_dv  )
d503 4
a506 2
!  For a given frequency and height, compute beta_value function.
!  This routine should be called for primary and image separately.
d509 1
a509 1
    use MLSCommon, only: RP, R8, IP
d512 1
a512 1
      & SLABS_LINES, SLABSWINT_LINES
d533 2
a534 3
    ! "Don't do this line" -- same size as slabs_0(k)%catalog%lines
    logical, intent(in), optional :: Polarized(:)
    logical, intent(in), optional :: Path_Flags(:) ! to do on fine path -- default true
a535 3
! optional inputs for temperature derivatives
    type(slabs_struct), intent(in), optional :: Slabs_p(:), Slabs_m(:)
    real(rp), intent(in), optional :: Tanh1_p(:), Tanh1_m(:) ! tanh(frq*expa/2)
d538 4
d543 1
d548 3
d554 5
a558 3
    integer :: J, K   ! Subscript, loop inductor
    integer :: LN_I   ! Line index
    integer :: NL     ! no of lines
d560 1
a560 1
    real(rp) :: dNu, tp, bp, tm, bm, bv, dw, dn, ds, dbdw, dbdn, dbdv
d564 3
a566 1
    nl = size(slabs_0(1)%v0s) ! All of the slabs have the same number of lines
d570 2
a571 9
      if ( present(path_flags) ) then
        if ( .not. path_flags(k) ) cycle
      end if

      tp = Temp(j) + 10.0_rp
      tm = Temp(j) - 10.0_rp

!  Setup absorption coefficients function
!  Now get the beta_value:
a575 2
! This nominally gets multiplied by "ratio**2" but in practice this
! function is for all isotopics forms of N2 hence the ratio is one.
d577 10
a586 1
        beta_value(j) = beta_value(j) + abs_cs_n2_cont(cont,Temp(j),Pressure(k),Fgr)
d591 2
a592 1
        cycle
d596 7
a602 1
        beta_value(j) = beta_value(j) + ratio * abs_cs_o2_cont(cont,Temp(j),Pressure(k),Fgr)
d606 7
a612 1
        beta_value(j) = beta_value(j) + ratio * abs_cs_cont(cont,Temp(j),Pressure(k),Fgr)
d618 1
a618 1
      if ( associated(dBeta_dw) .or. associated(dBeta_dn) .or. associated(dBeta_dv) ) then
d620 8
a627 2
        if ( present(polarized) ) then
          do ln_i = 1, nl
d629 1
a629 1
            if ( polarized(ln_i) ) cycle
d631 1
a631 1
            dNu = Fgr - slabs_0(k)%v0s(ln_i)
d633 9
a641 14
            if ( abs(slabs_0(k)%y(ln_i))+0.666666_rp*abs(slabs_0(k)%x1(ln_i)*dNu) &
            & > 100.0_rp ) then
              call Voigt_Lorentz ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), &
                &  lines(slabs_0(k)%catalog%lines(ln_i))%w, temp(j), &
                &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
                &  dw, dn, ds )
            else
              call DVoigt_Spectral ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), &
                &  lines(slabs_0(k)%catalog%lines(ln_i))%w, temp(j), &
                &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
                &  dw, dn, ds )
            end if
d643 1
a643 4
            beta_value(j) = beta_value(j) + ratio * bv
            dbdw = dbdw + dw
            dbdn = dbdn + dn
            dbdv = dbdv + ds
d645 2
a646 1
          end do
d648 1
a648 1
        else
d650 3
a652 1
          do ln_i = 1, nl
d662 1
a662 1
                &  dw, dn, ds )
d668 1
a668 1
                &  dw, dn, ds )
d671 1
a671 1
            beta_value(j) = beta_value(j) + ratio * bv
d674 1
a674 1
            dbdv = dbdv + ds
d678 3
a680 1
        end if
d682 1
a682 3
        if ( associated(dBeta_dw)) dBeta_dw(j) = ratio * dbdw
        if ( associated(dBeta_dn)) dBeta_dn(j) = ratio * dbdn
        if ( associated(dBeta_dv)) dBeta_dv(j) = ratio * dbdv
d684 1
a684 1
      else                ! No derivatives required
a685 10
        ! Add in sum of betas for all the lines
        if ( maxval(ABS(slabs_0(k)%yi)) < 1.0e-06_rp ) then
          beta_value(j) = beta_value(j) + &
            & ratio * slabs_lines ( Fgr, slabs_0(k), tanh1(j), polarized )
        else
          beta_value(j) = beta_value(j) + &
            & ratio * slabswint_lines ( Fgr, slabs_0(k), tanh1(j), polarized )
        end if

      end if
d870 6
@


2.54
log
@Steps along the way to analytic temperature derivatives
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.53 2004/03/20 01:15:23 jonathan Exp $"
d28 4
a31 4
        & Catalog, beta_group, polarized, gl_slabs, path_inds,     &
        & beta_path, gl_slabs_m, t_path_m, gl_slabs_p, t_path_p,   &
        & t_der_path_flags,                                        &
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path)
a44 1
    type(catalog_t), intent(in) :: Catalog(:)
d58 1
a58 1
    real(rp), intent(in) :: t_path_m(:) ! path temperatures for gl_slabs_m
d61 1
a61 1
    real(rp), intent(in) :: t_path_p(:) ! path temperatures for gl_slabs_p
d65 1
d93 5
a97 4
    real(rp), pointer :: dbeta_dt_path(:,:) ! n in beta = beta_0 (T/T_0)^n
    real(rp), pointer :: dbeta_dw_path(:,:) ! line width
    real(rp), pointer :: dbeta_dn_path(:,:) ! line width t dep.
    real(rp), pointer :: dbeta_dv_path(:,:) ! line position
d101 1
d103 1
a103 1
    integer(ip) :: I, J, K, N, IB, Molecule, No_of_lines, &
a106 1
    real(r8), allocatable, dimension(:) :: LineCenter, LineWidth
d122 2
a123 1
        no_of_lines = max(no_of_lines,size(catalog(ib)%lines))
a125 1
    allocate ( LineCenter(no_of_lines), LineWidth(no_of_lines) )
d143 2
a144 6
        molecule = catalog(ib)%molecule
        no_of_lines = size(catalog(ib)%lines)
        do k = 1, no_of_lines
          lineCenter(k) = lines(catalog(ib)%lines(k))%v0
          lineWidth(k) = lines(catalog(ib)%lines(k))%w
        end do
d149 1
a149 1
        ! of an array temp (polarized .and. catalog(ib)%polarized).
d151 1
a151 3
          call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
            & p_path, t_path,                                                 &
            & frq, lineCenter(:no_of_lines), lineWidth(:no_of_lines),         &
d153 1
a153 1
            & catalog(ib)%polarized, dBeta_dw=dBdw, dBeta_dn=dBdn, dBeta_dv=dBdv )
d155 1
a155 3
          call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
            & p_path, t_path,                                                 &
            & frq, lineCenter(:no_of_lines), lineWidth(:no_of_lines),         &
d162 1
a162 1
    if ( associated(dbeta_dt_path) ) then
d164 1
a164 1
      dbeta_dt_path(1:n_path,:) = 0.0
d176 2
a177 5
          Molecule = Catalog(ib)%molecule
          no_of_lines = size(catalog(ib)%lines)
          do k = 1, no_of_lines
            lineWidth(k) = lines(catalog(ib)%lines(k))%w
          end do ! k
d179 3
a181 5
            call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
              & p_path, tm, frq,                                                &
              & lineCenter(:no_of_lines), lineWidth(:no_of_lines),              &
              & beta_group(i)%ratio(n), gl_slabs_m(:,ib), tanh1_m, betam,       &
              & catalog(ib)%polarized, t_der_path_flags,                        &
d183 3
a185 5
            call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
              & p_path, tp, frq,                                                &
              & lineCenter(:no_of_lines), lineWidth(:no_of_lines),              &
              & beta_group(i)%ratio(n), gl_slabs_p(:,ib), tanh1_p, betap,       &
              & catalog(ib)%polarized, t_der_path_flags,                        &
d188 3
a190 5
            call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
              & p_path, tm, frq,                                                &
              & lineCenter(:no_of_lines), lineWidth(:no_of_lines),              &
              & beta_group(i)%ratio(n), gl_slabs_m(:,ib), tanh1_m, betam,       &
              & path_flags=t_der_path_flags, dBeta_dw=null(), dBeta_dn=null(),  &
d192 3
a194 5
            call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
              & p_path, tp, frq,                                                &
              & lineCenter(:no_of_lines), lineWidth(:no_of_lines),              &
              & beta_group(i)%ratio(n), gl_slabs_p(:,ib), tanh1_p, betap,       &
              & path_flags=t_der_path_flags, dBeta_dw=null(), dBeta_dn=null(),  &
d210 1
a210 1
            dbeta_dt_path(j,i) =  0.25 * ( &         ! Weighted average of
d215 1
a215 1
            dbeta_dt_path(j,i) = Log(bp/bb)/Log(tp(j)/t) ! Estimate over [temp+10,temp]
d217 1
a217 1
            dbeta_dt_path(j,i) = Log(bp/bm)/Log(tp(j)/tm(j)) ! Estimate over [temp+10,temp-10]
d219 1
a219 1
            dbeta_dt_path(j,i) = Log(bb/bm)/Log(t/tm(j)) ! Estimate over [temp,temp-10]
d221 1
a221 1
            dbeta_dt_path(j,i) = 0.0
a226 2
    deallocate ( lineCenter, lineWidth )

d369 3
a371 4
  subroutine Create_beta ( molecule, cont, pressure, Temp, Fgr, v0, pfaw, &
         &   slabs_0, tanh1, beta_value, polarized,                  &
         &   slabs_p, tanh1_p, slabs_m, tanh1_m,                     &
         &   t_power, dbeta_dw, dbeta_dn, dbeta_dv  )
d387 3
a389 1
    use SLABS_SW_M, only: DVOIGT_SPECTRAL, VOIGT_LORENTZ, SLABSWINT, SLABS
a391 2
    integer(ip), intent(in) :: molecule ! molecule id
    real(rp), intent(in) :: cont(:)    ! continuum parameters
a394 3
    real(r8), intent(in) :: v0(:)      ! line centers
    real(r8), intent(in) :: pfaw(:)    ! line widths
    real(rp), intent(in) :: tanh1      ! tanh(frq*expa/2)
d397 1
d406 4
a409 1
    logical, intent(in), optional :: Polarized(:)! "Don't do this line" -- same size as pfaw
d412 2
a413 2
    type(slabs_struct), intent(in), optional :: slabs_p, slabs_m
    real(rp), intent(in), optional :: tanh1_p, tanh1_m ! tanh(frq*expa/2)
d417 1
a417 1
    real(rp), optional, intent(out) :: T_POWER ! for temperature derivative
d424 5
a428 2
    integer(ip) :: LN_I
    integer(ip) :: NL ! no of lines
d430 1
a430 1
    real(rp) :: ra, dNu, tp, bp, tm, bm, bv, dw, dn, ds, dbdw, dbdn, dbdv
d434 1
a434 6
    nl = size(pfaw)

    tp = Temp + 10.0_rp
    tm = Temp - 10.0_rp

    if ( present(dbeta_dw) .or. present(dbeta_dn) .or. present(dbeta_dv) ) then
d445 4
a448 1
    select case ( molecule )
d451 4
a454 4
      beta_value = abs_cs_n2_cont(cont,Temp,Pressure,Fgr)
      if ( present(t_power) ) then
        bm = abs_cs_n2_cont(cont,tm,Pressure,Fgr)
        bp = abs_cs_n2_cont(cont,tp,Pressure,Fgr)
d460 1
a460 1
      if ( present(t_power)) t_power = 0.0_rp
d465 4
a468 4
      beta_value = abs_cs_o2_cont(cont,Temp,Pressure,Fgr)
      if ( present(t_power) ) then
        bm = abs_cs_o2_cont(cont,tm,Pressure,Fgr)
        bp = abs_cs_o2_cont(cont,tp,Pressure,Fgr)
d473 4
a476 4
      beta_value = abs_cs_cont(cont,Temp,Pressure,Fgr)
      if ( present(t_power) ) then
        bm = abs_cs_cont(cont,tm,Pressure,Fgr)
        bp = abs_cs_cont(cont,tp,Pressure,Fgr)
d481 1
a481 9
    if ( nl < 1 ) then
      if ( present(t_power) ) then
        ds = log(bp/beta_value)/log(tp/temp)  ! Estimate over [temp+10,temp]
        ra = log(bp/bm)/        log(tp/tm)    ! Estimate over [temp+10,temp-10]
        dw = log(beta_value/bm)/log(temp/tm)  ! Estimate over [temp,temp-10]
        t_power = 0.25 * (ds + 2.0 * ra + dw) ! Weighted Average
      end if
      return
    end if
d483 1
a483 1
    if ( present(dbeta_dw) .or. present(dbeta_dn) .or. present(dbeta_dv) ) then
d495 3
a497 3
          call Voigt_Lorentz ( dNu, slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &  slabs_0%yi(ln_i), slabs_0%y(ln_i), pfaw(ln_i), Temp, &
            &  tanh1, slabs_0%slabs1(ln_i), bv, slabs_0%dslabs1_dv0(ln_i), &
d500 3
a502 3
          call DVoigt_Spectral ( dNu, slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &  slabs_0%yi(ln_i), slabs_0%y(ln_i), pfaw(ln_i), Temp, &
            &  tanh1, slabs_0%slabs1(ln_i), bv, slabs_0%dslabs1_dv0(ln_i), &
d513 3
a515 3
      if ( present(dbeta_dw)) dbeta_dw = dbdw
      if ( present(dbeta_dn)) dbeta_dn = dbdn
      if ( present(dbeta_dv)) dbeta_dv = dbdv
d517 1
a517 1
    else if ( present(polarized) ) then  ! No derivatives required
d523 31
a553 15
      if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
        do ln_i = 1, nl
          if ( polarized(ln_i) ) cycle
          beta_value = beta_value + &
            &  Slabs(Fgr, v0(ln_i), slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &        tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i))
        end do
      else
        do ln_i = 1, nl
          if ( polarized(ln_i) ) cycle
          beta_value = beta_value + &
            &  Slabswint(Fgr, v0(ln_i), slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &            tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i),          &
            &            slabs_0%yi(ln_i))
        end do
d556 1
a556 1
    else ! Still no derivatives required
d558 29
a586 13
      if ( maxval(ABS(slabs_0%yi)) < 1.0e-06_rp ) then
        do ln_i = 1, nl
          beta_value = beta_value + &
            &  Slabs(Fgr, v0(ln_i), slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &        tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i))
        end do
      else
        do ln_i = 1, nl
          beta_value = beta_value + &
            &  Slabswint(Fgr, v0(ln_i), slabs_0%v0s(ln_i), slabs_0%x1(ln_i), &
            &            tanh1, slabs_0%slabs1(ln_i), slabs_0%y(ln_i),          &
            &            slabs_0%yi(ln_i))
        end do
a590 35
    if ( present(t_power) ) then

!  Find the temperature power dependency now:

      if ( maxval(abs(slabs_0%yi)) < 1.0e-6_rp ) then
        do ln_i = 1, nl
          if ( present(polarized) ) then
            if ( polarized(ln_i) ) cycle
          end if
          bp = bp + Slabs(Fgr, v0(ln_i), slabs_p%v0s(ln_i), slabs_p%x1(ln_i), &
            &             tanh1_p, slabs_p%slabs1(ln_i),slabs_p%y(ln_i))
          bm = bm + Slabs(Fgr, v0(ln_i), slabs_m%v0s(ln_i), slabs_m%x1(ln_i), &
            &             tanh1_m, slabs_m%slabs1(ln_i),slabs_m%y(ln_i))
        end do
      else
        do ln_i = 1, nl
          if ( present(polarized) ) then
            if ( polarized(ln_i) ) cycle
          end if
          bp = bp + Slabswint(Fgr, v0(ln_i), slabs_p%v0s(ln_i),             &
            &                 slabs_p%x1(ln_i), tanh1_p, slabs_p%slabs1(ln_i), &
            &                 slabs_p%y(ln_i), slabs_p%yi(ln_i))
          bm = bm + Slabswint(Fgr, v0(ln_i), slabs_m%v0s(ln_i),             &
            &                 slabs_m%x1(ln_i), tanh1_m, slabs_p%slabs1(ln_i), &
            &                 slabs_p%y(ln_i), slabs_p%yi(ln_i))
        end do
      end if

      ds = Log(bp/beta_value)/Log(tp/Temp)  ! Estimate over [temp+10,temp]
      ra = Log(bp/bm)/        Log(tp/tm)    ! Estimate over [temp+10,temp-10]
      dw = Log(beta_value/bm)/Log(Temp/tm)  ! Estimate over [temp,temp-10]
      t_power = 0.25 * (ds + 2.0 * ra + dw) ! Weighted Average

    end if

d595 4
a598 5
  subroutine Create_beta_path ( Molecule, Cont, Path_inds, Pressure, &
         &   Temp, Fgr, V0, Pfaw, Ratio,                             &
         &   Slabs_0, Tanh1, Beta_value, Polarized, Path_flags,      &
         &   Slabs_p, Tanh1_p, Slabs_m, Tanh1_m,                     &
         &   T_power, dBeta_dw, dBeta_dn, dBeta_dv  )
d606 3
a608 1
    use SLABS_SW_M, only: DVOIGT_SPECTRAL, VOIGT_LORENTZ, SLABSWINT, SLABS
a610 2
    integer(ip), intent(in) :: Molecule ! molecule id
    real(rp), intent(in) :: Cont(:)    ! continuum parameters
a614 2
    real(r8), intent(in) :: V0(:)      ! line centers
    real(r8), intent(in) :: Pfaw(:)    ! line widths
d618 1
d628 2
a629 1
    logical, intent(in), optional :: Polarized(:)  ! "Don't do this line" -- same size as pfaw
a637 1
    real(rp), optional, intent(out) :: T_power(:) ! for temperature derivative
d644 1
d646 2
a647 2
    integer :: LN_I
    integer :: NL ! no of lines
d649 1
a649 1
    real(rp) :: ra, dNu, tp, bp, tm, bm, bv, dw, dn, ds, dbdw, dbdn, dbdv
d653 1
a653 1
    nl = size(pfaw)
d667 2
a668 1
      select case ( molecule )
a673 4
        if ( present(t_power) ) then
          bm = abs_cs_n2_cont(cont,tm,Pressure(k),Fgr)
          bp = abs_cs_n2_cont(cont,tp,Pressure(k),Fgr)
        end if
a677 1
        if ( present(t_power)) t_power(j) = 0.0_rp
a682 4
        if ( present(t_power) ) then
          bm = abs_cs_o2_cont(cont,tm,Pressure(k),Fgr)
          bp = abs_cs_o2_cont(cont,tp,Pressure(k),Fgr)
        end if
a686 4
        if ( present(t_power) ) then
          bm = abs_cs_cont(cont,tm,Pressure(k),Fgr)
          bp = abs_cs_cont(cont,tp,Pressure(k),Fgr)
        end if
d690 1
a690 11
      if ( nl < 1 ) then
        if ( present(t_power) ) then ! t_power depends only on extinction
          bp = bp * ratio ! We really don't care how BP and BM are scaled, but
          bm = bm * ratio ! they have to be scaled like BETA_VALUE!
          ds = log(bp/beta_value(j))/log(tp/temp(j)) ! Estimate over [temp(j)+10,temp(j)]
          ra = log(bp/bm)           /log(tp/tm)      ! Estimate over [temp(j)+10,temp(j)-10]
          dw = log(beta_value(j)/bm)/log(temp(j)/tm) ! Estimate over [temp(j),temp(j)-10]
          t_power(j) = 0.25 * (ds + 2.0 * ra + dw)   ! Weighted Average
        end if
        cycle
      end if
d692 1
a692 1
      if ( associated(dbeta_dw) .or. associated(dbeta_dn) .or. associated(dbeta_dv) ) then
d704 2
a705 1
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
d710 2
a711 1
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
d732 2
a733 1
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
d738 2
a739 1
                &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
d753 3
a755 3
        if ( associated(dbeta_dw)) dbeta_dw(j) = ratio * dbdw
        if ( associated(dbeta_dn)) dbeta_dn(j) = ratio * dbdn
        if ( associated(dbeta_dv)) dbeta_dv(j) = ratio * dbdv
d759 1
d761 2
a762 16
          if ( present(polarized) ) then
            do ln_i = 1, nl
              if ( polarized(ln_i) ) cycle
              beta_value(j) = beta_value(j) + ratio * &
              &   Slabs(Fgr, v0(ln_i), slabs_0(k)%v0s(ln_i), &
              &         slabs_0(k)%x1(ln_i), tanh1(j), &
              &         slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i))
            end do
          else
            do ln_i = 1, nl
              beta_value(j) = beta_value(j) + ratio * &
                &  Slabs(Fgr, v0(ln_i), slabs_0(k)%v0s(ln_i), &
                &        slabs_0(k)%x1(ln_i), tanh1(j), &
                &        slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i))
            end do
          end if
d764 2
a765 18
          if ( present(polarized) ) then
            do ln_i = 1, nl
              if ( polarized(ln_i) ) cycle
              beta_value(j) = beta_value(j) + ratio * &
              &   Slabswint(Fgr, v0(ln_i), slabs_0(k)%v0s(ln_i), &
              &             slabs_0(k)%x1(ln_i), tanh1(j), &
              &             slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i), &
              &             slabs_0(k)%yi(ln_i))
            end do
          else
            do ln_i = 1, nl
              beta_value(j) = beta_value(j) + ratio * &
                &  Slabswint(Fgr, v0(ln_i), slabs_0(k)%v0s(ln_i), &
                &            slabs_0(k)%x1(ln_i), tanh1(j), &
                &            slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i), &
                &            slabs_0(k)%yi(ln_i))
            end do
          end if
d769 1
a769 62

      if ( present(t_power) ) then

!  Find the temperature power dependency now:

        if ( present(polarized) ) then
          if ( maxval(abs(slabs_0(k)%yi)) < 1.0e-6_rp ) then
            do ln_i = 1, nl
              if ( polarized(ln_i) ) cycle
              bp = bp + Slabs(Fgr, v0(ln_i), slabs_p(k)%v0s(ln_i), &
                &             slabs_p(k)%x1(ln_i), tanh1_p(j),     &
                &             slabs_p(k)%slabs1(ln_i),slabs_p(k)%y(ln_i))
              bm = bm + Slabs(Fgr, v0(ln_i), slabs_m(k)%v0s(ln_i), &
                &             slabs_m(k)%x1(ln_i), tanh1_m(j),     &
                &             slabs_m(k)%slabs1(ln_i),slabs_m(k)%y(ln_i))
            end do
          else
            do ln_i = 1, nl
              if ( polarized(ln_i) ) cycle
              bp = bp + Slabswint(Fgr, v0(ln_i), slabs_p(k)%v0s(ln_i), &
                &                 slabs_p(k)%x1(ln_i), tanh1_p(j),     &
                &                 slabs_p(k)%slabs1(ln_i), slabs_p(k)%y(ln_i), &
                &                 slabs_p(k)%yi(ln_i))
              bm = bm + Slabswint(Fgr, v0(ln_i), slabs_m(k)%v0s(ln_i), &
                &                 slabs_m(k)%x1(ln_i), tanh1_m(j),     &
                &                 slabs_m(k)%slabs1(ln_i), slabs_m(k)%y(ln_i), &
                &                 slabs_m(k)%yi(ln_i))
            end do
          end if
        else ! not polarized
          if ( maxval(abs(slabs_0(k)%yi)) < 1.0e-6_rp ) then
            do ln_i = 1, nl
              bp = bp + Slabs(Fgr, v0(ln_i), slabs_p(k)%v0s(ln_i), &
                &             slabs_p(k)%x1(ln_i), tanh1_p(j),     &
                &             slabs_p(k)%slabs1(ln_i),slabs_p(k)%y(ln_i))
              bm = bm + Slabs(Fgr, v0(ln_i), slabs_m(k)%v0s(ln_i), &
                &             slabs_m(k)%x1(ln_i), tanh1_m(j),     &
                &             slabs_m(k)%slabs1(ln_i),slabs_m(k)%y(ln_i))
            end do
          else
            do ln_i = 1, nl
              bp = bp + Slabswint(Fgr, v0(ln_i), slabs_p(k)%v0s(ln_i), &
                &                 slabs_p(k)%x1(ln_i), tanh1_p(j),     &
                &                 slabs_p(k)%slabs1(ln_i), slabs_p(k)%y(ln_i), &
                &                 slabs_p(k)%yi(ln_i))
              bm = bm + Slabswint(Fgr, v0(ln_i), slabs_m(k)%v0s(ln_i), &
                &                 slabs_m(k)%x1(ln_i), tanh1_m(j),     &
                &                 slabs_m(k)%slabs1(ln_i), slabs_m(k)%y(ln_i), &
                &                 slabs_m(k)%yi(ln_i))
            end do
          end if
        end if

        bp = bp * ratio ! We really don't care how BP and BM are scaled, but
        bm = bm * ratio ! they have to be scaled like BETA_VALUE!
        ds = Log(bp/beta_value(j))/Log(tp/temp(j))  ! Estimate over [temp(j)+10,temp(j)]
        ra = Log(bp/bm)           /Log(tp/tm)       ! Estimate over [temp(j)+10,temp(j)-10]
        dw = Log(beta_value(j)/bm)/Log(temp(j)/tm)  ! Estimate over [temp(j),temp(j)-10]
        t_power(j) = t_power(j) + 0.25 * (ds + 2.0 * ra + dw) ! Weighted Average

      end if
    end do ! j
d903 1
a903 1
    theta = 300.0_rp / temperature
d905 2
a906 2
    Abs_CS_O2_Cont_r = cont(1) * pressure * pressure * fsqr * (theta**cont(2)) &
                   & / (fsqr + (cont(3) * pressure * (theta**cont(4)) )**2 )
d953 3
@


2.53
log
@ minor changes
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.52 2004/03/19 04:07:31 vsnyder Exp $"
d245 1
a245 1
    deallocate ( lineWidth )
d933 28
d987 39
d1049 35
d1092 3
@


2.52
log
@Fix some blunders re dNu for spectral derivatives
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.51 2004/03/19 00:47:02 vsnyder Exp $"
d313 1
a313 1
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path,                 &
d315 1
a315 1
        & w0_path,                                                 & 
d328 2
a329 1
    
d343 2
a344 1
    real(rp), intent(out) :: w0_path(:)    ! single scattering albedo
d368 3
a370 2
    beta_path_cloud = 0.0
    w0_path    = 0.0
d380 2
a381 1
            w0_path(j) = w0_path(j) + W0 
d990 3
@


2.51
log
@Use line center instead of pressure-shifted line center in a few places
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.50 2004/02/27 22:47:32 bill Exp $"
d514 1
a514 1
        dNu = Fgr - v0(ln_i)
d748 1
a748 1
            dNu = Fgr - v0(ln_i)
d774 1
a774 1
            dNu = Fgr - v0(ln_i)
d986 3
@


2.50
log
@fixed bug in n2 continuum calc
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.49 2004/01/26 21:57:00 vsnyder Exp $"
d105 1
a105 1
    real(rp), allocatable, dimension(:) :: LineWidth
d124 1
a124 1
    allocate ( LineWidth(no_of_lines) )
d145 1
d155 3
a157 2
            & p_path, t_path, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
            & gl_slabs(:,ib), tanh_path, beta_path(:,i),                      &
d161 3
a163 2
            & p_path, t_path, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
            & gl_slabs(:,ib), tanh_path, beta_path(:,i),                      &
d190 3
a192 2
              & p_path, tm, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
              & gl_slabs_m(:,ib), tanh1_m, betam,                               &
d196 3
a198 2
              & p_path, tp, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
              & gl_slabs_p(:,ib), tanh1_p, betap,                               &
d203 5
a207 3
              & p_path, tm, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
              & gl_slabs_m(:,ib), tanh1_m, betam,  path_flags=t_der_path_flags, &
              & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
d209 5
a213 3
              & p_path, tp, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
              & gl_slabs_p(:,ib), tanh1_p, betap, path_flags=t_der_path_flags,  &
              & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
d385 1
a385 1
  subroutine Create_beta ( molecule, cont, pressure, Temp, Fgr, pfaw, &
d402 1
a402 1
    use MLSCommon, only: RP, IP
d411 3
a413 2
    real(rp), intent(in) :: fgr        ! frequency in MHz
    real(rp), intent(in) :: pfaw(:)    ! line widths
d514 1
a514 1
        dNu = Fgr - slabs_0%v0s(ln_i)
d550 2
a551 3
            &  Slabs(Fgr - slabs_0%v0s(ln_i), slabs_0%v0s(ln_i), &
            &        slabs_0%x1(ln_i), tanh1, &
            &        slabs_0%slabs1(ln_i), slabs_0%y(ln_i))
d557 3
a559 4
            &  Slabswint(Fgr - slabs_0%v0s(ln_i), slabs_0%v0s(ln_i), &
            &            slabs_0%x1(ln_i), tanh1, &
            &            slabs_0%slabs1(ln_i), &
            &            slabs_0%y(ln_i), slabs_0%yi(ln_i))
d568 2
a569 3
            &  Slabs(Fgr - slabs_0%v0s(ln_i), slabs_0%v0s(ln_i), &
            &        slabs_0%x1(ln_i), tanh1, &
            &        slabs_0%slabs1(ln_i), slabs_0%y(ln_i))
d574 3
a576 4
            &  Slabswint(Fgr - slabs_0%v0s(ln_i), slabs_0%v0s(ln_i), &
            &            slabs_0%x1(ln_i), tanh1, &
            &            slabs_0%slabs1(ln_i), &
            &            slabs_0%y(ln_i), slabs_0%yi(ln_i))
d591 4
a594 6
          bp = bp + Slabs(Fgr - slabs_p%v0s(ln_i), slabs_p%v0s(ln_i), &
            &             slabs_p%x1(ln_i), tanh1_p, &
            &             slabs_p%slabs1(ln_i),slabs_p%y(ln_i))
          bm = bm + Slabs(Fgr - slabs_m%v0s(ln_i), slabs_m%v0s(ln_i), &
            &             slabs_m%x1(ln_i), tanh1_m, &
            &             slabs_m%slabs1(ln_i),slabs_m%y(ln_i))
d601 6
a606 8
          bp = bp + Slabswint(Fgr - slabs_p%v0s(ln_i), slabs_p%v0s(ln_i), &
            &                 slabs_p%x1(ln_i), tanh1_p, &
            &                 slabs_p%slabs1(ln_i), slabs_p%y(ln_i), &
            &                 slabs_p%yi(ln_i))
          bm = bm + Slabswint(Fgr - slabs_m%v0s(ln_i), slabs_m%v0s(ln_i), &
            &                 slabs_m%x1(ln_i), tanh1_m, &
            &                 slabs_m%slabs1(ln_i), slabs_m%y(ln_i), &
            &                 slabs_m%yi(ln_i))
d622 1
a622 1
         &   Temp, Fgr, Pfaw, Ratio,                                 &
d631 1
a631 1
    use MLSCommon, only: RP, IP
d641 3
a643 2
    real(rp), intent(in) :: Fgr        ! frequency in MHz
    real(rp), intent(in) :: Pfaw(:)    ! line widths
d748 1
a748 1
            dNu = Fgr - slabs_0(k)%v0s(ln_i)
d774 1
a774 1
            dNu = Fgr - slabs_0(k)%v0s(ln_i)
d807 5
a811 5
              if ( .not. polarized(ln_i) ) &
                & beta_value(j) = beta_value(j) + ratio * &
                &   Slabs(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
                &        slabs_0(k)%x1(ln_i), tanh1(j), &
                &        slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i))
d816 1
a816 1
                &  Slabs(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
d824 6
a829 6
              if ( .not. polarized(ln_i) ) &
                & beta_value(j) = beta_value(j) + ratio * &
                &   Slabswint(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
                &            slabs_0(k)%x1(ln_i), tanh1(j), &
                &            slabs_0(k)%slabs1(ln_i), &
                &            slabs_0(k)%y(ln_i), slabs_0(k)%yi(ln_i))
d834 1
a834 1
                &  Slabswint(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
d836 2
a837 2
                &            slabs_0(k)%slabs1(ln_i), &
                &            slabs_0(k)%y(ln_i), slabs_0(k)%yi(ln_i))
d852 2
a853 2
              bp = bp + Slabs(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
                &             slabs_p(k)%x1(ln_i), tanh1_p(j), &
d855 2
a856 2
              bm = bm + Slabs(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
                &             slabs_m(k)%x1(ln_i), tanh1_m(j), &
d862 2
a863 2
              bp = bp + Slabswint(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
                &                 slabs_p(k)%x1(ln_i), tanh1_p(j), &
d866 2
a867 2
              bm = bm + Slabswint(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
                &                 slabs_m(k)%x1(ln_i), tanh1_m(j), &
d875 2
a876 2
              bp = bp + Slabs(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
                &             slabs_p(k)%x1(ln_i), tanh1_p(j), &
d878 2
a879 2
              bm = bm + Slabs(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
                &             slabs_m(k)%x1(ln_i), tanh1_m(j), &
d884 2
a885 2
              bp = bp + Slabswint(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
                &                 slabs_p(k)%x1(ln_i), tanh1_p(j), &
d888 2
a889 2
              bm = bm + Slabswint(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
                &                 slabs_m(k)%x1(ln_i), tanh1_m(j), &
d986 3
@


2.49
log
@Improve TeXnicalities
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.48 2003/12/07 19:46:10 jonathan Exp $"
d693 2
d696 1
a696 1
        beta_value(j) = beta_value(j) + ratio * abs_cs_n2_cont(cont,Temp(j),Pressure(k),Fgr)
d940 1
a940 1
    real(rp) :: THETA, FSQR, FSXT
d946 2
a947 2
                   & ( cont(1) * exp(-cont(3) * fsxt * theta) + &
                   &   cont(4) * exp(-cont(5) * fsxt * theta) * &
d983 3
@


2.48
log
@update for use in 2D cloud FWM
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.47 2003/08/20 21:12:39 bill Exp $"
d80 6
a85 3
!  $\beta_0 \left(\frac{T}{T_0}\right) ^n$.  Taking logarithms, we have
!  $\ln \beta = \ln \beta_0 + n \ln T - n \ln T_0$.
!  Using three estimates for $\frac{\partial\beta}{\partial T}$, \emph{viz}.
d87 5
a91 5
!  $(\beta(T+\delta T) - \beta(T) ) / \delta T$, and
!  $(\beta(T) - \beta(T - \delta T)) / \delta T$, we compute three estimates
!  for $n$.  It's the value of $n$ that's returned in {\tt dBeta\_dT\_path},
!  not $\frac{\partial\beta}{\partial T}$.  $\frac{\partial\beta}{\partial T}$
!  is actually assembled in {\tt dRad\_tran\_dT}.
d93 1
a93 1
    real(rp), pointer :: dbeta_dt_path(:,:) ! t dep.
d981 3
@


2.47
log
@fixed tanh1 bug associated with T-ders
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.46 2003/07/15 17:50:30 vsnyder Exp $"
d303 1
a303 1
        & beta_path_w0,  beta_path_phh,                                 & 
d330 1
a330 2
    real(rp), intent(out) :: beta_path_w0(:)    ! single scattering albedo
    real(rp), intent(out) :: beta_path_phh(:,:)   ! phase function
d355 1
a355 2
    beta_path_w0    = 0.0
    beta_path_phh   = 0.0
d365 2
a366 3
            beta_path_w0(j) = beta_path_w0(j) + W0 
            beta_path_phh(j,:) = beta_path_phh(j,:) + PHH(:) 
            
d978 3
@


2.46
log
@Callers need t_der_path_flags to be a pointer
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.45 2003/07/14 22:45:09 vsnyder Exp $"
d169 2
a170 2
      tanh1_p = tanh(0.5_rp * h_over_k * frq / tm)
      tanh1_m = tanh(0.5_rp * h_over_k * frq / tp)
d660 1
a660 1
    real(rp), intent(out) :: Beta_value(:)
d981 3
@


2.45
log
@Scale BP, BM by isotope ratio in t_power computation
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.44 2003/07/11 22:43:37 vsnyder Exp $"
d63 1
a63 1
    logical, intent(in) :: t_der_path_flags(:)     ! indicies where temperature
d981 3
@


2.44
log
@Multiply the continuum-derived Beta by the isotope ratio
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.43 2003/07/09 22:47:43 vsnyder Exp $"
d725 3
a727 1
        if ( present(t_power) ) then
d729 1
a729 1
          ra = log(bp/bm)/        log(tp/tm)         ! Estimate over [temp(j)+10,temp(j)-10]
d891 2
d894 1
a894 1
        ra = Log(bp/bm)/        Log(tp/tm)          ! Estimate over [temp(j)+10,temp(j)-10]
d981 3
@


2.43
log
@Make separate branches for the polarized and nonpolarized cases, so
we don't need to check "if (present(polarized))" inside the loop.  This
is the inner loop for the full forward model.
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.42 2003/07/07 19:53:51 vsnyder Exp $"
a32 1
!   use CREATE_BETA_M, only: CREATE_BETA
d51 1
a51 1
    logical, intent(in) :: Polarized    ! "Don't work on Zeeman-split lines"
d57 2
a58 2
    type(slabs_struct), pointer :: gl_slabs_m(:,:) ! reduced
!                               strength data for t_path_m
d63 3
a65 3
    logical, pointer :: t_der_path_flags(:)
!                                   indicies where temperature
! derivatives are needed. Only useful for subsetting.
d95 1
a95 1
! Local variables..
a100 1
!   real(rp) :: Ratio
a101 1
!   real(rp) :: VP, V0, VM
a111 5
!   beta_path = 0.0

!   if ( associated(dbeta_dw_path) ) dbeta_dw_path(1:n_path,:) = 0.0
!   if ( associated(dbeta_dn_path) ) dbeta_dn_path(1:n_path,:) = 0.0
!   if ( associated(dbeta_dv_path) ) dbeta_dv_path(1:n_path,:) = 0.0
d196 1
a196 1
              & gl_slabs_m(:,ib), tanh1_m, betam,                               &
d200 1
a200 1
              & gl_slabs_p(:,ib), tanh1_p, betap,                               &
d653 1
a653 1
    logical, intent(in), optional :: Polarized(:)! "Don't do this line" -- same size as pfaw
d694 1
a694 1
        beta_value(j) = beta_value(j) + abs_cs_n2_cont(cont,Temp(j),Pressure(k),Fgr)
d702 1
a702 1
        beta_value(j) = beta_value(j) + 1.0_rp
d708 1
a708 1
        beta_value(j) = beta_value(j) + abs_cs_o2_cont(cont,Temp(j),Pressure(k),Fgr)
d716 1
a716 1
        beta_value(j) = beta_value(j) + abs_cs_cont(cont,Temp(j),Pressure(k),Fgr)
d729 1
a729 1
          t_power(j) = 0.25 * (ds + 2.0 * ra + dw) ! Weighted Average
d736 2
a737 1
        do ln_i = 1, nl
a738 1
          if ( present(polarized) ) then
a739 1
          end if
d741 27
a767 1
          dNu = Fgr - slabs_0(k)%v0s(ln_i)
d769 17
a785 12
          if ( abs(slabs_0(k)%y(ln_i))+0.666666_rp*abs(slabs_0(k)%x1(ln_i)*dNu) &
          & > 100.0_rp ) then
            call Voigt_Lorentz ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
              &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
              &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
              &  dw, dn, ds )
          else
            call DVoigt_Spectral ( dNu, slabs_0(k)%v0s(ln_i), slabs_0(k)%x1(ln_i), &
              &  slabs_0(k)%yi(ln_i), slabs_0(k)%y(ln_i), pfaw(ln_i), temp(j), &
              &  tanh1(j), slabs_0(k)%slabs1(ln_i), bv, slabs_0(k)%dslabs1_dv0(ln_i), &
              &  dw, dn, ds )
          end if
d787 1
a787 4
          beta_value(j) = beta_value(j) + ratio * bv
          dbdw = dbdw + dw
          dbdn = dbdn + dn
          dbdv = dbdv + ds
d789 1
a789 1
        end do
d798 16
a813 9
          do ln_i = 1, nl
            if ( present(polarized) ) then
              if ( polarized(ln_i) ) cycle
            end if
            beta_value(j) = beta_value(j) + ratio * &
              &  Slabs(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
              &        slabs_0(k)%x1(ln_i), tanh1(j), &
              &        slabs_0(k)%slabs1(ln_i), slabs_0(k)%y(ln_i))
          end do
d815 18
a832 10
          do ln_i = 1, nl
            if ( present(polarized) ) then
              if ( polarized(ln_i) ) cycle
            end if
            beta_value(j) = beta_value(j) + ratio * &
              &  Slabswint(Fgr - slabs_0(k)%v0s(ln_i), slabs_0(k)%v0s(ln_i), &
              &            slabs_0(k)%x1(ln_i), tanh1(j), &
              &            slabs_0(k)%slabs1(ln_i), &
              &            slabs_0(k)%y(ln_i), slabs_0(k)%yi(ln_i))
          end do
d841 3
a843 3
        if ( maxval(abs(slabs_0(k)%yi)) < 1.0e-6_rp ) then
          do ln_i = 1, nl
            if ( present(polarized) ) then
d845 9
a853 11
            end if
            bp = bp + Slabs(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
              &             slabs_p(k)%x1(ln_i), tanh1_p(j), &
              &             slabs_p(k)%slabs1(ln_i),slabs_p(k)%y(ln_i))
            bm = bm + Slabs(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
              &             slabs_m(k)%x1(ln_i), tanh1_m(j), &
              &             slabs_m(k)%slabs1(ln_i),slabs_m(k)%y(ln_i))
          end do
        else
          do ln_i = 1, nl
            if ( present(polarized) ) then
d855 32
a886 10
            end if
            bp = bp + Slabswint(Fgr - slabs_p(k)%v0s(ln_i), slabs_p(k)%v0s(ln_i), &
              &                 slabs_p(k)%x1(ln_i), tanh1_p(j), &
              &                 slabs_p(k)%slabs1(ln_i), slabs_p(k)%y(ln_i), &
              &                 slabs_p(k)%yi(ln_i))
            bm = bm + Slabswint(Fgr - slabs_m(k)%v0s(ln_i), slabs_m(k)%v0s(ln_i), &
              &                 slabs_m(k)%x1(ln_i), tanh1_m(j), &
              &                 slabs_m(k)%slabs1(ln_i), slabs_m(k)%y(ln_i), &
              &                 slabs_m(k)%yi(ln_i))
          end do
d977 5
@


2.42
log
@Move newly-public Create_Beta and Create_Beta_Path above the 'Private
Procedures' comment
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.41 2003/07/07 19:08:38 vsnyder Exp $"
a145 1
!       ratio = beta_group(i)%ratio(n)
a151 24
         
!       do j = 1, n_path
!         k = path_inds(j)

!         call create_beta ( molecule, catalog(ib)%continuum, p_path(k),   &
!           & t_path(j), Frq, lineWidth(:no_of_lines), gl_slabs(k,ib), &
!           & tanh_path(j), bb, polarized .and. catalog(ib)%polarized,    &
!           & DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )

!         beta_path(j,i) = beta_path(j,i) + ratio * bb 

!         if ( associated(dbeta_dw_path)) &
!           &  dbeta_dw_path(j,i) = dbeta_dw_path(j,i) + ratio * v0
!         if ( associated(dbeta_dn_path)) &
!           &  dbeta_dn_path(j,i) = dbeta_dn_path(j,i) + ratio * vp
!         if ( associated(dbeta_dv_path)) &
!           &  dbeta_dv_path(j,i) = dbeta_dv_path(j,i) + ratio * vm
!       end do

        call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
          & p_path, t_path, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
          & gl_slabs(:,ib), tanh_path, beta_path(:,i),                      &
          & polarized .and. catalog(ib)%polarized,                          &
          & dBeta_dw=dBdw, dBeta_dn=dBdn, dBeta_dv=dBdv )
d153 15
a183 1
!         ratio = beta_group(i)%ratio(n)
d190 21
a210 23
!         do j = 1 , n_path
!           k = path_inds(j)
!           if ( t_der_path_flags(k)) then
!             call create_beta ( molecule, catalog(ib)%continuum, p_path(k), &
!             &  t_path_m(k), frq, lineWidth(:no_of_lines), gl_slabs_m(k,ib),                      &
!             &  tanh1_m(j), vm, polarized .and. catalog(ib)%polarized )
!             betam(j) = betam(j) + ratio * vm
!             call create_beta ( molecule, catalog(ib)%continuum, p_path(k), &
!             &  t_path_p(k), Frq, lineWidth(:no_of_lines), gl_slabs_p(k,ib),                      &
!             &  tanh1_p(j), vp, polarized .and. catalog(ib)%polarized )
!             betap(j) = betap(j) + ratio * vp
!           end if
!         end do ! j
          call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
            & p_path, tm, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
            & gl_slabs_m(:,ib), tanh1_m, betam,                               &
            & polarized .and. catalog(ib)%polarized, t_der_path_flags,        &
            & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
          call create_beta_path ( molecule, catalog(ib)%continuum, path_inds, &
            & p_path, tp, frq, lineWidth(:no_of_lines), beta_group(i)%ratio(n), &
            & gl_slabs_p(:,ib), tanh1_p, betap,                               &
            & polarized .and. catalog(ib)%polarized, t_der_path_flags,        &
            & dBeta_dw=null(), dBeta_dn=null(), dBeta_dv=null() )
d392 8
d538 26
a563 1
    else                ! No derivatives required
a566 3
          if ( present(polarized) ) then
            if ( polarized(ln_i) ) cycle
          end if
a573 3
          if ( present(polarized) ) then
            if ( polarized(ln_i) ) cycle
          end if
d923 4
@


2.41
log
@Make Create_Beta and Create_Beta_Path public
@
text
@d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.40 2003/07/07 16:47:01 pwagner Exp $"
a394 70
!     =====     Private Procedures     =================================

  ! ----------------------------------------------  Abs_CS_Cont  -----

  ! Compute the general continuum contribution
  pure function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_Cont_r)
  ! real(rp) function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency )
    use MLSCommon, only: RP

    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
    real(rp) :: Abs_CS_Cont_r

    Abs_CS_Cont_r = cont(1) * pressure * pressure * frequency * frequency * &
      & ( (300.0_rp / temperature)**cont(2) )

  end function Abs_CS_Cont

  ! -------------------------------------------  Abs_CS_N2_Cont  -----

  ! Compute the N2 continuum contribution
  pure function Abs_CS_N2_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_N2_Cont_r)
  ! real(rp) Function Abs_CS_N2_cont ( Cont, Temperature, Pressure, Frequency )
    use MLSCommon, only: RP

    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
    real(rp) :: Abs_CS_N2_Cont_r

    real(rp) :: THETA, FSQR, FSXT

    theta = 300.0_rp / temperature
    fsqr = frequency * frequency
    fsxt = fsqr * theta
    Abs_CS_N2_Cont_r = pressure * pressure * fsqr * (theta**cont(2)) * &
                   & ( cont(1) * exp(-cont(3) * fsxt * theta) + &
                   &   cont(4) * exp(-cont(5) * fsxt * theta) * &
                   & (cont(6)**2 + fsqr))

  end function Abs_CS_N2_Cont

  ! -------------------------------------------  Abs_CS_O2_Cont  -----

  ! Compute the O2 continuum contribution
  pure function Abs_CS_O2_Cont ( Cont, Temperature, Pressure, Frequency ) &
    & result(Abs_CS_O2_Cont_r)
  ! real(rp) Function ABS_CS_O2_CONT ( Cont, Temperature, Pressure, Frequency )
    use MLSCommon, only: RP

    real(rp), intent(in) :: CONT(:)     ! continuum parameters
    real(rp), intent(in) :: TEMPERATURE ! in Kelvin
    real(rp), intent(in) :: PRESSURE    ! in mbar
    real(rp), intent(in) :: FREQUENCY   ! in MegaHertz
    real(rp) :: Abs_CS_O2_Cont_r

    real(rp) :: THETA, FSQR

    theta = 300.0_rp / temperature
    fsqr = frequency * frequency
    Abs_CS_O2_Cont_r = cont(1) * pressure * pressure * fsqr * (theta**cont(2)) &
                   & / (fsqr + (cont(3) * pressure * (theta**cont(4)) )**2 )

  end function Abs_CS_O2_Cont

d831 70
d909 3
@


2.40
log
@Moved declaration of 3 function results inside body to appease NAG
@
text
@d8 1
d18 1
a18 1
    &  "$Id: get_beta_path_m.f90,v 2.39 2003/07/04 02:47:50 vsnyder Exp $"
d909 3
@


2.39
log
@Move Create_Beta here, add Create_Beta_Path routine
@
text
@d17 1
a17 1
    &  "$Id: get_beta_path_m.f90,v 2.38 2003/06/27 22:09:19 vsnyder Exp $"
d399 2
a400 1
  pure real(rp) function Abs_CS_Cont ( Cont, Temperature, Pressure, Frequency )
d408 1
d410 1
a410 1
    abs_cs_cont = cont(1) * pressure * pressure * frequency * frequency * &
d418 2
a419 1
  pure real(rp) function Abs_CS_N2_Cont ( Cont, Temperature, Pressure, Frequency )
d427 1
d434 1
a434 1
    abs_cs_n2_cont = pressure * pressure * fsqr * (theta**cont(2)) * &
d444 2
a445 1
  pure real(rp) function Abs_CS_O2_Cont ( Cont, Temperature, Pressure, Frequency )
d453 1
d459 1
a459 1
    abs_cs_o2_cont = cont(1) * pressure * pressure * fsqr * (theta**cont(2)) &
d908 3
@


2.38
log
@Move allocation of LineWidths out of loops; simplify exponent calculation
@
text
@d17 1
a17 1
    &  "$Id: get_beta_path_m.f90,v 2.37 2003/06/18 17:23:40 bill Exp $"
d32 1
a32 1
    use CREATE_BETA_M, only: CREATE_BETA
d63 1
a63 1
    LOGICAL, pointer :: t_der_path_flags(:)
d97 1
d100 4
a103 1
    real(rp) :: Ratio, BB, VP, V0, VM, T, TM, TP, BP, BM
d106 1
a106 1
    real(rp), dimension(size(path_inds)) :: tanh1_p, tanh1_m
d113 2
a114 1
    beta_path = 0.0
d116 3
a118 3
    if ( associated(dbeta_dw_path) ) dbeta_dw_path(1:n_path,:) = 0.0
    if ( associated(dbeta_dn_path) ) dbeta_dn_path(1:n_path,:) = 0.0
    if ( associated(dbeta_dv_path) ) dbeta_dv_path(1:n_path,:) = 0.0
d120 1
a120 2
    ! Determine size of the LineWidths array.  gl_slabs(:,ib) all have the
    ! same value, which is size(catalog(ib)%lines).
d131 13
d145 1
a145 1
        ratio = beta_group(i)%ratio(n)
d147 1
a147 1
        molecule = Catalog(ib)%molecule
d153 23
a175 2
        do j = 1, n_path
          k = path_inds(j)
a176 14
          call create_beta ( molecule, catalog(ib)%continuum, p_path(k),   &
            & t_path(j), Frq, lineWidth(:no_of_lines), gl_slabs(k,ib), &
            & tanh_path(j), bb, polarized .and. catalog(ib)%polarized,    &
            & DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )

          beta_path(j,i) = beta_path(j,i) + ratio * bb 

          if ( associated(dbeta_dw_path)) &
            &  dbeta_dw_path(j,i) = dbeta_dw_path(j,i) + ratio * v0
          if ( associated(dbeta_dn_path)) &
            &  dbeta_dn_path(j,i) = dbeta_dn_path(j,i) + ratio * vp
          if ( associated(dbeta_dv_path)) &
            &  dbeta_dv_path(j,i) = dbeta_dv_path(j,i) + ratio * vm
        end do
d183 2
d186 2
a187 2
      tanh1_p = tanh(0.5_rp * h_over_k * frq / t_path_p(path_inds))
      tanh1_m = tanh(0.5_rp * h_over_k * frq / t_path_m(path_inds))
d193 1
a193 1
          ratio = beta_group(i)%ratio(n)
d200 23
a222 13
          do j = 1 , n_path
            k = path_inds(j)
            if ( t_der_path_flags(k)) then
              call create_beta ( molecule, catalog(ib)%continuum, p_path(k), &
              &  t_path_m(k), frq, lineWidth(:no_of_lines), gl_slabs_m(k,ib),                      &
              &  tanh1_m(j), vm, polarized .and. catalog(ib)%polarized )
              betam(j) = betam(j) + ratio * vm
              call create_beta ( molecule, catalog(ib)%continuum, p_path(k), &
              &  t_path_p(k), Frq, lineWidth(:no_of_lines), gl_slabs_p(k,ib),                      &
              &  tanh1_p(j), vp, polarized .and. catalog(ib)%polarized )
              betap(j) = betap(j) + ratio * vp
            end if
          end do ! j
a226 2
          tm = t_path_m(k)
          tp = t_path_p(k)
d234 15
a248 17
          if ( n == 7 ) then ! bp > 0.0 .and. bb > 0.0 .and. bm > 0.0
            dbeta_dt_path(j,i) =  0.25 * ( &   ! Weighted average of
              &       Log(bp/bb)/Log(tp/t) + & ! Estimate over [temp+10,temp]
              & 2.0 * Log(bp/bm)/Log(tp/tm)+ & ! Estimate over [temp+10,temp-10]
              &       Log(bb/bm)/Log(t/tm) )   ! Estimate over [temp,temp-10]
          else
            select case ( n )
            case ( 6 ) ! bp > 0.0 .and. bb > 0.0
              dbeta_dt_path(j,i) = Log(bp/bb)/Log(tp/t)  ! Estimate over [temp+10,temp]
            case ( 3 ) ! bm > 0.0 .and. bb > 0.0
              dbeta_dt_path(j,i) = Log(bb/bm)/Log(t/tm)  ! Estimate over [temp,temp-10]
            case ( 5 ) ! bm > 0.0 .and. bp > 0.0
              dbeta_dt_path(j,i) = Log(bp/bm)/Log(tp/tm) ! Estimate over [temp+10,temp-10]
            case default
              dbeta_dt_path(j,i) = 0.0
            end select
          end if
d394 500
d902 3
@


2.37
log
@fixed NAG associated bug
@
text
@d17 1
a17 1
    &  "$Id: get_beta_path_m.f90,v 2.36 2003/06/18 14:44:53 bill Exp $"
a109 1
    ! compute path hyperbolic tangent
d115 11
d131 4
d140 1
a140 1
            & t_path(j), Frq, lines(catalog(ib)%lines)%w, gl_slabs(k,ib), &
d159 1
d170 1
a170 2
          no_of_lines = gl_slabs_m(1,ib)%no_lines
          allocate ( LineWidth(no_of_lines) )
d172 2
a173 2
            LineWidth(k) = Lines(Catalog(ib)%Lines(k))%W
          end do
d176 1
a176 2
            IF ( .not. t_der_path_flags(k)) CYCLE 
              tm = t_path_m(k)
d178 1
a178 1
              &  tm, frq, linewidth, gl_slabs_m(k,ib),                      &
d181 2
a182 3
              tp = t_path_p(k)
              call create_beta ( molecule, Catalog(ib)%continuum, p_path(k), &
              &  tp, Frq, LineWidth, gl_slabs_p(k,ib),                      &
d185 3
a187 3
          end do
          deallocate ( LineWidth )
        end do
d196 9
a204 16
          if ( bp > 0.0 .and. bb > 0.0 .and. bm > 0.0 ) then
            vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
            v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
            vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
          else if ( bp > 0.0 .and. bb > 0.0 ) then
            vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
            vm = vp
            v0 = vp
          else if ( bm > 0.0 .and. bb > 0.0 ) then
            vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
            vp = vm
            v0 = vm
          else if ( bm > 0.0 .and. bp > 0.0 ) then
            v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
            vp = v0
            vm = v0
d206 10
a215 3
            vp = 0.0
            v0 = 0.0
            vm = 0.0
d217 2
a218 3
          dbeta_dt_path(j,i) = (vp + 2.0 * v0 + vm) / 4.0  ! Weighted Average
        end do
      end do
d221 2
d370 3
@


2.36
log
@added subsetting feature for T-ders
@
text
@d17 1
a17 1
    &  "$Id: get_beta_path_m.f90,v 2.35 2003/06/02 22:41:33 vsnyder Exp $"
d63 2
a64 1
    LOGICAL, intent(in) :: t_der_path_flags(:) ! indicies where temperature
d357 3
@


2.35
log
@Remove unused symbols
@
text
@d17 1
a17 1
    &  "$Id: get_beta_path_m.f90,v 2.34 2003/05/16 23:51:51 livesey Exp $"
d29 1
d63 2
d161 11
a171 10
            tm = t_path_m(k)
            call create_beta ( molecule, catalog(ib)%continuum, p_path(k), &
            &  tm, frq, linewidth, gl_slabs_m(k,ib),                      &
            &  tanh1_m(j), vm, polarized .and. catalog(ib)%polarized )
            betam(j) = betam(j) + ratio * vm
            tp = t_path_p(k)
            call create_beta ( molecule, Catalog(ib)%continuum, p_path(k), &
            &  tp, Frq, LineWidth, gl_slabs_p(k,ib),                      &
            &  tanh1_p(j), vp, polarized .and. catalog(ib)%polarized )
            betap(j) = betap(j) + ratio * vp
d356 3
@


2.34
log
@Now uses molecules rather than spectags
@
text
@a5 2
  use MLSCommon, only: RP, R8

d17 1
a17 1
    &  "$Id$"
d20 1
a20 1
    &  "$RCSfile$"
d351 4
a354 1
! $Log$
@


2.33
log
@Moved some stuff up to FullForwardModel because Get_d_Deltau_pol_dT needs it
@
text
@d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.32 2003/05/10 00:48:09 vsnyder Exp $"
d22 1
a22 1
    &  "$RCSfile: get_beta_path_m.f90,v $"
a36 1
    use Molecules, only: SP_H2O
d95 1
a95 1
    integer(ip) :: I, J, K, N, IB, Spectag, No_of_lines, &
d118 1
a118 1
        Spectag = Catalog(ib)%Spec_Tag
d123 1
a123 1
          call create_beta ( spectag, catalog(ib)%continuum, p_path(k),   &
d152 1
a152 1
          Spectag = Catalog(ib)%Spec_Tag
d161 1
a161 1
            call create_beta ( spectag, catalog(ib)%continuum, p_path(k), &
d166 1
a166 1
            call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), &
d353 4
a356 1
! $Log: get_beta_path_m.f90,v $
@


2.32
log
@Add TeXnicalities
@
text
@d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.31 2003/05/09 20:07:07 vsnyder Exp $"
d28 1
a28 1
  subroutine Get_Beta_Path_Scalar ( frq, p_path, t_path, &
d43 4
a46 3
    real(r8), intent(in) :: Frq         ! frequency in MHz
    real(rp), intent(in) :: T_path(:)   ! path temperatures
    real(rp), intent(in) :: P_path(:)   ! path pressures in hPa!
d101 1
a101 1
    real(rp), dimension(size(path_inds)) :: tanh1, tanh1_p, tanh1_m
d109 1
a109 3
! Note that expa only depends on temperature.
! compute path hyperbolic tangent
    tanh1 = tanh(0.5_rp * h_over_k * frq / t_path(path_inds))
d125 2
a126 2
            & t_path(k), Frq, lines(catalog(ib)%lines)%w, gl_slabs(k,ib), &
            & tanh1(j), bb, polarized .and. catalog(ib)%polarized,        &
d176 1
a176 1
          t  = t_path(k)
d355 3
@


2.31
log
@Correct kind parameter for H, specify intent for GL_slabs and Beta_group
@
text
@d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.30 2003/05/09 19:24:38 vsnyder Exp $"
d73 15
d233 6
a238 1
    complex(rp), intent(out) :: beta_path(-1:,:,:) ! path beta for each species
d356 3
@


2.30
log
@Cosmetic change
@
text
@d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.29 2003/05/05 23:00:25 livesey Exp $"
d209 1
a209 1
    real(r8), intent(in) :: H(:)      ! Magnetic field component in instrument
d212 1
a212 1
    type (slabs_struct), dimension(:,:) :: Gl_slabs
d214 1
a214 1
    type (beta_group_T), dimension(:) :: beta_group
d336 3
@


2.29
log
@Merged in feb03 newfwm branch
@
text
@d19 1
a19 1
    &  "$Id$"
d22 1
a22 1
    &  "$RCSfile$"
d158 1
a158 1
          DeAllocate ( LineWidth )
d335 4
a338 1
! $Log$
@


2.28
log
@fix a bug with RHI and define RHI as real (rp)
@
text
@d10 2
a11 1
  public :: Get_Beta_Path, Get_Beta_Path_Scalar, Get_Beta_Path_Polarized, Get_Beta_Path_Cloud
a16 7
! *** Beta group type declaration:
  type, public :: beta_group_T
    integer :: n_elements
    integer, pointer  :: cat_index(:)
    real(rp), pointer :: ratio(:)
  end type beta_group_T

d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.27 2003/04/22 00:16:16 dwu Exp $"
d22 1
a22 1
    &  "$RCSfile: get_beta_path_m.f90,v $"
d27 5
a31 6
  ! ---------------------------------------  Get_Beta_Path_Scalar  -----
  subroutine Get_Beta_Path_Scalar ( frq, p_path, t_path, z_path_c, &
        & Catalog, beta_group, gl_slabs, path_inds, beta_path,     &
        & gl_slabs_m, t_path_m, gl_slabs_p, t_path_p,              &
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path, &
        & Incl_Cld )
d33 3
d37 2
a38 1
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
a39 2
    use CREATE_BETA_M, only: CREATE_BETA
    use Molecules, only: SP_H2O
a45 1
    real(rp), intent(in) :: z_path_c(:) ! =-log(p_path)
d52 1
a52 1
    logical, intent(in) :: Incl_Cld
d67 1
a67 1
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each species
d80 3
a82 3
    integer(ip) :: i, j, k, n, ib, Spectag, no_of_lines, &
              &    no_mol, n_path
    real(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm, cld_ext, RHI
d85 1
a85 2

    real(rp) :: P, Vapor_P
d93 4
d110 4
a113 3
          call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), t_path(k), &
            &  Frq, Lines(Catalog(ib)%Lines)%W, gl_slabs(k,ib), bb, DBETA_DW=v0,   &
            &  DBETA_DN=vp, DBETA_DV=vm )
d115 1
a115 1
             beta_path(j,i) = beta_path(j,i) + ratio * bb 
d130 2
d148 3
a150 2
            call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), tm, Frq, &
            &    LineWidth, gl_slabs_m(k,ib), vm )
d153 3
a155 2
            call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), tp, Frq, &
            &    LineWidth, gl_slabs_p(k,ib), vp )
d198 1
a198 1
        & Catalog, beta_group, gl_slabs, path_inds, beta_path )
d200 1
a213 1

d238 1
a238 1
         
d242 2
a243 2
          call o2_abs_cs ( frq, (/ ( -1, m=1,size(gl_slabs(k,ib)%v0s) ) /), &
            & h(k), gl_slabs(k,ib), &
d254 8
a261 5
!------------------------------------------------------------------
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path, z_path_c, &
        & Catalog, beta_group, gl_slabs, path_inds, beta_path_cloud,    &
        & RHi, Incl_Cld, IPSD, WC, NU, NUA, NAB, NR, NC )

a263 3
    use CREATE_BETA_M, only: CREATE_BETA
    use SpectroscopyCatalog_m, only: CATALOG_T,LINES
    use cloud_extinction, only: get_beta_cloud
d270 1
a270 3
    real(rp), intent(in) :: z_path_c(:) ! =-log(p_path)
    type(catalog_t), intent(in) :: Catalog(:)
    type (slabs_struct), dimension(:,:) :: Gl_slabs
d274 1
a275 3
    real(rp), intent(in)  :: RHi
    logical, intent(in) :: Incl_Cld
    INTEGER :: NC, NU, NUA, NAB, NR
d278 2
a279 6
    REAL(rp) :: W0(NC)       ! SINGLE SCATTERING ALBEDO
    REAL(rp) :: PHH(NC,NU)   ! PHASE FUNCTION

    type(slabs_struct), pointer :: gl_slabs_m(:,:) ! reduced

    type(slabs_struct), pointer :: gl_slabs_p(:,:) ! reduced
d283 3
a285 1
    real(rp), intent(out) :: beta_path_cloud(:) ! path beta for each species
d293 4
a296 3
    integer(ip) :: i, j, k, n, ib, Spectag, no_of_lines, &
              &    no_mol, n_path
    real(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm, cld_ext
d300 7
d310 2
d316 2
a317 2
          call get_beta_cloud (Frq, t_path(k), p_path(k),         &
                          &  WC(:,k), IPSD(k), N, NU, NUA, NAB, NR,       &
d321 3
a323 1

d328 1
a328 1
!----------------------------------------------------------------------
d335 12
a346 3
! $Log: get_beta_path_m.f90,v $
! Revision 2.27  2003/04/22 00:16:16  dwu
! change icon to RHi
d348 8
a355 1
! Revision 2.26  2003/02/13 23:06:01  jonathan
d357 3
@


2.27
log
@change icon to RHi
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.26 2003/02/13 23:06:01 jonathan Exp $"
d275 1
a275 1
    real(r8), intent(in)  :: RHi
d299 1
a299 1
    real(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm, cld_ext, RHI
d328 3
@


2.26
log
@changes dimension for beta_path_cloud
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25 2003/02/11 00:48:18 jonathan Exp $"
d255 1
a255 1
        & ICON, Incl_Cld, IPSD, WC, NU, NUA, NAB, NR, NC )
d275 1
a275 1
    integer, intent(in)  :: ICON
d328 3
@


2.25
log
@changes made after adding get_beta_path_cloud
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.24 2003/02/07 01:57:19 vsnyder Exp $"
d254 1
a254 1
        & Catalog, beta_group, gl_slabs, path_inds, beta_path,    &
d289 1
a289 1
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each species
a302 1
    no_mol = size(beta_group)
d305 1
a305 1
    beta_path = 0.0
a306 2
    do i = 1, no_mol
      do n = 1, beta_group(i)%n_elements         
d314 1
a314 1
            beta_path(j,i) = beta_path(j,i) + cld_ext 
a316 2
      end do
    end do
d328 3
@


2.25.2.1
log
@uses new slabs_sw
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25 2003/02/11 00:48:18 jonathan Exp $"
d33 1
a33 1
! ---------------------------------------  Get_Beta_Path_Scalar  -----
d37 2
a38 1
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path)
d58 2
d88 1
a88 2
    REAL(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm, cld_ext, expm1
    REAL(rp) :: RHI
d90 1
a90 2
    REAL(rp), DIMENSION(SIZE(path_inds)) :: betam, betap
    REAL(rp), DIMENSION(SIZE(path_inds)) :: tanh1, tanh1_p, tanh1_m
a91 1
    real(rp), parameter :: Boltzmhz = 20836.74_rp
a99 6
! Note that expa only depends on temperature.
! compute path hyperbolic tangent
    DO i = 1 , n_path
      expm1 = EXP(-frq / (boltzmhz * t_path(path_inds(i))))
      tanh1(i) = (1.0_rp - expm1) / (1.0_rp + expm1)
    ENDDO
d113 4
a116 3
          call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), &
            & t_path(k), Frq, Lines(Catalog(ib)%Lines)%W, gl_slabs(k,ib), &
            & tanh1(j), bb, DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )
a131 6
      DO i = 1 , n_path
        expm1 = EXP(-frq / (boltzmhz * t_path_p(path_inds(i))))
        tanh1_p(i) = (1.0_rp - expm1) / (1.0_rp + expm1)
        expm1 = EXP(-frq / (boltzmhz * t_path_m(path_inds(i))))
        tanh1_m(i) = (1.0_rp - expm1) / (1.0_rp + expm1)
      ENDDO
d148 2
a149 3
            call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), &
            &  tm, Frq, LineWidth, gl_slabs_m(k,ib), tanh1_m(j), &
            &  vm)
d152 2
a153 2
            call create_beta ( Spectag, Catalog(ib)%continuum, p_path(k), &
            & tp, Frq, LineWidth, gl_slabs_p(k,ib), tanh1_p(j), vp)
a332 3
! Revision 2.25  2003/02/11 00:48:18  jonathan
! changes made after adding get_beta_path_cloud
!
@


2.25.2.2
log
@changes dimension for beta_path_cloud
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.1 2003/02/13 17:34:27 bill Exp $"
d266 1
a266 1
        & Catalog, beta_group, gl_slabs, path_inds, beta_path_cloud,    &
d301 1
a301 1
    real(rp), intent(out) :: beta_path_cloud(:) ! path beta for each species
d315 1
d318 1
a318 1
    beta_path_cloud = 0.0
d320 2
d329 2
a330 1
            beta_path_cloud(j) = beta_path_cloud(j) + cld_ext 
d332 2
a344 3
! Revision 2.25.2.1  2003/02/13 17:34:27  bill
! uses new slabs_sw
!
@


2.25.2.3
log
@add singl. scat. albedo W0, ph funct PHH
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.2 2003/02/13 22:26:30 jonathan Exp $"
d265 2
a266 3
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path, z_path_c,       &
        & beta_group, path_inds, beta_path_cloud,    &
        & beta_path_w0,  beta_path_phh,                                 & 
d271 2
d281 2
a282 1
    
d292 6
a297 2
    REAL(rp) :: W0       ! SINGLE SCATTERING ALBEDO
    REAL(rp) :: PHH(NU)   ! PHASE FUNCTION
d301 1
a301 3
    real(rp), intent(out) :: beta_path_cloud(:) ! cloud extinction
    real(rp), intent(out) :: beta_path_w0(:)    ! single scattering albedo
    real(rp), intent(out) :: beta_path_phh(:,:)   ! phase function
d309 3
a311 2
    integer(ip) :: i, j, k, n_path
    real(rp) :: cld_ext, RHI
a317 2
    beta_path_w0    = 0.0
    beta_path_phh   = 0.0
d322 2
a323 2
          call get_beta_cloud (Frq, t_path(k), p_path(k),           &
                          &  WC(:,k), IPSD(k), NC, NU, NUA, NAB, NR, &
a326 3
            beta_path_w0(j) = beta_path_w0(j) + W0 
            beta_path_phh(j,:) = beta_path_phh(j,:) + PHH(:) 
            
a338 3
! Revision 2.25.2.2  2003/02/13 22:26:30  jonathan
! changes dimension for beta_path_cloud
!
@


2.25.2.4
log
@change input for get_beta_path_cloud
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.3 2003/02/14 00:21:42 jonathan Exp $"
d265 1
a265 1
  subroutine Get_Beta_Path_Cloud ( Frq, t_path,      &
d267 1
a267 1
        & beta_path_w0,  beta_path_phh,              & 
d278 2
d319 1
a319 1
          call get_beta_cloud (Frq, t_path(k),                       &
a338 3
! Revision 2.25.2.3  2003/02/14 00:21:42  jonathan
! add singl. scat. albedo W0, ph funct PHH
!
@


2.25.2.5
log
@Add polarized stuff.  Remove unused z_path_c argument of get_beta_path.
Remove unused p_path argument to get_beta_cloud.  Cosmetics.
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.4 2003/02/24 23:40:38 jonathan Exp $"
d34 3
a36 3
  subroutine Get_Beta_Path_Scalar ( frq, p_path, t_path, &
        & Catalog, beta_group, polarized, gl_slabs, path_inds,     &
        & beta_path, gl_slabs_m, t_path_m, gl_slabs_p, t_path_p,   &
d39 3
a42 2
    use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
    use MLSCommon, only: R8, RP, IP
a43 2
    use Physics, only: H_OVER_K
    use SpectroscopyCatalog_m, only: CATALOG_T, LINES
d50 1
a56 2
    logical, intent(in) :: Polarized    ! "Don't work on Zeeman-split lines"

d70 1
a70 1
    real(rp), intent(out) :: beta_path(:,:) ! path beta for each specie
d83 4
a86 3
    integer(ip) :: I, J, K, N, IB, Spectag, No_of_lines, &
              &    No_mol, N_path
    real(rp) :: Ratio, BB, VP, V0, VM, T, TM, TP, BP, BM
d88 5
a92 2
    real(rp), dimension(size(path_inds)) :: betam, betap
    real(rp), dimension(size(path_inds)) :: tanh1, tanh1_p, tanh1_m
d102 4
a105 2
    tanh1 = tanh(0.5_rp * h_over_k * frq / t_path(path_inds))

d119 4
a122 6
          call create_beta ( spectag, catalog(ib)%continuum, p_path(k),   &
            & t_path(k), Frq, lines(catalog(ib)%lines)%w, gl_slabs(k,ib), &
            & tanh1(j), bb, polarized .and. catalog(ib)%polarized,        &
            & DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )

          beta_path(j,i) = beta_path(j,i) + ratio * bb 
d137 6
a142 2
      tanh1_p = tanh(0.5_rp * h_over_k * frq / t_path_p(path_inds))
      tanh1_m = tanh(0.5_rp * h_over_k * frq / t_path_m(path_inds))
d159 3
a161 3
            call create_beta ( spectag, catalog(ib)%continuum, p_path(k), &
            &  tm, frq, linewidth, gl_slabs_m(k,ib),                      &
            &  tanh1_m(j), vm, polarized .and. catalog(ib)%polarized )
d165 1
a165 2
            &  tp, Frq, LineWidth, gl_slabs_p(k,ib),                      &
            &  tanh1_p(j), vp, polarized .and. catalog(ib)%polarized )
d208 1
a208 1
        & Catalog, Beta_group, GL_slabs, Path_inds, Beta_path )
d223 1
d253 1
a253 1
            & h(k), gl_slabs(k,ib), catalog(ib)%polarized,        &
d264 4
a267 4
  ! ----------------------------------------  Get_Beta_Path_Cloud  -----
  subroutine Get_Beta_Path_Cloud ( Frq, p_path, t_path,                 &
        & beta_group, path_inds, beta_path_cloud,                       &
        & beta_path_w0,  beta_path_phh,                                 & 
a269 1
    use Cloud_extinction, only: get_beta_cloud
d272 1
a277 1
    real(rp), intent(in) :: P_path(:)   ! path pressures in hPa!
d317 1
a317 1
          call get_beta_cloud (Frq, t_path(k), p_path(k),           &
@


2.25.2.6
log
@Use 'polarized' to specify size of quantum numbers array
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.5 2003/02/27 23:19:23 vsnyder Exp $"
d242 1
a242 1

d246 1
a246 1
          call o2_abs_cs ( frq, (/ ( -1, m=1,size(catalog(ib)%polarized) ) /), &
a331 4
! Revision 2.25.2.5  2003/02/27 23:19:23  vsnyder
! Add polarized stuff.  Remove unused z_path_c argument of get_beta_path.
! Remove unused p_path argument to get_beta_cloud.  Cosmetics.
!
@


2.25.2.7
log
@Add Dump_Beta_Group and generic Dump for it
@
text
@d10 1
a10 3
  public :: Get_Beta_Path, Get_Beta_Path_Scalar, Get_Beta_Path_Polarized
  public :: Get_Beta_Path_Cloud
  public :: Dump
a15 4
  interface Dump
    module procedure Dump_Beta_Group
  end interface

d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.6 2003/03/01 03:16:15 vsnyder Exp $"
d324 1
a324 24
  ! --------------------------------------------  Dump_Beta_Group  -----
  subroutine Dump_Beta_Group ( Beta_Group, Name )

    use Dump_0, only: Dump
    use Output_m, only: Output

    type(beta_group_t), intent(in) :: Beta_Group(:)
    character(len=*), intent(in), optional :: Name

    integer :: I

    call output ( 'Beta group' )
    if ( present(name) ) call output ( ' ' // trim(name) )
    call output ( ', SIZE = ' )
    call output ( size(beta_group), advance='yes' )
    do i = 1, size(beta_group)
      call output ( 'Item ' )
      call output ( i, advance='yes' )
      call dump ( beta_group(i)%cat_index, name='Cat_Index' )
      call dump ( beta_group(i)%ratio, name='Ratio' )
    end do
  end subroutine Dump_Beta_Group

!-----------------------------------------------------------------------
a331 3
! Revision 2.25.2.6  2003/03/01 03:16:15  vsnyder
! Use 'polarized' to specify size of quantum numbers array
!
@


2.25.2.8
log
@Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
@
text
@d12 1
d18 11
d31 1
a31 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.7 2003/03/12 21:35:44 vsnyder Exp $"
a45 1
    use Get_Species_Data_m, only: Beta_Group_T
a210 1
    use Get_Species_Data_m, only: Beta_Group_T
a270 1
    use Get_Species_Data_m, only: Beta_Group_T
d330 23
a360 3
! Revision 2.25.2.7  2003/03/12 21:35:44  vsnyder
! Add Dump_Beta_Group and generic Dump for it
!
@


2.25.2.9
log
@remove unused 'pressure' in call to cloud_extinction
@
text
@d19 1
a19 1
    &  "$Id: get_beta_path_m.f90,v 2.25.2.8 2003/03/22 04:03:04 vsnyder Exp $"
d309 1
a309 1
          call get_beta_cloud (Frq, t_path(k),                       &
a328 3
! Revision 2.25.2.8  2003/03/22 04:03:04  vsnyder
! Move Beta_Group_T and Dump_Beta_Group from get_beta_path to Get_Species_Data
!
@


2.24
log
@Delete USE RHIFromH2O because it's not used
@
text
@d10 1
a10 1
  public :: Get_Beta_Path, Get_Beta_Path_Scalar, Get_Beta_Path_Polarized
d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.23 2003/02/07 01:08:34 jonathan Exp $"
d38 1
a38 1
        & ICON, Incl_Cld, IPSD, WC, NU, NUA, NAB, NR, NC )
a57 1
    integer, intent(in)  :: ICON
a59 7
!    include 'constants.f9h'
    INTEGER :: NC, NU, NUA, NAB, NR
    INTEGER, intent(in) :: IPSD(:)
    REAL(rp), intent(in) :: WC(:,:)
    REAL(rp) :: W0(NC)       ! SINGLE SCATTERING ALBEDO
    REAL(rp) :: PHH(NC,NU)   ! PHASE FUNCTION

d114 3
a116 4
            &  Frq, Lines(Catalog(ib)%Lines)%W, gl_slabs(k,ib), bb,                &
            &  Incl_Cld, cld_ext, IPSD(K), WC(:,K), NU, NUA, NAB, NR, NC,          &
            &  DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )
          if ( .not. Incl_Cld ) then
d118 1
a118 3
          else
             beta_path(j,i) = beta_path(j,i) + ratio * bb + cld_ext 
          end if
d149 1
a149 2
            &    LineWidth, gl_slabs_m(k,ib), vm,                                  &
            &    Incl_Cld, cld_ext, IPSD(k), WC(:,k), NU, NUA, NAB, NR, NC )
d153 1
a153 2
            &    LineWidth, gl_slabs_p(k,ib), vp,                                  &
            &    Incl_Cld, cld_ext, IPSD(k), WC(:,k), NU, NUA, NAB, NR, NC )
d252 73
d333 3
@


2.23
log
@remove ICON option for compute super saturation
@
text
@d7 1
a7 1
  use RHIFromH2O, only: RHIFromH2O_Factor
d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.22 2003/02/06 22:12:49 jonathan Exp $"
d273 3
@


2.22
log
@fix bug
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.21 2003/02/06 00:20:16 jonathan Exp $"
a58 6

!-----------------------------------------------------------------------------
! ICON indicates different clear and cloudy sky combinations:
!		ICON=-1 is for clear-sky radiance limit assuming 110%RHi
!		ICON=-2 is for clear-sky radiance limit assuming 0%RHi
!-----------------------------------------------------------------------------
a120 12
          ! do the following only if ICON not equal to 0
!          if ( Spectag == SP_H2O .and. p_path(k) >= 100. .and. ICON .ne. 0) then
!            select case ( ICON )
!            case ( -1 )
!              RHI=110.0_r8
!            case ( -2 )
!              RHI=1.0e-9_r8
!            end select  
!            ratio = RHIFromH2O_Factor (t_path(k), z_path_c(k), 0, .true.)*RHI
            ! optional 0 will return ratio as parts per 1, as Bill uses here.
!          end if                                 

d273 3
@


2.21
log
@Add in many stuff to deal with clouds CloudIce, iwc_path, etc
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.20 2003/02/04 22:03:33 jonathan Exp $"
d128 8
a135 8
          if ( Spectag == SP_H2O .and. p_path(k) >= 100. .and. ICON .ne. 0) then
            select case ( ICON )
            case ( -1 )
              RHI=110.0_r8
            case ( -2 )
              RHI=1.0e-9_r8
            end select  
            ratio = RHIFromH2O_Factor (t_path(k), z_path_c(k), 0, .true.)*RHI
d137 1
a137 1
          end if                                 
d291 3
@


2.20
log
@ICON now equal to 0 as default
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.19 2003/02/04 21:46:27 jonathan Exp $"
d38 1
a38 1
        & ICON, Incl_Cld )
d67 7
d140 2
a141 1
            &  Frq, Lines(Catalog(ib)%Lines)%W, gl_slabs(k,ib), bb,  Incl_Cld, cld_ext, &
d178 2
a179 1
            &    LineWidth, gl_slabs_m(k,ib), vm, Incl_Cld, cld_ext )
d183 2
a184 1
            &    LineWidth, gl_slabs_p(k,ib), vp, Incl_Cld, cld_ext )
d291 3
@


2.19
log
@add ICON options for super saturation and dry cases
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.18 2003/02/03 22:56:58 vsnyder Exp $"
d58 2
a59 2
!    integer, intent(in)  :: ICON
    integer :: ICON                 ! this will be changed with intent(in) option
a102 2
    ICON=0  ! this will be removed later

d281 3
@


2.18
log
@Add Get_bata_path_polarized
@
text
@d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.17 2003/01/31 18:45:09 jonathan Exp $"
d58 7
a64 1
    integer, intent(in)  :: ICON
d95 1
a95 1
    real(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm, cld_ext
d103 2
d122 9
a130 3
          ! mask 100%RH below 100mb
          if ( Spectag == SP_H2O .and. ICON == -1 .and. p_path(k) >= 100. ) then
            ratio = RHIFromH2O_Factor (t_path(k), z_path_c(k), 0, .true.)*100.0_r8
d140 1
a140 1
             beta_path(j,i) = beta_path(j,i) + ratio * bb + cld_ext   ! cld_ext = 0. for now 1/31
d283 3
@


2.17
log
@use cld_ext only if Incl_Cld is ture
@
text
@d10 5
a14 1
  public :: get_beta_path
d25 1
a25 1
    &  "$Id: get_beta_path_m.f90,v 2.16 2003/01/31 17:53:48 jonathan Exp $"
a31 2
! This is a generic form of get coarse beta path. We really don't need
! separate versions of these.
d33 6
a38 4
  ! ----------------------------------------------  Get_Beta_Path  -----
  subroutine Get_Beta_Path ( frq, p_path, t_path, z_path_c, Catalog, beta_group, gl_slabs, &
        & path_inds, beta_path, gl_slabs_m, t_path_m, gl_slabs_p, t_path_p, &
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path, ICON, Incl_Cld )
d58 2
a59 2
    integer  :: ICON
    Logical :: Incl_Cld
d67 1
a67 1
    real(rp) :: t_path_m(:) ! path temperatures for gl_slabs_m
d70 1
a70 1
    real(rp) :: t_path_p(:) ! path temperatures for gl_slabs_p
d115 2
a116 2
          IF(Spectag .EQ. SP_H2O .AND. ICON .EQ.-1 .and. p_path(k).GE. 100.)THEN
            ratio = RHIFromH2O_Factor (t_path(k), z_path_c(k), 0, .true.)*100._r8
d118 1
a118 1
          ENDIF                                 
d123 1
a123 1
          IF ( .not. Incl_Cld ) THEN
d125 1
a125 1
          ELSE
d127 1
a127 1
          ENDIF
d201 59
a259 1
  end subroutine Get_Beta_Path
d269 3
@


2.16
log
@change z_path to z_path_c in passing to get_beta_path
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.15 2003/01/31 17:16:08 jonathan Exp $"
d119 5
a123 1
          beta_path(j,i) = beta_path(j,i) + ratio * bb + cld_ext   ! cld_ext = 0. for now 1/31
d207 3
@


2.15
log
@add Inc_Cld, and cld_ext
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.14 2003/01/30 17:43:04 jonathan Exp $"
d32 1
a32 1
  subroutine Get_Beta_Path ( frq, p_path, t_path, z_path, Catalog, beta_group, gl_slabs, &
d44 4
a47 4
    real(r8), intent(in) :: Frq ! frequency in MHz
    real(rp), intent(in) :: T_path(:) ! path temperatures
    real(rp), intent(in) :: P_path(:) ! path pressures in hPa!
    real(rp), intent(in) :: Z_path(:) ! =-log(p_path)
d112 1
a112 1
            ratio = RHIFromH2O_Factor (t_path(k), z_path(k), 0, .true.)*100._r8
d203 3
@


2.14
log
@remove RHtoEV
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.13 2003/01/30 00:17:42 jonathan Exp $"
d34 1
a34 1
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path, ICON )
d54 3
d85 1
a85 1
    real(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm
a88 1
    integer  :: ICON
d117 1
a117 1
            &  Frq, Lines(Catalog(ib)%Lines)%W, gl_slabs(k,ib), bb,     &
d119 1
a119 1
          beta_path(j,i) = beta_path(j,i) + ratio * bb
d150 1
a150 1
            &    LineWidth, gl_slabs_m(k,ib), vm )
d154 1
a154 1
            &    LineWidth, gl_slabs_p(k,ib), vp )
d203 3
@


2.13
log
@add z_path to get_beta_path & use Paul's RHIFromH2O to compute VMR from RHi
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.12 2003/01/14 21:49:33 jonathan Exp $"
a109 5

!             CALL RHtoEV(t_path(k),100._r8,Vapor_P)
!             P = p_path(k)-Vapor_P
!             ratio = Vapor_P/(max(1.e-9_r8, P)) ! define new mixing ratio for 
!                                                ! water vapor saturated below 100mb
d111 1
a111 1

a192 20

          SUBROUTINE RHtoEV(t,RH,EV) 
!         p ---- mb
!         t,td ---- K
!         RH --- %
!         SD --- g/m3                 

          REAL(rp) :: es, t, RH, EV, isat, t0

  	  t0 = 273.16_r8
	  isat = -9.09718*(t0/t-1.0) + 0.78583503 - 3.56654*LOG10(t0/t) &
            &     		     + 0.876793 * (1.0-t/t0)

          es=10**isat

          if (ES.lt.0._r8) ES=0._r8
          EV=ES*0.01*RH
          
          END SUBROUTINE RHtoEV

d201 3
@


2.12
log
@option for saturation below 100mb
@
text
@d7 1
a7 1
  
d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.11 2003/01/08 00:17:29 vsnyder Exp $"
d32 1
a32 1
  subroutine Get_Beta_Path ( frq, p_path, t_path, Catalog, beta_group, gl_slabs, &
d47 1
d110 7
a116 4
             CALL RHtoEV(t_path(k),100._r8,Vapor_P)
             P = p_path(k)-Vapor_P
             ratio = Vapor_P/(max(1.e-9_r8, P)) ! define new mixing ratio for 
                                                ! water vapor saturated below 100mb
d226 3
@


2.11
log
@Use "associated" instead of "present" to control optional computations
@
text
@d6 2
a7 2
  use MLSCommon, only: RP

d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.10 2002/12/13 02:06:51 vsnyder Exp $"
d34 1
a34 1
        & dbeta_dt_path, dbeta_dw_path, dbeta_dn_path, dbeta_dv_path )
d40 1
d85 3
d103 1
d106 9
d194 20
d222 3
@


2.10
log
@Use a SLABS structure for the slabs quantities
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.9 2002/10/08 17:08:03 pwagner Exp $"
d52 3
a54 2
! Another clumsy feature of f90
! Optional inputs:
d56 1
a56 1
    type(slabs_struct), optional :: gl_slabs_m(:,:) ! reduced
d58 2
a59 3
    real(rp), optional, intent(in) :: t_path_m(:) ! path temperatures for
!                                                 gl_slabs_m
    type(slabs_struct), optional :: gl_slabs_p(:,:) ! reduced
d61 1
a61 1
    real(rp), optional, intent(in) :: t_path_p(:) ! path temperatures for
d67 8
a74 1
! Optional output:
d76 1
a76 6
    real(rp), optional, intent(out) :: dbeta_dt_path(:,:) ! t dep.
    real(rp), optional, intent(out) :: dbeta_dw_path(:,:) ! line width
    real(rp), optional, intent(out) :: dbeta_dn_path(:,:) ! line width t dep.
    real(rp), optional, intent(out) :: dbeta_dv_path(:,:) ! line position

! Local varibles..
d90 3
a92 3
    if ( present(dbeta_dw_path) ) dbeta_dw_path = 0.0
    if ( present(dbeta_dn_path) ) dbeta_dn_path = 0.0
    if ( present(dbeta_dv_path) ) dbeta_dv_path = 0.0
d105 1
a105 1
          if ( present(dbeta_dw_path)) &
d107 1
a107 1
          if ( present(dbeta_dn_path)) &
d109 1
a109 1
          if ( present(dbeta_dv_path)) &
d115 1
a115 1
    if ( present(dbeta_dt_path) ) then
d117 1
a117 1
      dbeta_dt_path = 0.0
d188 3
@


2.9
log
@Added idents to survive zealous Lahey optimizer
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.8 2002/09/12 23:00:04 vsnyder Exp $"
d47 1
a47 1
    type (slabs_struct), dimension(:,:), pointer :: Gl_slabs
d50 1
a50 1
    type (beta_group_T), dimension(:), pointer :: beta_group
d55 1
a55 1
    type(slabs_struct), optional, pointer :: gl_slabs_m(:,:) ! reduced
d59 1
a59 1
    type(slabs_struct), optional, pointer :: gl_slabs_p(:,:) ! reduced
a96 5
        no_of_lines = gl_slabs(1,ib)%no_lines
        allocate ( LineWidth(no_of_lines) )
        do k = 1, no_of_lines
          LineWidth(k) = Lines(Catalog(ib)%Lines(k))%W
        end do
d100 2
a101 3
            &  Frq, no_of_lines, LineWidth, gl_slabs(k,ib)%v0s, gl_slabs(k,ib)%x1, &
            &  gl_slabs(k,ib)%y, gl_slabs(k,ib)%yi, gl_slabs(k,ib)%slabs1, bb,     &
            &  gl_slabs(k,ib)%dslabs1_dv0, DBETA_DW=v0, DBETA_DN=vp, DBETA_DV=vm )
a109 1
        DeAllocate ( LineWidth )
d133 1
a133 3
            &    no_of_lines, LineWidth, gl_slabs_m(k,ib)%v0s, gl_slabs_m(k,ib)%x1,&
            &    gl_slabs_m(k,ib)%y, gl_slabs_m(k,ib)%yi, gl_slabs_m(k,ib)%slabs1, &
            &    vm, gl_slabs_m(k,ib)%dslabs1_dv0 )
d137 1
a137 3
            &    no_of_lines, LineWidth, gl_slabs_p(k,ib)%v0s, gl_slabs_p(k,ib)%x1,&
            &    gl_slabs_p(k,ib)%y, gl_slabs_p(k,ib)%yi, gl_slabs_p(k,ib)%slabs1, &
            &    vp, gl_slabs_p(k,ib)%dslabs1_dv0 )
d186 3
@


2.8
log
@Cosmetic changes, move USEs from module scope to procedure scope
@
text
@d21 1
a21 1
    &  "$Id: get_beta_path_m.f90,v 2.7 2001/12/23 23:30:42 zvi Exp $"
d25 1
d190 4
d197 3
@


2.7
log
@Fixing a bug in the dbeta_dt computations
@
text
@d1 8
a8 6
Module GET_BETA_PATH_M
  use MLSCommon, only: R8, RP, IP
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
  use SpectroscopyCatalog_m, only: CATALOG_T, LINES
  use CREATE_BETA_M, only: CREATE_BETA
  Implicit NONE
d10 1
a10 1
  PUBLIC :: get_beta_path
d20 5
a24 4
  CHARACTER (LEN=256) :: Id = &
       "$Id: get_beta_path_m.f90,v 2.6 2001/12/14 23:43:15 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
       "$RCSfile: get_beta_path_m.f90,v $"
d29 11
a39 8
!
 SUBROUTINE get_beta_path(frq,p_path,t_path,Catalog,beta_group,gl_slabs, &
        &   path_inds,beta_path,gl_slabs_m,t_path_m,gl_slabs_p,t_path_p, &
        &   dbeta_dt_path,dbeta_dw_path,dbeta_dn_path,dbeta_dv_path)

!  ===============================================================
!  Declaration of variables for sub-program: get_coarse_beta_path
!  ===============================================================
a40 7
!
  REAL(r8), INTENT(in) :: frq ! frequency in MHz
  REAL(rp), INTENT(in) :: t_path(:) ! path temperatures
  REAL(rp), INTENT(in) :: p_path(:) ! path pressures in hPa!
  Type(Catalog_T), INTENT(IN) :: Catalog(:)
  Type (slabs_struct), DIMENSION(:,:), POINTER :: gl_slabs
  INTEGER(ip), INTENT(in) :: path_inds(:) ! indicies for reading gl_slabs
d42 9
a50 2
  type (beta_group_T), dimension(:), pointer :: beta_group
!
d53 2
a54 2
!
  TYPE(slabs_struct), OPTIONAL, POINTER :: gl_slabs_m(:,:) ! reduced
d56 1
a56 1
  REAL(rp), OPTIONAL, INTENT(in) :: t_path_m(:) ! path temperatures for
d58 1
a58 1
  TYPE(slabs_struct), OPTIONAL, POINTER :: gl_slabs_p(:,:) ! reduced
d60 2
a61 2
  REAL(rp), OPTIONAL, INTENT(in) :: t_path_p(:) ! path temperatures for
!
d63 3
a65 3
!
  REAL(rp), INTENT(out) :: beta_path(:,:) ! path beta for each species
!
d67 6
a72 6
!
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dt_path(:,:) ! t dep.
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dw_path(:,:) ! line width
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dn_path(:,:) ! line width t dep.
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dv_path(:,:) ! line position
!
d74 7
a80 7
!
  Integer(ip) :: i, j, k, m, n, nl, ib, nbe, Spectag, no_of_lines, &
            &    no_mol, n_path
  REAL(rp) :: ratio, bb, vp, v0, vm, t, tm, tp, bp, bm
  REAL(rp), allocatable, dimension(:) :: LineWidth
  REAL(rp), allocatable, dimension(:) :: betam, betap
!
a81 40
!
  no_mol = Size(beta_group)
  n_path = SIZE(path_inds)
!
  beta_path = 0.0
  if(PRESENT(dbeta_dw_path)) dbeta_dw_path = 0.0
  if(PRESENT(dbeta_dn_path)) dbeta_dn_path = 0.0
  if(PRESENT(dbeta_dv_path)) dbeta_dv_path = 0.0
!
  DO i = 1, no_mol
    nbe = beta_group(i)%n_elements
    do n = 1, nbe
      ratio = beta_group(i)%ratio(n)
      ib = beta_group(i)%cat_index(n)
      Spectag = Catalog(ib)%Spec_Tag
      no_of_lines = gl_slabs(1,ib)%no_lines
      Allocate(LineWidth(no_of_lines))
      do k = 1, no_of_lines
        m = Catalog(ib)%Lines(k)
        LineWidth(k) = Lines(m)%W
      end do
      DO j = 1, n_path
        k = path_inds(j)
        CALL create_beta(Spectag,Catalog(ib)%continuum,p_path(k),t_path(k), &
          &  Frq,no_of_lines,LineWidth,gl_slabs(k,ib)%v0s,gl_slabs(k,ib)%x1,&
          &  gl_slabs(k,ib)%y,gl_slabs(k,ib)%yi,gl_slabs(k,ib)%slabs1,bb,   &
          &  gl_slabs(k,ib)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,DBETA_DV=vm)
        beta_path(j,i) = beta_path(j,i) + ratio * bb
        if(PRESENT(dbeta_dw_path)) &
          &  dbeta_dw_path(j,i) = dbeta_dw_path(j,i) + ratio * v0
        if(PRESENT(dbeta_dn_path)) &
          &  dbeta_dn_path(j,i) = dbeta_dn_path(j,i) + ratio * vp
        if(PRESENT(dbeta_dv_path)) &
          &  dbeta_dv_path(j,i) = dbeta_dv_path(j,i) + ratio * vm
      END DO
      DEAllocate(LineWidth)
    end do
  END DO
!
  IF(PRESENT(dbeta_dt_path)) THEN
d83 7
a89 1
    Allocate(betam(n_path),betap(n_path))
d91 2
a92 7
    dbeta_dt_path = 0.0
!
    DO i = 1, no_mol
      betam = 0.0
      betap = 0.0
      nbe = beta_group(i)%n_elements
      do n = 1, nbe
d96 2
a97 2
        no_of_lines = gl_slabs_m(1,ib)%no_lines
        Allocate(LineWidth(no_of_lines))
d99 1
a99 2
          m = Catalog(ib)%Lines(k)
          LineWidth(k) = Lines(m)%W
d101 1
a101 1
        DO j = 1 , n_path
d103 52
a155 5
          CALL create_beta(Spectag,Catalog(ib)%continuum,p_path(k),tm,Frq,    &
          &    no_of_lines,LineWidth,gl_slabs_m(k,ib)%v0s,gl_slabs_m(k,ib)%x1,&
          &    gl_slabs_m(k,ib)%y,gl_slabs_m(k,ib)%yi,gl_slabs_m(k,ib)%slabs1,&
          &    vm,gl_slabs_m(k,ib)%dslabs1_dv0)
          betam(j) = betam(j) + vm * ratio
d157 26
a182 7
          CALL create_beta(Spectag,Catalog(ib)%continuum,p_path(k),tp,Frq,    &
          &    no_of_lines,LineWidth,gl_slabs_m(k,ib)%v0s,gl_slabs_p(k,ib)%x1,&
          &    gl_slabs_p(k,ib)%y,gl_slabs_p(k,ib)%yi,gl_slabs_p(k,ib)%slabs1,&
          &    vp,gl_slabs_p(k,ib)%dslabs1_dv0)
          betap(j) = betap(j) + vp * ratio
        END DO
        DeAllocate(LineWidth)
d184 3
a186 36
      DO j = 1 , n_path
        k = path_inds(j)
        t  = t_path(k)
        tm = t_path_m(k)
        tp = t_path_p(k)
        bm = betam(j)
        bp = betap(j)
        bb = beta_path(j,i)
        if ( bp > 0.0 .and. bb > 0.0 .and. bm > 0.0 ) then
          vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
          v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
          vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
        else if ( bp > 0.0 .and. bb > 0.0) then
          vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
          vm = vp
          v0 = vp
        else if ( bm > 0.0 .and. bb > 0.0) then
          vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
          vp = vm
          v0 = vm
        else if ( bm > 0.0 .and. bp > 0.0) then
          v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
          vp = v0
          vm = v0
        else
          vp = 0.0
          v0 = 0.0
          vm = 0.0
        endif
        dbeta_dt_path(j,i) = (vp + 2.0 * v0 + vm) / 4.0  ! Weighted Average
      END DO
    ENDDO
    DeAllocate(betam,betap)
  ENDIF
!
 END SUBROUTINE get_beta_path
d189 2
a190 1
End module GET_BETA_PATH_M
d192 3
@


2.6
log
@Modification for Grouping concept
@
text
@d19 1
a19 1
       "$Id: get_beta_path_m.f90,v 2.5 2001/11/15 01:22:01 zvi Exp $"
d73 1
d117 2
d122 2
a123 2
      bm = 0.0_rp
      bp = 0.0_rp
d142 1
a142 1
          bm = bm + vm * ratio
d148 1
a148 1
          bp = bp + vp * ratio
d155 4
d184 1
d192 3
@


2.5
log
@Remove Extiction debug
@
text
@d10 7
d18 4
a21 5
  character (len=*), parameter, private :: IdParm = &
  "$Id: get_beta_path_m.f90,v 2.4 2001/11/10 00:46:40 zvi Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
  "$RCSfile: get_beta_path_m.f90,v $"
d27 3
a29 3
 SUBROUTINE get_beta_path(frq,p_path,t_path,Catalog,gl_slabs,path_inds,      &
        &   beta_path,gl_slabs_m,t_path_m,gl_slabs_p,t_path_p,dbeta_dt_path, &
        &   dbeta_dw_path,dbeta_dn_path,dbeta_dv_path)
d42 2
d69 3
a71 2
  Integer(ip) :: n_sps, n_path, i, j, k, m, nl, no_of_lines, Spectag
  REAL(rp) :: bb, vp, v0, vm, vn2, t, tm, tp, bp, bm
d76 1
a76 1
  n_sps = Size(Catalog)
d79 32
a110 9
! no derivative call
!
  DO i = 1, n_sps
    Spectag = Catalog(i)%Spec_Tag
    no_of_lines = gl_slabs(1,i)%no_lines
    Allocate(LineWidth(no_of_lines))
    do k = 1, no_of_lines
      m = Catalog(i)%Lines(k)
      LineWidth(k) = Lines(m)%W
d112 1
a112 13
    DO j = 1, n_path
      k = path_inds(j)
      CALL create_beta(Spectag,Catalog(i)%continuum,p_path(k),t_path(k), &
        &  Frq,no_of_lines,LineWidth,gl_slabs(k,i)%v0s,gl_slabs(k,i)%x1, &
        &  gl_slabs(k,i)%y,gl_slabs(k,i)%yi,gl_slabs(k,i)%slabs1,bb,     &
        &  gl_slabs(k,i)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,DBETA_DV=vm)
      beta_path(j,i) = bb
      if(PRESENT(dbeta_dw_path)) dbeta_dw_path(j,i) = v0
      if(PRESENT(dbeta_dn_path)) dbeta_dn_path(j,i) = vp
      if(PRESENT(dbeta_dv_path)) dbeta_dv_path(j,i) = vm
    END DO
    DEAllocate(LineWidth)
  ENDDO
d115 2
d118 30
a147 7
    DO i = 1 , n_sps
      Spectag = Catalog(i)%Spec_Tag
      no_of_lines = gl_slabs_m(1,i)%no_lines
      Allocate(LineWidth(no_of_lines))
      do k = 1, no_of_lines
        m = Catalog(i)%Lines(k)
        LineWidth(k) = Lines(m)%W
a150 10
        tm = t_path_m(k)
        CALL create_beta(Spectag,Catalog(i)%continuum,p_path(k),tm,Frq,   &
        &    no_of_lines,LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_m(k,i)%x1,&
        &    gl_slabs_m(k,i)%y,gl_slabs_m(k,i)%yi,gl_slabs_m(k,i)%slabs1, &
        &    bm,gl_slabs_m(k,i)%dslabs1_dv0)
        tp = t_path_p(k)
        CALL create_beta(Spectag,Catalog(i)%continuum,p_path(k),tp,Frq,   &
        &    no_of_lines,LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_p(k,i)%x1,&
        &    gl_slabs_p(k,i)%y,gl_slabs_p(k,i)%yi,gl_slabs_p(k,i)%slabs1, &
        &    bp,gl_slabs_p(k,i)%dslabs1_dv0)
d175 1
a175 2
      ENDDO
      DeAllocate(LineWidth)
d184 3
@


2.4
log
@Adding the EXTINCTION capabilitis
@
text
@d9 1
a9 1
 
d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 2.3 2001/11/07 22:24:45 zvi Exp $"
d23 2
a24 2
        &   dbeta_dw_path,dbeta_dn_path,dbeta_dv_path,ext_ind,bn2_path)
 
a46 1
  INTEGER(ip), OPTIONAL, INTENT(in) :: ext_ind  ! EXTINCTION index among species
a57 2

  REAL(rp), OPTIONAL, INTENT(out) :: bn2_path(:)        ! path beta for N2
d85 1
a85 2
        &  gl_slabs(k,i)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,DBETA_DV=vm,&
        &  BV_N2=vn2)
a89 3
      if(PRESENT(bn2_path) .AND. PRESENT(ext_ind)) then
        if(i == ext_ind) bn2_path(j) = vn2
      endif
d146 1
a146 1
 
d150 3
@


2.3
log
@Further modification for the t-power computations
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 2.2 2001/11/07 21:13:48 livesey Exp $"
d21 3
a23 3
 SUBROUTINE get_beta_path(frq,p_path,t_path,Catalog,gl_slabs,path_inds,  &
        &   beta_path,gl_slabs_m,t_path_m,gl_slabs_p,t_path_p,       &
        &   dbeta_dt_path,dbeta_dw_path,dbeta_dn_path,dbeta_dv_path)
d47 1
d59 2
d65 1
a65 1
  REAL(rp) :: bb, vp, v0, vm, t, tm, tp, bp, bm
d88 2
a89 1
        &  gl_slabs(k,i)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,DBETA_DV=vm)
d94 3
d157 3
@


2.2
log
@Fixed bug with log(0.0/0.0) for molecues with no lines
or continua
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 2.1 2001/10/16 15:07:18 zvi Exp $"
d122 12
d150 4
@


2.1
log
@Continuum parameters are now part of Catalog
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d118 9
a126 3
        vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
        v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
        vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
d138 3
@


2.0
log
@New forward model
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.22.2.1 2001/09/10 10:02:32 zvi Exp $"
d82 4
a85 5
      CALL create_beta(Spectag,p_path(k),t_path(k),Frq,no_of_lines, &
        &  LineWidth,gl_slabs(k,i)%v0s,gl_slabs(k,i)%x1,            &
        &  gl_slabs(k,i)%y,gl_slabs(k,i)%yi,gl_slabs(k,i)%slabs1,   &
        &  bb,gl_slabs(k,i)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,    &
        &  DBETA_DV=vm)
d107 2
a108 2
        CALL create_beta(Spectag,p_path(k),tm,Frq,no_of_lines,            &
        &    LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_m(k,i)%x1,            &
d112 2
a113 2
        CALL create_beta(Spectag,p_path(k),tp,Frq,no_of_lines,            &
        &    LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_p(k,i)%x1,            &
d132 3
@


1.22
log
@Speed enhancement MAJOR update
@
text
@d1 4
a4 9
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module GET_BETA_PATH_M
  use MLSCommon, only: I4, R8
  use GLNP, only: NG
  use SpectroscopyCatalog_m, only: Catalog_T, Lines
  use L2PC_PFA_STRUCTURES, only: PFA_SLAB, SLABS_STRUCT, MAXLINES
  use PATH_ENTITIES_M, only: PATH_VECTOR, PATH_BETA, PATH_INDEX
d8 2
a9 2
  public :: GET_COARSE_BETA_PATH, GET_GLBETA_PATH, GET_BETA_PATH

d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.8 2001/03/09 02:26:11 vsnyder Exp $"
d18 7
a24 6
!----------------------------------------------------------------------

 SUBROUTINE get_coarse_beta_path(ptg_i,Catalog,ndx_path,gl_slabs, &
         &  no_frq,mnf,ht,frq_grid,z_path,h_path,t_path,Frq_Gap,  &
         &  temp_der, spect_der, beta_path, Ier)

d28 1
a28 59
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: ptg_i, no_frq, mnf

Real(r8), INTENT(IN) :: frq_grid(:)
Real(r8), INTENT(IN) :: ht, Frq_Gap
Logical,  INTENT(IN) :: temp_der, spect_der

Integer(i4), INTENT(OUT) :: ier

Type(path_vector), INTENT(IN) :: z_path, h_path, t_path

Type(path_index) :: ndx_path
Type (slabs_struct), DIMENSION(:,:), POINTER :: gl_slabs

Type(Catalog_T), INTENT(IN) :: Catalog(:)

Type(path_beta), POINTER :: beta_path(:,:)  ! (sps_i,frq_i)

!  ----------------
!  Local variables:
!  ----------------

Integer(i4) :: nl,i,j,k,mp,no_sps,spectag,frq_i,Ngp1,no_ele,brkpt

Real(r8) :: z, p, h, t, Frq
Real(r8) :: values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu

! Begin code:

  ier = 0
  Ngp1 = Ng + 1
  no_sps = Size(Catalog)
!
  brkpt = ndx_path%break_point_index
  no_ele = ndx_path%total_number_of_elements
!
! Allocate all the needed space for beta.
! NOTE: This is done onl once per MAF, at the lowest pointing,
! where the lenght of the path is maximal, also, allocate beta
! with the maximum number of frequencies (mnf) over all pointings..
!
  if(ptg_i == 1) then
!
    if ( associated(beta_path) ) then
      do i = 1, size(beta_path,1)
        do frq_i = 1, size(beta_path,2)
          DEALLOCATE(beta_path(i,frq_i)%values,   &
            &        beta_path(i,frq_i)%t_power,  &
            &        beta_path(i,frq_i)%dbeta_dw, &
            &        beta_path(i,frq_i)%dbeta_dn, &
            &        beta_path(i,frq_i)%dbeta_dnu, STAT=j )
        end do
      end do
      DEALLOCATE(beta_path,STAT=j)
    end if
!
    ALLOCATE(beta_path(no_sps,mnf),STAT=j)
d30 74
a103 18
    do i = 1, size(beta_path,1)
      do frq_i = 1, size(beta_path,2)
        ALLOCATE(beta_path(i,frq_i)%values(no_ele),    &
           &     beta_path(i,frq_i)%t_power(no_ele),   &
           &     beta_path(i,frq_i)%dbeta_dw(no_ele),  &
           &     beta_path(i,frq_i)%dbeta_dn(no_ele),  &
           &     beta_path(i,frq_i)%dbeta_dnu(no_ele), STAT = ier)
        if(ier /= 0) then
          PRINT *,'** Allocation error in routine: get_beta_path ..'
          PRINT *,'   no_ele,ptg_i,i,frq_i:',no_ele,ptg_i,i,frq_i
          PRINT *,'   STAT =',ier
          Return
        endif
        beta_path(i,frq_i)%values = 0.0
        beta_path(i,frq_i)%t_power = 0.0
        beta_path(i,frq_i)%dbeta_dw = 0.0
        beta_path(i,frq_i)%dbeta_dn = 0.0
        beta_path(i,frq_i)%dbeta_dnu = 0.0
d105 22
a126 68
    end do
!
  endif
!
  DO i = 1, no_sps
!
    Spectag = Catalog(i)%spec_tag
!
    nl = gl_slabs(1,i)%no_lines
!
    mp = 1 - Ngp1
    do
!
      mp = mp + Ngp1
      if (mp > brkpt) EXIT
!
      z = z_path%values(mp)
      if(z <= -4.5) CYCLE
!
      j = mp
      t = t_path%values(mp)
      p = 10.0d0**(-z)
!
      do frq_i = 1, no_frq
!
        Frq = frq_grid(frq_i)
!
        Call Create_beta (Spectag,p,t,Frq,nl,Catalog(i),gl_slabs(j,i)%v0s, &
       &     gl_slabs(j,i)%x1,gl_slabs(j,i)%y,gl_slabs(j,i)%yi,            &
       &     gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dx1_dv0,                   &
       &     gl_slabs(j,i)%dy_dv0,gl_slabs(j,i)%dslabs1_dv0,               &
       &     gl_slabs(j,i)%v0sp,gl_slabs(j,i)%x1p,gl_slabs(j,i)%yp,        &
       &     gl_slabs(j,i)%yip,gl_slabs(j,i)%slabs1p,gl_slabs(j,i)%v0sm,   &
       &     gl_slabs(j,i)%x1m,gl_slabs(j,i)%ym,gl_slabs(j,i)%yim,         &
       &     gl_slabs(j,i)%slabs1m,values,t_power,dbeta_dw,dbeta_dn,       &
       &     dbeta_dnu, Frq_Gap, temp_der, spect_der, Ier)
        if(Ier /= 0) Return
!
        beta_path(i,frq_i)%values(mp) = values
        beta_path(i,frq_i)%t_power(mp) = t_power
        beta_path(i,frq_i)%dbeta_dw(mp) = dbeta_dw
        beta_path(i,frq_i)%dbeta_dn(mp) = dbeta_dn
        beta_path(i,frq_i)%dbeta_dnu(mp) = dbeta_dnu
!
      end do          ! On frq_i
!
    end do
!
    mp = brkpt + 1
    h = h_path%values(mp)
    do while (h < ht - 0.0001)
      mp = mp + Ngp1
      h = h_path%values(mp)
    end do
!
    mp = mp - Ngp1
!
    do
!
      mp = mp + Ngp1
      if(mp > no_ele) Return
!
      z = z_path%values(mp)
      if(z <= -4.5) CYCLE
!
      j = mp
      t = t_path%values(mp)
      p = 10.0d0**(-z)
d128 2
a129 128
      do frq_i = 1, no_frq
!
        Frq = frq_grid(frq_i)
!
        Call Create_beta (Spectag,p,t,Frq,nl,Catalog(i),gl_slabs(j,i)%v0s, &
       &     gl_slabs(j,i)%x1,gl_slabs(j,i)%y,gl_slabs(j,i)%yi,            &
       &     gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dx1_dv0,                   &
       &     gl_slabs(j,i)%dy_dv0,gl_slabs(j,i)%dslabs1_dv0,               &
       &     gl_slabs(j,i)%v0sp,gl_slabs(j,i)%x1p,gl_slabs(j,i)%yp,        &
       &     gl_slabs(j,i)%yip,gl_slabs(j,i)%slabs1p,gl_slabs(j,i)%v0sm,   &
       &     gl_slabs(j,i)%x1m,gl_slabs(j,i)%ym,gl_slabs(j,i)%yim,         &
       &     gl_slabs(j,i)%slabs1m,values,t_power,dbeta_dw,dbeta_dn,       &
       &     dbeta_dnu, Frq_Gap, temp_der, spect_der, Ier)
!
        beta_path(i,frq_i)%values(mp) = values
        beta_path(i,frq_i)%t_power(mp) = t_power
        beta_path(i,frq_i)%dbeta_dw(mp) = dbeta_dw
        beta_path(i,frq_i)%dbeta_dn(mp) = dbeta_dn
        beta_path(i,frq_i)%dbeta_dnu(mp) = dbeta_dnu
!
      end do          ! On frq_i
!
    end do
!
  END DO              ! On i

  Return
!
 END SUBROUTINE get_coarse_beta_path

!----------------------------------------------------------------------

 SUBROUTINE get_glbeta_path(ptg_i,frq_i,Catalog,gl_ndx,no_gl_ndx,gl_slabs, &
         &  Frq,z_path,t_path,Frq_Gap,temp_der,spect_der,beta_path,Ier)

!  ===============================================================
!  Declaration of variables for sub-program: get_glbeta_path
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: ptg_i,frq_i, no_gl_ndx
Integer(i4), INTENT(IN) :: gl_ndx(:,:)
Logical,     INTENT(IN) :: temp_der, spect_der

Real(r8), INTENT(IN) :: Frq, Frq_Gap

Integer(i4), INTENT(OUT) :: ier

Type (slabs_struct), DIMENSION(:,:), POINTER :: gl_slabs

Type(path_vector), INTENT(IN) :: z_path, t_path

Type(Catalog_T), INTENT(IN) :: Catalog(:)

Type(path_beta), POINTER :: beta_path(:,:)  ! (sps_i,frq_i)

!  ----------------
!  Local variables:
!  ----------------

Integer(i4) :: nl, i, j, no_sps, spectag, Ngp1, mp, jj

Real(r8) :: z, p, t,values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu

! Begin code:

  ier = 0
  if(no_gl_ndx < 1) Return
!
  Ngp1 = Ng + 1
  no_sps = Size(Catalog)
!
  DO i = 1, no_sps
!
    Spectag = Catalog(i)%spec_tag
!
    nl = gl_slabs(1,i)%no_lines
!
    do jj = 1, no_gl_ndx
!
      mp = gl_ndx(jj,2)
      j = mp

      do                     !  GL Inner loop
!
        j = j + 1
        if(j >= gl_ndx(jj+1,2)) EXIT

        z = z_path%values(j)
        if(z <= -4.5) CYCLE
!
        p = 10.0d0**(-z)
        t = t_path%values(j)
!
        Call Create_beta (Spectag,p,t,Frq,nl,Catalog(i),gl_slabs(j,i)%v0s, &
       &     gl_slabs(j,i)%x1,gl_slabs(j,i)%y,gl_slabs(j,i)%yi,            &
       &     gl_slabs(j,i)%slabs1,gl_slabs(j,i)%dx1_dv0,                   &
       &     gl_slabs(j,i)%dy_dv0,gl_slabs(j,i)%dslabs1_dv0,               &
       &     gl_slabs(j,i)%v0sp,gl_slabs(j,i)%x1p,gl_slabs(j,i)%yp,        &
       &     gl_slabs(j,i)%yip,gl_slabs(j,i)%slabs1p,gl_slabs(j,i)%v0sm,   &
       &     gl_slabs(j,i)%x1m,gl_slabs(j,i)%ym,gl_slabs(j,i)%yim,         &
       &     gl_slabs(j,i)%slabs1m,values,t_power,dbeta_dw,dbeta_dn,       &
       &     dbeta_dnu, Frq_Gap, temp_der, spect_der, Ier)
        if(Ier /= 0) Return
!
        beta_path(i,frq_i)%values(j) = values
        beta_path(i,frq_i)%t_power(j) = t_power
        beta_path(i,frq_i)%dbeta_dw(j) = dbeta_dw
        beta_path(i,frq_i)%dbeta_dn(j) = dbeta_dn
        beta_path(i,frq_i)%dbeta_dnu(j) = dbeta_dnu
!
      end do          ! On GL inner loop
!
    end do            ! On jj
!
  END DO              ! On i
!
  Return
!
! Cleanup cycle ...
!
 99  Print *,'** Error in get_glbeta routine ..'

  Return

 END SUBROUTINE get_glbeta_path

a130 154
! Computes beta over the entire GL path without referring to the gl_ndx at all.

 subroutine Get_beta_path ( frequencies, Catalog, no_ele, z_path, t_path, &
      &     beta_path, vel_z, Frq_Gap, temp_der, spect_der, Ier)

 use SLABS_SW_M, only: SLABS_PREP_ARRAYS

  !  ===============================================================
  !  Declaration of variables for sub-program: get_beta_path
  !  ===============================================================
  !  ---------------------------
  !  Calling sequence variables:
  !  ---------------------------

  Real(r8), dimension(:), intent(in) :: frequencies
  Integer(i4), intent(in) :: no_ele
  Logical, intent(in) :: temp_der, spect_der

  Real(r8),    intent(in) :: vel_z, Frq_Gap

  Integer(i4), intent(out) :: ier

  Type(path_vector), intent(in) :: z_path, t_path

  Type(Catalog_T), dimension(:), intent(in) :: Catalog

  Type(path_beta), pointer :: beta_path(:,:)  ! (sps_i,frq_i)

  !  ----------------
  !  Local variables:
  !  ----------------

  Real(r8), parameter :: C = 299792.4583_r8    ! Speed of Light Km./Sec.

  Integer(i4) :: nl, i, no_sps, mnf, spectag, h_i, frq_i

  Real(r8) :: Qlog(3), mass, z, p, t, Frq, Vel_z_correction
  Real(r8) :: values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu

  Real(r8) :: y(50), ym(50), yp(50)
  Real(r8) :: yi(50), yim(50), yip(50)
  Real(r8) :: x1(50), x1m(50), x1p(50)
  Real(r8) :: v0s(50), v0sm(50), v0sp(50)
  Real(r8) :: slabs1(50), slabs1m(50), slabs1p(50)
  Real(r8) :: dy_dv0(50), dx1_dv0(50), dslabs1_dv0(50)

  ! Begin code:

  ier = 0
  no_sps = Size(Catalog)
  mnf =  size(frequencies)

  ! call output('In get_beta_path_m',advance='yes')
  ! call dump(frequencies)

  Vel_z_correction = 1.0_r8 - vel_z / c

  ! Allocate all the needed space for beta..

  if ( associated(beta_path) ) then
    do i = 1, size(beta_path,1)
      do frq_i = 1, size(beta_path,2)
        deallocate ( beta_path(i,frq_i)%values, beta_path(i,frq_i)%t_power, &
          & beta_path(i,frq_i)%dbeta_dw, beta_path(i,frq_i)%dbeta_dn, &
          & beta_path(i,frq_i)%dbeta_dnu, STAT=h_i )
      end do
    end do
  end if

  deallocate ( beta_path, stat=h_i )
  allocate ( beta_path(no_sps,mnf), stat=h_i )

  do i = 1, no_sps
    do frq_i = 1, mnf
      allocate(beta_path(i,frq_i)%values(no_ele),    &
  &            beta_path(i,frq_i)%t_power(no_ele),   &
  &            beta_path(i,frq_i)%dbeta_dw(no_ele),  &
  &            beta_path(i,frq_i)%dbeta_dn(no_ele),  &
  &            beta_path(i,frq_i)%dbeta_dnu(no_ele), STAT = ier)
      if ( ier /= 0 ) then
        print *,'** Allocation error in routine: get_beta_path ..'
        print *,'   no_ele,i,frq_i:',no_ele,i,frq_i
        print *,'   STAT =',ier
        goto 99
      end if
    end do
  end do

  do i = 1, no_sps

    Spectag = Catalog(i)%spec_tag
    mass = Real(Spectag) / 1000.0

    nl = Size(Catalog(i)%lines)
    Qlog(1:3) = Catalog(i)%QLOG(1:3)

    do h_i = 1, no_ele

      z = z_path%values(h_i)
      if(z <= -4.5) CYCLE

      p = 10.0**(-z)
      t = t_path%values(h_i)
!
      Call  Slabs_Prep_Arrays(Spectag,nl,t,p,mass,Catalog(i),Qlog,v0s, &
        &   x1,y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,x1p,yp,yip, &
        &   slabs1p,v0sm,x1m,ym,yim,slabs1m)

! Apply velocity corrections:

      v0s(1:nl)  = v0s(1:nl)  * Vel_z_correction
      v0sp(1:nl) = v0sp(1:nl) * Vel_z_correction
      v0sm(1:nl) = v0sm(1:nl) * Vel_z_correction

      do frq_i = 1, mnf

        Frq = frequencies(frq_i)

        Call Create_beta (Spectag,p,t,Frq,nl,Catalog(i),v0s,x1, &
       &     y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,x1p,yp,&
       &     yip,slabs1p,v0sm,x1m,ym,yim,slabs1m,values,t_power,&
       &     dbeta_dw,dbeta_dn,dbeta_dnu,Frq_Gap,temp_der,spect_der,Ier)
        if(Ier /= 0) goto 99

        beta_path(i,frq_i)%values(h_i) = values
        beta_path(i,frq_i)%t_power(h_i) = t_power
        beta_path(i,frq_i)%dbeta_dw(h_i) = dbeta_dw
        beta_path(i,frq_i)%dbeta_dn(h_i) = dbeta_dn
        beta_path(i,frq_i)%dbeta_dnu(h_i) = dbeta_dnu

      end do          ! On frq_i

    end do            ! On h_i

  end do              ! On i

  Return

! Cleanup cycle ...

 99  do i = 1, no_sps
       do frq_i = 1, mnf
         deallocate(beta_path(i,frq_i)%values,beta_path(i,frq_i)%t_power, &
           &        beta_path(i,frq_i)%dbeta_dw,beta_path(i,frq_i)%dbeta_dn, &
           &        beta_path(i,frq_i)%dbeta_dnu,STAT=h_i )
       end do
     end do

     deallocate ( beta_path, STAT=h_i )

    Return

  end subroutine get_beta_path
!
d133 2
a134 38
! Revision 1.21  2001/05/16 00:42:10  livesey
! Fixed velocity correction.  Make sure this is OK with people later.
!
! Revision 1.20  2001/05/15 03:47:26  zvi
! Adding derivative flag to beta calculations
!
! Revision 1.19  2001/05/14 23:14:54  zvi
! Added Freq. Gap test..
!
! Revision 1.18  2001/05/03 22:17:32  vsnyder
! Changed some d0 constants to _r8, cosmetic changes
!
! Revision 1.17  2001/05/02 20:49:23  zvi
! Cleaning up code
!
! Revision 1.16  2001/04/05 21:58:47  zvi
! Implementing l2cf inputs for FilterShape & Spectroscopy instead of FMI
!
! Revision 1.15  2001/04/03 07:32:45  zvi
! Modify the spectral structure - eliminating sps_ from the names
!
! Revision 1.14  2001/03/31 23:40:55  zvi
! Eliminate l2pcdim (dimension parameters) move to allocatable ..
!
! Revision 1.13  2001/03/29 08:51:01  zvi
! Changing the (*) toi (:) everywhere
!
! Revision 1.12  2001/03/20 23:22:40  zvi
! Change to new geoc_geod routine..
!
! Revision 1.11  2001/03/20 11:03:16  zvi
! Fixing code for "real" data run, increase dim. etc.
!
! Revision 1.10  2001/03/20 02:29:26  livesey
! Interim version, gets same numbers as zvi
!
! Revision 1.9  2001/03/15 12:18:03  zvi
! Adding the Velocity effect on Line center frequency
@


1.22.2.1
log
@Cleanup..comp_path_entities_m.f90
@
text
@d1 9
a9 4
Module GET_BETA_PATH_M
  use MLSCommon, only: R8, RP, IP
  use L2PC_PFA_STRUCTURES, only: SLABS_STRUCT
  use SpectroscopyCatalog_m, only: CATALOG_T, LINES
d13 2
a14 2
  PUBLIC :: get_beta_path
 
d23 6
a28 7
! This is a generic form of get coarse beta path. We really don't need
! separate versions of these.
!
 SUBROUTINE get_beta_path(frq,p_path,t_path,Catalog,gl_slabs,path_inds,  &
        &   beta_path,gl_slabs_m,t_path_m,gl_slabs_p,t_path_p,       &
        &   dbeta_dt_path,dbeta_dw_path,dbeta_dn_path,dbeta_dv_path)
 
d32 59
a90 1
! Inputs:
d92 18
a109 74
  REAL(r8), INTENT(in) :: frq ! frequency in MHz
  REAL(rp), INTENT(in) :: t_path(:) ! path temperatures
  REAL(rp), INTENT(in) :: p_path(:) ! path pressures in hPa!
  Type(Catalog_T), INTENT(IN) :: Catalog(:)
  Type (slabs_struct), DIMENSION(:,:), POINTER :: gl_slabs
  INTEGER(ip), INTENT(in) :: path_inds(:) ! indicies for reading gl_slabs
!
! Another clumsy feature of f90
! Optional inputs:
!
  TYPE(slabs_struct), OPTIONAL, POINTER :: gl_slabs_m(:,:) ! reduced
!                               strength data for t_path_m
  REAL(rp), OPTIONAL, INTENT(in) :: t_path_m(:) ! path temperatures for
!                                                 gl_slabs_m
  TYPE(slabs_struct), OPTIONAL, POINTER :: gl_slabs_p(:,:) ! reduced
!                               strength data for t_path_p
  REAL(rp), OPTIONAL, INTENT(in) :: t_path_p(:) ! path temperatures for
!
! outputs
!
  REAL(rp), INTENT(out) :: beta_path(:,:) ! path beta for each species
!
! Optional output:
!
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dt_path(:,:) ! t dep.
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dw_path(:,:) ! line width
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dn_path(:,:) ! line width t dep.
  REAL(rp), OPTIONAL, INTENT(out) :: dbeta_dv_path(:,:) ! line position
!
! Local varibles..
!
  Integer(ip) :: n_sps, n_path, i, j, k, m, nl, no_of_lines, Spectag
  REAL(rp) :: bb, vp, v0, vm, t, tm, tp, bp, bm
  REAL(rp), allocatable, dimension(:) :: LineWidth
!
! begin the code
!
  n_sps = Size(Catalog)
  n_path = SIZE(path_inds)
!
! no derivative call
!
  DO i = 1, n_sps
    Spectag = Catalog(i)%Spec_Tag
    no_of_lines = gl_slabs(1,i)%no_lines
    Allocate(LineWidth(no_of_lines))
    do k = 1, no_of_lines
      m = Catalog(i)%Lines(k)
      LineWidth(k) = Lines(m)%W
    end do
    DO j = 1, n_path
      k = path_inds(j)
      CALL create_beta(Spectag,p_path(k),t_path(k),Frq,no_of_lines, &
        &  LineWidth,gl_slabs(k,i)%v0s,gl_slabs(k,i)%x1,            &
        &  gl_slabs(k,i)%y,gl_slabs(k,i)%yi,gl_slabs(k,i)%slabs1,   &
        &  bb,gl_slabs(k,i)%dslabs1_dv0,DBETA_DW=v0,DBETA_DN=vp,    &
        &  DBETA_DV=vm)
      beta_path(j,i) = bb
      if(PRESENT(dbeta_dw_path)) dbeta_dw_path(j,i) = v0
      if(PRESENT(dbeta_dn_path)) dbeta_dn_path(j,i) = vp
      if(PRESENT(dbeta_dv_path)) dbeta_dv_path(j,i) = vm
    END DO
    DEAllocate(LineWidth)
  ENDDO
!
  IF(PRESENT(dbeta_dt_path)) THEN
!
    DO i = 1 , n_sps
      Spectag = Catalog(i)%Spec_Tag
      no_of_lines = gl_slabs_m(1,i)%no_lines
      Allocate(LineWidth(no_of_lines))
      do k = 1, no_of_lines
        m = Catalog(i)%Lines(k)
        LineWidth(k) = Lines(m)%W
d111 70
a180 22
      DO j = 1 , n_path
        k = path_inds(j)
        tm = t_path_m(k)
        CALL create_beta(Spectag,p_path(k),tm,Frq,no_of_lines,            &
        &    LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_m(k,i)%x1,            &
        &    gl_slabs_m(k,i)%y,gl_slabs_m(k,i)%yi,gl_slabs_m(k,i)%slabs1, &
        &    bm,gl_slabs_m(k,i)%dslabs1_dv0)
        tp = t_path_p(k)
        CALL create_beta(Spectag,p_path(k),tp,Frq,no_of_lines,            &
        &    LineWidth,gl_slabs_m(k,i)%v0s,gl_slabs_p(k,i)%x1,            &
        &    gl_slabs_p(k,i)%y,gl_slabs_p(k,i)%yi,gl_slabs_p(k,i)%slabs1, &
        &    bp,gl_slabs_p(k,i)%dslabs1_dv0)
        t  = t_path(k)
        bb = beta_path(j,i)
        vp = Log(bp/bb)/Log(tp/t)        ! Estimate over [temp+10,temp]
        v0 = Log(bp/bm)/Log(tp/tm)       ! Estimate over [temp+10,temp-10]
        vm = Log(bb/bm)/Log(t/tm)        ! Estimate over [temp,temp-10]
        dbeta_dt_path(j,i) = (vp + 2.0 * v0 + vm) / 4.0  ! Weighted Average
      ENDDO
      DeAllocate(LineWidth)
    ENDDO
  ENDIF
d182 28
a209 2
 END SUBROUTINE get_beta_path
 
d211 252
d465 39
@


1.21
log
@Fixed velocity correction.  Make sure this is OK with people later.
@
text
@d6 4
a9 2
  use PATH_ENTITIES_M, only: PATH_VECTOR, PATH_BETA
  use SLABS_SW_M, only: SLABS_PREP_WDER, SLABS_PREP
a10 3
  use output_m,only:output
  use Dump_0,only:dump
  use SpectroscopyCatalog_m, only: Catalog_T, Lines
d13 198
a210 1
  public :: get_beta_path
d212 95
a306 7
  !---------------------------- RCS Ident Info -------------------------------
    character (len=*), parameter, private :: IdParm = &
    "$Id: get_beta_path_m.f90,v 1.20 2001/05/15 03:47:26 zvi Exp $"
    character (len=len(idParm)) :: Id = IdParm
    character (len=*), parameter, private :: ModuleName= &
    "$RCSfile: get_beta_path_m.f90,v $"
  !---------------------------------------------------------------------------
a307 1
contains
d309 1
d312 3
a314 1
                      &     beta_path, vel_z, Frq_Gap, temp_der, spect_der, Ier)
d364 1
a364 2
  !  Vel_z_correction = 1.0_r8 + vel_z / c
  Vel_z_correction = 1.0_r8 - vel_z / c ! Debug
d412 4
a415 2

      Call Slabs_Prep_Arrays
d451 3
a453 3
         deallocate ( beta_path(i,frq_i)%values, beta_path(i,frq_i)%t_power, &
           &          beta_path(i,frq_i)%dbeta_dw, beta_path(i,frq_i)%dbeta_dn, &
           &          beta_path(i,frq_i)%dbeta_dnu, STAT=h_i )
d459 1
a459 40
  Return

! *****     Internal procedures     **********************************
  contains

! --------------------------------  slabs_prep_arrays   -----
    Subroutine Slabs_Prep_Arrays

    Integer(i4) :: j,k
    Real(r8) :: dslabs1,tp,tm

    if ( Spectag==18999 .or. Spectag==28964 .or. Spectag==28965 ) Return

    ! Check for anything but liquid water and dry air:

    do j = 1, nl

    ! Prepare the temperature weighted coefficients:

      k = Catalog(i)%Lines(j)
      Call Slabs_prep_wder(t,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,   &
        &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
        &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0s(j),x1(j),y(j),    &
        &  yi(j),slabs1(j),dx1_dv0(j),dy_dv0(j),dslabs1_dv0(j))

      tp = t + 10.0
      Call slabs_prep(tp,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,       &
        &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
        &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sp(j),x1p(j),yp(j), &
        &  yip(j),slabs1p(j),dslabs1)

      tm = t - 10.0
      Call slabs_prep(tm,mass,Lines(k)%V0, Lines(k)%EL,Lines(k)%W,      &
        &  Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
        &  Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sm(j),x1m(j),ym(j), &
        &  yim(j),slabs1m(j),dslabs1)

    end do

    End Subroutine Slabs_Prep_Arrays
d462 2
a463 1
end module GET_BETA_PATH_M
d465 3
@


1.20
log
@Adding derivative flag to beta calculations
@
text
@d18 1
a18 1
    "$Id: get_beta_path_m.f90,v 1.19 2001/05/14 23:14:54 zvi Exp $"
d78 2
a79 1
  Vel_z_correction = 1.0_r8 + vel_z / c
d216 3
@


1.19
log
@Added Freq. Gap test..
@
text
@d18 1
a18 1
    "$Id: get_beta_path_m.f90,v 1.18 2001/05/03 22:17:32 vsnyder Exp $"
d28 1
a28 1
                      &     beta_path, vel_z, Frq_Gap, ier )
d39 1
d142 1
a142 1
       &     dbeta_dw,dbeta_dn,dbeta_dnu,Frq_Gap,Ier)
d215 3
@


1.18
log
@Changed some d0 constants to _r8, cosmetic changes
@
text
@d18 1
a18 1
    "$Id: get_beta_path_m.f90,v 1.17 2001/05/02 20:49:23 zvi Exp $"
d28 1
a28 1
                      &     beta_path, vel_z, ier )
d39 2
a40 1
  Real(r8),    intent(in) :: vel_z
d141 1
a141 1
       &     dbeta_dw,dbeta_dn,dbeta_dnu,Ier)
d214 3
@


1.17
log
@Cleaning up code
@
text
@d1 3
d15 9
a23 7
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
  "$Id: get_beta_path_m.f90,v 1.16 2001/04/05 21:58:47 zvi Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
  "$RCSfile: get_beta_path_m.f90,v $"
!---------------------------------------------------------------------------
d27 13
a39 2
 SUBROUTINE get_beta_path(frequencies,Catalog,no_ele,z_path,t_path, &
                      &   beta_path,vel_z,ier)
d41 1
a41 6
!  ===============================================================
!  Declaration of variables for sub-program: get_beta_path
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
d43 1
a43 3
Real(r8), DIMENSION(:), INTENT(IN) :: frequencies
Integer(i4), INTENT(IN) :: no_ele
Real(r8),    INTENT(IN) :: vel_z
d45 1
a45 1
Integer(i4), INTENT(OUT) :: ier
d47 1
a47 1
Type(path_vector), INTENT(IN) :: z_path, t_path
d49 3
a51 1
Type(Catalog_T), DIMENSION(:), INTENT(IN) :: Catalog
d53 1
a53 1
Type(path_beta), POINTER :: beta_path(:,:)  ! (sps_i,frq_i)
d55 1
a55 3
!  ----------------
!  Local variables:
!  ----------------
d57 2
a58 1
Real(r8), PARAMETER :: c = 299792.4583d0     ! Speed of Light Km./Sec.
d60 8
a67 1
Integer(i4) :: nl, i, no_sps, mnf, spectag, h_i, frq_i
a68 12
Real(r8) :: Qlog(3), mass, z, p, t, Frq, Vel_z_correction
Real(r8) :: values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu
!
Real(r8) :: y(50), ym(50), yp(50)
Real(r8) :: yi(50), yim(50), yip(50)
Real(r8) :: x1(50), x1m(50), x1p(50)
Real(r8) :: v0s(50), v0sm(50), v0sp(50)
Real(r8) :: slabs1(50), slabs1m(50), slabs1p(50)
Real(r8) :: dy_dv0(50), dx1_dv0(50), dslabs1_dv0(50)
!
! Begin code:
!
d73 3
a75 3
! call output('In get_beta_path_m',advance='yes')
! call dump(frequencies)
!
d77 3
a79 3
!
! Allocate all the needed space for beta..
!
d83 1
a83 1
        DEALLOCATE ( beta_path(i,frq_i)%values, beta_path(i,frq_i)%t_power, &
d90 3
a92 3
  DEALLOCATE(beta_path,STAT=h_i)
  ALLOCATE(beta_path(no_sps,mnf),STAT=h_i)
!
d95 1
a95 1
      ALLOCATE(beta_path(i,frq_i)%values(no_ele),    &
d100 4
a103 4
      if(ier /= 0) then
        PRINT *,'** Allocation error in routine: get_beta_path ..'
        PRINT *,'   no_ele,i,frq_i:',no_ele,i,frq_i
        PRINT *,'   STAT =',ier
d105 1
a105 1
      endif
d108 3
a110 3
!
  DO i = 1, no_sps
!
d113 1
a113 1
!
d118 1
a118 1
!
d121 2
a122 2
!
      p = 10.0d0**(-z)
d124 1
a124 1
!
d126 1
a126 1
!
d128 1
a128 1
!
d132 1
a132 1
!
d134 1
a134 1
!
d136 1
a136 1
!
d142 1
a142 1
!
d148 1
a148 1
!
d150 1
a150 1
!
d152 2
a153 2
!
  END DO              ! On i
d156 1
a156 1
!
d158 1
a158 1
!
d161 3
a163 3
         DEALLOCATE(beta_path(i,frq_i)%values,beta_path(i,frq_i)%t_power,&
        &           beta_path(i,frq_i)%dbeta_dw,beta_path(i,frq_i)%dbeta_dn,&
        &           beta_path(i,frq_i)%dbeta_dnu, STAT=h_i)
d167 1
a167 1
     DEALLOCATE(beta_path, STAT=h_i)
d173 1
a173 1
!
d175 34
a208 4
  Subroutine Slabs_Prep_Arrays
!
  Integer(i4) :: j,k
  Real(r8) :: dslabs1,tp,tm
d210 1
a210 31
  if(Spectag==18999 .or. Spectag==28964 .or. Spectag==28965) Return
!
! Check for anything but liquid water and dry air:
!
  do j = 1, nl
!
! Prepare the temperature weighted coefficients:
!
    k = Catalog(i)%Lines(j)
    Call Slabs_prep_wder(t,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,   &
   &     Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
   &     Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0s(j),x1(j),y(j),    &
   &     yi(j),slabs1(j),dx1_dv0(j),dy_dv0(j),dslabs1_dv0(j))
!
    tp = t + 10.0
    Call slabs_prep(tp,mass,Lines(k)%V0,Lines(k)%EL,Lines(k)%W,       &
   &     Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
   &     Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sp(j),x1p(j),yp(j), &
   &     yip(j),slabs1p(j),dslabs1)
!
    tm = t - 10.0
    Call slabs_prep(tm,mass,Lines(k)%V0, Lines(k)%EL,Lines(k)%W,      &
   &     Lines(k)%PS, p, Lines(k)%N,Lines(k)%STR,Qlog,Lines(k)%DELTA, &
   &     Lines(k)%GAMMA,Lines(k)%N1,Lines(k)%N2,v0sm(j),x1m(j),ym(j), &
   &     yim(j),slabs1m(j),dslabs1)
!
  end do
!
  End Subroutine Slabs_Prep_Arrays
!
 END SUBROUTINE get_beta_path
d213 3
@


1.16
log
@Implementing l2cf inputs for FilterShape & Spectroscopy instead of FMI
@
text
@d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.15 2001/04/03 07:32:45 zvi Exp $"
a57 1
Real(r8) :: y1(50), y1m(50), y1p(50)
d208 3
@


1.15
log
@Modify the spectral structure - eliminating sps_ from the names
@
text
@a2 1
  use L2PC_PFA_STRUCTURES, only: PFA_SLAB
d8 1
d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.14 2001/03/31 23:40:55 zvi Exp $"
d22 2
a23 2
 SUBROUTINE get_beta_path(frequencies,pfs,no_ele, &
                       &  z_path,t_path,beta_path,vel_z,ier)
d31 2
a32 1
real(r8), dimension(:), intent(in) :: frequencies
d40 1
a40 1
Type (pfa_slab), INTENT(IN) :: pfs(:)
d55 7
a61 2
Real(r8) :: y(size(pfs(1)%V0)), ym(size(pfs(1)%V0)), &
            yp(size(pfs(1)%V0))
d63 1
a63 14
Real(r8) :: x1(size(pfs(1)%V0)), x1m(size(pfs(1)%V0)), &
            x1p(size(pfs(1)%V0))
!
Real(r8) :: y1(size(pfs(1)%V0)), y1m(size(pfs(1)%V0)), &
            y1p(size(pfs(1)%V0))
!
Real(r8) :: yi(size(pfs(1)%V0)), yim(size(pfs(1)%V0)),&
            yip(size(pfs(1)%V0))
!
Real(r8) :: v0s(size(pfs(1)%V0)), v0sm(size(pfs(1)%V0)), &
            v0sp(size(pfs(1)%V0))
!
Real(r8) :: slabs1(size(pfs(1)%V0)), slabs1m(size(pfs(1)%V0)), &
            slabs1p(size(pfs(1)%V0))
a64 5
Real(r8) :: dy_dv0(size(pfs(1)%V0)), dx1_dv0(size(pfs(1)%V0)), &
            dslabs1_dv0(size(pfs(1)%V0))
!
! Begin code:

d66 1
a66 1
  no_sps = pfs(1)%no_sps
d79 1
a79 1
        deallocate ( beta_path(i,frq_i)%values, beta_path(i,frq_i)%t_power, &
d107 1
a107 1
    Spectag = pfs(i)%spectag
d110 2
a111 2
    nl = pfs(i)%NO_LINES
    Qlog(1:3) = pfs(i)%QLOG(1:3)
d133 3
a135 3
        Call Create_beta (Spectag,p,t,Frq,nl,pfs(i),v0s,x1,y,yi,&
       &     slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,x1p,yp,yip, &
       &     slabs1p,v0sm,x1m,ym,yim,slabs1m,values,t_power,    &
d162 1
d164 1
a164 1
     stop
d173 1
a173 1
  Integer(i4) :: j
d184 5
a188 5
    Call Slabs_prep_wder(t,mass,pfs(i)%V0(j),pfs(i)%EL(j),&
   &     pfs(i)%W(j),pfs(i)%PS(j),p,pfs(i)%N(j),      &
   &     pfs(i)%STR(j),Qlog,pfs(i)%DELTA(j),pfs(i)%GAMMA(j),&
   &     pfs(i)%N1(j),pfs(i)%N2(j),v0s(j),x1(j),y(j),yi(j),&
   &     slabs1(j),dx1_dv0(j),dy_dv0(j),dslabs1_dv0(j))
d191 3
a193 4
    Call slabs_prep(tp,mass,pfs(i)%V0(j),pfs(i)%EL(j), &
   &     pfs(i)%W(j),pfs(i)%PS(j),p,pfs(i)%N(j),   &
   &     pfs(i)%STR(j),Qlog,pfs(i)%DELTA(j),pfs(i)%GAMMA(j),&
   &     pfs(i)%N1(j),pfs(i)%N2(j),v0sp(j),x1p(j),yp(j),&
d197 3
a199 4
    Call slabs_prep(tm,mass,pfs(i)%V0(j),pfs(i)%EL(j), &
   &     pfs(i)%W(j),pfs(i)%PS(j),p,pfs(i)%N(j),   &
   &     pfs(i)%STR(j),Qlog,pfs(i)%DELTA(j),pfs(i)%GAMMA(j),&
   &     pfs(i)%N1(j),pfs(i)%N2(j),v0sm(j),x1m(j),ym(j),&
d209 3
@


1.14
log
@Eliminate l2pcdim (dimension parameters) move to allocatable ..
@
text
@d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.13 2001/03/29 08:51:01 zvi Exp $"
d54 2
a55 2
Real(r8) :: y(size(pfs(1)%SPS_V0)), ym(size(pfs(1)%SPS_V0)), &
            yp(size(pfs(1)%SPS_V0))
d57 2
a58 2
Real(r8) :: x1(size(pfs(1)%SPS_V0)), x1m(size(pfs(1)%SPS_V0)), &
            x1p(size(pfs(1)%SPS_V0))
d60 2
a61 2
Real(r8) :: y1(size(pfs(1)%SPS_V0)), y1m(size(pfs(1)%SPS_V0)), &
            y1p(size(pfs(1)%SPS_V0))
d63 2
a64 2
Real(r8) :: yi(size(pfs(1)%SPS_V0)), yim(size(pfs(1)%SPS_V0)),&
            yip(size(pfs(1)%SPS_V0))
d66 2
a67 2
Real(r8) :: v0s(size(pfs(1)%SPS_V0)), v0sm(size(pfs(1)%SPS_V0)), &
            v0sp(size(pfs(1)%SPS_V0))
d69 2
a70 2
Real(r8) :: slabs1(size(pfs(1)%SPS_V0)), slabs1m(size(pfs(1)%SPS_V0)), &
            slabs1p(size(pfs(1)%SPS_V0))
d72 2
a73 2
Real(r8) :: dy_dv0(size(pfs(1)%SPS_V0)), dx1_dv0(size(pfs(1)%SPS_V0)), &
            dslabs1_dv0(size(pfs(1)%SPS_V0))
d119 1
a119 1
    Spectag = pfs(i)%sps_spectag
d123 1
a123 1
    Qlog(1:3) = pfs(i)%SPS_QLOG(1:3)
d195 4
a198 4
    Call Slabs_prep_wder(t,mass,pfs(i)%SPS_V0(j),pfs(i)%SPS_EL(j),&
   &     pfs(i)%SPS_W(j),pfs(i)%SPS_PS(j),p,pfs(i)%SPS_N(j),      &
   &     pfs(i)%SPS_STR(j),Qlog,pfs(i)%SPS_DELTA(j),pfs(i)%SPS_GAMMA(j),&
   &     pfs(i)%SPS_N1(j),pfs(i)%SPS_N2(j),v0s(j),x1(j),y(j),yi(j),&
d202 4
a205 4
    Call slabs_prep(tp,mass,pfs(i)%SPS_V0(j),pfs(i)%SPS_EL(j), &
   &     pfs(i)%SPS_W(j),pfs(i)%SPS_PS(j),p,pfs(i)%SPS_N(j),   &
   &     pfs(i)%SPS_STR(j),Qlog,pfs(i)%SPS_DELTA(j),pfs(i)%SPS_GAMMA(j),&
   &     pfs(i)%SPS_N1(j),pfs(i)%SPS_N2(j),v0sp(j),x1p(j),yp(j),&
d209 4
a212 4
    Call slabs_prep(tm,mass,pfs(i)%SPS_V0(j),pfs(i)%SPS_EL(j), &
   &     pfs(i)%SPS_W(j),pfs(i)%SPS_PS(j),p,pfs(i)%SPS_N(j),   &
   &     pfs(i)%SPS_STR(j),Qlog,pfs(i)%SPS_DELTA(j),pfs(i)%SPS_GAMMA(j),&
   &     pfs(i)%SPS_N1(j),pfs(i)%SPS_N2(j),v0sm(j),x1m(j),ym(j),&
d222 3
@


1.13
log
@Changing the (*) toi (:) everywhere
@
text
@d3 1
a3 1
  use L2PC_PFA_STRUCTURES, only: PFA_SLAB, MAXLINES
d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.12 2001/03/20 23:22:40 zvi Exp $"
d53 22
a74 11

Real(r8) :: v0s(MAXLINES), x1(MAXLINES), y(MAXLINES), yi(MAXLINES), &
            slabs1(MAXLINES), dx1_dv0(MAXLINES), dy_dv0(MAXLINES),  &
            dslabs1_dv0(MAXLINES)

Real(r8) :: v0sp(MAXLINES), x1p(MAXLINES), yp(MAXLINES), yip(MAXLINES), &
            slabs1p(MAXLINES)

Real(r8) :: v0sm(MAXLINES), x1m(MAXLINES), ym(MAXLINES), yim(MAXLINES), &
            slabs1m(MAXLINES)

d197 1
a197 1
   &     pfs(i)%SPS_STR(j),Qlog,pfs(i)%SPS_DELTA(j),pfs(i)%SPS_GAMMA(j),& 
d222 3
@


1.12
log
@Change to new geoc_geod routine..
@
text
@d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.11 2001/03/20 11:03:16 zvi Exp $"
d39 1
a39 1
Type (pfa_slab), INTENT(IN) :: pfs(*)
d211 3
@


1.11
log
@Fixing code for "real" data run, increase dim. etc.
@
text
@d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.10 2001/03/20 02:29:26 livesey Exp $"
d70 2
a71 2
  call output('In get_beta_path_m',advance='yes')
  call dump(frequencies)
d211 3
@


1.10
log
@Interim version, gets same numbers as zvi
@
text
@d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.9 2001/03/15 12:18:03 zvi Exp $"
d69 1
d211 3
@


1.9
log
@Adding the Velocity effect on Line center frequency
@
text
@d7 2
d14 1
a14 1
  "$Id: get_beta_path_m.f90,v 1.8 2001/03/09 02:26:11 vsnyder Exp $"
d22 1
a22 1
 SUBROUTINE get_beta_path(ptg_i,pfs,no_ele,no_ptg_frq,ptg_frq_grid, &
d31 2
a32 2
Integer(i4), INTENT(IN) :: ptg_i, no_ele
Integer(i4), INTENT(IN) :: no_ptg_frq(*)
a36 1
Type(path_vector), INTENT(IN) :: ptg_frq_grid(*)
d68 3
a70 1
  mnf =  no_ptg_frq(ptg_i)
a71 1
! Vel_z_correction = 1.0_r8 - vel_z / c
d90 1
a90 1
    do frq_i = 1, no_ptg_frq(ptg_i)
d98 1
a98 1
        PRINT *,'   no_ele,ptg_i,i,frq_i:',no_ele,ptg_i,i,frq_i
d129 1
a129 1
      do frq_i = 1, no_ptg_frq(ptg_i)
d131 1
a131 1
        Frq = ptg_frq_grid(ptg_i)%values(frq_i)
d156 1
a156 1
       do frq_i = 1, no_ptg_frq(ptg_i)
d163 1
a163 1

d210 3
@


1.8
log
@More work on deallocation
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.7 2001/03/09 02:11:28 vsnyder Exp $"
d21 1
a21 1
                       &  z_path,t_path,beta_path,ier)
d31 1
d46 2
d50 1
a50 1
Real(r8) :: Qlog(3), mass, z, p, t, Frq
d69 3
d83 1
d121 6
d208 3
@


1.7
log
@Repair deallocating
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.6 2001/03/05 21:37:20 zvi Exp $"
d147 1
d195 3
@


1.6
log
@New filter format
@
text
@d11 4
a14 3
  CHARACTER (LEN=256) :: Id = &
  "$Id: get_beta_path_m.f90,v 1.1 2001/02/01 00:08:13 Z.Shippony Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
d68 9
a81 3
      DEALLOCATE(beta_path(i,frq_i)%values,beta_path(i,frq_i)%t_power,&
  &              beta_path(i,frq_i)%dbeta_dw,beta_path(i,frq_i)%dbeta_dn,&
  &              beta_path(i,frq_i)%dbeta_dnu, STAT=h_i)
d194 3
@


1.5
log
@Latest modification: Conv/NoConv
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.4 2001/02/19 22:14:21 zvi Exp $"
d38 1
a38 1
Type(path_beta), INTENT(OUT) :: beta_path(:,:)  ! (sps_i,frq_i)
d44 1
a44 1
Integer(i4) :: nl, i, no_sps, spectag, h_i, frq_i
d63 1
d67 3
d82 2
a83 1
        PRINT *,'   IER =',ier
a186 2
! Revision 1.4  2001/02/19 22:14:21  zvi
!
@


1.4
log
@
Ctest modification Conv/NoConvVS: ----------------------------------------------------------------------
@
text
@d12 1
a12 1
  "$Id: get_beta_path_m.f90,v 1.1 2001/02/01 00:08:13 Z.Shippony Exp $"
d182 2
@


1.3
log
@Changes and additions
@
text
@d19 2
a20 2
 SUBROUTINE get_beta_path(ptg_i,pfa_spectrum,no_ele,no_ptg_frq, &
                     &    ptg_frq_grid,z_path,t_path,beta_path,ier)
d36 1
a36 1
Type (pfa_slab), INTENT(IN) :: PFA_SPECTRUM(*)
d44 1
a44 1
Integer(i4) :: nl, sps_i, no_sps, spectag, h_i, frq_i
d62 1
a62 1
  no_sps = pfa_spectrum(1)%no_sps
d66 1
a66 1
  do sps_i = 1, no_sps
d68 8
a75 11
      DEALLOCATE(beta_path(sps_i,frq_i)%values,      &
  &              beta_path(sps_i,frq_i)%t_power,     &
  &              beta_path(sps_i,frq_i)%dbeta_dw,    &
  &              beta_path(sps_i,frq_i)%dbeta_dn,    &
  &              beta_path(sps_i,frq_i)%dbeta_dnu, STAT = h_i)
      ALLOCATE(beta_path(sps_i,frq_i)%values(no_ele),    &
  &            beta_path(sps_i,frq_i)%t_power(no_ele),   &
  &            beta_path(sps_i,frq_i)%dbeta_dw(no_ele),  &
  &            beta_path(sps_i,frq_i)%dbeta_dn(no_ele),  &
  &            beta_path(sps_i,frq_i)%dbeta_dnu(no_ele), &
  &            STAT = ier)
d84 1
a84 1
  DO sps_i = 1, no_sps
d86 1
a86 1
    Spectag = pfa_spectrum(sps_i)%sps_spectag
d89 2
a90 2
    nl = pfa_spectrum(sps_i)%NO_LINES
    Qlog(1:3) = pfa_spectrum(sps_i)%SPS_QLOG(1:3)
d106 4
a109 4
        Call Create_beta (Spectag,p,t,Frq,nl,pfa_spectrum(sps_i), &
       &     v0s,x1,y,yi,slabs1,dx1_dv0,dy_dv0,dslabs1_dv0,v0sp,  &
       &     x1p,yp,yip,slabs1p,v0sm,x1m,ym,yim,slabs1m,values,   &
       &     t_power,dbeta_dw,dbeta_dn,dbeta_dnu,Ier)
d112 5
a116 5
        beta_path(sps_i,frq_i)%values(h_i) = values
        beta_path(sps_i,frq_i)%t_power(h_i) = t_power
        beta_path(sps_i,frq_i)%dbeta_dw(h_i) = dbeta_dw
        beta_path(sps_i,frq_i)%dbeta_dn(h_i) = dbeta_dn
        beta_path(sps_i,frq_i)%dbeta_dnu(h_i) = dbeta_dnu
d122 1
a122 1
  END DO              ! On sps_i
d128 1
a128 1
 99  do sps_i = 1, no_sps
d130 3
a132 5
         DEALLOCATE(beta_path(sps_i,frq_i)%values,   &
        &           beta_path(sps_i,frq_i)%t_power,  &
        &           beta_path(sps_i,frq_i)%dbeta_dw, &
        &           beta_path(sps_i,frq_i)%dbeta_dn, &
        &           beta_path(sps_i,frq_i)%dbeta_dnu, STAT = h_i)
d145 1
a145 1
  Real(r8) :: v0,el,log_i,w,ps,n,n1,n2,gamma,delta,dslabs1,tp,tm
a152 11
    n = pfa_spectrum(sps_i)%SPS_N(j)
    w = pfa_spectrum(sps_i)%SPS_W(j)
    v0 = pfa_spectrum(sps_i)%SPS_V0(j)
    el = pfa_spectrum(sps_i)%SPS_EL(j)
    ps = pfa_spectrum(sps_i)%SPS_PS(j)
    n1 = pfa_spectrum(sps_i)%SPS_N1(j)
    n2 = pfa_spectrum(sps_i)%SPS_N2(j)
    log_i = pfa_spectrum(sps_i)%SPS_STR(j)
    gamma = pfa_spectrum(sps_i)%SPS_GAMMA(j)
    delta = pfa_spectrum(sps_i)%SPS_DELTA(j)
!
d155 5
a159 3
    Call Slabs_prep_wder(t,mass,v0,el,w,ps,p,n,log_i,Qlog,delta, &
   &           gamma,n1,n2,v0s(j),x1(j),y(j),yi(j),slabs1(j),&
   &           dx1_dv0(j),dy_dv0(j),dslabs1_dv0(j))
d162 5
a166 2
    Call slabs_prep(tp,mass,v0,el,w,ps,p,n,log_i,Qlog,delta,gamma, &
   &           n1,n2,v0sp(j),x1p(j),yp(j),yip(j),slabs1p(j),dslabs1)
d169 5
a173 2
    Call slabs_prep(tm,mass,v0,el,w,ps,p,n,log_i,Qlog,delta,gamma, &
   &           n1,n2,v0sm(j),x1m(j),ym(j),yim(j),slabs1m(j),dslabs1)
@


1.2
log
@New version of forward model
@
text
@d3 3
a5 2
  use EOS_MDB, only: EOS_MDB_HDR, EOS_MDB_REC
  use PATH_ENTITIES_M, only: PATH_VECTOR
d7 1
a7 1
  implicit NONE
d12 1
a12 1
    "$Id: get_beta_path_m.f90,v 1.1 2000/06/21 21:56:10 zvi Exp $"
d14 1
a14 1
    "$RCSfile: get_beta_path_m.f90,v $"
d17 1
d19 2
a20 3
  Subroutine get_beta_path (Spectag, Freq, no_ele, z_path, t_path, &
                            mdb_hdr, mdb_rec, values, t_power, dbeta_dw, &
                            dbeta_dn, dbeta_dnu, Ier)
d22 72
a93 1
    integer(i4), intent(in) :: SPECTAG, no_ele
d95 31
a125 1
    real(r8), intent(in) :: Freq
d127 13
a139 1
    Type(path_vector), intent(in) :: z_path, t_path
d141 1
a141 2
    Type (eos_mdb_hdr), intent(in) :: MDB_HDR
    Type (eos_mdb_rec), intent(in) :: MDB_REC(*)
d143 8
a150 3
    integer(i4), intent(out) :: Ier
    real(r8), intent(out) :: values(*), t_power(*), dbeta_dw(*), &
                             dbeta_dn(*), dbeta_dnu(*)
d152 18
a169 2

! -----     Local variables     ----------------------------------------
d171 3
a173 4
    Integer(i4) :: h_i
    Real(r8) :: pn, pnu, pw, q, t, t_p, z

! -----     Executable statements     ----------------------------------
d175 3
d179 3
a181 19
    values(:no_ele) = 0.0
    t_power(:no_ele) = 0.0
    dbeta_dw(:no_ele) = 0.0
    dbeta_dn(:no_ele) = 0.0
    dbeta_dnu(:no_ele) = 0.0

    do h_i = 1, no_ele
      z = z_path%values(h_i)
      if(z <= -4.5) CYCLE
      t = t_path%values(h_i)
      Call Create_beta(Spectag, z, t, Freq, mdb_hdr, mdb_rec, &
   &                   q, t_p, pw, pn, pnu, Ier)
      if(Ier /= 0) Return
      values(h_i) = q
      t_power(h_i) = t_p
      dbeta_dw(h_i) = pw
      dbeta_dn(h_i) = pn
      dbeta_dnu(h_i) = pnu
    end do
d183 1
a183 1
    Return
d185 1
a185 1
  end subroutine get_beta_path
d187 1
d190 1
a190 4
! Revision 1.1  2000/06/21 21:56:10  zvi
! First version D.P.
!
! Revision 1.1  2000/05/04 18:12:04  vsnyder
@


1.1
log
@New version
@
text
@d19 1
a19 1
                            dbeta_dn, dbeta_dnu)
d27 1
a27 1
    Type (eos_mdb_hdr), intent(in) :: MDB_HDR(*)
d30 1
d54 2
a55 1
   &                   q, t_p, pw, pn, pnu)
a73 1
!
@

