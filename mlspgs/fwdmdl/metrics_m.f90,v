head	2.92;
access;
symbols
	v5-02-NRT-19:2.92
	v6-00:2.92
	v5-02-NRT-18:2.92
	v5-02:2.91
	v5-01-NRT-17:2.92
	v5-01-NRT-16:2.92
	v5-01-NRT-15:2.91
	v5-01-NRT-14:2.91
	neuralnetworks-1-0:2.91.0.6
	cfm-single-freq-0-1:2.91.0.4
	v5-01:2.91
	v5-00:2.91
	v4-23-TA133:2.91.0.2
	mus-emls-1-70:2.89.0.2
	rel-1-0-englocks-work:2.86.0.2
	VUMLS1-00:2.79
	VPL1-00:2.76
	V4-22-NRT-08:2.75
	VAM1-00:2.75
	V4-21:2.73.0.2
	V4-13:2.73
	V4-12:2.73
	V4-11:2.73
	V4-10:2.73
	V3-43:2.67
	M4-00:2.70
	V3-41:2.67
	V3-40-PlusGM57:2.67.0.2
	V2-24-NRT-04:2.56
	V3-33:2.67
	V2-24:2.56
	V3-31:2.67
	V3-30-NRT-05:2.67
	cfm-01-00:2.67
	V3-30:2.67
	V3-20:2.67
	V3-10:2.62
	V2-23-NRT-02:2.56
	V2-23:2.56
	V2-22-NRT-01:2.56
	V2-22:2.56
	V2-21:2.32
	V2-20:2.32
	V2-11:2.29
	V2-10:2.29
	V2-00:2.28
	V1-51:2.22
	V1-50:2.22
	V1-45:2.21
	V1-44:2.21
	V1-43:2.21
	V1-32:2.20
	V1-31:2.20
	V1-30:2.19
	V1-13:2.16
	V1-12:2.16
	V1-11:2.16
	V1-10:2.16
	newfwm-feb03:2.16.0.2
	V1-04:2.4
	V1-03:2.4
	V1-02:2.4
	JointForwardModel:2.6.0.2
	V1-00:2.4
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.92
date	2022.01.05.00.28.26;	author pwagner;	state Exp;
branches;
next	2.91;

2.91
date	2018.08.28.22.15.35;	author vsnyder;	state Exp;
branches;
next	2.90;

2.90
date	2018.08.15.01.15.47;	author vsnyder;	state Exp;
branches;
next	2.89;

2.89
date	2018.05.24.03.24.09;	author vsnyder;	state Exp;
branches;
next	2.88;

2.88
date	2018.05.17.02.15.45;	author vsnyder;	state Exp;
branches;
next	2.87;

2.87
date	2018.05.14.23.37.35;	author vsnyder;	state Exp;
branches;
next	2.86;

2.86
date	2017.09.20.01.16.22;	author vsnyder;	state Exp;
branches;
next	2.85;

2.85
date	2017.09.14.19.42.24;	author vsnyder;	state Exp;
branches;
next	2.84;

2.84
date	2017.09.13.19.39.24;	author vsnyder;	state Exp;
branches;
next	2.83;

2.83
date	2017.09.08.16.44.33;	author pwagner;	state Exp;
branches;
next	2.82;

2.82
date	2017.08.28.20.28.08;	author livesey;	state Exp;
branches;
next	2.81;

2.81
date	2017.07.26.20.05.22;	author vsnyder;	state Exp;
branches;
next	2.80;

2.80
date	2017.03.11.00.56.05;	author vsnyder;	state Exp;
branches;
next	2.79;

2.79
date	2016.11.17.02.06.12;	author vsnyder;	state Exp;
branches;
next	2.78;

2.78
date	2016.11.17.01.39.45;	author vsnyder;	state Exp;
branches;
next	2.77;

2.77
date	2016.10.18.00.25.37;	author vsnyder;	state Exp;
branches;
next	2.76;

2.76
date	2016.08.20.00.55.08;	author vsnyder;	state Exp;
branches;
next	2.75;

2.75
date	2015.09.22.01.59.32;	author vsnyder;	state Exp;
branches;
next	2.74;

2.74
date	2015.05.28.23.14.42;	author vsnyder;	state Exp;
branches;
next	2.73;

2.73
date	2013.06.12.02.32.30;	author vsnyder;	state Exp;
branches;
next	2.72;

2.72
date	2013.05.21.23.55.14;	author vsnyder;	state Exp;
branches;
next	2.71;

2.71
date	2013.05.18.00.34.44;	author vsnyder;	state Exp;
branches;
next	2.70;

2.70
date	2013.03.30.00.06.11;	author vsnyder;	state Exp;
branches;
next	2.69;

2.69
date	2013.02.28.21.08.29;	author vsnyder;	state Exp;
branches;
next	2.68;

2.68
date	2011.05.09.18.02.19;	author pwagner;	state Exp;
branches;
next	2.67;

2.67
date	2010.02.04.23.10.20;	author vsnyder;	state Exp;
branches;
next	2.66;

2.66
date	2010.02.02.01.34.55;	author vsnyder;	state Exp;
branches;
next	2.65;

2.65
date	2009.12.15.03.20.06;	author vsnyder;	state Exp;
branches;
next	2.64;

2.64
date	2009.12.09.21.32.03;	author vsnyder;	state Exp;
branches;
next	2.63;

2.63
date	2009.08.20.23.30.56;	author vsnyder;	state Exp;
branches;
next	2.62;

2.62
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.61;

2.61
date	2009.06.16.17.37.26;	author pwagner;	state Exp;
branches;
next	2.60;

2.60
date	2009.06.13.01.14.29;	author vsnyder;	state Exp;
branches;
next	2.59;

2.59
date	2008.06.26.00.28.16;	author vsnyder;	state Exp;
branches;
next	2.58;

2.58
date	2008.05.20.00.16.40;	author vsnyder;	state Exp;
branches;
next	2.57;

2.57
date	2007.11.08.01.49.39;	author vsnyder;	state Exp;
branches;
next	2.56;

2.56
date	2007.10.19.23.28.30;	author vsnyder;	state Exp;
branches;
next	2.55;

2.55
date	2007.10.11.20.17.35;	author vsnyder;	state Exp;
branches;
next	2.54;

2.54
date	2007.10.03.20.54.10;	author vsnyder;	state Exp;
branches;
next	2.53;

2.53
date	2007.09.07.01.37.23;	author vsnyder;	state Exp;
branches;
next	2.52;

2.52
date	2007.08.23.20.41.07;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2007.07.31.23.48.57;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2007.06.29.19.34.40;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2007.06.26.00.35.39;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2007.06.08.22.05.48;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2007.03.22.23.24.34;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2007.02.06.23.50.59;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2007.02.06.21.09.29;	author vsnyder;	state Exp;
branches;
next	2.44;

2.44
date	2007.02.01.02.53.15;	author vsnyder;	state Exp;
branches;
next	2.43;

2.43
date	2007.01.20.01.07.49;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2007.01.19.02.38.53;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2007.01.18.00.26.32;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2006.12.21.22.59.17;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2006.12.20.21.22.16;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2006.12.19.02.50.35;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2006.12.13.02.31.35;	author vsnyder;	state Exp;
branches;
next	2.36;

2.36
date	2006.12.09.02.25.42;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2006.12.08.23.57.08;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2006.12.08.22.50.55;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2006.11.29.01.05.13;	author vsnyder;	state Exp;
branches;
next	2.32;

2.32
date	2006.09.28.19.00.22;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2006.08.25.19.39.20;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2006.08.25.19.37.07;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2006.06.29.19.34.17;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2006.03.06.20.44.48;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2006.01.26.03.06.17;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2006.01.05.00.03.52;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2005.12.10.03.31.09;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2005.12.10.01.53.23;	author vsnyder;	state Exp;
branches;
next	2.23;

2.23
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.22;

2.22
date	2004.09.01.01.47.56;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2004.01.23.18.44.57;	author bill;	state Exp;
branches;
next	2.20;

2.20
date	2003.11.14.21.22.46;	author livesey;	state Exp;
branches;
next	2.19;

2.19
date	2003.06.27.23.43.34;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2003.06.20.23.41.48;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2003.05.22.20.12.32;	author vsnyder;	state Exp;
branches;
next	2.16;

2.16
date	2002.10.25.22.24.08;	author livesey;	state Exp;
branches;
next	2.15;

2.15
date	2002.10.08.17.08.05;	author pwagner;	state Exp;
branches;
next	2.14;

2.14
date	2002.10.08.14.42.57;	author bill;	state Exp;
branches;
next	2.13;

2.13
date	2002.10.01.02.27.49;	author vsnyder;	state Exp;
branches;
next	2.12;

2.12
date	2002.09.26.20.14.24;	author vsnyder;	state Exp;
branches;
next	2.11;

2.11
date	2002.09.25.23.35.13;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2002.09.06.18.16.41;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2002.08.10.00.13.33;	author livesey;	state Exp;
branches;
next	2.8;

2.8
date	2002.08.10.00.08.47;	author bill;	state Exp;
branches;
next	2.7;

2.7
date	2002.07.05.07.52.50;	author zvi;	state Exp;
branches;
next	2.6;

2.6
date	2002.06.19.11.00.35;	author zvi;	state Exp;
branches;
next	2.5;

2.5
date	2002.06.07.04.50.47;	author bill;	state Exp;
branches;
next	2.4;

2.4
date	2002.02.08.00.48.09;	author zvi;	state Exp;
branches;
next	2.3;

2.3
date	2002.02.07.18.50.47;	author bill;	state Exp;
branches;
next	2.2;

2.2
date	2002.01.30.01.11.21;	author zvi;	state Exp;
branches;
next	2.1;

2.1
date	2001.11.20.01.19.30;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.10.09.37;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.10.10.09.37;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.12.21.30.04;	author livesey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.12.21.36.51;	author livesey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.09.12.21.47.50;	author livesey;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.09.12.22.04.07;	author livesey;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.09.12.22.45.54;	author livesey;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2001.09.13.00.42.18;	author livesey;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2001.09.13.01.26.53;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.92
log
@Prevents crashing when compiled with NAG and run on OL8
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Metrics_m

  use Constants, only: Rad2Deg
  use MLSKinds, only: RP

  implicit NONE
  private
  public :: Height_Metrics, More_Metrics, Solve_H_Phi, Tangent_Metrics
  public :: More_Points

  ! Values for Stat argument to/from Solve_H_Phi:
  integer, parameter, public :: No_sol = 0  ! No solution
  integer, parameter, public :: NaN_sol = 1 ! No solution -- NaN
  integer, parameter, public :: Order = 2   ! No solution -- Phi out of order
  integer, parameter, public :: Complex = 3 ! Complex start for Newton iteration
                                            ! Good, Grid1, Grid2 must be last three
  integer, parameter, public :: Good = 4    ! Newton converged, tangent point, extrapolated
                                            ! Grid1 and Grid2 have to be the last two
  integer, parameter, public :: Grid1 = 5   ! Close to left grid point
  integer, parameter, public :: Grid2 = 6   ! Close to right grid point
  character(5), parameter :: nStat(no_sol:grid2) = &
    & (/ 'none ', 'NaN  ', 'order', 'cmplx', 'good ', 'grid1', 'grid2' /)

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: metrics_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

  ! Private stuff
  real(rp), parameter :: DefaultTol = 0.001_rp ! km, for Solve_h_phi
  ! To control debugging
  logical, parameter :: Bin42 = .false. ! Write inputs on unit 42 if failure
  logical, parameter :: Debug = .false.
  logical, parameter :: NewtonDetails = .true. .and. debug
  logical, parameter :: ComplexDebug = .true. .and. debug
  ! For debugging output format:
  ! logical, parameter :: Clean = .false.
  character(len=4), parameter :: Options=' '
  real, parameter :: Ang = rad2deg ! degrees
! real, parameter :: Ang = 1.0     ! .not. degrees
  character(*), parameter :: Fmt = '( i4,i2,i4,f12.5,f10.3,a )'

contains

  ! --------------------------------------------  Tangent_Metrics  -----
                               ! Inputs
  subroutine Tangent_Metrics ( Phi_T, P_Basis, H_Ref, Tan_Ind_F, &
                               ! Outputs
    &                          H_Surf, H_Tan, &
                               ! Optional inputs
    &                          Z_Ref, Tan_press, Surf_temp, Surf_height )

  ! Compute the surface height and the tangent height at Phi_T.

    use MLSKinds, only: RP
    use Sparse_Eta_m, only: Sparse_Eta_t

    ! inputs:

    real(rp), intent(in) :: Phi_t      ! orbit projected tangent geodetic angle,
                                       ! radians
    real(rp), intent(in) :: P_basis(:) ! horizontal temperature representation
                                       ! basis, radians
    real(rp), intent(in) :: H_ref(:,:) ! heights by fine zeta and p_basis,
                                       ! referenced to equivalent circular earth
                                       ! center, km
    integer, intent(in) :: Tan_ind_f   ! Index of tangent in H_Ref, which is on
                                       ! fine Zeta grid

    ! outputs:
    real(rp), intent(out) :: H_Surf    ! Height of the pressure reference
                                       ! surface at Phi_t -- interpolated in
                                       ! Surf_Height if present(Surf_Height)
                                       ! else interpolated in row 1 of H_REF,
                                       ! referenced to equivalent circular earth
                                       ! center, km
    real(rp), intent(out) :: H_Tan     ! Tangent height above H_Surf (negative
    !                                  ! for Earth-intersecting rays),
                                       ! referenced to equivalent circular earth
                                       ! center, km

    ! optional inputs
    ! We have Z_Ref, Tan_Press and Surf_Temp if the pointing is below the
    ! surface index (where zeta Z_Ref) and we don't have Surf_Height.
    ! Otherwise we have Surf_Height.
    real(rp), optional, intent(in) :: Z_Ref        ! Zeta corresponding to H_Ref(1,:)
    real(rp), optional, intent(in) :: Tan_press    ! Tangent pressure
    real(rp), optional, intent(in) :: Surf_temp(:) ! Surface temperature at p_basis
    real(rp), optional, intent(in) :: Surf_height(:) ! Surface height in km
                                       ! above mean sea level (whatever that
                                       ! means) on P_Basis.

    type(sparse_eta_t) :: ETA_T        ! Interpolating coefficients

    ! Get interpolating coefficients (eta_t) from p_basis to phi_t
    call eta_t%eta ( p_basis, phi_t )

    if ( present(surf_height) ) then
      ! We set the surface reference at the actual surface height if we
      ! have it, and adjust r_eq and h_tan relative to this, and adjust
      ! h_ref accordingly.
      h_surf = eta_t%row_dot_vec ( 1, surf_height )
    else
      ! If we don't have the actual surface height, we set the surface
      ! reference at the input z_ref and adjust r_eq and h_tan relative
      ! to this, and adjust h_ref accordingly.
      h_surf = eta_t%row_dot_vec ( 1, h_ref(1,:) )
    end if

    ! compute the tangent height above H_surf.
    if ( present(tan_press) .and. present(surf_temp) .and. &
      &  .not. present(surf_height) ) then
      ! Earth intersecting ray. Compute GP height (km) of tangent pressure
      ! below surface. This will be negative because tan_press < z_ref.
      ! present(tan_press) requires present(surf_temp).  We don't need to
      ! subtract h_surf here because this gives km from the z_ref surface.
      h_tan = eta_t%row_dot_vec ( 1, surf_temp ) * (tan_press-z_ref)/14.8
    else
      h_tan = eta_t%row_dot_vec ( 1, h_ref(tan_ind_f,:) ) - h_surf
    end if

  end subroutine Tangent_Metrics

  ! ---------------------------------------------  Height_Metrics  -----

                            ! Inputs:
  subroutine Height_Metrics (  phi_t, tan_ind, p_basis, h_ref, h_surf, &
                            &  tan_ht_s, z_ref, r_eq,                  &
                            ! Outputs:
                            &  req_s, vert_inds, h_path, p_path,       &
                            ! Optional inputs:
                            &  h_tol, forward )

    !{ This subroutine computes {\tt h\_path} and {\tt p\_path} that define
    !  a 2-d integration path.  These points are at the intersections of the
    !  line of sight given by $H = H_\text{tan} \sec \phi$ and the heights of
    !  surfaces of constant $\zeta$ represented in piecewise linear segments
    !  by consecutive elements of each row of {\tt H\_ref}.

    ! If the ray is an Earth-intersecting ray it is assumed to reflect from
    ! the pressure reference surface, not the geometric Earth surface.

    use Constants, only: Pi, Rad2Deg
    use Dump_0, only: Dump
    use GLNP, only: NG, NGP1
    use IEEE_Arithmetic, only: IEEE_Is_NaN
    use MLSKinds, only: RP
    use MLSMessageModule, only: MLSMessage, MLSMsg_Error, MLSMsg_Warning
    use MLSStringLists, only: SwitchDetail
    use Output_M, only: Output
    use Sparse_Eta_m, only: Sparse_Eta_t
    use Toggles, only: Switches

    ! inputs:

    real(rp), intent(in) :: Phi_t      ! Orbit projected tangent geodetic angle
    integer, intent(in) :: Tan_ind     ! Tangent height index, 1 = center of
                                       ! longest path
    real(rp), intent(in) :: P_basis(:) ! Horizontal temperature representation
                                       ! basis, radians
    real(rp), intent(in) :: H_ref(:,:) ! Geodetic heights (above R_Eq) by z_ref
                                       ! and p_basis, km
    real(rp), intent(in) :: H_Surf     ! Height of the pressure reference
                                       ! surface z_ref(1) above R_eq at phi_t, km
    real(rp), intent(in) :: Tan_Ht_s   ! Tangent height above H_Surf -- negative
                                       ! for Earth-intersecting ray, km
    real(rp), intent(in) :: Z_ref(:)   ! -log pressures (zetas) for which
                                       ! heights/temps are needed.  Only used
                                       ! where H/Phi iteration fails.
    real(rp), intent(in) :: R_Eq       ! Equivalent circular earth radius of
                                       ! true surface at Phi_T, km

    ! outputs:
    real(rp), intent(out) :: Req_s     ! H_Surf + R_Eq, Equivalent circular
                                       ! earth radius of pressure reference
                                       ! surface at Phi_T, km
    integer, intent(out) :: Vert_Inds(:) ! What to use in h_ref, 1:n_path
    real(rp), intent(out) :: H_Path(:) ! computed path heights, referenced to
                                       ! equivalent circular Earth center, km
    real(rp), intent(out) :: P_Path(:) ! computed path phi's, radians

    ! optional inputs
    real(rp), optional, intent(in) :: H_Tol ! Height tolerance in kilometers
                                       ! for convergence of phi/h iteration
    logical, optional, intent(in) :: Forward  ! for subsurface rays, indicates
                                       ! xi >= xi_sub (see Generate_TScat in
                                       ! FullForwardModel)

    ! Local variables.
    integer :: Do_Dumps    ! <0 = no dump, >=0 = dump, >0 = stop
    integer :: H_Phi_Dump  ! <0 = no dump, >=0 = dump, >0 = stop
    integer :: I, I1, I2, IBAD, J, K
    logical :: MyForward   ! Default .true., else Forward if it's present
    integer :: No_Bad_Fits
    integer :: No_Grid_Fits
    integer :: N_Path      ! Path length = 2*(n_vert+ngp1-tan_ind)
    integer :: N_Tan       ! Tangent index in path, (N_Path - ngp1 + 1)/2
    integer :: N_Vert      ! Size(H_ref,1)
    integer :: P_Coeffs    ! Size(P_basis)

    integer :: Stat(size(vert_inds))

    logical :: Outside     ! Solve_H_Phi converged outside the allowed area
    real(rp) :: A, B, C    ! Polynomial coefficients used to solve for phi and H
    real(rp) :: DP         ! p_basis(j+1) - p_basis(j)
    real(rp) :: DPJ0       ! p_basis(j  )-phi_t
    real(rp) :: DPJ1       ! p_basis(j+1)-phi_t
    real(rp) :: H          ! Tentative solution for H
    real(rp) :: My_H_Tol   ! Tolerance in kilometers for height convergence
    real(rp) :: P          ! Tentative solution for phi
    real(rp) :: Start      ! Starting phi for Newton iteration if > -0.5*huge(0.0_rp)
    real(rp) :: Tan_Ht     ! tan_ht_s + Req_s
    real(rp) :: Theta      ! 2.0_rp*Acos(tan_ht/req_s), angle between incident
                           ! and reflected ray for subsurface tangent height

    type(sparse_eta_t) :: ETA_T        ! Interpolating coefficients
    real(rp) :: Phi_Offset(size(vert_inds)) ! Orbit projected tangent geodetic
                           ! angle if the ray is not an earth intersecting
                           ! ray.  Otherwise the orbit projected tangent
                           ! geodetic angle of the ray between the instrument
                           ! and the intersection point, then the orbit projected
                           ! tangent geodetic angle of the reflected ray.

    real(rp) :: Phi_Sign(size(vert_inds))   ! +/- 1.0

    real(rp), parameter :: Pix2 = 2.0*pi

    ! For debugging
    logical, parameter :: TestStat = .false. ! Test whether any stat < good

!   It would be nice to do this the first time only, but the
!   retrieve command in the L2CF can now change switches
!   if ( do_dumps < 0 ) then ! First time only
      do_dumps = switchDetail(switches,'metd')
      h_phi_dump = switchDetail(switches,'hphi')
!   end if

    n_path = size(vert_inds)
    n_tan = (n_path - ng ) / 2
    n_vert = size(h_ref,1)

    my_h_tol = defaultTol ! kilometers
    if ( present(h_tol) ) my_h_tol = h_tol ! H_Tol is in kilometers
    p_coeffs = size(p_basis)

    ! Compute equivalent earth radius req_s at phi_t of the pressure
    ! reference surface interpolated to phi_t

    req_s = r_eq + h_surf            ! Radius of z_grid(1) surface at phi_t
    tan_ht = tan_ht_s + req_s           ! From equivalent earth center

    stat = no_sol ! No solutions
    ! The tangent points and the zero-thickness layer between them are special
    stat(n_tan:n_tan+ngp1) = good

    ! p_basis and p_path are phi's in offset radians relative to
    ! phi_t, that is, the phi_t, p_basis or p_path = 0.0 is phi_t.
    ! The phi basis is wholly independent of phi_t

    if ( tan_ht_s < 0.0 ) then ! Earth-intersecting ray
      myForward = .true.
      if ( present(forward) ) myForward = forward
      theta = 2.0_rp*Acos(tan_ht/req_s)
      ! Shouldn't need ever to look at phi_offset(n_tan+1:n_tan+ng)
      if ( myForward ) then
        phi_offset(1:n_tan) = phi_t + theta
        phi_offset(n_tan+1:) = phi_t
      else
        phi_offset(:n_tan+ng) = phi_t
        phi_offset(n_tan+ngp1:) = phi_t - theta
      end if
      ! This expression for p_path puts the midpoint of the path at the
      ! reflection point.
      p_path(n_tan:n_tan+ngp1) = 0.5 * ( phi_offset(n_tan) + phi_offset(n_tan+ngp1) )
      h_path(n_tan:n_tan+ngp1) = req_s
    else
      phi_offset = phi_t
      p_path(n_tan:n_tan+ngp1) = phi_offset(n_tan:n_tan+ngp1)
      h_path(n_tan:n_tan+ngp1) = tan_ht
    end if

    ! Only use the parts of the reference grids that are germane to the
    ! present path

    vert_inds = (/ (i, i=n_vert,tan_ind,-1), (tan_ind, i=1,ng), &
                &  (i, i=tan_ind,n_vert) /)

    ! sign of phi vector
    phi_sign = (/ (-1.0_rp, i=n_vert,tan_ind,-1), (1.0_rp, i=1,ng), &
               &  (+1.0_rp, i=tan_ind,n_vert) /)

    if ( h_phi_dump >= 0 ) call dumpInput ( tan_ind )

      if ( debug ) &
        & print '(a)', &
        & '   I J   K     offset   TAN_HT   HREF(K,J) HREF(K,J+1)    A        B    phi sign    C&
        &            D(K,J)        D(K,J+1)   STAT', &
        & '      P          phi    H_PATH   HREF(K,J) HREF(K,J+1)  H(TRIG)    D           N   Diffs'

    no_bad_fits = n_path - ngp1 - 1 ! Exclude coarse tangent points and fine
                                    ! points between them
    no_grid_fits = 0

    ! Get solutions outside of p_basis, if any, assuming constant H
    ! outside of p_basis.  Skip the points, if any, in the zero-thickness
    ! tangent layer.
    do i1 = 1, n_path
      if ( stat(i1) == good ) cycle ! Skip the tangent points
      k = vert_inds(i1)
      h = max(tan_ht,h_ref(k,1)+r_eq) ! or h_ref(k,1) - h_surf + req_s
      p = acos(tan_ht/h) * phi_sign(i1) + phi_offset(i1)
      if ( p >= p_basis(1) ) exit     ! phi is monotone
      p_path(i1) = p
      h_path(i1) = h
      no_bad_fits = no_bad_fits - 1
      stat(i1) = good
        if ( debug ) &
          & print fmt, i1, 0, k, ang*p_path(i1), h_path(i1), '  Below p_basis'

    end do
    do i2 = n_path, 1, -1
      if ( stat(i2) == good ) cycle ! Skip the tangent points
      k = vert_inds(i2)
      h = max(tan_ht,h_ref(k,p_coeffs)+r_eq)
      p = acos(tan_ht/h) * phi_sign(i2) + phi_offset(i2)
      if ( p <= p_basis(p_coeffs) ) exit  ! phi is monotone
      p_path(i2) = p
      h_path(i2) = h
      no_bad_fits = no_bad_fits - 1
      stat(i2) = good
        if ( debug ) &
          & print fmt, i2, p_coeffs, k, ang*p_path(i2), h_path(i2), '  Above p_basis'
    end do
      if ( debug ) then
        print fmt, ( n_tan+j, 0, vert_inds(n_tan+j), ang*p_path(n_tan+j), &
                   & h_path(n_tan+j), '  Tangent point', j = 0, ngp1 )
      end if

    !{ Let $H_{ij}$ denote an element of {\tt H\_ref}.  Remember that all
    ! heights are referenced from $R^\oplus_{\text{eq}}$.  Calculate the
    ! heights by solving for the intersections of the line of sight ($H =
    ! H_{\text{tan}} \sec \phi)$ with constant-$\zeta$ surfaces, piecewise
    ! linear segments of which are represented by two consecutive columns in
    ! each row of {\tt H\_ref}.  See wvs-048.
    !
    ! Extrapolated solutions are not accepted.

    ibad = i2 ! Index of row of first failure in a column
phi:do j = 1, p_coeffs-1
      dp = p_basis(j+1)-p_basis(j)
      a = dp * tan_ht ! Tan_Ht is height from equivalent Earth center
path: do i = i1, i2
        if ( stat(i) == good ) cycle  ! probably the tangent point
!        Don't do this; it causes trouble:
!        if ( stat(i) == grid1 ) cycle ! can't possibly be in this column
        k = vert_inds(i)
        dpj1 = p_basis(j+1)-phi_offset(i)
        dpj0 = p_basis(j)-phi_offset(i)
        b = -(h_ref(k,j+1) - h_ref(k,j)) ! h_surf cancels here
        c = -(h_ref(k,j)-h_surf)   * dpj1 &
          & +(h_ref(k,j+1)-h_surf) * dpj0 &
          & + dp * tan_ht_s ! tan_ht_s is height above H_surf
          if ( newtonDetails ) &
            & print 120, i, j, k, ang*phi_offset(i), tan_ht, &
            & h_ref(k,j)+r_eq, h_ref(k,j+1)+r_eq, &
            & a, b, int(phi_sign(i)), c, &
            & a*(1.0/cos(p_basis(j:j+1)-phi_offset(i))-1.0)+ &
            &         b*(p_basis(j:j+1)-phi_offset(i))+c, &
            & trim(nstat(stat(i)))
          120 format ( i4, i2, i4, f12.5, 2f10.3,f11.3, f10.5, 1p,g14.6, &
            & i3, 3g14.6, 1x, a )
        if ( stat(i) >= grid1 ) then
          no_grid_fits = no_grid_fits - 1
          no_bad_fits = no_bad_fits + 1
        end if
        start = -0.5*huge(0.0_rp)
        if ( i > 1 .and. i < n_path ) then
          if ( stat(i) == complex .and. stat(i-1) == good .and. stat(i+1) == good) then
            ! Complex starting point last time.  Start halfway between two good ones.
            start = 0.5 * ( p_path(i-1) + p_path(i+1) ) ! Solve_H_Phi subtracts phi_offset
            if ( newtonDetails ) &
              print '(2(a,i0),2(a,3f11.5),2(a,f11.5))', 'Phi(',i-1,':',i+1,')', &
                & p_path(i-1:i+1), ' =', p_path(i-1:i+1)*rad2deg, &
                & ' Starting phi ', start, ' = ', start*rad2deg
          end if
        end if
        call Solve_H_Phi ( p_basis(j:j+1), phi_offset(i), phi_sign(i), &
          &                h_ref(k,j:j+1), a, b, c, &
          &                tan_ht, r_eq, my_h_tol, i /= i2 .or. j /= p_coeffs-1, &
          &                start, h_path(i), p_path(i), stat(i), outside )
        if ( IEEE_Is_NaN(p_path(i)) ) then
          stat(i) = NaN_sol
          ! print *, 'i ', i, '  stat(i) ', stat(i)
        endif
        ! Test for phi out of order.
        if ( i > 1 .and. stat(i) >= good ) then
          ! print *, '- ', p_path(i), p_path(i-1), stat(i-1)
          if ( p_path(i) < p_path(i-1) .and. stat(i-1) >= good ) then
            stat(i) = order ! Phi out of order, can't be right
          end if
        end if
        if ( i < n_path .and. stat(i) >= good ) then
          ! print *, '+ ', p_path(i), p_path(i+1), stat(i+1)
          if ( any( stat(i+1) == (/ No_sol, NaN_sol /) ) )  then
            ! NAG now crashes under Oracle Linux 8 when this is the case
            stat(i+1) = NaN_sol
          elseif ( p_path(i) > p_path(i+1) .and. stat(i+1) >= good ) then
            stat(i) = order ! Phi out of order, can't be right
          end if
        end if
        if ( stat(i) >= good ) then ! still good (good < grid1 < grid2)
          no_bad_fits = no_bad_fits - 1
          if ( stat(i) >= grid1 ) no_grid_fits = no_grid_fits + 1
        end if
        if ( outside ) then
           ! phi is monotone; the remaining solutions are in the next
           ! column or even farther over, and not before the current row
           ! or the oldest "bad" row in this column.
          i1 = min(i,ibad)   
          ibad = i2
          exit
        end if
        if ( stat(i) >= good ) cycle  ! Newton iteration ended successfully
!        Don't do this; it causes trouble:
!        if ( stat(i) == grid1 ) cycle ! Can't be further to the right
        ibad=min(i,ibad)
        if ( (debug .or. complexDebug) .and. stat(i) == complex ) then ! Complex solution
            if ( debug ) &
              & print '(i4,i2,18x,f11.3,f12.3,1x,a)', &
                & i, j, h_ref(k,j)+r_eq, h_ref(k,j+1)+r_eq, 'Complex solution'
            if ( complexDebug ) then
              call output ( req_s, before='&in req_s = ' )
              call output ( h_surf, before=', H_Surf = ' )
              call output ( tan_ht_s, before=', tan_ht_s = ', after=',', advance='yes' )
              call output ( phi_t, before='  Phi_T = ' )
              call output ( rad2deg*phi_t, before=" = " )
              call output ( tan_ind, before=', tan_ind = ', advance='yes' )
              call dump ( h_ref(k,:), name='h_ref', lbound=k )
              call dump ( rad2deg*p_basis, name='p_basis (degrees)' )
            end if
        end if
      end do path ! i
    end do phi ! j

      if ( debug ) then
        print *, 'no_bad_fits =', no_bad_fits, ', no_grid+fits =', no_grid_fits
        call dump ( nStat(stat), name='Stat' )
      end if
    if ( no_bad_fits > 0 ) then
      call MLSMessage ( MLSMsg_Warning, ModuleName, &
        & "Height_Metrics failed to find H/Phi solution for some path segment" )
      if ( bin42 ) then
        rewind 42
        write ( 42 ) shape(p_path), shape(h_ref), shape(p_basis), phi_t, &
                   & tan_ind, h_surf, tan_ht_s, r_eq
        write ( 42 ) p_basis, h_ref, z_ref
        rewind 42
      end if
      if ( switchDetail(switches,'mhpx') > -1 ) then
        call dumpInput ( 1 )
        if ( .not. debug ) then
          call dump ( nStat(stat), name='Stat' )
        end if
        call dump ( h_path, 'H_Path before 1d fixup' )
        call dump ( rad2deg*p_path, 'P_Path (degrees) before 1d fixup' )
        call dump ( z_ref(tan_ind:), 'Z_Ref', lbound=tan_ind )
      end if
      ! We shouldn't get here at all, so don't worry about efficiency
      if ( stat(1) < good .or. stat(n_path) < good ) then
        call MLSMessage ( MLSMSG_Warning, moduleName, 'Resorting to 1d' )
        ! Get interpolating coefficients (eta_t) from p_basis to phi_t
        call eta_t%eta ( p_basis, phi_t )
        do i1 = 1, n_path
          if ( stat(i1) < good ) then
            ! Interpolate to tangent phi as a first guess
            h_path(i1) = eta_t%row_dot_vec ( 1, h_ref(vert_inds(i1),:) ) + r_eq
          end if
        end do
        ! Make sure H is monotone increasing away from the tangent point
        i1 = n_tan - 1
        i2 = 1
        do k = -1, 1, 2
          do j = i1, i2, k
            if ( h_path(j) <= h_path(j-k) ) then
              do i = j+k, i2, k
                if ( h_path(j-k) < h_path(i) ) exit
              end do
              if ( i == i2+k  ) then ! ran off the end
                h_path(j) = h_path(j-k) + 1.0 ! use SWAG method
              else
                h_path(j) = h_path(j-k) + (h_path(i)-h_path(j-k)) * &
                  & ( z_ref(vert_inds(j)) - z_ref(vert_inds(j-k))) / &
                  & ( z_ref(vert_inds(i)) - z_ref(vert_inds(j-k)))
              end if
            end if
          end do
          i1 = n_tan + ngp1 + 1
          i2 = n_path
        end do
        ! Just do them all to make sure they're consistent
        p_path = acos(tan_ht/h_path) * phi_sign + phi_offset
      else
        do j = n_tan-1, 2, -1
          if ( stat(j) == good ) cycle
          do i2 = j, 2, -1
            if ( stat(i2) == good ) exit
          end do
          do i1 = j, n_tan
            if ( stat(i1) == good ) exit
          end do
          h_path(j) = h_path(i1) + (h_path(i2)-h_path(i1)) * &
            & ( z_ref(vert_inds(j)) - z_ref(vert_inds(i1))) / &
            & ( z_ref(vert_inds(i2)) - z_ref(vert_inds(i1)))
          p_path(j) = acos(tan_ht/h_path(j)) * phi_sign(j) + phi_offset(j)
        end do
        do j = n_tan+ngp1+1, n_path-1
          if ( stat(j) == good ) cycle
          do i2 = j, n_path-1
            if ( stat(i2) == good ) exit
          end do
          do i1 = j, n_tan+ngp1, -1
            if ( stat(i1) == good ) exit
          end do
          h_path(j) = h_path(i1) + (h_path(i2)-h_path(i1)) * &
            & ( z_ref(vert_inds(j)) - z_ref(vert_inds(i1))) / &
            & ( z_ref(vert_inds(i2)) - z_ref(vert_inds(i1)))
          p_path(j) = acos(tan_ht/h_path(j)) * phi_sign(j) + phi_offset(j)
        end do
      end if
      if ( switchDetail(switches,'mhpx') > -1 ) then
        call dump ( h_path, name='H_Path after 1d fixup' )
        call dump ( rad2deg*p_path, name='P_Path (degrees) after 1d fixup' )
        if ( switchDetail(switches,'mhpx') > 0 ) &
          & call MLSMessage ( MLSMSG_Error, moduleName, 'Halt requested by mhpx1' )
      end if
    else if ( testStat ) then
      if ( any(stat < good) ) then
        call dump ( nStat(stat), name='Stat' )
        call MLSMessage ( MLSMSG_Error, moduleName, &
          & 'No_Bad_Fits = 0 but some stat < good' )
      end if
    end if

    if ( tan_ht_s < 0.0 ) then ! Earth-intersecting ray
      if ( n_path >= 4 ) then
        ! Put the reflection point on the same side of the Earth as the rest
        ! of the path.
        if ( abs(p_path(n_tan-1) - p_path(n_tan)) > 0.9 * pi ) then
          ! Reflection point on the wrong side of the earth
          p_path(n_tan:n_tan+ngp1) = mod(p_path(n_tan:n_tan+ngp1) + &
            & sign(pi,p_path(n_tan-1) - p_path(n_tan)),pix2)
        end if
      end if
    end if

    ! Since we have solved for the intersection of sec(phi) with the heights
    ! on constant-zeta surfaces, it is impossible for the heights not to be
    ! monotone increasing away from the tangent point.

    if ( do_dumps >= 0 ) then
      call output ( tan_ht_s, before='tan_ht_s = ' )
      call output ( req_s, before=' km, r_eq+h_surf = ' )
      call output ( h_surf, before=' km, h_surf = ', after=' km', advance='yes' )
      call dump ( rad2deg*p_path, name='P_Path (degrees) before refractive correction', &
        & format='(f14.8)', options=options )
      if ( h_phi_dump < 0 .and. do_dumps >= 1 ) &
        & call dump ( rad2deg*p_basis, name='p_basis (degrees)', format='(f14.6)', options=options )
      call dump ( h_path, name='h_path (km from center of equivalent circular Earth)', &
        & format='(f14.6)', options=options )
      if ( do_dumps >= 2 ) call dump ( nStat(stat), name='Stat' )
      if ( do_dumps >= 2 ) &
        & call dump ( z_ref(tan_ind:), name='z_ref', options=options, lbound=tan_ind )
    end if

  contains

    subroutine DumpInput ( FirstRow )
      integer, intent(in) :: FirstRow
      call output ( tan_ht_s, before='Tan_Ht_s = ' )
      call output ( req_s, before=', R_Eq+H_Surf = ' )
      call dump ( rad2deg*p_basis, name='P_Basis (degrees)', format='(f14.6)', options=options )
      call output ( phi_t, before='Phi_t = ', format='(f11.8)' )
      call output ( rad2deg*phi_t, before=" = ", format='(f13.8)' )
      call output ( h_surf, before =', H_Surf = ' )
      call output ( tan_ind, before=', Tan_Ind = ', advance='yes' )
      call output ( r_eq, before='R_Eq ' )
      call dump ( z_ref(tan_ind:), name=' Z_Ref ', lbound=tan_ind )
      if ( tan_ht_s < 0.0 ) then
        call output ( n_tan, before='Phi_Offset (' )
        call output ( n_tan+ngp1, before=':', after=') (radians) ' )
        call dump ( phi_offset(n_tan:n_tan+ngp1), options='c' ) ! clean=.true.
        call output ( n_tan, before='Phi_Offset (' )
        call output ( n_tan+ngp1, before=':', after=') (degrees) ' )
        call dump ( rad2deg*phi_offset(n_tan:n_tan+ngp1), options='c' ) ! clean=.true.
      end if
      call dump ( h_ref(firstRow:n_vert,:), name='H_Ref', format='(f14.7)', &
        & options=options, lbound=firstRow )
      if ( debug ) call dump ( vert_inds, name='Vert_Inds' )
    end subroutine DumpInput

  end subroutine Height_Metrics

  ! ------------------------------------------------  Solve_H_Phi  -----

  !{Solve for an intersection of $H = H_t \sec \phi$ and the line from
  ! $(\phi_1,h_1)$ to $(\phi_2,h_2)$, where $\phi_1$ and $\phi_2$ are
  ! {\tt p\_basis(1)} and {\tt p\_basis(2)}, and $h_1$ and $h_2$ are
  ! {\tt h\_ref(1)} and {\tt h\_ref(2)}.
  !
  ! The solution is only acceptable if $\phi_1 \leq \phi \leq \phi_2$ and
  ! $(h_1 - h) (h_2-h) \leq 0$ or $|h_1 - h| \leq \tau$ or $|h_2 - h| \leq
  ! \tau$, where $\phi$ is {\tt p\_path}, $h$ is {\tt h\_path}, and $\tau$
  ! is the height tolerance {\tt tol}.

  subroutine Solve_H_Phi ( & ! inputs
    &                      p_basis, phi_offset, phi_sign, h_ref, a, b, c, &
    &                      tan_ht, r_eq, tol, inside, start, &
                             ! outputs and inouts
    &                      h_path, phi, stat, outside )

    use MLSKinds, only: RP
    use Output_m, only: Output

    real(rp), intent(in) :: P_Basis(2) ! Coordinates for H_Ref.
    real(rp), intent(in) :: Phi_Offset ! Offset from center of path.  Either the
                                       ! tangent point if the ray is not an
                                       ! Earth-intersecting ray, or the tangent
                                       ! point for the incident ray on one side,
                                       ! and the tangent point for the reflected
                                       ! ray on the other side.
    real(rp), intent(in) :: Phi_Sign   ! Which way from tangent?
    real(rp), intent(in) :: H_Ref(2)   ! Height reference, km above R_Eq.
      ! A, B and C are coefficients of a quadratic approximation to the solution
    real(rp), intent(in) :: A          ! (p_basis(2)-p_basis(1)) * tan_ht
    real(rp), intent(in) :: B          ! -(h_ref(2) - h_ref(1))
    real(rp), intent(in) :: C          ! -(h_ref(1)-h_surf) * (p_basis(2)-phi_t)
                                       ! +(h_ref(2)-h_surf) * (p_basis(1)-phi_t)
                                       ! +(p_basis(2)-p_basis(1)) * h_tan
    real(rp), intent(in) :: Tan_Ht     ! From equivalent circular Earth center,
                                       ! H_Tan + r_eq, km
    real(rp), intent(in) :: R_eq       ! From center of equivalent circular
                                       ! earth, km
    real(rp), intent(in) :: Tol        ! Height tolerance for Newton convergence,
                                       ! km
    logical, intent(in) :: Inside      ! P_Basis(2) is not the last one in the grid
    real(rp), intent(in) :: Start      ! Start here if > -0.5*huge(0.0_rp)
    real(rp), intent(inout) :: H_Path  ! H solution, inout in case there is none
    real(rp), intent(out) :: Phi       ! Phi solution
    integer, intent(inout) :: Stat     ! "good" or "grid" or "complex" or unchanged
    logical, intent(out) :: Outside    ! Newton iteration converged to a point
                                       ! outside p_basis(1:2)

    real(rp) :: D      ! B^2 - 4 A C
    real(rp) :: Deriv  ! Derivative of A (sec(p)-1 ) + B p + C or
                       ! its polynomial approximation if p < p8Tol
    real(rp) :: H      ! tan_ht * ( 1.0_rp + secM1 ) - r_eq,
                       ! ~ tan_ht * sec(p) - r_eq
    integer :: N       ! Newton iteration counter
    integer, parameter :: NMax = 10 ! Maximum number of Newton iterations
    real(rp) :: P, P2  ! Candidate solution, p^2
    real(rp) :: P_Path ! Candidate path phi solution
    real(rp) :: Secm1  ! Sec(p) - 1
    real(rp) :: Secp   ! Sec(p) = 1/Cos(p), to compute SecM1 when p > p8Tol

    ! Coefficients in expansion of Sec(phi)-1 = c2*phi^2 + c4*phi^4 ...
    ! At phi-phi_t = 0.2 radians and tan_ht = 6400 km, this gives 56 cm accuracy
    real(rp), parameter :: C2 = 0.5_rp, C4 = 5.0_rp/24, C6 = 61.0_rp/720
    real(rp), parameter :: C8 = 277.0_rp/8064
    ! Coefficients in expansion of Sec(phi)*Tan(phi) = d/dPhi(sec(phi)-1)
    real(rp), parameter :: D1 = 2*c2, D3 = 4*c4, D5 = 6*c6 ! ... 2n * c_2n
    real(rp), parameter :: D7 = 8*c8
    ! Boundary on P for using the expansion instead of sec(p) - 1
    real(rp), parameter :: P8Tol = 0.2

    ! For debugging output
    real(rp) :: DD(merge(10,0,debug))

    if ( stat == order ) stat = no_sol
    outside = .false.
    if ( start < -0.25*huge(0.0_rp) ) then
      ! Solve 1/2 a p^2 + b p + c to start
      d = b*b - 2.0 * a * c
      if ( d < 0.0 ) then ! Complex starting solution, assume 1-d pressure
        p = phi_sign*acos(tan_ht/max(tan_ht,0.5*(h_ref(1)+h_ref(2))+r_eq))
        if ( stat < good ) &
          & stat = complex ! In case Newton iteration doesn't converge
          if ( debug ) then
            call output ( p + phi_offset, format='(f11.5)', &
              & before='Complex starting point' )
            call output ( ( p + phi_offset) * rad2deg, format='(f11.5)', &
              & before=' radians = ', after=' degrees', advance='yes' )
          end if
      else
        p = (-b + phi_sign * sqrt(d) ) / a
        if ( p < p_basis(1)-phi_offset .or. p > p_basis(2)-phi_offset ) then
          p = (-b - phi_sign * sqrt(d) ) / a
          if ( p < p_basis(1)-phi_offset .or. p > p_basis(2)-phi_offset ) &
            & p = phi_sign*acos(tan_ht/max(tan_ht,0.5*(h_ref(1)+h_ref(2))+r_eq))
        end if
      end if
    else
      p = start - phi_offset
    end if
    p_path = sign(p,phi_sign) + phi_offset
    !{Use P in Newton iterations with an expansion for $\sec(\phi)$ that is
    ! higher order than two.  We don't use $\sec(\phi)-1$ for small $\phi$
    ! because it suffers cancellation.  Rather, use more terms of its Taylor
    ! series than we used for the quadratic approximation.
    do n = 1, nMax
      if ( abs(p) < P8Tol ) then ! Small phi -- sec(phi)-1 has cancellation
        p2 = p**2                             ! $ ( \phi - \phi_t )^2 $
        secM1 = p2*(c2+p2*(c4+p2*(c6+p2*c8))) ! ~ sec(p) - 1 to eighth order
        secp = secM1 + 1.0                    ! ~ sec(p) to eighth order
      else ! Large phi -- sec(phi)-1 is good, polynomial approximation is not
        secp = 1.0 / cos(p)                   ! sec(p)
        secM1 = secp - 1.0                    ! sec(p) - 1
      end if
      d = a*secM1 + b*p + c
        if ( debug ) dd(n) = d
      h_path = tan_ht * secp
      h = h_path - r_eq  ! to test against h_ref
      if ( abs(d) < tol ) then ! difference is small enough
        if ( (p_path-p_basis(1)) * (p_path-p_basis(2)) <= 0.0 .and. &
               ! Converged within bounds?
                &  ( (h-h_ref(1))*(h-h_ref(2)) <= 0.0 .or. &
               ! or the difference in reference heights is within tolerance and
               ! the current H is outside the bounds by less than tolerance
          &    abs(b) < tol .and. &
          &    ( abs(h-h_ref(1)) < tol .or. &
          &      abs(h-h_ref(2)) < tol ) ) ) then
          ! Not extrapolating in phi
          stat = good
          if ( debug ) call debug1 ( 1, n, 'GOOD', p_path, p_print=p )
          phi = p_path
          return
        end if
        if ( p_path > p_basis(2) .and. abs(a*(h-h_ref(2))) > tan_ht*abs(d) &
          & .and. inside ) then
          ! Phi is beyond the range, and H is outside by more than the
          ! move.  Go on to the next columns of H_ref and P_Basis.
          outside = .true. ! phi is monotone; the rest are in the next column
          phi = p_path ! so phi has a defined value, even if it's no good
          if ( debug ) then
            call debug1 ( 1, n, 'OUTSIDE', p_path, p_print=p )
          end if
          if ( debug ) call debug2
          return           ! or even farther over
        end if
      end if
      if ( abs(p) < P8Tol ) then
        deriv = a*p*(d1+p2*(d3+p2*(d5+p2*d7))) + b       ! a P8' + b
      else
        deriv = a * secp * sign(sqrt(secp**2-1.0),p) + b ! a sec(p) tan(p) + b
      end if
        if ( newtonDetails ) then
          call debug1 ( 1, 0, 'STEP ' // merge('P','S',abs(p) < P8Tol), p_path, p, deriv )
        end if
      p = p - d / deriv ! do the Newton step
      p_path = sign(p,phi_sign) + phi_offset
    end do ! n
    ! Newton iteration failed to converge.  Use the break point if the
    ! result is very near to it.  We'll probably find it in the next
    ! panel, but just in case....
      if ( debug ) then
        if ( .not. outside ) then
          call debug1 ( max(n-3,1), n-1, merge('CONVERGE', 'BOUNDS  ', abs(d) < tol), p_path, &
            & p_print=p )
        else
          call debug1 ( max(n-3,1), n-1, 'NONE', p_path, p_print=p )
        end if
      end if
    phi = p_path ! make sure it has a defined value, even if it's no good
    if ( stat < grid1 ) then
      if ( abs(h-h_ref(1)) <  0.1 .and. &
        & abs(p_path-p_basis(1)) < abs(p_path-p_basis(2)) ) then
        h_path = h_ref(1) + r_eq
        if ( h_path > tan_ht ) then
          phi = p_basis(1)
          stat = grid1
          if ( debug ) call debug1 ( 1, 0, 'GRID 1', phi )
        end if
      else if ( abs(h-h_ref(2)) <  0.1 .and. &
        & abs(p_path-p_basis(2)) < abs(p_path-p_basis(1)) ) then
        h_path = h_ref(2) + r_eq
        if ( h_path > tan_ht ) then
          phi = p_basis(2)
          stat = grid2
          if ( debug ) call debug1 ( 1, 0, 'GRID 2', phi )
        end if
      end if
    end if
    if ( p_path > p_basis(2) .and. inside ) then
      outside = .true. ! phi is monotone; the rest are in the next column
    end if
    if ( debug ) call debug2

  contains

    subroutine debug1 ( K, L, Why, Phi, P_print, Deriv )
      integer, intent(in) :: K, L
      character(len=*), intent(in) :: Why
      real(rp), intent(in) :: Phi
      real(rp), intent(in), optional :: P_print
      real(rp), intent(in), optional :: Deriv
      character(merge(13,0,debug)) :: OOPS
      if ( debug ) then
        if ( present(P_print) ) then
          write ( *, '(f11.5)', advance='no' ) ang*P_print
        else
          write ( *, '(11x)', advance='no' )
        end if
        oops=''
        if ( abs(cos(p)*(h+r_eq)-tan_ht) > 5.0e-4 * cos(p) ) oops='TRIG'
        if ( why /= '' ) oops(6:) = why
      100 format (f11.5,f10.3,f10.3,f11.3,f10.3,1p,g14.6,i3,11g10.2)
        write (*, 100, advance='no') ang*phi, h_path, &
          & h_ref(1)+r_eq, h_ref(2)+r_eq, &
        ! & tan_ht / cos(p), &
          & tan_ht * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ tan_ht * sec(p)
          & d, n, dd(k:l)
        if ( present(deriv) ) then
          write ( *, '(f12.3)', advance='no' ) deriv
        else if ( k > l ) then
          write ( *, '(10x)', advance='no' )
        end if
        write (*, '(2x,a)') trim(adjustl(oops))
      end if
    end subroutine

    subroutine debug2
      call output ( phi, before='Phi ', format='(f11.5)' )
      call output ( phi*rad2deg, before=' = ', format='(f11.5)' )
      call output ( stat, before=' stat ', after=' = ' )
      call output ( nStat(stat), advance='yes' )
    end subroutine debug2

  end subroutine Solve_H_Phi

  ! -----------------------------------------------  More_Metrics  -----
  subroutine More_Metrics ( &
          ! Inputs:
          & Tan_Ind, N_Tan, T_Sv, Vert_Inds, T_Ref, dHidZij, P_Path,   &
          & Eta_P,                                                     &
          ! Outputs:
          & T_Path, dHitdZi,                                           &
          ! Optional inputs:
          & ddHidHidTl0, dHidTlm, Z_Ref,                               &
          ! Optional outputs:
          & ddHtdHtdTl0, dHitdTlm, dHtdTl0, dHtdZt,                    &
          & Eta_ZP, T_Der_Path_Flags, Tan_Phi_t )

    ! This subroutine computes metrics-related things after H_Path and
    ! P_Path are computed by Height_Metrics, and then perhaps augmented
    ! with, for example, the minimum Zeta point.

    use Dump_0, only: Dump
    use Load_Sps_Data_m, only: Grids_t
    use MLSKinds, only: RP
    use MLSStringLists, only: SwitchDetail
    use Sparse_Eta_m, only: Sparse_Eta_t
    use Sparse_m, only: Sparse_t
    use Toggles, only: Switches

    ! inputs:

    integer, intent(in) :: Tan_Ind      ! Tangent height index, 1 = center of
                                        ! longest path
    integer, intent(in) :: N_Tan        ! Tangent index in path, usually n_path/2
    type(grids_t), intent(in) :: T_Sv   ! Temperature state vector stuff
    integer, intent(in) :: Vert_Inds(:) ! First (vertical) subscripts for
                                        ![zt]_ref  at points on the path
    real(rp), intent(in) :: T_Ref(:,:)  ! Temperatures at Z_Ref X t_sv%phi_basis
    real(rp), intent(in) :: dHidZij(:,:)! Vertical derivative at Z_Ref X t_sv%phi_basis
    real(rp), intent(in) :: P_Path(:)   ! Phi's on the path
    type(sparse_eta_t), intent(inout) :: Eta_P ! Interpolating coefficients from
                                        ! Temperature's Phi basis to P_Path.
                                        ! InOut so as not to default initialize
                                        ! everything.

    ! outputs:

    real(rp), intent(out) :: T_Path(:)  ! computed temperatures on the path                            
    real(rp), intent(out) :: dHitdZi(:) ! derivative of height wrt zeta
                                        !--may be useful in future computations

    ! optional inputs

    real(rp), optional, intent(in) :: ddHidHidTl0(:,:,:) ! second order
             ! reference temperature derivatives. This is (height, phi_basis,
             ! zeta_basis). Needed only if present(dHidTlm).
    real(rp), optional, intent(inout) :: dHidTlm(:,:,:) ! reference temperature
             ! derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is
             ! 0.0 for all temperature coefficients.
             ! This is height X zeta_basis X phi_basis
    real(rp), optional, intent(in) :: Z_Ref(:)   ! -log pressures (zetas) for
             ! which derivatives are needed.  Only the parts from the tangent
             ! outward are used.  Needed only if present(dHidTlm).

    ! Optional outputs.

    real(rp), optional, intent(out), target :: ddHtdHtdTl0(:)  ! Second order
             ! derivatives of height w.r.t T_Ref at the tangent only -- used
             ! for antenna affects. Computed if present(dHidTlm).
    type(sparse_t), optional, intent(inout) :: dHitdTlm        ! Derivative of
             ! path position wrt temperature state vector
             ! (t_sv%zet_basis X t_sv%phi_basis)
    real(rp), optional, intent(out), target :: dHtdTl0(:)      ! First order derivatives
             ! of height w.r.t T_Ref at the tangent only.  Computed if
             ! present(dHidTlm).
    real(rp), optional, intent(out) :: dHtdZt          ! Height derivative wrt
             ! pressure at the tangent.  Computed if present(dHidTlm).
    type(sparse_eta_t), optional, intent(inout) :: Eta_ZP ! Interpolating
             ! coefficients for Temperature from Zeta X Phi to the path
    logical, optional, intent(out) :: T_Der_Path_Flags(:) ! An element in any
             ! column of row I of Eta_ZP is nonzero. Computed if
             ! present(dHidTlm).
    real(rp), optional, intent(out) :: Tan_Phi_t ! temperature at the tangent

    ! Local variables.

    integer :: Do_Dumps    ! <0 = no dump, >=0 = dump, >0 = stop
    integer :: I           ! Subscript, loop inductor
    integer :: N_Path      ! Path length = size(vert_inds)

!   It would be nice to do this the first time only, but the
!   retrieve command in the L2CF can now change switches
!   if ( do_dumps < 0 ) then ! First time only
      do_dumps = switchDetail(switches,'metd')
!   end if

    n_path = size(vert_inds)

    ! Interpolate Temperature (T_Ref) and the vertical height derivative
    ! (dHidZij) to the path (T_Path and dHitdZi).

    ! Compute the interpolating coefficients Eta_p for temperature.
    call eta_p%empty ! Clean out data but don't deallocate components
    call eta_p%eta_1d ( t_sv%phi_basis, p_path(:n_path), &
                      & create=.false., sorted=.true. )
    do i = 1, n_path
      ! Interpolate to t_path and dHitdZi one row at a time because
      ! t_ref(vert_inds,:) would be a big copy.
      t_path(i) = eta_p%row_dot_vec ( i, t_ref(vert_inds(i),:) )
      dHitdZi(i) = eta_p%row_dot_vec ( i, dHidZij(vert_inds(i),:) )
    end do

    ! Now for the optional tangent quantities.
    if ( n_tan <= n_path ) then
      ! Why aren't these two just t_ref(n_tan) and dHitdZi(n_tan)?
      if ( present(tan_phi_t) ) &
        & tan_phi_t = eta_p%row_dot_vec ( i, t_ref(tan_ind,:) )
      if ( present(dhtdzt) ) &
        & dhtdzt = eta_p%row_dot_vec ( i,  dHidZij(tan_ind,:) )
      ! compute temperature derivatives
      if ( present(dHidTlm) ) call Temperature_Derivatives
    end if

    if ( do_dumps >= 1 ) then
      call dump ( t_ref, name='t_ref', format='(1pg14.6)', options=options )
      call dump ( t_path(:n_path), name='T_Path', format='(1pg14.6)', options=options )
      call dump ( dHitdZi(:n_path), name='dHitdZi', format='(1pg14.6)', options=options )
      call eta_p%dump ( name='Eta_P', format='(1pg14.6)' )
      if ( do_dumps > 1 ) stop
    end if

  contains

    subroutine Temperature_Derivatives

      use Array_Stuff, only: Element_Position, Subscripts
      use Comp_Eta_DoCalc_Sparse_m, only: Comp_One_Eta_Z
      use GLNP, only: NG, NGP1
      logical :: Change                      ! Interpolator got set to zero
      real(rp), pointer :: ddHtdHtdTl0_2(:,:) ! Zeta X Path
      real(rp), pointer :: dHtdTl0_2(:,:)    ! Zeta X Path
      type(sparse_eta_t) :: Eta_Z            ! Zeta interpolating coefficients
      integer :: I, J, K, SV_P, SV_T, SV_Z   ! Loop inductors and subscripts
      integer :: P_Coeffs                    ! # of phi's, t_sv%l_p(1)
      integer :: Two_D_Bounds(2)             ! [ Z_Coeffs, P_Coeffs ]
      integer :: Two_Subs(2)                 ! [ Sv_Z, Sv_P ]
      real(rp) :: V                          ! Value to store in dHitdTlm
      integer :: WS                          ! t_sv%window_start(1)
      integer :: Z_Coeffs                    ! # of zetas, t_sv%l_z(1)
      real(rp) :: Z_Path(n_path)             ! Z_Ref(vert_inds(1:n_path))
      equivalence ( two_d_bounds(1), z_coeffs ), ( two_d_bounds(2), p_coeffs )
      equivalence ( two_subs(1), sv_z ), ( two_subs(2), sv_p )

      ! Adjust the 2d hydrostatic temperature derivative relative to the
      ! surface. Even though this is updated on every invocation, that is,
      ! with a new phi_t, it works as if the original value were updated with
      ! the current phi_t, because the interpolation represented by eta_p is
      ! linear. Thus, the effect of cumulative updates for each new phi_t are
      ! the same as starting from the original dHidTlm and updating with the
      ! latest phi_t.  The algebra is horrible, but Maple has verified this.

      p_coeffs = t_sv%l_p(1) ! Also sets two_d_bounds(2)
      z_coeffs = t_sv%l_z(1) ! Also sets two_d_bounds(1)

      do i = 1, z_coeffs
        dHidTlm(:,i,:) = dHidTlm(:,i,:) - eta_p%row_dot_vec ( n_tan, dHidTlm(1,i,:) )
      end do

      dHtdTl0_2(1:z_coeffs,1:p_coeffs) => dHtdTl0 ( 1 : z_coeffs * p_coeffs )
      ddHtdHtdTl0_2(1:z_coeffs,1:p_coeffs) => ddHtdHtdTl0 ( 1 : z_coeffs * p_coeffs )

      dHtdTl0_2 = 0
      ddHtdHtdTl0_2 = 0
      ! Now fill the places that have nonzero Phi interpolating coefficients
      ! in the tangent row.
      do i = 1, z_coeffs
        call eta_p%row_times_vec ( n_tan, dHidTlm(tan_ind,i,:), dHtdTl0_2(i,:) )
        call eta_p%row_times_vec ( n_tan, ddHidHidTl0(tan_ind,i,:), &
                                 &        ddHtdHtdTl0_2(i,:) )
      end do

      ! Compute Zeta interpolation coefficients from the temperature zeta
      ! basis to path zetas.

      z_path = z_ref(vert_inds(1:n_path))
      call comp_one_eta_z ( t_sv, n_tan, z_path, eta_z, skip=ngp1 )

      ! Compute interpolation coefficients from Zeta X Phi to the path.
      call eta_zp%empty ! clean it out but don't deallocate components
      ! Compute Eta_ZP =  Eta_Z x Eta_P^T where t_sv%deriv_flags is true
      call eta_zp%eta_nD ( eta_z, eta_p, flags=t_sv%deriv_flags )
      ! Don't need Eta_ZP at GL points between two coarse tangent points
      if ( n_path > n_tan ) eta_zp%rows(n_tan+1:n_tan+ng) = 0
      ! Compute the path temperature derivative, noting where the nonzeros are
      call dHitdTlm%empty ! Clean it out but don't deallocate components
      dHitdTlm%nRows = n_path ! usually filled by Sparse_Eta%*D
      t_der_path_flags = .false.
      do i = 1, n_path
        t_der_path_flags(i) = eta_zp%rows(i) /= 0
        ! An iterator to traverse a row of a sparse_t would be helpful
        j = eta_p%rows(i) ! Last element in the row
        if ( j /= 0 ) then
          do
            j = eta_p%e(j)%nr   ! Next element in the row
            sv_p = eta_p%e(j)%c ! Column subscript of the element
            do sv_z = 1, z_coeffs
              sv_t = element_position ( two_subs, two_d_bounds )
            ! sv_t = element_position ( [ sv_z, sv_p ], [ z_coeffs, p_coeffs ] )
              if ( t_sv%deriv_flags(sv_t) ) then
!               v = max(dHidTlm(vert_inds(i),sv_z,sv_p),0.0_rp) * eta_p%e(j)%v
                v = dHidTlm(vert_inds(i),sv_z,sv_p) * eta_p%e(j)%v
                if ( v > 0 ) call dHitdTlm%add_element ( v, i, sv_t )
              end if
            end do
            if ( j == eta_p%rows(i) ) exit ! just processed the last element
          end do
        end if
      end do

    end subroutine Temperature_Derivatives

  end subroutine More_Metrics

  ! ------------------------------------------------  More_Points  -----
                         ! Inputs:
  subroutine More_Points (  phi_t, tan_ind, p_basis, z_ref, h_ref, r_eq,  &
                         &  h_surf, h_tan, p_path,                        &
                         ! Outputs:
                         &  z_new, h_new, p_new, n_new,                   &
                         ! Optional inputs:
                         &  h_tol )

    ! Check for path crossings in h_ref from tan_ind down, which Height_Metrics
    ! doesn't do.

    use MLSKINDS, only: RP
    ! inputs:

    real(rp), intent(in) :: phi_t      ! Orbit projected tangent geodetic angle
    integer, intent(in) :: tan_ind     ! Tangent height index, 1 = center of
                                       !  longest path
    real(rp), intent(in) :: p_basis(:) ! Horizontal temperature representation
                                       !  basis
    real(rp), intent(in) :: z_ref(:)   ! Reference zetas
    real(rp), intent(in) :: h_ref(:,:) ! Heights by z_ref and p_basis
    real(rp), intent(in) :: R_eq       ! equivalent elliptical earth radius at
                                       ! H_Surf
    real(rp), intent(in) :: H_Surf     ! Height of the pressure reference
                                       ! surface
    real(rp), intent(in) :: H_Tan      ! Tangent height above H_Surf -- negative
                                       !  for Earth-intersecting ray
    real(rp), intent(in) :: p_path(:)  ! From Height_Metrics

    ! outputs:
    real(rp), intent(out) :: z_new(:)  ! computed addional zetas
    real(rp), intent(out) :: h_new(:)  ! computed heights, referenced to Earth center
    real(rp), intent(out) :: p_new(:)  ! computed phis
    integer, intent(out) :: n_new      ! How many points put into h_new, p_new

    ! optional inputs
    real(rp), optional, intent(in) :: H_Tol ! Height tolerance in kilometers
                                       !   for convergence of phi/h iteration

    ! Local variables
    real(rp) :: A, B, C
    real(rp) :: H1, H2    ! Height along line of sight at p_basis(j-1:j)
    integer :: I, J
    real(rp) :: My_H_Tol
    logical :: None
    logical :: Outside
    integer :: P_Coeffs
    real(rp) :: REQ_S     ! R_eq - H_Surf = radius at true surface
    integer :: Stat
    real(rp) :: Tan_Ht    ! H_Tan + R_eq = height above h_surf

    if ( h_tan < 0.0 ) return ! Can't be any intersections below the surface
    my_h_tol = defaultTol ! kilometers
    if ( present(h_tol) ) my_h_tol = h_tol ! H_Tol is in kilometers
    req_s = r_eq - h_surf
    tan_ht = H_Tan + R_eq
    p_coeffs = size(p_basis)
    n_new = 0
    h2 = 0.0 ! Just so it's defined; this value is never used
    do i = min(tan_ind,ubound(z_ref,1)), 1, -1
      none = .true. ! Assume there will be no intersections
      do j = 1, size(h_ref,2)
        h1 = h2
        h2 = tan_ht / cos(p_basis(j) - phi_t) - req_s
        if ( j == 1 ) cycle ! It takes two to tango
        if ( (h1-h_ref(i,j-1)) * (h2-h_ref(i,j)) < 0.0 ) then
          ! Line of sight intersects constant-zeta surface.  Solve for where.
          n_new = n_new + 1
          a = (p_basis(j)-p_basis(j-1)) * tan_ht
          b = -(h_ref(i,j)-h_ref(i,j-1)) ! h_surf cancels here
          c = -(h_ref(i,j-1)-h_surf)*(p_basis(j  )-phi_t) &
            & +(h_ref(i,j  )-h_surf)*(p_basis(j-1)-phi_t) &
            & +(p_basis(j)-p_basis(j-1)) * h_tan
          if ( debug ) &
            & print 120, j, i, h_ref(i,j)+req_s, h_ref(i,j+1)+req_s, &
            & a, b, c
          120 format ( 4x, i2, i4, 14x, f11.3,f12.3, f9.3, 1p,g14.6, 3x, g14.6 )
          stat = no_sol
          call Solve_H_Phi ( p_basis(j-1:j), phi_t, sign(1.0_rp,phi_t-p_basis(j-1)), &
          &                h_ref(i,j-1:j), a, b, c, &
          &                tan_ht, req_s, my_h_tol, i /= tan_ind .or. j /= p_coeffs, &
          &                -0.5*huge(0.0_rp), & ! Start
          &                h_new(n_new), p_new(n_new), stat, outside )
          if ( stat >= grid1 ) then
            if ( minval(abs(h_new(n_new)- h_ref(i,j-1:j))) > my_h_tol ) then
              stat = no_sol
              n_new = n_new - 1
              cycle
            end if
          end if
          if ( stat < good .or. outside ) then
            ! What's going on?
            n_new = n_new - 1
          else
            if ( minval(abs(p_new(n_new)-p_path)) < 1.0e-4 ) then
              ! New one is too close to a grid point -- ignore it.
              stat = no_sol
              n_new = n_new - 1
            else
              none = .false. ! There is an intersection in this row of H_Ref
              z_new(n_new) = z_ref(i)
            end if
          end if
        end if
        if ( n_new == size(z_new)-1 ) return ! No room for any more
      end do ! j
      if ( none ) exit ! Heights are monotone in each column of H_Ref, so if
                       ! there aren't any intersections in this row, there
                       ! aren't any others farther down.
    end do ! i

  end subroutine More_Points

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: metrics_m.f90,v 2.91 2018/08/28 22:15:35 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Metrics_m

! $Log: metrics_m.f90,v $
! Revision 2.91  2018/08/28 22:15:35  vsnyder
! Rearrange arguments because Eta_FZP is optional in Comp_Sps_Path_Sparse_No_Frq
!
! Revision 2.90  2018/08/15 01:15:47  vsnyder
! Add calculation of T_Der_Path_Flags for temperature derivatives
!
! Revision 2.89  2018/05/24 03:24:09  vsnyder
! Use sparse representation for dHitdTlm
!
! Revision 2.88  2018/05/17 02:15:45  vsnyder
! Use sparse instead of dense interpolation
!
! Revision 2.87  2018/05/14 23:37:35  vsnyder
! Change to sparse eta representation
!
! Revision 2.86  2017/09/20 01:16:22  vsnyder
! Revise some dumping, delete a redundant dump
!
! Revision 2.85  2017/09/14 19:42:24  vsnyder
! Better control over what's dumped using metd#
!
! Revision 2.84  2017/09/13 19:39:24  vsnyder
! Move nStat to module scope so more routines can use it.  Add unformatted
! output of inputs if debugging.  Add more debugging output.  Add more
! checking on phi order.  Add method to recover from complex starting point.
! Correct missing application of Phi_Sign, which caused phi to be out of
! order.  Some cannonball polishing.
!
! Revision 2.83  2017/09/08 16:44:33  pwagner
! Fixes bug that broke Platinum brick
!
! Revision 2.82  2017/08/28 20:28:08  livesey
! Changed the n,nf,np,nz elements to j,jf,...
!
! Revision 2.81  2017/07/26 20:05:22  vsnyder
! When the L4 component of Grids_t is constructed, the low bound for the
! first subscript is WindowStart, not 1.  That needs to be considered when
! looking at L4.
!
! Revision 2.80  2017/03/11 00:56:05  vsnyder
! Use list interpolation in More_Metrics, cosmetic changes
!
! Revision 2.79  2016/11/17 02:06:12  vsnyder
! Correct some LaTeX
!
! Revision 2.78  2016/11/17 01:39:45  vsnyder
! Change path variable names from xyz_grid to xyz_path
!
! Revision 2.77  2016/10/18 00:25:37  vsnyder
! Improve comments, some cannobball polishing
!
! Revision 2.76  2016/08/20 00:55:08  vsnyder
! Correct comments about units for Phi_t and P_Basis in Tangent_Metrics
!
! Revision 2.75  2015/09/22 01:59:32  vsnyder
! Correct some comments, dump Z
!
! Revision 2.74  2015/05/28 23:14:42  vsnyder
! Add units in comments about variables
!
! Revision 2.73  2013/06/12 02:32:30  vsnyder
! Cruft removal
!
! Revision 2.72  2013/05/21 23:55:14  vsnyder
! Compute No_Bad_Fits correctly, revise dump switches
!
! Revision 2.71  2013/05/18 00:34:44  vsnyder
! Insert NG fine-grid (GL) points between tangent points, thereby
! regularizing coarse-grid spacing, and reducing significantly the need
! to use c_inds to extract coarse-grid points from the composite grid.
!
! Revision 2.70  2013/03/30 00:06:11  vsnyder
! Put dummy argument declarations in same order as in subroutine statement
!
! Revision 2.69  2013/02/28 21:08:29  vsnyder
! Try not to access array out of bounds
!
! Revision 2.68  2011/05/09 18:02:19  pwagner
! Converted to using switchDetail
!
! Revision 2.67  2010/02/04 23:10:20  vsnyder
! Remove USE for unreferenced names
!
! Revision 2.66  2010/02/02 01:34:55  vsnyder
! Make do_calc_t intent(inout)
!
! Revision 2.65  2009/12/15 03:20:06  vsnyder
! Don't force phi_offset to -pix2..pix2 for Earth-intersecting rasy
!
! Revision 2.64  2009/12/09 21:32:03  vsnyder
! Remove ill-advised mod on p_grid
!
! Revision 2.63  2009/08/20 23:30:56  vsnyder
! Handwaving to put p_grid in -2 pi .. 2 pi and the reflection point of
! an Earth-intersecting path on the same side of the Earth as the rest of
! the path.
!
! Revision 2.62  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.61  2009/06/16 17:37:26  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.60  2009/06/13 01:14:29  vsnyder
! Extensive changes almost everywhere.  Correct many problems with
! Earth-reflecting rays.
!
! Revision 2.59  2008/06/26 00:28:16  vsnyder
! Cannonball polishing
!
! Revision 2.58  2008/05/20 00:16:40  vsnyder
! Correct some TeXnicalities
!
! Revision 2.57  2007/11/08 01:49:39  vsnyder
! Req should be Req_s in one place in More_Points
!
! Revision 2.56  2007/10/19 23:28:30  vsnyder
! Don't accept grid solutions less than Ht
!
! Revision 2.55  2007/10/11 20:17:35  vsnyder
! Accept grid solutions more readily
!
! Revision 2.54  2007/10/03 20:54:10  vsnyder
! Require phi to be monotone
!
! Revision 2.53  2007/09/07 01:37:23  vsnyder
! Spiff up some dumps
!
! Revision 2.52  2007/08/23 20:41:07  vsnyder
! Don't clobber "grid" status with "cplx" status on next panel
! Don't clobber "grid" phi with failed iteration value on next panel
! Separate "grid" into "grid1" and "grid2"; don't bother to look for
! intersection on next panel after "grid1" solution.
!
! Revision 2.51  2007/07/31 23:48:57  vsnyder
! Try to recover from failure of H/Phi convergence
!
! Revision 2.50  2007/06/29 19:34:40  vsnyder
! Make the default h/phi convergence tolerance a parameter
!
! Revision 2.49  2007/06/26 00:35:39  vsnyder
! Use column-sparse eta, make *_zxp arguments
!
! Revision 2.48  2007/06/08 22:05:48  vsnyder
! More work on min zeta
!
! Revision 2.47  2007/03/22 23:24:34  vsnyder
! Remove irrelevant USE
!
! Revision 2.46  2007/02/06 23:50:59  vsnyder
! Polish up some messages.  Use 8th order approximation for sec(phi)-1 since
! sixth order doesn't give one-meter accuracy.
!
! Revision 2.45  2007/02/06 21:09:29  vsnyder
! Don't skip unsolved segments when going to next phi
!
! Revision 2.44  2007/02/01 02:53:15  vsnyder
! Make Solve_H_Phi a subroutine, add More_Points subroutine
!
! Revision 2.43  2007/01/20 01:07:49  vsnyder
! Use Earth-intersection phi instead of tangent phi to compute tangent
! temerature derivatives, do some decrufting too.
!
! Revision 2.42  2007/01/19 02:38:53  vsnyder
! Include water in phi refractive correction
!
! Revision 2.41  2007/01/18 00:26:32  vsnyder
! Split Pure_Metrics into Tangent_Metrics and Height_Metrics
!
! Revision 2.40  2006/12/21 22:59:17  vsnyder
! Don't reference optional arguments that aren't present
!
! Revision 2.39  2006/12/20 21:22:16  vsnyder
! Split metrics into pure H-Phi calculation, and everything else, in
! preparation for inserting the minimum-Zeta point into the path.
!
! Revision 2.37  2006/12/13 02:31:35  vsnyder
! Revision 2.38  2006/12/19 02:50:35  vsnyder
! Get rid of STATUS, reference H_Grid to Earth center instead of surface,
! some cannonball polishing.
!
! Polish up a comment
!
! Revision 2.36  2006/12/09 02:25:42  vsnyder
! Size some arrays more accurately, use First:Last version of get_eta_matrix,
! remove Tangent_Temperature_Derivatives module procedure since it isn't used
!
! Revision 2.35  2006/12/08 23:57:08  vsnyder
! Revise earth-intersecting metrics
!
! Revision 2.34  2006/12/08 22:50:55  vsnyder
! Complete revision
!
@


2.91
log
@Rearrange arguments because Eta_FZP is optional in Comp_Sps_Path_Sparse_No_Frq
@
text
@d403 4
a406 1
        if ( IEEE_Is_NaN(p_path(i)) ) stat(i) = NaN_sol
d409 1
d415 5
a419 1
          if ( p_path(i) > p_path(i+1) .and. stat(i+1) >= good ) then
d1187 1
a1187 1
       "$Id: metrics_m.f90,v 2.90 2018/08/15 01:15:47 vsnyder Exp $"
d1197 3
@


2.90
log
@Add calculation of T_Der_Path_Flags for temperature derivatives
@
text
@d1024 1
a1024 1
      call comp_one_eta_z ( t_sv, 1, n_tan, z_path, eta_z, ngp1 )
d1179 1
a1179 1
       "$Id: metrics_m.f90,v 2.89 2018/05/24 03:24:09 vsnyder Exp $"
d1189 3
@


2.89
log
@Use sparse representation for dHitdTlm
@
text
@d854 1
a854 1
          & Eta_ZP, Tan_Phi_t )
d918 3
d976 1
a976 1
      use GLNP, only: NGP1
d1030 2
d1035 1
d1037 1
d1179 1
a1179 1
       "$Id: metrics_m.f90,v 2.88 2018/05/17 02:15:45 vsnyder Exp $"
d1189 3
@


2.88
log
@Use sparse instead of dense interpolation
@
text
@d854 1
a854 1
          & Eta_ZP, Do_Calc_Hyd, Tan_Phi_t )
d865 1
d908 3
a910 2
    real(rp), optional, intent(out) :: dHitdTlm(:,:)   ! Derivative of path
             ! position wrt temperature state vector (t_sv%zet_basis X t_sv%phi_basis)
a917 3
    logical, optional, intent(out) :: Do_Calc_Hyd(:,:) ! Nonzero locator for
             ! hydrostatic calculations.  Computed if present(dHidTlm).
             ! This is Path X StateVector = Path X ( Zeta * Phi )
d942 1
a942 1
      ! Interolate to t_path and dHitdZi one row at a time because
d982 1
d1010 1
d1025 2
a1026 1
      call eta_zp%eta_nD ( eta_z, eta_p ) ! Eta_ZP = outer product Eta_Z * Eta_P
d1028 2
a1029 1
      dHitdTlm = 0
a1030 1
        change = .false.
d1041 3
a1043 5
                dHitdTlm(i,sv_t) = max(dHidTlm(vert_inds(i),sv_z,sv_p),0.0_rp) * &
                    & eta_p%e(j)%v
              else
                change = .true.
                dHitdTlm(i,sv_t) = 0.0
a1048 17
        if ( change ) then ! Make some interpolators zero because
                           ! t_sv%deriv_flags was false
          ! An iterator to traverse a row of a sparse_t would be helpful
          j = eta_zp%rows(i) ! Last element in the row
          if ( j /= 0 ) then
            ws = t_sv%windowStart(1)
            do
              j = eta_zp%e(j)%nr   ! Next element in the row
              k = eta_zp%e(j)%c    ! Column subscript of the element
              two_subs = subscripts ( k, two_d_bounds ) ! [ sv_z, sv_p ]
              ! L4 is associated with Deriv_Flags
              if ( .not. t_sv%c(1)%l4(1,sv_z,ws+sv_p-1,1) ) &
                & eta_zp%e(j)%v = 0
              if ( j == eta_zp%rows(i) ) exit ! just processed the last element
            end do
          end if
        end if
a1049 1
      do_calc_hyd = dHitdTlm /= 0.0_rp
d1172 1
a1172 1
       "$Id: metrics_m.f90,v 2.87 2018/05/14 23:37:35 vsnyder Exp $"
d1182 3
@


2.87
log
@Change to sparse eta representation
@
text
@a66 1
    use Get_Eta_Matrix_M, only: Get_Eta_Sparse
d68 1
d105 1
a105 2
    integer :: First, Last             ! Nonzeros in Eta_T
    real(rp) :: ETA_T(size(p_basis))   ! Interpolating coefficients
d108 1
a108 1
    call get_eta_sparse ( p_basis, phi_t, eta_t, first, last )
d114 1
a114 1
      h_surf = dot_product(surf_height(first:last), eta_t(first:last))
d119 1
a119 1
      h_surf = dot_product(h_ref(1,first:last), eta_t(first:last))
d129 1
a129 2
      h_tan = dot_product(surf_temp(first:last),eta_t(first:last)) * &
        &     (tan_press-z_ref)/14.8
d131 1
a131 1
      h_tan = dot_product(h_ref(tan_ind_f,first:last),eta_t(first:last)) - h_surf
a156 1
    use Get_Eta_Matrix_M, only: Get_Eta_Sparse
d163 1
d170 1
a170 1
    !                                    longest path
d172 1
a172 1
    !                                    basis, radians
d176 1
a176 1
    !                                    surface z_ref(1) above R_eq at phi_t, km
d178 1
a178 1
    !                                    for Earth-intersecting ray, km
d180 2
a181 2
    !                                    heights/temps are needed.  Only used
    !                                    where H/Phi iteration fails.
d183 1
a183 1
    !                                    true surface at Phi_T, km
d187 2
a188 2
    !                                    earth radius of pressure reference
    !                                    surface at Phi_T, km
d228 1
a228 1
    real(rp) :: Eta_T(size(p_basis)) ! Interpolating coefficients
d475 2
a476 1
        call get_eta_sparse ( p_basis, phi_t, eta_t )
d480 1
a480 1
            h_path(i1) = dot_product(h_ref(vert_inds(i1),:),eta_t) + r_eq
d870 1
a870 1
    !                                     longest path
d874 1
a874 1
    !                                    [zt]_ref  at points on the path
d887 1
a887 1
    !                                    --may be useful in future computations
d892 2
a893 2
    !          reference temperature derivatives. This is (height, phi_basis,
    !          zeta_basis). Needed only if present(dHidTlm).
d895 3
a897 3
    !          derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is
    !          0.0 for all temperature coefficients.
    !          This is height X zeta_basis X phi_basis
d899 2
a900 2
    !          which derivatives are needed.  Only the parts from the tangent
    !          outward are used.  Needed only if present(dHidTlm).
d905 2
a906 2
    !          derivatives of height w.r.t T_Ref at the tangent only -- used
    !          for antenna affects. Computed if present(dHidTlm).
d908 1
a908 1
    !          position wrt temperature state vector (t_sv%zet_basis X t_sv%phi_basis)
d910 2
a911 2
    !          of height w.r.t T_Ref at the tangent only.  Computed if
    !          present(dHidTlm).
d913 1
a913 1
    !          pressure at the tangent.  Computed if present(dHidTlm).
d915 1
a915 1
    !          coefficients for Temperature from Zeta X Phi to the path
d917 2
a918 2
    !          hydrostatic calculations.  Computed if present(dHidTlm).
    !          This is Path X StateVector = Path X ( Zeta * Phi )
d1090 1
a1090 1
    !                                     longest path
d1092 1
a1092 1
    !                                     basis
d1100 1
a1100 1
    !                                     for Earth-intersecting ray
d1190 1
a1190 1
       "$Id: metrics_m.f90,v 2.86 2017/09/20 01:16:22 vsnyder Exp $"
d1200 3
@


2.86
log
@Revise some dumping, delete a redundant dump
@
text
@a68 3
    use MLSStringLists, only: SwitchDetail
    use Output_M, only: Output
    use Toggles, only: Switches
d803 1
d841 1
d855 1
a855 1
          & Eta_ZP, Do_Calc_Hyd, Do_Calc_T, Eta_zxp, NZ_Zxp, NNZ_Zxp, Tan_Phi_t )
a861 3
    use Get_Eta_List_m, only: Get_Eta_List
    use Indexed_Values_m, only: Dot_Product, Dump, Value_1D_List_t, &
      & Value_2D_List_t
d865 1
d873 1
a873 1
    type(grids_t), intent(in) :: T_Sv   ! Temperature state vector
d879 2
a880 2
    type(Value_1D_List_t), intent(inout) :: Eta_P(:) ! Interpolating coefficients
                                        ! from Temperature's Phi basis to P_Path.
d886 1
a886 1
    real(rp), intent(out) :: T_Path(:)  ! computed temperatures on the path
d915 2
a916 2
    type(Value_2D_List_t), optional, intent(out) :: Eta_ZP(:) ! Interpolating
    !          coefficients from Zeta X Phi to the path
a919 10
    logical, optional, intent(inout) :: Do_Calc_T(:,:) ! Nonzero locater for
    !          temperature bases computations.  Computed if present(dHidTlm).
    !          intent(inout) instead of intent(out) so as not to make parts we
    !          don't touch undefined.  Updated if present(dHidTlm).
    !          This is Path X StateVector = Path X ( Zeta * Phi )
    real(rp), optional, intent(inout) :: Eta_zxp(:,:)  ! Eta matrix for
    !          temperature.  Computed if present(dHidTlm).
    !          This is Path X StateVector = Path X ( Zeta * Phi )
    integer, optional, intent(inout) :: NZ_Zxp(:,:)    ! Nonzeros in Eta_zxp
    integer, optional, intent(inout) :: NNZ_Zxp(:)     ! Numbers of rows in NZ_ZXP
d939 4
a942 1
    call get_eta_list ( t_sv%phi_basis, p_path(:n_path), eta_p, sorted=.true. )
d944 4
a947 4
      ! We don't use Interpolate from Indexed_Values_m because
      ! t_ref(vert_inds,:) would be a copy.  So we do one row at a time.
      t_path(i) = dot_product ( t_ref(vert_inds(i),:), eta_p(i) )
      dHitdZi(i) = dot_product ( dHidZij(vert_inds(i),:), eta_p(i) )
d949 2
a950 1
    ! Now for the optional tangent quantities.  
d954 1
a954 1
        & tan_phi_t = dot_product ( t_ref(tan_ind,:), eta_p(i) )
d956 1
a956 1
        & dhtdzt = dot_product ( dHidZij(tan_ind,:), eta_p(i) )
d965 1
a965 1
      call dump ( eta_p, name='Eta_P', format='(1pg14.6)' )
d973 3
a975 3
      use Array_Stuff, only: Element_Position
      use Get_Do_Calc_m, only: Get_Eta_Do_Calc
      use GLNP, only: NG, NGP1
d979 1
a979 1
      type(Value_1D_List_t) :: Eta_Z(n_path) ! Interpolating coefficients
d986 1
d1002 1
a1002 2
        dHidTlm(:,i,:) = dHidTlm(:,i,:) - &
          & dot_product ( dHidTlm(1,i,:), eta_p(n_tan) )
a1007 2
      j = z_coeffs * p_coeffs

d1012 3
a1014 6
        dHtdTl0_2(i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%j) = &
          dHidTlm(tan_ind,i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%j) * &
            eta_p(n_tan)%v(:eta_p(n_tan)%n)%v
        ddHtdHtdTl0_2(i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%j) = &
          ddHidHidTl0(tan_ind,i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%j) * &
            eta_p(n_tan)%v(:eta_p(n_tan)%n)%v
d1018 4
a1021 1
      ! basis to reference zetas, noting where the nonzeros are
d1023 3
a1025 10
      ! Get_Eta_List is called twice because Z_Ref is sorted on N_Tan:1:-1
      ! and on N_Tan+ngp1:n_path.  This avoids sorting.
      call get_eta_list ( t_sv%zet_basis, z_ref(vert_inds(1:n_tan)), eta_z(1:n_tan) )
      eta_z(n_tan+1:n_tan+ng)%n = 0 ! Between the two tangent point elements
      call get_eta_list ( t_sv%zet_basis, z_ref(vert_inds(n_tan+ngp1:n_path)), &
      eta_z(n_tan+ngp1:n_path) )

      ! Compute interpolation coefficients from Zeta X Phi to the path, noting
      ! where the zeros are.
      call get_eta_list ( eta_z, eta_p, eta_zp )
d1030 18
a1047 12
        do j = 1, eta_p(i)%n ! At most two nonzero coefficients
          sv_p = eta_p(i)%v(j)%j
          do sv_z = 1, z_coeffs
            sv_t = element_position ( two_subs, two_d_bounds )
!           sv_t = element_position ( [ sv_z, sv_p ], [ z_coeffs, p_coeffs ] )
            if ( t_sv%deriv_flags(sv_t) ) then
              dHitdTlm(i,sv_t) = max(dHidTlm(vert_inds(i),sv_z,sv_p),0.0_rp) * &
                  & eta_p(i)%v(j)%v
            else
              change = .true.
              dHitdTlm(i,sv_t) = 0.0
            end if
d1049 1
a1049 1
        end do
d1052 14
a1065 9
          k = eta_zp(i)%n
          ws = t_sv%windowStart(1)
          do j = 1, k ! At most four values to check
            ! L4 is associated with Deriv_Flags
            if ( .not. t_sv%c(1)%l4(1,eta_zp(i)%v(j)%j,ws+eta_zp(i)%v(j)%jp-1,1) ) &
              & eta_zp(i)%v(j)%v = 0
          end do
          eta_zp(i)%n = count(eta_zp(i)%v(1:k)%v/=0)
          eta_zp(i)%v(1:eta_zp(i)%n) = pack(eta_zp(i)%v(1:k),eta_zp(i)%v(1:k)%v/=0)
a1068 2
! Temp while the forward model still needs Eta_zxp and Do_Calc_t
call get_eta_do_calc ( eta_zp(1:n_path), two_d_bounds, eta_zxp, do_calc_t, nz_zxp, nnz_zxp )
d1191 1
a1191 1
       "$Id: metrics_m.f90,v 2.85 2017/09/14 19:42:24 vsnyder Exp $"
d1201 3
@


2.85
log
@Better control over what's dumped using metd#
@
text
@a138 5
    if ( switchDetail(switches,'metd') > -1 ) then
      call output ( h_tan, before='H_Tan = ' )
      call output ( h_surf, before=', H_Surf = ', advance='yes' )
    end if

d178 2
a179 2
    real(rp), intent(in) :: H_ref(:,:) ! Heights above R_Eq by z_ref and
                                       ! p_basis, km
d570 2
a571 1
      call output ( req_s, before=', r_eq+h_surf = ', advance='yes' )
d1200 1
a1200 1
       "$Id: metrics_m.f90,v 2.84 2017/09/13 19:39:24 vsnyder Exp $"
d1210 3
@


2.84
log
@Move nStat to module scope so more routines can use it.  Add unformatted
output of inputs if debugging.  Add more debugging output.  Add more
checking on phi order.  Add method to recover from complex starting point.
Correct missing application of Phi_Sign, which caused phi to be out of
order.  Some cannonball polishing.
@
text
@d578 1
a578 1
      if ( h_phi_dump < 0 ) &
d582 2
a583 2
      call dump ( nStat(stat), name='Stat' )
      if ( do_dumps >= 1 ) &
d974 1
a974 1
    if ( do_dumps >= 0 ) then
d979 1
a979 1
      if ( do_dumps > 0 ) stop
d1204 1
a1204 1
       "$Id: metrics_m.f90,v 2.83 2017/09/08 16:44:33 pwagner Exp $"
d1214 7
@


2.83
log
@Fixes bug that broke Platinum brick
@
text
@d32 2
d44 1
d183 2
a184 1
    real(rp), intent(in) :: H_ref(:,:) ! Heights by z_ref and p_basis, km
d233 1
d251 1
a251 2
    character(5), parameter :: nStat(no_sol:grid2) = &
      & (/ 'none ', 'NaN  ', 'order', 'cmplx', 'good ', 'grid1', 'grid2' /)
d398 11
d412 1
a412 1
          &                h_path(i), p_path(i), stat(i), outside )
d414 1
d416 2
a417 2
          if ( p_path(i) < p_path(i-1) ) then ! Phi out of order, can't be right
            stat(i) = order
d420 6
a425 1
        if ( stat(i) >= good ) then ! good < grid1 < grid2
d452 1
a452 1
              call dump ( h_ref, name='h_ref' )
d461 1
a461 3
        do i = 1, size(stat), 10
          print "(i4,'#',10(1x,a:))", i, nStat(stat(i:min(size(stat),i+9)))
        end do
d466 7
d476 1
a476 3
          do i = 1, size(stat), 10
            print "(i4,'#',10(1x,a:))", i, nStat(stat(i:min(size(stat),i+9)))
          end do
d480 1
a480 1
        call dump ( z_ref, 'Z_Ref' )
d549 6
d580 5
a584 2
      call dump ( h_path, name='h_path', format='(f14.6)', options=options )
      if ( do_dumps >= 1 ) call dump ( z_ref, name='z_ref', options=options )
d591 4
a594 4
      call output ( tan_ht_s, before='tan_ht_s = ' )
      call output ( req_s, before=', r_eq+h_surf = ' )
      call dump ( rad2deg*p_basis, name='p_basis (degrees)', format='(f14.6)', options=options )
      call output ( phi_t, before='phi_t = ', format='(f11.8)' )
d596 4
a599 2
      call output ( h_surf, before =', h_surf = ' )
      call output ( tan_ind, before=', tan_ind = ', advance='yes' )
d601 1
a601 1
        call output ( n_tan, before='phi_offset (' )
d604 1
a604 1
        call output ( n_tan, before='phi_offset (' )
d608 3
a610 2
      call dump ( h_ref(firstRow:n_vert,:), name='h_ref', format='(f14.7)',options=options )
      if ( debug ) call dump ( vert_inds, name='vert_inds' )
d629 1
a629 1
    &                      tan_ht, r_eq, tol, inside, &
d644 1
a644 1
    real(rp), intent(in) :: H_Ref(2)   ! Height reference.
d658 1
d665 1
a665 1
    real(rp) :: D      ! B^2 - 4 a c
d688 1
a688 1
    real(rp) :: DD(merge(0,10,debug))
d692 21
a712 8
    ! Solve 1/2 a p^2 + b p + c to start
    d = b*b - 2.0 * a * c
    if ( d < 0.0 ) then ! Complex solution, assume 1-d pressure
      p = phi_sign*acos(tan_ht/max(tan_ht,0.5*(h_ref(1)+h_ref(2))+r_eq))
      if ( stat < good ) &
        & stat = complex ! In case Newton iteration doesn't converge
        if ( debug ) call output ( p + phi_offset, format='(f15.5)', &
          & after='  Complex starting point', advance='yes' )
d714 1
a714 6
      p = (-b + phi_sign * sqrt(d) ) / a
      if ( p < p_basis(1)-phi_offset .or. p > p_basis(2)-phi_offset ) then
        p = (-b - phi_sign * sqrt(d) ) / a
        if ( p < p_basis(1)-phi_offset .or. p > p_basis(2)-phi_offset ) &
          & p = phi_sign*acos(tan_ht/max(tan_ht,0.5*(h_ref(1)+h_ref(2))+r_eq))
      end if
d716 1
a716 1
    p_path = p + phi_offset
d745 1
a745 1
          if ( debug ) call debug1 ( 1, n, 'GOOD', p_path )
d756 1
a756 1
            call debug1 ( 1, n, 'OUTSIDE', p_path )
d758 1
d771 1
a771 1
      p_path = p + phi_offset
a805 1
      return           ! or even farther over
d807 1
d840 7
d956 1
a956 1
    call get_eta_list ( t_sv%phi_basis, p_path(:n_path), eta_p, sorted=.false. )
d959 1
a959 1
      ! t_ref(vert_inds(i),:) would be a copy.  So we do one row at a time.
d1169 1
d1204 1
a1204 1
       "$Id: metrics_m.f90,v 2.82 2017/08/28 20:28:08 livesey Exp $"
d1214 3
@


2.82
log
@Changed the n,nf,np,nz elements to j,jf,...
@
text
@d903 1
a903 1
    call get_eta_list ( t_sv%phi_basis, p_path(:n_path), eta_p, sorted=.true. )
d1150 1
a1150 1
       "$Id: metrics_m.f90,v 2.81 2017/07/26 20:05:22 vsnyder Exp $"
d1160 3
@


2.81
log
@When the L4 component of Grids_t is constructed, the low bound for the
first subscript is WindowStart, not 1.  That needs to be considered when
looking at L4.
@
text
@d974 2
a975 2
        dHtdTl0_2(i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%n) = &
          dHidTlm(tan_ind,i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%n) * &
d977 2
a978 2
        ddHtdHtdTl0_2(i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%n) = &
          ddHidHidTl0(tan_ind,i,eta_p(n_tan)%v(:eta_p(n_tan)%n)%n) * &
d1000 1
a1000 1
          sv_p = eta_p(i)%v(j)%n
d1019 1
a1019 1
            if ( .not. t_sv%c(1)%l4(1,eta_zp(i)%v(j)%n,ws+eta_zp(i)%v(j)%np-1,1) ) &
d1150 1
a1150 1
       "$Id: metrics_m.f90,v 2.80 2017/03/11 00:56:05 vsnyder Exp $"
d1160 5
@


2.80
log
@Use list interpolation in More_Metrics, cosmetic changes
@
text
@d944 1
d1016 1
d1019 1
a1019 1
            if ( .not. t_sv%c(1)%l4(1,eta_zp(i)%v(j)%n,eta_zp(i)%v(j)%np,1) ) &
d1150 1
a1150 1
       "$Id: metrics_m.f90,v 2.79 2016/11/17 02:06:12 vsnyder Exp $"
d1160 3
@


2.79
log
@Correct some LaTeX
@
text
@a51 1

d64 5
a68 5
    use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE
    use MLSKINDS, only: RP
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use OUTPUT_M, only: OUTPUT
    use TOGGLES, only: SWITCHES
d100 1
a100 1
    real(rp), optional, intent(in) :: Surf_temp(:) ! Surface temperature at phi_basis
d162 3
a164 3
    use CONSTANTS, only: PI, RAD2DEG
    use DUMP_0, only: DUMP
    use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE
d166 6
a171 6
    use IEEE_ARITHMETIC, only: IEEE_IS_NAN
    use MLSKINDS, only: RP
    use MLSMESSAGEMODULE, only: MLSMESSAGE, MLSMSG_ERROR, MLSMSG_WARNING
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use OUTPUT_M, only: OUTPUT
    use TOGGLES, only: SWITCHES
d212 3
a214 3
    integer :: NO_BAD_FITS
    integer :: NO_GRID_FITS
    integer :: N_PATH      ! Path length = 2*(n_vert+ngp1-tan_ind)
d217 1
a217 1
    integer :: P_COEFFS    ! Size(P_basis)
d233 2
a234 2
    real(rp) :: ETA_T(size(p_basis)) ! Interpolating coefficients
    real(rp) :: PHI_OFFSET(size(vert_inds)) ! Orbit projected tangent geodetic
d241 1
a241 1
    real(rp) :: PHI_SIGN(size(vert_inds))   ! +/- 1.0
d445 1
a445 1
      call MLSMessage ( MLSMSG_Warning, ModuleName, &
d598 1
a598 1
    use Output_m, only: OUTPUT
d800 1
d807 1
a807 1
          & Do_Calc_Hyd, Do_Calc_T, Eta_zxp, NZ_Zxp, NNZ_Zxp, Tan_Phi_t )
d814 3
a816 2
    use Dump_NZ_m, only: Dump_NZ
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse, Multiply_Eta_Column_Sparse
d833 4
d859 1
a859 1
    real(rp), optional, intent(out) :: ddHtdHtdTl0(:)  ! Second order
d864 1
a864 1
    real(rp), optional, intent(out) :: dHtdTl0(:)      ! First order derivatives
d869 2
a891 8
    logical :: Not_Zero_p(size(vert_inds),t_sv%l_p(1))
    integer :: col1(size(vert_inds))         ! First nonzero in rows of Eta_P
    integer :: col2(size(vert_inds))         ! Last nonzero in rows of Eta_P
    integer :: NZ_p(size(vert_inds),t_sv%l_p(1)) ! Nonzeros in columns of Eta_P
    integer :: NNZ_p(t_sv%l_p(1)) ! Numbers of rows in NZ_P

    real(rp) :: Eta_p(size(vert_inds),t_sv%l_p(1))

d903 1
a903 5
    nnz_p = 0
    eta_p = 0.0
    not_zero_p = .false.
    call get_eta_sparse ( t_sv%phi_basis, p_path(:n_path), eta_p, 1, n_path, &
      & nz_p, nnz_p, col1, col2, not_zero_p )
d905 4
a908 5
      t_path(i) = dot_product(t_ref(vert_inds(i),col1(i):col2(i)), &
        & eta_p(i,col1(i):col2(i)))
      ! compute the vertical derivative grid
      dHitdZi(i) = dot_product(dHidZij(vert_inds(i),col1(i):col2(i)), &
        & eta_p(i,col1(i):col2(i)))
a909 1

d914 1
a914 2
        & tan_phi_t = dot_product(t_ref(tan_ind,col1(n_tan):col2(n_tan)), &
          & eta_p(n_tan,col1(n_tan):col2(n_tan)))
d916 1
a916 3
        & dhtdzt = dot_product(dHidZij(tan_ind,col1(n_tan):col2(n_tan)), &
          & eta_p(n_tan,col1(n_tan):col2(n_tan)))

d925 1
a925 4
      call dump ( eta_p, name='eta_p', format='(1pg14.6)', options=options )
      call dump ( col1, name='col1', options=options )
      call dump ( col2, name='col2', options=options )
      call dump_nz ( nz_p, nnz_p, what=' in More_Metrics' )
d933 14
a946 7
      use GLNP, only: NGP1
      real(rp) :: ETA_T2(n_path,t_sv%l_z(1)) ! Path X Zeta
      integer :: NZ_T2(n_path,t_sv%l_z(1))   ! Nonzeros in Eta_T2
      integer :: NNZ_T2(t_sv%l_z(1))         ! Numbers of rows in NZ_T2
      integer :: I, J, SV_P, SV_T, SV_Z      ! Loop inductors and subscripts
      integer :: P_Coeffs                    ! t_sv%l_p(1)
      integer :: Z_Coeffs                    ! t_sv%l_z(1)
d956 2
a957 2
      p_coeffs = t_sv%l_p(1)
      z_coeffs = t_sv%l_z(1)
d961 1
a961 2
          & dot_product ( dHidTlm(1,i,col1(n_tan):col2(n_tan)), &
                        & eta_p(n_tan,col1(n_tan):col2(n_tan)) )
d964 3
a967 2
      dHtdTl0 = RESHAPE(dHidTlm(tan_ind,:,:) * SPREAD(eta_p(n_tan,:),1,z_coeffs),&
                     & (/j/))
d969 11
a979 3
      ddHtdHtdTl0 = RESHAPE( &
                   ddHidHidTl0(tan_ind,:,:) * SPREAD(eta_p(n_tan,:),1,z_coeffs), &
                     & (/j/))
d983 28
a1010 31
      nnz_t2 = 0
      eta_t2 = 0.0
      ! Get_Eta_Sparse is called twice because Z_Ref is sorted on N_Tan:1:-1
      ! and on N_Tan+ngp1:
      call get_eta_sparse ( t_sv%zet_basis, z_ref(vert_inds), eta_t2, &
        & n_tan, 1, nz_t2, nnz_t2, .true. )
      call get_eta_sparse ( t_sv%zet_basis, z_ref(vert_inds), eta_t2, &
        & n_tan+ngp1, size(vert_inds), nz_t2, nnz_t2, .true. )

      ! Compute Zeta X Phi interpolation coefficients, noting where the zeros
      ! are.  This is ultimately the same as Comp_Eta_Docalc_No_Frq, but that
      ! doesn't return the Eta_P it computes, which we use above for a one-D
      ! interpolation.
      call multiply_eta_column_sparse ( eta_t2, nz_t2, nnz_t2, eta_p, nz_p, nnz_p, &
        & eta_zxp, nz_zxp, nnz_zxp, do_calc_t )

      ! Compute the path temperature derivative, noting where the zeros are
      sv_t = 0
      do sv_p = 1 , p_coeffs
        do sv_z = 1 , z_coeffs
          sv_t = sv_t + 1
          if ( t_sv%deriv_flags(sv_t) ) then
            dHitdTlm(:,sv_t) = max(dHidTlm(vert_inds,sv_z,sv_p),0.0_rp) * eta_p(:,sv_p)
            do_calc_hyd(:,sv_t) = dHitdTlm(:,sv_t) /= 0.0_rp
          else
            do_calc_hyd(:,sv_t) = .false.
            dHitdTlm(:,sv_t) = 0.0
            eta_zxp(nz_zxp(:nnz_zxp(sv_t),sv_t),sv_t) = 0.0
            do_calc_t(nz_zxp(:nnz_zxp(sv_t),sv_t),sv_t) = .false.
            nnz_zxp(sv_t) = 0
          end if
d1012 11
d1024 3
d1148 1
a1148 1
       "$Id: metrics_m.f90,v 2.78 2016/11/17 01:39:45 vsnyder Exp $"
d1158 3
@


2.78
log
@Change path variable names from xyz_grid to xyz_path
@
text
@d154 1
a154 1
    !{ This subroutine computes {\tt h\_grid} and {\tt p\_grid} that define
d589 1
a589 1
  ! \tau$, where $\phi$ is {\tt p\_grid}, $h$ is {\tt h\_grid}, and $\tau$
d1135 1
a1135 1
       "$Id: metrics_m.f90,v 2.77 2016/10/18 00:25:37 vsnyder Exp $"
d1145 3
@


2.77
log
@Improve comments, some cannobball polishing
@
text
@d150 1
a150 1
                            &  req_s, vert_inds, h_grid, p_grid,       &
d197 1
a197 1
    real(rp), intent(out) :: H_grid(:) ! computed heights, referenced to
d199 1
a199 1
    real(rp), intent(out) :: P_grid(:) ! computed phi's, radians
d275 2
a276 2
    ! p_basis and p_grid are phi's in offset radians relative to
    ! phi_t, that is, the phi_t, p_basis or p_grid = 0.0 is phi_t.
d291 1
a291 1
      ! This expression for p_grid puts the midpoint of the path at the
d293 2
a294 2
      p_grid(n_tan:n_tan+ngp1) = 0.5 * ( phi_offset(n_tan) + phi_offset(n_tan+ngp1) )
      h_grid(n_tan:n_tan+ngp1) = req_s
d297 2
a298 2
      p_grid(n_tan:n_tan+ngp1) = phi_offset(n_tan:n_tan+ngp1)
      h_grid(n_tan:n_tan+ngp1) = tan_ht
d317 1
a317 1
        & '      P          phi    H_GRID   HREF(K,J) HREF(K,J+1)  H(TRIG)    D           N   Diffs'
d332 2
a333 2
      p_grid(i1) = p
      h_grid(i1) = h
d337 1
a337 1
          & print fmt, i1, 0, k, ang*p_grid(i1), h_grid(i1), '  Below p_basis'
d346 2
a347 2
      p_grid(i2) = p
      h_grid(i2) = h
d351 1
a351 1
          & print fmt, i2, p_coeffs, k, ang*p_grid(i2), h_grid(i2), '  Above p_basis'
d354 2
a355 2
        print fmt, ( n_tan+j, 0, vert_inds(n_tan+j), ang*p_grid(n_tan+j), &
                   & h_grid(n_tan+j), '  Tangent point', j = 0, ngp1 )
d398 2
a399 2
          &                h_grid(i), p_grid(i), stat(i), outside )
        if ( IEEE_Is_NaN(p_grid(i)) ) stat(i) = NaN_sol
d401 1
a401 1
          if ( p_grid(i) < p_grid(i-1) ) then ! Phi out of order, can't be right
d455 2
a456 2
        call dump ( h_grid, 'H_Grid before 1d fixup' )
        call dump ( rad2deg*p_grid, 'P_Grid (degrees) before 1d fixup' )
d466 1
a466 1
            h_grid(i1) = dot_product(h_ref(vert_inds(i1),:),eta_t) + r_eq
d474 1
a474 1
            if ( h_grid(j) <= h_grid(j-k) ) then
d476 1
a476 1
                if ( h_grid(j-k) < h_grid(i) ) exit
d479 1
a479 1
                h_grid(j) = h_grid(j-k) + 1.0 ! use SWAG method
d481 1
a481 1
                h_grid(j) = h_grid(j-k) + (h_grid(i)-h_grid(j-k)) * &
d491 1
a491 1
        p_grid = acos(tan_ht/h_grid) * phi_sign + phi_offset
d501 1
a501 1
          h_grid(j) = h_grid(i1) + (h_grid(i2)-h_grid(i1)) * &
d504 1
a504 1
          p_grid(j) = acos(tan_ht/h_grid(j)) * phi_sign(j) + phi_offset(j)
d514 1
a514 1
          h_grid(j) = h_grid(i1) + (h_grid(i2)-h_grid(i1)) * &
d517 1
a517 1
          p_grid(j) = acos(tan_ht/h_grid(j)) * phi_sign(j) + phi_offset(j)
d521 2
a522 2
        call dump ( h_grid, name='H_Grid after 1d fixup' )
        call dump ( rad2deg*p_grid, name='P_Grid (degrees) after 1d fixup' )
d532 1
a532 1
        if ( abs(p_grid(n_tan-1) - p_grid(n_tan)) > 0.9 * pi ) then
d534 2
a535 2
          p_grid(n_tan:n_tan+ngp1) = mod(p_grid(n_tan:n_tan+ngp1) + &
            & sign(pi,p_grid(n_tan-1) - p_grid(n_tan)),pix2)
d547 1
a547 1
      call dump ( rad2deg*p_grid, name='p_grid (degrees) before refractive correction', &
d551 1
a551 1
      call dump ( h_grid, name='h_grid', format='(f14.6)', options=options )
d596 1
a596 1
    &                      h_grid, phi, stat, outside )
d623 1
a623 1
    real(rp), intent(inout) :: H_Grid  ! H solution, inout in case there is none
d637 1
a637 1
    real(rp) :: P_Grid ! Candidate phi solution
d672 1
a672 1
    p_grid = p + phi_offset
d688 2
a689 2
      h_grid = tan_ht * secp
      h = h_grid - r_eq  ! to test against h_ref
d691 1
a691 1
        if ( (p_grid-p_basis(1)) * (p_grid-p_basis(2)) <= 0.0 .and. &
d701 2
a702 2
          if ( debug ) call debug1 ( 1, n, 'GOOD', p_grid )
          phi = p_grid
d705 1
a705 1
        if ( p_grid > p_basis(2) .and. abs(a*(h-h_ref(2))) > tan_ht*abs(d) &
d710 1
a710 1
          phi = p_grid ! so phi has a defined value, even if it's no good
d712 1
a712 1
            call debug1 ( 1, n, 'OUTSIDE', p_grid )
d723 1
a723 1
          call debug1 ( 1, 0, 'STEP ' // merge('P','S',abs(p) < P8Tol), p_grid, p, deriv )
d726 1
a726 1
      p_grid = p + phi_offset
d733 1
a733 1
          call debug1 ( max(n-3,1), n-1, merge('CONVERGE', 'BOUNDS  ', abs(d) < tol), p_grid, &
d736 1
a736 1
          call debug1 ( max(n-3,1), n-1, 'NONE', p_grid, p_print=p )
d739 1
a739 1
    phi = p_grid ! make sure it has a defined value, even if it's no good
d742 3
a744 3
        & abs(p_grid-p_basis(1)) < abs(p_grid-p_basis(2)) ) then
        h_grid = h_ref(1) + r_eq
        if ( h_grid > tan_ht ) then
d750 3
a752 3
        & abs(p_grid-p_basis(2)) < abs(p_grid-p_basis(1)) ) then
        h_grid = h_ref(2) + r_eq
        if ( h_grid > tan_ht ) then
d759 1
a759 1
    if ( p_grid > p_basis(2) .and. inside ) then
d782 1
a782 1
        write (*, 100, advance='no') ang*phi, h_grid, &
d800 1
a800 1
          & Tan_Ind, N_Tan, P_Basis, Vert_Inds, T_Ref, dHidZij, P_Grid, &
d802 1
a802 1
          & T_Grid, dHitdZi,                                            &
d804 1
a804 1
          & ddHidHidTl0, dHidTlm, T_Deriv_Flag, Z_Basis, Z_Ref,         &
d806 1
a806 1
          & ddHtdHtdTl0, dHitdTlm, dHtdTl0, dHtdZt,                     &
d809 2
a810 2
    ! This subroutine computes metrics-related things after H_Grid and
    ! P_Grid are computed by Height_Metrics, and then perhaps augmented
d813 8
a820 6
    use DUMP_0, only: DUMP
    use DUMP_NZ_M, only: DUMP_NZ
    use GET_ETA_MATRIX_M, only: GET_ETA_SPARSE, MULTIPLY_ETA_COLUMN_SPARSE
    use MLSKINDS, only: RP
    use MLSSTRINGLISTS, only: SWITCHDETAIL
    use TOGGLES, only: SWITCHES
d826 1
a826 2
    real(rp), intent(in) :: P_Basis(:)  ! Horizontal temperature representation
    !                                     basis
d829 3
a831 3
    real(rp), intent(in) :: T_Ref(:,:)  ! Temperatures at Z_Ref X P_Basis
    real(rp), intent(in) :: dHidZij(:,:)! Vertical derivative at Z_Ref X P_Basis
    real(rp), intent(in) :: P_Grid(:)   ! Phi's on the path
d835 2
a836 2
    real(rp), intent(out) :: T_Grid(:) ! computed temperatures
    real(rp), intent(out) :: dHitdZi(:)! derivative of height wrt zeta
a847 4
    logical, optional, intent(in) :: T_Deriv_Flag(:)  ! User's deriv. flags for
    !          Temperature.  Needed only if present(dHidTlm).
    real(rp), optional, intent(in) :: Z_Basis(:) ! Vertical temperature basis.
    !          Needed only if present(dHidTlm).
d858 1
a858 1
    !          position wrt temperature state vector (z_basis X phi_basis)
d883 1
a883 1
    integer :: N_PATH      ! Path length = size(vert_inds)
d885 5
a889 5
    logical :: NOT_ZERO_P(size(vert_inds),size(p_basis))
    integer :: col1(size(vert_inds))        ! First nonzero in rows of Eta_P
    integer :: col2(size(vert_inds))        ! Last nonzero in rows of Eta_P
    integer :: NZ_P(size(vert_inds),size(p_basis)) ! Nonzeros in columns of Eta_P
    integer :: NNZ_P(size(p_basis))         ! Numbers of rows in NZ_P
d891 1
a891 1
    real(rp) :: ETA_P(size(vert_inds),size(p_basis))
d902 1
a902 1
    ! (dHidZij) to the path (T_Grid and dHitdZi).
d907 1
a907 1
    call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p, 1, n_path, &
d910 1
a910 1
      t_grid(i) = dot_product(t_ref(vert_inds(i),col1(i):col2(i)), &
d928 1
a928 1
      if ( present(dHidTlm) ) call Temperature_Derivatives ( size(z_basis) )
d933 1
a933 1
      call dump ( t_grid(:n_path), name='t_grid', format='(1pg14.6)', options=options )
d944 2
a945 4
    subroutine Temperature_Derivatives ( Z_Coeffs )
      ! This is a subroutine instead of inline so that the references to the
      ! size of Z_Basis in the dimensions of automatic variables are only
      ! attempted if Z_Basis is present.  But we could have used size(T_Ref,1).
d947 6
a952 6
      integer, intent(in) :: Z_Coeffs     ! size(z_basis)
      real(rp) :: ETA_T2(n_path,z_coeffs) ! Path X Zeta
      integer :: NZ_T2(n_path,z_coeffs)   ! Nonzeros in Eta_T2
      integer :: NNZ_T2(z_coeffs)         ! Numbers of rows in NZ_T2
      integer :: I, J, SV_P, SV_T, SV_Z   ! Loop inductors and subscripts
      integer :: P_Coeffs                 ! size(p_basis)
d962 3
a970 1
      p_coeffs = size(p_basis)
d979 2
a980 1
      ! Compute Zeta interpolation coefficients, noting where the zeros are
d985 1
a985 1
      call get_eta_sparse ( z_basis, z_ref(vert_inds), eta_t2, &
d987 1
a987 1
      call get_eta_sparse ( z_basis, z_ref(vert_inds), eta_t2, &
d1002 1
a1002 1
          if ( t_deriv_flag(sv_t) ) then
d1022 1
a1022 1
                         &  h_surf, h_tan, p_grid,                        &
d1047 1
a1047 1
    real(rp), intent(in) :: p_grid(:)  ! From Height_Metrics
d1113 1
a1113 1
            if ( minval(abs(p_new(n_new)-p_grid)) < 1.0e-4 ) then
d1135 1
a1135 1
       "$Id: metrics_m.f90,v 2.76 2016/08/20 00:55:08 vsnyder Exp $"
d1145 3
@


2.76
log
@Correct comments about units for Phi_t and P_Basis in Tangent_Metrics
@
text
@d800 1
a800 1
          & tan_ind, n_tan, p_basis, vert_inds, t_ref, dhidzij, p_grid, &
d802 1
a802 1
          & t_grid, dhitdzi,                                            &
d804 1
a804 1
          & ddhidhidtl0, dhidtlm, t_deriv_flag, z_basis, z_ref,         &
d806 2
a807 2
          & ddhtdhtdtl0, dhitdtlm, dhtdtl0, dhtdzt,                     &
          & do_calc_hyd, do_calc_t, eta_zxp, nz_zxp, nnz_zxp, tan_phi_t )
d821 1
a821 1
    integer, intent(in) :: tan_ind     ! tangent height index, 1 = center of
d823 2
a824 2
    integer, intent(in) :: n_tan       ! tangent index in path, usually n_path/2
    real(rp), intent(in) :: p_basis(:) ! horizontal temperature representation
d826 5
a830 4
    integer, intent(in) :: vert_inds(:) ! What to use in [zt]_ref
    real(rp), intent(in) :: t_ref(:,:) ! temperatures at z_ref X p_basis
    real(rp), intent(in) :: dhidzij(:,:)! vertical derivative at z_ref X p_basis
    real(rp), intent(in) :: p_grid(:)  ! phi's on the path
d834 2
a835 2
    real(rp), intent(out) :: t_grid(:) ! computed temperatures
    real(rp), intent(out) :: dhitdzi(:)! derivative of height wrt zeta
d840 41
a880 37
    real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:) ! second order reference
    !   temperature derivatives. This is (height, phi_basis, zeta_basis).
    !   Needed only if present(dhidtlm).
    real(rp), optional, intent(inout) :: dhidtlm(:,:,:) ! reference temperature
    !   derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is 0.0 for
    !   all temperature coefficients. This is height X zeta_basis X phi_basis
    logical, optional, intent(in) :: t_deriv_flag(:)  ! User's deriv. flags for
    !   Temperature. needed only if present(dhidtlm).
    real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
    !   Needed only if present(dhidtlm).
    real(rp), optional, intent(in) :: z_ref(:)   ! -log pressures (zetas) for
    !   which derivatives are needed.  Only the parts from the tangent outward
    !   are used.  Needed only if present(dhidtlm).

    ! optional outputs.

    real(rp), optional, intent(out) :: ddhtdhtdtl0(:) ! Second order 
    !          derivative at the tangent only---used for antenna affects.
    !          Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: dhitdtlm(:,:)
    !                             derivative of path position wrt temperature
    !                             statevector (z_basis X phi_basis)
    real(rp), optional, intent(out) :: dhtdtl0(:)  ! First order derivative at
    !           the tangent.  Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: dhtdzt      ! height derivative wrt
    !                                                pressure at the tangent
    logical, optional, intent(out) :: do_calc_hyd(:,:) ! nonzero locator for
    !           hydrostatic calculations.  Computed if present(dhidtlm)
    logical, optional, intent(inout) :: do_calc_t(:,:) ! nonzero locater for
    !           temperature bases computations.  Computed if present(dhidtlm).
    !           intent(inout) instead of intent(out) so as not to make parts we
    !           don't touch undefined.
    real(rp), optional, intent(inout) :: eta_zxp(:,:) ! eta matrix for temperature
    !           Computed if present(dhidtlm)
    integer, optional, intent(inout) :: NZ_ZXP(:,:)   ! Nonzeros in Eta_zxp
    integer, optional, intent(inout) :: NNZ_ZXP(:)    ! Numbers of rows in NZ_ZXP
    real(rp), optional, intent(out) :: tan_phi_t ! temperature at the tangent
d905 1
a905 1
    ! (dhidzij) to the path (T_Grid and dhitdzi).
d916 1
a916 1
      dhitdzi(i) = dot_product(dhidzij(vert_inds(i),col1(i):col2(i)), &
d920 1
a920 1
    ! now for the optional tangent quantities.
d922 1
d927 1
a927 1
        & dhtdzt = dot_product(dhidzij(tan_ind,col1(n_tan):col2(n_tan)), &
d930 2
a931 2
      ! compute tangent temperature derivatives
      if ( present(dhidtlm) ) call Tangent_Temperature_Derivatives ( size(z_basis) )
d937 1
a937 1
      call dump ( dhitdzi(:n_path), name='dhitdzi', format='(1pg14.6)', options=options )
d947 4
a950 4
    subroutine Tangent_Temperature_Derivatives ( N )
      ! This is a subroutine instead of inline so that the references
      ! to Z_Basis in the dimensions of automatic variables are only
      ! attempted if Z_Basis is present.
d952 13
a964 14
      integer, intent(in) :: N
      real(rp) :: ETA_T2(n_path,n)    ! n = size(z_basis)
      integer :: NZ_T2(n_path,n)      ! Nonzeros in Eta_T2
      integer :: NNZ_T2(n)            ! Numbers of rows in NZ_T2
      integer :: I, J, SV_P, SV_T, SV_Z ! Loop inductors and subscripts
      integer :: P_COEFFS    ! size(p_basis)
      integer :: Z_COEFFS    ! size(z_basis)

      ! Adjust the 2d hydrostatic relative to the surface. Even though
      ! this is updated on every invocation, that is, with a new phi_t, it
      ! works as if the original value were updated with the current
      ! phi_t, because the interpolation represented by eta_p is linear.
      ! Thus, the effect of cumulative updates for each new phi_t are the
      ! same as starting from the original dhidtlm and updating with the
d966 1
a966 2
      p_coeffs = size(p_basis)
      z_coeffs = size(z_basis)
d968 3
a970 3
        dhidtlm(:,i,:) = dhidtlm(:,i,:) - &
          & dot_product(dhidtlm(1,i,col1(n_tan):col2(n_tan)), &
            & eta_p(n_tan,col1(n_tan):col2(n_tan)))
d973 1
d975 1
a975 1
      dhtdtl0 = RESHAPE(dhidtlm(tan_ind,:,:) * SPREAD(eta_p(n_tan,:),1,z_coeffs),&
d978 2
a979 2
      ddhtdhtdtl0 = RESHAPE( &
                   ddhidhidtl0(tan_ind,:,:) * SPREAD(eta_p(n_tan,:),1,z_coeffs), &
d982 1
a982 1
      ! compute the path temperature, noting where the zeros are
d985 2
d988 1
a988 1
        & n_tan, 1, nz_t2, nnz_t2, .false. )
d992 4
d999 1
d1005 2
a1006 2
            dhitdtlm(:,sv_t) = max(dhidtlm(vert_inds,sv_z,sv_p),0.0_rp) * eta_p(:,sv_p)
            do_calc_hyd(:,sv_t) = dhitdtlm(:,sv_t) /= 0.0_rp
d1009 1
a1009 1
            dhitdtlm(:,sv_t) = 0.0
d1017 1
a1017 1
    end subroutine Tangent_Temperature_Derivatives
d1137 1
a1137 1
       "$Id: metrics_m.f90,v 2.75 2015/09/22 01:59:32 vsnyder Exp $"
d1147 3
@


2.75
log
@Correct some comments, dump Z
@
text
@d74 1
a74 1
                                       ! degrees
d76 1
a76 1
                                       ! basis, degrees
d1125 1
a1125 1
       "$Id: metrics_m.f90,v 2.74 2015/05/28 23:14:42 vsnyder Exp $"
d1135 3
@


2.74
log
@Add units in comments about variables
@
text
@d14 2
a15 2
  use CONSTANTS, only: RAD2DEG
  use MLSKINDS, only: RP
d22 1
a22 1
  ! Values for stat argument to/from Solve_H_Phi:
d47 1
a47 1
  character(len=4), parameter :: options=' '
d180 1
a180 1
    !                                    basis, degrees
d199 1
a199 1
    real(rp), intent(out) :: P_grid(:) ! computed phi's, degrees
d552 1
d1125 1
a1125 1
       "$Id: metrics_m.f90,v 2.73 2013/06/12 02:32:30 vsnyder Exp $"
d1135 3
@


2.73
log
@Cruft removal
@
text
@d73 2
a74 1
    real(rp), intent(in) :: Phi_t      ! orbit projected tangent geodetic angle
d76 4
a79 2
                                       ! basis
    real(rp), intent(in) :: H_ref(:,:) ! heights by fine zeta and p_basis
d87 3
a89 1
                                       ! else interpolated in row 1 of H_REF.
d91 3
a93 1
    !                                  ! for Earth-intersecting rays)
d106 2
a107 2
    integer :: First, Last           ! Nonzeros in Eta_T
    real(rp) :: ETA_T(size(p_basis)) ! Interpolating coefficients
d178 1
a178 1
    !                                     longest path
d180 2
a181 2
    !                                     basis
    real(rp), intent(in) :: H_ref(:,:) ! Heights by z_ref and p_basis
d183 1
a183 1
    !                                     surface z_ref(1) above R_eq at phi_t
d185 1
a185 1
    !                                     for Earth-intersecting ray
d187 2
a188 2
    !                                     heights/temps are needed.  Only used
    !                                     where H/Phi iteration fails.
d190 1
a190 1
    !                                     true surface at Phi_T
d193 3
a195 3
    real(rp), intent(out) :: Req_s       ! H_Surf + R_Eq, Equivalent circular
    !                                      earth radius of pressure reference
    !                                      surface at Phi_T
d197 3
a199 2
    real(rp), intent(out) :: H_grid(:)   ! computed heights, referenced to Earth center
    real(rp), intent(out) :: P_grid(:)   ! computed phi's
d203 4
a206 4
                                         ! for convergence of phi/h iteration
    logical, optional, intent(in) :: Forward   ! for subsurface rays, indicates
                                         ! xi >= xi_sub (see Generate_TScat in
                                         ! FullForwardModel)
d600 1
a600 3
    real(rp), intent(in) :: P_Basis(:) ! Coordinates for H_Ref.  Actually 1:2,
                                       ! but we don't want to force copy-in if
                                       ! the actual argument isn't contiguous.
d608 2
a609 3
    real(rp), intent(in) :: H_Ref(:)   ! Height reference.  Actually 1:2,
                                       ! but we don't want to force copy-in if
                                       ! the actual argument isn't contiguous.
d615 6
a620 4
      ! A, B and C are coefficients of a quadratic approximation to the solution
    real(rp), intent(in) :: Tan_Ht     ! From center, H_Tan + r_eq
    real(rp), intent(in) :: R_eq       ! From center of equivalent circular earth
    real(rp), intent(in) :: Tol        ! Height tolerance for Newton convergence
d638 1
a638 1
    real(rp) :: Secp   ! 1/Cos(p), to compute SecM1 when p > p8Tol
d651 1
a651 1
    real(rp) :: DD(10)
d1124 1
a1124 1
       "$Id: metrics_m.f90,v 2.72 2013/05/21 23:55:14 vsnyder Exp $"
d1134 3
@


2.72
log
@Compute No_Bad_Fits correctly, revise dump switches
@
text
@a47 1
  logical, parameter :: Degrees = .true.
a235 1
    real(rp), parameter :: Pid2 = 0.5*pi
a873 1
    integer :: N_VERT      ! size(z_ref)
a888 1
    n_vert = size(t_ref,1)
d1117 1
a1117 1
       "$Id: metrics_m.f90,v 2.71 2013/05/18 00:34:44 vsnyder Exp $"
d1127 3
@


2.71
log
@Insert NG fine-grid (GL) points between tangent points, thereby
regularizing coarse-grid spacing, and reducing significantly the need
to use c_inds to extract coarse-grid points from the composite grid.
@
text
@d131 1
a131 1
    if ( max(switchDetail(switches,'metD'),switchDetail(switches,'metd')) > -1 ) then
d202 2
a203 3
    integer :: Do_Dumps    ! 0 = no dump, >0 = dump
    integer :: H_Phi_Dump  ! 0 = no dump, >0 = dump
    integer :: H_Phi_Stop  ! 0 = no dump, >0 = dump/stop
d247 2
a248 5
      do_dumps = max( &
        & switchDetail(switches,'metD'),switchDetail(switches,'metd') &
        & ) + 1
      h_phi_stop = switchDetail(switches,'hphI')
      h_phi_dump = max(h_phi_stop,switchDetail(switches,'hphi')) + 1
d305 1
a305 1
    if ( h_phi_dump > 0 ) call dumpInput ( tan_ind )
d313 2
a314 1
    no_bad_fits = n_path - ng
d442 1
a442 1
      if ( switchDetail(switches,'MHPX') > -1 .or. switchDetail(switches,'mhpx') > -1 ) then
d514 1
a514 1
      if ( switchDetail(switches,'MHPX') > -1 .or. switchDetail(switches,'mhpx') > -1 ) then
d517 2
a518 2
        if ( switchDetail(switches,'MHPX') > -1 ) &
        call MLSMessage ( MLSMSG_Error, moduleName, 'Halt requested by MHPX' )
d538 1
a538 1
    if ( do_dumps > 0 ) then
d543 1
a543 1
      if ( h_phi_dump == 0 ) &
d873 1
a873 2
    integer :: Do_Dumps    ! 0 = no dump, >0 = dump
    integer :: Dump_Stop   ! 0 = no dump, >0 = dump/stop
d889 1
a889 2
      dump_stop = switchDetail(switches,'metD') + 1
      do_dumps = max( dump_stop, switchDetail(switches,'metd') + 1 )
d924 1
a924 1
    if ( do_dumps > 0 ) then
d932 1
a932 1
      if ( dump_stop > 0 ) stop
d1121 1
a1121 1
       "$Id: metrics_m.f90,v 2.70 2013/03/30 00:06:11 vsnyder Exp $"
d1131 5
@


2.70
log
@Put dummy argument declarations in same order as in subroutine statement
@
text
@d160 1
d209 2
a210 2
    integer :: N_PATH      ! Path length = 2*(n_vert+1-tan_ind)
    integer :: N_Tan       ! Tangent index in path, N_Path/2
d256 1
a256 1
    n_tan = n_path / 2
d270 2
a271 2
    ! The tangent point is special
    stat(n_tan:n_tan+1) = good
d281 1
d286 2
a287 2
        phi_offset(:n_tan) = phi_t
        phi_offset(n_tan+1:) = phi_t - theta
d291 2
a292 2
      p_grid(n_tan:n_tan+1) = 0.5 * ( phi_offset(n_tan) + phi_offset(n_tan+1) )
      h_grid(n_tan:n_tan+1) = req_s
d295 2
a296 2
      p_grid(n_tan:n_tan+1) = phi_offset(n_tan:n_tan+1)
      h_grid(n_tan:n_tan+1) = tan_ht
d302 2
a303 1
    vert_inds = (/ (i, i=n_vert,tan_ind,-1), (i, i=tan_ind,n_vert) /)
d306 2
a307 1
    phi_sign = (/ (-1, i=n_vert,tan_ind,-1), (+1, i=tan_ind,n_vert) /)
d317 1
a317 1
    no_bad_fits = n_path - 2
d321 2
a322 1
    ! outside of p_basis.
d324 1
a324 1
      if ( stat(i1) == good ) cycle ! Skip the tangent point
d328 1
a328 1
      if ( p >= p_basis(1) ) exit ! phi is monotone
d338 1
a338 1
      if ( stat(i2) == good ) cycle ! Skip the tangent point
d342 1
a342 1
      if ( p <= p_basis(p_coeffs) ) exit ! phi is monotone
d351 2
a352 2
        print fmt, n_tan, 0, vert_inds(n_tan), ang*p_grid(n_tan), h_grid(n_tan), '  Tangent point'
        print fmt, n_tan+1, 0, vert_inds(n_tan+1), ang*p_grid(n_tan+1), h_grid(n_tan+1), '  Tangent point'
d484 1
a484 1
          i1 = n_tan + 2
d503 1
a503 1
        do j = n_tan+2, n_path-1
d508 1
a508 1
          do i1 = j, n_tan+1, -1
d531 1
a531 1
          p_grid(n_tan:n_tan+1) = mod(p_grid(n_tan:n_tan+1) + &
d564 2
a565 2
        call output ( n_tan+1, before=':', after=') (radians) ' )
        call dump ( phi_offset(n_tan:n_tan+1), options='c' ) ! clean=.true.
d567 2
a568 2
        call output ( n_tan+1, before=':', after=') (degrees) ' )
        call dump ( rad2deg*phi_offset(n_tan:n_tan+1), options='c' ) ! clean=.true.
d776 1
a776 1
        if ( abs(h+r_eq-tan_ht/cos(p)) > 5.0e-4 ) oops='TRIG'
d781 2
a782 2
          & tan_ht / cos(p), &
        ! & tan_ht * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ tan_ht * sec(p)
d946 1
d978 1
a978 1
      ! compute the path temperature noting where the zeros are
d984 1
a984 1
        & n_tan+1, size(vert_inds), nz_t2, nnz_t2, .true. )
d1126 1
a1126 1
       "$Id: metrics_m.f90,v 2.69 2013/02/28 21:08:29 vsnyder Exp $"
d1136 3
@


2.69
log
@Try not to access array out of bounds
@
text
@d818 1
a821 1
    integer, intent(in) :: vert_inds(:) ! What to use in [zt]_ref
d1120 1
a1120 1
       "$Id: metrics_m.f90,v 2.68 2011/05/09 18:02:19 pwagner Exp $"
d1130 3
@


2.68
log
@Converted to using switchDetail
@
text
@d912 7
a918 6
    if ( present(tan_phi_t) ) &
      & tan_phi_t = dot_product(t_ref(tan_ind,col1(n_tan):col2(n_tan)), &
        & eta_p(n_tan,col1(n_tan):col2(n_tan)))
    if ( present(dhtdzt) ) &
      & dhtdzt = dot_product(dhidzij(tan_ind,col1(n_tan):col2(n_tan)), &
        & eta_p(n_tan,col1(n_tan):col2(n_tan)))
d920 3
a922 2
    ! compute tangent temperature derivatives
    if ( present(dhidtlm) ) call Tangent_Temperature_Derivatives ( size(z_basis) )
d1064 1
a1064 1
    do i = tan_ind, 1, -1
d1120 1
a1120 1
       "$Id: metrics_m.f90,v 2.67 2010/02/04 23:10:20 vsnyder Exp $"
d1130 3
@


2.67
log
@Remove USE for unreferenced names
@
text
@d14 2
a15 2
  use Constants, only: Rad2Deg
  use MLSKinds, only: RP
d66 5
a70 4
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
    use MLSKinds, only: RP
    use Output_m, only: OUTPUT
    use Toggles, only: Switches
d131 1
a131 1
    if ( max(index(switches,'metD'),index(switches,'metd')) > 0 ) then
d157 9
a165 8
    use Constants, only: Pi, Rad2Deg
    use Dump_0, only: Dump
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
    use IEEE_Arithmetic, only: IEEE_Is_NaN
    use MLSKinds, only: RP
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
    use Output_m, only: OUTPUT
    use Toggles, only: Switches
d247 5
a251 3
      do_dumps = max(index(switches,'metD'),index(switches,'metd'))
      h_phi_stop = index(switches,'hphI')
      h_phi_dump = max(h_phi_stop,index(switches,'hphi'))
d440 1
a440 1
      if ( index(switches,'MHPX') /= 0 .or. index(switches,'mhpx') /= 0 ) then
d512 1
a512 1
      if ( index(switches,'MHPX') /= 0 .or. index(switches,'mhpx') /= 0 ) then
d515 1
a515 1
        if ( index(switches,'MHPX') /= 0 ) &
d805 6
a810 5
    use Dump_0, only: Dump
    use Dump_NZ_m, only: Dump_NZ
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse, Multiply_Eta_Column_Sparse
    use MLSKinds, only: RP
    use Toggles, only: Switches
d888 2
a889 2
      dump_stop = index(switches,'metD')
      do_dumps = max(dump_stop,index(switches,'metd'))
d1014 1
a1014 1
    use MLSKinds, only: RP
d1118 1
a1118 1
       "$Id: metrics_m.f90,v 2.66 2010/02/02 01:34:55 vsnyder Exp $"
d1128 3
@


2.66
log
@Make do_calc_t intent(inout)
@
text
@d67 1
a67 3
    use GLNP, only: NGP1
    use Make_Z_Grid_m, only: Default_Thresh ! Threshold for rejecting duplicates
    use MLSKinds, only: RP, R8
a157 1
    use Geometry, only: Get_R_Eq
d1113 1
a1113 1
       "$Id: metrics_m.f90,v 2.65 2009/12/15 03:20:06 vsnyder Exp $"
d1123 3
@


2.65
log
@Don't force phi_offset to -pix2..pix2 for Earth-intersecting rasy
@
text
@d857 4
a860 2
    logical, optional, intent(out) :: do_calc_t(:,:) ! nonzero locater for
    !           temperature bases computations.  Computed if present(dhidtlm)
d1116 1
a1116 1
       "$Id: metrics_m.f90,v 2.64 2009/12/09 21:32:03 vsnyder Exp $"
d1126 3
@


2.64
log
@Remove ill-advised mod on p_grid
@
text
@d280 2
a281 2
        phi_offset(1:n_tan) = mod(phi_t + theta, pix2)
        phi_offset(n_tan+1:) = mod(phi_t, pix2)
d283 2
a284 2
        phi_offset(:n_tan) = mod(phi_t, pix2)
        phi_offset(n_tan+1:) = mod(phi_t - theta, pix2)
d1114 1
a1114 1
       "$Id: metrics_m.f90,v 2.63 2009/08/20 23:30:56 vsnyder Exp $"
d1124 3
@


2.63
log
@Handwaving to put p_grid in -2 pi .. 2 pi and the reflection point of
an Earth-intersecting path on the same side of the Earth as the rest of
the path.
@
text
@a518 3
    ! Put angles in -2 pi .. 2 pi
    p_grid(:n_path) = mod(p_grid(:n_path),pix2)

d1114 1
a1114 1
       "$Id: metrics_m.f90,v 2.62 2009/06/23 18:26:11 pwagner Exp $"
d1124 5
@


2.62
log
@Prevent Intel from optimizing ident string away
@
text
@d35 1
a35 1
       "$RCSfile: $"
d519 14
a532 5
!     if ( maxval(p_grid) < -pix2 ) then
!       p_grid = p_grid + pix2
!     else if ( minval(p_grid) > pix2 ) then
!       p_grid = p_grid - pix2
!     end if
d1117 1
a1117 1
       "$Id: read_apriori.f90 is it here $"
d1127 3
@


2.61
log
@Changed api for dump, diff routines; now rely on options for most optional behavior
@
text
@d35 1
a35 1
       "$RCSfile: metrics_m.f90,v $"
d1105 1
a1106 1
!---------------------------- RCS Ident Info -------------------------------
d1108 2
a1109 3
       "$Id: metrics_m.f90,v 2.60 2009/06/13 01:14:29 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1111 1
a1111 1
    print *, not_used_here ! .mod files sometimes change if PRINT is added
d1113 1
d1118 3
@


2.60
log
@Extensive changes almost everywhere.  Correct many problems with
Earth-reflecting rays.
@
text
@d46 2
a47 1
  logical, parameter :: Clean = .false.
d533 1
a533 1
        & format='(f14.8)', clean=clean )
d535 2
a536 2
        & call dump ( rad2deg*p_basis, name='p_basis (degrees)', format='(f14.6)', clean=clean )
      call dump ( h_grid, name='h_grid', format='(f14.6)', clean=clean )
d545 1
a545 1
      call dump ( rad2deg*p_basis, name='p_basis (degrees)', format='(f14.6)', clean=clean )
d553 1
a553 1
        call dump ( phi_offset(n_tan:n_tan+1), clean=.true. )
d556 1
a556 1
        call dump ( rad2deg*phi_offset(n_tan:n_tan+1), clean=.true. )
d558 1
a558 1
      call dump ( h_ref(firstRow:n_vert,:), name='h_ref', format='(f14.7)',clean=clean )
d913 6
a918 6
      call dump ( t_ref, name='t_ref', format='(1pg14.6)', clean=clean )
      call dump ( t_grid(:n_path), name='t_grid', format='(1pg14.6)', clean=clean )
      call dump ( dhitdzi(:n_path), name='dhitdzi', format='(1pg14.6)', clean=clean )
      call dump ( eta_p, name='eta_p', format='(1pg14.6)', clean=clean )
      call dump ( col1, name='col1', clean=clean )
      call dump ( col2, name='col2', clean=clean )
d1108 1
a1108 1
       "$Id: metrics_m.f90,v 2.59 2008/06/26 00:28:16 vsnyder Exp $"
d1118 4
@


2.59
log
@Cannonball polishing
@
text
@d14 1
d24 3
a26 1
  integer, parameter, public :: Complex = 1 ! Complex start for Newton iteration
d28 1
a28 1
  integer, parameter, public :: Good = 2    ! Newton converged, tangent point, extrapolated
d30 2
a31 2
  integer, parameter, public :: Grid1 = 3   ! Close to left grid point
  integer, parameter, public :: Grid2 = 4   ! Close to right grid point
d47 5
d57 1
a57 3
  subroutine Tangent_Metrics ( Phi_T, P_Basis, Z_Ref, H_Ref, Csq, &
                               ! Inout
    &                          Tan_Ind_C, NZ, &
d59 1
a59 1
    &                          R_eq, H_Surf, H_Tan, Z_Ref_New, &
d61 1
a61 1
    &                          Tan_press, Surf_temp, Surf_height )
d63 1
a63 5
  ! Compute the surface height, the tangent height, and the equivalent
  ! spherical earth radius.
  ! If the ray is an Earth-intersecting ray (H_TAN < 0) determine whether to
  ! copy Z_Ref to Z_Ref_New and add a new Zeta to it, in which case NZ =
  ! size(Z_Ref) + 1, else NZ = size(Z_Ref).
a64 1
    use Geometry, only: EarthRadA
d74 2
a75 2
    real(rp), intent(in) :: phi_t      ! orbit projected tangent geodetic angle
    real(rp), intent(in) :: p_basis(:) ! horizontal temperature representation
d77 3
a79 13
    real(rp), intent(in) :: z_ref(:)   ! Coarse grid of -log pressures (zetas).
    real(rp), intent(in) :: h_ref(:,:) ! heights by fine zeta and p_basis
    real(rp), intent(in) :: csq        ! (minor axis of orbit plane projected
                                       ! Earth ellipse)**2

    ! inout
    integer, intent(inout) :: tan_ind_c ! Index of tangent in Z_Ref.  For an
                                       ! Earth-intersecting ray, it might be
                                       ! changed to a value such that
                                       ! Z_Ref_New(tan_ind_c) = Z_Tan.
    integer, intent(inout) :: NZ       ! Effective size of Z_Ref_New, increased
                                       ! by 1 if a new Earth-intersecting zeta
                                       ! is inserted.
a81 2
    real(rp), intent(out) :: R_eq      ! equivalent elliptical earth radius at
                                       ! H_Surf
d83 3
a85 3
                                       ! surface -- interpolated in Surf_Height
                                       ! if present(Surf_Height) else
                                       ! interpolated in row 1 of H_REF.
a87 6
    real(rp), intent(out) :: Z_Ref_New(:) ! Coarse grid of -log pressures (zetas).
                                       ! If the ray intersects the Earth
                                       ! surface, and the zeta of the
                                       ! intersection is sufficiently different
                                       ! from elements of Z_Ref, Z_Ref is copied
                                       ! here and a new one is added.
d90 4
a93 3
    ! We have Tan_Press and Surf_Temp if the pointing is below the surface
    ! index (where zeta < -3) and we don't have Surf_Height.  Otherwise
    ! we have Surf_Height.
d100 1
a100 5
    real(r8), parameter :: EarthRadA_2 = EarthRadA**2, EarthRadA_4 = EarthRadA**4

    integer :: Do_Dumps
    integer :: First, Last ! Nonzeros in Eta_T
    real(rp) :: CP2, SP2   ! Cos^2 phi_t, Sin^2 phi_t
a101 8
    real(rp) :: H_T1, H_T2 ! Used to determine where H_Tan is in H_Ref
    real(rp) :: R          ! H_T2/(H_T1-H_T2), used for interpolating in Z_Ref
    integer :: Tan_Ind_F   ! Tangent index in H_Ref, which is on fine Zeta grid
    real(rp) :: Z_Tan      ! Zeta at H_Tan

    do_dumps = max(index(switches,'metD'),index(switches,'metd'))

    tan_ind_f = (tan_ind_c-1) * ngp1 + 1
d108 2
a109 2
      ! have it, and adjust the r_eq and the h_tan relative to this, and
      ! adjust h_ref accordingly.
d113 2
a114 2
      ! reference at the input z_ref(1) and adjust the r_eq and the h_tan
      ! relative to this, and adjust h_ref accordingly.
d118 3
a120 21
    !{ Compute equivalent earth radius (\tt{r\_eq}) at phi\_t(1) (nearest
    ! surface) and adjust to the input z\_grid(1) using Equation (5.21) in
    ! the 19 August 2004 ATBD JPL D-18130.
    !
    ! $c^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$.
    ! This is Equation (5.3) in the 19 August 2004 ATBD JPL D-18130.
    !
    ! $R^\oplus_{\text{eq}} \equiv H^\oplus_t =
    ! N(\phi_t) \sqrt{\sin^2 \phi_t + \frac{c^4}{a^4}\cos^2 \phi_t} + h_{\text{surf}} =
    ! \sqrt{\frac{a^4 \sin^2 \phi_t + c^4 \cos^2 \phi_t}
    !            {a^2 \cos^2 \phi_t + c^2 \sin^2 \phi_t}} + h_{\text{surf}}$
    !
    ! $a$ and $c$ are in meters; we want $R^\oplus_{\text{eq}}$ in kilometers.

    cp2 = cos(phi_t)**2
    sp2 = 1.0_rp - cp2
    r_eq = 0.001_rp*sqrt((earthrada_4*sp2 + csq**2*cp2) / &
                      & (earthrada_2*cp2 + csq*sp2)) + h_surf

    ! compute the tangent height distance above H_surf.
    if ( present(tan_press) .and. .not. present(surf_height) ) then
d122 3
a124 1
      ! below surface. This will be negative because tan_press < z_ref(1).
d126 1
a126 1
        &     (tan_press-z_ref(1))/14.8
d131 1
a131 31
    ! Determine whether the ray intersects the Earth surface
    if ( h_tan < 0.0 ) then ! Earth intersecting ray
      ! Find where h_tan is in h_ref
      h_t1 = h_tan
      do tan_ind_f = tan_ind_f, size(h_ref,1), ngp1
        h_t2 = dot_product(h_ref(tan_ind_f+ngp1,first:last),eta_t(first:last)) &
          &    - h_surf
        if ( h_t2 >= 0 ) exit
        h_t1 = h_t2
      end do
      tan_ind_c = tan_ind_f/ngp1 + 1
      ! h_t1 < 0 <= h_t2 here, so z_ref(tan_ind_c) <= z_tan <= z_ref(tan_ind_c+1)
      ! Interpolate linearly to get z_tan
      r = h_t2/(h_t2-h_t1)
      z_tan = z_ref(tan_ind_c) * r + (r-1.0) * z_ref(tan_ind_c+1)
      if ( abs(z_tan-z_ref(tan_ind_c+1)) <= default_thresh ) then
        ! Tangent zeta is at tan_ind_c + 1; there is no new zeta
        tan_ind_c = tan_ind_c + 1
      else if ( abs(z_tan-z_ref(tan_ind_c)) > default_thresh ) then
        ! Add a new zeta
        z_ref_new(:tan_ind_c-1) = z_ref(:tan_ind_c-1)
        z_ref_new(tan_ind_c) = z_tan
        z_ref_new(tan_ind_c+1:nz+1) = z_ref(tan_ind_c:nz)
        nz = nz + 1
      else
        ! Tangent zeta is at tan_ind_c; nothing needs doing
      end if
      if ( do_dumps > 0 ) call output ( z_tan, before='Z_Tan = ', after=', ' )
    end if

    if ( do_dumps > 0 ) then
d133 1
a133 3
      call output ( h_surf, before=', H_Surf = ' )
      call output ( tan_ind_c, before=', Tan_ind_c = ' )
      call output ( tan_ind_f, before=', Tan_ind_f = ', advance='yes' )
d141 2
a142 2
  subroutine Height_Metrics (  phi_t, tan_ind, p_basis, h_ref, r_eq, h_surf, &
                            &  h_tan, z_ref,                                 &
d144 1
a144 1
                            &  vert_inds, h_grid, p_grid,                    &
d146 1
a146 1
                            &  h_tol )
d154 4
d159 1
a169 3
                                       ! for rays that do not intersect the earth,
                                       ! or the orbit projected geodetic angle
                                       ! of the intersection point.
a174 2
    real(rp), intent(in) :: R_eq       ! equivalent elliptical earth radius at
                                       ! Phi_t
d176 2
a177 2
                                       ! surface above R_eq
    real(rp), intent(in) :: H_Tan      ! Tangent height above H_Surf -- negative
d182 2
d186 3
d195 4
a198 1
                                       !   for convergence of phi/h iteration
d205 1
d223 3
a225 2
    real(rp) :: REQ_S      ! R_eq - H_Surf
    real(rp) :: Tan_Ht     ! H_Tan + r_eq
d228 7
a234 1
    real(rp) :: PHI_OFFSET(size(vert_inds)) ! PHI_T or a function of NEG_H_TAN
d237 3
d242 1
a242 1
      & (/ 'none ', 'cmplx', 'good ', 'grid1', 'grid2' /)
d260 12
a271 2
    ! p_basis and p_grid are phi's in offset radians relative to phi_t, that
    ! is, the phi_t, p_basis or p_grid = 0.0 is phi_t.
d274 15
a288 6
    req_s = r_eq - h_surf
    tan_ht = h_tan + r_eq

    phi_offset(:n_tan) = phi_t
    if ( h_tan < 0.0 ) then ! Earth-intersecting ray
      phi_offset(n_tan+1:) = phi_t - 2.0_rp*Acos(tan_ht/r_eq)
d290 3
a292 1
      phi_offset(n_tan+1:) = phi_t
a294 7
    if ( h_phi_dump > 0 ) call dumpInput ( tan_ind )

      if ( debug ) &
        & print '(a)', &
        & '   I J   K                HREF(K,J) HREF(K,J+1)    A        B    phi sign    C', &
        & '          phi    H_GRID   HREF(K,J) HREF(K,J+1)  H(TRIG)    D           N   Diffs'

d303 8
a310 5
    stat = no_sol ! No solutions
    ! The tangent point is special
    stat(n_tan:n_tan+1) = good
    p_grid(n_tan:n_tan+1) = phi_offset(n_tan:n_tan+1)
    h_grid(n_tan:n_tan+1) = tan_ht
d319 1
a319 1
      h = max(tan_ht,h_ref(k,1)+req_s)
d326 3
a328 4
        if ( debug ) then
          print 3, i1, 0, p_grid(i1), h_grid(i1), '  Below p_basis'
        3 format ( i4,i2,f9.5,f9.3,a )
        end if
d333 1
a333 1
      h = max(tan_ht,h_ref(k,p_coeffs)+req_s)
d341 1
a341 1
          & print 3, i2, p_coeffs, p_grid(i2), h_grid(i2), '  Above p_basis'
d344 2
a345 2
        print 3, n_tan, 0, p_grid(n_tan), h_grid(n_tan), '  Tangent point'
        print 3, n_tan+1, 0, p_grid(n_tan+1), h_grid(n_tan+1), '  Tangent point'
d353 1
a353 25
    ! each row of {\tt H\_ref} (see wvs-048).
    !%
    ! \begin{equation*}
    ! H_{ij} + (H_{i,j+1}-H_{ij})
    !                   \frac{\phi-\phi_t-(\phi_j-\phi_t)}
    !                        {\phi_{j+1}-\phi_t-(\phi_j-\phi_t)} - H_t
    ! = (H_t+R^\oplus_{\text{eq}})(\sec (\phi-\phi_t) - 1)\,.
    ! \end{equation*}
    !%
    ! Notice that $R^\oplus_{\text{eq}}$ cancels everywhere on the left-hand
    ! side.  Using $\sec\phi \approx 1 + \frac12 \phi^2$, writing
    ! $\delta\phi=\phi-\phi_t$ and $H_{\text{tan}}=H_t+R^\oplus_{\text{eq}}$,
    ! and putting the resulting polynomial in standard form, we start by
    ! solving for $\delta\phi$ in
    !%
    ! \begin{equation*}
    ! \frac12 (\phi_{j+1}-\phi_j) H_{\text{tan}} \delta\phi^2 -
    ! (H_{i,j+1}-H_{ij})\delta\phi -
    ! H_{ij} (\phi_{j+1}-\phi_t) + H_{i,j+1} (\phi_j-\phi_t) +
    ! (\phi_{j+1}-\phi_j)H_t
    ! \approx 0
    ! \end{equation*}
    !%
    ! In the code, this in the form $A \delta\phi^2 + B \delta\phi + C = 0$.
    ! This is then improved using a Newton iteration.
d355 1
a355 3
    ! Extrapolated solutions are not accepted.  Outside of P\_Basis assume
    ! constant {\tt H\_ref}.  For I $<$ N\_Tan, try the minimum solution,
    ! otherwise try the maximum solution.
d360 1
a360 3
      a = dp * tan_ht ! Actually 2*A
      dpj1 = p_basis(j+1)-phi_t
      dpj0 = p_basis(j)-phi_t
d366 2
d371 1
a371 1
          & + dp * h_tan
d373 8
a380 3
            & print 120, i, j, k, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s, &
            & a, b, int(phi_sign(i)), c
          120 format ( i4, i2, i4, 14x, f11.3,f12.3, f9.3, 1p,g14.6, i3, g14.6 )
d387 1
a387 1
          &                tan_ht, req_s, my_h_tol, i /= i2 .or. j /= p_coeffs-1, &
d389 1
a389 1
        if ( IEEE_Is_NaN(p_grid(i)) ) stat(i) = no_sol
d392 1
a392 1
            stat(i) = no_sol
d395 1
a395 4
        if ( stat(i) == good ) then
          no_bad_fits = no_bad_fits - 1
        else if ( stat(i) >= grid1 ) then
          no_grid_fits = no_grid_fits + 1
d397 1
d414 1
a414 1
                & i, j, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s, 'Complex solution'
d416 1
a416 1
              call output ( r_eq, before='&in R_eq = ' )
d418 1
a418 1
              call output ( h_tan, before=', H_Tan = ', after=',', advance='yes' )
d420 1
d423 1
a423 1
              call dump ( p_basis, name='p_basis' )
a435 1
      call dumpInput ( 1 )
d438 7
a444 2
      if ( index(switches,'MHPX') /= 0 ) then
        call dump ( stat, 'STAT' )
d446 2
a447 1
        call dump ( p_grid, 'P_Grid before 1d fixup' )
d455 2
a456 1
            h_grid(i1) = dot_product(h_ref(vert_inds(i1),:),eta_t)
d465 1
a465 1
              do i = j-1, 1, -1
d468 1
a468 1
              if ( i < 1 ) then
d480 2
d483 4
a486 3
        do j = n_tan-1, 1, -1
          do i2 = j, 1, -1
            if ( stat(i2) >= good ) exit
d489 1
a489 1
            if ( stat(i1) >= good ) exit
d494 1
d496 4
a499 3
        do j = n_tan+2, n_path
          do i2 = j, n_path
            if ( stat(i2) >= good ) exit
d502 1
a502 1
            if ( stat(i1) >= good ) exit
d507 1
d510 1
a510 4
      do i = 1, n_path
        if ( stat(i) < good ) p_grid(i) = acos(h_grid(n_tan)/h_grid(i))
      end do
      if ( index(switches,'MHPX') /= 0 ) then
d512 2
a513 1
        call dump ( p_grid, name='P_Grid after 1d fixup' )
d518 6
d529 4
a532 4
      call output ( h_tan, before='h_tan = ' )
      call output ( r_eq, before=', r_eq = ', advance='yes' )
      call dump ( p_grid(:n_path), name='p_grid before refractive correction', &
        & format='(1pg14.6)', clean=clean )
d534 2
a535 2
        & call dump ( p_basis, name='p_basis', format='(f14.8)', clean=clean )
      call dump ( h_grid(:n_path), name='h_grid', format='(1pg14.7)', clean=clean )
d542 5
a546 4
      call output ( h_tan, before='h_tan = ' )
      call output ( r_eq, before=', r_eq = ', advance='yes' )
      call dump ( p_basis, name='p_basis', format='(f14.8)', clean=clean )
      call output ( phi_t, before='phi_t = ', format='(f14.8)' )
d549 10
a558 2
      call dump ( phi_offset, name='phi_offset', clean=clean )
      call dump ( h_ref(firstRow:n_vert,:)+req_s, name='h_ref+req_s', format='(f14.7)',clean=clean )
d567 2
a568 2
  ! {\tt p\_basis(1)} and {\tt p\_basis(2)}, $h_1$ and $h_2$ are {\tt
  ! h\_ref(1)} and {\tt h\_ref(2)}.
d573 1
a573 1
  ! is the height tolerance.
d577 1
a577 1
    &                      tan_ht, req_s, tol, inside, &
d587 6
a592 1
    real(rp), intent(in) :: Phi_Offset ! Offset from tangent point
d603 2
a604 1
    real(rp), intent(in) :: Req_s      ! R_eq - H_Surf
a611 1
    real(rp), intent(in) :: Tan_Ht     ! H_Tan + r_eq
d614 4
a617 2
    real(rp) :: H      ! tan_ht * ( 1.0_rp + secM1 ) - req_s,
                       ! ~ tan_ht * sec(p) - r_eq + h_surf
d622 2
a623 1
    real(rp) :: Secm1  ! Sec(phi) - 1
d626 2
a627 1
    real(rp), parameter :: C2 = 0.5_rp, C4 = 5.0_rp/24, C6 = 61.0_rp/720.0
d632 2
d638 1
d640 4
a643 5
    d = b*b - 2.0 * a * c ! Actually b^2-4ac, since A is actually 2*a
    if ( d < 0.0 ) then ! Complex solution, use SWAG method
      ! Pretend D is zero
      p = -b/a
      p = min(max(p,p_basis(1)-phi_offset),p_basis(2)-phi_offset)
d650 5
a654 2
      if ( p < p_basis(1)-phi_offset ) &
        & p = 0.5 * (p_basis(1)+p_basis(2)) - phi_offset
d658 2
a659 2
    ! higher order than two.  We don't use $\sec(\phi)-1$ because it suffers
    ! cancellation for small $\phi$.  Rather, use more terms of its Taylor
d662 8
a669 2
      p2 = p**2                             ! $ ( \phi - \phi_t )^2 $
      secM1 = p2*(c2+p2*(c4+p2*(c6+p2*c8))) ! ~ sec(p)-1 to eighth order
d672 2
a673 1
      h = tan_ht * ( 1.0_rp + secM1 ) - req_s ! ~ tan_ht * sec(p) - r_eq + h_surf
a683 1
          h_grid = h + req_s
d685 1
a685 1
          if ( debug ) call debug1 ( 1, n )
d689 1
a689 1
        if ( p_grid > p_basis(2) .and. abs(h-h_ref(2)) > abs(d) &
d694 1
d696 1
a696 2
            h_grid = h + req_s
            call debug1 ( 1, n, 'OUTSIDE' )
d701 5
d707 1
a707 2
          h_grid = h + req_s
          call debug1 ( n, n, 'STEP' )
d709 1
a709 1
      p = p - d / (a*p*(d1+p2*(d3+p2*(d5+p2*d7))) + b) ! do the Newton step
d717 2
a718 2
          h_grid = h + req_s
          call debug1 ( max(n-3,1), n-1, merge('BOUNDS  ', 'CONVERGE', abs(d) < tol) )
d720 1
a720 1
          call debug1 ( max(n-3,1), n-1 )
d723 1
d727 1
a727 1
        h_grid = h_ref(1)+req_s
d731 1
a731 1
          if ( debug ) call debug1 ( 1, 0, 'GRID 1' )
d735 1
a735 1
        h_grid = h_ref(2)+req_s
d739 1
a739 1
          if ( debug ) call debug1 ( 1, 0, 'GRID 2' )
d749 6
a754 3
    subroutine debug1 ( k, l, why )
      integer, intent(in) :: k, l
      character(len=*), intent(in), optional :: why
d757 5
d763 5
a767 5
        if ( abs(h+req_s-tan_ht/cos(p)) > 5.0e-4 ) oops='TRIG'
        if ( present(why) ) oops(6:) = why
      100 format (f15.5,f9.3,f11.3,f12.3,f9.3,1p,g14.6,i3,11g10.2)
        write (*, 100, advance='no') p_grid, h_grid, &
          & h_ref(1)+req_s, h_ref(2)+req_s, &
d771 5
d1039 1
a1039 2
    real(rp) :: Phi_Offset
    real(rp) :: REQ_S     ! R_eq - H_Surf
d1041 1
a1041 1
    real(rp) :: Tan_Ht    ! H_Tan + R_eq
d1043 1
a1053 5
        if ( h_tan < 0.0 .and. phi_t > p_basis(j) ) then ! Earth-intersecting ray
          phi_offset = phi_t - 2.0_rp*Acos(tan_ht/r_eq)
        else
          phi_offset = phi_t
        end if
d1055 1
a1055 1
        h2 = tan_ht / cos(p_basis(j) - phi_offset) - req_s
d1070 1
a1070 1
          call Solve_H_Phi ( p_basis(j-1:j), phi_offset, sign(1.0_rp,phi_t-p_basis(j-1)), &
d1107 1
a1107 1
       "$Id: metrics_m.f90,v 2.58 2008/05/20 00:16:40 vsnyder Exp $"
d1111 1
d1117 3
@


2.58
log
@Correct some TeXnicalities
@
text
@d53 1
a53 1
    &                          Req, H_Surf, H_Tan, Z_Ref_New, &
d91 1
a91 1
    real(rp), intent(out) :: Req       ! equivalent elliptical earth radius at
d99 1
a99 1
    real(rp), intent(out) :: z_ref_new(:) ! Coarse grid of -log pressures (zetas).
d136 1
a136 1
      ! have it, and adjust the req and the h_tan relative to this, and
d141 1
a141 1
      ! reference at the input z_ref(1) and adjust the req and the h_tan
d146 3
a148 3
    !{ Compute equivalent earth radius (REQ) at phi\_t(1) (nearest surface)
    ! and adjust to the input z\_grid(1) using Equation (5.21) in the 19
    ! August 2004 ATBD JPL D-18130.
d162 1
a162 1
    req = 0.001_rp*sqrt((earthrada_4*sp2 + csq**2*cp2) / &
d217 2
a218 2
  subroutine Height_Metrics (  phi_t, tan_ind, p_basis, h_ref, req, h_surf, &
                            &  h_tan, z_ref,                                &
d220 1
a220 1
                            &  vert_inds, h_grid, p_grid,                   &
d241 3
d249 2
a250 2
    real(rp), intent(in) :: Req        ! equivalent elliptical earth radius at
                                       ! H_Surf
d252 1
a252 1
                                       ! surface
a287 1
    real(rp) :: HTAN_R     ! H_Tan + req
d290 2
a291 1
    real(rp) :: REQ_S      ! Req - H_Surf
d321 2
a322 2
    req_s = req - h_surf
    htan_r = h_tan + req
d326 1
a326 1
      phi_offset(n_tan+1:) = phi_t - 2.0_rp*Acos(htan_r/req)
d350 1
a350 1
    h_grid(n_tan:n_tan+1) = htan_r
d359 2
a360 2
      h = max(htan_r,h_ref(k,1)+req_s)
      p = acos(htan_r/h) * phi_sign(i1) + phi_offset(i1)
d374 2
a375 2
      h = max(htan_r,h_ref(k,p_coeffs)+req_s)
      p = acos(htan_r/h) * phi_sign(i2) + phi_offset(i2)
d427 1
a427 1
      a = dp * htan_r ! Actually 2*A
d449 1
a449 1
          &                htan_r, req_s, my_h_tol, i /= i2 .or. j /= p_coeffs-1, &
d480 1
a480 1
              call output ( req, before='&in Req = ' )
d577 1
a577 1
      call output ( req, before=', req = ', advance='yes' )
d590 1
a590 1
      call output ( req, before=', req = ', advance='yes' )
d615 1
a615 1
    &                      htan_r, req_s, tol, inside, &
d630 1
a630 1
    real(rp), intent(in) :: A          ! (p_basis(2)-p_basis(1)) * Htan_r
d636 1
a636 2
    real(rp), intent(in) :: Htan_r     ! H_Tan + req
    real(rp), intent(in) :: Req_s      ! Req - H_Surf
d644 1
d647 2
a648 2
    real(rp) :: H      ! htan_r * ( 1.0_rp + secM1 ) - req_s,
                       ! ~ htan_r * sec(p) - req + h_surf
d690 1
a690 1
      h = htan_r * ( 1.0_rp + secM1 ) - req_s ! ~ htan_r * sec(p) - req + h_surf
d741 1
a741 1
        if ( h_grid > htan_r ) then
d749 1
a749 1
        if ( h_grid > htan_r ) then
d768 1
a768 1
        if ( abs(h+req_s-htan_r/cos(p)) > 5.0e-4 ) oops='TRIG'
d773 2
a774 2
          & htan_r / cos(p), &
        ! & htan_r * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ htan_r * sec(p)
d993 2
a994 2
  subroutine More_Points (  phi_t, tan_ind, p_basis, z_ref, h_ref, req,  &
                         &  h_surf, h_tan, p_grid,                       &
d996 1
a996 1
                         &  z_new, h_new, p_new, n_new,                  &
d1013 1
a1013 1
    real(rp), intent(in) :: Req        ! equivalent elliptical earth radius at
a1033 1
    real(rp) :: Htan_r    ! H_Tan + Req
d1040 1
a1040 1
    real(rp) :: REQ_S     ! Req - H_Surf
d1042 1
d1046 2
a1047 2
    req_s = req - h_surf
    hTan_r = H_Tan + Req
d1055 1
a1055 1
          phi_offset = phi_t - 2.0_rp*Acos((req+h_tan)/req)
d1060 1
a1060 1
        h2 = hTan_r / cos(p_basis(j) - phi_offset) - req_s
d1065 1
a1065 1
          a = (p_basis(j)-p_basis(j-1)) * hTan_r
d1077 1
a1077 1
          &                htan_r, req_s, my_h_tol, i /= tan_ind .or. j /= p_coeffs, &
d1112 1
a1112 1
       "$Id: metrics_m.f90,v 2.57 2007/11/08 01:49:39 vsnyder Exp $"
d1121 3
@


2.57
log
@Req should be Req_s in one place in More_Points
@
text
@d154 1
a154 1
    ! N(\phi_t) \sqrt{\sin^\phi_t + \frac{c^4}{a^4}\cos^2 \phi_t} + h_{\text{surf}} =
d1109 1
a1109 1
       "$Id: metrics_m.f90,v 2.56 2007/10/19 23:28:30 vsnyder Exp $"
d1118 3
@


2.56
log
@Don't accept grid solutions less than Ht
@
text
@d1057 1
a1057 1
        h2 = hTan_r / cos(p_basis(j) - phi_offset) - req
d1109 1
a1109 1
       "$Id: metrics_m.f90,v 2.55 2007/10/11 20:17:35 vsnyder Exp $"
d1118 3
@


2.55
log
@Accept grid solutions more readily
@
text
@d738 5
a742 3
        phi = p_basis(1)
        stat = grid1
        if ( debug ) call debug1 ( 1, 0, 'GRID 1' )
d746 5
a750 3
        phi = p_basis(2)
        stat = grid2
        if ( debug ) call debug1 ( 1, 0, 'GRID 2' )
d1057 1
a1057 1
        h2 = hTan_r / cos(p_basis(j) - phi_offset) - req_s
d1067 4
d1109 1
a1109 1
       "$Id: metrics_m.f90,v 2.54 2007/10/03 20:54:10 vsnyder Exp $"
d1118 3
@


2.54
log
@Require phi to be monotone
@
text
@d232 1
a287 2
    real(rp) :: P_Prev     ! Previous phi.  Phi's are monotone, so next one
                           ! cannot be less.
a352 1
    p_prev = -0.5 * huge(0.0_rp)
a358 1
      p_prev = p
d448 6
a453 1
        if ( p_grid(i) < p_prev ) stat(i) = no_sol
d468 1
a468 4
        if ( stat(i) == good ) then  ! Newton iteration ended successfully
          p_prev = p_grid(i)
          cycle
        end if
d489 6
a495 6
        if ( debug ) then
          print *, 'no_bad_fits =', no_bad_fits, ', no_grid+fits =', no_grid_fits
          do i = 1, size(stat), 10
            print "(i4,'#',10(1x,a:))", i, nStat(stat(i:min(size(stat),i+9)))
          end do
        end if
d1101 1
a1101 1
       "$Id: metrics_m.f90,v 2.53 2007/09/07 01:37:23 vsnyder Exp $"
d1110 3
@


2.53
log
@Spiff up some dumps
@
text
@d91 6
a96 5
    real(rp), intent(out) :: req       ! equivalent elliptical earth radius
    real(rp), intent(out) :: H_SURF    ! Height of the reference surface --
                                       ! interpolated in Surf_Height if
                                       ! present(Surf_Height) else interpolated
                                       ! in row 1 of H_REF.
d245 4
a248 2
    real(rp), intent(in) :: Req        ! Equivalent elliptical earth radius
    real(rp), intent(in) :: H_Surf     ! Height at the Earth surface
d287 2
d319 3
d324 1
a324 1
      phi_offset(n_tan+1:) = phi_t - 2.0_rp*Acos((req+h_tan)/req)
a328 3
    req_s = req - h_surf
    htan_r = h_tan + req

d354 1
d361 1
d391 5
a395 1
    ! heights by solving
d402 1
a402 1
    ! 
d406 3
a408 3
    ! and putting the resulting polynomial in standard form, we solve for
    ! $\delta\phi$ in
    ! 
d416 3
d420 3
a422 7
    ! which arises from solving for the intersections of the line of sight
    ! ($H = H_{\text{tan}} \sec \phi)$ with constant-$\zeta$ surfaces,
    ! piecewise linear segments of which are represented by two consecutive
    ! columns in each row of {\tt H\_ref} (see wvs-048).  Extrapolated
    ! solutions are not accepted.  Outside of P\_Basis assume constant {\tt
    ! H\_ref}.  For I $<$ N\_Tan, try the minimum solution, otherwise try
    ! the maximum solution.
d432 2
a433 1
        if ( stat(i) == grid1 ) cycle ! can't possibly be in this column
d451 1
d466 6
a471 2
        if ( stat(i) == good ) cycle  ! Newton iteration ended successfully
        if ( stat(i) == grid1 ) cycle ! Can't be further to the right
d580 1
a580 1
      call dump ( h_grid(:n_path), name='h_grid', format='(1pg14.6)', clean=clean )
d664 1
a664 1
    d = b*b - 2.0 * a * c ! Actually b^2-4ac, since a is actually 2*A
d684 1
a684 1
      p2 = p**2
d1007 4
a1010 2
    real(rp), intent(in) :: req        ! Equivalent elliptical earth radius
    real(rp), intent(in) :: H_Surf     ! Height at the Earth surface
d1040 1
a1042 1
    req_s = req - h_surf
d1060 1
a1060 1
          b = -(h_ref(i,j)-h_ref(i,j-1))
d1102 1
a1102 1
       "$Id: metrics_m.f90,v 2.52 2007/08/23 20:41:07 vsnyder Exp $"
d1111 3
@


2.52
log
@Don't clobber "grid" status with "cplx" status on next panel
Don't clobber "grid" phi with failed iteration value on next panel
Separate "grid" into "grid1" and "grid2"; don't bother to look for
intersection on next panel after "grid1" solution.
@
text
@a262 1
    integer :: Dump_Stop   ! 0 = no dump, >0 = dump/stop
d297 1
a297 2
      dump_stop = index(switches,'metD')
      do_dumps = max(dump_stop,index(switches,'metd'))
d562 2
a564 1
      if ( dump_stop > 0 ) stop
d776 1
d890 1
d893 4
d907 1
a907 1
      real(rp) :: ETA_T2(n_path,n)    ! n = size(z_basis) but Intel's
d1084 1
a1084 1
       "$Id: metrics_m.f90,v 2.51 2007/07/31 23:48:57 vsnyder Exp $"
d1093 6
@


2.51
log
@Try to recover from failure of H/Phi convergence
@
text
@d24 1
d26 3
a28 1
  integer, parameter, public :: Grid = 3    ! Close to a grid point
d292 2
a293 2
    character(4), parameter :: nStat(no_sol:grid) = &
      & (/ 'none', 'cplx', 'good', 'grid' /)
d423 2
a424 1
        if ( stat(i) == good ) cycle ! probably the tangent point
d434 1
a434 1
        if ( stat(i) == grid ) then
d444 1
a444 1
        else if ( stat(i) == grid ) then
d456 2
a457 1
        if ( stat(i) == good ) cycle ! Newton iteration ended successfully
d492 1
a492 2
      if ( stat(1) /= good .and. stat(1) /= grid .or. &
        &  stat(n_path) /= good .and. stat(n_path) /= grid ) then
d496 1
a496 1
          if ( stat(i1) /= good .and. stat(i1) /= grid ) then
d524 1
a524 1
            if ( stat(i2) == good .or. stat(i2) == grid ) exit
d527 1
a527 1
            if ( stat(i1) == good .or. stat(i1) == grid ) exit
d535 1
a535 1
            if ( stat(i2) == good .or. stat(i2) == grid ) exit
d538 1
a538 1
            if ( stat(i1) == good .or. stat(i1) == grid ) exit
d546 1
a546 2
        if ( stat(i) /= good .and. stat(i) /= grid ) &
          & p_grid(i) = acos(h_grid(n_tan)/h_grid(i))
d600 1
a600 1
    &                      h_grid, p_grid, stat, outside )
d624 1
a624 1
    real(rp), intent(out) :: P_Grid    ! Phi solution
d629 4
a632 4
    real(rp) :: D     ! B^2 - 4 a c
    real(rp) :: H     ! htan_r * ( 1.0_rp + secM1 ) - req_s,
                      ! ~ htan_r * sec(p) - req + h_surf
    integer :: N      ! Newton iteration counter
d634 3
a636 2
    real(rp) :: P, P2 ! Candidate solution, p^2
    real(rp) :: Secm1 ! Sec(phi) - 1
d654 2
a655 1
      stat = complex ! In case Newton iteration doesn't converge
d687 1
d713 1
a713 1
        if ( stat /= good .and. .not. outside ) then
d720 1
a720 1
    if ( stat /= grid ) then
d724 3
a726 2
        p_grid = p_basis(1)
        stat = grid
d730 3
a732 2
        p_grid = p_basis(2)
        stat = grid
d1046 1
a1046 1
          if ( stat == grid ) then
d1053 1
a1053 1
          if ( stat == no_sol .or. stat == complex .or. outside ) then
d1079 1
a1079 1
       "$Id: metrics_m.f90,v 2.50 2007/06/29 19:34:40 vsnyder Exp $"
d1088 3
@


2.50
log
@Make the default h/phi convergence tolerance a parameter
@
text
@d214 1
a214 1
                            &  h_tan,                                       &
d227 1
d229 1
a229 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d245 3
d284 1
d323 1
a323 9
    if ( h_phi_dump > 0 ) then
      call dump ( p_basis, name='p_basis', format='(1pg14.6)', clean=clean )
      call output ( phi_t, before='phi_t = ', format='(1pg14.6)' )
      call output ( h_surf, format='(f7.2)', before =', h_surf = ' )
      call output ( tan_ind, before=', tan_ind = ' )
      call output ( req, format='(f7.2)', before=', req = ', advance='yes' )
      call dump ( phi_offset, name='phi_offset', clean=clean )
      call dump ( h_ref(tan_ind:n_vert,:)+req_s, name='h_ref+req_s', format='(f14.3)',clean=clean )
    end if
d326 3
a328 2
        & print '(2a,f9.3,a,f7.3)', '   I J    phi  H(TAYLOR)',&
          & '  HREF(I,J) HREF(I,J+1)  H(TRIG)    H-HREF      N   Diffs'
a421 1
        k = vert_inds(i)
d478 72
a549 2
      call MLSMessage ( MLSMSG_Error, ModuleName, &
       & "Height_Metrics failed to find H/Phi solution for some path segment" )
d565 14
d642 1
a642 1
    real(rp) :: DD(merge(10,0,debug))
a894 1
      logical :: NOT_ZERO_T(n_path,n)   ! compiler won't allow that
d1071 1
a1071 1
       "$Id: metrics_m.f90,v 2.49 2007/06/26 00:35:39 vsnyder Exp $"
d1080 3
@


2.49
log
@Use column-sparse eta, make *_zxp arguments
@
text
@d14 2
d34 1
d300 1
a300 1
    my_h_tol = 0.001_rp ! kilometers
d594 1
a594 1
          &    abs(b) < 0.001 .and. &
d905 1
a905 1
    real(rp), intent(out) :: z_new(:)  ! computed zetas
d927 1
a927 1
    my_h_tol = 0.001_rp ! kilometers
d991 1
a991 1
       "$Id: metrics_m.f90,v 2.48 2007/06/08 22:05:48 vsnyder Exp $"
d1000 3
@


2.48
log
@More work on min zeta
@
text
@d678 1
a678 1
          & do_calc_hyd, do_calc_t, eta_zxp, tan_phi_t )
d685 1
a685 1
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
d738 1
a738 1
    real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature
d740 2
d755 2
d773 5
a777 2
    call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p, &
      & not_zero = not_zero_p, first=col1, last=col2, sorted=.true. )
d810 4
a813 2
      real(rp) :: ETA_T2(size(vert_inds),n)    ! n = size(z_basis) but Intel's
      logical :: NOT_ZERO_T(size(vert_inds),n)   ! compiler won't allow that
d842 9
a850 1
      call get_eta_sparse ( z_basis, z_ref(vert_inds), eta_t2, NOT_ZERO = not_zero_t )
d857 2
a858 10
            do_calc_t(:,sv_t) = not_zero_t(:,sv_z) .and. not_zero_p(:,sv_p)
            ! Don't bother with WHERE here since one multiply is faster
            eta_zxp(:,sv_t) = eta_t2(:,sv_z) * eta_p(:,sv_p)
            do_calc_hyd(:,sv_t) = not_zero_p(:,sv_p) .and. &
              &                   dhidtlm(vert_inds,sv_z,sv_p) > 0.0_rp
            where ( do_calc_hyd(:,sv_t) )
              dhitdtlm(:,sv_t) = dhidtlm(vert_inds,sv_z,sv_p) * eta_p(:,sv_p)
            elsewhere
              dhitdtlm(:,sv_t) = 0.0
            end where
a859 2
            do_calc_t(:,sv_t) = .false.
            eta_zxp(:,sv_t) = 0.0
d862 3
d988 1
a988 1
       "$Id: metrics_m.f90,v 2.47 2007/03/22 23:24:34 vsnyder Exp $"
d997 3
@


2.47
log
@Remove irrelevant USE
@
text
@d60 1
a60 1
    use Make_Z_Grid_m, only: Default_Thresh
d116 1
d136 1
a136 1
      h_surf = dot_product(h_ref(1,first:last),eta_t(first:last))
d181 2
a182 1
      z_tan = z_ref(tan_ind_c) + h_t2/(h_t2-h_t1)
d195 1
a195 1
      call output ( z_tan, before='Z_Tan = ', after=', ' )
d210 2
a211 2
  subroutine Height_Metrics (  phi_t, tan_ind, p_basis, z_ref, h_ref, req, &
                            &  h_surf, h_tan,                              &
d213 1
a213 1
                            &  h_grid, p_grid,                             &
a223 1
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
d231 2
a232 2
    real(rp), intent(in) :: phi_t      ! Orbit projected tangent geodetic angle
    integer, intent(in) :: tan_ind     ! Tangent height index, 1 = center of
d234 1
a234 1
    real(rp), intent(in) :: p_basis(:) ! Horizontal temperature representation
d236 2
a237 5
    real(rp), intent(in) :: z_ref(:)   ! -log pressures (zetas) for which
    !                                     heights/temps are needed.  Only the
    !                                     parts from the tangent outward are used
    real(rp), intent(in) :: h_ref(:,:) ! Heights by z_ref and p_basis
    real(rp), intent(in) :: req        ! Equivalent elliptical earth radius
d243 3
a245 2
    real(rp), intent(out) :: h_grid(:) ! computed heights, referenced to Earth center
    real(rp), intent(out) :: p_grid(:) ! computed phi's
a255 1
    integer :: First, Last ! Nonzeros in Eta_T
d259 1
a259 1
    integer :: N_PATH      ! Path length = 2*(size(z_ref)+1-tan_ind)
d261 1
a261 1
    integer :: N_VERT      ! Size(z_ref)
a263 1
    integer :: VERT_INDS(2*(size(z_ref)+1-tan_ind)) ! What to use in z_ref
a276 1
    real(rp) :: ETA_T(size(p_basis))
d280 4
d295 1
a299 4
    n_vert = size(z_ref)

    ! Get interpolating coefficients (eta_t) from p_basis to phi_t
    call get_eta_sparse ( p_basis, phi_t, eta_t, first, last )
a322 1
!     call dump ( z_ref(tan_ind:n_vert), name='z_ref', clean=clean )
d358 1
a358 1
          print 3, i1, 0, p_grid(i1), h_grid(i1), '  Outside p_basis'
a361 1
    j = p_coeffs
d365 1
a365 1
      h = max(htan_r,h_ref(k,j)+req_s)
d373 1
a373 1
          & print 3, i2, p_coeffs, p_grid(i2), h_grid(i2), '  Outside p_basis'
a420 3
          if ( newtonDetails ) &
            & print 120, i, j, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s
          120 format ( i4, i2, 18x, f11.3,f12.3 )
d426 8
a433 1
        if ( stat(i) == grid ) no_grid_fits = no_grid_fits - 1
d472 6
a477 2
        if ( debug ) &
          & print *, 'no_bad_fits =', no_bad_fits, ', no_grid+fits =', no_grid_fits
a558 1
    character(merge(10,0,debug)) :: OOPS
d571 2
d597 1
a597 1
          if ( debug ) exit
d607 1
a607 1
            exit
d612 4
a618 16
    if ( debug ) then
      if ( stat == good .or. outside ) then
        if ( debug ) then
          oops=''
          if ( abs(h+req_s-htan_r/cos(p)) > 5.0e-4 ) oops='      TRIG'
        100 format (f15.5,f9.3,f11.3,f12.3,f9.3,1p,g14.6,i3,11g10.2)
          write (*, 100, advance='no') p_grid, h_grid, &
            & h_ref(1)+req_s, h_ref(2)+req_s, &
            & htan_r / cos(p), &
          ! & htan_r * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ htan_r * sec(p)
            & d, n, dd(1:n)
          write (*, '(2x,a)') trim(adjustl(oops))
        end if
      end if
      return
    end if
d623 3
a625 3
        write (*,100, advance='no') p_grid, h+req_s
        if ( abs(d) < 0.001_rp ) then
          write (*,'(a,i3,1p,3g10.2)') " Newton out of bounds  ", n, dd(1:min(n,3))
d627 1
a627 1
          write (*,'(a,i3,1p,3g10.2)') " Newton didn't converge", n, dd(1:min(n,3))
d648 18
d671 1
a671 1
          & tan_ind, n_tan, p_basis, t_ref, dhidzij, p_grid,        &
d673 1
a673 1
          & t_grid, dhitdzi,                                        &
d675 1
a675 1
          & ddhidhidtl0, dhidtlm, t_deriv_flag, z_basis, z_ref,     &
d677 1
a677 1
          & ddhtdhtdtl0, dhitdtlm, dhtdtl0, dhtdzt,                 &
a687 1

d698 1
d747 1
a747 1
    integer :: N_PATH      ! Path length = 2*(size(z_ref)+1-tan_ind)
a748 1
    integer :: VERT_INDS(2*(size(t_ref,1)+1-tan_ind)) ! What to use in [zt]_ref
a763 5

    ! Only use the parts of the reference grids that are germane to the
    ! present path

    vert_inds = (/ (i, i=n_vert,tan_ind,-1), (i, i=tan_ind,n_vert) /)
d788 1
a788 1
    if ( present(dhidtlm) ) call Tangent_Temperature_Derivatives
d798 1
a798 1
    subroutine Tangent_Temperature_Derivatives
d802 3
a804 2
      real(rp) :: ETA_T2(size(vert_inds),size(z_basis))
      logical :: NOT_ZERO_T(size(vert_inds),size(z_basis))
d978 1
a978 1
       "$Id: metrics_m.f90,v 2.46 2007/02/06 23:50:59 vsnyder Exp $"
d987 3
@


2.46
log
@Polish up some messages.  Use 8th order approximation for sec(phi)-1 since
sixth order doesn't give one-meter accuracy.
@
text
@d224 1
a224 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error, MLSMSG_Warning
d973 1
a973 1
       "$Id: metrics_m.f90,v 2.45 2007/02/06 21:09:29 vsnyder Exp $"
d982 4
@


2.45
log
@Don't skip unsolved segments when going to next phi
@
text
@d448 1
d455 1
a455 1
        if ( stat(i) == complex ) then ! Complex solution
d459 1
a459 3
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & "Complex starting value for Newton iteration shouldn't happen" )
              if ( complexDebug ) then
d476 1
a476 1
       &                "Height_Metrics failed to find H/Phi solution" )
d549 1
d552 1
d577 1
a577 1
      secM1 = p2*((c2+p2*(c4+p2*c6))) ! ~ sec(p)-1 to sixth order
d608 1
a608 1
      p = p - d / (a*p*(d1+p2*(d3+p2*d5)) + b) ! do the Newton step
d906 1
a906 2
    real(rp) :: Phi_Sign
    real(rp) :: REQ_S      ! Req - H_Surf
d928 1
a928 1
          ! Line of sight intersects constant-zeta surface.
a929 1
          phi_sign = sign(1.0_rp,phi_t-p_basis(j-1))
d936 1
a936 1
          call Solve_H_Phi ( p_basis(j-1:j), phi_offset, phi_sign, &
d952 1
d973 1
a973 1
       "$Id: metrics_m.f90,v 2.44 2007/02/01 02:53:15 vsnyder Exp $"
d982 3
@


2.44
log
@Make Solve_H_Phi a subroutine, add More_Points subroutine
@
text
@d35 1
d258 1
a258 1
    integer :: I, I1, I2, J, K
d325 1
a325 1
      call dump ( h_ref(tan_ind:n_vert,:), name='h_ref', clean=clean )
d417 1
d427 1
a427 1
            & write ( *, 120 ) i, j, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s
d446 5
a450 2
          i1 = i    ! phi is monotone; the remaining solutions are in the next
          exit      ! column or even farther over, and not before the current row
d453 1
d456 1
a456 1
              & write (*, '(i4,i2,18x,f11.3,f12.3,1x,a)' ) &
d460 9
a468 1
          cycle
d514 1
d560 6
a565 6
      if ( -d < (10.0 * epsilon(d)) * b*b ) then
        p = -b/a ! D is negative round-off.  Pretend it's zero
      else ! Use the middle phi to start the Newton iteration
        stat = complex ! In case Newton iteration doesn't converge
        p = 0.5 * ( p_basis(1) + p_basis(2) ) - phi_offset
      end if
d581 1
a581 5
          if ( newtonDetails ) then
            write (*, 110) n, p_grid, h+req_s
        110 format ( 4x,i2,f9.5,f9.3 )
          end if
        if ( p_grid >= p_basis(1) .and. p_grid <= p_basis(2) .and. &
a590 11
          p_grid = p_grid
            if ( debug ) then
              oops=''
              if ( abs(h+req_s-htan_r/cos(p)) > 5.0e-4 ) oops='      TRIG'
            100 format (6x,f9.5,f9.3,23x,f9.3,1p,g14.6,i3,11g10.2)
              write (*, 100, advance='no') p_grid, h_grid, &
                & htan_r / cos(p), &
              ! & htan_r * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ htan_r * sec(p)
                & d, n, dd(1:n)
              write (*, '(2x,a)') trim(adjustl(oops))
            end if
d592 1
d600 4
d610 16
d973 1
a973 1
       "$Id: metrics_m.f90,v 2.43 2007/01/20 01:07:49 vsnyder Exp $"
d982 3
@


2.43
log
@Use Earth-intersection phi instead of tangent phi to compute tangent
temerature derivatives, do some decrufting too.
@
text
@d16 8
a23 1
  public :: Height_Metrics, More_Metrics, Tangent_Metrics
d31 7
d223 1
a223 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Error
d257 1
a257 1
    integer :: I, I1, I2, J, K, N
a266 4
    ! Values for stat:
    integer, parameter :: No_sol = 0 ! No solution
    integer, parameter :: Good = 1   ! Newton converged, tangent point, extrapolated
    integer, parameter :: Grid = 2   ! Close to a grid point
d268 2
a269 1
    real(rp) :: A, B, C, D ! Polynomial coefficients used to solve for phi and H
d276 1
a276 2
    real(rp) :: P, Q       ! Tentative solutions for phi
    real(rp) :: P2         ! P**2
a277 1
    real(rp) :: SecM1      ! Taylor series for sec(phi)-1
a282 14
    ! Coefficients in expansion of Sec(phi)-1 = c2*phi^2 + c4*phi^4 ...
    real(rp), parameter :: C2 = 0.5_rp, C4 = 5.0_rp/24, C6 = 61.0_rp/720.0
    ! Coefficients in expansion of Sec(phi)*Tan(phi) = d/dPhi(sec(phi)-1)
    real(rp), parameter :: D1 = 2*c2, D3 = 4*c4, D5 = 6*c6 ! ... 2n * c_2n

    ! To control debugging
    logical, parameter :: Debug = .false.
    logical, parameter :: NewtonDetails = .true. .and. debug
    ! For debugging output format:
    logical, parameter :: clean = .false.
    ! For debugging output
    real(rp) :: DD(merge(10,0,debug))
    character(merge(10,0,debug)) :: OOPS

d309 1
a309 1
      phi_offset(n_tan+1:) = phi_t-2.0_rp*Acos((req+h_tan)/req)
d321 1
a322 1
      call output ( tan_ind, before='tan_ind = ' )
d422 5
a426 1
        if ( stat(i) == good ) cycle
d432 17
a448 2
        d = b*b - 2.0 * a * c ! Actually b^2-4ac, since a is actually 2*A
        if ( d < 0.0 ) then ! Complex solution
d452 1
a452 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d454 1
a454 95
          cycle  ! in case error level changed, and then crash somewhere else
        end if
        d = sqrt(d)
        p = (-b + phi_sign(i) * d ) / a
        !{Use P in Newton iterations with a higher-order expansion for
        ! $\sec(\phi)$.  We don't use $\sec(\phi)-1$ because it suffers
        ! cancellation for small $\phi$.  Rather, use more terms of its
        ! Taylor series than we used for the quadratic approximation.
        do n = 1, 10
          p2 = p**2
          secM1 = p2*((c2+p2*(c4+p2*c6))) ! ~ sec(p)-1
          d = a*secM1 + b*p + c
            if ( debug ) dd(n) = d
          h = htan_r * ( 1.0_rp + secM1 ) - req_s ! ~ htan_r * sec(p) - req + h_surf
          if ( abs(d) < my_h_tol ) then ! difference is small enough
            q = p + phi_offset(i)
              if ( newtonDetails ) then
                print 110, n, q, h+req_s, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s,h_ref(k,j+1)-h_ref(k,j)
            110 format ( 4x,i2,f9.5,f9.3,f11.3,f12.3,11x,g14.6 )
              end if
            if ( q >= p_basis(j) .and. q <= p_basis(j+1) .and. &
                   ! Converged within bounds?
                    &  ( (h-h_ref(k,j))*(h-h_ref(k,j+1)) <= 0.0 .or. &
                   ! or the difference in reference heights is within tolerance and
                   ! the current H is outside the bounds by less than tolerance
              &    abs(b) < 0.001 .and. &
              &    ( abs(h-h_ref(k,j)) < my_h_tol .or. &
              &      abs(h-h_ref(k,j+1)) < my_h_tol ) ) ) then
              ! Not extrapolating in phi
              h_grid(i) = h + req_s
              p_grid(i) = q
                if ( debug ) then
                  oops=''
                  if ( abs(h+req_s-htan_r/cos(p)) > 5.0e-4 ) oops='      TRIG'
                100 format (i4,i2,f9.5,f9.3,f11.3,f12.3,f9.3, &
                      & 1p,g14.6,i3,11g10.2)
                  write (*, 100, advance='no') &
                    & i, j, p_grid(i), h_grid(i), &
                    & h_ref(k,j)+req_s, h_ref(k,j+1)+req_s, &
                  htan_r / cos(p), &
                  !htan_r * ( 1.0_rp + p2*((c2+p2*(c4+p2*c6))) ), & ! ~ htan_r * sec(p)
                  !a, b, c, &
                  d, n, dd(1:n)
                  write (*, '(2x,a)') trim(adjustl(oops))
                end if
              if ( stat(i) == grid ) then
                no_grid_fits = no_grid_fits - 1
              else
                no_bad_fits = no_bad_fits - 1
              end if
              stat(i) = good
              cycle path ! end the Newton iteration successfully
            end if
            if ( q > p_basis(j+1) .and. abs(h-h_ref(k,j+1)) > abs(d) &
              & .and. (i /= i2 .or. j /= p_coeffs-1) ) then
              ! Phi is beyond the range, and H is outside by more than the
              ! move.  Go on to the next columns of H_ref and P_Basis.
              i1 = i     ! phi is monotone; the rest are in the next column
              exit path  ! or even farther over
            end if
          end if
          p = p - d / (a*p*(d1+p2*(d3+p2*d5)) + b) ! do the Newton step
        end do ! n
        ! Newton iteration failed to converge.  Use the break point if the
        ! result is very near to it.  We'll probably find it in the next
        ! panel, but just in case....
        q = p + phi_offset(i)
          if ( debug ) then
            write (*,100, advance='no') i, j, q, h+req_s, h_ref(k,j)+req_s, h_ref(k,j+1)+req_s
            if ( abs(d) < 0.001_rp ) then
              write (*,'(a,i3,1p,3g10.2)') " Newton out of bounds  ", n, dd(1:min(n,3))
            else
              write (*,'(a,i3,1p,3g10.2)') " Newton didn't converge", n, dd(1:min(n,3))
            end if
          end if
        if ( stat(i) /= grid ) then
          if ( abs(h-h_ref(k,j)) <  0.1 .and. &
            & abs(q-p_basis(j)) < abs(q-p_basis(j+1)) ) then
            h_grid(i) = h_ref(k,j)+req_s
            p_grid(i) = p_basis(j)
            stat(i) = grid
            no_grid_fits = no_grid_fits + 1
            no_bad_fits = no_bad_fits - 1
          else if ( abs(h-h_ref(k,j+1)) <  0.1 .and. &
            & abs(q-p_basis(j+1)) < abs(q-p_basis(j)) ) then
            h_grid(i) = h_ref(k,j+1)+req_s
            p_grid(i) = p_basis(j+1)
            stat(i) = grid
            no_grid_fits = no_grid_fits + 1
            no_bad_fits = no_bad_fits - 1
          end if
        end if
        if ( q > p_basis(j+1) .and. (i /= i2 .or. j /= p_coeffs-1) ) then
          i1 = i    ! phi is monotone; the remaining solutions are in the next
          exit path ! column or even farther over, and not before the current row
d459 6
a464 2
      if ( debug .and. no_bad_fits > 0 ) &
        & print *, 'no_bad_fits =', no_bad_fits, ', no_grid+fits =', no_grid_fits
d481 155
a724 3
    ! For debugging output format:
    logical, parameter :: clean = .false.

d836 113
d952 1
a952 1
       "$Id: metrics_m.f90,v 2.42 2007/01/19 02:38:53 vsnyder Exp $"
d961 4
@


2.42
log
@Include water in phi refractive correction
@
text
@d44 1
a44 1
    use GLNP, only: NG, NGP1
d46 1
a46 1
    use MLSKinds, only: IP, RP, R8
a97 1
    integer :: I
a206 1
    use Geometry, only: EarthRadA
d208 1
a208 1
    use MLSKinds, only: IP, RP, R8
a261 1
    real(rp) :: CP2        ! Cos^2 phi_t
a262 1
    real(rp) :: H_T2       ! Used when searching for surface height in h_ref
a268 4
    real(rp) :: SP2        ! Sin^2 phi_t
    real(rp) :: Z_Tan      ! Zeta at the tangent point, usually from
                           ! z_ref(tan_ind), but solved here for earth-
                           ! intersecting rays.
a278 2
    real(r8), parameter :: EarthRadA_2 = EarthRadA**2, EarthRadA_4 = EarthRadA**4

d560 1
a560 2
          & phi_t, tan_ind, n_tan, p_basis, z_ref, t_ref, h_grid,    &
          & dhidzij, p_grid,                                         &
d562 1
a562 1
          & t_grid, dhitdzi,                                         &
d564 1
a564 1
          & ddhidhidtl0, dhidtlm, t_deriv_flag, z_basis,             &
d566 1
a566 1
          & ddhtdhtdtl0, dhitdtlm, dhtdtl0, dhtdzt,                  &
d575 1
a575 1
    use MLSKinds, only: RP, IP
d580 1
a580 2
    real(rp), intent(in) :: phi_t      ! orbit projected tangent geodetic angle
    integer(ip), intent(in) :: tan_ind ! tangent height index, 1 = center of
d582 1
a582 1
    integer(ip), intent(in) :: n_tan   ! tangent index in path, usually n_path/2
d585 2
a586 6
    real(rp), intent(in) :: z_ref(:)   ! -log pressures (zetas) for which
    !                                     heights/temps are needed.  Only the
    !                                     parts from the tangent outward are used
    real(rp), intent(in) :: t_ref(:,:) ! temperatures by t_phi_basis
    real(rp), intent(in) :: h_grid(:)  ! computed heights, referenced to Earth center
    real(rp), intent(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
d607 3
a634 2
    integer :: First, Last ! Nonzeros in Eta_T
    integer :: H_Phi_Dump  ! 0 = no dump, >0 = dump
d638 1
a638 1
    integer :: VERT_INDS(2*(size(z_ref)+1-tan_ind)) ! What to use in z_ref
d641 2
a644 3
    real(rp) :: ETA_T(size(p_basis))
    real(rp) :: N_GRID(size(vert_inds))     ! index of refraction
    real(rp) :: PHI_CORR(size(vert_inds))   ! the refractive correction
a653 1
      h_phi_dump = index(switches,'hphi')
d656 1
a656 1
    n_vert = size(z_ref)
d661 1
a661 1
    vert_inds = (/ (i, i=n_vert,tan_ind,-1), (i,  i=tan_ind,n_vert) /)
d668 1
a668 1
      & NOT_ZERO = not_zero_p, sorted=.true. )
d670 2
a671 1
      t_grid(i) = dot_product(t_ref(vert_inds(i),:), eta_p(i,:))
d673 2
a674 1
      dhitdzi(i) = dot_product(dhidzij(vert_inds(i),:), eta_p(i,:))
a677 2
    if ( present(tan_phi_t) .or. present(dhtdzt) .or. present(dhidtlm) ) &
      & call get_eta_sparse ( p_basis, phi_t, eta_t, first, last )
d679 2
a680 1
      & tan_phi_t = dot_product(t_ref(tan_ind,first:last),eta_t(first:last))
d682 2
a683 1
      & dhtdzt = dot_product(dhidzij(tan_ind,first:last),eta_t(first:last))
d709 1
a709 1
      ! phi_t, because the interpolation represented by eta_t is linear.
d717 2
a718 1
          & dot_product(dhidtlm(1,i,first:last),eta_t(first:last))
d722 1
a722 1
      dhtdtl0 = RESHAPE(dhidtlm(tan_ind,:,:) * SPREAD(eta_t,1,z_coeffs),&
d726 1
a726 1
                   ddhidhidtl0(tan_ind,:,:) * SPREAD(eta_t,1,z_coeffs), &
d738 2
a739 5
            where ( do_calc_t(:,sv_t) )
              eta_zxp(:,sv_t) = eta_t2(:,sv_z) * eta_p(:,sv_p)
            elsewhere
              eta_zxp(:,sv_t) = 0.0
            end where
d741 1
a741 1
              &                   dhidtlm(vert_inds(:),sv_z,sv_p) > 0.0_rp
d743 1
a743 1
              dhitdtlm(:,sv_t) = dhidtlm(vert_inds(:),sv_z,sv_p) * eta_p(:,sv_p)
d763 1
a763 1
       "$Id: metrics_m.f90,v 2.41 2007/01/18 00:26:32 vsnyder Exp $"
d772 3
@


2.41
log
@Split Pure_Metrics into Tangent_Metrics and Height_Metrics
@
text
@d570 2
a571 4
          & phi_t, tan_ind, n_tan, p_basis, z_ref, n_ref, t_ref,     &
          & h_grid, dhidzij, refract,                                &
          ! Inout:
          & p_grid,                                                  &
a586 1
    use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction
a599 1
    real(rp), intent(in) :: n_ref(:,:) ! Indices of refraction by t_phi_basis
d603 1
a603 5
    logical,  intent(in) :: refract    ! compute phi refractive correction

    ! Inout:

    real(rp), intent(inout) :: p_grid(:)  ! phi's on the path
a660 1
    real(rp) :: PHI_SIGN(size(vert_inds))   ! +/- 1.0
a680 20
    ! sign of phi vector
    phi_sign = (/ (-1, i=n_vert,tan_ind,-1), (+1, i=tan_ind,n_vert) /)

    ! Interpolate the index of refraction (N_Ref) to the path (N_Grid)
    ! and correct phi for refraction.
    if ( refract ) then
      call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p(:,:) )
      do i = 1, n_path
        n_grid(i) = dot_product(n_ref(vert_inds(i),:), eta_p(i,:))
      end do
      call phi_refractive_correction ( n_tan, n_grid, h_grid(:n_path), phi_corr )
      p_grid(:n_path) = p_grid(:n_path) + phi_sign * phi_corr
      if ( h_phi_dump > 0 ) &
        & call dump ( phi_corr, format='(1pg14.6)', &
        &             name='Refractive correction', clean=clean )
      if ( do_dumps > 0 ) &
        & call dump ( p_grid(:n_path), name='p_grid after refractive correction', &
          & format='(1pg14.6)', clean=clean )
    end if

d684 2
a685 1
    call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p, NOT_ZERO = not_zero_p )
d780 1
a780 1
       "$Id: metrics_m.f90,v 2.40 2006/12/21 22:59:17 vsnyder Exp $"
d789 3
@


2.40
log
@Don't reference optional arguments that aren't present
@
text
@d16 1
a16 1
  public :: Pure_Metrics, More_Metrics
d26 166
a191 1
  ! -----------------------------------------------  Pure_Metrics  -----
d194 2
a195 1
  subroutine Pure_Metrics (    phi_t, tan_ind, p_basis, z_ref, h_ref, csq, &
d197 1
a197 1
                            &  h_grid, p_grid, req,                        &
d199 1
a199 1
                            &  h_tol, tan_press, surf_temp )
d217 2
a218 2
    real(rp), intent(in) :: phi_t      ! orbit projected tangent geodetic angle
    integer(ip), intent(in) :: tan_ind ! tangent height index, 1 = center of
d220 1
a220 1
    real(rp), intent(in) :: p_basis(:) ! horizontal temperature representation
d225 6
a230 3
    real(rp), intent(in) :: h_ref(:,:) ! heights by t_phi_basis
    real(rp), intent(in) :: csq        ! (minor axis of orbit plane projected
    !                                    Earth ellipse)**2
a233 1
    real(rp), intent(out) :: req       ! equivalent elliptical earth radius
a237 2
    real(rp), optional, intent(in) :: Tan_press    ! Tangent pressure
    real(rp), optional, intent(in) :: Surf_temp(:) ! Surface temperature at phi_basis
d266 1
a266 5
    real(rp) :: H_SURF     ! Height of the reference surface -- interpolated in
                           ! row 1 of H_REF
    real(rp) :: H_T        ! Tangent height -- interpolated in row TAN_IND
                           ! of H_REF, then H_SURF is subtracted
    real(rp) :: H_TAN      ! Either H_T or NEG_H_TAN
d274 3
a287 2
    ! For debugging output format:
    logical, parameter :: clean = .false.
d292 2
d307 3
d315 1
a315 4
    ! compute the tangent height vertical.
    ! For simplicity, we set the surface reference at the input z_ref(1)
    ! and adjust the req and the h_t relative to this, and adjust h_ref
    ! accordingly
a316 33
    h_surf = dot_product(h_ref(1,first:last),eta_t(first:last))
    h_t = dot_product(h_ref(tan_ind,first:last),eta_t(first:last)) - h_surf
    h_tan = h_t

    !{ Compute equivalent earth radius (REQ) at phi\_t(1) (nearest surface)
    ! and adjust to the input z\_grid(1) using Equation (5.21) in the 19
    ! August 2004 ATBD JPL D-18130.
    !
    ! $c^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$.
    ! This is Equation (5.3) in the 19 August 2004 ATBD JPL D-18130.
    !
    ! $R^\oplus_{\text{eq}} \equiv H^\oplus_t =
    ! N(\phi_t) \sqrt{\sin^\phi_t + \frac{c^4}{a^4}\cos^2 \phi_t} + h_{\text{surf}} =
    ! \sqrt{\frac{a^4 \sin^2 \phi_t + c^4 \cos^2 \phi_t}
    !            {a^2 \cos^2 \phi_t + c^2 \sin^2 \phi_t}} + h_{\text{surf}}$
    !
    ! $a$ and $c$ are in meters; we want $R^\oplus_{\text{eq}}$ in kilometers.

    cp2 = cos(phi_t)**2
    sp2 = 1.0_rp - cp2
    req_s = 0.001_rp*sqrt((earthrada_4*sp2 + csq**2*cp2) / &
                        & (earthrada_2*cp2 + csq*sp2))
    req = req_s + h_surf

    ! Only use the parts of the reference grids that are germane to the
    ! present path

    vert_inds = (/ (i, i=n_vert,tan_ind,-1), (i, i=tan_ind,n_vert) /)
    n_path = size(vert_inds)
    n_tan = n_path / 2

    ! sign of phi vector
    phi_sign = (/ (-1, i=n_vert,tan_ind,-1), (+1, i=tan_ind,n_vert) /)
d322 2
a323 4
    phi_offset(:n_path) = phi_t
    if ( present(tan_press) ) then ! Earth intersecting ray
      ! Compute GP height (in KM.) of tan. press. below surface
      h_tan = dot_product(surf_temp(first:last),eta_t(first:last))*(tan_press-z_ref(1))/14.8
d325 2
d328 2
a334 1
      call output ( h_t, format='(f7.2)', before=', h_t = ' )
a337 1
      call output ( csq, before=', csq = ', advance='yes' )
d347 8
d565 1
a565 1
  end subroutine Pure_Metrics
d583 1
a583 1
    ! P_Grid are computed by Pure_Metrics, and then perhaps augmented
d808 1
a808 1
       "$Id: metrics_m.f90,v 2.39 2006/12/20 21:22:16 vsnyder Exp $"
d817 3
@


2.39
log
@Split metrics into pure H-Phi calculation, and everything else, in
preparation for inserting the minimum-Zeta point into the path.
@
text
@d518 1
a518 1
    integer :: I, J, SV_P, SV_T, SV_Z ! Loop inductors and subscripts
a520 1
    integer :: P_COEFFS    ! size(p_basis)
a521 1
    integer :: Z_COEFFS    ! size(z_basis)
a523 1
    logical :: NOT_ZERO_T(size(vert_inds),size(z_basis))
a526 1
    real(rp) :: ETA_T2(size(vert_inds),size(z_basis))
d581 2
d589 19
a607 1
    if ( present(dhidtlm) ) then
a617 1
      call get_eta_sparse ( p_basis, phi_t, eta_t, first, last )
d661 1
a661 7
    end if

    if ( do_dumps > 0 ) then
      call dump ( t_grid(:n_path), name='t_grid', format='(1pg14.6)', clean=clean )
      call dump ( dhitdzi(:n_path), name='dhitdzi', format='(1pg14.6)', clean=clean )
      if ( dump_stop > 0 ) stop
    end if
d668 1
a668 1
       "$Id: metrics_m.f90,v 2.37 2006/12/13 02:31:35 vsnyder Exp $"
d677 4
@


2.38
log
@Get rid of STATUS, reference H_Grid to Earth center instead of surface,
some cannonball polishing.
@
text
@d16 1
a16 1
  public :: Metrics
d26 1
a26 1
  ! ----------------------------------------------------  Metrics  -----
d28 12
a39 15
  subroutine Metrics ( &
          ! Input:
          &  phi_t, tan_ind, p_basis, z_ref, n_ref, h_ref, t_ref,      &
          &  dhidzij, csq, refract,                                    &
          ! Output:
          &  h_grid, p_grid, t_grid, dhitdzi, req,                     &
          ! Optional inputs:
          &  ddhidhidtl0, dhidtlm, tan_press, surf_temp, t_deriv_flag, &
          &  z_basis, h_tol,                                           &
          ! Optional outputs:
          &  ddhtdhtdtl0, dhitdtlm, dhtdtl0, dhtdzt,                   &
          &  do_calc_hyd, do_calc_t, eta_zxp, tan_phi_h, tan_phi_t )

    ! The goal of this subroutine is to return h_grid, p_grid
    ! that define a 2 d integration path
d44 1
a44 1
    use MLSKinds, only: RP, IP
a46 1
    use Phi_Refractive_Correction_m, only: Phi_Refractive_Correction
a58 1
    real(rp), intent(in) :: n_ref(:,:) ! Indices of refraction by t_phi_basis
a59 2
    real(rp), intent(in) :: t_ref(:,:) ! temperatures by t_phi_basis
    real(rp), intent(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
a61 2
    logical,  intent(in) :: refract    ! compute phi refractive correction

a62 1

a64 3
    real(rp), intent(out) :: t_grid(:) ! computed temperatures
    real(rp), intent(out) :: dhitdzi(:)! derivative of height wrt zeta
    !                                    --may be useful in future computations
d68 4
a71 36

    real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:) ! second order reference
    !   temperature derivatives. This is (height, phi_basis, zeta_basis).
    !   Needed only if present(dhidtlm).
    real(rp), optional, intent(inout) :: dhidtlm(:,:,:) ! reference temperature
    !   derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is 0.0 for
    !   all temperature coefficients. This is height X zeta_basis X phi_basis
    real(rp), optional, intent(in) :: Tan_press  ! Tangent pressure
    real(rp), optional, intent(in) :: Surf_temp(:)    ! Surface temperature at phi_basis
    logical, optional, intent(in) :: t_deriv_flag(:)  ! User's deriv. flags for
    !   Temperature. needed only if present(dhidtlm).
    real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
    !   Needed only if present(dhidtlm).
    real(rp), optional, intent(in) :: H_Tol      ! Height tolerance in kilometers
    !   for convergence of phi/h iteration

    ! optional outputs.

    real(rp), optional, intent(out) :: ddhtdhtdtl0(:) ! Second order 
    !          derivative at the tangent only---used for antenna affects.
    !          Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: dhitdtlm(:,:)
    !                             derivative of path position wrt temperature
    !                             statevector (z_basis X phi_basis)
    real(rp), optional, intent(out) :: dhtdtl0(:)  ! First order derivative at
    !           the tangent.  Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: dhtdzt      ! height derivative wrt
    !                                                pressure at the tangent
    logical, optional, intent(out) :: do_calc_hyd(:,:) ! nonzero locator for
    !           hydrostatic calculations.  Computed if present(dhidtlm)
    logical, optional, intent(out) :: do_calc_t(:,:) ! nonzero locater for
    !           temperature bases computations.  Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature
    !           Computed if present(dhidtlm)
    real(rp), optional, intent(out) :: tan_phi_h ! height at the tangent
    real(rp), optional, intent(out) :: tan_phi_t ! temperature at the tangent
a73 1

d84 1
a84 1
    integer :: N_VERT      ! size(z_ref)
d87 7
a112 10
    integer :: VERT_INDS(2*(size(z_ref)+1-tan_ind)) ! What to use in z_ref
    integer :: Stat(size(vert_inds))
    ! Values for stat:
    integer, parameter :: No_sol = 0 ! No solution
    integer, parameter :: Good = 1   ! Newton converged, tangent point, extrapolated
    integer, parameter :: Grid = 2   ! Close to a grid point

    logical :: NOT_ZERO_P(size(vert_inds),size(p_basis))

    real(rp) :: ETA_P(size(vert_inds),size(p_basis))
a113 2
    real(rp) :: N_GRID(size(vert_inds))     ! index of refraction
    real(rp) :: PHI_CORR(size(vert_inds))   ! the refractive correction
d122 1
d172 2
a173 2
    req_s = 0.001_rp*sqrt((earthrada**4*sp2 + csq**2*cp2) / &
                        & (earthrada**2*cp2 + csq*sp2))
d416 141
d569 3
a584 1
    if ( present(tan_phi_h) ) tan_phi_h = h_tan
d591 1
a591 22
    if ( present(dhidtlm) ) call Tangent_Temperature_Derivatives

    if ( do_dumps > 0 ) then
      call output ( h_tan, before='h_tan = ' )
      call output ( req, before=', req = ', advance='yes' )
      call dump ( p_grid(:n_path), name='p_grid', format='(1pg14.6)', clean=clean )
      call dump ( h_grid(:n_path), name='h_grid', format='(1pg14.6)', clean=clean )
      call dump ( t_grid(:n_path), name='t_grid', format='(1pg14.6)', clean=clean )
      call dump ( dhitdzi(:n_path), name='dhitdzi', format='(1pg14.6)', clean=clean )
      if ( dump_stop > 0 ) stop
    end if

  contains

    ! --------------------------  Tangent_Temperature_Derivatives  -----
    subroutine Tangent_Temperature_Derivatives

      real(rp), dimension(n_path,size(z_basis)) :: ETA_T2
      logical, dimension(n_path,size(z_basis)) :: NOT_ZERO_T
      integer :: I, J, SV_P, SV_T, SV_Z ! Loop inductors and subscripts
      integer :: P_COEFFS               ! size(p_basis)
      integer :: Z_COEFFS               ! size(z_basis)
d602 1
d646 7
a652 1
    end subroutine Tangent_Temperature_Derivatives
d654 1
a654 1
  end subroutine Metrics
d669 4
@


2.37
log
@Polish up a comment
@
text
@d33 1
a33 1
          &  h_grid, p_grid, t_grid, dhitdzi, req, status,             &
d70 1
d72 2
a73 1
    real(rp), intent(out) :: h_grid(:) ! computed heights
a78 2
    integer, intent(out) :: Status     ! 0 => No trouble, 1 => Convergence failed,
    !                                    2 => Resorted to 1d
d81 1
d98 1
d119 1
a191 1
    status = 0 ! assume it will work
d234 1
a234 1
    phi_sign = (/ (-1, i=1, n_vert-tan_ind+1), (+1, i=n_vert+tan_ind, 2*n_vert) /)
a479 4
    ! The forward model wants H_grid referenced to the equivalent Earth
    ! surface instead of its center.
    h_grid(:n_path) = h_grid(:n_path) - req

d580 1
a580 1
       "$Id: metrics_m.f90,v 2.36 2006/12/09 02:25:42 vsnyder Exp $"
d589 3
@


2.36
log
@Size some arrays more accurately, use First:Last version of get_eta_matrix,
remove Tangent_Temperature_Derivatives module procedure since it isn't used
@
text
@d126 1
a126 1
    integer :: N_Tan       ! Tangent index in path, usually N_Path/2
d471 1
a471 1
      call phi_refractive_correction ( n_grid, h_grid(:n_path), phi_corr )
d582 1
a582 1
       "$Id: metrics_m.f90,v 2.35 2006/12/08 23:57:08 vsnyder Exp $"
d591 4
@


2.35
log
@Revise earth-intersecting metrics
@
text
@d117 5
a121 4
    integer :: Do_Dumps = -1  ! -1 = first time, 0 = no dump, >0 = dump
    integer :: Dump_Stop = -1 ! -1 = first time, 0 = no dump, >0 = dump/stop
    integer :: H_Phi_Dump = -1 ! -1 = first time, 0 = no dump, >0 = dump
    integer :: H_Phi_Stop = -1 ! -1 = first time, 0 = no dump, >0 = dump/stop
a142 1
    real(rp) :: Neg_H_Tan  ! sub earth tangent height
d158 1
a158 1
    real(rp) :: ETA_P(size(p_grid),size(p_basis))
d160 4
a163 4
    real(rp) :: N_GRID(size(p_grid))        ! index of refraction
    real(rp) :: PHI_CORR(size(p_grid))      ! the refractive correction
    real(rp) :: PHI_OFFSET(size(p_grid))    ! PHI_T or a function of NEG_H_TAN
    real(rp) :: PHI_SIGN(size(p_grid))      ! +/- 1.0
d199 3
a201 3
    call get_eta_sparse ( p_basis, phi_t, eta_t )
    h_surf = dot_product(h_ref(1,:),eta_t)
    h_t = dot_product(h_ref(tan_ind,:),eta_t) - h_surf
d232 1
a232 1
    phi_sign(:n_path) = (/ (-1, i=1, n_vert-tan_ind+1), (+1, i=n_vert+tan_ind, 2*n_vert) /)
d241 2
a242 2
      h_tan = dot_product(surf_temp,eta_t)*(tan_press-z_ref(1))/14.8
      phi_offset(n_vert+1:2*n_vert) = phi_t-2.0_rp*Acos((req+h_tan)/req)
d254 1
a254 1
      call dump ( phi_offset(:n_path), name='phi_offset', clean=clean )
d467 1
a467 1
      call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p(:n_path,:) )
d471 2
a472 2
      call phi_refractive_correction ( n_grid(:n_path), h_grid(:n_path), phi_corr(:n_path) )
      p_grid(:n_path) = p_grid(:n_path) + phi_sign(:n_path) * phi_corr(:n_path)
d474 1
a474 1
        & call dump ( phi_corr(:n_path), format='(1pg14.6)', &
d485 1
a485 1
    call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p(:n_path,:), NOT_ZERO = not_zero_p )
d494 4
a497 2
    if ( present(tan_phi_t) ) tan_phi_t = dot_product(t_ref(tan_ind,:),eta_t)
    if ( present(dhtdzt) ) dhtdzt = dot_product(dhidzij(tan_ind,:),eta_t)
d533 2
a534 1
        dhidtlm(:,i,:) = dhidtlm(:,i,:) - dot_product(dhidtlm(1,i,:), eta_t)
d555 1
a555 1
              eta_zxp(:,sv_t) = eta_t2(:,sv_z) * eta_p(:n_path,sv_p)
d562 1
a562 1
              dhitdtlm(:,sv_t) = dhidtlm(vert_inds(:),sv_z,sv_p) * eta_p(:n_path,sv_p)
a578 105
  ! --------------------------  Tangent_Temperature_Derivatives  -----
  subroutine Tangent_Temperature_Derivatives ( phi_t, tan_ind, p_basis, p_path, &
    & z_basis, z_path, ddhidhidtl0, t_deriv_flag, dhitdtlm, ddhtdhtdtl0, &
    & dhidtlm, dhtdtl0, do_calc_hyd, do_calc_t, eta_zxp )

    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
    use MLSKinds, only: RP, IP

    ! Inputs
    real(rp), intent(in) :: phi_t      ! orbit projected tangent geodetic angle
    integer(ip), intent(in) :: tan_ind ! tangent height index, 1 = center of
    !                                    longest path
    real(rp), intent(in) :: p_basis(:) ! horizontal temperature representation
    !                                    basis
    real(rp), intent(in) :: P_Path(:)  ! Phi on the path
    real(rp), intent(in) :: z_basis(:) ! vertical temperature basis
    real(rp), intent(in) :: z_path(:)  ! -log pressures (zetas) along the path.
    real(rp), intent(in) :: ddhidhidtl0(:,:,:) ! second order reference
    !   temperature derivatives. This is (height, phi_basis, zeta_basis).
    logical, intent(in) :: t_deriv_flag(:)  ! User's deriv. flags for
    !   Temperature. needed only if present(dhidtlm).

    ! Inout
    real(rp), intent(inout) :: dhidtlm(:,:,:) ! reference temperature
    !   derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is 0.0 for
    !   all temperature coefficients. This is height X zeta_basis X phi_basis

    ! Outputs
    real(rp), intent(out) :: ddhtdhtdtl0(:) ! Second order  derivative at the
    !          tangent only---used for antenna affects.
    real(rp), intent(out) :: dhitdtlm(:,:)
    !          derivative of path position wrt temperature
    !          statevector (z_basis X phi_basis)
    real(rp), intent(out) :: dhtdtl0(:)  ! First order derivative at
    !          the tangent.
    logical, intent(out) :: do_calc_hyd(:,:) ! nonzero locator for
    !          hydrostatic calculations.
    logical, intent(out) :: do_calc_t(:,:) ! nonzero locater for
    !          temperature bases computations.
    real(rp), intent(out) :: eta_zxp(:,:) ! eta matrix for temperature

    real(rp) :: ETA_P(size(p_path),size(p_basis))
    real(rp) :: ETA_T(size(p_basis))
    real(rp) :: ETA_T2(size(z_path),size(z_basis))
    integer :: I, J, SV_P, SV_T, SV_Z ! Loop inductors and subscripts
    logical :: NOT_ZERO_P(size(p_path),size(p_basis))
    logical :: NOT_ZERO_T(size(z_path),size(z_basis))
    integer :: N_path                 ! size(z_path)
    integer :: P_COEFFS               ! size(p_basis)
    integer :: Z_COEFFS               ! size(z_basis)
    integer :: Vert_Inds(size(z_path)) ! To access dhitdlm

    call get_eta_sparse ( p_basis, p_path, eta_p, NOT_ZERO = not_zero_p )
    call get_eta_sparse ( p_basis, phi_t, eta_t )

    ! adjust the 2d hydrostatic relative to the surface
    p_coeffs = size(p_basis)
    z_coeffs = size(z_basis)
    do i = 1, z_coeffs
      dhidtlm(:,i,:) = dhidtlm(:,i,:) - dot_product(dhidtlm(1,i,:), eta_t)
    end do

    j = z_coeffs * p_coeffs
    dhtdtl0 = RESHAPE(dhidtlm(tan_ind,:,:) * SPREAD(eta_t,1,z_coeffs),&
                   & (/j/))

    ddhtdhtdtl0 = RESHAPE( &
                 ddhidhidtl0(tan_ind,:,:) * SPREAD(eta_t,1,z_coeffs), &
                   & (/j/))

    ! compute the path temperature noting where the zeros are
    call get_eta_sparse ( z_basis, z_path, eta_t2, NOT_ZERO = not_zero_t )

    n_path = size(z_path)
    vert_inds = (/ (i, i = n_path/2, tan_ind, -1), (i, i = tan_ind, n_path/2) /)

    sv_t = 0
    do sv_p = 1 , p_coeffs
      do sv_z = 1 , z_coeffs
        sv_t = sv_t + 1
        if ( t_deriv_flag(sv_t) ) then
          do_calc_t(:,sv_t) = not_zero_t(:,sv_z) .and. not_zero_p(:,sv_p)
          where ( do_calc_t(:,sv_t) )
            eta_zxp(:,sv_t) = eta_t2(:,sv_z) * eta_p(:n_path,sv_p)
          elsewhere
            eta_zxp(:,sv_t) = 0.0
          end where
          do_calc_hyd(:,sv_t) = not_zero_p(:,sv_p) .and. &
            &                   dhidtlm(vert_inds(:),sv_z,sv_p) > 0.0_rp
          where ( do_calc_hyd(:,sv_t) )
            dhitdtlm(:,sv_t) = dhidtlm(vert_inds(:),sv_z,sv_p) * eta_p(:n_path,sv_p)
          elsewhere
            dhitdtlm(:,sv_t) = 0.0
          end where
        else
          do_calc_t(:,sv_t) = .false.
          eta_zxp(:,sv_t) = 0.0
          do_calc_hyd(:,sv_t) = .false.
          dhitdtlm(:,sv_t) = 0.0
        end if
      end do
    end do

  end subroutine Tangent_Temperature_Derivatives

d582 1
a582 1
       "$Id: metrics_m.f90,v 2.34 2006/12/08 22:50:55 vsnyder Exp $"
d591 3
@


2.34
log
@Complete revision
@
text
@d30 2
a31 2
          &  phi_t, tan_ind, p_basis, z_ref, n_ref, h_ref, t_ref,     &
          &  dhidzij, csq, refract,                                   &
d33 1
a33 1
          &  h_grid, p_grid, t_grid, dhitdzi, req, status,            &
d35 2
a36 2
          &  ddhidhidtl0, dhidtlm, neg_h_tan, t_deriv_flag, z_basis,  &
          &  h_tol,                                                   &
d38 1
a38 1
          &  ddhtdhtdtl0, dhitdtlm, dhtdtl0, dhtdzt,                  &
d87 2
a88 1
    real(rp), optional, intent(in) :: neg_h_tan  ! sub earth tangent height
d142 1
d239 4
a242 3
    if ( present(neg_h_tan) ) then
      phi_offset(n_vert+1:2*n_vert) = phi_t-2.0_rp*Acos((req+neg_h_tan)/req)
      h_tan = neg_h_tan
d684 1
a684 1
       "$Id: metrics_m.f90,v 2.31 2006/08/25 19:39:20 vsnyder Exp $"
d693 3
@


2.33
log
@Change some dumps
@
text
@d39 1
a39 2
          &  do_calc_hyd, do_calc_t, eta_zxp, tan_phi_h, tan_phi_t,   &
          &  z_grid, n_path_out )
d41 2
a42 2
    ! The goal of this program is to return a matrix of h_grids
    ! and t_grids that define 2 d integration paths
d48 1
a48 1
    use MLSMessageModule, only: MLSMessage, MLSMSG_Warning
d51 1
a51 1
    use Toggles, only: Emit, Switches, Toggle
a72 1
    ! t_grid is not computed if present(z_grid) .and. present(n_path_out)
d94 1
a94 1
    !
a95 1
    ! Most are not computed if present(z_grid) .and. present(n_path_out)
d114 32
a145 30
    real(rp), optional, intent(out) :: z_grid(:) ! If present, augment p_grid
    !           with phi's from p_basis (excluding really close values),
    !           compute corresponding h_grid, t_grid, z_grid and dhitdzi, and
    !           report the revised length in N_Path_out.
    integer, optional, intent(out) :: N_Path_out ! Goes with z_grid, q.v.

    ! Local variables.  CAN WE GET SOME COMMENTS FOR EACH OF THESE?
    integer, save :: Do_Dumps = -1  ! -1 = first time, 0 = no dump, >0 = dump
    integer, save :: Dump_Stop = -1 ! -1 = first time, 0 = no dump, >0 = dump/stop
    integer, save :: H_Phi_Dump = -1 ! -1 = first time, 0 = no dump, >0 = dump
    integer, save :: H_Phi_Stop = -1 ! -1 = first time, 0 = no dump, >0 = dump/stop
    integer :: I, I1(1)  ! I1 is for output from MAXLOC
    integer :: ITER      ! Counter for H/Phi iteration
    integer :: Min_Zeta  ! Position where minimum zeta added to z_grid
    integer :: My_Tan    ! Tangent index might change if we add phi's
    integer :: N_PATH    ! Path length = 2*(size(z_ref)+1-tan_ind)
    integer :: NO_OF_BAD_FITS
    integer :: N_VERT    ! size(z_ref)
    integer :: P_COEFFS  ! size(p_basis)

    logical :: Converge  ! H/Phi iteration has converged

    real(rp) :: CP2      ! Cos^2 phi_t
    real(rp) :: H_SURF   ! Height of the reference surface
    real(rp) :: H_T      ! Tangent height
    real(rp) :: H_TAN    ! Either H_T or NEG_H_TAN
    real(rp) :: My_H_Tol
    real(rp) :: Phi_Min  ! Phi where minimum zeta occurs
    real(rp) :: SP2      ! Sin^2 phi_t
    real(rp) :: Zeta_Min ! Minimum zeta
d148 5
a153 1
    logical :: MASK(size(vert_inds))
a155 1
    real(rp) :: CVF_Z_GRID(size(vert_inds)) ! z_ref(vert_inds)
a157 2
    real(rp) :: H_ZMIN                      ! Height at min zeta
    real(rp) :: H_NEW(2) ! At zeta max and another tangent pressure pt
a158 3
    real(rp) :: OLD_HTS1(size(vert_inds))   ! Previous H in H/Phi iteration,
                                            ! from interpolation
    real(rp) :: OLD_HTS2(2)  ! Previous H in H/Phi iteration, from ACOS(phi)
d163 18
a180 3
    ! Begin program

    if ( do_dumps < 0 ) then ! First time only
d185 1
a185 4
    end if

    my_h_tol = 0.01_rp
    if ( present(h_tol) ) my_h_tol = h_tol
d188 2
d218 3
a220 3
    req = 0.001_rp*sqrt((earthrada**4*sp2 + csq**2*cp2) / &
                      & (earthrada**2*cp2 + csq*sp2)) &
        & + h_surf
d227 1
a227 1
    if ( present(z_grid) ) z_grid(:n_path) = z_ref(vert_inds)
d241 1
d243 11
a253 17
    cvf_z_grid = z_ref(vert_inds)

    ! We will subtract req from h_grid at the end of everything.
    ! We add it in now to avoid forming req+h_grid(:n_path), which would
    ! require an array temp.
    h_grid(:n_path) = h_t + req
    h_new = h_grid(1)

    !{Estimate the phi's using the tangent height as a first guess.

    p_grid(:n_path) = phi_offset(:n_path)

    if ( .not. present(neg_h_tan) ) then
      ! tangent is above the earth surface
      ! force the del phi at the tangent to be zero
      p_grid(n_vert - tan_ind + 1) = phi_offset(n_vert - tan_ind + 1)
      p_grid(n_vert - tan_ind + 2) = phi_offset(n_vert - tan_ind + 2)
d256 46
a301 68
    ! Estimate some new heights.
    ! This is going to have some small surface errors away
    ! from the tangent but we ignore this issue for now.
    ! The following lines replace an extremely sparse matrix
    ! multiplication with a less memory intensive
    ! and probably faster alternative.

    ! now these parts will change with iteration therefore these steps
    ! get repeated

    !{ Interpolate $h$ onto the $\phi$ grid, then compute
    !  $\phi = \phi_t \pm \cos^{-1}
    !   \left( \frac{h_t + H^\oplus_t}{h+H^\oplus_t} \right) =
    !   \phi_t \pm \cos^{-1}
    !   \left( \frac{h_t + R^\oplus_{\text{eq}}}{h+R^\oplus_{\text{eq}}} \right)$.
    !  Iterate until $h$ doesn't change too much.  This is Equation (5.24)
    !  in the 19 August 2004 ATBD JPL D-18130.

    if ( h_phi_dump > 0 ) call dump ( p_basis, name='p_basis', clean=.true. )
    iter = 0
    min_zeta = 0
    old_hts2 = h_t
    call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p(:n_path,:) )
    do

      old_hts1(:n_path) = h_grid(:n_path)
      do i = 1, n_path
        h_grid(i) = max ( h_tan, &
          &               dot_product(h_ref(vert_inds(i),:), eta_p(i,:)) - h_surf ) &
          &               + req ! We will subtract req at the end of everything
        if ( refract ) &
          & n_grid(i) = dot_product(n_ref(vert_inds(i),:), eta_p(i,:))
      end do

      call Assure_H_is_Monotone

      mask = abs(old_hts1(:n_path)-h_grid(:n_path)) > my_h_tol
      no_of_bad_fits = count(mask)
      converge = no_of_bad_fits == 0
      iter = iter + 1
      if ( iter == 20 ) exit

      ! recompute subsurface phi_s - phi_t because we need it for p_grid,
      ! which we need for h_grid, upon which we are iterating.
      if ( present(neg_h_tan) ) &
        & phi_offset(n_vert+1:2*n_vert) = phi_t - &
                  & 2.0_rp*Acos((req+neg_h_tan)/h_grid(n_vert+1:2*n_vert))

      if ( refract ) then
        call phi_refractive_correction ( n_grid(:n_path), h_grid(:n_path), phi_corr(:n_path) )

        !{ Apply the refractive correction
        !
        !  $\phi = \phi_t \pm \left[ \phi_{\text{corr}} + \cos^{-1}
        !   \left( \frac{h_t + H^\oplus_t}{h+H^\oplus_t} \right)\right] =
        !   \phi_t \pm \left[ \phi_{\text{corr}} +  \cos^{-1}
        !   \left( \frac{h_t + R^\oplus_{\text{eq}}}
        !               {h+R^\oplus_{\text{eq}}} \right)\right]$.
        p_grid(:n_path) = phi_offset(:n_path) + &
          & phi_sign(:n_path) * ( phi_corr(:n_path) + Acos((req+h_tan)/h_grid(:n_path)) )
      else
        !{ or not\dots. $\phi = \phi_t \pm \cos^{-1} \left( \frac{h_t + H^\oplus_t}{h + H^\oplus_t} \right)
        !       = \phi_t \pm \cos^{-1} \left( \frac{h_t + R^\oplus_{\text{eq}}}
        !                                          {h + R^\oplus_{\text{eq}}} \right)$.
        !
        ! This is Equation (5.24) in the 19 August 2004 ATBD JPL D-18130.
        p_grid(:n_path) = phi_offset(:n_path) + &
          & phi_sign(:n_path) * Acos((req+h_tan)/h_grid(:n_path))
d304 146
a449 18
      if ( h_phi_dump > 0 ) then
        call output ( req+h_tan, before='req+h_tan = ' )
        call output ( iter, before=', iter = ', advance='yes' )
        call dump ( h_grid(:n_path), name='h_grid', clean=.true. )
        call dump ( p_grid(:n_path), name='p_grid', clean=.true. )
      end if

      call get_eta_sparse ( p_basis, p_grid(:n_path), eta_p(:n_path,:) )
      if ( present(z_grid) ) then
        ! Find the maximum zeta by Hermite interpolation
        do i = 1, n_path
          ! compute the height vertical derivative w.r.t. zeta grid
          dhitdzi(i) = dot_product(dhidzij(vert_inds(i),:), eta_p(i,:))
        end do
        call get_min_zeta
        if ( min_zeta > 0 ) then
          if ( abs(old_hts2(1)-h_zmin ) > my_h_tol ) converge = .false.
          old_hts2(1)=h_zmin
d451 2
a452 7
      end if

      if ( converge ) exit

    end do

    if ( no_of_bad_fits > 0 ) call bad_fits ( eta_p(1,:) )
d454 2
a455 2
    !  Compute final set of angles (Equation (5.24) again) now that we have
    !  final heights
d457 3
a459 6
    if ( h_phi_dump > 0 ) then
      if ( any((req+h_tan)/h_grid(:n_path) > 1.0 ) ) then
        call output ( req+h_tan, before='ACOS((req+h_tan)/h_grid(:n_path)) is going to fail, req+h_tan =' )
        call dump ( h_grid(:n_path), name='h_grid', clean=.true. )
      end if
    end if
d461 2
d464 9
a472 23
        !{ Apply the refractive correction
        !
        !  $\phi = \phi_t \pm \left[ \phi_{\text{corr}} + \cos^{-1}
        !   \left( \frac{h_t + H^\oplus_t}{h+H^\oplus_t} \right)\right] =
        !   \phi_t \pm \left[ \phi_{\text{corr}} +  \cos^{-1}
        !   \left( \frac{h_t + R^\oplus_{\text{eq}}}
        !               {h+R^\oplus_{\text{eq}}} \right)\right]$.

      p_grid(:n_path) = phi_offset(:n_path) + &
        & phi_sign(:n_path) * ( phi_corr(:n_path) + Acos((req+h_tan)/h_grid(:n_path)) )
    else
        !{ or not\dots. $\phi = \phi_t \pm \cos^{-1} \left( \frac{h_t + H^\oplus_t}{h + H^\oplus_t} \right)
        !       = \phi_t \pm \cos^{-1} \left( \frac{h_t + R^\oplus_{\text{eq}}}
        !                                          {h + R^\oplus_{\text{eq}}} \right)$.
        !
        ! This is Equation (5.24) in the 19 August 2004 ATBD JPL D-18130.

      p_grid(:n_path) = phi_offset(:n_path) + &
        & phi_sign(:n_path) * Acos((req+h_tan)/h_grid(:n_path))
    end if
    if ( .not. present(neg_h_tan) ) then
      p_grid(n_vert - tan_ind + 1) = phi_offset(n_vert - tan_ind + 1)
      p_grid(n_vert - tan_ind + 2) = phi_offset(n_vert - tan_ind + 2)
d475 2
d479 2
a480 24
    ! Must we add p_basis to p_grid?
    if ( present(z_grid) .and. present(n_path_out) ) then
      my_tan = n_path / 2
      do i = 1, size(p_basis)
        call augment_grids ( p_basis(i) )
      end do
      ! For now, we are assuming the tangent is at the midpoint of the
      ! path.  If we've added points unsymmetrically, we need to add some
      ! more points to balance things.  When the rest of the code is able
      ! to handle paths for which the tangent isn't at the midpoint, delete
      ! this.
      do while ( my_tan /= n_path / 2 )
        if ( my_tan < n_path / 2 ) then
          ! Need to add a point before the tangent to balance it
          i1 = maxloc(p_grid(2:my_tan)-p_grid(1:my_tan-1))
        else ! Need to add a point after the tangent to balance it
          i1 = maxloc(p_grid(my_tan+1:n_path)-p_grid(my_tan:n_path-1)) + my_tan
        end if
        i = i1(1) ! Because maxloc returns a rank-1 array of extent 1
        call augment_grids ( 0.5 * (p_grid(i)+p_grid(i+1)) )
      end do
      n_path_out = n_path
      return
    end if
d500 4
a503 4
      call dump ( h_grid(:n_path), name='h_grid', clean=.true. )
      call dump ( p_grid(:n_path), name='p_grid', clean=.true. )
      call dump ( t_grid(:n_path), name='t_grid', clean=.true. )
      call dump ( dhitdzi(:n_path), name='dhitdzi', clean=.true. )
a508 217
    ! ---------------------------------------  Assure_H_is_Monotone  -----
    subroutine Assure_H_is_Monotone
      ! Check whether H_Grid is monotone increasing away from the midpoint.
      ! If not, replace nonincreasing points by interpolation in Zeta
      ! (cvf_z_grid) using nearby ones that are increasing.
      integer :: I, I1, I2, J, M
      real :: R
      i1 = n_path/2-1
      i2 = 1
      do m = -1, 1, 2
        do i = i1, i2, m
          if ( h_grid(i) <= h_grid(i-m) ) then ! not increasing
            do j = i+m, i2, m
              if ( h_grid(j) > h_grid(i) ) exit
            end do
            if ( j /= i2+m ) then ! not at the end
              r = (cvf_z_grid(i)-cvf_z_grid(i-m)) / &
                & (cvf_z_grid(j)-cvf_z_grid(i-m))
              h_grid(i) = (1.0 - r) * h_grid(i-m) + r * h_grid(j)
            else ! at the end
              h_grid(i) = h_grid(i-m) + 1.0 ! use SWAG method
            end if
          end if
        end do
        i1 = n_path/2 + 2
        i2 = n_path
      end do
    end subroutine Assure_H_is_Monotone

    ! ----------------------------------------------  Augment_Grids  -----
    subroutine Augment_Grids ( New_Phi )

      !{ Let $\phi$ be represented by {\tt p\_basis}, $\zeta^\text{ref}$ by
      !  {\tt z\_ref}, $H^\text{ref}$ by {\tt h\_ref} and $\zeta$ by {\tt
      !  z\_grid}. Compute additional $\zeta_m = \zeta^\text{ref}_i - \frac{T_i
      !  - \sqrt{T_i^2 + 2 \Gamma Z (H_m-H^\text{ref}_{i,m})}}{\Gamma}$ at
      !  $\phi_m$ points along the path, where $H_m = \frac{H_t}{\cos \phi_m}$,
      !  $H_t$ is the tangent height, $\Gamma =
      !  \frac{T_{i+1}-T_i}{\zeta^\text{ref}_{i+1}-\zeta^\text{ref}_i}$, $Z =
      !  \frac{(T_{i+1}+T_i)(\zeta^\text{ref}_{i+1}-\zeta^\text{ref}_i)}
      !  {2(H^\text{ref}_{i+1,m}-H^\text{ref}_{i,m})}$, and $i$ is such that
      !  $H^\text{ref}_{i,m} < H_m < H^\text{ref}_{i+1,m}$.

      use MLSKinds, only: RP

      real(rp), intent(in) :: New_Phi

      integer :: J
      real(rp) :: G, R, Z
return
      ! Determine whether to add a phi.  Don't add it at the end.
      if ( all(abs(new_phi-p_grid(:n_path)) > 0.01) .and. &
        & new_phi > p_grid(1) .and. new_phi < p_grid(n_path) ) then
        n_path = n_path + 1
        ! Find where the new phi goes by doing an insertion sort,
        ! assuming p_grid is already sorted.
        do j = n_path, 2, -1
          if ( new_phi > p_grid(j) ) then
            h_grid(j) = h_grid(j-1)
            p_grid(j) = p_grid(j-1)
            if ( refract ) phi_corr(j) = phi_corr(j-1)
            phi_offset(j) = phi_offset(j-1)
            phi_sign(j) = phi_sign(j-1)
            t_grid(j) = t_grid(j-1)
            z_grid(j) = z_grid(j-1)
            if ( j == my_tan ) my_tan = my_tan + 1
          else
            p_grid(j) = new_phi
            r = (new_phi - p_grid(j-1)) / &
              & (p_grid(j+1) - p_grid(j-1))
            if ( refract ) then
              phi_corr(j) = phi_corr(j-1) * (1.0-r) + phi_corr(j+1) * r
              h_grid(j) = (h_tan + req) / &
                & cos(p_grid(j)-phi_offset(j)-phi_sign(j)*phi_corr(j)) - req
            else ! No refractive correction
              h_grid(j) = h_tan/cos(p_grid(j)-phi_offset(j))
            end if
            g = (t_grid(j+1)-t_grid(j-1))/(z_grid(j+1)-z_grid(j-1))
            z = ((t_grid(j+1)+t_grid(j-1))*(z_grid(j+1)-z_grid(j-1))) / &
              & (2.0_rp * (h_grid(j+1)-h_grid(j-1)))
            z_grid(j) = z_grid(j-1) - (t_grid(j-1) - &
              &            sqrt(t_grid(j-1)**2 + 2.0_rp * G * Z * (h_grid(j+1) - &
              &                 h_grid(j-1)))) / &
              &           g
            ! In case another one lands in the same area:
            t_grid(j) = t_grid(j-1) * (1.0-r) + t_grid(j+1) * r
            exit
          end if
        end do ! j = n_path, 2, -1
      end if
    end subroutine Augment_Grids

    ! -------------------------------------------------  Bad_Fits  -----
    subroutine Bad_Fits ( ETA_P_1 )

      real(rp), dimension(:), intent(out) :: ETA_P_1 ! Scratch, not used by caller
      
      integer, dimension(no_of_bad_fits) :: JUNK
      integer :: END_IND
      integer :: HI_PT
      integer :: LOW_PT
      integer :: ST_IND

      if ( toggle(emit) ) then
        call MLSMessage ( MLSMSG_Warning, moduleName, &
          & 'Full convergence not achieved, implementing an improved approximation patch' )
        status = 1
        call output ( 'pth ind, error', advance='yes' )
      end if

      ! We are going to assume that the tangent value is good.
      ! The following is an F90 specific design that is quite different
      ! from the IDL code

      junk = PACK((/(i,i=1,n_path)/),mask)
      st_ind = 1
      do end_ind = 1, no_of_bad_fits
        ! Find ranges of contiguous indicies
        if ( end_ind < no_of_bad_fits ) then
          if ( junk(end_ind+1) - junk(end_ind) < 2 ) cycle
        end if

        if ( toggle(emit) ) then
          call output ( junk(st_ind), places=7, after=', ' )
          call output ( old_hts1(junk(st_ind))-h_grid(junk(st_ind)), advance='yes' )
        end if

        if ( junk(st_ind) ==  1 .or. junk(end_ind) == n_path ) then
          call mlsMessage ( mlsmsg_warning, moduleName, 'resorting to 1d option in metrics' )
          status = 2
          ! resort to 1 d equivalent
          call get_eta_sparse ( p_basis, phi_t, eta_p_1 )
          do i = st_ind, end_ind
            h_grid(junk(i)) = &
              & dot_product(h_ref(vert_inds(junk(i)),:),eta_p_1) - h_surf + req
          end do
        else
          ! find which side of the tangent we are on
          if ( junk(st_ind) <= n_path/2 ) then ! near observer side
            low_pt = junk(end_ind) + 1
            hi_pt  = MAX(junk(st_ind) - 1, 1)
          else                                 ! far observer side
            low_pt = junk(st_ind) - 1
            hi_pt  = MIN(junk(end_ind) + 1, n_path)
          end if
          ! Correct unconverged H_Grid using linear Zeta interpolation
          h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) + &
             & (h_grid(hi_pt) - h_grid(low_pt)) * &
             & (cvf_z_grid(junk(st_ind):junk(end_ind))-cvf_z_grid(low_pt)) / &
             & (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
        end if
        st_ind = end_ind + 1
        if ( h_phi_dump > 0 ) call dump ( h_grid(:n_path), 'h_grid in Bad_Fits', clean=.true. )
      end do

      call Assure_H_is_Monotone
      if ( h_phi_stop > 0 ) stop

    end subroutine Bad_Fits

    ! -----------------------------------------------  Get_Min_Zeta  -----
    subroutine Get_Min_Zeta
    ! Find Zeta_Min = the minimum zeta and Min_Zeta = where in z_grid it
    ! appears.  Min_Zeta == 0 if it's too close to a phi that's already there.
      use Hermite_Coeffs_m, only: Hermite_coeffs
      real(rp) :: Coeffs(0:3,2:n_path) ! coeffs(:,i) for [i-1,i] segment of path
      real(rp) :: D, dz_dphi(n_path)
      integer :: I
      real(rp) :: X_min, Zeta
      !{ First get {\tt dz\_dphi} =
      !  $\frac{\text{d}h}{\text{d}\phi} \frac{\text{d}\zeta}{\text{d}h} =
      !   \sec \phi \tan \phi \frac{\text{d}\zeta}{\text{d}h} =
      !   (H+R^\oplus_{\text{eq}}) \tan \phi \frac{\text{d}\zeta}{\text{d}h}$.
      if ( refract ) then
        dz_dphi = (h_grid(:n_path)+req) * &
          &  tan(p_grid(:n_path)-phi_offset(:n_path)-phi_sign(:n_path)*phi_corr(:n_path)) / &
          &  dhitdzi(:n_path)
      else
        dz_dphi = (h_grid(:n_path)+req) * &
          &  tan(p_grid(:n_path)-phi_offset(:n_path)) / &
          &  dhitdzi(:n_path)
      end if
      !{ Get the coefficients for the Hermite polynomials in each segment of
      ! the path.  Use them to compute zeta min:
      ! $\zeta^\prime = c_1 + c_2 x + c_3 x^2$, so $\zeta^\prime = 0$ when
      ! $x = \frac{-c_2 -\sqrt{c_2^2-3 c_1 c_3}}{3c_3}$ provided $c_3 \neq 0$
      ! or $x = -\frac{c_1}{2 c_2}$ if $c_3 = 0$.  If $x<0$ or $x>1$ or $x$
      ! is complex, the extremum is at a grid point.  See wvs-041r1.
      call hermite_coeffs ( z_grid(:n_path), dz_dphi, coeffs )
      zeta_min = minval(z_grid(:n_path))
      min_zeta = 0               ! Indicate it's already in the grid
      do i = 2, n_path
        if ( coeffs(3,i) == 0.0 ) then
          if ( coeffs(2,i) <= 0.0 ) cycle ! no minimum within the interval
          x_min = -0.5 * coeffs(1,i) / coeffs(2,i)
        else
          d = coeffs(2,i)**2 - 3.0*coeffs(1,i)*coeffs(3,i)
          if ( d < 0 ) cycle ! complex zero
          x_min = (-coeffs(2,i) - sqrt(d))/(3.0*coeffs(3,i))
        end if
        zeta = coeffs(0,i) + x_min * ( coeffs(1,i) + x_min * (coeffs(2,i) + &
          &      x_min * coeffs(3,i)))
        if ( zeta < zeta_min ) then
          if ( min(abs(x_min-0.005),abs(x_min-0.995)) < 0.005 ) then
            ! 0 < x_min < 0.01 or 0.99 < x_min < 1.0
            min_zeta = 0 ! It's already in the grid
          else
            zeta_min = zeta
            phi_min = x_min * p_grid(i) + (1.0-x_min) * p_grid(i-1)
            h_zmin = (h_tan + req) / &
                & cos(phi_min-phi_offset(i-1)-phi_sign(i-1)*phi_corr(i-1)) - req
            min_zeta = i
          end if
        end if
      end do ! i
    end subroutine Get_Min_Zeta

d515 1
d518 8
a525 1
      ! adjust the 2d hydrostatic relative to the surface
d540 1
a540 1
      call get_eta_sparse ( z_basis, cvf_z_grid, eta_t2, NOT_ZERO = not_zero_t )
d573 105
d681 1
a681 1
       "$Id: metrics_m.f90,v 2.32 2006/09/28 19:00:22 vsnyder Exp $"
a689 119
! Revision 2.32  2006/09/28 19:00:22  vsnyder
! Correct array bounds problem if no refraction
!
! Revision 2.31  2006/08/25 19:39:20  vsnyder
! Recomitted to get correct comment into the log:  Substantial revision,
! and simplification, works only for one pointing now, repair ACOS bug.
!
! Revision 2.30  2006/08/25 19:37:07  vsnyder
! Substantial revision
!
! Revision 2.29  2006/06/29 19:34:17  vsnyder
! Remove capability to handle more than one tangent -- substantial simplification
!
! Revision 2.28  2006/03/06 20:44:48  vsnyder
! Cannonball polishing
!
! Revision 2.27  2006/01/26 03:06:17  vsnyder
! Don't deallocate 'mask' until after it's no longer needed!
!
! Revision 2.26  2006/01/05 00:03:52  vsnyder
! Implement refractive correction for Phi
!
! Revision 2.25  2005/12/10 03:31:09  vsnyder
! Replace SUM(A*B) with Dot_Product(A,B) to avoid array temps
!
! Revision 2.24  2005/12/10 01:53:23  vsnyder
! Use get_eta_sparse_1d
!
! Revision 2.23  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.22  2004/09/01 01:47:56  vsnyder
! Add status argument
!
! Revision 2.21  2004/01/23 18:44:57  bill
! problem with approximate correction patch when interpolation can't be done tentatively implimentaed
!
! Revision 2.20  2003/11/14 21:22:46  livesey
! Bug fix and output tidy up
!
! Revision 2.19  2003/06/27 23:43:34  vsnyder
! Remove unreferenced USE names
!
! Revision 2.18  2003/06/20 23:41:48  vsnyder
! Revise how compound etas are computed -- hopefully a faster method
!
! Revision 2.17  2003/05/22 20:12:32  vsnyder
! Get rid of some array temps
!
! Revision 2.16  2002/10/25 22:24:08  livesey
! Made the warning output optional
!
! Revision 2.15  2002/10/08 17:08:05  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.14  2002/10/08 14:42:57  bill
! fixed bug in non convergent estimator?
!
! Revision 2.13  2002/10/01 02:27:49  vsnyder
! Reduce number of array temps, move allocation for some out of loops.  Fix
! a bug (junk could be accessed after being deallocated).  Cosmetic changes.
!
! Revision 2.12  2002/09/26 20:14:24  vsnyder
! Get PI from Units module
!
! Revision 2.11  2002/09/25 23:35:13  vsnyder
! Simplify equivalent earth radius, insert copyright notice
!
! Revision 2.10  2002/09/06 18:16:41  vsnyder
! Cosmetic changes, move USEs from module scope to procedure scope
!
! Revision 2.9  2002/08/10 00:13:33  livesey
! Tiny bug fix to Bill's bug fix
!
! Revision 2.8  2002/08/10 00:08:47  bill
! fixed bad pt correction bug
!
! Revision 2.7  2002/07/05 07:52:50  zvi
! Coor. switch (phi,z) -> (z,phi)
!
! Revision 2.6  2002/06/19 11:00:35  zvi
! Some cosmetic corrections
!
! Revision 2.5  2002/06/07 04:50:47  bill
! fixes and improvements--wgr
!
! Revision 2.4  2002/02/08 00:48:09  zvi
! Restoring the t_deriv_flag code
!
! Revision 2.2  2002/01/30 01:11:21  zvi
! Fix bug in user selectable coeff. code
!
! Revision 2.1  2001/11/20 01:19:30  zvi
! Some clarification of code
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.1.2.8  2001/09/13 01:26:53  zvi
! fixing allocation bug
!
! Revision 1.1.2.7  2001/09/13 00:42:18  livesey
! Fixed memory leak
!
! Revision 1.1.2.6  2001/09/12 22:45:54  livesey
! A version that seems to work
!
! Revision 1.1.2.5  2001/09/12 22:04:07  livesey
! Interim still broken version
!
! Revision 1.1.2.4  2001/09/12 21:47:50  livesey
! More bug fixes
!
! Revision 1.1.2.3  2001/09/12 21:36:51  livesey
! Bug fix.
!
! Revision 1.1.2.2  2001/09/12 21:30:04  livesey
! Updates changes to pointers etc.
!
@


2.32
log
@Correct array bounds problem if no refraction
@
text
@d154 1
a165 2
    real(rp), target :: ETA_P(size(p_grid),size(p_basis))

d321 2
a322 1
        call dump ( (/ req+h_tan /), name='req+h_tan' )
d426 2
a431 1
      call output ( req, before='req \1 ', advance='yes' )
d713 1
a713 1
       "$Id: metrics_m.f90,v 2.31 2006/08/25 19:39:20 vsnyder Exp $"
d722 3
@


2.31
log
@Recomitted to get correct comment into the log:  Substantial revision,
and simplification, works only for one pointing now, repair ACOS bug.
@
text
@d318 1
a318 1
          & phi_sign * Acos((req+h_tan)/h_grid(:n_path))
d376 1
a376 1
        & phi_sign * Acos((req+h_tan)/h_grid(:n_path))
d485 1
a485 1

d712 1
a712 1
       "$Id: metrics_m.f90,v 2.30 2006/08/25 19:37:07 vsnyder Exp $"
d721 4
@


2.30
log
@metrics_m.f90
@
text
@d712 1
a712 1
       "$Id: metrics_m.f90,v 2.29 2006/06/29 19:34:17 vsnyder Exp $"
d721 3
@


2.29
log
@Remove capability to handle more than one tangent -- substantial simplification
@
text
@d31 1
a31 1
          &  dhidzij, beta, refract,                                  &
d36 1
d39 2
a40 1
          &  do_calc_hyd, do_calc_t, eta_zxp, tan_phi_h, tan_phi_t )
d46 1
a46 1
    use Geometry, only: EarthRadA, EarthRadB
d57 2
a58 1
    integer(ip), intent(in) :: tan_ind ! tangent height index
d68 2
a69 1
    real(rp), intent(in) :: beta       ! orbital incline angle (Radians)
d74 1
a81 1
    ! Keywords:
d94 2
d97 2
a98 1
    ! optional outputs
d117 5
a121 7

    ! NOTES
    ! p_basis and p_grid are phi's in offset radians relative to phi_t, that
    ! is the phi_t p_basis or p_grid = 0.0 is phi_t.
    ! The phi basis is wholly independent of phi_t
    ! compute primary hydrostatic grid
    ! tangent phi index
d126 7
a132 4
    integer :: I
    integer :: ITER
    integer :: J
    integer :: N_CVF
d134 4
a137 2
    integer :: N_VERT
    integer :: P_COEFFS
d140 5
a144 3
    real(rp) :: CSQ      ! c^2
    real(rp) :: H_T
    real(rp) :: H_SURF
d146 1
d148 1
a148 5
    integer, dimension(2*(size(z_ref)+1-tan_ind)) :: CVF_INDS
    integer, dimension(size(cvf_inds)) :: VERT_INDS

    logical, dimension(size(cvf_inds)) :: MASK
    logical, dimension(size(cvf_inds),size(p_basis)) :: NOT_ZERO_P
d150 2
a151 2
! TEMPORARY until z_grid becomes an argument
real(rp), dimension(size(h_grid)) :: Z_GRID
d153 11
a163 12
    real(rp), dimension(size(cvf_inds)) :: CVF_ANG_OFFSET
    real(rp), dimension(size(cvf_inds)) :: CVF_H_TAN
    real(rp), dimension(size(cvf_inds)) :: CVF_SIGN
    real(rp), dimension(size(cvf_inds)) :: CVF_Z_GRID
    real(rp), dimension(size(p_basis)) :: ETA_T
    real(rp), dimension(size(cvf_inds)) :: N_GRID   ! index of refraction
    real(rp), dimension(size(cvf_inds)) :: OLD_HTS
    real(rp), dimension(size(cvf_inds)) :: PHI_CORR ! the refractive correction

    real(rp), dimension(size(cvf_inds),size(p_basis)), target :: ETA_P
    real(rp), dimension(:), pointer :: ETA_P_1 ! Target is a section of eta_p
real(rp), dimension(:,:), pointer :: ETA_PI
d165 1
a165 1
    ! For optional calculations
d172 2
d176 3
a182 6
    !{ $c^2 = \frac{a^2 b^2}{a^2 \sin^2 \beta + b^2 \cos^2 \beta}$.
    !  This is Equation (5.3) in the 19 August 2004 ATBD JPL D-18130.

    csq = (earthrada * earthradb)**2 / &
          & ((earthrada**2-earthradb**2)*sin(beta)**2 + earthradb**2)

d184 3
a186 3
    ! For simplicity, we are going to set the
    ! surface reference at the input z_ref(1) and adjust the req and the
    ! h_t relative to this, and adjust h_ref accordingly
d190 1
d192 1
a192 1
    !{ Compute equivalent earth radius (REQ) at phi\_t(1), nearest surface
d196 3
d212 2
a213 5
    ! construct some basic arrays
    cvf_h_tan = h_t

    ! determine condensed vector format so we don't mess with a bunch
    ! of zeros
d216 2
d219 2
a220 1
    n_cvf = size(cvf_inds)
d222 3
a224 5
    ! cvf_inds = 1:n_vert-tan_ind+1 // n_vert+tan_ind:2*n_vert
    cvf_inds = (/ (i, i=1, n_vert-tan_ind+1), (i, i=n_vert+tan_ind, 2*n_vert) /)

    ! sign of phi vector
    cvf_sign = (/ (-1, i=1, n_vert-tan_ind+1), (+1, i=n_vert+tan_ind, 2*n_vert) /)
d226 1
a226 2
    cvf_ang_offset = phi_t
    ! compute phi_s - phi_t
d228 2
a229 2
      cvf_ang_offset(n_vert+1:2*n_vert) = phi_t-2.0_rp*Acos((req+neg_h_tan)/req)
      cvf_h_tan = neg_h_tan
d234 7
a240 9
    h_grid = h_t
 
    !{Estimate the phi's using the tangent heights as a first guess.
    !
    ! $\phi = \phi_t \pm \cos^{-1} \left( \frac{h_t + H^\oplus_t}{h + H^\oplus_t} \right)
    !       = \phi_t \pm \cos^{-1} \left( \frac{h_t + R^\oplus_{\text{eq}}}
    !                                          {h + R^\oplus_{\text{eq}}} \right)$
    !
    ! This is Equation (5.24) in the 19 August 2004 ATBD JPL D-18130.
d242 1
a242 1
    p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))
a243 1
    ! These are the tangent indicies on a cvf array
d245 1
a245 1
      ! some tangents above the earth surface
d247 2
a248 2
      p_grid(n_vert - tan_ind + 1:n_vert - tan_ind + 2) = &
      & cvf_ang_offset(n_vert - tan_ind + 1:n_vert - tan_ind + 2)
d253 1
a253 1
    ! from the tangent but we will ignore this issue for now.
a259 1
nullify ( eta_pi )
d269 1
d271 3
d276 5
a280 5
      old_hts = h_grid
      call get_eta_sparse ( p_basis, p_grid, eta_p )
      do i = 1, n_cvf
        h_grid(i) = max ( cvf_h_tan(i), &
          &               dot_product(h_ref(vert_inds(i),:)-h_surf, eta_p(i,:)) )
d285 5
a290 3
      mask = abs(old_hts-h_grid) > 0.01_rp
      no_of_bad_fits = count(mask)
      if ( no_of_bad_fits == 0 ) exit
d296 2
a297 2
        & cvf_ang_offset(n_vert+1:2*n_vert) = phi_t - &
                  & 2.0_rp*Acos((req+neg_h_tan)/(req+h_grid(j)))
d300 1
a300 1
        call phi_refractive_correction ( n_grid, req+h_grid, phi_corr )
d309 30
a338 4
        p_grid = cvf_ang_offset + cvf_sign * &
          & ( phi_corr + Acos((req+cvf_h_tan)/(req+h_grid)) )
      else ! or not....
        p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))
d341 2
d345 1
a345 3
    eta_p_1 => eta_p(1,:)

    if ( no_of_bad_fits > 0 ) call bad_fits
d350 7
d365 12
a376 4
      p_grid = cvf_ang_offset + cvf_sign * &
        & ( phi_corr + Acos((req+cvf_h_tan)/(req+h_grid)) )
    else ! or not...
      p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))
d379 29
a407 2
      p_grid(n_vert - tan_ind + 1:n_vert - tan_ind + 2) = &
        & cvf_ang_offset(n_vert - tan_ind + 1:n_vert - tan_ind + 2)
d410 2
a411 2
    call get_eta_sparse ( p_basis, p_grid, eta_p, NOT_ZERO = not_zero_p )
    do i = 1, n_cvf
a416 9
    !{ Compute $\zeta$ along the path $= \zeta_m$ ({\tt z\_grid})
    !  $= \frac{\Gamma \zeta_0 - T_0 + \sqrt{T_0^2 + 2 \Gamma Z
    !   (H_m-H_0)}}{\Gamma}$ from the
    !  reference $\zeta = \zeta_l$ ({\tt z\_ref}) using $\phi$ along the
    !  path $= \phi_m$ ({\tt p\_basis}) and $H$ along the path $= H_m =
    !  \frac{H_t}{\cos \phi_m}$, where $\Gamma = \frac{T_1-T_0}{\zeta_m-\zeta_0}$
    !  and $Z = \frac{T_1+T_0)(\zeta_1-\zeta_0)}{2(H_1-H_0)}$ and the 0 and 1
    !  subscripts refer to positions on the $H_l$ grid that bracket $H_m$.

d418 1
a418 7
    if ( present(tan_phi_h) ) then
      if ( present(neg_h_tan) ) then
        tan_phi_h = neg_h_tan - h_surf
      else
        tan_phi_h = h_t
      end if
    end if
d426 4
a429 4
      call dump ( h_grid, name='h_grid', clean=.true. )
      call dump ( p_grid, name='p_grid', clean=.true. )
      call dump ( t_grid, name='t_grid', clean=.true. )
      call dump ( dhitdzi, name='dhitdzi', clean=.true. )
d435 93
d529 1
a529 1
    subroutine Bad_Fits
d531 2
a534 1
      integer :: END_IND1
a536 1
      integer :: Path_Ind
a537 1
      integer :: TAN_PTR
d550 1
a550 2
      ! Find ranges of contiguous indicies
      junk = PACK((/(i,i=1,n_cvf)/),mask)
a551 1
      path_ind = cvf_inds(junk(st_ind))
d553 1
d559 2
a560 3
          call output ( path_ind, places=7 )
          call output ( ', ' )
          call output ( old_hts(junk(st_ind))-h_grid(junk(st_ind)), advance='yes' )
d563 1
a563 19
        ! find which side of the tangent we are on
        if ( path_ind < n_vert + 1 ) then ! near observer side
          low_pt = junk(end_ind) + 1
          hi_pt  = MAX(junk(st_ind) - 1,1)
        else                              ! far observer side
          low_pt = junk(st_ind) - 1
          hi_pt  = MIN(junk(end_ind) + 1,n_cvf)
        end if
        tan_ptr = 2 * n_vert
        if ( cvf_inds(junk(st_ind)) ==  1 ) then
          call mlsMessage(mlsmsg_warning,moduleName,'resorting to 1d option in metrics')
          status = 2
          ! resort to 1 d equvalent
          call get_eta_sparse ( p_basis, phi_t, eta_p_1 )
          do i = st_ind, end_ind
            h_grid(junk(i)) = dot_product(h_ref(n_vert-cvf_inds(junk(i))-1,:),eta_p_1) - h_surf
          end do
        else if ( cvf_inds(junk(end_ind)) > tan_ptr - 1 ) then
          ! calculate the path ending index.
a565 1
          end_ind1 = st_ind + tan_ptr - cvf_inds(junk(st_ind))
d568 3
a570 2
          do i = st_ind, end_ind1
            h_grid(junk(i)) = dot_product(h_ref(cvf_inds(junk(i))-n_vert,:),eta_p_1) - h_surf
d573 9
a581 2

          ! Correct
d588 1
a588 2
        if ( st_ind < no_of_bad_fits ) &
          & path_ind = cvf_inds(junk(st_ind))
d591 3
d596 57
d656 4
a659 4
      real(rp), dimension(n_cvf,size(z_basis)) :: ETA_T2
      logical, dimension(n_cvf,size(z_basis)) :: NOT_ZERO_T
      integer :: SV_P, SV_T, SV_Z ! Loop inductors and subscripts
      integer :: Z_COEFFS         ! size(z_basis)
d664 1
a664 2
        dhidtlm(1:n_vert,i,1:p_coeffs) = dhidtlm(1:n_vert,i,1:p_coeffs) - &
          & dot_product(dhidtlm(1,i,:), eta_t)
d685 1
a685 1
              eta_zxp(:,sv_t) = eta_t2(:,sv_z) * eta_p(:,sv_p)
d689 2
a690 1
            do_calc_hyd(:,sv_t) = not_zero_p(:,sv_p) .and. dhidtlm(vert_inds(:),sv_z,sv_p) > 0.0_rp
d692 1
a692 1
              dhitdtlm(:,sv_t) = dhidtlm(vert_inds(:),sv_z,sv_p) * eta_p(:,sv_p)
d712 1
a712 1
       "$Id: metrics_m.f90,v 2.28 2006/03/06 20:44:48 vsnyder Exp $"
d721 3
@


2.28
log
@Cannonball polishing
@
text
@a23 2
  integer, save :: CalledTimes = 0

d30 2
a31 2
          &  phi_t, tan_inds, p_basis, z_grid, n_ref, h_ref, t_ref,   &
          &  dhidzij, beta, t_deriv_flag, refract,                    &
d34 5
a38 4
          ! Optional:
          &  dhidtlm, ddhidhidtl0, dhitdtlm, eta_zxp, tan_phi_h_grid, &
          &  tan_phi_t_grid, dhtdzt, dhtdtl0, ddhtdhtdtl0, neg_h_tan, &
          &  z_basis, do_calc_t, do_calc_hyd )
d43 1
a43 7
    ! Although this program was originally designed to work with Compressed
    ! Vector Format (CVF), which concatenates several paths of different
    ! lengths, the Phi refractive correction does not work in that case.
    ! There is a chance that other evolutionary modifications also do not
    ! work in that case.

    use Allocate_deallocate, only: Allocate_test, Deallocate_test
d50 1
a50 1
    use Toggles, only: Emit, Toggle
d54 3
a56 3
    real(rp), intent(in) :: phi_t(:)   !orbit projected tangent geodetic angles
    integer(ip), intent(in) :: tan_inds(:)!tangent height indicies
    real(rp), intent(in) :: p_basis(:) !horizontal temperature representation
d58 3
a60 2
    real(rp), intent(in) :: z_grid(:)  !-log pressures (zetas) for which
    !                                     heights/temps are needed
d65 1
a65 2
    real(rp), intent(in) :: beta       !orbital incline angle (Radians)
    logical,  intent(in) :: t_deriv_flag(:)  ! User's deriv. flags for Temp.
d68 6
a73 6
    real(rp), intent(out) :: h_grid(:) !computed heights
    real(rp), intent(out) :: p_grid(:) !computed phi's
    real(rp), intent(out) :: t_grid(:) !computed temperatures
    real(rp), intent(out) :: dhitdzi(:)!derivative of height wrt zeta
    !                                   --may be useful in future computations
    real(rp), intent(out) :: req       !equivalent elliptical earth radius
d79 3
a81 1
    real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
d85 6
a90 3
    real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:)! second order reference
    !   temperature derivatives. This is (height, phi_basis, zeta_basis)
    real(rp), optional, intent(in) :: neg_h_tan(:)  !sub earth tangent heights
d92 3
a94 11
    real(rp), optional, intent(out) :: tan_phi_h_grid(:)!heights along the
    !                                                      tangent
    real(rp), optional, intent(out) :: tan_phi_t_grid(:)!temperature along the
    !                                                      tangent
    real(rp), optional, intent(out) :: dhtdzt(:)   ! height derivative wrt
    !                                                pressure along the tangent
    real(rp), optional, intent(out) :: dhtdtl0(:,:) ! First order derivative at
    !                                                the tangent
    real(rp), optional, intent(out) :: ddhtdhtdtl0(:,:) ! Second order 
    !          derivative at the tangent only---used for antenna affects
    !
d97 13
a109 7
    !                             statevector (z_basisXphi_basis)
    real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature.

    logical, optional, intent(out) :: do_calc_t(:,:) ! non zero locater for
    !                                       temperature bases computations.
    logical, optional, intent(out) :: do_calc_hyd(:,:) !non zero locator for
    !                                       hydrostatic calculations.
d112 1
a112 1
    ! p_basis and p_grid are phi's in offset degrees relative to phi_t, that
a117 2
    ! ===>> EVERYTHING comes out in cvf format <<===!

d119 2
a120 3
    integer :: END_IND
    integer :: END_IND1
    integer :: HI_PT
a123 1
    integer :: LOW_PT
a125 1
    integer :: N_TAN
a127 8
    integer :: Path_Ind
    integer :: SS_HTAN
    integer :: ST_IND
    integer :: SV_P
    integer :: SV_T
    integer :: SV_Z
    integer :: Z_COEFFS
    integer :: TAN_PTR
d129 3
a131 2
    real(rp) :: CP2
    real(rp) :: CSQ
d133 23
a155 1
    real(rp) :: SP2
d157 1
a157 31
    logical, dimension(:), pointer :: MASK
    logical, dimension(:,:), pointer :: MASK2
    logical, dimension(:,:), pointer :: NOT_ZERO_P
    logical, dimension(:,:), pointer :: NOT_ZERO_T

    integer, dimension(:), pointer :: CVF_INDS
    integer, dimension(:), pointer :: FORCE_ZERO
    integer, dimension(:), pointer :: INDS
    integer, dimension(:), pointer :: JUNK, JUN ! JUN => some_of_JUNK
    integer, dimension(:), pointer :: NEAR_INDS
    integer, dimension(:), pointer :: PATH_INDS
    integer, dimension(:), pointer :: VERT_INDS

    real(rp), dimension(:), pointer :: CVF_ANG_OFFSET
    real(rp), dimension(:), pointer :: CVF_H_TAN
    real(rp), dimension(:), pointer :: CVF_SIGN
    real(rp), dimension(:), pointer :: CVF_Z_GRID
    real(rp), dimension(:), pointer :: DHTDTL
    real(rp), dimension(:), pointer :: ETA_P_1
    real(rp), dimension(size(tan_inds)) :: H_GRID_T
    real(rp), dimension(:), pointer :: H_GRID_TT
    real(rp), dimension(:), pointer :: N_GRID
    real(rp), dimension(:), pointer :: OLD_HTS
    real(rp), dimension(:), pointer :: PHI_CORR ! Refractive correction

    real(rp), dimension(:,:), pointer :: ETA_P
    real(rp), dimension(:,:), pointer :: ETA_T
    real(rp), dimension(2*size(z_grid),size(tan_inds)) :: H_TANS
    real(rp), dimension(:,:), pointer :: H_ZF
    real(rp), dimension(2*size(z_grid),size(tan_inds)) :: M_Z_GRID
    real(rp), dimension(2*size(z_grid),size(tan_inds)) :: PHI_TANS
d161 5
a166 1
    calledTimes = calledTimes + 1
d168 4
a171 2
    n_vert = size(z_grid)
    n_tan = size(tan_inds)
d176 7
a182 2
    nullify ( eta_t )
    call allocate_test ( eta_t, n_tan, p_coeffs, 'eta_t', moduleName )
d184 10
a193 9
    ! compute the tangent height vertical
    ! for simplicity, we are going to set the
    ! surface reference at the input z_grid(1) and adjust the req and the
    ! h_grid_t relative to this, and adjust h_ref accordingly
    call get_eta_sparse ( p_basis, phi_t, eta_t )
    h_surf = dot_product(h_ref(1,:),eta_t(1,:))
    do i = 1, n_tan
      h_grid_t(i) = dot_product(h_ref(tan_inds(i),:),eta_t(i,:)) - h_surf
    end do
d195 1
a195 2
    ! compute equivalent earth radius at phi_t(1), nearest surface
    cp2 = cos(phi_t(1))**2
d198 2
a199 1
                      & (earthrada**2*cp2 + csq*sp2))
d201 2
a202 2
    ! now for the path quantities.  adjust req to the input z_grid(1)
    req = req + h_surf
d204 2
a205 11
    if ( present(tan_phi_h_grid) ) tan_phi_h_grid = h_grid_t
    if ( present(tan_phi_t_grid) ) then
      do i = 1, n_tan
        tan_phi_t_grid(i) = dot_product(t_ref(tan_inds(i),:),eta_t(i,:))
      end do
    end if
    if ( present(dhtdzt) ) then
      do i = 1, n_tan
        dhtdzt(i) = dot_product(dhidzij(tan_inds(i),:),eta_t(i,:))
      end do
    end if
d207 1
a207 10
    ! compute tangent temperature derivative
    if ( present(dhidtlm) ) then
      z_coeffs = size(z_basis)
      nullify ( dhtdtl )
      call allocate_test ( dhtdtl, z_coeffs, 'dhtdtl', moduleName )
!     dhtdtl = sum(RESHAPE(dhidtlm(1,:,:),(/z_coeffs,p_coeffs/)) &
!       * SPREAD(RESHAPE(eta_t(1,:),(/p_coeffs/)),1,z_coeffs),dim=2)
      do i = 1, z_coeffs
        dhtdtl(i) = dot_product(dhidtlm(1,i,:), eta_t(1,:))
      end do
d209 1
a209 3
      ! adjust the 2d hydrostatic relative to the surface
      dhidtlm = dhidtlm - SPREAD(SPREAD(dhtdtl,1,n_vert),3,p_coeffs)
!     dhidtlm = dhidtlm - SPREAD(SPREAD(dhtdtl,1,n_vert),2,p_coeffs)
d211 2
a212 3
      j = z_coeffs * p_coeffs
      dhtdtl0 = RESHAPE(dhidtlm(tan_inds,:,:) * SPREAD(eta_t,2,z_coeffs),&
                     & (/n_tan, j/))
d214 2
a215 3
      ddhtdhtdtl0 = RESHAPE( &
                   ddhidhidtl0(tan_inds,:,:) * SPREAD(eta_t,2,z_coeffs), &
                     & (/n_tan, j/))
d217 2
a218 5
      call deallocate_test ( dhtdtl, 'dhtdtl', moduleName )

    end if

    ss_htan = 0
d220 2
a221 2
      ss_htan = size(neg_h_tan)
      if ( present(tan_phi_h_grid) ) tan_phi_h_grid(1:ss_htan)=neg_h_tan-h_surf
d224 1
a224 12
    ! construct some basic matrices
    h_tans = SPREAD(h_grid_t,1,2*n_vert)
    phi_tans = SPREAD(phi_t,1,2*n_vert)

    nullify ( h_grid_tt )
    call allocate_test ( h_grid_tt, n_vert, 'h_grid_tt', moduleName )

    call allocate_test ( eta_t, n_vert, max (1,n_tan-ss_htan), 'n_vert', moduleName )
    call get_eta_sparse ( z_grid(tan_inds(min(n_tan,ss_htan+1):n_tan)), z_grid, &
                        & eta_t )
    h_grid_tt = matmul(eta_t,h_grid_t(min(n_tan,ss_htan+1):n_tan))
    call deallocate_test ( eta_t, 'eta_t', moduleName )
d226 9
a234 2
    ! basic pressure grid
    m_z_grid = SPREAD((/z_grid(n_vert:1:-1),z_grid(1:n_vert)/),2,n_tan)
d236 1
a236 54
    ! determine condensed vector format so we don't mess with a bunch
    ! of zeros

    n_cvf = 2*sum(n_vert + 1 - tan_inds)

    nullify ( old_hts, cvf_h_tan, n_grid, cvf_z_grid )
    nullify ( cvf_ang_offset, cvf_sign, h_zf, cvf_inds )

    call allocate_test ( old_hts, n_cvf, 'old_hts', moduleName )
    call allocate_test ( cvf_h_tan, n_cvf, 'cvf_h_tan', moduleName )
    call allocate_test ( n_grid, n_cvf, 'n_grid', moduleName )
    call allocate_test ( cvf_z_grid, n_cvf, 'cvf_z_grid', moduleName )
    call allocate_test ( cvf_ang_offset, n_cvf, 'cvf_ang_offset', moduleName )
    call allocate_test ( cvf_sign, n_cvf, 'cvf_sign', moduleName )
    call allocate_test ( h_zf, n_cvf, p_coeffs, 'h_zf', moduleName )
    call allocate_test ( cvf_inds, n_cvf, 'cvf_inds', moduleName )

    cvf_inds = PACK((/(i,i=1,2*n_vert*n_tan)/),                     &
    & RESHAPE(SPREAD((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/),2,n_tan), &
    &             (/2*n_vert*n_tan/)) -                             &
    & RESHAPE(SPREAD(tan_inds,1,2*n_vert),(/2*n_vert*n_tan/)) >= 0)

    ! sign of phi matrix
    cvf_sign = (-1.0_rp)**((modulo(cvf_inds-1,2*n_vert)/n_vert)+1)

    ! Apparently you can't sequentially access elements of a multirank array
    ! in f90 like you can in idl, which is a major but necessary inconvenience
    ! (because array elements taken in array element order aren't necessarily
    ! in consecutive memory locations, and it would be a slow process to compute
    ! where they really are)
    nullify ( mask2 )
    call allocate_test ( mask2, 2*n_vert, n_tan, 'mask2', moduleName )
    mask2 = .false.
    ! mask2(cvf_inds) = .true.
    do i = 1, size(cvf_inds)
      mask2(mod(cvf_inds(i)-1,2*n_vert)+1, (cvf_inds(i)-1)/(2*n_vert) + 1) &
        & = .true.
    end do
    cvf_ang_offset = PACK(phi_tans,mask2)
    h_grid = PACK(SPREAD(h_grid_tt((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)), &
                      &  2,n_tan),mask2)
    call deallocate_test ( h_grid_tt, 'h_grid_tt', moduleName )

    ! compute phi_s - phi_t
    j = n_vert
    do i = 1 , ss_htan ! Subsurface stuff; ss_htan == 0 if neg_h_tan not present
      cvf_ang_offset(j+1:j+n_vert)=phi_t(i)-2.0_rp*Acos((req+neg_h_tan(i))/req)
      h_tans(:,i) = neg_h_tan(i)
      j = j + n_vert + n_vert
    end do
    cvf_h_tan = PACK(h_tans,mask2)
    cvf_z_grid = PACK(m_z_grid,mask2)

    call deallocate_test ( mask2, 'mask2', moduleName )
d239 1
a239 1
    if ( n_tan > ss_htan ) then
d241 3
a243 11
      nullify ( force_zero )
      call allocate_test ( force_zero, 2*(n_tan-ss_htan), 'force_zero', moduleName )
      force_zero(1) = n_vert*(2*ss_htan + 1) - tan_inds(1+ss_htan) + 1
      force_zero(2) = force_zero(1) + 1
      j = 3
      do i = 2, n_tan - ss_htan
        force_zero(j) = force_zero(j-2)+2*n_vert - &
                      & tan_inds(ss_htan+i-1)-tan_inds(ss_htan+i)+2
        force_zero(j+1) = force_zero(j)+1
        j = j + 2
      end do
d246 1
a246 7
    ! estimate the phi's using the tangent heights as a first guess
    p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))

    ! force the del phi at the tangent to be zero
    if ( n_tan > ss_htan ) p_grid(force_zero) = cvf_ang_offset(force_zero)

    ! estimate some new heights
d249 3
a251 20
    ! the following lines replace an extremely sparse matrix
    ! multiplication with a less memory intensive alternative
    ! and probably faster alternative
    ! convert the cvf indicies into path indicies

    nullify ( path_inds, vert_inds, near_inds )
    call allocate_test ( vert_inds, n_cvf, 'vert_inds', moduleName )
    call allocate_test ( path_inds, n_cvf, 'path_inds', moduleName )
    call allocate_test ( near_inds, n_cvf/2, 'near_inds', moduleName )

    path_inds = modulo((cvf_inds - 1),2*n_vert) + 1
    vert_inds = path_inds - n_vert
    near_inds = PACK((/(i,i=1,n_cvf)/),path_inds <= n_vert)
    vert_inds(near_inds) = n_vert - path_inds(near_inds) + 1

    call deallocate_test ( near_inds, 'near_inds', moduleName )
    call deallocate_test ( path_inds, 'path_inds', moduleName )

    ! h_ref with surface adjustment
    h_zf = h_ref(vert_inds,:) - h_surf
d255 1
a255 6
    nullify ( mask, phi_corr, eta_p )
    call allocate_test ( mask, n_cvf, 'mask', moduleName )
    if ( refract ) &
      & call allocate_test ( phi_corr, n_cvf, 'phi_corr', moduleName )
    call allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', moduleName )
    eta_p_1 => eta_p(1,:)
d257 7
a263 5
    !{ Compute $\phi = \phi_t + \cos^{-1}
    !   \left( \frac{h_t + H_t^\oplus}{h+H_t^\oplus} \right)$.  This is
    !  Equation (5.24) in the 19 August 2004 ATBD JPL D-18130.  We have to
    !  iterate because the $h$ that's used is interpolated onto the $\phi$
    !  grid, so it changes when the $\phi$ changes.
d271 2
a272 1
        h_grid(i) = max ( cvf_h_tan(i), dot_product(h_zf(i,:), eta_p(i,:)) )
d283 5
a287 7
      ! recompute phi_s - phi_t because we have to iterate on phi_s - phi_t
      j = n_vert
      do i = 1 , ss_htan ! Subsurface stuff; ss_htan == 0 if neg_h_tan not present
        cvf_ang_offset(j+1:j+n_vert) = phi_t(i) - &
                  & 2.0_rp*Acos((req+neg_h_tan(i))/(req+h_grid(j)))
        j = j + n_vert + n_vert
      end do
a289 1
        !!!! This only works for one path, not for a CVF !!!!
d292 7
d301 1
a301 1
      else
d307 76
a382 1
    if ( no_of_bad_fits > 0 ) then
d391 1
a391 1
      ! we are going to assume that the tangent value is good
d395 2
a396 5
      ! find ranges of contigous indicies
      nullify ( junk )
      call allocate_test ( junk, n_cvf, 'junk', moduleName )
      jun => junk(:no_of_bad_fits)
      jun = PACK((/(i,i=1,n_cvf)/),mask)
d398 1
a398 1
      path_ind = modulo(cvf_inds(jun(st_ind))-1,2*n_vert) + 1
d401 1
a401 1
          if ( jun(end_ind+1) - jun(end_ind) < 2 ) cycle
d407 1
a407 1
          call output ( old_hts(jun(st_ind))-h_grid(jun(st_ind)), advance='yes' )
d412 2
a413 2
          low_pt = jun(end_ind) + 1
          hi_pt  = MAX(jun(st_ind) - 1,1)
d415 2
a416 2
          low_pt = jun(st_ind) - 1
          hi_pt  = MIN(jun(end_ind) + 1,n_cvf)
d418 2
a419 2
        tan_ptr = 2 * n_vert * ((cvf_inds(low_pt)-1) / (2*n_vert) + 1)
        if ( cvf_inds(jun(st_ind)) == tan_ptr - 2*n_vert + 1 ) then
d422 2
a423 3
! resort to 1 d equvalent
          call get_eta_sparse ( p_basis, phi_t((cvf_inds(low_pt)-1) &
               & / (2*n_vert) + 1), eta_p_1 )
d425 1
a425 2
            h_grid(jun(i)) = dot_product(h_ref(n_vert - MODULO(cvf_inds(jun(i))-1, &
            & 2*n_vert),:),eta_p_1) - h_surf
d427 2
a428 2
        else if ( cvf_inds(jun(end_ind)) > tan_ptr - 1 ) then
! calculate the path ending index.
d431 3
a433 4
          end_ind1 = st_ind + tan_ptr - cvf_inds(jun(st_ind))
! resort to 1 d equvalent
          call get_eta_sparse ( p_basis, phi_t((cvf_inds(low_pt) - 1) &
          & / (2*n_vert) + 1), eta_p_1 )
d435 1
a435 2
            h_grid(jun(i)) = dot_product(h_ref(MODULO(cvf_inds(jun(i))-1,2*n_vert) &
                          & + 1 - n_vert,:),eta_p_1) - h_surf
a436 10
! This is in case the anomaly wraps to the next higher tangent level.
          if ( end_ind1 < end_ind ) then
! resort to 1 d equivalent
            call get_eta_sparse ( p_basis,phi_t((cvf_inds(low_pt)-1) &
                 & / (2*n_vert) + 2), eta_p_1 )
            do i = end_ind1+1, end_ind
              h_grid(jun(i)) = dot_product(h_ref(n_vert - MODULO(cvf_inds(jun(i))-1, &
              & 2*n_vert),:),eta_p_1) - h_surf
            end do
          end if
d440 1
a440 1
          h_grid(jun(st_ind):jun(end_ind)) = h_grid(low_pt) + &
d442 1
a442 1
             & (cvf_z_grid(jun(st_ind):jun(end_ind))-cvf_z_grid(low_pt)) / &
d447 1
a447 1
          & path_ind = modulo(cvf_inds(jun(st_ind))-1,2*n_vert) + 1
d450 1
a450 1
      call deallocate_test ( junk, 'junk', moduleName )
d452 2
a453 1
    end if
d455 4
a458 1
    call deallocate_test ( mask, 'mask', moduleName )
d460 6
a465 3
    ! deallocate the loop iteration stuff
    call deallocate_test ( h_zf, 'h_zf', moduleName )
    call deallocate_test ( old_hts, 'old_hts', moduleName )
d467 3
a469 2
    nullify ( not_zero_p )
    call allocate_test ( not_zero_p, n_cvf, p_coeffs, 'not_zero_p', moduleName )
d471 3
a473 13
    ! compute final set of angles
    if ( refract ) then
      p_grid = cvf_ang_offset + cvf_sign * &
        & ( phi_corr + Acos((req+cvf_h_tan)/(req+h_grid)) )
    else
      p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))
    end if
    if ( n_tan > ss_htan ) then
      p_grid(force_zero) = cvf_ang_offset(force_zero)
      call deallocate_test ( force_zero, 'force_zero', moduleName )
    end if
    if ( refract ) &
      & call deallocate_test ( phi_corr, 'phi_corr', moduleName )
a474 20
    call get_eta_sparse ( p_basis, p_grid, eta_p, NOT_ZERO = not_zero_p )
    do i = 1, n_cvf
      t_grid(i) = dot_product(t_ref(vert_inds(i),:), eta_p(i,:))
      ! compute the vertical derivative grid
      dhitdzi(i) = dot_product(dhidzij(vert_inds(i),:), eta_p(i,:))
    end do

    ! compute the temperature derivative grid

    if ( present(dhitdtlm) ) then

      nullify ( inds, not_zero_t )
      call allocate_test ( inds, n_cvf, 'inds', moduleName )
      call allocate_test ( eta_t, n_cvf, z_coeffs, 'eta_t', moduleName )
      call allocate_test ( not_zero_t, n_cvf, z_coeffs, 'not_zero_t', moduleName )

      ! desparate attempt to try something different
      inds = modulo(cvf_inds-1,2*n_vert) - n_vert
      where ( inds >= 0 ) inds = inds + 1
      inds = abs(inds)
d476 1
a476 1
      call get_eta_sparse ( z_basis, cvf_z_grid, eta_t, NOT_ZERO = not_zero_t )
d485 1
a485 1
              eta_zxp(:,sv_t) = eta_t(:,sv_z) * eta_p(:,sv_p)
d489 1
a489 1
            do_calc_hyd(:,sv_t) = not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_z,sv_p) > 0.0_rp
d491 1
a491 1
              dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_z,sv_p) * eta_p(:,sv_p)
d504 1
a504 15
      call deallocate_test ( not_zero_t, 'not_zero_t', moduleName )
      call deallocate_test ( eta_t, 'eta_t', moduleName )
      call deallocate_test ( inds, 'inds', moduleName )

    end if

    call deallocate_test ( eta_p, 'eta_p', moduleName )
    call deallocate_test ( cvf_ang_offset, 'cvf_ang_offset', moduleName )
    call deallocate_test ( n_grid, 'n_grid', moduleName )
    call deallocate_test ( cvf_z_grid, 'cvf_z_grid', moduleName )
    call deallocate_test ( cvf_sign, 'cvf_sign', moduleName )
    call deallocate_test ( cvf_h_tan, 'cvf_h_tan', moduleName )
    call deallocate_test ( cvf_inds, 'cvf_inds', moduleName )
    call deallocate_test ( vert_inds, 'vert_inds', moduleName )
    call deallocate_test ( not_zero_p, 'not_zero_p', moduleName )
d511 1
a511 1
       "$Id: metrics_m.f90,v 2.27 2006/01/26 03:06:17 vsnyder Exp $"
d520 3
@


2.27
log
@Don't deallocate 'mask' until after it's no longer needed!
@
text
@d53 1
a53 1
    use MLSCommon, only: RP, IP
d322 1
a322 1
    do i = 1 , ss_htan ! Subsurface stuff
d412 1
a412 1
      do i = 1 , ss_htan ! Subsurface stuff
d494 1
a494 1
! resort to 1 d equvalent
d612 1
a612 1
       "$Id: metrics_m.f90,v 2.26 2006/01/05 00:03:52 vsnyder Exp $"
d621 3
@


2.26
log
@Implement refractive correction for Phi
@
text
@a429 2
    call deallocate_test ( mask, 'mask', moduleName )

d519 2
d612 1
a612 1
       "$Id: metrics_m.f90,v 2.25 2005/12/10 03:31:09 vsnyder Exp $"
d621 3
@


2.25
log
@Replace SUM(A*B) with Dot_Product(A,B) to avoid array temps
@
text
@d30 6
a35 2
  subroutine Metrics ( phi_t, tan_inds, p_basis, z_grid, h_ref, t_ref, dhidzij,&
          &  beta, t_deriv_flag, h_grid, p_grid, t_grid, dhitdzi, req, status, &
d37 3
a39 3
          &  dhidtlm, ddhidhidtl0, dhitdtlm, eta_zxp, tan_phi_h_grid,          &
          &  tan_phi_t_grid, dhtdzt, dhtdtl0, ddhtdhtdtl0, neg_h_tan, z_basis, &
          &  do_calc_t, do_calc_hyd )
d42 1
a42 1
    ! and t_grids which define 2 d integration paths
d44 5
a48 2
    ! The main change in this routine is to interchange the z_coeffs and
    ! p_coeffs so as to make it consistent with the radiative transfer program.
d56 1
d65 3
a67 2
    real(rp), intent(in) :: z_grid(:)  !pressures for which heights/temps are
    !                                     needed
d73 1
d172 1
d174 1
d176 1
a176 1
    real(rp), dimension(:,:), pointer :: ETA_P, ET_P ! ET_P => some_of_ETA_P
d192 1
a192 1
          &  ((earthrada**2-earthradb**2)*sin(beta)**2 + earthradb**2)
d195 1
a195 1
    call allocate_test ( eta_t, n_tan, p_coeffs, 'eta_t', ModuleName )
d232 1
a232 1
      call allocate_test ( dhtdtl, z_coeffs, 'dhtdtl', ModuleName )
d251 1
a251 1
      call deallocate_test ( dhtdtl, 'dhtdtl', ModuleName )
a254 2
    call deallocate_test ( eta_t, 'eta_t', ModuleName )

d265 2
a266 2
    nullify ( eta_t, h_grid_tt )
    call allocate_test ( h_grid_tt, n_vert, 'h_grid_tt', ModuleName )
d268 1
a268 1
    call allocate_test ( eta_t, n_vert, max (1,n_tan-ss_htan), 'n_vert', ModuleName )
d272 1
a272 1
    call deallocate_test ( eta_t, 'eta_t', ModuleName )
d275 1
a275 1
    m_z_grid = SPREAD(z_grid((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)),2,n_tan)
d282 2
a283 2
    nullify ( old_hts, cvf_h_tan, cvf_z_grid, cvf_ang_offset, cvf_sign )
    nullify ( h_zf, cvf_inds )
d285 8
a292 7
    call allocate_test ( old_hts, n_cvf, 'old_hts', ModuleName )
    call allocate_test ( cvf_h_tan, n_cvf, 'cvf_h_tan', ModuleName )
    call allocate_test ( cvf_z_grid, n_cvf, 'cvf_z_grid', ModuleName )
    call allocate_test ( cvf_ang_offset, n_cvf, 'cvf_ang_offset', ModuleName )
    call allocate_test ( cvf_sign, n_cvf, 'cvf_sign', ModuleName )
    call allocate_test ( h_zf, n_cvf, p_coeffs, 'h_zf', ModuleName )
    call allocate_test ( cvf_inds, n_cvf, 'cvf_inds', ModuleName )
d308 1
a308 1
    call allocate_test ( mask2, 2*n_vert, n_tan, 'mask2', ModuleName )
d318 1
a318 1
    call deallocate_test ( h_grid_tt, 'h_grid_tt', ModuleName )
d322 1
a322 1
    do i = 1 , ss_htan
d330 1
a330 1
    call deallocate_test ( mask2, 'mask2', ModuleName )
d336 1
a336 1
      call allocate_test ( force_zero, 2*(n_tan-ss_htan), 'force_zero', ModuleName )
d349 1
a349 2
    old_hts = h_grid
    p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+old_hts))
d363 3
a365 3
    call allocate_test ( vert_inds, n_cvf, 'vert_inds', ModuleName )
    call allocate_test ( path_inds, n_cvf, 'path_inds', ModuleName )
    call allocate_test ( near_inds, n_cvf/2, 'near_inds', ModuleName )
d372 2
a373 2
    call deallocate_test ( near_inds, 'near_inds', ModuleName )
    call deallocate_test ( path_inds, 'path_inds', ModuleName )
d380 5
a384 4
    nullify ( mask, eta_p, junk )
    call allocate_test ( junk, n_cvf, 'junk', moduleName )
    call allocate_test ( mask, n_cvf, 'mask', ModuleName )
    call allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )
d387 5
a391 7
    call get_eta_sparse ( p_basis, p_grid, eta_p )
    do i = 1, n_cvf
      h_grid(i) = max( cvf_h_tan(i), dot_product(h_zf(i,:), eta_p(i,:)) )
    end do

    ! this construct is considered more desireable than a do while
    ! according to the Fortran explained book
d396 8
a407 2
      jun => junk(:no_of_bad_fits)
      jun = PACK((/(i,i=1,n_cvf)/),mask)
a409 3
      old_hts = h_grid
      et_p => eta_p(:no_of_bad_fits,:)

d412 1
a412 1
      do i = 1 , ss_htan
d418 9
a426 6
      call get_eta_sparse ( p_basis, cvf_ang_offset(jun) + cvf_sign(jun) &
        & * Acos((req + cvf_h_tan(jun))/(req + old_hts(jun))), et_p )
      do i = 1, no_of_bad_fits
        h_grid(jun(i)) = max ( cvf_h_tan(jun(i)), &
          & dot_product(h_zf(jun(i),:), et_p(i,:)) )
      end do
d430 1
a430 1
    call deallocate_test ( mask, 'mask', ModuleName )
d435 1
a435 1
        call MLSMessage ( MLSMSG_Warning, ModuleName, &
d442 1
a442 1
      ! The following is an F90 specific design which is quite different
d446 4
d517 2
d522 2
a523 3
    call deallocate_test ( junk, 'junk', ModuleName )
    call deallocate_test ( old_hts, 'old_hts', ModuleName )
    call deallocate_test ( h_zf, 'h_zf', ModuleName )
d526 1
a526 1
    call allocate_test ( not_zero_p, n_cvf, p_coeffs, 'not_zero_p', ModuleName )
d529 6
a534 1
    p_grid = cvf_ang_offset + cvf_sign * Acos((req+cvf_h_tan)/(req+h_grid))
d537 1
a537 1
      call deallocate_test ( force_zero, 'force_zero', ModuleName )
d539 2
a548 1

d553 4
a556 4
      nullify ( inds, eta_t, not_zero_t )
      call allocate_test ( inds, n_cvf, 'inds', ModuleName )
      call allocate_test ( eta_t, n_cvf, z_coeffs, 'eta_t', ModuleName )
      call allocate_test ( not_zero_t, n_cvf, z_coeffs, 'not_zero_t', ModuleName )
d591 3
a593 3
      call deallocate_test ( not_zero_t, 'not_zero_t', ModuleName )
      call deallocate_test ( eta_t, 'eta_t', ModuleName )
      call deallocate_test ( inds, 'inds', ModuleName )
d597 9
a605 8
    call deallocate_test ( eta_p, 'eta_p', ModuleName )
    call deallocate_test ( cvf_ang_offset, 'cvf_ang_offset', ModuleName )
    call deallocate_test ( cvf_z_grid, 'cvf_z_grid', ModuleName )
    call deallocate_test ( cvf_sign, 'cvf_sign', ModuleName )
    call deallocate_test ( cvf_h_tan, 'cvf_h_tan', ModuleName )
    call deallocate_test ( cvf_inds, 'cvf_inds', ModuleName )
    call deallocate_test ( vert_inds, 'vert_inds', ModuleName )
    call deallocate_test ( not_zero_p, 'not_zero_p', ModuleName )
d612 1
a612 1
       "$Id: metrics_m.f90,v 2.24 2005/12/10 01:53:23 vsnyder Exp $"
d621 3
@


2.24
log
@Use get_eta_sparse_1d
@
text
@d186 3
d190 4
a193 2
    h_grid_t = sum(h_ref(tan_inds,:)*eta_t,dim=2)
    h_surf = sum(h_ref(1,:)*eta_t(1,:))
d201 1
a201 3
    ! now for the path quantities. for simplicity, we are going to set the
    ! surface reference at the input z_grid(1) and adjust the req and the
    ! h_grid_t relative to this
a203 2
    ! adjust h_ref accordingly
    h_grid_t = h_grid_t - h_surf
d205 10
a214 3
    if ( present(tan_phi_t_grid) ) &
      tan_phi_t_grid = sum(t_ref(tan_inds,:)*eta_t,dim=2)
    if ( present(dhtdzt) ) dhtdzt = sum(dhidzij(tan_inds,:)*eta_t,dim=2)
d223 3
a225 1
      dhtdtl = sum(dhidtlm(1,:,:) * SPREAD(eta_t(1,:),1,z_coeffs),dim=2)
d292 4
a295 1
    ! in f90 like you can in idl, which is a major inconvenience
d319 1
a319 1
    call deallocate_test ( mask2, 'mask', ModuleName )
d377 3
a379 1
    h_grid = max(cvf_h_tan, sum(h_zf * eta_p,dim=2))
d408 4
a411 1
      h_grid(jun) = max ( cvf_h_tan(jun), sum(h_zf(jun,:) * et_p, dim=2) )
d460 2
a461 2
            h_grid(jun(i)) = SUM(h_ref(n_vert - MODULO(cvf_inds(jun(i))-1, &
            & 2*n_vert),:)*eta_p_1) - h_surf
d465 1
a465 1
          call mlsMessage(mlsmsg_warning,moduleName,'resorting to 1d option in metrics')
d472 2
a473 2
            h_grid(jun(i)) = SUM(h_ref(MODULO(cvf_inds(jun(i))-1,2*n_vert) &
                          & + 1 - n_vert,:)*eta_p_1) - h_surf
d481 2
a482 2
              h_grid(jun(i)) = SUM(h_ref(n_vert - MODULO(cvf_inds(jun(i))-1, &
              & 2*n_vert),:)*eta_p_1) - h_surf
d516 5
a520 1
    t_grid = sum(t_ref(vert_inds,:) * eta_p,dim=2)
a521 2
    ! compute the vertical derivative grid
    dhitdzi = sum(dhidzij(vert_inds,:) * eta_p,dim=2)
d585 1
a585 1
       "$Id: metrics_m.f90,v 2.23 2005/06/22 18:08:19 pwagner Exp $"
d594 3
@


2.23
log
@Reworded Copyright statement, moved rcs id
@
text
@d20 1
a20 1
       "$RCSfile: $"
d159 1
d186 1
a186 1
    call get_eta_sparse ( p_basis,phi_t, eta_t )
d361 1
d392 1
a392 1
        & * Acos((req + cvf_h_tan(jun))/ (req + old_hts(jun))), et_p )
a396 1
    call deallocate_test ( eta_p, 'eta_p', ModuleName )
d435 2
a436 2
        IF (cvf_inds(jun(st_ind)) == tan_ptr - 2*n_vert + 1) THEN
          CALL mlsMessage(mlsmsg_warning,moduleName,'resorting to 1d option in metrics')
d439 3
a441 5
          CALL allocate_test(eta_p,1,p_coeffs,'eta_p',modulename)
          CALL get_eta_sparse(p_basis,(/phi_t((cvf_inds(low_pt)-1) &
               & / (2*n_vert) + 1)/), eta_p)
! this should be eta_p(1,p_coeffs)
          DO i = st_ind, end_ind
d443 3
a445 4
            & 2*n_vert),:)*eta_p(1,:)) - h_surf
          enddo
          call deallocate_test ( eta_p, 'eta_p', ModuleName )
        ELSE IF (cvf_inds(jun(end_ind)) > tan_ptr - 1) THEN
d447 1
a447 1
          CALL mlsMessage(mlsmsg_warning,moduleName,'resorting to 1d option in metrics')
d451 3
a453 4
          CALL allocate_test(eta_p,1,p_coeffs,'eta_p',modulename)
          CALL get_eta_sparse(p_basis,(/phi_t((cvf_inds(low_pt) - 1) &
          & / (2*n_vert) + 1)/), eta_p)
          DO i = st_ind, end_ind1
d455 2
a456 2
                          & + 1 - n_vert,:)*eta_p(1,:)) - h_surf
          enddo
d458 1
a458 1
          IF (end_ind1 < end_ind) THEN
d460 3
a462 4
            CALL get_eta_sparse(p_basis,(/phi_t((cvf_inds(low_pt)-1) &
                 & / (2*n_vert) + 2)/), eta_p)
! this should be eta_p(1,p_coeffs)
            DO i = end_ind1+1, end_ind
d464 3
a466 4
              & 2*n_vert),:)*eta_p(1,:)) - h_surf
            enddo
          endif
          call deallocate_test ( eta_p, 'eta_p', ModuleName )
d474 1
a474 1
        endif
a496 4
    ! now compute the temperature grid
    nullify ( eta_p )
    call allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )

d565 1
a565 1
       "$Id: $"
d574 3
@


2.22
log
@Add status argument
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d18 3
a20 6
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
    & "$Id: metrics_m.f90,v 2.21 2004/01/23 18:44:57 bill Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: metrics_m.f90,v $"
d22 1
a22 1
  !---------------------------------------------------------------------------
d572 5
d583 3
@


2.21
log
@problem with approximate correction patch when interpolation can't be done tentatively implimentaed
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.20 2003/11/14 21:22:46 livesey Exp $"
d26 5
a30 4
          &  beta, t_deriv_flag, h_grid, p_grid, t_grid, dhitdzi, req, dhidtlm,&
          &  ddhidhidtl0, dhitdtlm, eta_zxp, tan_phi_h_grid, tan_phi_t_grid,   &
          &  dhtdzt, dhtdtl0, ddhtdhtdtl0, neg_h_tan, z_basis, do_calc_t,      &
          &  do_calc_hyd )
d66 2
d167 1
d398 1
d430 2
a431 1
          CALL mlsmessage(mlsmsg_warning,modulename,'resorting to 1d option in metrics')
d444 2
a445 1
          CALL mlsmessage(mlsmsg_warning,modulename,'resorting to 1d option in metrics')
d573 3
@


2.20
log
@Bug fix and output tidy up
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.19 2003/06/27 23:43:34 vsnyder Exp $"
d108 1
d126 1
d418 1
a418 1
          hi_pt  = jun(st_ind) - 1
d421 1
a421 1
          hi_pt  = jun(end_ind) + 1
d423 38
d462 2
a463 2
        ! Correct
        h_grid(jun(st_ind):jun(end_ind)) = h_grid(low_pt) + &
d467 1
d566 3
@


2.19
log
@Remove unreferenced USE names
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.18 2003/06/20 23:41:48 vsnyder Exp $"
d391 1
a391 1
          & 'Full convergence not, implementing an improved approximation patch' )
d409 1
d428 2
a429 1
        path_ind = modulo(cvf_inds(jun(st_ind))-1,2*n_vert) + 1
d525 3
@


2.18
log
@Revise how compound etas are computed -- hopefully a faster method
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.17 2003/05/22 20:12:32 vsnyder Exp $"
a37 1
    use Dump_0, only: dump
a43 1
    use Units, only: PI
d523 3
@


2.17
log
@Get rid of some array temps
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.16 2002/10/25 22:24:08 livesey Exp $"
a473 8
!
! Initialize all ..
!
      do_calc_t = .false.
      do_calc_hyd = .false.

      eta_zxp = 0.0_rp
      dhitdtlm = 0.0_rp
d479 19
a497 9
          if ( .not. t_deriv_flag(sv_t) ) cycle
          where ( not_zero_t(:,sv_z) .and. not_zero_p(:,sv_p) )
            do_calc_t(:,sv_t) = .true.
            eta_zxp(:,sv_t) = eta_t(:,sv_z) * eta_p(:,sv_p)
          end where
          where ( not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_z,sv_p) > 0.0_rp )
            do_calc_hyd(:,sv_t) = .TRUE.
            dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_z,sv_p) * eta_p(:,sv_p)
          end where
d525 3
@


2.16
log
@Made the warning output optional
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.15 2002/10/08 17:08:05 pwagner Exp $"
d109 2
a110 8
    integer :: P_COEFFS
    integer :: Z_COEFFS
    integer :: N_VERT
    integer :: N_TAN
    integer :: SS_HTAN
    integer :: SV_T
    integer :: SV_P
    integer :: SV_Z
d112 1
d114 1
a115 1
    integer :: ITER
d117 5
d123 4
a126 4
    integer :: END_IND
    integer :: LOW_PT
    integer :: HI_PT
    INTEGER :: noos ! number out of sequence
d128 1
d130 1
a130 1
    real(rp) :: CP2
a131 1
    real(rp) :: H_SURF
d139 4
a144 8
    integer, dimension(:), pointer :: NEAR_INDS
    integer, dimension(:), pointer :: PATH_IND
    integer, dimension(:), pointer :: JUNK, JUN ! JUN => some_of_JUNK
    integer, dimension(:), pointer :: FORCE_ZERO
    integer, dimension(:), pointer :: INDS
    integer, dimension(:), pointer :: TAN_IND
    INTEGER, DIMENSION(:), POINTER :: diff
    INTEGER, DIMENSION(:), POINTER :: ind_bp
d186 1
a186 1
    ! now for the path quantities, for simplicity, we are going to set the
d202 1
a202 1
      call Allocate_test ( dhtdtl, z_coeffs, 'dhtdtl', ModuleName )
d236 1
a236 2
    call Allocate_test ( eta_t, n_vert, max (1,n_tan-ss_htan), 'n_vert', ModuleName )
    call Allocate_test ( h_grid_tt, n_vert, 'h_grid_tt', ModuleName )
d238 1
d242 1
a248 1
    call Deallocate_test ( eta_t, 'eta_t', ModuleName )
d253 1
a253 1
    nullify ( h_zf, path_inds, vert_inds, near_inds, cvf_inds )
a260 3
    call allocate_test ( path_inds, n_cvf, 'path_inds', ModuleName )
    call allocate_test ( vert_inds, n_cvf, 'vert_inds', ModuleName )
    call allocate_test ( near_inds, n_cvf/2, 'near_inds', ModuleName )
d282 3
a292 2
    h_grid = PACK(SPREAD(h_grid_tt((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)), &
                      &  2,n_tan),mask2)
a295 1
    call deallocate_test ( h_grid_tt, 'h_grid_tt', ModuleName )
d329 5
d339 3
d382 1
a382 1
      h_grid(jun) = max ( cvf_h_tan(jun), sum(h_zf(jun,:) * et_p,dim=2) )
d394 1
a394 2
        call output ( 'pth ind, tan ind, error', advance='yes' )

d401 12
a412 12
      nullify ( path_ind, tan_ind )
      call Allocate_test ( path_ind, no_of_bad_fits, 'path_ind', ModuleName )
      call Allocate_test ( tan_ind, no_of_bad_fits, 'tan_ind', ModuleName )
      path_ind = modulo(cvf_inds(jun)-1,2*n_vert) + 1
      tan_ind = 1 + (cvf_inds(jun)-1) / (2*n_vert)
      if ( toggle(emit) ) then
        do i = 1, no_of_bad_fits
          call output ( path_ind(i) )
          call output ( tan_ind(i) )
          call output ( old_hts(jun(i))-h_grid(jun(i)), advance='yes' )
        end do
      end if
a413 1
      if ( no_of_bad_fits == 1 ) then
d415 6
a420 8
        if ( path_ind(1) < n_vert + 1 ) then
          ! this is the near observer side
          low_pt = jun(1) + 1
          hi_pt  = jun(1) - 1
        else
          ! this is the far observer side
          low_pt = jun(1) - 1
          hi_pt  = jun(1) + 1
d422 1
d424 1
a424 1
        h_grid(jun(1)) = h_grid(low_pt) + &
d426 1
a426 1
             & (cvf_z_grid(jun(1))-cvf_z_grid(low_pt)) / &
d428 3
a430 49
      else

!        end_ind = 1
!        st_ind = 1
!        do while ( end_ind <= no_of_bad_fits )

!          do while ( tan_ind(end_ind) <= tan_ind(st_ind) )
!            end_ind = end_ind + 1
!          end do

!          end_ind = end_ind - 1
! replacement code: find ranges of contigous indicies
        NULLIFY(diff,ind_bp)
        CALL ALLOCATE_TEST(diff, no_of_bad_fits, 'diff', modulename)
        diff(1:no_of_bad_fits-1) = jun(2:no_of_bad_fits) &
                               & - jun(1:no_of_bad_fits-1)
        diff(no_of_bad_fits) = 2
        noos = COUNT(diff > 1)
        CALL ALLOCATE_TEST(ind_bp,noos,'ind_bp',modulename)
        ind_bp = PACK((/(i,i=1,no_of_bad_fits)/),diff > 1)
        st_ind = 1
        DO i = 1 , noos
          end_ind = ind_bp(i)

          ! find which side of the tangent we are on
          if ( path_ind(st_ind) < n_vert + 1 ) then
            ! this is the near observer side
            low_pt = jun(end_ind) + 1
            hi_pt  = jun(st_ind) - 1
          else
            ! this is the far observer side
            low_pt = jun(st_ind) - 1
            hi_pt  = jun(end_ind) + 1
          end if

          ! Correct
          h_grid(jun(st_ind):jun(end_ind)) = h_grid(low_pt) + &
               & (h_grid(hi_pt) - h_grid(low_pt)) * &
               & (cvf_z_grid(jun(st_ind):jun(end_ind))-cvf_z_grid(low_pt)) / &
               & (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
          st_ind = end_ind + 1
!          end_ind = st_ind
        end do
        CALL DEALLOCATE_TEST(diff,'diff',modulename)
        CALL DEALLOCATE_TEST(ind_bp,'ind_bp',modulename)
      end if

      call deallocate_test ( path_ind, 'path_ind', ModuleName )
      call deallocate_test ( tan_ind, 'tan_ind', ModuleName )
a437 2
    call deallocate_test ( path_inds, 'path_inds', ModuleName )
    call deallocate_test ( near_inds, 'near_inds', ModuleName )
d523 3
@


2.15
log
@Added idents to survive zealous Lahey optimizer
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.14 2002/10/08 14:42:57 bill Exp $"
d42 3
d390 6
a395 3
      print *,'Warning: full convergence not acheived on:'
      print *,'implementing an improved approximation patch'
      print *,'path index  tangent index  error'
d406 7
a412 2
      print '(i9,i15,3x,f7.3)', (path_ind(i),tan_ind(i), &
              & old_hts(jun(i))-h_grid(jun(i)), i = 1 , no_of_bad_fits )
a475 1
      print *,'completed re-estimation of bad points'
d573 3
@


2.14
log
@fixed bug in non convergent estimator?
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.13 2002/10/01 02:27:49 vsnyder Exp $"
d16 1
d556 4
d563 3
@


2.13
log
@Reduce number of array temps, move allocation for some out of loops.  Fix
a bug (junk could be accessed after being deallocated).  Cosmetic changes.
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.12 2002/09/26 20:14:24 vsnyder Exp $"
d122 1
d143 2
d420 18
a437 1
        end_ind = 1
d439 2
a440 7
        do while ( end_ind <= no_of_bad_fits )

          do while ( tan_ind(end_ind) <= tan_ind(st_ind) )
            end_ind = end_ind + 1
          end do

          end_ind = end_ind - 1
d459 1
a459 1
          end_ind = st_ind
d461 2
d558 4
@


2.12
log
@Get PI from Units module
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.11 2002/09/25 23:35:13 vsnyder Exp $"
d18 1
a18 1
  Integer, save :: CALLEDTIMES = 0
d45 1
a45 1
    Real(rp), intent(in) :: phi_t(:)   !orbit projected tangent geodetic angles
d47 1
a47 1
    Real(rp), intent(in) :: p_basis(:) !horizontal temperature representation
d49 1
a49 1
    Real(rp), intent(in) :: z_grid(:)  !pressures for which heights/temps are
d51 4
a54 4
    Real(rp), intent(in) :: h_ref(:,:) ! heights by t_phi_basis
    Real(rp), intent(in) :: t_ref(:,:) ! temperatures by t_phi_basis
    Real(rp), intent(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
    Real(rp), intent(in) :: beta       !orbital incline angle (Radians)
d57 4
a60 4
    Real(rp), intent(out) :: h_grid(:) !computed heights
    Real(rp), intent(out) :: p_grid(:) !computed phi's
    Real(rp), intent(out) :: t_grid(:) !computed temperatures
    Real(rp), intent(out) :: dhitdzi(:)!derivative of height wrt zeta
d62 1
a62 1
    Real(rp), intent(out) :: req       !equivalent elliptical earth radius
d66 2
a67 2
    Real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
    Real(rp), optional, intent(inout) :: dhidtlm(:,:,:) ! reference temperature
d70 1
a70 1
    Real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:)! second order reference
d72 1
a72 1
    Real(rp), optional, intent(in) :: neg_h_tan(:)  !sub earth tangent heights
d74 1
a74 1
    Real(rp), optional, intent(out) :: tan_phi_h_grid(:)!heights along the
d76 1
a76 1
    Real(rp), optional, intent(out) :: tan_phi_t_grid(:)!temperature along the
d78 1
a78 1
    Real(rp), optional, intent(out) :: dhtdzt(:)   ! height derivative wrt
d80 1
a80 1
    Real(rp), optional, intent(out) :: dhtdtl0(:,:) ! First order derivative at
d82 1
a82 1
    Real(rp), optional, intent(out) :: ddhtdhtdtl0(:,:) ! Second order 
d85 1
a85 1
    Real(rp), optional, intent(out) :: dhitdtlm(:,:)
d88 1
a88 1
    Real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature.
d123 4
a126 4
    Real(rp) :: CSQ
    Real(rp) :: CP2
    Real(rp) :: SP2
    Real(rp) :: H_SURF
d129 1
d138 1
a138 1
    integer, dimension(:), pointer :: JUNK
d143 15
a157 18
    Real(rp), dimension(:), pointer :: ARG
    Real(rp), dimension(:), pointer :: CVF_ANG_OFFSET
    Real(rp), dimension(:), pointer :: CVF_H_TAN
    Real(rp), dimension(:), pointer :: CVF_SIGN
    Real(rp), dimension(:), pointer :: CVF_Z_GRID
    Real(rp), dimension(:), pointer :: DHTDTL
    Real(rp), dimension(:), pointer :: H_BETTER
    Real(rp), dimension(size(tan_inds)) :: H_GRID_T
    Real(rp), dimension(:), pointer :: H_GRID_TT
    Real(rp), dimension(:), pointer :: OLD_HTS
    Real(rp), dimension(:), pointer :: SOME_PHI

    Real(rp), dimension(:,:), pointer :: ETA_P
    Real(rp), dimension(:,:), pointer :: ETA_T
    Real(rp), dimension(2*size(z_grid),size(tan_inds)) :: H_TANS
    Real(rp), dimension(:,:), pointer :: H_ZF
    Real(rp), dimension(2*size(z_grid),size(tan_inds)) :: M_Z_GRID
    Real(rp), dimension(2*size(z_grid),size(tan_inds)) :: PHI_TANS
d170 1
a170 1
    call Allocate_test ( eta_t, n_tan, p_coeffs, 'eta_t', ModuleName )
d200 3
a202 3
      dhtdtl = sum(RESHAPE(dhidtlm(1,:,:),(/z_coeffs,p_coeffs/)) &
        * SPREAD(RESHAPE(eta_t(1,:),(/p_coeffs/)),1,z_coeffs),dim=2)
!?    dhtdtl = sum(dhidtlm(1,:,:) * SPREAD(eta_t(1,:),1,z_coeffs),dim=2)
d216 1
a216 1
      call Deallocate_test ( dhtdtl, 'dhtdtl', ModuleName )
d220 1
a220 1
    call Deallocate_test ( eta_t, 'eta_t', ModuleName )
d228 1
a228 1
    ! construct some basic matricies
d252 10
a261 10
    call Allocate_test ( old_hts, n_cvf, 'old_hts', ModuleName )
    call Allocate_test ( cvf_h_tan, n_cvf, 'cvf_h_tan', ModuleName )
    call Allocate_test ( cvf_z_grid, n_cvf, 'cvf_z_grid', ModuleName )
    call Allocate_test ( cvf_ang_offset, n_cvf, 'cvf_ang_offset', ModuleName )
    call Allocate_test ( cvf_sign, n_cvf, 'cvf_sign', ModuleName )
    call Allocate_test ( h_zf, n_cvf, p_coeffs, 'h_zf', ModuleName )
    call Allocate_test ( path_inds, n_cvf, 'path_inds', ModuleName )
    call Allocate_test ( vert_inds, n_cvf, 'vert_inds', ModuleName )
    call Allocate_test ( near_inds, n_cvf/2, 'near_inds', ModuleName )
    call Allocate_test ( cvf_inds, n_cvf, 'cvf_inds', ModuleName )
d271 11
a281 7
    ! Apparently you can't sequentially access indicies in a multirank array
    ! in f90 like you can in idl which is a major inconvenience
    nullify ( mask )
    call Allocate_test ( mask, 2*n_vert*n_tan, 'mask', ModuleName )
    mask = .false.
    mask(cvf_inds) = .true.
    cvf_ang_offset = PACK(phi_tans,RESHAPE(mask,(/2*n_vert,n_tan/)))
d291 3
a293 3
                      &  2,n_tan),RESHAPE(mask,(/2*n_vert,n_tan/)))
    cvf_h_tan = PACK(h_tans,RESHAPE(mask,(/2*n_vert,n_tan/)))
    cvf_z_grid = PACK(m_z_grid,RESHAPE(mask,(/2*n_vert,n_tan/)))
d295 2
a296 2
    call Deallocate_test ( h_grid_tt, 'h_grid_tt', ModuleName )
    call Deallocate_test ( mask, 'mask', ModuleName )
d302 1
a302 1
      call Allocate_test ( force_zero, 2*(n_tan-ss_htan), 'force_zero', ModuleName )
d306 1
a306 1
      do i = 2,n_tan - ss_htan
d339 4
a342 3
    nullify ( mask, eta_p )
    call Allocate_test ( mask, n_cvf, 'mask', ModuleName )
    call Allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )
d345 1
a345 10
    h_grid = sum(h_zf * eta_p,dim=2)
    call Deallocate_test ( eta_p, 'eta_p', ModuleName )

    mask = abs(old_hts-h_grid) > 0.01_rp
    no_of_bad_fits = count(mask)

    nullify ( junk )
    call Allocate_Test ( junk , no_of_bad_fits, 'junk', ModuleName )
    junk = PACK((/(i,i=1,n_cvf)/),mask)
    where ( h_grid < cvf_h_tan ) h_grid = cvf_h_tan
d354 7
a360 1
      if ( no_of_bad_fits == 0 .or. iter == 20 ) exit
d362 1
d372 3
a374 29
      nullify ( arg, some_phi, h_better, eta_p )
      call Allocate_test ( arg, no_of_bad_fits, 'arg', ModuleName )
      call Allocate_test ( some_phi, no_of_bad_fits, 'some_phi', ModuleName )
      call Allocate_test ( h_better, no_of_bad_fits, 'h_better', ModuleName )
      call Allocate_test ( eta_p, no_of_bad_fits, p_coeffs, 'eta_p', ModuleName )

      arg = (req + cvf_h_tan(junk))/ (req + old_hts(junk))
      some_phi = cvf_ang_offset(junk) + cvf_sign(junk) * Acos(arg)
      call get_eta_sparse ( p_basis, some_phi, eta_p )
      h_better = sum(h_zf(junk,:) * eta_p,dim=2)
      h_better = max ( cvf_h_tan(junk), h_better )

  !   where (h_better < cvf_h_tan(junk) )
  !     h_better = cvf_h_tan(junk)
  !   end where

      h_grid(junk) = h_better
      call Deallocate_test ( junk, 'junk', ModuleName )
      call Deallocate_test ( h_better, 'h_better', ModuleName )
      call Deallocate_test ( arg, 'arg', ModuleName )
      call Deallocate_test ( some_phi, 'some_phi', ModuleName )
      call Deallocate_test ( eta_p, 'eta_p', ModuleName )

      mask = abs(old_hts-h_grid) > 0.01_rp
      no_of_bad_fits = count(mask)

      call Deallocate_test ( junk, 'junk', ModuleName )
      call Allocate_test ( junk, no_of_bad_fits, 'junk', ModuleName )
      junk = PACK((/(i,i=1,n_cvf)/),mask)
d378 1
d385 1
a385 1
      print *,'path index, tangent index, error'
d394 4
a397 8
      path_ind = modulo(cvf_inds(junk)-1,2*n_vert) + 1
      tan_ind = 1 + (cvf_inds(junk)-1) / (2*n_vert)
      st_ind = 1
      end_ind = 1
      do i = 1 , no_of_bad_fits
        print '(i5,1x,i5,1x,f7.3)',path_ind(i),tan_ind(i), &
              & old_hts(junk(i))-h_grid(junk(i))
      end do
d400 15
a414 15
         ! find which side of the tangent we are on
         if ( path_ind(st_ind) < n_vert + 1 ) then
            ! this is the near observer side
            low_pt = junk(1) + 1
            hi_pt  = junk(1) - 1
         else
            ! this is the far observer side
            low_pt = junk(1) - 1
            hi_pt  = junk(1) + 1
         end if
         ! Correct
         h_grid(junk(1)) = h_grid(low_pt) + &
              & (h_grid(hi_pt) - h_grid(low_pt)) * &
              & (cvf_z_grid(junk(1))-cvf_z_grid(low_pt)) / &
              & (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
d417 9
a425 2
         fixheights: do
            if ( end_ind > no_of_bad_fits ) exit fixheights
d427 19
a445 26
            getrange: do
               if ( tan_ind(end_ind) > tan_ind(st_ind) ) exit getrange
               end_ind = end_ind + 1
            end do getrange

            end_ind = end_ind - 1

            ! find which side of the tangent we are on
            if ( path_ind(st_ind) < n_vert + 1 ) then
               ! this is the near observer side
               low_pt = junk(end_ind) + 1
               hi_pt  = junk(st_ind) - 1
            else
               ! this is the far observer side
               low_pt = junk(st_ind) - 1
               hi_pt  = junk(end_ind) + 1
            end if

            ! Correct
            h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) + &
                 & (h_grid(hi_pt) - h_grid(low_pt)) * &
                 & (cvf_z_grid(junk(st_ind):junk(end_ind))-cvf_z_grid(low_pt)) / &
                 & (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
            st_ind = end_ind + 1
            end_ind = st_ind
         end do fixheights
d449 2
a450 2
      call Deallocate_test ( path_ind, 'path_ind', ModuleName )
      call Deallocate_test ( tan_ind, 'tan_ind', ModuleName )
d455 5
a459 5
    call Deallocate_test ( junk, 'junk', ModuleName )
    call Deallocate_test ( old_hts, 'old_hts', ModuleName )
    call Deallocate_test ( h_zf, 'h_zf', ModuleName )
    call Deallocate_test ( path_inds, 'path_inds', ModuleName )
    call Deallocate_test ( near_inds, 'near_inds', ModuleName )
d462 1
a462 1
    call Allocate_test ( not_zero_p, n_cvf, p_coeffs, 'not_zero_p', ModuleName )
d468 1
a468 1
      call Deallocate_test ( force_zero, 'force_zero', ModuleName )
d473 1
a473 1
    call Allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )
d475 1
a475 1
    call get_eta_sparse(p_basis,p_grid,eta_p,NOT_ZERO = not_zero_p)
d486 3
a488 3
      call Allocate_test ( inds, n_cvf, 'inds', ModuleName )
      call Allocate_test ( eta_t, n_cvf, z_coeffs, 'eta_t', ModuleName )
      call Allocate_test ( not_zero_t, n_cvf, z_coeffs, 'not_zero_t', ModuleName )
d492 1
a492 1
      where(inds >= 0) inds = inds + 1
d509 2
a510 2
          if ( .NOT. t_deriv_flag(sv_t) ) cycle
          where (not_zero_p(:,sv_p) .and. not_zero_t(:,sv_z))
d514 1
a514 1
          where (not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_z,sv_p) > 0.0_rp)
d521 3
a523 3
      call Deallocate_test ( inds, 'inds', ModuleName )
      call Deallocate_test ( eta_t, 'eta_t', ModuleName )
      call Deallocate_test ( not_zero_t, 'not_zero_t', ModuleName )
d527 8
a534 8
    call Deallocate_test ( eta_p, 'eta_p', ModuleName )
    call Deallocate_test ( cvf_ang_offset, 'cvf_ang_offset', ModuleName )
    call Deallocate_test ( cvf_z_grid, 'cvf_z_grid', ModuleName )
    call Deallocate_test ( cvf_sign, 'cvf_sign', ModuleName )
    call Deallocate_test ( cvf_h_tan, 'cvf_h_tan', ModuleName )
    call Deallocate_test ( cvf_inds, 'cvf_inds', ModuleName )
    call Deallocate_test ( vert_inds, 'vert_inds', ModuleName )
    call Deallocate_test ( not_zero_p, 'not_zero_p', ModuleName )
d541 3
@


2.11
log
@Simplify equivalent earth radius, insert copyright notice
@
text
@d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.10 2002/09/06 18:16:41 vsnyder Exp $"
d38 1
a38 1
    use Geometry, only: EarthRadA, EarthRadB, Pi
d41 1
d569 3
@


2.10
log
@Cosmetic changes, move USEs from module scope to procedure scope
@
text
@d1 2
a2 2
! The goal of this program is to return a matrix of h_grids
! and t_grids which define 2 d integration paths
d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.9 2002/08/10 00:13:33 livesey Exp $"
d30 3
d37 1
a37 1
    use dump_0, only: dump
d122 1
a122 1
    Real(rp) :: C
d167 2
a168 2
    c = earthrada * earthradb / &
         sqrt(earthrada**2*sin(beta)**2 + earthradb**2*cos(beta)**2)
d181 2
a182 2
    req = 0.001_rp*sqrt((earthrada**4*sp2 + c**4*cp2) / &
                      & (earthrada**2*cp2 + c**2*sp2))
d203 1
d568 3
@


2.9
log
@Tiny bug fix to Bill's bug fix
@
text
@d4 1
a4 1
Module metrics_m
d6 1
a6 8
  USE MLSCommon, only: RP, IP
  USE Geometry, only: earthrada,earthradb,pi
  USE get_eta_matrix_m, only: get_eta_sparse
  USE Allocate_deallocate, only: Allocate_test, Deallocate_test

  USE dump_0, only: dump

  IMPLICIT NONE
d8 1
a9 1
  public :: metrics
d12 1
a12 1
    & "$Id: metrics_m.f90,v 2.8 2002/08/10 00:08:47 bill Exp $"
d22 1
a22 1
  ! ------------------------------------------------ Metrics --------------
d24 5
a28 5
  subroutine metrics(phi_t,tan_inds,p_basis,z_grid,h_ref,t_ref,dhidzij, &
          &  beta,t_deriv_flag,h_grid,p_grid,t_grid,dhitdzi,req,dhidtlm,&
          &  ddhidhidtl0,dhitdtlm,eta_zxp,tan_phi_h_grid,tan_phi_t_grid,&
          &  dhtdzt,dhtdtl0,ddhtdhtdtl0,neg_h_tan,z_basis,do_calc_t,    &
          &  do_calc_hyd)
d33 6
d45 4
a48 4
    Real(rp), intent(in) :: z_grid(:)!pressures for which heights/temps are
    !                                 needed
    Real(rp), intent(in) :: h_ref(:,:)! heights by t_phi_basis
    Real(rp), intent(in) :: t_ref(:,:)! temperatures by t_phi_basis
d53 3
a55 3
    Real(rp), intent(out) :: h_grid(:)!computed heights
    Real(rp), intent(out) :: p_grid(:)!computed phi's
    Real(rp), intent(out) :: t_grid(:)!computed temperatures
d57 1
a57 1
    !                              --maybe useful in future computations
d76 1
a76 1
    Real(rp), OPTIONAL, INTENT(out) :: dhtdtl0(:,:) ! First order derivative at
d78 1
a78 1
    Real(rp), OPTIONAL, INTENT(out) :: ddhtdhtdtl0(:,:) ! Second order 
d145 1
a145 1
    Real(rp), dimension(:), pointer :: H_GRID_T
d152 1
a152 1
    Real(rp), dimension(:,:), pointer :: H_TANS
d154 2
a155 2
    Real(rp), dimension(:,:), pointer :: M_Z_GRID
    Real(rp), dimension(:,:), pointer :: PHI_TANS
d159 1
a159 1
    calledTimes=calledTimes + 1
d164 1
a164 1
    c = earthrada*earthradb / &
d167 1
a167 2
    nullify ( h_grid_t, eta_t, m_z_grid, h_tans, phi_tans )
    call Allocate_test ( h_grid_t, n_tan, 'h_grid_t', ModuleName )
a168 3
    call Allocate_test ( m_z_grid, 2*n_vert, n_tan, 'm_z_grid', ModuleName )
    call Allocate_test ( h_tans, 2*n_vert, n_tan, 'h_tans', ModuleName )
    call Allocate_test ( phi_tans, 2*n_vert, n_tan, 'phi_tans', ModuleName )
d171 1
a171 1
    call get_eta_sparse(p_basis,phi_t,eta_t)
d182 1
a182 1
    ! surface reference at the inputted z_grid(1) and adjust the req and the
d188 2
a189 2
    if(present(tan_phi_h_grid)) tan_phi_h_grid = h_grid_t
    if(present(tan_phi_t_grid)) &
d191 1
a191 1
    if(present(dhtdzt)) dhtdzt = sum(dhidzij(tan_inds,:)*eta_t,dim=2)
d194 1
a194 1
    if (present(dhidtlm)) then
d215 1
a215 1
    endif
d220 1
a220 1
    if(PRESENT(neg_h_tan)) then
d222 2
a223 2
      if(PRESENT(tan_phi_h_grid)) tan_phi_h_grid(1:ss_htan)=neg_h_tan-h_surf
    endif
d233 2
a234 2
    call get_eta_sparse(z_grid(tan_inds(min(n_tan,ss_htan+1):n_tan)),z_grid, &
                      & eta_t)
a241 1
    call Deallocate_test ( h_grid_t, 'h_grid_t', ModuleName )
a287 3
    call Deallocate_test ( m_z_grid, 'm_z_grid', ModuleName )
    call Deallocate_test ( h_tans, 'h_tans', ModuleName )
    call Deallocate_test ( phi_tans, 'phi_tans', ModuleName )
d292 1
a292 1
    if(n_tan > ss_htan) then
d305 1
a305 1
    endif
d312 1
a312 1
    if(n_tan > ss_htan) p_grid(force_zero) = cvf_ang_offset(force_zero)
d336 1
a336 1
    call get_eta_sparse(p_basis,p_grid,eta_p)
d338 1
a338 1
    call Deallocate_test( eta_p, 'eta_p', ModuleName )
d346 1
a346 3
    where(h_grid < cvf_h_tan)
      h_grid = cvf_h_tan
    endwhere
d349 1
a349 1
    ! according to the fortran explained book
d355 1
a355 1
      if (no_of_bad_fits == 0 .or. iter == 20) EXIT
d374 1
a374 1
      call get_eta_sparse(p_basis,some_phi,eta_p)
d380 1
a380 1
  !   endwhere
d400 1
a400 1
    if (no_of_bad_fits > 0) then
d422 1
a422 1
      IF(no_of_bad_fits == 1) THEN
d424 1
a424 1
         if (path_ind(st_ind) < n_vert + 1) then
d438 1
a438 1
      ELSE
d440 2
a441 2
         fixheights: DO
            IF (end_ind > no_of_bad_fits) EXIT fixheights
d443 2
a444 2
            getrange: DO
               if(tan_ind(end_ind) > tan_ind(st_ind)) exit getrange
d446 1
a446 1
            END DO getrange
d451 1
a451 1
            if (path_ind(st_ind) < n_vert + 1) then
d468 2
a469 2
         END DO fixheights
      END IF
d475 1
a475 1
    endif
d489 1
a489 1
    if(n_tan > ss_htan) then
d492 1
a492 1
    endif
d506 1
a506 1
    if (PRESENT(dhitdtlm)) then
d518 1
a518 1
      call get_eta_sparse(z_basis,cvf_z_grid,eta_t,NOT_ZERO = not_zero_t)
d532 1
a532 1
          if(.NOT. t_deriv_flag(sv_t)) CYCLE
d536 1
a536 1
          endwhere
d540 1
a540 1
          endwhere
d548 1
a548 1
    endif
d559 3
a561 1
  end subroutine metrics
a562 1
end module metrics_m
d564 3
@


2.8
log
@fixed bad pt correction bug
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.7 2002/07/05 07:52:50 zvi Exp $"
d447 1
a447 1
              & (cvf_z_grid(junk(1):junk(1))-cvf_z_grid(low_pt)) / &
d574 3
@


2.7
log
@Coor. switch (phi,z) -> (z,phi)
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.6 2002/06/19 11:00:35 zvi Exp $"
d433 48
a480 32
      do

        if(end_ind > no_of_bad_fits) EXIT

        do
          if(tan_ind(end_ind) > tan_ind(st_ind)) exit
          end_ind = end_ind + 1
        end do

        end_ind = end_ind - 1

        ! find which side of the tangent we are on
        if (path_ind(st_ind) < n_vert + 1) then
          ! this is the near observer side
          low_pt = junk(end_ind) + 1
          hi_pt  = junk(st_ind) - 1
        else
          ! this is the far observer side
          low_pt = junk(st_ind) - 1
          hi_pt  = junk(end_ind) + 1
        end if

        ! Correct
        h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) + &
          & (h_grid(hi_pt) - h_grid(low_pt)) * &
          & (cvf_z_grid(junk(st_ind):junk(end_ind))-cvf_z_grid(low_pt)) / &
          & (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
        st_ind = end_ind + 1
        end_ind = st_ind

      end do

d574 3
@


2.6
log
@Some cosmetic corrections
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.5 2002/06/07 04:50:47 bill Exp $"
d42 1
a42 1
    real(rp), intent(in) :: phi_t(:)   !orbit projected tangent geodetic angles
d44 1
a44 1
    real(rp), intent(in) :: p_basis(:) !horizontal temperature representation
d46 1
a46 1
    real(rp), intent(in) :: z_grid(:)!pressures for which heights/temps are
d48 4
a51 4
    real(rp), intent(in) :: h_ref(:,:)! heights by t_phi_basis
    real(rp), intent(in) :: t_ref(:,:)! temperatures by t_phi_basis
    real(rp), intent(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
    real(rp), intent(in) :: beta       !orbital incline angle (Radians)
d54 4
a57 4
    real(rp), intent(out) :: h_grid(:)!computed heights
    real(rp), intent(out) :: p_grid(:)!computed phi's
    real(rp), intent(out) :: t_grid(:)!computed temperatures
    real(rp), intent(out) :: dhitdzi(:)!derivative of height wrt zeta
d59 1
a59 1
    real(rp), intent(out) :: req       !equivalent elliptical earth radius
d63 2
a64 2
    real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
    real(rp), optional, intent(inout) :: dhidtlm(:,:,:) ! reference temperature
d66 2
a67 2
    !   all temperature coefficients. This is height X phi_basis X zeta_basis
    real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:)! second order reference
d69 1
a69 1
    real(rp), optional, intent(in) :: neg_h_tan(:)  !sub earth tangent heights
d71 1
a71 1
    real(rp), optional, intent(out) :: tan_phi_h_grid(:)!heights along the
d73 1
a73 1
    real(rp), optional, intent(out) :: tan_phi_t_grid(:)!temperature along the
d75 8
a82 7
    real(rp), optional, intent(out) :: dhtdzt(:)     !height derivative wrt
    !                                                   pressure along the tangent
    REAL(rp), OPTIONAL, INTENT(out) :: dhtdtl0(:,:,:)!First order derivative at
    !                                                 the tangent
    REAL(rp), OPTIONAL, INTENT(out) :: ddhtdhtdtl0(:,:,:)!second order derivative
    !                            at the tangent only---used for antenna affects
    real(rp), optional, intent(out) :: dhitdtlm(:,:)
d85 2
a86 1
    real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature.
d120 4
a123 4
    real(rp) :: C
    real(rp) :: CP2
    real(rp) :: SP2
    real(rp) :: H_SURF
d139 18
a156 18
    real(rp), dimension(:), pointer :: ARG
    real(rp), dimension(:), pointer :: CVF_ANG_OFFSET
    real(rp), dimension(:), pointer :: CVF_H_TAN
    real(rp), dimension(:), pointer :: CVF_SIGN
    real(rp), dimension(:), pointer :: CVF_Z_GRID
    real(rp), dimension(:), pointer :: DHTDTL
    real(rp), dimension(:), pointer :: H_BETTER
    real(rp), dimension(:), pointer :: H_GRID_T
    real(rp), dimension(:), pointer :: H_GRID_TT
    real(rp), dimension(:), pointer :: OLD_HTS
    real(rp), dimension(:), pointer :: SOME_PHI

    real(rp), dimension(:,:), pointer :: ETA_P
    real(rp), dimension(:,:), pointer :: ETA_T
    real(rp), dimension(:,:), pointer :: H_TANS
    real(rp), dimension(:,:), pointer :: H_ZF
    real(rp), dimension(:,:), pointer :: M_Z_GRID
    real(rp), dimension(:,:), pointer :: PHI_TANS
d165 2
a166 3
    c = earthrada*earthradb &
      / sqrt(earthrada**2*sin(beta)**2 &
      + earthradb**2*cos(beta)**2)
d183 2
a184 2
    req = 0.001_rp*sqrt((earthrada**4*sp2 + c**4*cp2)/(earthrada**2*cp2 &
      + c**2*sp2))
d203 2
a204 2
      dhtdtl = sum(RESHAPE(dhidtlm(1,:,:),(/p_coeffs,z_coeffs/)) &
        * SPREAD(RESHAPE(eta_t(1,:),(/p_coeffs/)),2,z_coeffs),dim=1)
d207 11
a217 3
      dhidtlm = dhidtlm - SPREAD(SPREAD(dhtdtl,1,n_vert),2,p_coeffs)
      dhtdtl0 = dhidtlm(tan_inds,:,:) * SPREAD(eta_t,3,z_coeffs)
      ddhtdhtdtl0 = ddhidhidtl0(tan_inds,:,:) * SPREAD(eta_t,3,z_coeffs)
d219 1
d239 1
a239 1
      eta_t)
d285 1
a285 2
      cvf_ang_offset(j+1:j+n_vert) = phi_t(i) &
        -2.0_rp*acos((req + neg_h_tan(i)) / req)
d290 1
a290 1
      2,n_tan),RESHAPE(mask,(/2*n_vert,n_tan/)))
d309 2
a310 2
        force_zero(j) = force_zero(j-2)+2*n_vert &
          - tan_inds(ss_htan+i-1)-tan_inds(ss_htan+i)+2
d318 1
a318 2
    p_grid = cvf_ang_offset + cvf_sign &
      * acos((req + cvf_h_tan)/(req + old_hts))
d372 2
a373 2
        cvf_ang_offset(j+1:j+n_vert) = phi_t(i) &
          -2.0_rp*acos((req + neg_h_tan(i)) / (req + h_grid(j)))
d384 1
a384 1
      some_phi = cvf_ang_offset(junk) + cvf_sign(junk) * acos(arg)
d388 5
a392 3
      !       where (h_better < cvf_h_tan(junk) )
      !         h_better = cvf_h_tan(junk)
      !       endwhere
d430 1
a430 1
          old_hts(junk(i))-h_grid(junk(i))
d456 4
a459 4
        h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) &
          + (h_grid(hi_pt) - h_grid(low_pt)) &
          * (cvf_z_grid(junk(st_ind):junk(end_ind)) - cvf_z_grid(low_pt)) &
          / (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
d483 1
a483 2
    p_grid = cvf_ang_offset + cvf_sign  &
      * acos((req + cvf_h_tan)/(req + h_grid))
d532 3
a534 3
          where (not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_p,sv_z) > 0.0_rp)
            do_calc_hyd(:,sv_t) = .true.
            dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_p,sv_z) * eta_p(:,sv_p)
d558 3
@


2.5
log
@fixes and improvements--wgr
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.4 2002/02/08 00:48:09 zvi Exp $"
a206 4
!      if(PRESENT(dhtdtl0)) dhtdtl0 = sum(dhidtlm(tan_inds,:,:) &
!        * SPREAD(eta_t,3,z_coeffs),dim=2)
!      if(PRESENT(ddhtdhtdtl0)) ddhtdhtdtl0 = &
!        sum(ddhidhidtl0(tan_inds,:,:) * SPREAD(eta_t,3,z_coeffs),dim=2)
d347 1
a347 1
    where(h_grid < cvf_h_tan) 
d410 1
a410 1
      
d468 1
a468 1
    
d535 1
a535 1
    
d549 3
@


2.4
log
@Restoring the t_deriv_flag code
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.2 2002/01/30 01:11:21 zvi Exp $"
d77 1
a77 1
    real(rp), optional, intent(out) :: dhtdtl0(:,:)!First order derivative at
d79 1
a79 1
    real(rp), optional, intent(out) :: ddhtdhtdtl0(:,:)!second order derivative
d207 6
a212 4
      if(PRESENT(dhtdtl0)) dhtdtl0 = sum(dhidtlm(tan_inds,:,:) &
        * SPREAD(eta_t,3,z_coeffs),dim=2)
      if(PRESENT(ddhtdhtdtl0)) ddhtdhtdtl0 = &
        sum(ddhidhidtl0(tan_inds,:,:) * SPREAD(eta_t,3,z_coeffs),dim=2)
d553 3
@


2.3
log
@commented out t_deriv_flag
@
text
@d91 2
d520 1
a520 1
!          if(.NOT. t_deriv_flag(sv_t)) CYCLE
@


2.2
log
@Fix bug in user selectable coeff. code
@
text
@d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.1 2001/11/20 01:19:30 zvi Exp $"
a90 2
    ! p_basis and p_grid are phi's in offset degrees relative to phi_t, that
    ! is the phi_t p_basis or p_grid = 0.0 is phi_t.
d518 1
a518 1
          if(.NOT. t_deriv_flag(sv_t)) CYCLE
d549 3
@


2.1
log
@Some clarification of code
@
text
@d4 1
a4 5
module metrics_m
  use MLSCommon, only: RP, IP
  use Geometry, only: earthrada,earthradb,pi
  use get_eta_matrix_m, only: get_eta_sparse
  use Allocate_deallocate, only: Allocate_test, Deallocate_test
d6 8
a13 2
  use dump_0, only: dump
  implicit none
d19 1
a19 1
    & "$Id: metrics_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d25 1
a25 1
  integer, save :: CALLEDTIMES = 0
d32 4
a35 3
    beta,h_grid,p_grid,t_grid,dhitdzi,req,dhidtlm,ddhidhidtl0, &
    dhitdtlm,eta_zxp,tan_phi_h_grid,tan_phi_t_grid,dhtdzt,dhtdtl0, &
    ddhtdhtdtl0,neg_h_tan,z_basis,do_calc_t,do_calc_hyd)
d52 1
d258 4
a261 4
    cvf_inds = PACK((/(i,i=1,2*n_vert*n_tan)/), &
      RESHAPE(SPREAD((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/),2,n_tan), &
      (/2*n_vert*n_tan/)) &
      - RESHAPE(SPREAD(tan_inds,1,2*n_vert),(/2*n_vert*n_tan/)) >= 0)
d286 1
a351 1
    iter = 0
d355 2
d358 3
a360 1
      if (no_of_bad_fits == 0 .or. iter == 20) exit
d398 1
a398 1
      iter = iter + 1
d404 1
d426 3
a428 1
        if(end_ind > no_of_bad_fits) exit
d433 1
d456 1
d458 1
d461 1
d493 1
d495 1
d507 10
a516 1
      sv_t = 1
d519 2
a523 3
          elsewhere
            do_calc_t(:,sv_t) = .false.
            eta_zxp(:,sv_t) = 0.0_rp
a524 1
          
a527 3
          elsewhere
            do_calc_hyd(:,sv_t) = .false.
            dhitdtlm(:,sv_t) = 0.0_rp
d529 3
a531 3
          sv_t = sv_t + 1
        enddo
      enddo
d535 1
d546 1
d548 1
a549 2


d551 3
@


2.0
log
@New forward model
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.8 2001/09/13 01:26:53 zvi Exp $"
d198 2
a199 2
      dhtdtl = sum(reshape(dhidtlm(1,:,:),(/p_coeffs,z_coeffs/)) &
        * spread(reshape(eta_t(1,:),(/p_coeffs/)),2,z_coeffs),dim=1)
d202 5
a206 5
      dhidtlm = dhidtlm - spread(spread(dhtdtl,1,n_vert),2,p_coeffs)
      if(present(dhtdtl0)) dhtdtl0 = sum(dhidtlm(tan_inds,:,:) &
        * spread(eta_t,3,z_coeffs),dim=2)
      if(present(ddhtdhtdtl0)) ddhtdhtdtl0 = &
        sum(ddhidhidtl0(tan_inds,:,:) * spread(eta_t,3,z_coeffs),dim=2)
d213 1
a213 1
    if(present(neg_h_tan)) then
d215 1
a215 1
      if(present(tan_phi_h_grid)) tan_phi_h_grid(1:ss_htan)=neg_h_tan-h_surf
d219 2
a220 2
    h_tans = spread(h_grid_t,1,2*n_vert)
    phi_tans = spread(phi_t,1,2*n_vert)
d231 1
a231 1
    m_z_grid = spread(z_grid((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)),2,n_tan)
d254 2
a255 2
    cvf_inds = pack((/(i,i=1,2*n_vert*n_tan)/), &
      reshape(spread((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/),2,n_tan), &
d257 1
a257 1
      - reshape(spread(tan_inds,1,2*n_vert),(/2*n_vert*n_tan/)) >= 0)
d268 1
a268 1
    cvf_ang_offset = pack(phi_tans,reshape(mask,(/2*n_vert,n_tan/)))
d278 4
a281 4
    h_grid = pack(spread(h_grid_tt((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)), &
      2,n_tan),reshape(mask,(/2*n_vert,n_tan/)))
    cvf_h_tan = pack(h_tans,reshape(mask,(/2*n_vert,n_tan/)))
    cvf_z_grid = pack(m_z_grid,reshape(mask,(/2*n_vert,n_tan/)))
d322 1
a322 1
    near_inds = pack((/(i,i=1,n_cvf)/),path_inds <= n_vert)
d343 1
a343 1
    junk = pack((/(i,i=1,n_cvf)/),mask)
d389 1
a389 1
      junk = pack((/(i,i=1,n_cvf)/),mask)
d478 1
a478 1
    if (present(dhitdtlm)) then
d529 3
@


1.1
log
@file metrics_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 549
@


1.1.2.1
log
@Major Design change..
@
text
@a0 435
!
! The goal of this program is to return a matrix of h_grids
! and t_grids which define 2 d integration paths
!
MODULE metrics_m
 use MLSCommon, only: RP, IP
 USE Geometry, ONLY: earthrada,earthradb,pi
 USE get_eta_matrix_m, ONLY: get_eta_sparse
 IMPLICIT NONE
!
CONTAINS
!
 SUBROUTINE metrics(phi_t,tan_inds,p_basis,z_grid,h_ref,t_ref,dhidzij, &
            beta,h_grid,p_grid,t_grid,dhitdzi,req,dhidtlm,ddhidhidtl0, &
            dhitdtlm,eta_zxp,tan_phi_h_grid,tan_phi_t_grid,dhtdzt,dhtdtl0, &
            ddhtdhtdtl0,neg_h_tan,z_basis,do_calc_t,do_calc_hyd)
!
! The main change in this routine is to interchange the z_coeffs and
! p_coeffs so as to make it consistent with the radiative transfer program.
!
! inputs:
!
  REAL(rp), INTENT(in) :: phi_t(:)   !orbit projected tangent geodetic angles
  INTEGER(ip), INTENT(in) :: tan_inds(:)!tangent height indicies
  REAL(rp), INTENT(in) :: p_basis(:) !horizontal temperature representation
!                                     basis
  REAL(rp), INTENT(in) :: z_grid(:)!pressures for which heights/temps are
!                                 needed
  REAL(rp), INTENT(in) :: h_ref(:,:)! heights by t_phi_basis
  REAL(rp), INTENT(in) :: t_ref(:,:)! temperatures by t_phi_basis
  REAL(rp), INTENT(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
  REAL(rp), INTENT(in) :: beta       !orbital incline angle (Radians)
! outputs:
  REAL(rp), INTENT(out) :: h_grid(:)!computed heights
  REAL(rp), INTENT(out) :: p_grid(:)!computed phi's
  REAL(rp), INTENT(out) :: t_grid(:)!computed temperatures
  REAL(rp), INTENT(out) :: dhitdzi(:)!derivative of height wrt zeta
!                              --maybe useful in future computations
  REAL(rp), INTENT(out) :: req       !equivalent elliptical earth radius
!
! Keywords:
! optional inputs
  REAL(rp), OPTIONAL, INTENT(in) :: z_basis(:) ! vertical temperature basis
  REAL(rp), OPTIONAL, INTENT(inout) :: dhidtlm(:,:,:) ! reference temperature
!   derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is 0.0 for
!   all temperature coefficients. This is height X phi_basis X zeta_basis
  REAL(rp), OPTIONAL, INTENT(in) :: ddhidhidtl0(:,:,:)! second order reference
!   temperature derivatives. This is (height, phi_basis, zeta_basis)
  REAL(rp), OPTIONAL, INTENT(in) :: neg_h_tan(:)  !sub earth tangent heights
! optional outputs
  REAL(rp), OPTIONAL, INTENT(out) :: tan_phi_h_grid(:)!heights along the
!                                                      tangent
  REAL(rp), OPTIONAL, INTENT(out) :: tan_phi_t_grid(:)!temperature along the
!                                                      tangent
  REAL(rp), OPTIONAL, INTENT(out) :: dhtdzt(:)     !height derivative wrt
!                                                   pressure along the tangent
  REAL(rp), OPTIONAL, INTENT(out) :: dhtdtl0(:,:)!First order derivative at
!                                                 the tangent
  REAL(rp), OPTIONAL, INTENT(out) :: ddhtdhtdtl0(:,:)!second order derivative
!                            at the tangent only---used for antenna affects
  REAL(rp), OPTIONAL, INTENT(out) :: dhitdtlm(:,:)
!                             derivative of path position wrt temperature
!                             statevector (z_basisXphi_basis)
  REAL(rp), OPTIONAL, INTENT(out) :: eta_zxp(:,:) ! eta matrix for temperature.
  LOGICAL, OPTIONAL, INTENT(out) :: do_calc_t(:,:) ! non zero locater for
!                                       temperature bases computations.
  LOGICAL, OPTIONAL, INTENT(out) :: do_calc_hyd(:,:) !non zero locator for
!                                       hydrostatic calculations.
!
! NOTES
! p_basis and p_grid are phi's in offset degrees relative to phi_t, that
! is the phi_t p_basis or p_grid = 0.0 is phi_t.
! The phi basis is wholly independent of phi_t
! compute primary hydrostatic grid
! tangent phi index
!
! ===>> EVERYTHING comes out in cvf format <<===!
! Internal declarations
!
  LOGICAL, ALLOCATABLE :: mask(:),not_zero_p(:,:),not_zero_t(:,:)
!
  INTEGER(ip) :: p_coeffs,z_coeffs,n_vert,n_tan,ss_htan,sv_t,sv_p,sv_z
  INTEGER(ip) :: i,j,n_cvf,iter,no_of_bad_fits,st_ind,end_ind,low_pt,hi_pt
  INTEGER(ip), ALLOCATABLE :: cvf_inds(:),path_inds(:),vert_inds(:)
  INTEGER(ip), ALLOCATABLE :: near_inds(:),path_ind(:)
  INTEGER(ip), ALLOCATABLE :: junk(:),force_zero(:),inds(:),tan_ind(:)
!
  REAL(rp) :: c, cp2, sp2, h_surf
  REAL(rp), ALLOCATABLE :: eta_t(:,:),h_grid_t(:)
  REAL(rp), ALLOCATABLE :: cvf_h_tan(:),cvf_z_grid(:),dhtdtl(:)
  REAL(rp), ALLOCATABLE :: m_z_grid(:,:),h_tans(:,:),h_grid_tt(:)
  REAL(rp), ALLOCATABLE :: cvf_ang_offset(:),cvf_sign(:),eta_p(:,:)
  REAL(rp), ALLOCATABLE :: old_hts(:),arg(:),some_phi(:)
  REAL(rp), ALLOCATABLE :: h_zf(:,:),h_better(:),phi_tans(:,:)
!
! Begin program
!
  p_coeffs = SIZE(p_basis)
  n_vert = SIZE(z_grid)
  n_tan = SIZE(tan_inds)
!
  c = earthrada*earthradb &
    / SQRT(earthrada**2*SIN(beta)**2 &
    + earthradb**2*COS(beta)**2)
!
  ALLOCATE(h_grid_t(1:n_tan), &
     eta_t(1:n_tan,1:p_coeffs),m_z_grid(1:2*n_vert,1:n_tan), &
     h_tans(1:2*n_vert,1:n_tan), phi_tans(1:2*n_vert,1:n_tan))
!
! compute the tangent height vertical
!
  CALL get_eta_sparse(p_basis,phi_t,eta_t)
  h_grid_t = SUM(h_ref(tan_inds,:)*eta_t,dim=2)
  h_surf = SUM(h_ref(1,:)*eta_t(1,:))
!
! compute equivalent earth radius at phi_t(1), nearest surface
!
  cp2 = COS(phi_t(1))**2
  sp2 = 1.0_rp - cp2
  req = 0.001_rp*SQRT((earthrada**4*sp2 + c**4*cp2)/(earthrada**2*cp2 &
      + c**2*sp2))
!
! now for the path quantities, for simplicity, we are going to set the
! surface reference at the inputted z_grid(1) and adjust the req and the
! h_grid_t relative to this
!
  req = req + h_surf
!
! adjust h_ref accordingly
!
  h_grid_t = h_grid_t - h_surf
  IF(PRESENT(tan_phi_h_grid)) tan_phi_h_grid = h_grid_t
  IF(PRESENT(tan_phi_t_grid)) &
               tan_phi_t_grid = SUM(t_ref(tan_inds,:)*eta_t,dim=2)
  IF(PRESENT(dhtdzt)) dhtdzt = SUM(dhidzij(tan_inds,:)*eta_t,dim=2)
!
! compute tangent temperature derivative
!
  IF (PRESENT(dhidtlm)) THEN
    z_coeffs = SIZE(z_basis)
    ALLOCATE(dhtdtl(1:z_coeffs))
    dhtdtl = SUM(RESHAPE(dhidtlm(1,:,:),(/p_coeffs,z_coeffs/)) &
           * SPREAD(RESHAPE(eta_t(1,:),(/p_coeffs/)),2,z_coeffs),dim=1)
!
! adjust the 2d hydrostatic relative to the surface
!
    dhidtlm = dhidtlm - SPREAD(SPREAD(dhtdtl,1,n_vert),2,p_coeffs)
    IF(PRESENT(dhtdtl0)) dhtdtl0 = SUM(dhidtlm(tan_inds,:,:) &
                                 * SPREAD(eta_t,3,z_coeffs),dim=2)
    IF(PRESENT(ddhtdhtdtl0)) ddhtdhtdtl0 = &
        SUM(ddhidhidtl0(tan_inds,:,:) * SPREAD(eta_t,3,z_coeffs),dim=2)
    DEALLOCATE(dhtdtl,STAT=i)
  ENDIF
!
  DEALLOCATE(eta_t,STAT=i)
!
  ss_htan = 0
  IF(PRESENT(neg_h_tan)) THEN
    ss_htan = SIZE(neg_h_tan)
    IF(PRESENT(tan_phi_h_grid)) tan_phi_h_grid(1:ss_htan)=neg_h_tan-h_surf
  ENDIF
!
! construct some basic matricies
!
  h_tans = SPREAD(h_grid_t,1,2*n_vert)
  phi_tans = SPREAD(phi_t,1,2*n_vert)
  ALLOCATE(eta_t(1:n_vert,1:MAX(1,n_tan-ss_htan)),h_grid_tt(1:n_vert))
  CALL get_eta_sparse(z_grid(tan_inds(MIN(n_tan,ss_htan+1):n_tan)),z_grid, &
                      eta_t)
  h_grid_tt = MATMUL(eta_t,h_grid_t(MIN(n_tan,ss_htan+1):n_tan))
!
! basic pressure grid
!
  m_z_grid = SPREAD(z_grid((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)),2,n_tan)
!
! determine condensed vector format so we don't mess with a bunch
! of zeros
!
  DEALLOCATE(h_grid_t,eta_t,STAT=i)
  n_cvf = 2*SUM(n_vert + 1 - tan_inds)
  ALLOCATE(old_hts(1:n_cvf),cvf_h_tan(1:n_cvf), &
           cvf_z_grid(1:n_cvf),cvf_ang_offset(1:n_cvf),cvf_sign(1:n_cvf), &
           h_zf(1:n_cvf,1:p_coeffs),path_inds(1:n_cvf),vert_inds(1:n_cvf), &
           near_inds(1:n_cvf/2),cvf_inds(1:n_cvf))
  cvf_inds = PACK((/(i,i=1,2*n_vert*n_tan)/), &
             RESHAPE(SPREAD((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/),2,n_tan), &
             (/2*n_vert*n_tan/)) &
           - RESHAPE(SPREAD(tan_inds,1,2*n_vert),(/2*n_vert*n_tan/)) >= 0)
!
! sign of phi matrix
!
  cvf_sign = (-1.0_rp)**((MODULO(cvf_inds-1,2*n_vert)/n_vert)+1)
!
! Apparently you can't sequentially access indicies in a multirank array
! in f90 like you can in idl which is a major inconvenience
!
  ALLOCATE(mask(1:2*n_vert*n_tan))
  mask = .false.
  mask(cvf_inds) = .true.
  cvf_ang_offset = PACK(phi_tans,RESHAPE(mask,(/2*n_vert,n_tan/)))
!
! compute phi_s - phi_t
!
  j = n_vert
  DO i = 1 , ss_htan
    cvf_ang_offset(j+1:j+n_vert) = phi_t(i) &
          -2.0_rp*ACOS((req + neg_h_tan(i)) / req)
    h_tans(:,i) = neg_h_tan(i)
    j = j + n_vert + n_vert
  END DO
  h_grid = PACK(SPREAD(h_grid_tt((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)), &
                2,n_tan),RESHAPE(mask,(/2*n_vert,n_tan/)))
  cvf_h_tan = PACK(h_tans,RESHAPE(mask,(/2*n_vert,n_tan/)))
  cvf_z_grid = PACK(m_z_grid,RESHAPE(mask,(/2*n_vert,n_tan/)))
  DEALLOCATE(m_z_grid,h_tans,phi_tans,h_grid_tt,mask,STAT=i)
!
! These are the tangent indicies on a cvf array
!
  IF(n_tan > ss_htan) THEN
! some tangents above the earth surface
    ALLOCATE(force_zero(1:2*(n_tan - ss_htan)))
    force_zero(1) = n_vert*(2*ss_htan + 1) - tan_inds(1+ss_htan) + 1
    force_zero(2) = force_zero(1) + 1
    j = 3
    DO i = 2,n_tan - ss_htan
      force_zero(j) = force_zero(j-2)+2*n_vert &
                        - tan_inds(ss_htan+i-1)-tan_inds(ss_htan+i)+2
      force_zero(j+1) = force_zero(j)+1
      j = j + 2
    END DO
  ENDIF
!
! estimate the phi's using the tangent heights as a first guess
!
  old_hts = h_grid
  p_grid = cvf_ang_offset + cvf_sign &
          * ACOS((req + cvf_h_tan)/(req + old_hts))
!
! force the del phi at the tangent to be zero
!
  IF(n_tan > ss_htan) p_grid(force_zero) = cvf_ang_offset(force_zero)
!
! estimate some new heights
! This is going to have some small surface errors away
! from the tangent but we will ignore this issue for now.
! the following lines replace an extremely sparse matrix
! multiplication with a less memory intensive alternative
! and probably faster alternative
! convert the cvf indicies into path indicies
!
  path_inds = MODULO((cvf_inds - 1),2*n_vert) + 1
  vert_inds = path_inds - n_vert
  near_inds = PACK((/(i,i=1,n_cvf)/),path_inds <= n_vert)
  vert_inds(near_inds) = n_vert - path_inds(near_inds) + 1
!
! h_ref with surface adjustment
!
  h_zf = h_ref(vert_inds,:) - h_surf
!
! now these parts will change with iteration therefore these steps
! get repeated
!
  ALLOCATE(mask(1:n_cvf),eta_p(1:n_cvf,1:p_coeffs))
  CALL get_eta_sparse(p_basis,p_grid,eta_p)
  h_grid = SUM(h_zf * eta_p,dim=2)
  DEALLOCATE(eta_p,STAT=i)
  mask = .false.
  WHERE(ABS(old_hts - h_grid) > 0.01_rp) mask = .true.
  no_of_bad_fits = COUNT(mask)
  ALLOCATE(junk(1:no_of_bad_fits))
  junk = PACK((/(i,i=1,n_cvf)/),mask)
  WHERE(h_grid < cvf_h_tan) h_grid = cvf_h_tan
  iter = 0
!
! this construct is considered more desireable than a do while
! according to the fortran explained book
!
  DO

    IF (no_of_bad_fits == 0 .OR. iter == 20) EXIT
    old_hts = h_grid
!
! recompute phi_s - phi_t because we have to iterate on phi_s - phi_t
!
    j = n_vert
    DO i = 1 , ss_htan
      cvf_ang_offset(j+1:j+n_vert) = phi_t(i) &
           -2.0_rp*ACOS((req + neg_h_tan(i)) / (req + h_grid(j)))
      j = j + n_vert + n_vert
    END DO
    ALLOCATE(arg(1:no_of_bad_fits),some_phi(1:no_of_bad_fits), &
             h_better(1:no_of_bad_fits),eta_p(1:no_of_bad_fits,1:p_coeffs))
    arg = (req + cvf_h_tan(junk))/ (req + old_hts(junk))
    some_phi = cvf_ang_offset(junk) + cvf_sign(junk) * ACOS(arg)
    CALL get_eta_sparse(p_basis,some_phi,eta_p)
    h_better = SUM(h_zf(junk,:) * eta_p,dim=2)
    WHERE(h_better < cvf_h_tan(junk)) h_better = cvf_h_tan(junk)
    h_grid(junk) = h_better
    DEALLOCATE(junk,arg,some_phi,h_better,eta_p,STAT=i)
    mask = .false.
    WHERE(ABS(old_hts - h_grid) > 0.01_rp) mask = .true.
    no_of_bad_fits = COUNT(mask)
    ALLOCATE(junk(1:no_of_bad_fits))
    junk = PACK((/(i,i=1,n_cvf)/),mask)
    iter = iter + 1

  END DO

  DEALLOCATE(mask,STAT=i)
!
  IF (no_of_bad_fits > 0) THEN
!
    PRINT *,'Warning: full convergence not acheived on:'
    PRINT *,'implementing an improved approximation patch'
    PRINT *,'path index, tangent index, error'
!
! we are going to assume that the tangent value is good
! The following is an F90 specific design which is quite different
! from the IDL code
!
    ALLOCATE(path_ind(1:no_of_bad_fits),tan_ind(1:no_of_bad_fits))
    path_ind = MODULO(cvf_inds(junk)-1,2*n_vert) + 1
    tan_ind = 1 + (cvf_inds(junk)-1) / (2*n_vert)
    st_ind = 1
    end_ind = 1
    DO i = 1 , no_of_bad_fits
      PRINT '(i5,1x,i5,1x,f7.3)',path_ind(i),tan_ind(i), &
              old_hts(junk(i))-h_grid(junk(i))
    END DO
!
    DO
      IF(end_ind > no_of_bad_fits) EXIT
      DO
        IF(tan_ind(end_ind) > tan_ind(st_ind)) exit
          end_ind = end_ind + 1
      END DO
      end_ind = end_ind - 1
!
! find which side of the tangent we are on
!
      IF (path_ind(st_ind) < n_vert + 1) THEN
!
! this is the near observer side
!
        low_pt = junk(end_ind) + 1
        hi_pt  = junk(st_ind) - 1
!
      ELSE
!
! this is the far observer side
!
        low_pt = junk(st_ind) - 1
        hi_pt  = junk(end_ind) + 1
!
      END IF
!
! Correct
!
      h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) &
        + (h_grid(hi_pt) - h_grid(low_pt)) &
        * (cvf_z_grid(junk(st_ind):junk(end_ind)) - cvf_z_grid(low_pt)) &
        / (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
       st_ind = end_ind + 1
       end_ind = st_ind
!
    END DO
!
    PRINT *,'completed re-estimation of bad points'
    DEALLOCATE(path_ind,tan_ind,STAT=i)
!
  ENDIF
!
! deallocate the loop iteration stuff
!
  DEALLOCATE(junk,old_hts,h_zf,path_inds,near_inds,STAT=i)
  ALLOCATE(not_zero_p(1:n_cvf,1:p_coeffs))
!
! compute final set of angles
!
  p_grid = cvf_ang_offset + cvf_sign  &
          * ACOS((req + cvf_h_tan)/(req + h_grid))
  IF(n_tan > ss_htan) THEN
    p_grid(force_zero) = cvf_ang_offset(force_zero)
    DEALLOCATE(force_zero,STAT=i)
  ENDIF
!
! now compute the temperature grid
!
  ALLOCATE(eta_p(1:n_cvf,1:p_coeffs))
  CALL get_eta_sparse(p_basis,p_grid,eta_p,NOT_ZERO = not_zero_p)
  t_grid = SUM(t_ref(vert_inds,:) * eta_p,dim=2)
!
! compute the vertical derivative grid
!
  dhitdzi = SUM(dhidzij(vert_inds,:) * eta_p,dim=2)
!
! compute the temperature derivative grid
!
  IF (PRESENT(dhitdtlm)) THEN
    ALLOCATE(inds(1:n_cvf),eta_t(1:n_cvf,1:z_coeffs), &
             not_zero_t(1:n_cvf,1:z_coeffs))
!
! desparate attempt to try something different
!
    inds = MODULO(cvf_inds-1,2*n_vert) - n_vert
    WHERE(inds >= 0) inds = inds + 1
    inds = ABS(inds)
! compute the path temperature noting where the zeros are
    CALL get_eta_sparse(z_basis,cvf_z_grid,eta_t,NOT_ZERO = not_zero_t)
    sv_t = 1
    DO sv_p = 1 , p_coeffs
      DO sv_z = 1 , z_coeffs
        WHERE(not_zero_p(:,sv_p) .AND. not_zero_t(:,sv_z))
          do_calc_t(:,sv_t) = .true.
          eta_zxp(:,sv_t) = eta_t(:,sv_z) * eta_p(:,sv_p)
        ELSEWHERE
          do_calc_t(:,sv_t) = .false.
          eta_zxp(:,sv_t) = 0.0_rp
        ENDWHERE
        WHERE(not_zero_p(:,sv_p) .AND. dhidtlm(inds(:),sv_p,sv_z) > 0.0_rp)
          do_calc_hyd(:,sv_t) = .true.
          dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_p,sv_z) * eta_p(:,sv_p)
        ELSEWHERE
          do_calc_hyd(:,sv_t) = .false.
          dhitdtlm(:,sv_t) = 0.0_rp
        ENDWHERE
        sv_t = sv_t + 1
      ENDDO
    ENDDO
    DEALLOCATE(inds,eta_t,not_zero_t,STAT=i)
  ENDIF
  DEALLOCATE(eta_p,cvf_ang_offset,cvf_z_grid,cvf_sign, &
             cvf_h_tan,cvf_inds,vert_inds,not_zero_p,STAT=i)
  END SUBROUTINE metrics
END MODULE metrics_m
@


1.1.2.2
log
@Updates changes to pointers etc.
@
text
@d1 1
d4 117
a120 172

module metrics_m
  use MLSCommon, only: RP, IP
  use Geometry, only: earthrada,earthradb,pi
  use get_eta_matrix_m, only: get_eta_sparse
  use Allocate_deallocate, only: Allocate_test, Deallocate_test

  use dump_0, only: dump
  implicit none
  private

  public :: metrics
  !---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter, private :: IdParm = &
    & "$Id: FullForwardModel_m.f90,v 1.5.2.45 2001/09/12 04:42:32 zvi Exp $"
  character (len=len(idParm)) :: Id = IdParm
  character (len=*), parameter, private :: ModuleName= &
    & "$RCSfile: FullForwardModel_m.f90,v $"
  !---------------------------------------------------------------------------

contains

  ! ------------------------------------------------ Metrics --------------

  subroutine metrics(phi_t,tan_inds,p_basis,z_grid,h_ref,t_ref,dhidzij, &
    beta,h_grid,p_grid,t_grid,dhitdzi,req,dhidtlm,ddhidhidtl0, &
    dhitdtlm,eta_zxp,tan_phi_h_grid,tan_phi_t_grid,dhtdzt,dhtdtl0, &
    ddhtdhtdtl0,neg_h_tan,z_basis,do_calc_t,do_calc_hyd)

    ! The main change in this routine is to interchange the z_coeffs and
    ! p_coeffs so as to make it consistent with the radiative transfer program.

    ! inputs:

    real(rp), intent(in) :: phi_t(:)   !orbit projected tangent geodetic angles
    integer(ip), intent(in) :: tan_inds(:)!tangent height indicies
    real(rp), intent(in) :: p_basis(:) !horizontal temperature representation
    !                                     basis
    real(rp), intent(in) :: z_grid(:)!pressures for which heights/temps are
    !                                 needed
    real(rp), intent(in) :: h_ref(:,:)! heights by t_phi_basis
    real(rp), intent(in) :: t_ref(:,:)! temperatures by t_phi_basis
    real(rp), intent(in) :: dhidzij(:,:)! vertical derivative by t_phi_basis
    real(rp), intent(in) :: beta       !orbital incline angle (Radians)
    ! outputs:
    real(rp), intent(out) :: h_grid(:)!computed heights
    real(rp), intent(out) :: p_grid(:)!computed phi's
    real(rp), intent(out) :: t_grid(:)!computed temperatures
    real(rp), intent(out) :: dhitdzi(:)!derivative of height wrt zeta
    !                              --maybe useful in future computations
    real(rp), intent(out) :: req       !equivalent elliptical earth radius

    ! Keywords:
    ! optional inputs
    real(rp), optional, intent(in) :: z_basis(:) ! vertical temperature basis
    real(rp), optional, intent(inout) :: dhidtlm(:,:,:) ! reference temperature
    !   derivatives. This gets adjusted so that at ref_h(1,@@tan phi)) is 0.0 for
    !   all temperature coefficients. This is height X phi_basis X zeta_basis
    real(rp), optional, intent(in) :: ddhidhidtl0(:,:,:)! second order reference
    !   temperature derivatives. This is (height, phi_basis, zeta_basis)
    real(rp), optional, intent(in) :: neg_h_tan(:)  !sub earth tangent heights
    ! optional outputs
    real(rp), optional, intent(out) :: tan_phi_h_grid(:)!heights along the
    !                                                      tangent
    real(rp), optional, intent(out) :: tan_phi_t_grid(:)!temperature along the
    !                                                      tangent
    real(rp), optional, intent(out) :: dhtdzt(:)     !height derivative wrt
    !                                                   pressure along the tangent
    real(rp), optional, intent(out) :: dhtdtl0(:,:)!First order derivative at
    !                                                 the tangent
    real(rp), optional, intent(out) :: ddhtdhtdtl0(:,:)!second order derivative
    !                            at the tangent only---used for antenna affects
    real(rp), optional, intent(out) :: dhitdtlm(:,:)
    !                             derivative of path position wrt temperature
    !                             statevector (z_basisXphi_basis)
    real(rp), optional, intent(out) :: eta_zxp(:,:) ! eta matrix for temperature.
    logical, optional, intent(out) :: do_calc_t(:,:) ! non zero locater for
    !                                       temperature bases computations.
    logical, optional, intent(out) :: do_calc_hyd(:,:) !non zero locator for
    !                                       hydrostatic calculations.

    ! NOTES
    ! p_basis and p_grid are phi's in offset degrees relative to phi_t, that
    ! is the phi_t p_basis or p_grid = 0.0 is phi_t.
    ! The phi basis is wholly independent of phi_t
    ! compute primary hydrostatic grid
    ! tangent phi index

    ! ===>> EVERYTHING comes out in cvf format <<===!

    ! Local variables.  CAN WE GET SOME COMMENTS FOR EACH OF THESE?
    integer :: P_COEFFS
    integer :: Z_COEFFS
    integer :: N_VERT
    integer :: N_TAN
    integer :: SS_HTAN
    integer :: SV_T
    integer :: SV_P
    integer :: SV_Z
    integer :: I
    integer :: J
    integer :: N_CVF
    integer :: ITER
    integer :: NO_OF_BAD_FITS
    integer :: ST_IND
    integer :: END_IND
    integer :: LOW_PT
    integer :: HI_PT

    real(rp) :: C
    real(rp) :: CP2
    real(rp) :: SP2
    real(rp) :: H_SURF

    logical, dimension(:), pointer :: MASK
    logical, dimension(:,:), pointer :: NOT_ZERO_P
    logical, dimension(:,:), pointer :: NOT_ZERO_T

    integer, dimension(:), pointer :: CVF_INDS
    integer, dimension(:), pointer :: PATH_INDS
    integer, dimension(:), pointer :: VERT_INDS
    integer, dimension(:), pointer :: NEAR_INDS
    integer, dimension(:), pointer :: PATH_IND
    integer, dimension(:), pointer :: JUNK
    integer, dimension(:), pointer :: FORCE_ZERO
    integer, dimension(:), pointer :: INDS
    integer, dimension(:), pointer :: TAN_IND

    real(rp), dimension(:), pointer :: ARG
    real(rp), dimension(:), pointer :: CVF_ANG_OFFSET
    real(rp), dimension(:), pointer :: CVF_H_TAN
    real(rp), dimension(:), pointer :: CVF_SIGN
    real(rp), dimension(:), pointer :: CVF_Z_GRID
    real(rp), dimension(:), pointer :: DHTDTL
    real(rp), dimension(:), pointer :: H_BETTER
    real(rp), dimension(:), pointer :: H_GRID_T
    real(rp), dimension(:), pointer :: H_GRID_TT
    real(rp), dimension(:), pointer :: OLD_HTS
    real(rp), dimension(:), pointer :: SOME_PHI

    real(rp), dimension(:,:), pointer :: ETA_P
    real(rp), dimension(:,:), pointer :: ETA_T
    real(rp), dimension(:,:), pointer :: H_TANS
    real(rp), dimension(:,:), pointer :: H_ZF
    real(rp), dimension(:,:), pointer :: M_Z_GRID
    real(rp), dimension(:,:), pointer :: PHI_TANS

    ! Begin program
    p_coeffs = size(p_basis)
    n_vert = size(z_grid)
    n_tan = size(tan_inds)

    c = earthrada*earthradb &
      / sqrt(earthrada**2*sin(beta)**2 &
      + earthradb**2*cos(beta)**2)

    nullify ( h_grid_t, eta_t, m_z_grid, h_tans, phi_tans )
    call Allocate_test ( h_grid_t, n_tan, 'h_grid_t', ModuleName )
    call Allocate_test ( eta_t, n_tan, p_coeffs, 'eta_t', ModuleName )
    call Allocate_test ( m_z_grid, 2*n_vert, n_tan, 'm_z_grid', ModuleName )
    call Allocate_test ( h_tans, 2*n_vert, n_tan, 'h_tans', ModuleName )
    call Allocate_test ( phi_tans, 2*n_vert, n_tan, 'phi_tans', ModuleName )

    ! compute the tangent height vertical
    call get_eta_sparse(p_basis,phi_t,eta_t)
    h_grid_t = sum(h_ref(tan_inds,:)*eta_t,dim=2)
    h_surf = sum(h_ref(1,:)*eta_t(1,:))

    ! compute equivalent earth radius at phi_t(1), nearest surface
    cp2 = cos(phi_t(1))**2
    sp2 = 1.0_rp - cp2
    req = 0.001_rp*sqrt((earthrada**4*sp2 + c**4*cp2)/(earthrada**2*cp2 &
d122 157
d280 5
a284 89
    ! now for the path quantities, for simplicity, we are going to set the
    ! surface reference at the inputted z_grid(1) and adjust the req and the
    ! h_grid_t relative to this
    req = req + h_surf

    ! adjust h_ref accordingly
    h_grid_t = h_grid_t - h_surf
    if(present(tan_phi_h_grid)) tan_phi_h_grid = h_grid_t
    if(present(tan_phi_t_grid)) &
      tan_phi_t_grid = sum(t_ref(tan_inds,:)*eta_t,dim=2)
    if(present(dhtdzt)) dhtdzt = sum(dhidzij(tan_inds,:)*eta_t,dim=2)

    ! compute tangent temperature derivative
    if (present(dhidtlm)) then
      z_coeffs = size(z_basis)
      nullify ( dhtdtl )
      call Allocate_test ( dhtdtl, z_coeffs, 'dhtdtl', ModuleName )
      dhtdtl = sum(reshape(dhidtlm(1,:,:),(/p_coeffs,z_coeffs/)) &
        * spread(reshape(eta_t(1,:),(/p_coeffs/)),2,z_coeffs),dim=1)

      ! adjust the 2d hydrostatic relative to the surface
      dhidtlm = dhidtlm - spread(spread(dhtdtl,1,n_vert),2,p_coeffs)
      if(present(dhtdtl0)) dhtdtl0 = sum(dhidtlm(tan_inds,:,:) &
        * spread(eta_t,3,z_coeffs),dim=2)
      if(present(ddhtdhtdtl0)) ddhtdhtdtl0 = &
        sum(ddhidhidtl0(tan_inds,:,:) * spread(eta_t,3,z_coeffs),dim=2)
      call Deallocate_test ( dhtdtl, 'dhtdtl', ModuleName )
    endif

    call Deallocate_test ( eta_t, 'eta_t', ModuleName )

    ss_htan = 0
    if(present(neg_h_tan)) then
      ss_htan = size(neg_h_tan)
      if(present(tan_phi_h_grid)) tan_phi_h_grid(1:ss_htan)=neg_h_tan-h_surf
    endif

    ! construct some basic matricies
    h_tans = spread(h_grid_t,1,2*n_vert)
    phi_tans = spread(phi_t,1,2*n_vert)

    nullify ( eta_t, h_grid_tt )
    call Allocate_test ( eta_t, n_vert, max (1,n_tan-ss_htan), 'n_vert', ModuleName )
    call Allocate_test ( h_grid_tt, n_vert, 'h_grid_tt', ModuleName )

    call get_eta_sparse(z_grid(tan_inds(min(n_tan,ss_htan+1):n_tan)),z_grid, &
      eta_t)
    h_grid_tt = matmul(eta_t,h_grid_t(min(n_tan,ss_htan+1):n_tan))

    ! basic pressure grid
    m_z_grid = spread(z_grid((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)),2,n_tan)

    ! determine condensed vector format so we don't mess with a bunch
    ! of zeros
    call Deallocate_test ( h_grid_t, 'h_grid_t', ModuleName )
    call Deallocate_test ( eta_t, 'eta_t', ModuleName )

    n_cvf = 2*sum(n_vert + 1 - tan_inds)

    nullify ( old_hts, cvf_h_tan, cvf_z_grid, cvf_ang_offset, cvf_sign )
    nullify ( h_zf, path_inds, vert_inds, near_inds, cvf_inds )

    call Allocate_test ( old_hts, n_cvf, 'old_hts', ModuleName )
    call Allocate_test ( cvf_h_tan, n_cvf, 'cvf_h_tan', ModuleName )
    call Allocate_test ( cvf_z_grid, n_cvf, 'cvf_z_grid', ModuleName )
    call Allocate_test ( cvf_ang_offset, n_cvf, 'cvf_ang_offset', ModuleName )
    call Allocate_test ( cvf_sign, n_cvf, 'cvf_sign', ModuleName )
    call Allocate_test ( h_zf, n_cvf, p_coeffs, 'h_zf', ModuleName )
    call Allocate_test ( path_inds, n_cvf, 'path_inds', ModuleName )
    call Allocate_test ( vert_inds, n_cvf, 'vert_inds', ModuleName )
    call Allocate_test ( near_inds, n_cvf/2, 'near_inds', ModuleName )
    call Allocate_test ( cvf_inds, n_cvf, 'cvf_inds', ModuleName )

    cvf_inds = pack((/(i,i=1,2*n_vert*n_tan)/), &
      reshape(spread((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/),2,n_tan), &
      (/2*n_vert*n_tan/)) &
      - reshape(spread(tan_inds,1,2*n_vert),(/2*n_vert*n_tan/)) >= 0)

    ! sign of phi matrix
    cvf_sign = (-1.0_rp)**((modulo(cvf_inds-1,2*n_vert)/n_vert)+1)

    ! Apparently you can't sequentially access indicies in a multirank array
    ! in f90 like you can in idl which is a major inconvenience
    call Allocate_test ( mask, 1, 2*n_vert*n_tan, 'mask', ModuleName )
    mask = .false.
    mask(cvf_inds) = .true.
    cvf_ang_offset = pack(phi_tans,reshape(mask,(/2*n_vert,n_tan/)))

    ! compute phi_s - phi_t
d286 1
a286 1
    do i = 1 , ss_htan
d288 1
a288 2
        -2.0_rp*acos((req + neg_h_tan(i)) / req)
      h_tans(:,i) = neg_h_tan(i)
d290 45
a334 139
    end do
    h_grid = pack(spread(h_grid_tt((/(i,i=n_vert,1,-1),(i,i=1,n_vert)/)), &
      2,n_tan),reshape(mask,(/2*n_vert,n_tan/)))
    cvf_h_tan = pack(h_tans,reshape(mask,(/2*n_vert,n_tan/)))
    cvf_z_grid = pack(m_z_grid,reshape(mask,(/2*n_vert,n_tan/)))
    call Deallocate_test ( m_z_grid, 'm_z_grid', ModuleName )
    call Deallocate_test ( h_tans, 'h_tans', ModuleName )
    call Deallocate_test ( phi_tans, 'phi_tans', ModuleName )
    call Deallocate_test ( h_grid_tt, 'h_grid_tt', ModuleName )
    call Deallocate_test ( mask, 'mask', ModuleName )

    ! These are the tangent indicies on a cvf array
    if(n_tan > ss_htan) then
      ! some tangents above the earth surface
      call Allocate_test ( force_zero, 2*(n_tan-ss_htan), 'force_zero', ModuleName )
      force_zero(1) = n_vert*(2*ss_htan + 1) - tan_inds(1+ss_htan) + 1
      force_zero(2) = force_zero(1) + 1
      j = 3
      do i = 2,n_tan - ss_htan
        force_zero(j) = force_zero(j-2)+2*n_vert &
          - tan_inds(ss_htan+i-1)-tan_inds(ss_htan+i)+2
        force_zero(j+1) = force_zero(j)+1
        j = j + 2
      end do
    endif

    ! estimate the phi's using the tangent heights as a first guess
    old_hts = h_grid
    p_grid = cvf_ang_offset + cvf_sign &
      * acos((req + cvf_h_tan)/(req + old_hts))

    ! force the del phi at the tangent to be zero
    if(n_tan > ss_htan) p_grid(force_zero) = cvf_ang_offset(force_zero)

    ! estimate some new heights
    ! This is going to have some small surface errors away
    ! from the tangent but we will ignore this issue for now.
    ! the following lines replace an extremely sparse matrix
    ! multiplication with a less memory intensive alternative
    ! and probably faster alternative
    ! convert the cvf indicies into path indicies

    path_inds = modulo((cvf_inds - 1),2*n_vert) + 1
    vert_inds = path_inds - n_vert
    near_inds = pack((/(i,i=1,n_cvf)/),path_inds <= n_vert)
    vert_inds(near_inds) = n_vert - path_inds(near_inds) + 1

    ! h_ref with surface adjustment
    h_zf = h_ref(vert_inds,:) - h_surf

    ! now these parts will change with iteration therefore these steps
    ! get repeated
    nullify ( mask, eta_p )
    call Allocate_test ( mask, n_cvf, 'mask', ModuleName )
    call Allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )

    call get_eta_sparse(p_basis,p_grid,eta_p)
    h_grid = sum(h_zf * eta_p,dim=2)
    call Deallocate_test( eta_p, 'eta_p', ModuleName )

    mask = abs(old_hts-h_grid) > 0.01_rp
    no_of_bad_fits = count(mask)

    call Allocate_Test (junk , no_of_bad_fits, 'junk', ModuleName )
    junk = pack((/(i,i=1,n_cvf)/),mask)
    where(h_grid < cvf_h_tan) 
      h_grid = cvf_h_tan
    endwhere
    iter = 0

    ! this construct is considered more desireable than a do while
    ! according to the fortran explained book
    do
      if (no_of_bad_fits == 0 .or. iter == 20) exit
      old_hts = h_grid

      ! recompute phi_s - phi_t because we have to iterate on phi_s - phi_t
      j = n_vert
      do i = 1 , ss_htan
        cvf_ang_offset(j+1:j+n_vert) = phi_t(i) &
          -2.0_rp*acos((req + neg_h_tan(i)) / (req + h_grid(j)))
        j = j + n_vert + n_vert
      end do

      nullify ( arg, some_phi, h_better, eta_p )
      call Allocate_test ( arg, no_of_bad_fits, 'arg', ModuleName )
      call Allocate_test ( some_phi, no_of_bad_fits, 'some_phi', ModuleName )
      call Allocate_test ( h_better, no_of_bad_fits, 'h_better', ModuleName )
      call Allocate_test ( eta_p, no_of_bad_fits, p_coeffs, 'eta_p', ModuleName )

      arg = (req + cvf_h_tan(junk))/ (req + old_hts(junk))
      some_phi = cvf_ang_offset(junk) + cvf_sign(junk) * acos(arg)
      call get_eta_sparse(p_basis,some_phi,eta_p)
      h_better = sum(h_zf(junk,:) * eta_p,dim=2)
      h_better = max ( cvf_h_tan(junk), h_better )
      !       where (h_better < cvf_h_tan(junk) )
      !         h_better = cvf_h_tan(junk)
      !       endwhere
      h_grid(junk) = h_better
      call Deallocate_test ( junk, 'junk', ModuleName )
      call Deallocate_test ( arg, 'arg', ModuleName )
      call Deallocate_test ( some_phi, 'some_phi', ModuleName )
      call Deallocate_test ( eta_p, 'eta_p', ModuleName )

      mask = abs(old_hts-h_grid) > 0.01_rp
      no_of_bad_fits = count(mask)

      nullify ( junk )
      call Allocate_test ( junk, no_of_bad_fits, 'junk', ModuleName )
      junk = pack((/(i,i=1,n_cvf)/),mask)
      iter = iter + 1
    end do

    call deallocate_test ( mask, 'mask', ModuleName )

    if (no_of_bad_fits > 0) then
      print *,'Warning: full convergence not acheived on:'
      print *,'implementing an improved approximation patch'
      print *,'path index, tangent index, error'

      ! we are going to assume that the tangent value is good
      ! The following is an F90 specific design which is quite different
      ! from the IDL code
      
      call Allocate_test ( path_ind, no_of_bad_fits, 'path_ind', ModuleName )
      call Allocate_test ( tan_ind, no_of_bad_fits, 'tan_ind', ModuleName )
      path_ind = modulo(cvf_inds(junk)-1,2*n_vert) + 1
      tan_ind = 1 + (cvf_inds(junk)-1) / (2*n_vert)
      st_ind = 1
      end_ind = 1
      do i = 1 , no_of_bad_fits
        print '(i5,1x,i5,1x,f7.3)',path_ind(i),tan_ind(i), &
          old_hts(junk(i))-h_grid(junk(i))
      end do

      do
        if(end_ind > no_of_bad_fits) exit
        do
          if(tan_ind(end_ind) > tan_ind(st_ind)) exit
d336 100
a435 116
        end do
        end_ind = end_ind - 1

        ! find which side of the tangent we are on
        if (path_ind(st_ind) < n_vert + 1) then
          ! this is the near observer side
          low_pt = junk(end_ind) + 1
          hi_pt  = junk(st_ind) - 1
        else
          ! this is the far observer side
          low_pt = junk(st_ind) - 1
          hi_pt  = junk(end_ind) + 1
        end if

        ! Correct
        h_grid(junk(st_ind):junk(end_ind)) = h_grid(low_pt) &
          + (h_grid(hi_pt) - h_grid(low_pt)) &
          * (cvf_z_grid(junk(st_ind):junk(end_ind)) - cvf_z_grid(low_pt)) &
          / (cvf_z_grid(hi_pt) - cvf_z_grid(low_pt))
        st_ind = end_ind + 1
        end_ind = st_ind

      end do
      print *,'completed re-estimation of bad points'
      call Deallocate_test ( path_ind, 'path_ind', ModuleName )
      call Deallocate_test ( tan_ind, 'tan_ind', ModuleName )
    endif

    ! deallocate the loop iteration stuff
    call Deallocate_test ( junk, 'junk', ModuleName )
    call Deallocate_test ( old_hts, 'old_hts', ModuleName )
    call Deallocate_test ( h_zf, 'h_zf', ModuleName )
    call Deallocate_test ( path_inds, 'path_inds', ModuleName )
    call Deallocate_test ( near_inds, 'near_inds', ModuleName )
    
    nullify ( not_zero_p )
    call Allocate_test ( not_zero_p, n_cvf, p_coeffs, 'not_zero_p', ModuleName )

    ! compute final set of angles
    p_grid = cvf_ang_offset + cvf_sign  &
      * acos((req + cvf_h_tan)/(req + h_grid))
    if(n_tan > ss_htan) then
      p_grid(force_zero) = cvf_ang_offset(force_zero)
      call Dellocate_test ( force_zero, 'force_zero', ModuleName )
      deallocate(force_zero,STAT=i)
    endif

    ! now compute the temperature grid
    nullify ( eta_p )
    call Allocate_test ( eta_p, n_cvf, p_coeffs, 'ModuleName' )

    call get_eta_sparse(p_basis,p_grid,eta_p,NOT_ZERO = not_zero_p)
    t_grid = sum(t_ref(vert_inds,:) * eta_p,dim=2)

    ! compute the vertical derivative grid
    dhitdzi = sum(dhidzij(vert_inds,:) * eta_p,dim=2)

    ! compute the temperature derivative grid
    if (present(dhitdtlm)) then
      nullify ( inds, eta_t, not_zero_t )
      call Allocate_test ( inds, n_cvf, 'inds', ModuleName )
      call Allocate_test ( eta_t, n_cvf, z_coeffs, 'eta_t', ModuleName )
      call Allocate_test ( not_zero_t, n_cvf, z_coeffs, 'not_zero_t', ModuleName )

      ! desparate attempt to try something different
      inds = modulo(cvf_inds-1,2*n_vert) - n_vert
      where(inds >= 0) inds = inds + 1
      inds = abs(inds)
      ! compute the path temperature noting where the zeros are
      call get_eta_sparse(z_basis,cvf_z_grid,eta_t,NOT_ZERO = not_zero_t)
      sv_t = 1
      do sv_p = 1 , p_coeffs
        do sv_z = 1 , z_coeffs
          where(not_zero_p(:,sv_p) .and. not_zero_t(:,sv_z))
            do_calc_t(:,sv_t) = .true.
            eta_zxp(:,sv_t) = eta_t(:,sv_z) * eta_p(:,sv_p)
          elsewhere
            do_calc_t(:,sv_t) = .false.
            eta_zxp(:,sv_t) = 0.0_rp
          endwhere
          !            print*,'sv_p, sv_z', sv_p, sv_z
          !             call dump (not_zero_p(:,sv_p), 'not_zero', clean=.true. )
          !             call dump (inds, 'inds', clean=.true.)
          !             call dump (dhidtlm(inds(:),sv_p,sv_z),'dhidtlm',clean=.true.)
          !             call dump (eta_p(:,sv_p),'eta_p',clean=.true.)
          !        if ( (calledtimes==2).and. (sv_z == 2) ) stop
          where(not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_p,sv_z) > 0.0_rp)
            do_calc_hyd(:,sv_t) = .true.
            dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_p,sv_z) * eta_p(:,sv_p)
          elsewhere
            do_calc_hyd(:,sv_t) = .false.
            dhitdtlm(:,sv_t) = 0.0_rp
          endwhere
          !            print*,'Got past the where'
          sv_t = sv_t + 1
        enddo
      enddo
      call Deallocate_test ( inds, 'inds', ModuleName )
      call Deallocate_test ( eta_t, 'eta_t', ModuleName )
      call Deallocate_test ( not_zero_t, 'not_zero_t', ModuleName )
    endif
    
    call Deallocate_test ( eta_p, 'eta_p', ModuleName )
    call Deallocate_test ( cvf_ang_offset, 'cvf_ang_offset', ModuleName )
    call Deallocate_test ( cvf_z_grid, 'cvf_z_grid', ModuleName )
    call Deallocate_test ( cvf_sign, 'cvf_sign', ModuleName )
    call Deallocate_test ( cvf_h_tan, 'cvf_h_tan', ModuleName )
    call Deallocate_test ( cvf_inds, 'cvf_inds', ModuleName )
    call Deallocate_test ( vert_inds, 'vert_inds', ModuleName )
    call Deallocate_test ( not_zero_p, 'not_zero_p', ModuleName )

  end subroutine metrics
end module metrics_m


! $Log$
@


1.1.2.3
log
@Bug fix.
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.2 2001/09/12 21:30:04 livesey Exp $"
d20 1
a20 1
    & "$RCSfile: metrics_m.f90,v $"
d260 1
a260 1
    call Allocate_test ( mask, 2*n_vert*n_tan, 'mask', ModuleName )
d461 1
a461 1
    call Allocate_test ( eta_p, n_cvf, p_coeffs, 'eta_p', ModuleName )
d527 1
a527 4
! $Log: metrics_m.f90,v $
! Revision 1.1.2.2  2001/09/12 21:30:04  livesey
! Updates changes to pointers etc.
!
@


1.1.2.4
log
@More bug fixes
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.3 2001/09/12 21:36:51 livesey Exp $"
a259 1
    nullify ( mask )
a285 1
      nullify ( force_zero )
d335 1
a335 2
    nullify ( junk )
    call Allocate_Test ( junk , no_of_bad_fits, 'junk', ModuleName )
a395 1
      nullify ( path_ind, tan_ind )
d455 1
a455 1
      call Deallocate_test ( force_zero, 'force_zero', ModuleName )
a527 3
! Revision 1.1.2.3  2001/09/12 21:36:51  livesey
! Bug fix.
!
@


1.1.2.5
log
@Interim still broken version
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.4 2001/09/12 21:47:50 livesey Exp $"
d502 7
a508 11

          ! Make this a do loop for the moment.
          do i = 1, n_cvf
            if (not_zero_p(i,sv_p) .and. dhidtlm(inds(i),sv_p,sv_z) > 0.0_rp) then
              do_calc_hyd(i,sv_t) = .true.
              dhitdtlm(i,sv_t) = dhidtlm(inds(i),sv_p,sv_z) * eta_p(i,sv_p)
            else
              do_calc_hyd(i,sv_t) = .false.
              dhitdtlm(i,sv_t) = 0.0_rp
            endif
          end do
a531 3
! Revision 1.1.2.4  2001/09/12 21:47:50  livesey
! More bug fixes
!
@


1.1.2.6
log
@A version that seems to work
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.5 2001/09/12 22:04:07 livesey Exp $"
a22 2
  integer, save :: CALLEDTIMES = 0

a150 2

    calledTimes=calledTimes + 1
d489 1
a489 1
          where (not_zero_p(:,sv_p) .and. not_zero_t(:,sv_z))
d496 18
a513 8
          
          where (not_zero_p(:,sv_p) .and. dhidtlm(inds(:),sv_p,sv_z) > 0.0_rp)
            do_calc_hyd(:,sv_t) = .true.
            dhitdtlm(:,sv_t) = dhidtlm(inds(:),sv_p,sv_z) * eta_p(:,sv_p)
          elsewhere
            do_calc_hyd(:,sv_t) = .false.
            dhitdtlm(:,sv_t) = 0.0_rp
          endwhere
d530 1
a535 3
! Revision 1.1.2.5  2001/09/12 22:04:07  livesey
! Interim still broken version
!
@


1.1.2.7
log
@Fixed memory leak
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.6 2001/09/12 22:45:54 livesey Exp $"
a378 1
      call Deallocate_test ( h_better, 'h_better', ModuleName )
d386 1
a386 1
      call Deallocate_test ( junk, 'junk', ModuleName )
a528 3
! Revision 1.1.2.6  2001/09/12 22:45:54  livesey
! A version that seems to work
!
@


1.1.2.8
log
@fixing allocation bug
@
text
@d17 1
a17 1
    & "$Id: metrics_m.f90,v 1.1.2.7 2001/09/13 00:42:18 livesey Exp $"
d465 1
a529 3
! Revision 1.1.2.7  2001/09/13 00:42:18  livesey
! Fixed memory leak
!
@


