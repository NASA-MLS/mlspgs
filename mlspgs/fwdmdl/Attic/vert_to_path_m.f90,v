head	1.18;
access;
symbols
	newfwm-sep01:1.17.0.2
	V0-7:1.17
	V0-5-Level2:1.14
	V0-5-SIPS:1.13;
locks; strict;
comment	@# @;


1.18
date	2001.09.17.20.26.28;	author livesey;	state dead;
branches;
next	1.17;

1.17
date	2001.06.21.13.07.09;	author zvi;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.06.07.23.39.32;	author pwagner;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.21.22.08.35;	author zvi;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.23.21.43.28;	author zvi;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.13.03.34.46;	author zvi;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.13.02.00.25;	author vsnyder;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.01.44.36;	author vsnyder;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.13.01.13.59;	author vsnyder;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.13.00.27.35;	author vsnyder;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.12.21.41.24;	author livesey;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.31.23.40.56;	author zvi;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.30.20.28.21;	author zvi;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.26.17.56.14;	author zvi;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.20.11.03.16;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.00.40.32;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.23.07.32;	author zvi;	state Exp;
branches;
next	;

1.17.2.1
date	2001.09.10.10.01.11;	author zvi;	state dead;
branches;
next	;


desc
@@


1.18
log
@New forward model
@
text
@! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module VERT_TO_PATH_M
  use Allocate_Deallocate, only: Allocate_test, Deallocate_Test
  use MLSCommon, only: I4, R4, R8
  use I_HUNT_M, only: HUNT
  use ELLIPSE_SW_M, only: H_TO_S_PHI
  use D_GET_ONE_ETA_M, only: GET_ONE_ETA
  use EARTH_INTERSECTION_M, only: EARTH_INTERSECTION
  use ELLIPSE_M, only: ELLIPSE

  Implicit NONE
  private
  public :: Vert_To_Path

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: vert_to_path_m.f90,v 1.17 2001/06/21 13:07:09 zvi Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName= &
    & "$RCSfile: vert_to_path_m.f90,v $"
!---------------------------------------------------------------------------
contains
!----------------------------------------------------------------------
!    This subroutine computes all the (z,t,h,phi,dh_dz,dh_dt) along a
! GIVEN ray path, which are tanget dependent.
!    The grid points are the Gauss-Legendre points, i.e. there are: gl_count
!  (2*(Ng+1)*N_lvls) points per array.

! *** NOTE: This routine is using The Equivalent Circle concept

  subroutine Vert_To_Path ( Elvar, N_lvls, Ng, Ngt, gl_count, WinSize, &
    &  MidWin, No_t, Htan, Z_glgrid, T_glgrid, H_glgrid, Dhdz_glgrid, &
    &  T_phi_basis, Z_path, H_path, T_path, Phi_path, Dhdz_path, Phi_eta, &
    &  Brkpt, Totnp, Ier )

    !  ===============================================================
    !  Declaration of variables for sub-program: vert_to_path
    !  ===============================================================
    !  ---------------------------
    !  calling sequence variables:
    !  ---------------------------
    integer, intent(in) :: N_lvls, Ng, gl_count, WinSize, MidWin, No_t, Ngt

    integer, intent(out) :: Totnp, Brkpt, Ier

    type(ellipse), intent(in out) :: Elvar

    real(r8), intent(out) :: h_path(:), z_path(:), t_path(:), phi_path(:), &
                             dhdz_path(:), phi_eta(:,:)

    real(r8), intent(in) :: htan, z_glgrid(:)
    real(r8), intent(in) :: h_glgrid(:,:), t_glgrid(:,:), t_phi_basis(:), &
                            dhdz_glgrid(:,:)

    !  ----------------
    !  Local variables:
    !  ----------------

    integer, dimension(1) :: brk_pt            ! Result of minloc
    integer :: i, j, k, l, m, n, n_d, npp, ibrk, Ngp1, iter

    real(r8) :: h, s, r, dz, rs, phi, rss, dhdz

    integer, pointer, dimension(:) :: cndx=>NULL()
    integer, pointer, dimension(:) :: vtp_ndx=>NULL()

    real(r8), pointer, dimension(:) :: dum_z=>NULL(), dum_h=>NULL(),&
                                       dum_phi=>NULL(), prev_h=>NULL()

    real(r8), pointer, dimension(:,:) :: h_a=>NULL()

    ! Allocate enough space for the various (temporary) arrys we are going
    ! to use...

    Ier = 0
    Ngp1 = Ng + 1

!?? print*,'Ngt is:',ngt
    call Allocate_test ( cndx, ngt, 'cndx', ModuleName )
    call Allocate_test ( vtp_ndx, ngt, 'vtp_ndx', ModuleName )
    call Allocate_test ( dum_z, ngt, 'dum_z', ModuleName )
    call Allocate_test ( dum_h, ngt, 'dum_h', ModuleName )
    call Allocate_test ( prev_h, ngt, 'prev_h', ModuleName )
    call Allocate_test ( dum_phi, ngt, 'dum_phi', ModuleName )
    call Allocate_test ( h_a, ngt, WinSize, 'h_a', ModuleName )
!?? print*,'WinSize is:',WinSize

!   Initialize all arrays:

    n_d = 0
    cndx = 0
    vtp_ndx = 0

    h_a = 0.0
    dum_z = 0.0
    dum_h = 0.0
    dum_phi = 0.0
    phi_eta = 0.0

    r = -999.99
    dz = r / 57.2958
    z_path = r
    h_path = r
    t_path = r
    phi_path = dz
    dhdz_path = 0.0

!   Define the various ELLIPSE variables needed for computations:

    elvar%ht = htan
    elvar%earthx = (htan < -0.01)

    if ( htan < -0.01 ) then
      elvar%rr = (elvar%roc + elvar%ht) / elvar%roc
      call earth_intersection ( elvar, rs )
    else
      elvar%rr = 0.0D0
      elvar%phi_s = elvar%phi_tan
      elvar%nphi_s = elvar%nphi_tan
    end if

!   Define the index points of the tangent locations:

    k = 2 * N_lvls

!   Store the initial guess heights in dum_h. This estimate is the h_glgrid
!   at the "Center Phi", Also compute the Path zeta on the GL grid:

    npp = 0
    l = gl_count + 1

    do
      do n = 1, Ngp1
        l = l - 1
        npp = npp + 1
        vtp_ndx(npp) = l
        dum_z(npp) = z_glgrid(l)
        dum_h(npp) = h_glgrid(l,MidWin)
      end do
      h = h_glgrid(l-1,MidWin)
      if ( abs(h-htan) < 0.001  .OR. l-Ngp1 < 1) exit
    end do

    l = l - 1
    npp = npp + 1
    vtp_ndx(npp) = l
    dum_z(npp) = z_glgrid(l)
    dum_h(npp) = h_glgrid(l,MidWin)

    l = l - 1
    ibrk = npp + 1

    do
      do n = 1, Ngp1
        l = l + 1
        npp = npp + 1
        vtp_ndx(npp) = l
        dum_z(npp) = z_glgrid(l)
        dum_h(npp) = h_glgrid(l,MidWin)
      end do
      if ( l+Ngp1 > gl_count) EXIT
    end do

    l = l + 1
    npp = npp + 1
    vtp_ndx(npp) = l
    dum_z(npp) = z_glgrid(l)
    dum_h(npp) = h_glgrid(l,MidWin)

!  Cast the h_glgrid onto the path

    DO m = 1, WinSize
      h_a(1:npp,m) = h_glgrid((/(vtp_ndx(k),k=1,npp)/),m)
    END DO

    iter = 0

    DO

      iter = iter + 1

      if(iter == 1) then

        elvar%ps = -1.0D0     ! Right hand side ray
        DO i = 1, ibrk-1
          CALL H_TO_S_PHI(elvar,dum_h(i),s,dum_phi(i))
        END DO
        elvar%ps = 1.0D0     ! Left hand side ray
        DO i = ibrk, npp
          CALL H_TO_S_PHI(elvar,dum_h(i),s,dum_phi(i))
        END DO

      else

        DO j = 1, n_d
          i = cndx(j)
          elvar%ps = -1.0D0                  ! Right hand side ray
          IF(i >= ibrk) elvar%ps = 1.0D0     ! Left hand side ray
          CALL H_TO_S_PHI(elvar,dum_h(i),s,dum_phi(i))
        END DO

      endif

!  Compute the Phi_Eta matrix based on the "Path" Phi's

      DO i = 1, npp
        r = dum_phi(i)
        DO m = 1, WinSize
          CALL get_one_eta(r,t_phi_basis,WinSize,m,phi_eta(i,m))
        END DO
      END DO
!
!  Re-Compute the estimate H:
!
      prev_h = dum_h
      dum_h = SUM(h_a*phi_eta,dim=2)
!
! Define the indecies array for which the process did not converged ..
!
!   cndx(1:) = 0
!   cndx = PACK((/(i,i=1,ngt)/),(abs(dum_h-prev_h) > 0.01))
!   n_d = COUNT(cndx > 0)
!
      n_d = 0
      do i = 1, npp
        if(abs(dum_h(i)-prev_h(i)) > 0.01) then
          n_d = n_d + 1
          cndx(n_d) = i
        endif
      end do

! **** ITERATE as needed

      IF(n_d == 0 .OR. iter == 10) EXIT

    END DO           ! On iter loop

!   For indices that did not converge within 10 iterations, use linear
!   interpolation on H and then recompute Phi and Phi_Eta for those indecies.

    IF(n_d > 1) THEN
      k = MAX(1,cndx(1)-1)
      l = MIN(npp,cndx(n_d)+1)
      dz = dum_z(l) - dum_z(k)
      dhdz = (dum_h(l) - dum_h(k)) / dz
      dO i = 1, n_d
        j = cndx(i)
        elvar%ps = -1.0D0
        IF(j >= ibrk) elvar%ps = 1.0D0
        dz = dum_z(j) - dum_z(k)
        dum_h(j) = dum_h(k) + dhdz * dz
        CALL H_TO_S_PHI(elvar,dum_h(j),s,dum_phi(j))
        DO m = 1, WinSize
          call get_one_eta ( dum_phi(j), t_phi_basis, WinSize, m, &
                          &  phi_eta(j,m) )
        END DO
      END DO
    END IF

!   **** CONVERGED !!
!   Now - Compute the path Temperature and path dh_dz

!   First, compute the path Temperature:
!   Cast the t_glgrid onto the path

    DO m = 1, WinSize
      h_a(1:npp,m) = t_glgrid((/(vtp_ndx(k),k=1,npp)/),m)
    END DO
    t_path = SUM(h_a*phi_eta,dim=2)

    totnp = npp
    z_path(1:npp)   = dum_z(1:npp)
    h_path(1:npp)   = dum_h(1:npp)
    phi_path(1:npp) = dum_phi(1:npp)

! Now compute the break points for the tangent layer for this tanget height

    brk_pt = minloc(abs(h_path(1:)-htan))
    brkpt = brk_pt(1)
!
! Second, compute the path dh_dz:
! Cast the dhdz_glgrid onto the path

    DO m = 1, WinSize
      h_a(1:npp,m) = dhdz_glgrid((/(vtp_ndx(k),k=1,npp)/),m)
    END DO
    dhdz_path = SUM(h_a*phi_eta,dim=2)

    call deallocate_test ( h_a, 'h_a', ModuleName )
    call deallocate_test ( dum_phi, 'dump_phi', ModuleName )
    call deallocate_test ( dum_h, 'dum_h', ModuleName )
    call deallocate_test ( prev_h, 'prev_h', ModuleName )
    call deallocate_test ( dum_z, 'dum_z', ModuleName )
    call deallocate_test ( cndx, 'cndx', ModuleName )
    call deallocate_test ( vtp_ndx, 'vtp_ndx', ModuleName )

    Return

  end subroutine Vert_To_Path
end module Vert_To_Path_M
! $Log: vert_to_path_m.f90,v $
! Revision 1.17  2001/06/21 13:07:09  zvi
! Speed enhancement MAJOR update
!
! Revision 1.16  2001/06/07 23:39:32  pwagner
! Added Copyright statement
!
! Revision 1.15  2001/05/21 22:08:35  zvi
! A small modification in searching for tanget
!
! Revision 1.14  2001/04/23 21:43:28  zvi
! Introducing no_phi_t etc.
!
! Revision 1.13  2001/04/13 03:34:46  zvi
! Correcting minor error in allocation, cleaing up comments.
!
! Revision 1.12  2001/04/13 02:00:25  vsnyder
! Undo all of the lmin:lmax nonsense
!
! Revision 1.11  2001/04/13 01:44:36  vsnyder
! Work on moving window
!
! Revision 1.10  2001/04/13 01:13:59  vsnyder
! Use lmin:lmax for more dimensions
!
! Revision 1.9  2001/04/13 00:27:35  vsnyder
! Comment out some of Nathaniel's debugging print
!
! Revision 1.8  2001/04/12 21:41:24  livesey
! Changed allocatable to automatic then pointer.  Still fails on large chunks.
! Van will try it on LF95
!
! Revision 1.7  2001/03/31 23:40:56  zvi
! Eliminate l2pcdim (dimension parameters) move to allocatable ..
!
! Revision 1.6  2001/03/30 20:28:21  zvi
! General fix-up to get rid of COMMON BLOCK (ELLIPSE)
!
! Revision 1.5  2001/03/26 17:56:14  zvi
! New codes to deal with dh_dt_path issue.. now being computed on the fly
!
! Revision 1.4  2001/03/20 11:03:16  zvi
! Fixing code for "real" data run, increase dim. etc.
!
! Revision 1.3  2001/03/09 00:40:32  zvi
! Correcting an error in HUNT routine
!
! Revision 1.2  2001/01/31 01:08:48  zvi
! New version of forward model
!
! Revision 1.1  2000/06/21 21:56:18  zvi
! First version D.P.
!
! Revision 1.1 2000/06/09 00:08:14  Z.Shippony
! Initial conversion to Fortran 90
@


1.17
log
@Speed enhancement MAJOR update
@
text
@d19 1
a19 1
    & "$Id: vert_to_path_m.f90,v 1.16 2001/06/07 23:39:32 pwagner Exp $"
d304 3
@


1.17.2.1
log
@*** empty log message ***
@
text
@d19 1
a19 1
    & "$Id: vert_to_path_m.f90,v 1.17 2001/06/21 13:07:09 zvi Exp $"
a303 3
! Revision 1.17  2001/06/21 13:07:09  zvi
! Speed enhancement MAJOR update
!
@


1.16
log
@Added Copyright statement
@
text
@a6 1
  use D_LINTRP_M, only: LINTRP
d19 1
a19 1
    & "$Id: vert_to_path_m.f90,v 1.15 2001/05/21 22:08:35 zvi Exp $"
d61 2
a62 1
    integer :: i, j, k, l, m, n, n_d, npp, ibrk, Ngp1, no_iter
d64 1
a64 1
    real(r8) :: h, s, r, dz, rs, phi, rss, dhdz, prev_h
d67 1
d70 1
a70 1
                                       dum_phi=>NULL()
d82 1
d85 1
d92 1
d94 2
d133 1
a133 1
 
d138 1
d148 1
d159 1
d163 1
a163 1
      if ( l+Ngp1 > gl_count) exit
d168 1
d172 1
a172 1
!    Cast the h_glgrid onto the path (using liner interpolation)
d174 3
a176 3
    do m = 1, WinSize
      call lintrp (z_glgrid, dum_z, h_glgrid(1:,m), h_a(1:,m), gl_count, npp)
    end do
d178 1
a178 2
    n_d = ngt
    no_iter = 0
d180 1
a180 2
    do
      no_iter = no_iter + 1
d182 1
a182 2
!     Compute the Phi that goes with the Heights along the path:
!     Right hand side ray:
d184 1
a184 14
      l = -1
      elvar%ps = -1.0D0
      do i = 1, ibrk-1
        h = dum_h(i)
        phi = dum_phi(i)
        if ( n_d == ngt ) then
          call H_TO_S_PHI ( elvar, h, s, phi )
        else
          call hunt ( i, cndx, n_d, l, j )
          if ( cndx(l) == i .OR. cndx(j) == i) &
                  call H_TO_S_PHI ( elvar, h, s, phi )
        end if
        dum_phi(i) = phi
      end do
d186 8
a193 1
!     Left hand side ray:
d195 1
a195 14
      l = -1
      elvar%ps = 1.0D0
      do i = ibrk, npp
        h = dum_h(i)
        phi = dum_phi(i)
        if ( n_d == ngt ) then
          call H_TO_S_PHI ( elvar, h, s, phi )
        else
          call hunt ( i, cndx, n_d, l, j )
          if ( cndx(l) == i .OR. cndx(j) == i) &
                   call H_TO_S_PHI ( elvar, h, s, phi )
        end if
        dum_phi(i) = phi
      end do
d197 6
a202 1
!     Compute the Phi_Eta matrix based on the "Path" Phi's
d204 1
a204 6
      do i = 1, npp
        r = dum_phi(i)
        do m = 1, WinSize
          call get_one_eta ( r, t_phi_basis, WinSize, m, phi_eta(i,m) )
        end do
      end do
d206 1
a206 1
!     Re-Compute the estimate H:
d208 18
a226 1
      rss = 0.0D0
d228 1
a228 4
        prev_h = dum_h(i)
        dum_h(i) = SUM(h_a(i,:)*phi_eta(i,:))
        r = ABS(dum_h(i) - prev_h)
        if ( r > 0.01 ) then
d231 1
a231 2
          rss = rss + r * r
        end if
d234 3
a236 1
!   **** ITERATE
d238 1
a238 2
      if ( n_d <= 0 .OR. no_iter >= 10 ) exit
    end do
d243 1
a243 1
    if ( n_d > 1 ) then
d248 1
a248 1
      do i = 1, n_d
d251 1
d254 7
a260 9
        h = dum_h(j)
        if ( j >= ibrk) elvar%ps = 1.0D0
        call H_TO_S_PHI ( elvar, h, s, phi )
        dum_phi(j) = phi
        do m = 1, WinSize
          call get_one_eta ( dum_phi(j), t_phi_basis, WinSize, m, phi_eta(j,m) )
        end do
      end do
    end if
d263 1
a263 1
!   Now - Compute the path Temperature, dh_dz  and dH_dTlm
d266 1
a266 1
!   Cast the t_glgrid onto the path (using liner interpolation)
d268 4
a271 3
    do m = 1, WinSize
      call lintrp ( z_glgrid, dum_z, t_glgrid(1:,m), h_a(1:,m), gl_count, npp )
    end do
a272 2
    s = 1.0e10
    brkpt = -1
d274 16
a290 25
!    Also, compute the break points for the tangent layer for this tanget height

    do i = 1, npp
      t_path(i) = SUM(h_a(i,:)*phi_eta(i,:))
      z_path(i) = dum_z(i)
      h_path(i) = dum_h(i)
      phi_path(i) = dum_phi(i)
      r = abs(h_path(i)-htan)
      if ( r < s ) then
        s = r
        brkpt = i
      end if
    end do

!   Second, compute the path dh_dz:
!   Cast the dhdz_glgrid onto the path (using liner interpolation)

    do m = 1, WinSize
      call lintrp (z_glgrid,dum_z,dhdz_glgrid(1:,m),h_a(1:,m),gl_count,npp)
    end do

    do i = 1, npp
      dhdz_path(i) = SUM(h_a(i,:)*phi_eta(i,:))
    end do
 
d294 1
d297 1
d304 3
@


1.15
log
@A small modification in searching for tanget
@
text
@d1 3
d20 1
a20 1
    & "$Id: vert_to_path_m.f90,v 1.14 2001/04/23 21:43:28 zvi Exp $"
d311 3
@


1.14
log
@Introducing no_phi_t etc.
@
text
@d17 1
a17 1
    & "$Id: vert_to_path_m.f90,v 1.13 2001/04/13 03:34:46 zvi Exp $"
d133 1
a133 1
      if ( h <= htan  .OR. l-Ngp1 < 1) exit
d308 3
@


1.13
log
@Correcting minor error in allocation, cleaing up comments.
@
text
@d17 1
a17 1
    & "$Id: vert_to_path_m.f90,v 1.12 2001/04/13 02:00:25 vsnyder Exp $"
d31 4
a34 3
  subroutine Vert_To_Path ( Elvar, N_lvls, Ng, Ngt, gl_count, WinSize, No_t, &
    &  Htan, Z_glgrid, T_glgrid, H_glgrid, Dhdz_glgrid, T_phi_basis, Z_path, &
    &  H_path, T_path, Phi_path, Dhdz_path, Phi_eta, Brkpt, Totnp, Ier )
d42 1
a42 1
    integer, intent(in) :: N_lvls, Ng, gl_count, WinSize, No_t, Ngt
d59 1
a59 1
    integer :: i, j, k, l, m, n, jp, n_d, npp, ibrk, Ngp1, no_iter
d124 1
a124 2
    jp = (WinSize + 1) / 2

d130 1
a130 1
        dum_h(npp) = h_glgrid(l,jp)
d132 1
a132 1
      h = h_glgrid(l-1,jp)
d139 1
a139 1
    dum_h(npp) = h_glgrid(l,jp)
d149 1
a149 1
        dum_h(npp) = h_glgrid(l,jp)
d157 1
a157 1
    dum_h(npp) = h_glgrid(l,jp)
d308 3
@


1.12
log
@Undo all of the lmin:lmax nonsense
@
text
@d17 1
a17 1
    & "$Id: vert_to_path_m.f90,v 1.11 2001/04/13 01:44:36 vsnyder Exp $"
d31 1
a31 1
  subroutine Vert_To_Path ( Elvar, N_lvls, Ng, Ngt, Gl_count, No_phi_t, No_t, &
d41 1
a41 1
    integer, intent(in) :: N_lvls, Ng, Gl_count, No_phi_t, No_t, Ngt
d64 2
a65 1
    real(r8), pointer, dimension(:) :: dum_z=>NULL(), dum_h=>NULL(), dum_phi=>NULL()
d80 2
a81 18
    call Allocate_test ( h_a, ngt, no_phi_t, 'h_a', ModuleName )
!?? print*,'no_phi_t is:',no_phi_t

!     DEALLOCATE(cndx, dum_z, dum_h, dum_phi, STAT=i)
!      ALLOCATE(cndx(ngt), dum_z(ngt), dum_h(ngt), dum_phi(ngt), &
!     &         STAT = ier)
!      if ( ier /= 0 ) then
!        Ier = 1
!        Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
!        GOTO 99
!      end if
!     DEALLOCATE(h_a, STAT=i)
!      ALLOCATE(h_a(ngt,no_phi_t),STAT=ier)
!      if ( ier /= 0 ) then
!        Ier = 1
!        Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
!        GOTO 99
!      end if
d86 1
a89 1
    h_a = 0.0
d123 1
a123 1
    jp = (no_phi_t + 1) / 2
d161 2
a162 2
    do m = 1, no_phi_t
      call lintrp ( z_glgrid, dum_z, h_glgrid(1:,m), h_a(1:,m), gl_count, npp )
d210 2
a211 2
        do m = 1, no_phi_t
          call get_one_eta ( r, t_phi_basis, no_phi_t, m, phi_eta(i,m) )
d252 2
a253 2
        do m = 1, no_phi_t
          call get_one_eta ( dum_phi(j), t_phi_basis, no_phi_t, m, phi_eta(j,m) )
d264 1
a264 1
    do m = 1, no_phi_t
d289 2
a290 2
    do m = 1, no_phi_t
      call lintrp ( z_glgrid, dum_z, dhdz_glgrid(1:,m), h_a(1:,m), gl_count, npp )
a296 1
!?? print*,'Hello Im deallocating!'
d303 1
a303 2
!    99 DEALLOCATE(h_a, STAT=i)
!       DEALLOCATE(cndx, dum_z, dum_h, dum_phi, STAT=i)
a304 1
    return
d308 3
@


1.11
log
@Work on moving window
@
text
@a3 2
  use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Deallocate, &
    & MLSMSG_Error
d17 1
a17 1
    & "$Id: vert_to_path_m.f90,v 1.10 2001/04/13 01:13:59 vsnyder Exp $"
d48 1
a48 3
                             dhdz_path(:)

    real(r8), pointer :: phi_eta(:,:) ! Pointer, so we get bounds as well as shape
d58 1
a58 1
    integer :: i, j, k, l, lmax, lmin, m, n, jp, n_d, npp, ibrk, Ngp1, no_iter
a73 3
    lmin = lbound(phi_eta,2)
    lmax = ubound(phi_eta,2)

d79 2
a80 4
    allocate ( h_a(ngt,lmin:lmax), stat=i )
    if ( i /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'H_a' )
    print*,'no_phi_t is:',no_phi_t
d138 1
a138 1
    jp = (lmin + lmax) / 2
d176 1
a176 1
    do m = lmin, lmax
d225 1
a225 1
        do m = lmin, lmax
d267 1
a267 1
        do m = lmin, lmax
d279 1
a279 1
    do m = lmin, lmax
d304 1
a304 1
    do m = lmin, lmax
d326 3
@


1.10
log
@Use lmin:lmax for more dimensions
@
text
@d19 1
a19 1
    & "$Id: vert_to_path_m.f90,v 1.9 2001/04/13 00:27:35 vsnyder Exp $"
d50 3
a52 1
                             dhdz_path(:), phi_eta(:,:)
d335 3
@


1.9
log
@Comment out some of Nathaniel's debugging print
@
text
@d4 2
d19 1
a19 1
    & "$Id: vert_to_path_m.f90,v 1.8 2001/04/12 21:41:24 livesey Exp $"
d43 1
a43 1
    integer, intent(in) :: n_lvls,Ng,gl_count,no_phi_t,no_t,ngt
d45 1
a45 1
    integer, intent(out) :: totnp,brkpt,Ier
d47 1
a47 1
    type(ellipse), intent(in out) :: elvar
d60 1
a60 1
    integer :: i, j, k, l, m, n, jp, n_d, npp, ibrk, Ngp1, no_iter
d76 3
d84 3
a86 1
    call Allocate_test ( h_a,ngt,no_phi_t,'h_a',ModuleName )
d111 2
a112 4
    do j = 1, no_phi_t
      h_a(1:ngt,j) = 0.0
      phi_eta(1:ngt,j) = 0.0
    end do
d116 5
a120 5
    z_path(1:ngt) = r
    h_path(1:ngt) = r
    t_path(1:ngt) = r
    phi_path(1:ngt) = dz
    dhdz_path(1:ngt) = 0.0
d145 1
a145 1
    jp = (no_phi_t + 1) / 2
d183 1
a183 1
    do m = 1, no_phi_t
d232 1
a232 1
        do m = 1, no_phi_t
d274 1
a274 1
        do m = 1, no_phi_t
d286 1
a286 1
    do m = 1, no_phi_t
d311 1
a311 1
    do m = 1, no_phi_t
d320 1
a320 1
    call deallocate_test ( h_a,'h_a',ModuleName )
d333 3
@


1.8
log
@Changed allocatable to automatic then pointer.  Still fails on large chunks.
Van will try it on LF95
@
text
@d10 1
d12 3
d16 5
a20 4
  CHARACTER (LEN=256) :: Id = &
    "$Id: vert_to_path_m.f90,v 1.7 2001/03/31 23:40:56 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
    "$RCSfile: vert_to_path_m.f90,v $"
d31 50
a80 287
SUBROUTINE vert_to_path(elvar,n_lvls,Ng,ngt,gl_count,no_phi_t,no_t,htan,     &
           z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,t_phi_basis,z_path,  &
           h_path,t_path,phi_path,dhdz_path,phi_eta,brkpt,totnp,Ier)

!  ===============================================================
!  Declaration of variables for sub-program: vert_to_path
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer, INTENT(IN) :: n_lvls,Ng,gl_count,no_phi_t,no_t,ngt

Integer, INTENT(OUT) :: totnp,brkpt,Ier

Type(ELLIPSE), intent(in out) :: elvar

Real(r8), INTENT(OUT) :: h_path(:), z_path(:), t_path(:), phi_path(:), &
                         dhdz_path(:), phi_eta(:,:)

Real(r8), INTENT(IN) :: htan, z_glgrid(:)
Real(r8), INTENT(IN) :: h_glgrid(:,:), t_glgrid(:,:), t_phi_basis(:), &
                        dhdz_glgrid(:,:)

!  ----------------
!  Local variables:
!  ----------------

Integer :: i, j, k, l, m, n, jp, n_d, npp, ibrk, Ngp1, no_iter

Real(r8) :: h, s, r, dz, rs, phi, rss, dhdz, prev_h

Integer, pointer, dimension(:) :: cndx=>NULL()

Real(r8), pointer, dimension(:) :: dum_z=>NULL(), dum_h=>NULL(), dum_phi=>NULL()

Real(r8), pointer, dimension(:,:) :: h_a=>NULL()

! Allocate enough space for the various (temporary) arrys we are going
! to use...

  Ier = 0
  Ngp1 = Ng + 1

  print*,'Ngt is:',ngt
  call Allocate_test(cndx, ngt, 'cndx', ModuleName)
  call Allocate_test(dum_z, ngt, 'dum_z', ModuleName)
  call Allocate_test(dum_h, ngt, 'dum_h', ModuleName)
  call Allocate_test(dum_phi, ngt, 'dum_phi', ModuleName)
  call Allocate_test(h_a,ngt,no_phi_t,'h_a',ModuleName)
  print*,'no_phi_t is:',no_phi_t

!   DEALLOCATE(cndx, dum_z, dum_h, dum_phi, STAT=i)
!    ALLOCATE(cndx(ngt), dum_z(ngt), dum_h(ngt), dum_phi(ngt), &
!   &         STAT = ier)
!    IF(ier /= 0) THEN
!      Ier = 1
!      Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
!      GOTO 99
!    endif
!   DEALLOCATE(h_a, STAT=i)
!    ALLOCATE(h_a(ngt,no_phi_t),STAT=ier)
!    IF(ier /= 0) THEN
!      Ier = 1
!      Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
!      GOTO 99
!    endif

! Initialze all arrays:

  cndx = 0
  dum_z = 0.0
  dum_h = 0.0
  dum_phi = 0.0
  DO j = 1, no_phi_t
    h_a(1:ngt,j) = 0.0
    phi_eta(1:ngt,j) = 0.0
  END DO

  r = -999.99
  dz = r / 57.2958
  z_path(1:ngt) = r
  h_path(1:ngt) = r
  t_path(1:ngt) = r
  phi_path(1:ngt) = dz
  dhdz_path(1:ngt) = 0.0

! Define the various ELLIPSE variables needed for computations:

  elvar%ht = htan
  elvar%earthx = (htan < -0.01)

  IF(htan < -0.01) THEN
    elvar%rr = (elvar%roc + elvar%ht) / elvar%roc
    CALL earth_intersection(elvar,rs)
  ELSE
    elvar%rr = 0.0D0
    elvar%phi_s = elvar%phi_tan
    elvar%nphi_s = elvar%nphi_tan
  END IF

! Define the index points of the tangent locations:

  k = 2 * N_lvls

! Store the initial guess heights in dum_h. This estimate is the h_glgrid
! at the "Center Phi", Also compute the Path zeta on the GL grid:

  npp = 0
  l = gl_count + 1
  jp = (no_phi_t + 1) / 2

  DO
    DO n = 1, Ngp1
      l = l - 1
      npp = npp + 1
      dum_z(npp) = z_glgrid(l)
      dum_h(npp) = h_glgrid(l,jp)
    END DO
    h = h_glgrid(l-1,jp)
    if(h <= htan  .OR. l-Ngp1 < 1) EXIT
  END DO

  l = l - 1
  npp = npp + 1
  dum_z(npp) = z_glgrid(l)
  dum_h(npp) = h_glgrid(l,jp)

  l = l - 1
  ibrk = npp + 1

  DO
    DO n = 1, Ngp1
      l = l + 1
      npp = npp + 1
      dum_z(npp) = z_glgrid(l)
      dum_h(npp) = h_glgrid(l,jp)
    END DO
    IF(l+Ngp1 > gl_count) EXIT
  END DO

  l = l + 1
  npp = npp + 1
  dum_z(npp) = z_glgrid(l)
  dum_h(npp) = h_glgrid(l,jp)

!  Cast the h_glgrid onto the path (using liner interpolation)

  DO m = 1, no_phi_t
    CALL lintrp(z_glgrid,dum_z,h_glgrid(1:,m),h_a(1:,m),gl_count,npp)
  END DO

  n_d = ngt
  no_iter = 0

10 no_iter = no_iter + 1

!  Compute the Phi that goes with the Heights along the path:
!  Right hand side ray:

  l = -1
  elvar%ps = -1.0D0
  DO i = 1, ibrk-1
    h = dum_h(i)
    phi = dum_phi(i)
    IF(n_d == ngt) THEN
      CALL H_TO_S_PHI(elvar,h,s,phi)
    ELSE
      CALL hunt(i,cndx,n_d,l,j)
      IF(cndx(l) == i .OR. cndx(j) == i) &
              CALL H_TO_S_PHI(elvar,h,s,phi)
    END IF
    dum_phi(i) = phi
  END DO

!  Left hand side ray:

  l = -1
  elvar%ps = 1.0D0
  DO i = ibrk, npp
    h = dum_h(i)
    phi = dum_phi(i)
    IF(n_d == ngt) THEN
      CALL H_TO_S_PHI(elvar,h,s,phi)
    ELSE
      CALL hunt(i,cndx,n_d,l,j)
      IF(cndx(l) == i .OR. cndx(j) == i) &
               CALL H_TO_S_PHI(elvar,h,s,phi)
    END IF
    dum_phi(i) = phi
  END DO

!  Compute the Phi_Eta matrix based on the "Path" Phi's

  DO i = 1, npp
    r = dum_phi(i)
    DO m = 1, no_phi_t
      CALL get_one_eta(r,t_phi_basis,no_phi_t,m,phi_eta(i,m))
    END DO
  END DO

!  Re-Compute the estimate H:

  n_d = 0
  rss = 0.0D0
  DO i = 1, npp
    prev_h = dum_h(i)
    dum_h(i) = SUM(h_a(i,:)*phi_eta(i,:))
    r = ABS(dum_h(i) - prev_h)
    IF(r > 0.01) THEN
      n_d = n_d + 1
      cndx(n_d) = i
      rss = rss + r * r
    END IF
  END DO

! **** ITERATE

  IF(n_d > 0.AND.no_iter < 10) GO TO 10

! For indecies which did not converged within 10 iterations, use liner
! interpolation on H and then recompute Phi and Phi_Eta for those indecies.

  IF(n_d > 1) THEN
    k = MAX(1,cndx(1)-1)
    l = MIN(npp,cndx(n_d)+1)
    dz = dum_z(l) - dum_z(k)
    dhdz = (dum_h(l) - dum_h(k)) / dz
    DO i = 1, n_d
      j = cndx(i)
      elvar%ps = -1.0D0
      dz = dum_z(j) - dum_z(k)
      dum_h(j) = dum_h(k) + dhdz * dz
      h = dum_h(j)
      IF(j >= ibrk) elvar%ps = 1.0D0
      CALL H_TO_S_PHI(elvar,h,s,phi)
      dum_phi(j) = phi
      DO m = 1, no_phi_t
        CALL get_one_eta(dum_phi(j),t_phi_basis,no_phi_t,m, phi_eta(j,m))
      END DO
    END DO
  END IF

! **** CONVERGED !!
! Now - Compute the path Temperature, dh_dz  and dH_dTlm

! First, compute the path Temperature:
! Cast the t_glgrid onto the path (using liner interpolation)

  DO m = 1, no_phi_t
    CALL lintrp(z_glgrid,dum_z,t_glgrid(1:,m),h_a(1:,m),gl_count,npp)
  END DO

  s = 1.0e10
  brkpt = -1
  totnp = npp

!  Also, compute the break points for the tangent layer for this tanget height

  DO i = 1, npp
    t_path(i) = SUM(h_a(i,:)*phi_eta(i,:))
    z_path(i) = dum_z(i)
    h_path(i) = dum_h(i)
    phi_path(i) = dum_phi(i)
    r = abs(h_path(i)-htan)
    if(r < s) then
      s = r
      brkpt = i
    endif
  END DO

! Second, compute the path dh_dz:
! Cast the dhdz_glgrid onto the path (using liner interpolation)

  DO m = 1, no_phi_t
    CALL lintrp(z_glgrid,dum_z,dhdz_glgrid(1:,m),h_a(1:,m),gl_count,npp)
  END DO

  DO i = 1, npp
    dhdz_path(i) = SUM(h_a(i,:)*phi_eta(i,:))
  END DO
  
  print*,'Hello Im deallocating!'
  call deallocate_test(h_a,'h_a',ModuleName)
  call deallocate_test(dum_phi, 'dump_phi', ModuleName)
  call deallocate_test(dum_h, 'dum_h', ModuleName)
  call deallocate_test(dum_z, 'dum_z', ModuleName)
  call deallocate_test(cndx, 'cndx', ModuleName)
a81 1
!  99 DEALLOCATE(h_a, STAT=i)
d83 104
d188 139
a326 3
  RETURN
END SUBROUTINE vert_to_path
end module VERT_TO_PATH_M
d328 4
@


1.7
log
@Eliminate l2pcdim (dimension parameters) move to allocatable ..
@
text
@d2 1
d13 1
a13 1
    "$Id: vert_to_path_m.f90,v 1.6 2001/03/30 20:28:21 zvi Exp $"
d36 1
a36 1
Integer(i4), INTENT(IN) :: n_lvls,Ng,gl_count,no_phi_t,no_t,ngt
d38 1
a38 1
Integer(i4), INTENT(OUT) :: totnp,brkpt,Ier
d53 1
a53 1
Integer(i4) :: i, j, k, l, m, n, jp, n_d, npp, ibrk, Ngp1, no_iter
d57 1
a57 1
Integer(i4), ALLOCATABLE, DIMENSION(:) :: cndx
d59 1
a59 1
Real(r8), ALLOCATABLE, DIMENSION(:) :: dum_z, dum_h, dum_phi
d61 1
a61 1
Real(r8), ALLOCATABLE, DIMENSION(:,:) :: h_a
d69 23
a91 16
  DEALLOCATE(cndx, dum_z, dum_h, dum_phi, STAT=i)
  ALLOCATE(cndx(ngt), dum_z(ngt), dum_h(ngt), dum_phi(ngt), &
 &         STAT = ier)
  IF(ier /= 0) THEN
    Ier = 1
    Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
    GOTO 99
  endif

  DEALLOCATE(h_a, STAT=i)
  ALLOCATE(h_a(ngt,no_phi_t),STAT=ier)
  IF(ier /= 0) THEN
    Ier = 1
    Print *,'** Error: ALLOCATION error in VERT_TO_PATH routine ..'
    GOTO 99
  endif
d306 7
d314 2
a315 2
 99 DEALLOCATE(h_a, STAT=i)
    DEALLOCATE(cndx, dum_z, dum_h, dum_phi, STAT=i)
d321 3
@


1.6
log
@General fix-up to get rid of COMMON BLOCK (ELLIPSE)
@
text
@a1 1
  use L2PCDim, only: Nlvl, NSPS, N2LVL
d12 1
a12 1
    "$Id: vert_to_path_m.f90,v 1.5 2001/03/26 17:56:14 zvi Exp $"
d306 3
@


1.5
log
@New codes to deal with dh_dt_path issue.. now being computed on the fly
@
text
@d9 1
a9 2
  use ELLIPSE, only: A2, C2, C2OA2, CPT, SPT, CPS, SPS, CPTS, SPTS, HT, &
 &    HT2, RR, PHI_TAN, NPHI_TAN, PHI_S, NPHI_S, PS, ROC, XOC, YOC, EARTHX
d13 1
a13 1
    "$Id: vert_to_path_m.f90,v 1.4 2001/03/20 11:03:16 zvi Exp $"
d26 1
a26 1
SUBROUTINE vert_to_path(n_lvls,Ng,ngt,gl_count,no_phi_t,no_t,htan,     &
d40 2
d105 1
a105 1
! Define the various COMMON variables needed for computations:
d107 2
a108 2
  ht = htan
  earthx = (htan < -0.01)
d111 2
a112 2
    rr = (roc + ht) / roc
    CALL earth_intersection(rs)
d114 3
a116 3
    rr = 0.0D0
    phi_s = phi_tan
    nphi_s = nphi_tan
d179 1
a179 1
  ps = -1.0D0
d184 1
a184 1
      CALL H_TO_S_PHI(h,s,phi)
d187 2
a188 1
      IF(cndx(l) == i .OR. cndx(j) == i) CALL H_TO_S_PHI(h,s,phi)
d196 1
a196 1
  ps = 1.0D0
d201 1
a201 1
      CALL H_TO_S_PHI(h,s,phi)
d204 2
a205 1
      IF(cndx(l) == i .OR. cndx(j) == i) CALL H_TO_S_PHI(h,s,phi)
d248 1
a248 1
      ps = -1.0D0
d252 2
a253 2
      IF(j >= ibrk) ps = 1.0D0
      CALL H_TO_S_PHI(h,s,phi)
d307 3
@


1.4
log
@Fixing code for "real" data run, increase dim. etc.
@
text
@d14 1
a14 1
    "$Id: vert_to_path_m.f90,v 1.3 2001/03/09 00:40:32 zvi Exp $"
d27 3
a29 4
SUBROUTINE vert_to_path(n_lvls,Ng,ngt,gl_count,no_phi_t,no_t,    &
           htan,z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,            &
           dh_dt_glgrid,t_phi_basis,z_path,h_path,t_path,phi_path, &
           dhdz_path,dhdt_path,brkpt,totnp,Ier)
a40 2
Real(r4), INTENT(OUT) :: dhdt_path(:,:,:)

d42 1
a42 1
                         dhdz_path(:)
d46 1
a46 1
                        dhdz_glgrid(:,:), dh_dt_glgrid(:,:,:)
d54 1
a54 1
Real(r8) :: h, s, r, dz, rs, phi, rss, sum, dhdz, prev_h
d58 1
a58 1
Real(r8), ALLOCATABLE, DIMENSION(:) :: dum_z, dum_h, dum_t, dum_phi
d60 1
a60 1
Real(r8), ALLOCATABLE, DIMENSION(:,:) :: h_a, phi_eta
d68 2
a69 2
  DEALLOCATE(cndx, dum_z, dum_h, dum_t, dum_phi, STAT=i)
  ALLOCATE(cndx(ngt), dum_z(ngt), dum_h(ngt), dum_t(ngt), dum_phi(ngt), &
d77 2
a78 2
  DEALLOCATE(h_a, phi_eta, STAT=i)
  ALLOCATE(h_a(ngt,no_phi_t), phi_eta(ngt,no_phi_t), STAT = ier)
a89 1
  dum_t = 0.0
a101 1

a102 1
  dhdt_path(1:ngt,1:no_phi_t,1:no_t) = 0.0
a220 1
    sum = 0.0
d222 2
a223 5
    DO m = 1, no_phi_t
      sum = sum + h_a(i,m) * phi_eta(i,m)
    END DO
    dum_h(i) = sum
    r = ABS(sum - prev_h)
d275 1
a275 6
    sum = 0.0_r8
    DO m = 1, no_phi_t
      sum = sum + h_a(i,m) * phi_eta(i,m)
    END DO
    dum_t(i) = sum
    t_path(i) = sum
d294 1
a294 18
    sum = 0.0_r8
    DO m = 1, no_phi_t
      sum = sum + h_a(i,m) * phi_eta(i,m)
    END DO
    dhdz_path(i) = sum
  END DO

! Fourth: compute the path dH_dTlm:
! Cast the dh_dt_glgrid onto the path (using liner interpolation)

  DO j = 1, no_t
    DO m = 1, no_phi_t
      CALL lintrp(z_glgrid, dum_z, dh_dt_glgrid(1:,m,j), dum_h, &
     &            gl_count, npp)
      DO i = 1, npp
        dhdt_path(i,m,j) = dum_h(i) * phi_eta(i,m)
      END DO
    END DO
d297 2
a298 2
 99 DEALLOCATE(h_a, phi_eta, STAT=i)
    DEALLOCATE(cndx, dum_z, dum_h, dum_t, dum_phi, STAT=i)
d304 3
@


1.3
log
@Correcting an error in HUNT routine
@
text
@d14 1
a14 1
    "$Id: vert_to_path_m.f90,v 1.2 2001/01/31 01:08:48 zvi Exp $"
d47 3
a49 3
Real(r8), INTENT(IN) :: htan
Real(r8), INTENT(IN) :: z_glgrid(:), h_glgrid(:,:), t_glgrid(:,:), &
                     t_phi_basis(:), dhdz_glgrid(:,:), dh_dt_glgrid(:,:,:)
d336 3
@


1.2
log
@New version of forward model
@
text
@d14 1
a14 1
    "$Id: vert_to_path_m.f90,v 1.1 2000/06/21 21:56:18 zvi Exp $"
d199 1
d336 3
@


1.1
log
@New version
@
text
@a0 1
!
d27 1
a27 1
SUBROUTINE vert_to_path(n_lvls,ng,npath,gl_count,no_phi_t,no_t,    &
d30 1
a30 1
           dhdz_path,dh_dt_path,brkpt,totnp,rad_cur,phi_lat,Ier)
d38 1
a38 1
Integer(i4), INTENT(IN) :: n_lvls,ng,gl_count,no_phi_t,no_t,npath
d42 1
a42 1
Real(r4), INTENT(OUT) :: dh_dt_path(:,:,:)
d47 1
a47 1
Real(r8), INTENT(IN) :: rad_cur, phi_lat, htan
d55 1
a55 1
Integer(i4) :: i, j, k, l, m, n, jp, n_d, npp, kgp, ibrk, Ngp1, no_iter
a69 1
  kgp = N2lvl * Ngp1
d71 2
a72 1
  ALLOCATE(cndx(kgp), dum_z(kgp), dum_h(kgp), dum_t(kgp), dum_phi(kgp), &
d80 2
a81 1
  ALLOCATE(h_a(kgp,no_phi_t), phi_eta(kgp,no_phi_t), STAT = ier)
d96 2
a97 2
    h_a(1:kgp,j) = 0.0
    phi_eta(1:kgp,j) = 0.0
d102 4
a105 4
  z_path(1:Npath) = r
  h_path(1:Npath) = r
  t_path(1:Npath) = r
  phi_path(1:Npath) = dz
d107 2
a108 2
  dhdz_path(1:Npath) = 0.0
  dh_dt_path(1:Npath,1:no_phi_t,1:no_t) = 0.0
a112 2
  roc = rad_cur
  phi_tan = phi_lat
d175 1
a175 1
  n_d = kgp
d188 1
a188 1
    IF(n_d == kgp) THEN
d203 1
a203 1
    IF(n_d == kgp) THEN
d323 1
a323 1
        dh_dt_path(i,m,j) = dum_h(i) * phi_eta(i,m)
@

