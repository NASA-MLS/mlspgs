head	2.12;
access;
symbols
	mus-emls-1-70:2.11.0.8
	rel-1-0-englocks-work:2.11.0.6
	VUMLS1-00:2.11
	VPL1-00:2.11
	V4-22-NRT-08:2.11
	VAM1-00:2.11
	V4-21:2.11.0.4
	V4-13:2.11
	V4-12:2.11
	V4-11:2.11
	V4-10:2.11
	V3-43:2.11
	M4-00:2.11
	V3-41:2.11
	V3-40-PlusGM57:2.11.0.2
	V2-24-NRT-04:2.10
	V3-33:2.11
	V2-24:2.10
	V3-31:2.11
	V3-30-NRT-05:2.11
	cfm-01-00:2.11
	V3-30:2.11
	V3-20:2.11
	V3-10:2.11
	V2-23-NRT-02:2.10
	V2-23:2.10
	V2-22-NRT-01:2.10
	V2-22:2.10
	V2-21:2.9
	V2-20:2.9
	V2-11:2.9
	V2-10:2.9
	V2-00:2.9
	V1-51:2.8
	V1-50:2.8
	V1-45:2.8
	V1-44:2.8
	V1-43:2.8
	V1-32:2.8
	V1-31:2.8
	V1-30:2.8
	V1-13:2.6
	V1-12:2.6
	V1-11:2.6
	V1-10:2.6
	newfwm-feb03:2.6.0.2
	V1-04:2.2
	V1-03:2.2
	V1-02:2.2
	JointForwardModel:2.2.0.2
	V1-00:2.2
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.12
date	2018.09.12.23.48.08;	author vsnyder;	state dead;
branches;
next	2.11;

2.11
date	2009.06.23.18.26.11;	author pwagner;	state Exp;
branches;
next	2.10;

2.10
date	2007.06.06.01.16.27;	author vsnyder;	state Exp;
branches;
next	2.9;

2.9
date	2005.06.22.18.08.18;	author pwagner;	state Exp;
branches;
next	2.8;

2.8
date	2003.06.20.23.41.48;	author vsnyder;	state Exp;
branches;
next	2.7;

2.7
date	2003.05.05.23.00.25;	author livesey;	state Exp;
branches;
next	2.6;

2.6
date	2002.10.08.17.08.03;	author pwagner;	state Exp;
branches
	2.6.2.1;
next	2.5;

2.5
date	2002.09.07.02.17.52;	author vsnyder;	state Exp;
branches;
next	2.4;

2.4
date	2002.08.22.23.13.33;	author livesey;	state Exp;
branches;
next	2.3;

2.3
date	2002.07.08.17.45.39;	author zvi;	state Exp;
branches;
next	2.2;

2.2
date	2002.01.27.08.37.48;	author zvi;	state Exp;
branches;
next	2.1;

2.1
date	2001.11.02.10.48.39;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.26;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.10.09.41;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

2.6.2.1
date	2003.03.20.01.42.26;	author vsnyder;	state Exp;
branches;
next	;

1.1.2.1
date	2001.09.10.10.09.41;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.12.21.38.46;	author zvi;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.12.21.47.22;	author zvi;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.09.12.21.48.49;	author zvi;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.09.13.22.51.21;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.12
log
@No longer used
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module Eval_Spect_Path_m

  implicit NONE

  private
  public :: Eval_Spect_Path

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: eval_spect_path_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!-----------------------------------------------------------------

  subroutine Eval_Spect_Path ( Grids_x, lo, sideband,  path_zeta, path_phi,  &
                        &      do_calc, eta_fzp )

! Compute some various spectroscopy path arrays

    use MLSCommon, only: RP, IP, R8
    use Get_Eta_Matrix_m, only: Get_Eta_Sparse
    use Load_Sps_Data_m, only: Grids_T

! Input:
    type (Grids_T), intent(in) :: Grids_x  ! All the needed coordinates
    real(r8), intent(in) :: LO             ! Local oscillator
    integer, intent(in) :: Sideband        ! -1 or 1


    real(rp), intent(in) :: Path_zeta(:)   ! zeta values along path
    real(rp), intent(in) :: Path_phi(:)    ! phi values along path

! Output:

    logical, intent(out) :: Do_calc(:,:)   !logical indicating whether there
!                         is a contribution for this state vector element
!                         This is the same length as values.
    real(rp), intent(out) :: Eta_fzp(:,:)  ! Eta_z x Eta_phi x Eta_frq for 
!          each state vector element. This is the same length as values.

! Internal declarations

    integer(ip) :: Sps_i, Sv_f, Sv_p, Sv_z, Sv_v
    integer(ip) :: P_inda, Z_inda, V_inda, P_indb, Z_indb, V_indb, F_inda, F_indb

    real(rp) :: Frq      ! ** ZEBUG ** this will have to change later 
                         ! for the actuall frequecies array coming in as input

!   Actually, all we need is the largest of any grids_x%l_X(i)-grids_x%l_X(i-1)
!   real(rp) :: Eta_f(nfrq,grids_x%l_f(ubound(grids_x%l_f,1)))
    real(rp) :: Eta_f(1,grids_x%l_f(ubound(grids_x%l_f,1))) ! ** ZEBUG, use only one freq.
    real(rp) :: Eta_p(size(path_zeta),grids_x%l_p(ubound(grids_x%l_p,1)))
    real(rp) :: Eta_z(size(path_zeta),grids_x%l_z(ubound(grids_x%l_z,1)))
!   logical :: Not_zero_f(nfrq,grids_x%l_f(ubound(grids_x%l_f,1)))
    logical :: Not_zero_f(1,grids_x%l_f(ubound(grids_x%l_f,1))) ! ** ZEBUG, use only one freq.
    logical :: Not_zero_p(size(path_zeta),grids_x%l_p(ubound(grids_x%l_p,1)))
    logical :: Not_zero_z(size(path_zeta),grids_x%l_z(ubound(grids_x%l_z,1)))

! Begin executable code:

    frq = 0.0

    f_inda = 0
    p_inda = 0
    z_inda = 0
    v_inda = 0

    do sps_i = 1, ubound(grids_x%l_z,1)

      v_indb = grids_x%l_v(sps_i)
      if ( v_indb == v_inda ) cycle

      f_indb = grids_x%l_f(sps_i)
      p_indb = grids_x%l_p(sps_i)
      z_indb = grids_x%l_z(sps_i)

! There are two ways to do this (slow and easy vs quick but difficult)
! For ease let's do the slow and easy (and certainly more reliable)

! Compute etas

      call get_eta_sparse ( lo+sideband*grids_x%frq_basis(f_inda+1:f_indb), &
                         &  (/frq/), eta_f, not_zero_f )
      call get_eta_sparse ( grids_x%zet_basis(z_inda+1:z_indb),  &
                         &  path_zeta, eta_z, not_zero_z )
      call get_eta_sparse ( grids_x%phi_basis(p_inda+1:p_indb),  &
                         &  path_phi, eta_p, not_zero_p, sorted=.true. )

      sv_v = v_inda
      do sv_p = p_inda+1, p_indb
        do sv_z = z_inda+1, z_indb
          do sv_f = f_inda+1, f_indb
            sv_v = sv_v + 1
            if ( not_zero_f(1,sv_f) ) then
              do_calc(:,sv_v) = not_zero_z(:,sv_z) .and. not_zero_p(:,sv_p)
              where ( do_calc(:,sv_v) )
                eta_fzp(:,sv_v) = eta_f(1,sv_f) * eta_z(:,sv_z) * eta_p(:,sv_p)
              elsewhere
                eta_fzp(:,sv_v) = 0.0
              end where
            end if
          end do
        end do
      end do

      f_inda = f_indb
      z_inda = z_indb
      p_inda = p_indb
      v_inda = v_indb

    end do

  end subroutine Eval_Spect_Path

!---------------------------------------------------------------------

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: eval_spect_path_m.f90,v 2.11 2009/06/23 18:26:11 pwagner Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Eval_Spect_Path_m
!
! $Log: eval_spect_path_m.f90,v $
! Revision 2.11  2009/06/23 18:26:11  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 2.10  2007/06/06 01:16:27  vsnyder
! Tell get_eta_matrix that the grid is sorted
!
! Revision 2.9  2005/06/22 18:08:18  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.8  2003/06/20 23:41:48  vsnyder
! Revise how compound etas are computed -- hopefully a faster method
!
! Revision 2.7  2003/05/05 23:00:25  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.6.2.1  2003/03/20 01:42:26  vsnyder
! Revise Grids_T structure
!
! Revision 2.6  2002/10/08 17:08:03  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.5  2002/09/07 02:17:52  vsnyder
! Move USEs from module scope to procedure scope.
! Convert some allocatable arrays to automatics.  Cosmetic changes.
!
! Revision 2.4  2002/08/22 23:13:33  livesey
! New frq_Basis based on intermediate frequency
!
! Revision 2.3  2002/07/08 17:45:39  zvi
! cleaner code to find indecies
!
! Revision 2.2  2002/01/27 08:37:48  zvi
! Adding Users selected coefficients for derivatives
!
! Revision 2.1  2001/11/02 10:48:39  zvi
! Implementing frequecy grid
!
! Revision 2.0  2001/09/17 20:26:26  livesey
! New forward model
!
! Revision 1.1.2.5  2001/09/13 22:51:21  zvi
! Separating allocation stmts
!
! Revision 1.1.2.4  2001/09/12 21:48:49  zvi
! Beautifying ..
!
! Revision 1.1.2.3  2001/09/12 21:47:22  zvi
! Adding CVS stuff
!
@


2.11
log
@Prevent Intel from optimizing ident string away
@
text
@d21 1
a21 1
       "$RCSfile: $"
d132 1
a132 1
       "$Id: read_apriori.f90 is it here $"
d142 3
@


2.10
log
@Tell get_eta_matrix that the grid is sorted
@
text
@d21 1
a21 1
       "$RCSfile: eval_spect_path_m.f90,v $"
d129 1
a130 1
!---------------------------- RCS Ident Info -------------------------------
d132 2
a133 3
       "$Id: eval_spect_path_m.f90,v 2.9 2005/06/22 18:08:18 pwagner Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d135 1
d137 1
d142 3
@


2.9
log
@Reworded Copyright statement, moved rcs id
@
text
@d21 1
a21 1
       "$RCSfile: $"
d99 1
a99 1
                         &  path_phi, eta_p, not_zero_p )
d132 1
a132 1
       "$Id: $"
d141 3
@


2.8
log
@Revise how compound etas are computed -- hopefully a faster method
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d19 3
a21 6
!---------------------------- RCS Ident Info -------------------------------
  character (LEN=*), parameter :: IdParm = &
    & "$Id: eval_spect_path_m.f90,v 2.7 2003/05/05 23:00:25 livesey Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (LEN=*), parameter :: ModuleName= &
    & "$RCSfile: eval_spect_path_m.f90,v $"
d130 5
d141 3
@


2.7
log
@Merged in feb03 newfwm branch
@
text
@d13 1
a13 1
    & "$Id$"
d16 1
a16 1
    & "$RCSfile$"
d33 2
a34 2
    real(r8), intent(in) :: LO            ! Local oscillator
    integer, intent(in) :: Sideband       ! -1 or 1
d37 2
a38 2
    real(rp), intent(in) :: Path_zeta(:) ! zeta values along path
    real(rp), intent(in) :: Path_phi(:)  ! phi values along path
d42 1
a42 1
    logical, intent(out) :: Do_calc(:,:) !logical indicating whether there
d45 1
a45 1
    real(rp), intent(out) :: Eta_fzp(:,:) ! Eta_z x Eta_phi x Eta_frq for 
a46 1
! Internal declaritions
d48 3
a50 2
    integer(ip) :: N_f, N_p, N_z, Nfzp
    integer(ip) :: Sps_i, Sv_i, Sv_j, Sv_f, Sv_z, Sv_p
a68 2
    eta_fzp = 0.0
    do_calc = .false.
d78 1
a78 2
      nfzp = v_indb - v_inda
      if ( nfzp == 0 ) cycle
a83 4
      n_f = f_indb - f_inda
      n_p = p_indb - p_inda
      n_z = z_indb - z_inda

d85 1
a85 1
! For ease lets do the slow and easy (and certainly more reliable)
d96 15
a110 9
      do sv_i = 1, nfzp
        sv_j = v_inda + sv_i
        call brkmod ( sv_i, n_f, n_z, n_p, sv_f, sv_z, sv_p )
        if ( not_zero_f(1,sv_f) ) then
          where ( not_zero_z(:,sv_z) .and. not_zero_p(:,sv_p) )
            do_calc(:,sv_j) = .true.
            eta_fzp(:,sv_j) = eta_f(1,sv_f) * eta_z(:,sv_z) * eta_p(:,sv_p)
          end where
        end if
a119 17
  contains

    subroutine BrkMod ( m, nf, nz, np, jf, jz, jp )

     Integer, intent(in) :: m, nf, nz, np
     Integer, intent(out) :: jf, jz, jp

     Integer :: k

      jf = 1 + MOD(m-1,nf)
      k = (m-jf+nf-1)/nf
      jz = 1 + MOD(k,nz)
      k = (k-jz+nz-1)/nz
      jp = 1 + MOD(k,np)

    end subroutine BrkMod

d130 4
a133 1
! $Log$
@


2.6
log
@Added idents to survive zealous Lahey optimizer
@
text
@d13 1
a13 1
    & "$Id: eval_spect_path_m.f90,v 2.5 2002/09/07 02:17:52 vsnyder Exp $"
d16 1
a16 1
    & "$RCSfile: eval_spect_path_m.f90,v $"
d56 9
a64 8
!   real(rp) :: Eta_f(nfrq,maxval(grids_x%no_f))
    real(rp) :: Eta_f(1,maxval(grids_x%no_f)) ! ** ZEBUG, use only one freq.
    real(rp) :: Eta_p(size(path_zeta),maxval(grids_x%no_p))
    real(rp) :: Eta_z(size(path_zeta),maxval(grids_x%no_z))
!   logical :: Not_zero_f(nfrq,maxval(grids_x%no_f))
    logical :: Not_zero_f(1,maxval(grids_x%no_f)) ! ** ZEBUG, use only one freq.
    logical :: Not_zero_p(size(path_zeta),maxval(grids_x%no_p))
    logical :: Not_zero_z(size(path_zeta),maxval(grids_x%no_z))
d72 9
a80 11
    f_inda = 1
    p_inda = 1
    z_inda = 1
    v_inda = 1

    do sps_i = 1, size(grids_x%no_z)

      n_f = grids_x%no_f(sps_i)
      n_z = grids_x%no_z(sps_i)
      n_p = grids_x%no_p(sps_i)
      nfzp = n_z * n_p * n_f
d83 7
a89 5
      f_indb = f_inda + n_f
      z_indb = z_inda + n_z
      p_indb = p_inda + n_p

      v_indb = v_inda + nfzp
d96 1
a96 1
      call get_eta_sparse ( lo+sideband*grids_x%frq_basis(f_inda:f_indb-1), &
d98 1
a98 1
      call get_eta_sparse ( grids_x%zet_basis(z_inda:z_indb-1),  &
d100 1
a100 1
      call get_eta_sparse ( grids_x%phi_basis(p_inda:p_indb-1),  &
d104 1
a104 1
        sv_j = v_inda + sv_i - 1
d148 7
a154 1
! $Log: eval_spect_path_m.f90,v $
@


2.6.2.1
log
@Revise Grids_T structure
@
text
@d13 1
a13 1
    & "$Id: eval_spect_path_m.f90,v 2.6 2002/10/08 17:08:03 pwagner Exp $"
d56 8
a63 9
!   Actually, all we need is the largest of any grids_x%l_X(i)-grids_x%l_X(i-1)
!   real(rp) :: Eta_f(nfrq,grids_x%l_f(ubound(grids_x%l_f,1)))
    real(rp) :: Eta_f(1,grids_x%l_f(ubound(grids_x%l_f,1))) ! ** ZEBUG, use only one freq.
    real(rp) :: Eta_p(size(path_zeta),grids_x%l_p(ubound(grids_x%l_p,1)))
    real(rp) :: Eta_z(size(path_zeta),grids_x%l_z(ubound(grids_x%l_z,1)))
!   logical :: Not_zero_f(nfrq,grids_x%l_f(ubound(grids_x%l_f,1)))
    logical :: Not_zero_f(1,grids_x%l_f(ubound(grids_x%l_f,1))) ! ** ZEBUG, use only one freq.
    logical :: Not_zero_p(size(path_zeta),grids_x%l_p(ubound(grids_x%l_p,1)))
    logical :: Not_zero_z(size(path_zeta),grids_x%l_z(ubound(grids_x%l_z,1)))
d71 12
a82 6
    f_inda = 0
    p_inda = 0
    z_inda = 0
    v_inda = 0

    do sps_i = 1, ubound(grids_x%l_z,1)
d84 3
a86 3
      v_indb = grids_x%l_v(sps_i)
      nfzp = v_indb - v_inda
      if ( nfzp == 0 ) cycle
d88 1
a88 7
      f_indb = grids_x%l_f(sps_i)
      p_indb = grids_x%l_p(sps_i)
      z_indb = grids_x%l_z(sps_i)

      n_f = f_indb - f_inda
      n_p = p_indb - p_inda
      n_z = z_indb - z_inda
d95 1
a95 1
      call get_eta_sparse ( lo+sideband*grids_x%frq_basis(f_inda+1:f_indb), &
d97 1
a97 1
      call get_eta_sparse ( grids_x%zet_basis(z_inda+1:z_indb),  &
d99 1
a99 1
      call get_eta_sparse ( grids_x%phi_basis(p_inda+1:p_indb),  &
d103 1
a103 1
        sv_j = v_inda + sv_i
a147 3
! Revision 2.6  2002/10/08 17:08:03  pwagner
! Added idents to survive zealous Lahey optimizer
!
@


2.5
log
@Move USEs from module scope to procedure scope.
Convert some allocatable arrays to automatics.  Cosmetic changes.
@
text
@d13 1
a13 1
    & "$Id: eval_spect_path_m.f90,v 2.4 2002/08/22 23:13:33 livesey Exp $"
d17 1
d141 4
d148 4
@


2.4
log
@New frq_Basis based on intermediate frequency
@
text
@d1 6
a6 10
!
! This is a new module to compute some various spectroscopy path arrays
!
MODULE eval_spect_path_m
!
  use MLSCommon, only: RP, IP, R8
  USE get_eta_matrix_m, ONLY: get_eta_sparse
  use Load_sps_data_m, only: Grids_T
!
  IMPLICIT NONE
d8 2
a9 2
  Private
  Public :: eval_spect_path
d12 3
a14 2
  character (LEN=256) :: Id = &
   & "$Id: eval_spect_path_m.f90,v 2.3 2002/07/08 17:45:39 zvi Exp $"
d16 1
a16 1
   & "$RCSfile: eval_spect_path_m.f90,v $"
d18 1
a18 1
 CONTAINS
d20 10
a29 3
!
 SUBROUTINE eval_spect_path(Grids_x,lo,sideband, path_zeta,path_phi, &
                        &   do_calc,eta_fzp)
d31 8
a38 8
  type (Grids_T), INTENT(in) :: Grids_x  ! All the needed coordinates
  real(r8), intent(in) :: lo            ! Local oscillator
  integer, intent(in) :: sideband       ! -1 or 1
  
!
  REAL(rp), INTENT(in) :: path_zeta(:) ! zeta values along path
  REAL(rp), INTENT(in) :: path_phi(:)  ! phi values along path
!
d40 2
a41 2
!
  LOGICAL, INTENT(out) :: do_calc(:,:) !logical indicating whether there
d44 1
a44 1
  REAL(rp), INTENT(out) :: eta_fzp(:,:) ! Eta_z x Eta_phi x Eta_frq for 
a46 4
!
  INTEGER(ip) :: n_f, n_p, n_z, nfzp
  INTEGER(ip) :: sps_i,n_sps,n_path,sv_i,sv_j,sv_f,sv_z,sv_p
  INTEGER(ip) :: p_inda,z_inda,v_inda,p_indb,z_indb,v_indb,f_inda,f_indb
d48 15
a62 2
  REAL(rp) :: Frq      ! ** ZEBUG ** this will have to change later 
                       ! for the actuall frequecies array coming in as input
a63 3
  REAL(rp), ALLOCATABLE :: eta_z(:,:),eta_p(:,:),eta_f(:,:)
  LOGICAL, ALLOCATABLE :: not_zero_z(:,:),not_zero_p(:,:),not_zero_f(:,:)
!
a64 24
!
  n_sps = SIZE(Grids_x%no_z)
  n_path = SIZE(path_zeta)
!
  Frq = 0.0
  eta_fzp = 0.0
  do_calc = .FALSE.
!
  f_inda = 1
  p_inda = 1
  z_inda = 1
  v_inda = 1
!
  DO sps_i = 1, n_sps
!
    n_f = Grids_x%no_f(sps_i)
    n_z = Grids_x%no_z(sps_i)
    n_p = Grids_x%no_p(sps_i)
    nfzp = n_z * n_p * n_f
    if(nfzp == 0) CYCLE

    f_indb = f_inda + n_f
    z_indb = z_inda + n_z
    p_indb = p_inda + n_p
d66 23
a88 2
    v_indb = v_inda + nfzp
!
a90 9
!
    ALLOCATE(eta_z(1:n_path,1:n_z))
    ALLOCATE(eta_p(1:n_path,1:n_p))

    ALLOCATE(not_zero_z(1:n_path,1:n_z))
    ALLOCATE(not_zero_p(1:n_path,1:n_p))

!   ALLOCATE(eta_f(1:nfrq,1:n_f))
    ALLOCATE(eta_f(1:1,1:n_f))         ! ** ZEBUG, use only one freq.
a91 3
!   ALLOCATE(not_zero_f(1:nfrq,1:n_f))
    ALLOCATE(not_zero_f(1:1,1:n_f))    ! ** ZEBUG, use only one freq.
!
a92 42
!
    CALL get_eta_sparse(lo+sideband*Grids_x%frq_basis(f_inda:f_indb-1),(/Frq/), &
                     &  eta_f,not_zero_f)
    CALL get_eta_sparse(Grids_x%zet_basis(z_inda:z_indb-1),path_zeta, &
                     &  eta_z,not_zero_z)
    CALL get_eta_sparse(Grids_x%phi_basis(p_inda:p_indb-1),path_phi, &
                     &  eta_p,not_zero_p)
!
    DO sv_i = 1, nfzp
      sv_j = v_inda + sv_i - 1
      Call BrkMod(sv_i,n_f,n_z,n_p,sv_f,sv_z,sv_p)
      IF(not_zero_f(1,sv_f)) THEN
        WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
          do_calc(:,sv_j) = .TRUE.
          eta_fzp(:,sv_j) = eta_f(1,sv_f) * eta_z(:,sv_z) * eta_p(:,sv_p)
        ENDWHERE
      ENDIF
    END DO
!
    f_inda = f_indb
    z_inda = z_indb
    p_inda = p_indb
    v_inda = v_indb

    DEALLOCATE(not_zero_f)
    DEALLOCATE(not_zero_z)
    DEALLOCATE(not_zero_p)

    DEALLOCATE(eta_f)
    DEALLOCATE(eta_z)
    DEALLOCATE(eta_p)
!
  END DO
!
 END SUBROUTINE eval_spect_path

!---------------------------------------------------------------------

 SUBROUTINE BrkMod(m,nf,nz,np,jf,jz,jp)

  Integer, intent(in) :: m, nf, nz, np
  Integer, intent(out) :: jf, jz, jp
d94 39
a132 1
  Integer :: k
d134 1
a134 5
   jf = 1 + MOD(m-1,nf)
   k = (m-jf+nf-1)/nf
   jz = 1 + MOD(k,nz)
   k = (k-jz+nz-1)/nz
   jp = 1 + MOD(k,np)
d136 1
a136 1
 END SUBROUTINE BrkMod
d140 1
d142 3
a144 1
END MODULE eval_spect_path_m
a145 1
! $Log: eval_spect_path_m.f90,v $
@


2.3
log
@cleaner code to find indecies
@
text
@d6 1
a6 1
  use MLSCommon, only: RP, IP
d17 1
a17 1
   & "$Id: eval_spect_path_m.f90,v 2.2 2002/01/27 08:37:48 zvi Exp $"
d24 1
a24 1
 SUBROUTINE eval_spect_path(Grids_x,path_zeta,path_phi, &
d28 3
d99 1
a99 1
    CALL get_eta_sparse(Grids_x%frq_basis(f_inda:f_indb-1),(/Frq/), &
d157 3
@


2.2
log
@Adding Users selected coefficients for derivatives
@
text
@d17 1
a17 1
 "$Id: eval_spect_path_m.f90,v 2.1 2001/11/02 10:48:39 zvi Exp $"
d19 1
a19 1
 "$RCSfile: eval_spect_path_m.f90,v $"
d58 1
a58 1
  do_calc = .false.
d108 1
a108 1
          do_calc(:,sv_j) = .true.
d135 2
a136 2
 Integer, intent(in) :: m, nf, nz, np
 Integer, intent(out) :: jf, jz, jp
d138 7
a144 24
 Integer :: sv_p,sv_z,sv_f,k
 
 jf = 0
 jz = 0
 jp = 0

 k = 0
 do sv_p = 1, np
   do sv_z = 1, nz
     do sv_f = 1, nf
       k = k + 1
       if(k == m) then
         jf = sv_f
         jz = sv_z
         jp = sv_p
         Return
       endif
     end do
   end do
 end do

 jf = nf
 jz = nz
 jp = np
d147 1
d154 3
@


2.1
log
@Implementing frequecy grid
@
text
@d17 1
a17 1
 "$Id: eval_spect_path_m.f90,v 2.0 2001/09/17 20:26:26 livesey Exp $"
d25 1
a25 1
                        &   do_calc,eta_zxp)
d37 2
a38 2
  REAL(rp), INTENT(out) :: eta_zxp(:,:) ! Eta_z x Eta_phi for each state
!                          vector element. This is the same length as values.
d41 3
a43 3
  INTEGER(ip) :: n_p, n_z, npxz
  INTEGER(ip) :: i_sps,n_sps,n_path,sv_i,sv_z,sv_p,sv_j
  INTEGER(ip) :: p_inda,z_inda,v_inda,p_indb,z_indb,v_indb
d45 5
a49 2
  REAL(rp), ALLOCATABLE :: eta_z(:,:),eta_p(:,:)
  LOGICAL, ALLOCATABLE :: not_zero_z(:,:), not_zero_p(:,:)
d56 2
a57 1
  eta_zxp = 0.0
d60 1
d65 1
a65 1
  DO i_sps = 1, n_sps
d67 5
a71 4
    n_z = Grids_x%no_z(i_sps)
    n_p = Grids_x%no_p(i_sps)
    npxz = n_z * n_p
    if(npxz == 0) CYCLE
d73 1
d77 1
a77 1
    v_indb = v_inda + npxz
d82 1
d84 2
a85 1
    ALLOCATE(eta_z(1:n_path,1:n_z))
d87 6
a92 1
    ALLOCATE(not_zero_z(1:n_path,1:n_z))
d96 2
d100 1
a100 1
    CALL get_eta_sparse(Grids_x%phi_basis(p_inda:p_indb-1),path_phi,  &
d103 9
a111 8
    DO sv_i = 0 , npxz - 1
      sv_j = v_inda + sv_i
      sv_z = 1 + MODULO(sv_i,n_z)
      sv_p = 1 + sv_i / n_z
      WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
        do_calc(:,sv_j) = .true.
        eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
      ENDWHERE
d114 1
d119 1
d122 2
d130 36
d170 3
@


2.0
log
@New forward model
@
text
@d8 1
d17 1
a17 1
 "$Id: eval_spect_path_m.f90,v 1.1.2.5 2001/09/13 22:51:21 zvi Exp $"
d24 2
a25 2
 SUBROUTINE eval_spect_path(z_basis,phi_basis,no_z,no_phi,path_zeta, &
                        &   path_phi,do_calc,eta_zxp)
d27 1
a28 7
  REAL(rp), INTENT(in) :: z_basis(:) ! a vector of zeta basis loaded
!                             sequentially ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: phi_basis(:) ! a vector of orbit plane projected
!                                      horizontal bases, entered squentially
!                             ie [basis_1,basis_2,..., basis_n]
  INTEGER(ip), INTENT(in) :: no_z(:) ! number of z_bases by sps number
  INTEGER(ip), INTENT(in) :: no_phi(:) ! number of phi_bases by sps number
d30 1
a30 1
  REAL(rp), INTENT(in) :: path_phi(:) ! phi values along path
d50 1
a50 1
  n_sps = SIZE(no_z)
d62 2
a63 2
    n_z = no_z(i_sps)
    n_p = no_phi(i_sps)
d82 4
a85 2
    CALL get_eta_sparse(z_basis(z_inda:z_indb-1),path_zeta,eta_z,not_zero_z)
    CALL get_eta_sparse(phi_basis(p_inda:p_indb-1),path_phi,eta_p,not_zero_p)
d113 3
@


1.1
log
@file eval_spect_path_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 124
@


1.1.2.1
log
@Major Design change..
@
text
@a0 99
!
! This is a new module to compute some various spectroscopy path arrays
!
MODULE eval_spect_path_m
!
  use MLSCommon, only: RP, IP
  USE get_eta_matrix_m, ONLY: get_eta_sparse
!
  IMPLICIT NONE
!
!-----------------------------------------------------------------
 CONTAINS
!-----------------------------------------------------------------
!
 SUBROUTINE eval_spect_path(z_basis,phi_basis,no_z,no_phi,path_zeta, &
                        &   path_phi,do_calc,eta_zxp)
! Input:
!
  REAL(rp), INTENT(in) :: z_basis(:) ! a vector of zeta basis loaded
!                             sequentially ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: phi_basis(:) ! a vector of orbit plane projected
!                                      horizontal bases, entered squentially
!                             ie [basis_1,basis_2,..., basis_n]
  INTEGER(ip), INTENT(in) :: no_z(:) ! number of z_bases by sps number
  INTEGER(ip), INTENT(in) :: no_phi(:) ! number of phi_bases by sps number
  REAL(rp), INTENT(in) :: path_zeta(:) ! zeta values along path
  REAL(rp), INTENT(in) :: path_phi(:) ! phi values along path
!
! Output:
!
  LOGICAL, INTENT(out) :: do_calc(:,:) !logical indicating whether there
!                         is a contribution for this state vector element
!                         This is the same length as values.
  REAL(rp), INTENT(out) :: eta_zxp(:,:) ! Eta_z x Eta_phi for each state
!                          vector element. This is the same length as values.
! Internal declaritions
!
  INTEGER(ip) :: n_p, n_z, npxz
  INTEGER(ip) :: i_sps,n_sps,n_path,sv_i,sv_z,sv_p,sv_j
  INTEGER(ip) :: p_inda,z_inda,v_inda,p_indb,z_indb,v_indb

  REAL(rp), ALLOCATABLE :: eta_z(:,:),eta_p(:,:)
  LOGICAL, ALLOCATABLE :: not_zero_z(:,:), not_zero_p(:,:)
!
! Begin executable code:
!
  n_sps = SIZE(no_z)
  n_path = SIZE(path_zeta)
!
  eta_zxp = 0.0
  do_calc = .false.
!
  p_inda = 1
  z_inda = 1
  v_inda = 1
!
  DO i_sps = 1, n_sps
!
    n_z = no_z(i_sps)
    n_p = no_phi(i_sps)
    npxz = n_z * n_p
    if(npxz == 0) CYCLE

    z_indb = z_inda + n_z
    p_indb = p_inda + n_p

    v_indb = v_inda + npxz
!
! There are two ways to do this (slow and easy vs quick but difficult)
! For ease lets do the slow and easy (and certainly more reliable)
!
    ALLOCATE(eta_p(1:n_path,1:n_p),eta_z(1:n_path,1:n_z), &
          &  not_zero_p(1:n_path,1:n_p),not_zero_z(1:n_path,1:n_z))
!
! Compute etas
!
    CALL get_eta_sparse(z_basis(z_inda:z_indb-1),path_zeta,eta_z,not_zero_z)
    CALL get_eta_sparse(phi_basis(p_inda:p_indb-1),path_phi,eta_p,not_zero_p)
!
    DO sv_i = 0 , npxz - 1
      sv_j = v_inda + sv_i
      sv_z = 1 + MODULO(sv_i,n_z)
      sv_p = 1 + sv_i / n_z
      WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
        do_calc(:,sv_j) = .true.
        eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
      ENDWHERE
    END DO
!
    z_inda = z_indb
    p_inda = p_indb
    v_inda = v_indb
    DEALLOCATE(eta_p,eta_z,not_zero_p,not_zero_z)
!
  END DO
!
 END SUBROUTINE eval_spect_path
!
END MODULE eval_spect_path_m
@


1.1.2.2
log
@Added CVS stuff
@
text
@a9 3

  Private
  Public :: eval_spect_path
@


1.1.2.3
log
@Adding CVS stuff
@
text
@d13 2
a14 7

!---------------------------- RCS Ident Info -------------------------------
  character (LEN=256) :: Id = &
 "$Id: load_sps_data_m.f90,v 1.1.2.10 2001/09/12 21:38:51 zvi Exp $"
  character (LEN=*), parameter :: ModuleName= &
 "$RCSfile: load_sps_data_m.f90,v $"
!---------------------------------------------------------------------------
a102 3
!
! $Log$
!
@


1.1.2.4
log
@Beautifying ..
@
text
@d16 1
a16 1
 "$Id: eval_spect_path_m.f90,v 1.1.2.3 2001/09/12 21:47:22 zvi Exp $"
d18 1
a18 1
 "$RCSfile: eval_spect_path_m.f90,v $"
d109 1
a109 3
! $Log: eval_spect_path_m.f90,v $
! Revision 1.1.2.3  2001/09/12 21:47:22  zvi
! Adding CVS stuff
@


1.1.2.5
log
@Separating allocation stmts
@
text
@d16 1
a16 1
 "$Id: eval_spect_path_m.f90,v 1.1.2.4 2001/09/12 21:48:49 zvi Exp $"
d80 2
a81 4
    ALLOCATE(eta_p(1:n_path,1:n_p))
    ALLOCATE(eta_z(1:n_path,1:n_z))
    ALLOCATE(not_zero_p(1:n_path,1:n_p))
    ALLOCATE(not_zero_z(1:n_path,1:n_z))
d101 1
a101 5

    DEALLOCATE(not_zero_z)
    DEALLOCATE(not_zero_p)
    DEALLOCATE(eta_z)
    DEALLOCATE(eta_p)
a109 3
! Revision 1.1.2.4  2001/09/12 21:48:49  zvi
! Beautifying ..
!
@


