head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2001.03.05.23.24.36;	author zvi;	state dead;
branches;
next	1.4;

1.4
date	2001.03.05.21.37.20;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.19.22.14.21;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.23.07.28;	author zvi;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@Program l2_numder
  use GL6P, only: NG
  use MLSCommon, only: I4, R8
  use L2_TEST_STRUCTURES_M
  use STRINGS, only: STRLWR
  use L2PC_FILE_PARAMETERS, only: mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT
  use L2PC_PFA_STRUCTURES, only: LIMB_PRESS
  use L2PCdim, only: Nlvl, N2lvl, NSPS, Nptg, MNP => max_no_phi, &
                     MNM => max_no_mmaf
  use ELLIPSE, only: PHI_TAN, ROC
  use L2_LOAD_M, only: L2_LOAD
  use COMP_PATH_ENTITIES_M, only: COMP_PATH_ENTITIES
  use REFRACTION_M, only: REFRACTION_CORRECTION
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
                             PATH_DERIVATIVE
  use HYDROSTATIC_MODEL_M, only: HYDROSTATIC_MODEL
  use GET_CHI_ANGLES_M, only: GET_CHI_ANGLES
  use GET_BETA_PATH_M, only: GET_BETA_PATH
  use GEOC_GEOD_CONV_M, only: GEOC_GEOD_CONV
  use RAD_TRAN_M, only: RAD_TRAN
  use FOV_CONVOLVE_M, only: FOV_CONVOLVE
  use FREQ_AVG_M, only: FREQ_AVG
  use D_HUNT_M, only: HUNT          ! ** DEBUG
  use D_CSPLINE_M, only: CSPLINE

  Implicit NONE
!---------------------------------------------------------------------------
!
Integer(i4), PARAMETER :: ngt = (Ng+1) * N2lvl

Type(fwd_mdl_info) :: FMI
Type(fwd_mdl_config) :: FMC
Type(temporary_fwd_mdl_info) :: T_FMI

Integer(i4) :: SPECT_ATMOS(Nsps)

Integer(i4) :: ma, line_no, kz, ier, ch1, ch2, no_pfa_ch, pfa_ch(2)
Integer(i4) :: i, j, k, kk, jj, ht_i, no_t, no_tan_hts, ch, Spectag, &
               prev_npf, n_obs, si, band, n_sps,  ptg_i, &
               frq_i, io, l, brkpt, no_ele, mid, m, ilo, ihi, no_phi_t, &
               gl_count, mmaf

Type(path_index)  :: ndx_path(Nptg,mnm)
Type(path_vector) :: z_path(Nptg,mnm),t_path(Nptg,mnm),h_path(Nptg,mnm),  &
                     dhdz_path(Nptg,mnm), spsfunc_path(Nsps,Nptg,mnm),    &
                     n_path(Nptg,mnm),phi_path(Nptg,mnm)

Type(path_derivative) :: dh_dt_path(Nptg,mnm)

Real(r8) :: thbs(10),elev_offset
Real(r8) :: t_script(N2lvl),ref_corr(N2lvl,Nptg),tau(N2lvl), &
            tan_dh_dt(Nlvl,mnm,mxco)

Real(r8) :: dx,var,zco,daz
Real(r8) :: dx_dt(Nptg,mxco), d2x_dxdt(Nptg,mxco)

Real(r8) :: h_glgrid(ngt,mnm), t_glgrid(ngt,mnm), z_glgrid(ngt/2)
Real(r8) :: dh_dt_glgrid(ngt,mnm,mxco), dhdz_glgrid(ngt,mnp)

Real(r8) :: ptg_angles(Nptg,mnm), center_angle
Real(r8) :: tan_hts(Nptg,mnm), tan_temp(Nptg,mnm)

Logical :: do_mol, do_spec

Real(r8) :: T_PHI_BASIS_COPY(mnp)
Real(r8) :: F_PHI_BASIS_COPY(mnp,Nsps)

Real(r8), DIMENSION(:), ALLOCATABLE :: RadV, F_grid
Real(r8), DIMENSION(:,:), ALLOCATABLE :: S_PHI_BASIS_COPY

Real(r8) :: I_STAR_ALL(Nptg)
!
Type(path_beta), DIMENSION(:,:), POINTER :: beta_path    ! (sps_i,frq_i)

Real(r8) :: Radiances(Nptg)
Real(r8) :: e_rad, zeta, Frq, h_tan, Rad, geoc_lat, q, r
!
Character (LEN=16) :: dName, Vname
Character (LEN=80) :: Line
Character (LEN=40) :: Ax

!  ----------------------

  Line(1:) = ' '
! Line = '/home/zvi/seez'      ! HOME PC, JPL PC
  Line = '/user5/zvi/seez'     ! MLSGATE, SUN
  FMC%Z = Line
!
! Load all needed data via l2_load routine:
!
  Call L2_LOAD(FMC, FMI, T_FMI, Ier)
  if(ier /= 0) goto 99

  ch1 = FMC%Channels_range(1)
  ch2 = FMC%Channels_range(2)
  no_pfa_ch = min(2,ch2-ch1+1)
  do i = 1, no_pfa_ch
    pfa_ch(i) = ch1 + i - 1
  end do

  elev_offset = 0.0                         ! Zero elev_offset in any case
  SPECT_ATMOS(1:Nsps) = -1
!
! Set n_obs to be: N_lvls always.
!   (Changed, Aug/6/96 Z.Shippony & W.G.Read)

  band = FMI%band
  n_obs = FMC%n_lvls

  no_t = T_FMI%no_t
  no_phi_t = T_FMI%no_phi_t

  T_PHI_BASIS_COPY(1:no_phi_t) = T_FMI%t_phi_basis(1:no_phi_t)
!
  n_sps = FMI%n_sps
  DO m = 1, n_sps
    kk = T_FMI%no_phi_f(m)
    F_PHI_BASIS_COPY(1:kk,m) = T_FMI%f_phi_basis(1:kk,m)
  END DO
!
! Create spect_atmos array:
!
  do k = 1, n_sps
    Spectag = T_FMI%atmospheric(k)%Spectag
    do i = 1, FMI%no_spectro
      if(Spectag == FMI%spectroscopic(i)%Spectag) then
        spect_atmos(k) = i
        EXIT
      endif
    end do
  end do
!
  kk = mxco
  k = FMI%mfi + 2

  DEALLOCATE(S_PHI_BASIS_COPY,STAT=i)
  ALLOCATE(S_PHI_BASIS_COPY(k,FMI%no_spectro),STAT=io)
  IF(io /= 0) then
    Print *,'** ALLOCATE Error: S_PHI_BASIS_COPY, STAT =',io
    goto 99
  endif

  do j = 1, FMI%no_spectro
    S_PHI_BASIS_COPY(1:k,j) = FMI%spectroscopic(j)%PHI_BASIS(1:k)
  end do
!
! Convert GeoDetic Latitude to GeoCentric Latitude, and convert both to
! Radians (instead of Degrees). Also compute the effective earth radius.
!
  mmaf = 3                     ! Do only this mmaf (middle phi)
  phi_tan = FMC%phi_tan_mmaf(mmaf)
  Call geoc_geod_conv(T_FMI%beta_inc,phi_tan,geoc_lat,E_rad)
!
  ma = -1
  kz = -1
  dx = 0.0
  dName = ' '
  Vname = ' '
  daz = -1.666667
  do_mol = .false.
  do_spec = .false.
  Print *,'Enter name of variable to differentiate by. Choises are:'
  Call Gti(' dT, dMr, dw, dn & dNu',dName)
  if(dName < '!') goto 99
  Call StrLwr(dName)
  Print *

  Call Gti(' Enter step size',Ax)
  if(Ax < '!') goto 99
  read(Ax,*,iostat=io) dx
  if(io /= 0) goto 99
  if(abs(dx) < 1.0e-12) goto 99
  Print *

  Line(1:)=' '
  Line = 'Enter Zeta level of the coefficient to differentiate w.r.t.'
  i = LEN_TRIM(Line)
  Line = Line(1:i)//'(Default: -1.6667)'
  i = LEN_TRIM(Line)
  Print *,Line(1:i)
  Call Gti(' (Phi coefficient is taken to be the middle one)',Ax)
  if(Ax < '!') Ax = '-1.666667'
  read(Ax,*,iostat=i) daz
  if(i /= 0) daz = -1.666667
  Print *,Ax

  j = -1
  if(dName == 'dmr') j = 1
  if(dName == 'dw' .or. dName == 'dn' .or. dName == 'dnu') j = 2
  if(j > 0) then
    if(j == 2) then
      zco = daz
      do_spec = .true.
    else
      do_mol = .true.
    endif
    Call Gti(' Enter molecule name',Vname)
    if(Vname < '!') goto 99
    Call StrLwr(Vname)
    Print *,Vname
  endif

  if(dName == 'dt') then
    Call Hunt(daz,T_FMI%t_zeta_basis,no_t,kz,i)
    IF(ABS(daz-T_FMI%t_zeta_basis(i)) < ABS(daz-T_FMI%t_zeta_basis(kz))) kz=i
    zco = T_FMI%t_zeta_basis(kz)
  endif

  if(do_mol) then
    ht_i = T_FMI%no_coeffs_f(ma)
    Call Hunt(daz,T_FMI%f_zeta_basis(1:,ma),ht_i,kz,i)
    IF(ABS(daz-T_FMI%f_zeta_basis(i,ma)) <  &
   &   ABS(daz-T_FMI%f_zeta_basis(kz,ma))) kz=i
    zco = T_FMI%f_zeta_basis(kz,ma)
    k = (T_FMI%no_phi_f(ma)+1)/2
    r = 0.05 * abs(T_FMI%mr_f(kz,k,ma))
    q = sign(1.0_r8,dx) * max(1.0d-8,r)
    dx = q
    Print *,'** Modified Step Size:',Sngl(dx)
  endif

  if(do_spec) then
    line_no = 1
    DO j = 1, n_sps
      Ax = T_FMI%atmospheric(j)%NAME
      Call StrLwr(Ax)
      if(Ax == Vname) then
        if(dName == 'dw') then
          var = FMI%pfa_spectrum(j)%SPS_W(line_no)
          r = 0.1 * abs(var)
          q = sign(1.0_r8,dx) * max(1.0d-8,r)
          dx = q
          Print *,'** Modified Step Size:',Sngl(dx)
          FMI%pfa_spectrum(j)%SPS_W(line_no) = var + dx
        else if(dName == 'dn') then
          var = FMI%pfa_spectrum(j)%SPS_N(line_no)
          r = 0.1 * abs(var)
          q = sign(1.0_r8,dx) * max(1.0d-8,r)
          dx = q
          Print *,'** Modified Step Size:',Sngl(dx)
          FMI%pfa_spectrum(j)%SPS_N(line_no) = var + dx
        else if(dName == 'dnu') then
          var = FMI%pfa_spectrum(j)%SPS_V0(line_no)
          Print *,'** Modified Step Size:',Sngl(dx)
          FMI%pfa_spectrum(j)%SPS_V0(line_no) = var + dx
        endif
        EXIT
      endif
    END DO
  endif
!
  Print *
  Print *, 'VarName: ',dName
  Print *, 'Molecule: ',Vname
  Print *, 'Step Size: ',Sngl(dx)
  Print *, 'Differentiated w.r.t. Coefficient #',kz
  Print *, 'Zeta of differentiated Coefficient:',Sngl(zco)
  Print *
!
! Perturbe the middle Phi coefficient for the 'zco' pressure level
!
  if(dName == 'dt') then
    k = (FMC%no_mmaf+1)/2
    var = T_FMI%t_coeff(kz,k)
    T_FMI%t_coeff(kz,k) = var + dx
  else if(dName == 'dmr') then
    k = (T_FMI%no_phi_f(ma)+1)/2
    var = T_FMI%mr_f(kz,k,ma)
    T_FMI%mr_f(kz,k,ma) = var + dx
  endif
!
! Convert GeoDetic Latitude to GeoCentric Latitude, and convert both to
! Radians (instead of Degrees). Also compute the effective earth radius.
!
  mmaf = 3                       ! Do only this mmaf (The middle phi)
  phi_tan = FMC%phi_tan_mmaf(mmaf)
  Call geoc_geod_conv(T_FMI%beta_inc,phi_tan,geoc_lat,E_rad)
!
! Compute the hydrostatic_model on the GL-Grid for all mmaf(s):
!
  thbs(1:) = 0.0
  si = FMI%Surface_index
  thbs(1:si-1) = FMI%Tan_hts_below_surface(1:si-1)
  Call hydrostatic_model(si,FMC%N_lvls,T_FMI%no_t,FMC%no_mmaf,FMC%t_indx, &
       FMC%no_tan_hts,geoc_lat,T_FMI%Href,T_FMI%Zref,FMI%z_grid,thbs, &
       T_FMI%t_zeta_basis, T_FMI%t_coeff, z_glgrid, h_glgrid, t_glgrid, &
       dhdz_glgrid,dh_dt_glgrid,FMI%tan_press,tan_hts,tan_temp,tan_dh_dt, &
       gl_count, Ier)
  IF(ier /= 0) goto 99

  Zeta = zco
  no_tan_hts = FMC%no_tan_hts
  Call Hunt(Zeta,FMI%tan_press,no_tan_hts,jj,i)
  IF(ABS(Zeta-FMI%tan_press(i)) < ABS(Zeta-FMI%tan_press(jj))) jj = i
!
! Compute all path entities for all mmafs and tanget pointings
!
  Call comp_path_entities(FMC%n_lvls,T_FMI%no_t,gl_count,ndx_path, &
       z_glgrid,t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,        &
       T_FMI%atmospheric,T_FMI%f_zeta_basis,T_FMI%mr_f,            &
       T_FMI%no_coeffs_f,tan_hts,no_tan_hts,FMI%n_sps,             &
       T_FMI%no_phi_f,T_FMI%f_phi_basis,z_path,h_path,t_path,phi_path,&
       n_path,dhdz_path,dh_dt_path,T_FMI%no_phi_t,T_FMI%t_phi_basis,  &
       spsfunc_path,T_FMI%is_f_log,FMC%no_mmaf,FMC%phi_tan_mmaf,Ier)
  IF(ier /= 0) goto 99
!
! **********************  MAIN Mmaf Loop *******************

  l = mmaf                    ! ** Do this mmaf only
!
  phi_tan = FMC%phi_tan_mmaf(l)
!
  T_FMI%t_phi_basis(1:no_phi_t) = t_phi_basis_copy(1:no_phi_t) + phi_tan

  DO j = 1, n_sps
    k = T_FMI%no_phi_f(j)
    T_FMI%f_phi_basis(1:k,j) = f_phi_basis_copy(1:k,j) + phi_tan
  end do

  k = FMI%mfi + 2
  do j = 1, FMI%no_spectro
    FMI%spectroscopic(j)%PHI_BASIS(1:k) = s_phi_basis_copy(1:k,j) + phi_tan
  end do
!
! Compute the ptg_angles (chi) for Antenna convolution, also the derivatives
! of chi w.r.t to T and other parameters
!
  Call get_chi_angles(ndx_path(1:,l),n_path(1:,l),FMI%tan_press,         &
 &     tan_hts(1:,l),tan_temp(1:,l),phi_tan,RoC,T_FMI%h_obs,elev_offset, &
 &     tan_dh_dt(1:,l,1:),no_tan_hts,T_FMI%no_t,T_FMI%t_zeta_basis,si,   &
 &     center_angle,ptg_angles(1:,l),dx_dt,d2x_dxdt,ier)
  IF(ier /= 0) goto 99

! Compute the refraction correction scaling matrix for this mmaf:
!
  Call refraction_correction(no_tan_hts, tan_hts(1:,l), h_path(1:,l), &
 &                n_path(1:,l), ndx_path(1:,l), E_rad, ref_corr)
!
! Now, Compute the radiances alone:
!
  prev_npf = -1
  Radiances(1:Nptg) = 0.0
!
! **********************  MAIN Pointing Loop *******************
!
  DO ptg_i = 1, no_tan_hts-1
!
    k = ptg_i
    h_tan = tan_hts(k,l)
    kk = FMI%no_ptg_frq(k)
!
    if(kk /= prev_npf) then
      prev_npf = kk
      DEALLOCATE(RadV,F_grid,STAT=i)
      ALLOCATE(RadV(kk),F_grid(kk),STAT=ier)
      IF(ier /= 0) then
        Print *,'** ALLOCATE Error: RadV or F_grid arrays, STAT =',ier
        goto 99
      endif
    endif
!
! Compute the beta's along the path, for this tanget hight and this mmaf:
!
    no_ele = ndx_path(ptg_i,l)%total_number_of_elements
    Call get_beta_path(ptg_i,FMI%pfa_spectrum,no_ele,FMI%no_ptg_frq, &
   &     FMI%ptg_frq_grid,z_path(ptg_i,l),t_path(ptg_i,l),beta_path,ier)
    IF(ier /= 0) goto 99
!
    RadV(1:kk) = 0.0
    f_grid(1:kk) = FMI%ptg_frq_grid(k)%values(1:kk)
!
    do frq_i = 1, kk
!
      Frq = f_grid(frq_i)
!
      Call Rad_Tran(Frq, FMC%N_lvls, h_tan, FMI%n_sps, ndx_path(k,l),  &
     &    z_path(k,l), h_path(k,l), t_path(k,l), phi_path(k,l),&
     &    dHdz_path(k,l), T_FMI%earth_ref, beta_path(1:,frq_i),      &
     &    spsfunc_path(1:,k,l), ref_corr(1:,k), T_FMI%s_temp, brkpt, &
     &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
      IF(ier /= 0) goto 99
!
      RadV(frq_i) = Rad
!
    end do

! Frequency Average the radiances with the appropriate filter shapes
!
    i = 1
    ch = pfa_ch(i)
    if(FMC%do_frqavg) then
      Call Freq_Avg(F_grid,FMI%F_grid_filter(1:,i),  &
     &     FMI%Filter_func(1:,i),RadV,kk,FMI%no_filt_pts, &
     &     Radiances(ptg_i))
    else
      Radiances(ptg_i) = RadV(1)
    endif
!
  END DO              ! Pointing Loop
!
! Complete the radiances's last location
!
  kk = no_tan_hts
  Radiances(kk) = Radiances(kk-1)
!
  if(FMC%do_conv) then
!
! Here comes the Convolution code
!
    Call convolve_rad(T_FMI%ptg_press,FMI%tan_press,ptg_angles(1:,l), &
   &     band,center_angle,FMI%fft_pts,Radiances,no_tan_hts,i_star_all, &
   &     FMI%Xlamda,FMI%Aaap,FMI%D1Aaap,FMI%D2Aaap,FMI%Ias,ier)
    IF(ier /= 0) goto 99
!
  else
!
! Here comes the No_Convolution code
!
    Call no_convolve_rad (T_FMI%ptg_press,FMI%tan_press,Radiances, &
   &                      no_tan_hts,i_star_all)
!
  endif
!
! *** DEBUG Print
!
  if(FMC%do_conv) then
    Print *,'Convolution: ON'
  else
    Print *,'Convolution: OFF'
  endif
!
  Frq = FMC%Zfrq
  if(Frq > 0.0) then
    write(*,901) Frq
901 format(' Frequency Averaging: OFF',/,  &
         & ' (All computations done at Frq =',f12.4,')')
  else
    Print *,'Frequency Averaging: ON'
  endif
  Print *
!
  i = 1
  ch = pfa_ch(i)
  kk = T_FMI%ptg_press%no_lin_values
  write(*,903) ch,char(92),kk
  write(*,905) (i_star_all(k),k=1,kk)

903 format('ch',i2.2,'_avg_conv_pfa_rad',a1,i2.2)
905 format(4(2x,1pg15.8))
!
 99  CLOSE(11,iostat=i)
     CLOSE(13,iostat=i)
     CLOSE(32,iostat=i)
!
     if(io /= 0) Call ErrMsg(Line,io)

  Stop

!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------
!
Subroutine Gti(Msg,Ti)
!
  Implicit none

  Character(len=*), intent(IN) :: Msg
  Character(len=*), intent(OUT) :: Ti
!
  Integer :: i

  i = Len(ti)
  Ti(1:i) = ' '
  i = Len_Trim(msg)
  write(*,900,Advance='NO') Msg(1:i)
  Read(5,'(a)',iostat=i) Ti
  i = Len_Trim(Ti)
  if(i > 1) Ti = AdjustL(Ti)

 900  Format(A,': ')
!
End Subroutine Gti

!---------------------------------------------------------------------------
! This subroutine transfers the derivatives over from the internal
! convolution grid to the users specified points. This module uses
! cubic spline interpolation to do the job.
!
Subroutine convolve_rad (ptg_press,tan_press,ptg_angles, &
           band,center_angle, fft_pts, i_raw, no_tan_hts, i_star_all,&
           Xlamda,Aaap,D1Aap,D2Aap,Ias,ier)

!
    integer(i4), intent(IN) :: IAS, no_tan_hts, band, fft_pts
!
    real(r8), intent(IN) :: CENTER_ANGLE, Xlamda
    real(r8), intent(IN) :: TAN_PRESS(*), PTG_ANGLES(*)
    real(r8), intent(IN) :: I_RAW(*)

    Real(r8), intent(in) :: AAAP(:,:),D1AAP(:,:),D2AAP(:,:)

!
    type(limb_press), intent(IN) :: PTG_PRESS
!
! -----     Output Variables   ----------------------------------------
!
    integer(i4), intent(OUT) :: IER
!
    real(r8), intent(OUT) :: I_STAR_ALL(:)
!
! -----     Local Variables     ----------------------------------------
!
    integer(i4) :: IS, J, K, NTR
!
    real(r8) :: Q, FFT_ANGLES(2**fft_pts), RAD(2**fft_pts)
!
! -----  Begin the code  -----------------------------------------
!
! Compute the ratio of the strengths
!
! This subroutine is called by channel
!
    Ier = 0
    ntr = 2**fft_pts
!
    Rad(1:no_tan_hts) = i_raw(1:no_tan_hts)
!
! Compute the convolution of the mixed radiances
!
    fft_angles(1:no_tan_hts) = ptg_angles(1:no_tan_hts)
    Call fov_convolve(fft_angles,Rad,center_angle,1,no_tan_hts,band, &
   &                  fft_pts,XLAMDA,AAAP,D1AAP,D2AAP,IAS,Ier)
    if (Ier /= 0) Return
!
! Interpolate the output values and store the radiances in: i_star_all
!
    is = 1
    k = no_tan_hts
    q = ptg_press%lin_val(1)-0.01
    do while(tan_press(is) < q)
      is = is + 1
    end do
    j = k - is + 1
    Call Cspline(fft_angles,ptg_angles(is:k),Rad,i_star_all,ntr,j)
!
    Return
!
  End Subroutine CONVOLVE_RAD

!---------------------------------------------------------------------------
! This subroutine transfers the derivatives over from the internal
! convolution grid to the users specified points. This module uses
! cubic spline interpolation to do the job.
!
Subroutine no_convolve_rad (ptg_press,tan_press,i_raw, no_tan_hts, i_star_all)
!
    Integer(i4), intent(IN) :: no_tan_hts
!
    Real(r8), intent(IN) :: TAN_PRESS(*), I_RAW(*)
!
    Type(limb_press), intent(IN) :: PTG_PRESS
!
! -----     Output Variables   ----------------------------------------
!
    Real(r8), intent(OUT) :: I_STAR_ALL(:)
!
! -----     Local Variables     ----------------------------------------
!
    Integer(i4) :: J, K
!
    Real(r8) :: PtP(Nlvl)
!
! -----  Begin the code  -----------------------------------------
!
    j = ptg_press%no_lin_values
    PtP(1:j) = dble(ptg_press%lin_val(1:j))
!
! Interpolate the output values and store the radiances in: i_star_all
!
    k = no_tan_hts
    Call Cspline(tan_press,PtP,i_raw,i_star_all,k,j)
!
    Return
!
  End Subroutine NO_CONVOLVE_RAD

end Program l2_numder
@


1.4
log
@New filter format
@
text
@@


1.3
log
@
Ctest modification Conv/NoConvVS: ----------------------------------------------------------------------
@
text
@d3 2
a4 1
  use MLSCommon, only: I4, R4, R8
d6 3
a8 6
  use L2PC_FILE_PARAMETERS, only: mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT, &
                                  DEG2RAD
  use L2PC_PFA_STRUCTURES, only: ATMOS_COMP, GEOM_PARAM, MAXFILTPTS, &
                                 PFA_SLAB, SPECTRO_PARAM, MAXPFACH, &
                                 MAXGEOM, LIMB_PRESS
  use L2PCdim, only: Nlvl, N2lvl, NSPS, Nptg, NCH, MNP => max_no_phi, &
d11 1
a17 1
  use GET_FILTERS_M, only: GET_FILTERS
d31 11
a41 12
Integer(i4), PARAMETER :: mnf = 75

Integer(i4) :: p_indx(Nlvl), SPECT_ATMOS(Nsps), no_ptg_frq(Nptg), &
               no_coeffs_f(Nsps), no_phi_f(Nsps), SPECT_INDEX(Nsps), &
               no_spectro, pfa_ch(MAXPFACH), t_indx(Nptg)

Integer(i4) :: ma, line_no, Freq_Index, k1, k2, kz, ier, fft_pts
Integer(i4) :: i, j, k, kk, jj, ht_i, no_t, mnz, no_geom, no_tan_hts, &
               ld, ch, Spectag, no_freqs, no_pfa_ch, prev_npf, n_obs, &
               no_atmos, ch1, ch2, n_lvls, si, mfi, jp, band, n_sps,  &
               ptg_i, frq_i, io, l, brkpt, no_ele, nl, mid, m,ilo,    &
               ihi, no_filt_pts, no_phi_t, no_mmaf, gl_count, mmaf
a46 1
Type(path_vector) :: ptg_frq_grid(Nptg)
d50 3
a52 4
Real(r8) :: z_gnlv(400),thbs(10),phi_tan_mmaf(mnm),elev_offset
Real(r8) :: href(Nlvl),zref(Nlvl),t_z_basis(mxco),t_script(N2lvl),  &
            t_coeff(mxco,mnm),ref_corr(N2lvl,Nptg),tau(N2lvl),Qlog(3), &
            tan_dh_dt(Nlvl,mnm,mxco),t_phi_basis(mnp),t_phi_basis_copy(mnp)
d54 1
a54 1
Real(r8) :: dx,var,zco,daz,Zfrq
d58 1
a58 1
Real(r8) :: z_grid(Nlvl),dh_dt_glgrid(ngt,mnm,mxco), dhdz_glgrid(ngt,mnp)
d61 1
a61 4
Real(r8) :: tan_press(Nptg), tan_hts(Nptg,mnm), tan_temp(Nptg,mnm)

Logical :: IS_F_LOG(Nsps)
Logical :: do_mol, do_spec, do_conv, do_frqavg
d63 1
a63 1
real(r8) :: freq_grid(mnf),freqs(Nch)
d65 2
a66 2
real(r8) :: MR_F(mxco,mnp,Nsps), F_BASIS(mxco,Nsps)
real(r8) :: F_PHI_BASIS(mnp,Nsps), F_PHI_BASIS_COPY(mnp,Nsps)
d68 2
a69 2
real(r8) :: FILTER_FUNC(maxfiltpts,maxpfach)
real(r8) :: F_GRID_FILTER(maxfiltpts,maxpfach)
d71 1
a71 1
real(r8) :: I_STAR_ALL(Nptg)
d73 1
a73 1
Type(path_beta) :: beta_path(Nsps,mnf)
d76 1
a76 5
Real(r8) :: RadV(mnf), f_grid(mnf)
Real(r8) :: s_temp, h_obs, earth_ref, e_rad, zeta, Frq, h_tan, Rad, &
            beta_inc, geoc_lat, q, r

Real(r4) :: elev_183, elev_205
a77 2
Character (LEN=01) :: Primag
Character (LEN=08) :: Name
d79 1
a79 1
Character (LEN=80) :: InDir, Aaap, Fnd, Line
d82 18
a99 5
Type(limb_press)       :: PTG_PRESS
Type (atmos_comp)      :: ATMOSPHERIC(Nsps)
Type (geom_param)      :: GEOMETRIC(maxgeom)
Type (pfa_slab)        :: PFA_SPECTRUM(Nsps)
Type (spectro_param)   :: SPECTROSCOPIC(3*Nsps)
d101 8
a108 1
Real(r8), DIMENSION(:,:), ALLOCATABLE :: s_phi_basis_copy
d110 12
a121 2
!  ----------------------
! Read convolution & freq. averaging data from file: tmp.dat
d123 9
a131 4
  Line = 'tmp.dat'
  CLOSE(13,iostat=io)
  OPEN(13,file=Line,status='OLD',action='READ',iostat=io)
  if(io /= 0) goto 99
d133 8
a140 9
  Zfrq = -1.0
  Freq_Index = -1
  read(13,*,iostat=io) do_conv
  if(io /= 0) goto 99
  read(13,*,iostat=io) do_frqavg
  if(io /= 0) goto 99
  if(.not. do_frqavg) then
    read(13,*,iostat=io) Zfrq
    if(io /= 0) goto 99
d142 11
a152 3
  CLOSE(13,iostat=io)
!  ----------------------
! Read the rest of the inputs from a file...
a153 9
  ier = 0
  Fnd(1:) = ' '
  Line(1:)= ' '
! Fnd = '/home/zvi/mod_seez'      ! HOME PC
  Fnd = '/user5/zvi/mod_seez'     ! MLSGATE, SUN
  CLOSE(11,iostat=io)
  OPEN(11,file=Fnd,status='OLD',action='READ',iostat=io)
  if(io /= 0) goto 99

a202 385
  p_indx(1:Nlvl) = 0
  t_indx(1:Nptg) = 0
  no_phi_f(1:Nsps) = 0
  no_ptg_frq(1:Nptg) = 0
  pfa_ch(1:MAXPFACH) = 0
  no_coeffs_f(1:Nsps) = 0

  SPECT_INDEX(1:Nsps) = -1
  SPECT_ATMOS(1:Nsps) = -1

  do
    Ax(1:) = ' '
    read(11,'(A)',iostat=io) Ax
    if(io /= 0) goto 99
    if (Index(Ax,'No_Mmaf') > 0) EXIT
  end do

  read(11,*,iostat=io) j
  if(io /= 0) goto 99

  Primag = 'p'
  no_mmaf = min(j,mnm)

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  tau(1:no_mmaf) = 0.0
  read(11,*,iostat=io) (tau(i),i=1,no_mmaf)
  if(io /= 0) goto 99

  phi_tan_mmaf(1:no_mmaf) = tau(1:no_mmaf) * deg2rad

  do
    Ax(1:) = ' '
    read(11,'(A)',iostat=io) Ax
    if(io /= 0) goto 99
    if (Index(Ax,'Channels_Range') > 0) EXIT
  end do

  read(11,*,iostat=io) ch1, ch2
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_pfa_ch
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (pfa_ch(i),i=1,no_pfa_ch)
  if(io /= 0) goto 99
!
  primag = 'p'
  freqs(1:Nch) = 0.0D0
  DO i = ch1, ch2
    CALL radiometry(i,q,r,zeta,kk)     ! DEBUG, Added Jan/23/2000, Z.S
    IF(primag == 'p') freqs(i) = q     ! DEBUG, Added Jan/23/2000, Z.S
    IF(primag == 'i') freqs(i) = r     ! DEBUG, Added Jan/23/2000, Z.S
  END DO
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) ptg_press%name, (ptg_press%der_calc(i),i=1,6)
  if(io /= 0) goto 99

  read(11,*,iostat=io) j
  if(io /= 0) goto 99

  ptg_press%no_lin_values = j
  read(11,*,iostat=io) (ptg_press%lin_val(i),i=1,j)
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_geom
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  do i = 1, no_geom
    read(11,*,iostat=io) geometric(i)
    if(io /= 0) goto 99
    r = geometric(i)%lin_val
    IF(geometric(i)%name == 'ELEV_183') THEN
      elev_183 = r
    ELSE IF(geometric(i)%name == 'ELEV_205') THEN
      elev_205 = r
    ELSE IF(geometric(i)%name == 'EARTHREF') THEN
      earth_ref = r
    ELSE IF(geometric(i)%name == 'SPACE_T') THEN
      s_temp = r
    ELSE IF(geometric(i)%name == 'GEOCSRAD') THEN
      h_obs = r
    END IF
  end do

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_atmos
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

! read(11,*,iostat=io) (atmos_index(i),i=1,no_atmos)
  read(11,*,iostat=io) i                              ! ** DUMMY read
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  kk = mxco
  do j = 1, no_atmos
    Ax(1:)=' '
    read(11,'(A)',iostat=io) Ax
    if(io /= 0) goto 99
    atmospheric(j)%NAME = AdjustL(Ax)
    read(11,*,iostat=io) Spectag, ht_i
    if(io /= 0) goto 99
    atmospheric(j)%SPECTAG = Spectag
    atmospheric(j)%NO_LIN_VALUES = ht_i
    read(11,*,iostat=io) (atmospheric(j)%FWD_CALC(i),i=1,6)
    if(io /= 0) goto 99
    read(11,*,iostat=io) (atmospheric(j)%DER_CALC(i),i=1,6)
    if(io /= 0) goto 99
    read(11,*,iostat=io) (atmospheric(j)%LIN_VAL(i),i=1,kk)
    if(io /= 0) goto 99
    read(11,*,iostat=io) (atmospheric(j)%BASIS_PEAKS(i),i=1,kk+2)
    if(io /= 0) goto 99
  end do

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) band, n_sps
  if(io /= 0) goto 99

  elev_offset = 0.0                         ! Zero elev_offset in any case
! if (band >= 5) then                       ! 183
!   elev_offset = elev_183 * deg2rad
! else if (band >= 2) then                  ! 205
!   elev_offset = elev_205 * deg2rad
! else                                      ! 63 / pointing reference
!   elev_offset = 0.0
! end if

  m = 0
  do j = 1, no_atmos
    IF(atmospheric(j)%FWD_CALC(band)) THEN
      m = m + 1
      atmospheric(m) = atmospheric(j)
      if(ma < 1 .and. do_mol) then
        Ax = atmospheric(m)%NAME
        Call StrLwr(Ax)
        if(Ax == Vname) ma = m
      endif
    ENDIF
  end do
  no_atmos = m

  if(no_atmos /= n_sps) then
    io = 3
    Print *,'** Error: New code: n_sps should be equal to no_atmos !'
    Print *,'          n_sps =',n_sps,' no_atmos:',no_atmos
    goto 99
  endif

  m = 0
  pfa_spectrum(1)%NO_SPS = n_sps     ! Make sure we have this

  read(11,'(A)',iostat=io) Ax    ! pfa_spectrum(s)
  if(io /= 0) goto 99

  DO

    if(m == n_sps) then
      do
        read(11,'(A)',iostat=io) Ax
        if(io /= 0) goto 99
        if(Index(Ax,'END_CAT') > 0) EXIT
      end do
      EXIT
    endif

    Line = ' '
    Name = ' '
    read(11,'(A)',iostat=io) Line
    if(io /= 0) goto 99
    if(Index(Line,'END_CAT').gt.0) EXIT
    read(Line,*,iostat=io) Name, Spectag, nl, (Qlog(i),i=1,3)
    if(io /= 0) goto 99

    j = 0
    DO i = 1, n_sps
      if(Name == atmospheric(i)%NAME) then
        j = i
        EXIT
      endif
    END DO

    if(j < 1) then
      do i = 1, nl
        read(11,'(A)',iostat=io) Ax
        if(io /= 0) goto 99
      end do
    else
      m = m + 1
      pfa_spectrum(j)%SPS_NAME = Name
      pfa_spectrum(j)%NO_SPS = n_sps
      pfa_spectrum(j)%NO_LINES = nl
      pfa_spectrum(j)%SPS_SPECTAG = Spectag
      pfa_spectrum(j)%SPS_QLOG(1:3) = Qlog(1:3)
      do i = 1, nl
        read(11,*,iostat=io) (thbs(k),k=1,10)
        if(io /= 0) goto 99
        pfa_spectrum(j)%SPS_V0(i) = thbs(1)
        pfa_spectrum(j)%SPS_EL(i) = thbs(2)
        pfa_spectrum(j)%SPS_STR(i) = thbs(3)
        pfa_spectrum(j)%SPS_W(i) = thbs(4)
        pfa_spectrum(j)%SPS_PS(i) = 0.0    !   thbs(5)  ** DEBUG
        pfa_spectrum(j)%SPS_N(i) = thbs(6)
        pfa_spectrum(j)%SPS_DELTA(i) = thbs(7)
        pfa_spectrum(j)%SPS_N1(i) = thbs(8)
        pfa_spectrum(j)%SPS_GAMMA(i) = thbs(9)
        pfa_spectrum(j)%SPS_N2(i) = thbs(10)
      end do
    endif
!
  END DO
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_spectro, mfi
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (spect_index(i),i=1,no_spectro)
  if(io /= 0) goto 99
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  kk = mxco
  k = mfi + 2

  DEALLOCATE(s_phi_basis_copy,STAT=i)
  ALLOCATE(s_phi_basis_copy(k,no_spectro),STAT=io)
  IF(io /= 0) then
    Print *,'** ALLOCATE Error: s_phi_basis_copy, STAT =',io
    goto 99
  endif

  do j = 1, no_spectro
    Ax(1:)=' '
    read(11,'(A)',iostat=io) Ax
    if(io /= 0) goto 99
    spectroscopic(j)%TYPE = AdjustL(Ax)
    Ax(1:)=' '
    read(11,'(A)',iostat=io) Ax
    if(io /= 0) goto 99
    spectroscopic(j)%NAME = AdjustL(Ax)
    read(11,*,iostat=io) Spectag
    if(io /= 0) goto 99
    spectroscopic(j)%SPECTAG = Spectag
    read(11,*,iostat=io) ht_i
    if(io /= 0) goto 99
    spectroscopic(j)%NO_PHI_VALUES = ht_i
    read(11,*,iostat=io) ht_i
    if(io /= 0) goto 99
    spectroscopic(j)%NO_ZETA_VALUES = ht_i
    read(11,*,iostat=io) (spectroscopic(j)%DER_CALC(i),i=1,6)
    if(io /= 0) goto 99
    tau(1:k) = 0.0
    read(11,*,iostat=io) (tau(i),i=1,k)
    if(io /= 0) goto 99
    spectroscopic(j)%PHI_BASIS(1:k) = tau(1:k) * deg2rad
    s_phi_basis_copy(1:k,j) = spectroscopic(j)%PHI_BASIS(1:k)
    read(11,*,iostat=io) (spectroscopic(j)%ZETA_BASIS(i),i=1,kk+2)
    if(io /= 0) goto 99
  end do
!
! Create spect_atmos array:
!
  do k = 1, no_atmos
    Spectag = atmospheric(k)%Spectag
    do i = 1, no_spectro
      if(Spectag == spectroscopic(i)%Spectag) then
        spect_atmos(k) = i
        EXIT
      endif
    end do
  end do
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  InDir(1:)=' '
  read(11,'(A)',iostat=io) InDir
  if(io /= 0) goto 99
  InDir = AdjustL(InDir)

  Aaap(1:) = ' '
  Aaap = 'aaap.umls'

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  Ax(1:)=' '
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99
  Ax = AdjustL(Ax)

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) si,n_lvls,no_tan_hts,mnz,no_filt_pts
  if(io /= 0) goto 99
!
! Set n_obs to be: N_lvls always.
!   (Changed, Aug/6/96 Z.Shippony & W.G.Read)

  n_obs = n_lvls

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) q, r, beta_inc
  if(io /= 0) goto 99

  href(1:n_lvls) = q
  zref(1:n_lvls) = r
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (p_indx(i),i=1,n_lvls)
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (t_indx(i),i=1,no_tan_hts)
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  thbs(1:) = 0.0
  read(11,*,iostat=io) (thbs(i),i=1,si-1)   ! tan_hts_below_surface
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (z_gnlv(i),i=1,mnz)
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_t, no_phi_t
  if(io /= 0) goto 99

  if(no_mmaf < no_phi_t) then
    io = -1
    Print *,'** Error: no_mmaf < no_phi_t ...'
    Print *,'   Please correct input file and re-run !'
    goto 99
  endif

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (t_z_basis(i),i=1,no_t)
  if(io /= 0) goto 99

d204 3
a206 3
    Call Hunt(daz,t_z_basis,no_t,kz,i)
    IF(ABS(daz-t_z_basis(i)) < ABS(daz-t_z_basis(kz))) kz=i
    zco = t_z_basis(kz)
a208 57
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (t_phi_basis(i),i=1,no_phi_t)
  if(io /= 0) goto 99

  t_phi_basis(1:no_phi_t) = t_phi_basis(1:no_phi_t) * deg2rad
  t_phi_basis_copy(1:no_phi_t) = t_phi_basis(1:no_phi_t)

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) ((t_coeff(i,j),j=1,no_mmaf),i=1,no_t)
  if(io /= 0) goto 99
!
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (no_phi_f(i),i=1,no_atmos)
  if(io /= 0) goto 99

  do i = 1, no_atmos
    if(no_mmaf < no_phi_f(i)) then
      io = -1
      Print *,'** Error: no_mmaf < no_phi_f(i), i =',i
      Print *,'   Please correct input file and re-run !'
      goto 99
    endif
  end do

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (no_coeffs_f(i),i=1,no_atmos)
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (is_f_log(i),i=1,no_atmos)     ! ** A a new one !
  if(io /= 0) goto 99
!
  tau(1:mnp) = 0.0
  DO m = 1, no_atmos
    kk = no_phi_f(m)
    ht_i = no_coeffs_f(m)
    read(11,*,iostat=io) (f_basis(i,m),i=1,ht_i)
    if(io /= 0) goto 99
    tau(1:kk) = 0.0
    read(11,*,iostat=io) (tau(i),i=1,kk)
    if(io /= 0) goto 99
    f_phi_basis(1:kk,m) = tau(1:kk) * deg2rad
    f_phi_basis_copy(1:kk,m) = f_phi_basis(1:kk,m)
    read(11,*,iostat=io) ((mr_f(i,j,m),j=1,kk),i=1,ht_i)
    if(io /= 0) goto 99
  END DO

d210 7
a216 6
    ht_i = no_coeffs_f(ma)
    Call Hunt(daz,f_basis(1:,ma),ht_i,kz,i)
    IF(ABS(daz-f_basis(i,ma)) < ABS(daz-f_basis(kz,ma))) kz=i
    zco = f_basis(kz,ma)
    k = (no_phi_f(ma)+1)/2
    r = 0.05 * abs(mr_f(kz,k,ma))
d225 1
a225 1
      Ax = atmospheric(j)%NAME
d229 1
a229 1
          var = pfa_spectrum(j)%SPS_W(line_no)
d234 1
a234 1
          pfa_spectrum(j)%SPS_W(line_no) = var + dx
d236 1
a236 1
          var = pfa_spectrum(j)%SPS_N(line_no)
d241 1
a241 1
          pfa_spectrum(j)%SPS_N(line_no) = var + dx
d243 1
a243 1
          var = pfa_spectrum(j)%SPS_V0(line_no)
d245 1
a245 1
          pfa_spectrum(j)%SPS_V0(line_no) = var + dx
a251 14
  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) no_freqs
  if(io /= 0) goto 99

  read(11,'(A)',iostat=io) Ax
  if(io /= 0) goto 99

  read(11,*,iostat=io) (freq_grid(i),i=1,no_freqs)
  if(io /= 0) goto 99

  CLOSE(11,iostat=i)

a259 18
  fft_pts = 10

! Get all the filter's loaded & define:
!
  Call get_filters(no_pfa_ch,no_filt_pts,pfa_ch,f_grid_filter, &
 &                 freqs,filter_func,InDir,ld,primag,ier)
  if(ier /= 0) goto 99
!
! Get the selected integration grid pressures. Also, define the GL
! pressure grid:

  z_grid(1:) = 0.0
  DO i = 1, n_lvls
    j = p_indx(i)
    z_grid(i) = z_gnlv(j)
  END DO
  z_grid(n_lvls+1) = z_grid(n_lvls)
!
d263 3
a265 3
    k = (no_mmaf+1)/2
    var = t_coeff(kz,k)
    t_coeff(kz,k) = var + dx
d267 3
a269 3
    k = (no_phi_f(ma)+1)/2
    var = mr_f(kz,k,ma)
    mr_f(kz,k,ma) = var + dx
d276 2
a277 2
  phi_tan = phi_tan_mmaf(mmaf)
  Call geoc_geod_conv(beta_inc,phi_tan,geoc_lat,E_rad)
d281 7
a287 4
  Call hydrostatic_model(si,N_lvls,no_t,no_mmaf,t_indx,   &
       no_tan_hts, geoc_lat, Href, Zref, z_grid, thbs, t_z_basis,  &
       t_coeff, z_glgrid, h_glgrid, t_glgrid, dhdz_glgrid,         &
       dh_dt_glgrid, tan_press, tan_hts, tan_temp, tan_dh_dt,      &
d292 3
a294 105
  Call Hunt(Zeta,tan_press,no_tan_hts,jj,i)
  IF(ABS(Zeta-tan_press(i)) < ABS(Zeta-tan_press(jj))) jj = i
!
! Load the pointing vs. frequencies database for the given band
! (needed for frequency averaging)
!
  Fnd(1:) = ' '
! Fnd = '/home/zvi/ptg_frq_grid_bxx.dat'     ! HOME PC
  Fnd = '/user5/zvi/ptg_frq_grid_bxx.dat'    ! SUN, MLSGATE
  i = index(Fnd,'_bxx.dat')
  write(Fnd(i+2:i+3),'(i2.2)') band
!
  kk = -1
  no_ptg_frq(1:Nptg) = 0
!
  Close(32,iostat=i)
  Open(32,file=Fnd,action='READ',status='OLD',iostat=io)
  if(io /= 0) goto 44
!
! First entry in the file is the 'Band' frequency. All the rest are
! relative to this (center) frequency for this band
!
  Read(32,*,iostat=io) q
  if(io /= 0) goto 44
!
  DO
    Read(32,*,iostat=io) r, jp
    if(io > 0) goto 44
    if(io /= 0) EXIT
    Call Hunt(r,tan_press,no_tan_hts,k,i)
    IF(ABS(r-tan_press(i)) < ABS(r-tan_press(k))) k = i
    if(ABS(r-tan_press(k)) > 0.001) &
   &       Print *,'** Warning: Zeta:',r,' k:',k
    no_ptg_frq(k) = jp
    DEALLOCATE(ptg_frq_grid(k)%values,STAT=i)
!   ALLOCATE(ptg_frq_grid(k)%values(jp),STAT=i)
        j = max(53,jp)                                  ! ** DEBUG
        ALLOCATE(ptg_frq_grid(k)%values(j),STAT=i)      ! ** DEBUG
        no_ptg_frq(k) = j                               ! ** DEBUG
    IF(i /= 0) THEN
      ier = i
      PRINT *,'** Error: ALLOCATION error for ptg_frq_grid ..'
      PRINT *,'   tan_hts index:',k,' STAT =',ier
      do l = 1, k
        DEALLOCATE(ptg_frq_grid(l)%values,STAT=i)
      end do
      goto 99
    ENDIF
    Read(32,*,iostat=io) (ptg_frq_grid(k)%values(i),i=1,jp)
    if(io /= 0) goto 44
    if(kk < 0) kk = k
!
! Add 'band' frequency to ptg_frq_grid to convert to absolute grid
!
    ptg_frq_grid(k)%values(1:jp) = ptg_frq_grid(k)%values(1:jp) + q
!
  END DO
!
  if(kk > 1) then
    jp = no_ptg_frq(kk)
    do k = 1, kk-1
      DEALLOCATE(ptg_frq_grid(k)%values,STAT=i)
      ALLOCATE(ptg_frq_grid(k)%values(jp),STAT=i)
      IF(i /= 0) THEN
        ier = i
        PRINT *,'** Error: ALLOCATION error for ptg_frq_grid ..'
        PRINT *,'   tan_hts index:',k,' STAT =',ier
        do l = 1, k
          DEALLOCATE(ptg_frq_grid(l)%values,STAT=i)
        end do
        goto 99
      ENDIF
      no_ptg_frq(k) = jp
      ptg_frq_grid(k)%values(1:jp) = ptg_frq_grid(kk)%values(1:jp)
    end do
  endif
!
 44 Close(32,iostat=i)
    if(io > 0) then
      ier = io
      goto 99
    else
      io = 0
    endif
!
    if(Zfrq > 0.0) then
      kk = no_ptg_frq(jj)
      Call Hunt(Zfrq,ptg_frq_grid(jj)%values,kk,i,j)
      IF(ABS(Zfrq-ptg_frq_grid(jj)%values(j)) <    &
         ABS(Zfrq-ptg_frq_grid(jj)%values(i))) i=j
      ptg_frq_grid(jj)%values(i) = Zfrq
      Freq_Index = i
    endif
!
!  **** DEBUG
!
    jp = no_ptg_frq(jj)
    do i = 1, no_tan_hts
      if(i /= jj) then
        no_ptg_frq(i)=no_ptg_frq(jj)
        ptg_frq_grid(i)%values(1:jp)=ptg_frq_grid(jj)%values(1:jp)
      endif
    end do
!
!  **** END DEBUG
d298 7
a304 6
  Call comp_path_entities(n_lvls,no_t,gl_count,ndx_path,z_glgrid,  &
 &     t_glgrid,h_glgrid,dhdz_glgrid,dh_dt_glgrid,atmospheric,     &
 &     no_atmos,f_basis,mr_f,no_coeffs_f,tan_hts,no_tan_hts,n_sps, &
 &     no_phi_f,f_phi_basis,z_path,h_path,t_path,phi_path,n_path,  &
 &     dhdz_path,dh_dt_path,no_phi_t,t_phi_basis,spsfunc_path,     &
 &     is_f_log,no_mmaf,phi_tan_mmaf,Ier)
d311 1
a311 1
  phi_tan = phi_tan_mmaf(l)
d313 1
a313 1
  t_phi_basis(1:no_phi_t) = t_phi_basis_copy(1:no_phi_t) + phi_tan
d315 3
a317 3
  DO j = 1, no_atmos
    k = no_phi_f(j)
    f_phi_basis(1:k,j) = f_phi_basis_copy(1:k,j) + phi_tan
d320 3
a322 3
  k = mfi + 2
  do j = 1, no_spectro
    spectroscopic(j)%PHI_BASIS(1:k) = s_phi_basis_copy(1:k,j) + phi_tan
d328 4
a331 4
  Call get_chi_angles(ndx_path(1:,l),n_path(1:,l),tan_press,tan_hts(1:,l),&
 &     tan_temp(1:,l),phi_tan,RoC,h_obs,elev_offset,tan_dh_dt(1:,l,1:),   &
 &     no_tan_hts,no_t,t_z_basis,si,center_angle,ptg_angles(1:,l),dx_dt,  &
 &     d2x_dxdt,ier)
d350 1
a350 1
    kk = no_ptg_frq(k)
d354 6
a359 1
      f_grid(1:mnf) = 0.0
d365 2
a366 2
    Call get_beta_path(ptg_i,pfa_spectrum,no_ele,no_ptg_frq, &
   &     ptg_frq_grid,z_path(ptg_i,l),t_path(ptg_i,l),beta_path,ier)
d369 2
a370 10
    RadV(1:mnf) = 0.0
    f_grid(1:kk) = ptg_frq_grid(k)%values(1:kk)
!
    k1 = 1
    k2 = kk

    if(Freq_Index > 0) then
      k1 = Freq_Index
      k2 = Freq_Index
    endif
d372 1
a372 1
    do frq_i = k1, k2
d376 1
a376 1
      Call Rad_Tran(Frq, N_lvls, h_tan, n_sps, ndx_path(k,l),  &
d378 2
a379 2
     &    dHdz_path(k,l), earth_ref, beta_path(1:,frq_i),      &
     &    spsfunc_path(1:,k,l), ref_corr(1:,k), s_temp, brkpt, &
d391 4
a394 4
!
    if(do_frqavg) then
      Call Freq_Avg(f_grid,F_grid_filter(1:,i),Filter_func(1:,i), &
   &                RadV,kk,no_filt_pts,Radiances(ptg_i))
d396 1
a396 1
      Radiances(ptg_i) = RadV(Freq_Index)
d406 1
a406 1
  if(do_conv) then
d410 3
a412 3
    Call convolve_rad (ptg_press, tan_press, ptg_angles(1:,l), &
         band, center_angle, fft_pts, Radiances, &
         no_tan_hts, i_star_all, InDir, Aaap, Ier)
d419 2
a420 1
    Call no_convolve_rad (ptg_press,tan_press,Radiances,no_tan_hts,i_star_all)
d426 1
a426 1
  if(do_conv) then
d432 2
a433 2
  if(Freq_Index > 0) then
    Frq = ptg_frq_grid(jj)%values(Freq_Index)
d444 1
a444 1
  kk = ptg_press%no_lin_values
a484 75
SUBROUTINE radiometry(ch, f_p, f_i, db_fi, lmt)

! This subroutine calculates the center frequency of the primary and image
! sideband by channel. It also Returns the bandwidth limits of integration
! and the gain of the primary sideband relative to the image in db units.

INTEGER(i4), INTENT(IN) :: ch
INTEGER(i4), INTENT(OUT) :: lmt

REAL(r8), INTENT(OUT) :: f_p
REAL(r8), INTENT(OUT) :: f_i
REAL(r8), INTENT(OUT) :: db_fi

LOGICAL, SAVE :: sgn_fp(6) = (/                                    &
                 .false., .true., .false., .true., .true., .false./)

INTEGER(i4) :: band, sub_ch, j

Real(r4), SAVE :: db_fi_data(90) =(/                   &
     &    -0.5218,  0.0000,  0.5218,  0.8264,  0.9654, &
     &     1.0332,  1.0668,  1.0890,  1.1111,  1.1440, &
     &     1.2091,  1.3365,  1.5807,  0.3476, -3.6798, &
     &    -1.7854, -1.6204, -1.5519, -1.5142, -1.4966, &
     &    -1.4884, -1.4840, -1.4811, -1.4783, -1.4741, &
     &    -1.4659, -1.4486, -1.4167, -1.3607, -1.2602, &
     &    -1.0409, -1.1206, -1.1641, -1.1874, -1.1995, &
     &    -1.2052, -1.2084, -1.2104, -1.2124, -1.2157, &
     &    -1.2216, -1.2347, -1.2607, -1.3128, -1.4233, &
     &    -1.0921, -1.2329, -1.2863, -1.3121, -1.3234, &
     &    -1.3284, -1.3309, -1.3327, -1.3343, -1.3367, &
     &    -1.3416, -1.3507, -1.3667, -1.3884, -1.4035, &
     &     0.6661,  0.6480,  0.7759,  0.8029,  0.8741, &
     &     0.8307,  0.9736,  0.9273,  0.5800,  0.8906, &
     &     0.9772,  0.9596,  0.9426,  0.8669,  0.7433, &
     &     0.3108,  1.0632,  0.7029,  0.4426,  0.2910, &
     &     0.2261,  0.2396,  0.2244,  0.2237,  0.1811, &
     &     0.1795,  0.1534,  0.1418,  0.3651,  0.5647 /)
!

REAL(r8), SAVE :: f_prime(6) = (/                          &
    63568.418D0, 204352.161D0, 204574.627D0, 206132.067D0, &
    183310.062D0, 184377.788D0/)

REAL(r8), SAVE :: f_image(6) = (/                          &
    62997.812D0, 202181.555D0, 201959.089D0, 200401.648D0, &
    186245.513D0, 185177.788D0/)

REAL(r8) :: ch_offset

  band = (ch - 1) / 15 + 1
  sub_ch = ch - 15 * (band - 1)
!
  IF(sub_ch == 8) THEN
    j = 0
    lmt = 1
  ELSE                      ! Above and below the spectral center
    lmt = 2**(ABS(sub_ch - 8) - 1)
    j = SIGN(3*lmt - 1, sub_ch - 8)
  END IF

  ch_offset = float(j)
  db_fi = db_fi_data(ch)

  IF(sgn_fp(band)) THEN
    f_p = f_prime(band) + ch_offset
    f_i = f_image(band) - ch_offset
  ELSE
    f_p = f_prime(band) - ch_offset
    f_i = f_image(band) + ch_offset
  END IF

  Return
END SUBROUTINE radiometry

!---------------------------------------------------------------------------
d491 2
a492 1
           InDir,Aaap,Ier)
d494 1
a494 1
    integer(i4), intent(IN) :: no_tan_hts, band, fft_pts
d496 1
a496 1
    real(r8), intent(IN) :: CENTER_ANGLE
d500 2
a501 2
!
    Character(LEN=*), intent(IN) :: InDir, Aaap
d532 1
a532 1
   &                  fft_pts,InDir,Aaap,Ier)
@


1.2
log
@New version of forward model
@
text
@d3 12
a14 18
  use EOS_MDB
  use L2PC_FILE_PARAMETERS, mnsv => MAX_NO_SV_ELMNTS, &
                            mxco => MAX_NO_ELMNTS_PER_SV_COMPONENT
  use L2PC_PFA_STRUCTURES
  use L2PC_FILE_STRUCTURES
  use L2PCdim
  use MLSCommon
  use EARTH_INTERSECTION_M, only: EARTH_INTERSECTION
  use STRINGS
  use MDBETA
  use ELLIPSE
  use GEO_GRIDS_M
  use GEOC_GEOD_CONV_M, only: GEOC_GEOD_CONV
  use GET_BETA_PATH_M, only: GET_BETA_PATH
  use FILTER_SW_M, only: FILTER
  use DSIMPSON_MODULE, only: SIMPS
  use TWO_D_POLATE_M, only: TWO_D_POLATE
  use REFRACTION_M
d17 7
a23 4
  use DO_T_SCRIPT_M, only: DO_T_SCRIPT
  use FAST_DELTA_M, only: FAST_DELTA
  use FAST_ZOPACITY_M, only: FAST_ZOPACITY
  use SCRT_DN_M, only: SCRT_DN
d25 2
a26 1
  use D_HUNT_M, only: HUNT
d28 1
a28 1
  implicit NONE
d31 1
a31 1
Integer(i4), PARAMETER :: Npath = (Ng+1) * N2lvl
d37 1
a37 1
               no_spectro, pfa_ch(MAXPFACH), jpm, klo, kz, ma
d39 28
a66 18
Integer(i4) :: i, j, k, kk, ht_i, no_t, mnz, no_geom, no_tan_hts, ld, &
               no_atmos, ch1, ch2, n_lvls, si, mfi, band, n_sps, Spectag, &
               no_freqs, ptg_i, frq_i, io, m, brkpt, no_ele, &
               mid, ilo, ihi, no_pfa_ch, n_obs, ier, no_filt_pts, no_phi_t

Type(path_index)  :: ndx_path(Nptg)
Type(path_vector) :: z_path(Nptg),t_path(Nptg),h_path(Nptg), &
                     n_path(Nptg),phi_path(Nptg),dhdz_path(Nptg), &
                     spsfunc_path(Nsps,Nptg),ptg_frq_grid(Nptg)

Type(path_derivative) :: dh_dt_path(Nptg)

Real(r8) :: href(Nlvl), zref(Nlvl), tan_hts(Nptg), dx, zco, &
            tan_hts_raw(Nptg), tan_press(Nptg), tan_temp(Nptg), &
            t_coeff(mxco,mnp), t_z_basis(mxco), t_phi_basis(mnp), &
            tan_dh_dt(Nlvl,mxco),z_grid(Nlvl), Frq, h_tan, Rad, &
            t_grid(Nlvl),h_grid(Nlvl),z_gnlv(400), e_rad, var, daz, &
            ref_corr(N2lvl,Nptg), t_script(N2lvl), tau(N2lvl)
d69 6
a75 3
real(r8) :: MR_F(mxco,mnp,Nsps)
real(r8) :: C_FREQ(Nch),freq_grid(mnf)
real(r8) :: F_BASIS(mxco,Nsps), PHI_BASIS_F(mnp,Nsps)
d79 1
d81 1
a81 1
Type(path_beta) :: beta_path(Nsps,mnf,Nptg)
d84 11
a94 7
Real(r8) :: RadV(mnf),f_grid(mnf)
Real(r8) :: S_TEMP, H_OBS, EARTH_REF, q, r
!
Character :: Primag
Character (LEN=08) :: dName,Vname
Character (LEN=40) :: Ax, Fdata
Character (LEN=80) :: InDir, Fnd, Line
d96 1
a96 3
Logical :: do_mol

Type (l2pc_header_one) :: HEADER1
d99 1
a99 1
Type (pfa_slab)        :: PFA_SPECTRUM(6,Nsps)
d102 2
d105 20
a124 1
! Read the inputs from a file...
d127 4
a130 3
  Fdata(1:) = ' '
  Fdata = '/user5/zvi/seez'     ! SUN, MLSGATE
! Fdata = '/home/zvi/seez'      ! HOME PC
d132 1
a132 1
  OPEN(11,file=Fdata,status='OLD',action='READ',iostat=io)
d142 1
d172 6
a177 2
    do_mol = .true.
    if(j == 2) zco = daz
d185 1
d194 13
d210 2
a211 2
  kk = 0
  read(11,*,iostat=io) kk
d214 10
a223 2
  HEADER1%NO_POINTINGS = kk
  read(11,*,iostat=io) (HEADER1%sv_components(i),i=1,kk)
d225 2
a226 1
  read(11,*,iostat=io) (HEADER1%no_elmnts_per_sv_component(i),i=1,kk)
d228 2
a229 9
  read(11,*,iostat=io) (HEADER1%sv_component_first_elmnt_index(i),i=1,kk)
  if(io /= 0) goto 99
  read(11,*,iostat=io) HEADER1%no_bands
  if(io /= 0) goto 99
  read(11,*,iostat=io) HEADER1%no_channels_per_band
  if(io /= 0) goto 99
  read(11,*,iostat=io) HEADER1%no_sv_components
  if(io /= 0) goto 99
  read(11,*,iostat=io) HEADER1%no_coeff_per_component
d235 1
a235 1
  read(11,*,iostat=io) ch1, ch2
d237 9
a245 1

d249 1
a249 1
  read(11,*,iostat=io) no_pfa_ch
d252 1
a252 1
  read(11,'(A)',iostat=io) Ax
d255 2
a256 1
  read(11,*,iostat=io) (pfa_ch(i),i=1,no_pfa_ch)
d269 1
a269 1
    read(11,*,iostat=io) GEOMETRIC(i)
d271 12
a306 5
    if(ma < 1 .and. do_mol) then
      Ax = atmospheric(j)%NAME
      Call StrLwr(Ax)
      if(Ax == Vname) ma = j
    endif
d327 9
d341 5
d357 4
a360 1
  read(11,'(A)',iostat=io) Ax
d362 15
a376 2
  do i = 1, n_sps
    read(11,*,iostat=io) pfa_spectrum(band,i)%NO_SPS
d378 2
a379 1
    read(11,*,iostat=io) pfa_spectrum(band,i)%NO_LINES
a380 3
    read(11,*,iostat=io) pfa_spectrum(band,i)%SPS_SPECTAG
    if(io /= 0) goto 99
  end do
d382 38
d436 9
d465 2
a466 1
    read(11,*,iostat=io) (spectroscopic(j)%PHI_BASIS(i),i=1,mfi+2)
d468 2
d494 3
d500 2
a501 2
  Fnd(1:)=' '
  read(11,'(A)',iostat=io) Fnd
d503 1
a503 1
  Fnd = AdjustL(Fnd)
d510 5
d519 1
a519 1
  read(11,*,iostat=io) q, r, phi_tan   !, geoc_lat
d534 8
a541 1
  read(11,*,iostat=io) (z_gnlv(i),i=1,mnz)
d547 1
a547 1
  read(11,*,iostat=io) (tan_hts_raw(i),i=1,no_tan_hts)
d556 7
d581 3
d587 1
a587 1
  read(11,*,iostat=io) ((t_coeff(i,j),j=1,no_phi_t),i=1,no_t)
d589 1
a589 1

d596 9
d616 2
a617 1

d623 2
a624 1
    read(11,*,iostat=io) (phi_basis_f(i,m),i=1,kk)
d626 2
d637 5
a641 7
    if(dName == 'dmr') then
      k = (no_phi_f(ma)+1)/2
      r = 0.05 * abs(mr_f(kz,k,ma))
      q = sign(1.0_r8,dx) * max(1.0d-8,r)
      dx = q
      Print *,'** Modified Step Size:',Sngl(dx)
    endif
d644 30
a688 1
  r = abs(dx)
d691 1
a691 1
  Print *, 'Step Size: ',Sngl(r)
d695 2
d698 6
d707 1
d714 2
a715 9
  jpm = 0
  Radiances(1:Nptg) = 0.0

  if(dName == 'dw' .or. dName == 'dn' .or. dName == 'dnu') then
    jpm = 1
    zco = daz
    if(dx < 0.0) jpm = -1
  endif

d717 1
a717 1
    k = (no_phi_t+1)/2
a725 186
  Primag = 'p'
  Call fwd_mdl_set_up(Primag,href,zref,e_rad,z_grid,t_grid,h_grid,    &
 &     ndx_path,n_lvls,geometric,no_geom,t_z_basis,t_coeff,no_t,      &
 &     atmospheric,no_atmos,f_basis,mr_f,no_coeffs_f,c_freq, &
 &     si,earth_ref,s_temp,h_obs,n_obs,tan_hts_raw,tan_hts,tan_press, &
 &     tan_temp,no_tan_hts,n_sps,no_pfa_ch,no_filt_pts,  &
 &     pfa_ch,pfa_spectrum,f_grid_filter,filter_func,ch1,ch2,InDir,ld,&
 &     band,no_phi_f,phi_basis_f,z_path,h_path,t_path,phi_path,n_path,&
 &     dhdz_path,dh_dt_path,Npath,no_phi_t,t_phi_basis,spectroscopic,&
 &     no_spectro,tan_dh_dt,spsfunc_path,no_ptg_frq,ptg_frq_grid,     &
 &     is_f_log,beta_path,jpm,ier)
  IF(ier /= 0) goto 99

  if(dName == 'dt') then
    k = (no_phi_t+1)/2
    t_coeff(kz,k) = var
  else if(dName == 'dmr') then
    k = (no_phi_f(ma)+1)/2
    mr_f(kz,k,ma) = var
  endif
!
! Compute the refraction correction scaling matrix:
!
  CALL refraction_correction(no_tan_hts, tan_hts, h_path, n_path, &
 &                           ndx_path, E_rad, ref_corr)
!
! Now, Compute the radiances alone:
!
  Call Hunt(daz,tan_press,no_tan_hts,klo,i)
  IF(ABS(daz-tan_press(i)) < ABS(daz-tan_press(klo))) klo=i

  do ptg_i = 1, no_tan_hts-1
!
    k = ptg_i
    h_tan = tan_hts(k)
    kk = no_ptg_frq(k)
!
    RadV(1:mnf) = 0.0
    f_grid(1:kk) = ptg_frq_grid(k)%values(1:kk)
!
    do frq_i = 1, kk
!
      Frq = ptg_frq_grid(k)%values(frq_i)
!
      Call Rad_Tran(Frq, N_lvls, h_tan, n_sps, ndx_path(k),  &
     &    z_path(k), h_path(k), t_path(k), phi_path(k), dHdz_path(k), &
     &    earth_ref, beta_path(1:,frq_i,k), spsfunc_path(1:,k),       &
     &    ref_corr(1:,k), s_temp, brkpt, no_ele, mid, ilo, ihi,       &
     &    t_script, tau, Rad, Ier)
      IF(ier /= 0) goto 99
!
      RadV(frq_i) = Rad
!
    end do
!
! Frequency Average the radiances with the appropriate filter shapes
!
    i = 1
    Call Freq_Avg(f_grid,F_grid_filter(1:,i),Filter_func(1:,i), &
   &              RadV,kk,maxfiltpts,Rad,Ier)
    IF(ier /= 0) goto 99
    Radiances(ptg_i) = Rad

  end do
!
  j = no_tan_hts
  Radiances(j) = Radiances(j-1)

    kk = j - si + 1
    write(*,903) char(92),kk
    write(*,904) (Radiances(k),k=si,j)
903 format('avg_pfa_rad',a1,i2.2)
904 format(4(2x,1pg17.10))

 99  CLOSE(11,iostat=i)
     if(io /= 0) Call ErrMsg(' ',io)

     Stop

!----------------------------------------------------------------
contains
!----------------------------------------------------------------

Function I2C(n)

Integer n
Character(LEN=12) I2C,Zx

   Zx(1:)=' '
   write(Zx,*) n
   I2C = AdjustL(Zx)

end Function I2C

!----------------------------------------------------------------

SUBROUTINE fwd_mdl_set_up(primag,href,zref,e_rad,z_grid,t_grid,h_grid,  &
           ndx_path,n_lvls,geometric,no_geom,t_z_basis,t_coeff,no_t,    &
           atmospheric,no_atmos,f_basis,mr_f,no_coeffs_f,freq, &
           si,earth_ref,s_temp,h_obs,n_obs,tan_hts_raw,tan_hts,tan_press,&
           tan_temp,no_tan_hts,n_sps,no_pfa_ch,no_filt_pts, &
           pfa_ch,pfa_spectrum,f_grid_fltr,fltr_func,ch1,ch2,InDir,ld,   &
           band,no_phi_f,phi_basis_f,z_path,h_path,t_path,phi_path,n_path,&
           dhdz_path,dh_dt_path,npath,no_phi_t,t_phi_basis,   &
           spectroscopic,no_spectro,tan_dh_dt,spsfunc_path,no_ptg_frq,  &
           ptg_frq_grid,is_f_log,beta_path,jpm,ier)

!  ===============================================================
!  Declaration of variables for sub-program: fwd_mdl_set_up
!  ===============================================================

Integer(i4), PARAMETER :: ngt = (Ng+1) * Nlvl

!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: n_lvls, no_atmos, no_t, ch1, ch2, jpm,  &
             no_phi_t, no_coeffs_f(:), no_phi_f(:), band, n_sps, &
             no_spectro, npath, si, no_pfa_ch, no_filt_pts, pfa_ch(:)
!
Integer(i4), INTENT(IN OUT) :: no_tan_hts, no_geom, ld

Integer(i4), INTENT(OUT) :: n_obs,no_ptg_frq(:),ier

!
Real(r8), INTENT(IN) :: z_grid(:), href(:), zref(:), &
          t_phi_basis(:), t_coeff(:,:), t_z_basis(:), &
          mr_f(:,:,:), phi_basis_f(:,:), f_basis(:,:)
!
Real(r8), INTENT(OUT) :: tan_hts(:), tan_dh_dt(:,:)
Real(r8), INTENT(IN OUT) :: tan_hts_raw(:)

Type(path_beta), INTENT(OUT) :: beta_path(:,:,:)
!

Type(path_index) , INTENT(OUT) :: ndx_path(:)
Type(path_vector), INTENT(OUT) :: z_path(:),t_path(:),h_path(:), n_path(:), &
             phi_path(:), dhdz_path(:), spsfunc_path(:,:), ptg_frq_grid(:)

Type(path_derivative), INTENT(OUT) :: dh_dt_path(:)

Real(r8), INTENT(OUT) :: e_rad,earth_ref,s_temp,h_obs,freq(:), &
          tan_temp(:),t_grid(:),h_grid(:),tan_press(:), &
          fltr_func(:,:),f_grid_fltr(:,:)

Logical, INTENT(IN) :: is_f_log(*)
!
Character (LEN=*), INTENT(IN) :: InDir
Character (LEN=*), INTENT(IN) :: primag
!  ----------------------
!  Local variables:
!  ----------------

Logical :: wet
Integer(i4) :: i, j, k, jp, io, ich, sps_i, geo_i, geo_j, ih2o, kk, &
               no_geom_new, gl_count

Real(r4) :: def_val(maxgeom) = (/                                    &
            0.0, 0.0, 0.0, 0.0, 90.0, 0.0, 0.0, 0.0, 6972.0, 6372.0, &
            0.05, 2.735, 1.0 /)

Type(path_vector) :: h2o_path(Nptg)

Real(r8) :: q,r,p,g,rp,beta_inc,zeta,phi,geoc_lat

Character (LEN=80) :: Fnd
Character (LEN=8) :: geomname(maxgeom) = (/                         &
         &  'ELEV_183','ELEV_205','AZIM_183','AZIM_205','AZIM_REF', &
         &  'ROLL    ','PITCH   ','YAW     ','GEOCSRAD','GEOCERAD', &
         &  'EARTHREF','SPACE_T ','LOOK_DIR'/)

!  PFA variables:

type (geom_param),    intent(inout) :: GEOMETRIC(*)
type (atmos_comp),    intent(inout) :: ATMOSPHERIC(*)
type (spectro_param), intent(inout) :: SPECTROSCOPIC(*)
type (pfa_slab), intent(inout)      :: PFA_SPECTRUM(6,*)
!
! Set up the default geometric linearization values of earth radius,earth
! emission,background space temperature and satellite position.
! Compute the default geocentric earth radius

  ier = 0

  beta_inc = 98.0D0                ! Orbit inclination angle for EOS-MLS
!
d729 12
a740 45
  Call geoc_geod_conv('d2c',beta_inc,phi_tan,geoc_lat,rp)
!
! Convert the t_phi_basis to radians and add phi_tan:
!
  do j = 1, no_phi_t
    t_phi_basis(j) = deg2rad * t_phi_basis(j) + phi_tan
  end do
!
! Convert the phi_basis_f to radians and add phi_tan:
!
    do j = 1, n_sps
      i = no_phi_f(j)
      phi_basis_f(1:i,j) = deg2rad * phi_basis_f(1:i,j) + phi_tan
    end do
!
! Convert the spectroscopic to radians and add phi_tan:
!
  do j = 1, no_spectro
    i = spectroscopic(j)%NO_PHI_VALUES
    spectroscopic(j)%PHI_BASIS(1:i) = &
   &        deg2rad * spectroscopic(j)%PHI_BASIS(1:i) + phi_tan
  end do

! Call the grids program to get the preselected integration heights and
! pointings. Also transfer the pointings expressed in pressure units to
! heights.  Also, set up geophysical parameters (for derivatives):
! [The following routine replaces the older code using the two routines:
!  grids() and geo_basis() ]

! (z_grid,t_grid,h_grid) are the arrays of the preselected integration grid.

  CALL geo_grids(z_grid,t_grid,h_grid,tan_dh_dt,n_lvls,t_z_basis,    &
       t_coeff,si,tan_hts,tan_hts_raw,tan_press,tan_temp,no_tan_hts, &
       z_path,h_path,t_path,phi_path,dhdz_path,dh_dt_path,Npath,g,href, &
       zref,geoc_lat,no_t,no_phi_t,t_phi_basis,ndx_path,ier)
  IF(ier /= 0) Return

  ps = -1.0D0

  e_rad = rp
  def_val(10) = e_rad

! Default earth emission

  earth_ref = def_val(11)
d742 3
a744 123
! Default satellite position

  h_obs = def_val(9)

! Default space temperature

  s_temp = def_val(12)
!
! Scan geometric quantities for specific values of the above if user wants
! to override the defaults

  no_geom_new = no_geom
  DO geo_i = 1, maxgeom

! Search the geometric parameters for inclusion of "vital" quantities
! Insert defaults if these do not presently exist

    geo_j = 1
    DO WHILE(geometric(geo_j)%name /= geomname(geo_i) .AND.  &
          geo_j < no_geom )
      geo_j = geo_j + 1
    END DO

    IF(geometric(geo_j)%name /= geomname(geo_i) ) THEN

! Meaning it did not find it

      no_geom_new = no_geom_new + 1
      geometric(no_geom_new)%name = geomname(geo_i)

      DO i = 1, max_no_bands
        geometric(no_geom_new)%der_calc(i) = .false.
      END DO

      geometric(no_geom_new)%lin_val = def_val(geo_i)

      IF(geomname(geo_i) /= 'LOOK_DIR') THEN
        Print *,' WARNING: ',geometric(no_geom_new)%name, &
     &          ' NOT FOUND IN USER INPUTS'
        Print *,' ASSUMING ',geometric(no_geom_new)%lin_val, &
     &          ' FOR THIS QUANTITY'
      END IF

    ELSE

! It is there and set up internal parameters accordingly
! If applicable place the earth radius in the state vector

      IF(geometric(geo_j)%name == 'GEOCERAD') THEN

! Force geometric earth radius value to be value appropriate for the
! latitude bin

        geometric(geo_j)%lin_val = def_val(10)

!           E_rad = geometric(geo_j)%lin_val

! Look for earth emission

      ELSE IF(geometric(geo_j)%name == 'EARTHREF') THEN

        earth_ref = geometric(geo_j)%lin_val

! Look for the background space temperature

      ELSE IF(geometric(geo_j)%name == 'SPACE_T') THEN

        s_temp = geometric(geo_j)%lin_val

! Look for satellite position

      ELSE IF(geometric(geo_j)%name == 'GEOCSRAD') THEN

        h_obs = geometric(geo_j)%lin_val

      END IF

    END IF

  END DO

  no_geom = no_geom_new
!
  DO ich = 1, nch
    freq(ich) = 0.0D0
  END DO

  DO ich = ch1, ch2
    CALL radiometry(ich,q,r,p,kk)       ! DEBUG, Added Jan/23/2000, Z.S
    IF(primag == 'p') freq(ich) = q     ! DEBUG, Added Jan/23/2000, Z.S
    IF(primag == 'i') freq(ich) = r     ! DEBUG, Added Jan/23/2000, Z.S
  END DO
!
! Create the specie function along the path for all species
!
  DO k = 1, no_tan_hts
    gl_count = ndx_path(k)%total_number_of_elements
    do j = 1, n_sps
      jp = no_phi_f(j)
      kk = no_coeffs_f(j)
      DEALLOCATE(spsfunc_path(j,k)%values,STAT=i)
      ALLOCATE(spsfunc_path(j,k)%values(gl_count),STAT=i)
      IF(i /= 0) THEN
        ier = i
        PRINT *,'** Error: ALLOCATION error for spsfunc_path ..'
        PRINT *,'   STAT =',ier
        Return
      ENDIF
      do i = 1, gl_count
        zeta = z_path(k)%values(i)
        phi = phi_path(k)%values(i)
        if (is_f_log(j)) then
          Call TWO_D_POLATE(f_basis(1:,j), LOG(mr_f(1:kk,1:jp,j)), &
         &                  kk, phi_basis_f(1:,j), jp, zeta, phi, r)
          q = exp(r)
        else
          Call TWO_D_POLATE(f_basis(1:,j), mr_f(1:kk,1:jp,j), kk,  &
         &                  phi_basis_f(1:,j), jp, zeta, phi, q)
        endif
        spsfunc_path(j,k)%values(i) = q
      end do
    end do
  END DO
d759 1
a759 1
  Open(32,file=Fnd,action='READ',iostat=io)
d778 4
a781 1
    ALLOCATE(ptg_frq_grid(k)%values(jp),STAT=i)
d786 4
a789 1
      Return
d810 4
a813 1
        Return
d821 37
a857 4
  if(io > 0) then
    ier = io
    Return
  endif
d859 1
a859 2
! Set n_obs to be: N_lvls always.
!   (Changed, Aug/6/96 Z.Shippony & W.G.Read)
d861 5
a865 1
  n_obs = n_lvls
d867 4
a870 1
!  *** Special PC code - check if number of Keys will exceed maximum:
d872 13
a884 4
  kk = 3                ! x_star key + i_star key + Ptan63 Key
  DO geo_i = 1, no_geom
    IF(geometric(geo_i)%der_calc(band)) kk = kk + 1
  END DO
d886 35
a920 4
  DO sps_i = 1, no_atmos
    j = no_phi_f(sps_i) * no_coeffs_f(sps_i)
    kk = kk + j
  END DO
d922 19
a940 5
  DO i = 1, no_spectro
    j = spectroscopic(i)%no_phi_values
    j = j * spectroscopic(i)%no_zeta_values
    kk = kk + j
  END DO
d942 59
a1000 7
  IF(kk >= max_no_key_addr) THEN
    ier = 1
    PRINT *,'** Error in fwd_mdl_set_up subroutine **'
    PRINT *,'   Number of records exceeded maximum. kk =',kk
    PRINT *,'   Maximum number of records allowed =',max_no_key_addr
    Return
  END IF
d1002 8
a1009 1
!  *** End Special PC code
d1011 1
a1011 2
! Compute the relative refractive index minus one.
! Get the water mixing ratio function
d1013 7
a1019 4
  sps_i = 1
  DO WHILE (atmospheric(sps_i)%name /= 'H2O' .AND. sps_i <= no_atmos)
    sps_i = sps_i + 1
  END DO
d1021 4
a1024 7
  IF (atmospheric(sps_i)%name == 'H2O') THEN
    j = sps_i
    ih2o = sps_i
  ELSE             ! Ignore water contribution to refractive index (dry air)
    j = 1
    ih2o = 0
  END IF
d1026 7
a1032 16
  wet = (ih2o > 0)
  jp = no_phi_f(j)
  kk = no_coeffs_f(j)
  CALL refractive_index(mr_f(1:,1:,j),f_basis(1:,j),phi_basis_f(1:,j), &
  &                     kk,jp,ndx_path,z_path,t_path,phi_path,n_path,  &
  &                     h2o_path,no_tan_hts,wet)

! Create filter grids & functions for PFA calculations

  IF(no_pfa_ch > 0) THEN
    CALL pfa_prep(atmospheric,band,no_atmos,no_pfa_ch,no_filt_pts,pfa_ch, &
         pfa_spectrum,f_grid_fltr,freq,fltr_func,no_tan_hts,  &
         ndx_path,no_ptg_frq,ptg_frq_grid,z_path,t_path,    &
         beta_path,InDir,ld,primag,jpm,ier)
    IF(ier /= 0) Return
  ENDIF
d1034 3
a1036 4
  Return
END SUBROUTINE fwd_mdl_set_up

!-----------------------------------------------------------------------
d1038 1
d1113 14
a1126 1
!----------------------------------------------------------------
a1127 102
SUBROUTINE pfa_prep(atmospheric,band,no_atmos,no_pfa_ch,no_filt_pts,    &
           pfa_ch,pfa_spectrum,f_grid_filter,freqs,filter_func,  &
           no_tan_hts,ndx_path,no_ptg_frq,ptg_frq_grid,z_path, &
           t_path,beta_path,InDir,ld,primag,jpm,ier)

!  ===============================================================
!  Declaration of variables for sub-program: pfa_prep
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: no_atmos, no_pfa_ch, no_filt_pts, pfa_ch(*), &
                           no_tan_hts, band, jpm, no_ptg_frq(*)

Integer(i4), INTENT(OUT) :: ier, ld

Real(r8), INTENT(IN) :: freqs(*)

Type(path_index), INTENT(IN) :: ndx_path(*)
Type(path_vector), INTENT(IN) :: z_path(*), t_path(*), ptg_frq_grid(*)

Type (atmos_comp), INTENT(IN) :: ATMOSPHERIC(*)

Type (pfa_slab), INTENT(INOUT) :: PFA_SPECTRUM(6,*)

Real(r8), INTENT(OUT) :: filter_func(:,:), f_grid_filter(:,:)

Type(path_beta), INTENT(OUT) :: beta_path(:,:,:)  ! (sps_i,frq_i,ptg_i)

Character (LEN=*), INTENT(IN) :: InDir, primag

!  ----------------
!  Local variables:
!  ----------------

Integer(i4) :: i, j, k, m, ch_i, sps_i, pb, no_sps, spectag, &
               mch, ptg_i, frq_i, spectags(MAXSPS)

Real(r8) :: xlhs, xrhs, df, q, area, frq

Character (LEN=8) :: sps_name

! Type (eos_mdb_hdr) :: MDB_HDR(MAXSPS)
! Type (eos_mdb_rec) :: MDB_REC(MAX_NO_LINES)
Type (eos_mdb_hdr) :: MDB_HDR(02)      ! ** DEBUG
Type (eos_mdb_rec) :: MDB_REC(02)      ! ** DEBUG

Real(r8), DIMENSION(:), ALLOCATABLE :: values, t_power, dbeta_dw, &
                                       dbeta_dn, dbeta_dnu
! Begin code:

  ier = 0

!  Read in the EOS Beta database for all species involved

  pb = 0
  spectags(1:MAXSPS) = -1
  no_sps = pfa_spectrum(band,1)%no_sps

sps:DO sps_i = 1, no_sps

    Spectag = pfa_spectrum(band,sps_i)%sps_spectag

    j = 1
    DO WHILE(j < no_atmos .AND. spectag /= atmospheric(j)%spectag)
      j = j + 1
    END DO

!  Check if specie is in the database

    IF(spectag /= atmospheric(j)%spectag) THEN
      ier = 1
      WRITE(6,900) spectag
      Return
    END IF

    IF(.NOT.atmospheric(j)%fwd_calc(band)) CYCLE sps

!  Now check if we loaded this Spectag already ..

    IF(pb > 0) THEN
      DO k = 1, pb
        IF(spectag == spectags(k)) CYCLE sps
      END DO
    END IF

    IF(pb == 9) THEN
      ier = 1
      PRINT *,'** Error in routine: read_EOS_db ..'
      PRINT *,'   This limited version does not support more then &
          &nine species..'
      Return
    END IF

    pb = pb + 1
    spectags(pb) = Spectag
    CALL read_eos_db(Spectag,sps_name,mdb_hdr(pb),mdb_rec,jpm,Ier)
    IF(ier /= 0) THEN
      PRINT *,'** Error in routine: read_EOS_db, Spectag:',spectag
      PRINT *,'   Called by routine: pfa_prep ..'
      Return
    END IF
d1129 21
a1149 1
! Now, build the beta arrays along the path
d1151 2
a1152 1
    do ptg_i = 1, no_tan_hts
d1154 1
a1154 8
      m = ndx_path(ptg_i)%total_number_of_elements
      ALLOCATE(values(m),t_power(m),dbeta_dw(m),dbeta_dn(m), &
               dbeta_dnu(m),STAT=ier)
      if(ier /= 0) then
        PRINT *,'** Allocation error in routine: pfa_prep ..'
        PRINT *,'   IER =',ier
        Return
      endif
d1156 1
a1156 2
      k = ptg_i
      do frq_i = 1, no_ptg_frq(k)
d1158 4
a1161 23
        DEALLOCATE(beta_path(j,frq_i,ptg_i)%values,    &
     &             beta_path(j,frq_i,ptg_i)%t_power,   &
     &             beta_path(j,frq_i,ptg_i)%dbeta_dw,  &
     &             beta_path(j,frq_i,ptg_i)%dbeta_dn,  &
     &             beta_path(j,frq_i,ptg_i)%dbeta_dnu, &
     &             STAT=i)
!
        Frq = ptg_frq_grid(k)%values(frq_i)
        CALL get_beta_path (Spectag, Frq, m, z_path(k), t_path(k),     &
     &                mdb_hdr(pb), mdb_rec, values, t_power, dbeta_dw, &
     &                dbeta_dn,dbeta_dnu)
!
        ALLOCATE(beta_path(j,frq_i,ptg_i)%values(m),    &
     &           beta_path(j,frq_i,ptg_i)%t_power(m),   &
     &           beta_path(j,frq_i,ptg_i)%dbeta_dw(m),  &
     &           beta_path(j,frq_i,ptg_i)%dbeta_dn(m),  &
     &           beta_path(j,frq_i,ptg_i)%dbeta_dnu(m), &
     &           STAT = ier)
        if(ier /= 0) then
          PRINT *,'** Allocation error in routine: pfa_prep ..'
          PRINT *,'   IER =',ier
          Return
        endif
d1163 1
a1163 5
        beta_path(j,frq_i,ptg_i)%values(1:m) = values(1:m)
        beta_path(j,frq_i,ptg_i)%t_power(1:m) = t_power(1:m)
        beta_path(j,frq_i,ptg_i)%dbeta_dw(1:m) = dbeta_dw(1:m)
        beta_path(j,frq_i,ptg_i)%dbeta_dn(1:m) = dbeta_dn(1:m)
        beta_path(j,frq_i,ptg_i)%dbeta_dnu(1:m) = dbeta_dnu(1:m)
d1165 5
a1169 4
      end do

      DEALLOCATE(values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu,STAT=i)

d1171 2
a1172 135

  END DO sps

! Find the species index in the l2pc mixing ratio database:

  m = pb
  pb = -1
  no_sps = pfa_spectrum(band,1)%no_sps

  DO ch_i = 1, no_pfa_ch

    mch = pfa_ch(ch_i)

    pb = band
    frq = freqs(mch)
    IF(frq < 1.0D0) THEN
      ier = 1
      WRITE(6,905) mch
      Return
    END IF

! Set up filter's response function

    q = 0.0
    df = Filter(q,mch,xlhs,xrhs,area,ier,InDir,primag,ld)
    IF(ier /= 0) GO TO 99

    df = (xrhs-xlhs)/(no_filt_pts-1)
    DO j = 1, no_filt_pts
      q = xlhs + (j - 1) * df
      f_grid_filter(j,ch_i) = frq + q
      filter_func(j,ch_i) = Filter(q)
    END DO

!  Normalize the filter's response array:

    CALL Simps(filter_func(1:,ch_i),df,no_filt_pts,q)
    DO j = 1, no_filt_pts
      filter_func(j,ch_i) = filter_func(j,ch_i) / q
    END DO

  END DO                         ! On ch_i

 99 IF(ier /= 0) THEN
      PRINT *,' ** Error in Pfa_Prep subroutine **'
      PRINT *,'    After calling subroutine: Get_Filter_Param'
      CALL errmsg(' ',ier)
    END IF

  900  FORMAT(' ** Error in Pfa_Prep subroutine **',/, &
      '    PFA species: ',i7.7,' not among L2PC species database !')
  905  FORMAT(' ** Error in Pfa_Prep subroutine **',/, &
      '    Inconsistant User Input.',/, &
      '    PFA Channel:',i3,' not among the non-PFA channels !')

  Return

END SUBROUTINE pfa_prep

!---------------------------------------------------------------------
!  This routine reads the EOS database and Returns the structer holding
!  the required Spectag

SUBROUTINE read_eos_db(spectag,sps_name,mdb_hdr,mdb_rec,jpm,ier)

!  ===============================================================
!  Declaration of variables for sub-program: read_eos_db
!  ===============================================================
!  ---------------------------
!  Calling sequence variables:
!  ---------------------------
Integer(i4), INTENT(IN) :: spectag,jpm
Integer(i4), INTENT(OUT) :: ier

Character (LEN=8), intent (OUT) :: sps_name

type (eos_mdb_hdr), intent (OUT) :: mdb_hdr
type (eos_mdb_rec), intent (OUT) :: mdb_rec(*)
!  ----------------
!  Local variables:
!  ----------------
Integer(i4) :: i, j, k, io, nl, du, iu, ii, jj, kk, no_lines

Integer(i4), SAVE :: init = 0

Integer(i4) :: no_sps = 14
Integer(i4) :: spectags(14) = (/                          &
        32001, 34001, 18003, 44004, 63001, 27001, 51002,  &
        48004, 28001, 52006, 33001, 36001, 97001, 17001/)

Character (LEN=80) :: fhd, fdt, datdir
Character (LEN=8) :: names(14) = (/                                &
           'O2      ','O-18-O  ','H2O     ','N2O     ','HNO3    ', &
           'HCN     ','CLO     ','O3      ','CO      ','HOCL    ', &
           'HO2     ','HCL     ','BR-81-O ','OH      '/)

type (eos_mdb_hdr), SAVE :: mdb_zero_hdr
type (eos_mdb_rec), SAVE :: mdb_zero_rec

! Begin code:

  IF(init < 1) THEN
!
! Initialize mdb_zero_hdr:
!
    init = 5
    mdb_zero_hdr%spectag = 0
    mdb_zero_hdr%no_lines = 0
    mdb_zero_hdr%q_log(1) = 0.0
    mdb_zero_hdr%q_log(2) = 0.0
    mdb_zero_hdr%q_log(3) = 0.0
    DO ii = 1, max_no_lines
      mdb_zero_hdr%n(ii) = 0.0
      mdb_zero_hdr%w(ii) = 0.0
      mdb_zero_hdr%el(ii) = 0.0
      mdb_zero_hdr%n1(ii) = 0.0
      mdb_zero_hdr%n2(ii) = 0.0
      mdb_zero_hdr%v0(ii) = 0.0
      mdb_zero_hdr%ps(ii) = 0.0
      mdb_zero_hdr%delta(ii) = 0.0
      mdb_zero_hdr%gamma(ii) = 0.0
      mdb_zero_hdr%log_i(ii) = 0.0
      mdb_zero_hdr%no_f_grid(ii) = 0.0
      DO jj = 1, max_freq
        mdb_zero_hdr%x_grid(jj,ii) = 0.0
      END DO
    END DO

    DO ii = 1, max_zeta
      mdb_zero_hdr%zeta(ii) = 0.0
    END DO

    DO ii = 1, max_temp
      mdb_zero_hdr%log_temp(ii) = 0.0
    END DO
d1174 1
a1174 1
! Initialize mdb_zero_rec:
d1176 1
a1176 10
    DO ii = 1,max_zeta
      DO jj = 1, max_temp
        DO kk = 1, max_freq
          mdb_zero_rec%log_beta(ii,jj,kk) = 0.0
          mdb_zero_rec%dlog_beta_dw(ii,jj,kk) = 0.0
          mdb_zero_rec%dlog_beta_dn(ii,jj,kk) = 0.0
          mdb_zero_rec%dlog_beta_dnu0(ii,jj,kk) = 0.0
        END DO
      END DO
    END DO
d1178 6
a1183 85
  END IF

  i = 0
  j = 0
  ier = 0
  sps_name(1:) = ' '
  DO WHILE(j < no_sps .AND. i < 1)
    j = j + 1
    IF(spectags(j) == spectag) THEN
      i = j
      j = 23
    END IF
  END DO

  IF(i < 1) THEN
    io = -1
    GO TO 99
  END IF

  sps_name = names(i)
  Call StrLwr(sps_name)

  fdt(1:) = ' '
! fdt = '/home/zvi/temp/'              ! HOME PC
  fdt = '/user5/zvi/linux/temp/'       ! MLSGATE, VANPC
! fdt = '/user5/zvi/temp/'             ! SUN, SGI

  i = LEN_TRIM(fdt)
  if(jpm < 0) then
    datdir = fdt(1:i)//'/minus/'
  else if(jpm > 0) then
    datdir = fdt(1:i)//'/plus/'
  else
!   datdir = '/home/zvi/data/'              ! HOME PC
    datdir = '/user5/zvi/linux/MLS/data/'   ! MLSGATE, VANPC
!   datdir = '/user5/zvi/zvi/eos/data/'     ! SUN, SGI
  endif

  fdt(1:) = ' '
  fhd(1:) = ' '
  j = LEN_TRIM(datdir)
  i = LEN_TRIM(sps_name)
  fdt = datdir(1:j)//sps_name(1:i)//'_eosmdb.dat'
  j = LEN_TRIM(fdt)
  i = INDEX(fdt,'.dat')
  fhd = fdt(1:i-1)//'.hdr'

  du = 43
  iu = du + 1
  CLOSE(iu,IOSTAT=io)
  inquire (iolength=k) mdb_hdr
  OPEN(iu,FILE=fhd,FORM='UNFORMATTED',STATUS='OLD',action='READ', &
       RECL=k,ACCESS='DIRECT',IOSTAT=io)
  IF(io /= 0) GO TO 99

  CLOSE(du,IOSTAT=io)
  inquire (iolength=j) mdb_rec(1)
  OPEN(du,FILE=fdt,FORM='UNFORMATTED',STATUS='OLD',action='READ', &
       RECL=j,ACCESS='DIRECT',IOSTAT=io)
  IF(io /= 0) GO TO 99

  mdb_hdr = mdb_zero_hdr                    ! Initialize mdb_hdr
  READ(iu,REC=1,IOSTAT=io) mdb_hdr
  IF(io /= 0) GO TO 99

  no_lines = mdb_hdr%no_lines

  DO nl = 1, no_lines

    mdb_rec(nl) = mdb_zero_rec              ! Initialize mdb_rec
    READ(du,REC=nl,IOSTAT=io) mdb_rec(nl)
    IF(io /= 0) GO TO 99

  END DO

  99   IF(io > 0) THEN
    ier = 1
    CALL errmsg(' ',io)
  END IF

  CLOSE(du,IOSTAT=i)
  CLOSE(iu,IOSTAT=i)

  Return
 END SUBROUTINE read_eos_db
d1185 1
a1185 1
!---------------------------------------------------------------------
d1187 1
a1187 1
      SUBROUTINE GTI(MSG,TI)
d1189 1
a1189 4
      IMPLICIT NONE

      CHARACTER(LEN=*),INTENT(IN) :: MSG
      CHARACTER(LEN=*),INTENT(OUT) :: TI
d1191 1
a1191 10
      INTEGER :: I,J,L

      L=LEN(TI)
      TI(1:L)=' '
      I=LEN_TRIM(MSG)
      WRITE(*,900,ADVANCE='NO') MSG(1:I)
 900  FORMAT(A,': ')
      READ(5,'(A)',IOSTAT=J) TI
      J=LEN_TRIM(TI)
      IF(J > 1) CALL LEFTJ(TI)
d1193 1
a1193 9
      END SUBROUTINE GTI

!----------------------------------------------------------------------
! This is the radiative transfer model, radiances only !

    Subroutine Rad_Tran(Frq,N_lvls,h_tan,n_sps, &
      &    ndx_path, z_path, h_path, t_path, phi_path, dHdz_path,     &
      &    earth_ref,beta_path, spsfunc_path, ref_corr, s_temp,brkpt, &
      &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
d1195 1
a1195 17
    Integer(i4), intent(in) :: N_LVLS, N_SPS

    Integer(i4), intent(out) :: BRKPT, NO_ELE, MID, ILO, IHI, IER

    Real(r8), intent(in) :: FRQ, H_TAN, EARTH_REF, S_TEMP

    Real(r8), intent(in) :: REF_CORR(*)

    Type(path_beta), intent(in) :: BETA_PATH(:)   ! (Nsps)

    Type(path_index), intent(in)  :: NDX_PATH
    Type(path_vector), intent(in) :: Z_PATH, T_PATH, H_PATH, PHI_PATH, &
   &                                 DHDZ_PATH
    Type(path_vector), intent(in) :: SPSFUNC_PATH(:)

    Real(r8), intent(out) :: T_SCRIPT(*), TAU(*)
    Real(r8), intent(out) :: RAD
d1197 1
a1197 4
    Integer(i4) :: Ngp1

    Real(r8) :: CSE, RS
    Real(r8) :: del_opacity(N2lvl), delta(N2lvl,Nsps)
d1199 1
a1199 33
! 'brkpt' is the index of the path break-point (when it change from
!         incoming ray to outgoing ray)
! 'no_ele' is the total number of entries in ?_path%values(1...no_ele)

    Ngp1 = Ng + 1
    brkpt = ndx_path%break_point_index
    no_ele = ndx_path%total_number_of_elements

    EarthX = .false.
    ht = h_tan
    Rr = ht + RoC
    ht2 = Rr * Rr
    if (h_tan < -0.01) then
      Rr = Rr / RoC
      cse = earth_ref
      Call Earth_Intersection(Rs)
    else
      cse = 1.0
      Rr = 0.0d0
      Phi_s = Phi_tan
      NPhi_s = NPhi_tan
    end if
!
!  Compute the appropriate t_script & dt_scrpt_dnp along the integration
!  path of this tanget:
!
    CALL do_t_script(Ngp1, Frq, s_temp, brkpt, no_ele, t_path, &
   &                 mid, t_script)
!
    Call FAST_DELTA(mid,brkpt,no_ele,z_path,h_path,phi_path,beta_path, &
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,Nlvl, &
 &       ref_corr,delta,Ier)
    if (Ier /= 0) Return
d1201 1
a1201 1
! Initialize the tau & del_opacity arrays:
d1203 2
a1204 2
    tau(1:N2lvl) = 0.0
    del_opacity(1:N2lvl) = 0.0
d1206 1
a1206 2
    CALL FAST_ZOPACITY(n_sps, Ngp1, N2lvl, brkpt, &
   &                   no_ele, delta, del_opacity)
d1208 2
a1209 2
    Call Scrt_dn(t_script, N_lvls, cse, del_opacity, tau, Rad, mid, &
   &             ilo, ihi)
d1212 2
a1213 1
  End Subroutine RAD_TRAN
d1215 1
a1215 1
End Program l2_numder
@


1.1
log
@New version
@
text
@d2 1
a2 1
  use GL6P
d15 1
d18 1
a18 1
  use DSIMPSON_MODULE, only: DSIMPS
d27 2
d33 1
a33 4
Integer(i4), PARAMETER :: ngt = (Ng+1) * Nlvl
Integer(i4), PARAMETER :: Npath = 2 * ngt

Integer(i4), PARAMETER :: mnf = 25
d35 1
a35 1
Logical :: temp_der
d37 3
a39 5
Integer(i4) :: p_indx(Nlvl), N_TAN(Nlvl),no_filt_pts,  &
  jpm, ier, no_phi_t, no_spectro, SPECT_ATMOS(Nsps),        &
  no_coeffs_f(Nsps), no_phi_f(Nsps), n_obs, NO_SPS_TBL(6), no_pfa_ch,    &
  SPECT_INDEX(Nsps), ATMOS_INDEX(Nsps), NDX_SPS(Nsps,MAXPFACH),          &
  SPS_TBL(Nsps,6),pfa_ch(MAXPFACH),NO_INT_FRQS(MAXPFACH),NO_PHI_VEC(mnsv)
d42 3
a44 2
               no_atmos, ch1, ch2, geo_i, n_lvls, si, mfi, band, n_sps, &
               no_freqs, ptg_i, frq_i, io, brkpt, no_ele, mid, ilo, ihi
d49 1
a49 1
                     spsfunc_path(Nsps,Nptg)
d53 1
a53 1
Real(r8) :: href(Nlvl), zref(Nlvl), t_tan(Nptg), tan_hts(Nptg),  &
d57 1
a57 1
            t_grid(Nlvl),h_grid(Nlvl),z_gnlv(400), e_rad, cse, Rs, &
a61 1
real(r8) :: C_FREQ(Nch), freq_grid(mnf)
d63 1
d65 1
a65 1
real(r8) :: F_GRID(maxaitkenpts,maxpfach)
a66 1
real(r8) :: FILTER_FUNC(maxfiltpts,maxpfach)
d71 3
a73 2
Real(r8) :: S_TEMP, H_OBS, EARTH_REF, ZRoC, geoc_lat, q, r
Real(r8) :: RadV(Nptg)
d76 1
d78 3
a80 1
Character (LEN=80) :: InDir, Fnd
d83 4
a86 4
Type (atmos_comp) :: ATMOSPHERIC(Nsps)
Type (geom_param) :: GEOMETRIC(maxgeom)
Type (spectro_param) :: SPECTROSCOPIC(3*Nsps)
Type (pfa_slab)   :: PFA_SPECTRUM(6,Nsps)
d93 2
a94 2
! Fdata = '/hpusr/zvi/new_seez'     ! SUN
  Fdata = '/home/zvi/new_seez'      ! PC
d99 12
a110 10
33  jpm = 0
    Call Gti('Enter plus/minus (p/m)',Ax)
    if(Ax < '!') goto 99
    if(Ax(1:1) == 'p') then
      jpm = 1
    else if(Ax(1:1) == 'm') then
      jpm = -1
    else
      goto 33
    endif
d112 5
d118 33
a150 1
  no_int_frqs(1:maxpfach) = 0
d216 2
a217 1
  read(11,*,iostat=io) (atmos_index(i),i=1,no_atmos)
d229 6
a234 1
    read(11,*,iostat=io) k, ht_i
d236 1
a236 1
    atmospheric(j)%SPECTAG = k
d254 16
a289 3
  SPECT_INDEX(1:Nsps) = -1
  SPECT_ATMOS(1:Nsps) = -1

d306 1
a306 1
    read(11,*,iostat=io) ht_i
d308 1
a308 1
    spectroscopic(j)%SPECTAG = ht_i
d326 1
a326 1
    kk = atmospheric(k)%Spectag
d328 1
a328 1
      if(kk == spectroscopic(i)%Spectag) then
d360 1
a360 1
  read(11,*,iostat=io) q, r, phi_tan, geoc_lat
a365 8
! Add phi_tan to the spectroscopic phi's and convert to radiance:
!
  do j = 1, no_spectro
    i = spectroscopic(j)%NO_PHI_VALUES
    spectroscopic(j)%PHI_BASIS(1:i) = (spectroscopic(j)%PHI_BASIS(1:i) + &
   &                                   phi_tan) * deg2rad
  end do

d396 6
d432 4
a435 4
  DO geo_i = 1, no_atmos
    kk = no_phi_f(geo_i)
    ht_i = no_coeffs_f(geo_i)
    read(11,*,iostat=io) (f_basis(i,geo_i),i=1,ht_i)
d437 1
a437 1
    read(11,*,iostat=io) (phi_basis_f(i,geo_i),i=1,kk)
d439 1
a439 1
    read(11,*,iostat=io) ((mr_f(i,j,geo_i),j=1,kk),i=1,ht_i)
d443 14
d471 9
d489 19
d511 1
a511 1
 &     geoc_lat,atmospheric,no_atmos,f_basis,mr_f,no_coeffs_f,c_freq, &
d513 5
a517 7
 &     tan_temp,no_tan_hts,no_sps_tbl,sps_tbl,no_pfa_ch,no_filt_pts,  &
 &     pfa_ch,no_int_frqs,pfa_spectrum,t_tan,ndx_sps,n_tan,           &
 &     f_grid_filter,f_grid,filter_func,ch1,ch2,InDir,ld,             &
 &     header1,no_phi_f,phi_basis_f,atmos_index,no_phi_vec,z_path,    &
 &     h_path,t_path,phi_path,n_path,dhdz_path,dh_dt_path,Npath,      &
 &     no_phi_t,t_phi_basis,ZRoC,spectroscopic,no_spectro,            &
 &     spect_index,tan_dh_dt,no_freqs,freq_grid,spsfunc_path,         &
d520 8
d536 3
a538 4
  RadV(:Nptg) = 0.0
  temp_der = .true.
! temp_der = .false.
!
d543 4
d548 1
a548 2
!   do frq_i = 1, no_freqs
    do frq_i = 1, 1               ! ** DEBUG
d550 1
a550 1
      Frq = freq_grid(frq_i)
d552 5
a556 5
      Call Rad_Tran(Frq,N_lvls,h_tan,band,n_sps, sps_tbl, ndx_path(k), &
      &    z_path(k), h_path(k), t_path(k), phi_path(k), dHdz_path(k), &
      &    earth_ref, beta_path(1:,frq_i,k), spsfunc_path(1:,k),       &
      &    ref_corr(1:,k), s_temp, brkpt, no_ele, mid, ilo, ihi, cse,  &
      &    Rs, t_script, tau, Rad, Ier)
d559 1
a559 1
      if(frq_i == 1) RadV(ptg_i) = Rad
d563 8
d573 9
a581 9
  RadV(no_tan_hts) = RadV(no_tan_hts-1)
!
     k = 61
     j = no_tan_hts
     kk = j - si + 1
     write(*,'(''pfa_rad'',a1,i2.2)') char(92),kk
     write(*,905) (RadV(k),k=si,j)
905  format(4(2x,1pg15.8))
!
d587 1
d606 8
a613 10
           geoc_lat,atmospheric,no_atmos,f_basis,mr_f,no_coeffs_f,freq, &
           si,earth_ref,s_temp,h_obs,n_obs,tan_hts_raw,tan_hts,tan_press, &
           tan_temp,no_tan_hts,no_sps_tbl,sps_tbl,no_pfa_ch,no_filt_pts, &
           pfa_ch,no_int_frqs,pfa_spectrum,t_tan,ndx_sps,n_tan_ptr,     &
           f_grid_fltr,f_grid,fltr_func,ch1,ch2,InDir,ld,hdr1,          &
           no_phi_f,phi_basis_f,atmos_index,no_phi_vec,z_path,h_path,   &
           t_path,phi_path,n_path,dhdz_path,dh_dt_path,npath,           &
           no_phi_t,t_phi_basis,rad_cur,spectroscopic,no_spectro,       &
           spect_index,tan_dh_dt,no_freqs,freq_grid,spsfunc_path,       &
           is_f_log,beta_path,jpm,ier)
d624 3
a626 5
Integer(i4), INTENT(IN) :: n_lvls, no_atmos, no_t, ch1, ch2, si,  &
             atmos_index(:), spect_index(:), no_phi_t, no_freqs, &
             no_coeffs_f(:), no_phi_f(:), jpm, &
             no_spectro, npath, no_pfa_ch, no_filt_pts, pfa_ch(:), &
             no_int_frqs(:)
d630 2
a631 2
Integer(i4), INTENT(OUT) :: n_obs, no_sps_tbl(:), sps_tbl(:,:),  &
             no_phi_vec(:), ier, ndx_sps(:,:), n_tan_ptr(:)
d633 1
a633 1
Real(r8), INTENT(IN) :: z_grid(:), href(:), zref(:), freq_grid(:), &
d644 2
a645 2
Type(path_vector), INTENT(OUT) :: z_path(:),t_path(:),h_path(:), &
                   phi_path(:), n_path(:), dhdz_path(:), spsfunc_path(:,:)
d649 3
a651 3
Real(r8), INTENT(OUT) :: e_rad,earth_ref,s_temp,h_obs,freq(:),geoc_lat, &
          tan_temp(:),t_grid(:),h_grid(:),tan_press(:),t_tan(:),rad_cur, &
          f_grid(:,:),fltr_func(:,:),f_grid_fltr(:,:)
d662 2
a663 2
Integer(i4) :: i, j, k, jp, ncpb, ich, sps_i, geo_i, band, geo_j, &
               ih2o, kk, no_geom_new, band1, band2, gl_count
a668 3
Real(r8) :: z_glgrid(ngt)

! Real(r8) :: h2o_path(Npath,Nptg)
d671 1
a671 1
Real(r8) :: q,r,p,g,sw,cw,rp,b2,z1,z2,xm,ym,beta_inc,incl,zeta,phi
d673 1
d681 4
a684 6
type (l2pc_header_one), intent(in)  :: hdr1

type (geom_param),    intent(inout) :: geometric(*)
type (atmos_comp),    intent(inout) :: atmospheric(*)
type (spectro_param), intent(inout) :: spectroscopic(*)
type (pfa_slab), intent(inout)      :: pfa_spectrum(6,*)
a691 6
  q = DBLE(earth_major)
  a2 = q * q

  r = DBLE(earth_minor)
  b2 = r * r

d693 26
a718 30
  incl = (beta_inc - 90.0D0) * deg2rad
  q = TAN(incl)
  r = q * q
  c2 = (1.0D0+r)*a2*b2/(a2+b2*r)   ! This is c*c
  q = SQRT(c2)                     ! This is c, Minor axis for 2D ellipse

  c2oa2 = c2 / a2

! Get the Tangent Phi (Geodetic Lat.) from the Geocentric Lat.
!
! r = geoc_lat * deg2rad
! q = SIN(r)
! sw = q * q
! r = COS(incl)
! cw = r * r
! q = a2*a2*sw*cw/(b2*b2+(a2*a2-b2*b2)*sw*cw)
! spt = SQRT(q)                ! Sin(Phi_tan)
! phi_tan = DASIN(spt)
!
! Get the Geocentric Lat. (geoc_lat) from the Tangent Phi (Geodetic Lat.)
!
  r = Phi_tan
  Phi_tan  = r * deg2rad               ! Convert to Radians
  spt = SIN(Phi_tan)
  cpt = COS(Phi_tan)
  cw = cpt * cpt
  sw = spt * spt
  r = a2*a2*cw +b2*b2*sw
  q = spt*b2/Sqrt(r)/COS(incl)
  geoc_lat = DASIN(q) / deg2rad        ! In Degrees
d720 5
a724 2
  nphi_tan = a2 / SQRT(c2-(c2-a2)*cw)
  ps = -1.0D0
d726 1
a726 1
!  Compute Radius of Curvature Circle (RoC) and its center coordinates:
d728 5
a732 6
  r = c2 * cpt / a2
  q = spt * spt + r * r
  roc = nphi_tan * SQRT(q)
  xoc = (nphi_tan - roc) * cpt
  yoc = (c2oa2 * nphi_tan - roc) * spt
  rad_cur = roc
d734 1
a734 4
!  Compure Earth Radius (Elliptical)

  q = ((a2*a2)*cw+(b2*b2)*sw)/(a2*cw+b2*sw)
  rp = SQRT(q)
a749 21

! From the selected integration grid pressures define the GL pressure
! grid:

  gl_count = 0
  z2 = z_grid(1)
  DO i = 2, n_lvls
    z1 = z2
    z2 = z_grid(i)
    xm = 0.5D0 * (z2 + z1)
    ym = 0.5D0 * (z2 - z1)
    gl_count = gl_count + 1
    z_glgrid(gl_count) = z1
    DO j = 1, ng
      gl_count = gl_count + 1
      z_glgrid(gl_count) = xm + ym * Gx(j)
    END DO
  END DO

  gl_count = gl_count + 1
  z_glgrid(gl_count) = z2
a750 9
! Initialize the no_phi_vec array. This array stores the number of Phi's for
! each state_vector type entry. Initial value for all is: 1.
! (Later, we will connect between 'no_phi_vec' and 'no_phi_f' and 'no_phi_g'
! entries.)

  DO i = 1, max_no_sv_elmnts
    no_phi_vec(i) = 1
  END DO

d825 1
a825 19

! Call the grids program to get the preselected integration heights and
! pointings. Also transfer the pointings expressed in pressure units to
! heights.  Also, set up geophysical parameters (for derivatives):
! [The following routine replaces the older code using the two routines:
!  grids() and geo_basis() ]

! (z_grid,t_grid,h_grid) are the arrays of the preselected integration grid.

  CALL geo_grids(z_glgrid,gl_count,z_grid,t_grid,h_grid,tan_dh_dt,  &
       n_lvls,t_z_basis,t_coeff,si,tan_hts,tan_hts_raw,tan_press,   &
       tan_temp,no_tan_hts,z_path,h_path,t_path,phi_path,dhdz_path, &
       dh_dt_path,Npath,g,href,zref,phi_tan,geoc_lat,roc,n_tan_ptr, &
       t_tan,no_t,no_phi_t,t_phi_basis,ndx_path,ier)
  IF(ier /= 0) RETURN
! Get the crossections if this is the first Call to the subroutine,
! The subroutine knows that this is the first Call if the time counter
! in the main program is one

a834 15

  ncpb = hdr1%no_channels_per_band
  band1 = (ch1 + ncpb - 1) / ncpb     ! Begining Band
  band2 = (ch2 + ncpb - 1) / ncpb     !  Ending  Band

  DO band = band1, band2
    kk = 0
    DO i = 1, no_atmos
      IF(atmospheric(i)%fwd_calc(band)) THEN
        kk = kk + 1
        sps_tbl(kk,band) = i
      END IF
    END DO
    no_sps_tbl(band) = kk
  END DO
d840 23
a862 20
    DO band = band1, band2
      do sps_i = 1, no_sps_tbl(band)
        j = sps_tbl(sps_i,band)
        jp = no_phi_f(j)
        kk = no_coeffs_f(j)
        ALLOCATE(spsfunc_path(j,k)%values(gl_count),STAT=i)
        IF(i /= 0) THEN
          ier = i
          PRINT *,'** Error: ALLOCATION error for spsfunc_path ..'
          PRINT *,'   STAT =',ier
          RETURN
        ENDIF
        do i = 1, gl_count
          zeta = z_path(k)%values(i)
          phi = phi_path(k)%values(i)
          Call TWO_D_POLATE (f_basis(1:,j), mr_f(1:,1:,j), kk,    &
     &                       phi_basis_f(1:,j), jp, zeta, phi, q)
          if (is_f_log(j)) q = exp(q)
          spsfunc_path(j,k)%values(i) = q
        end do
d866 72
a937 1

a942 16
! Connect between 'no_phi_vec' and 'no_phi_f' entries.

  DO i = 1, no_atmos
    j = atmos_index(i)
    kk = hdr1%sv_component_first_elmnt_index(j)
    no_phi_vec(kk) = no_phi_f(i)
  END DO

! Connect between 'no_phi_vec' and number of spectral phi's entries.

  DO i = 1, no_spectro
    j = spect_index(i)
    kk = hdr1%sv_component_first_elmnt_index(j)
    no_phi_vec(kk) = spectroscopic(i)%no_phi_values
  END DO

d947 1
a947 1
    IF(geometric(geo_i)%der_calc(band1)) kk = kk + 1
d966 1
a966 1
    RETURN
d975 1
a975 2
  DO WHILE (atmospheric(sps_i)%name /= 'H2O'  .AND.  &
        sps_i <= no_atmos)
d997 5
a1001 5
    CALL pfa_prep(atmospheric,no_atmos,no_pfa_ch,no_filt_pts,pfa_ch,   &
         no_int_frqs,pfa_spectrum,ndx_sps,f_grid_fltr,f_grid,freq,     &
         fltr_func,no_tan_hts,no_freqs,ndx_path,z_path,t_path,   &
         beta_path,freq_grid,InDir,ld,primag,jpm,ier)
    IF(ier /= 0) RETURN
d1004 1
a1004 1
  RETURN
d1012 1
a1012 1
! sideband by channel. It also returns the bandwidth limits of integration
d1022 1
a1022 1
LOGICAL, save :: sgn_fp(6) = (/                                    &
d1027 1
a1027 1
Real(r4), save :: db_fi_data(90) =(/                   &
d1048 1
a1048 1
REAL(r8), save :: f_prime(6) = (/                          &
d1052 1
a1052 1
REAL(r8), save :: f_image(6) = (/                          &
d1080 1
a1080 1
  RETURN
d1083 1
a1083 1
!-----------------------------------------------------------------
d1085 4
a1088 4
SUBROUTINE pfa_prep(atmospheric,no_atmos,no_pfa_ch,no_filt_pts,pfa_ch, &
           no_int_frqs,pfa_spectrum,ndx_sps,f_grid_filter,f_grid,freqs,   &
           filter_func,no_tan_hts,no_freqs,ndx_path,z_path,t_path,  &
           beta_path,freq_grid,InDir,ld,primag,jpm,ier)
d1096 2
a1097 2
Integer(i4), INTENT(IN) :: no_atmos, no_pfa_ch, no_filt_pts, pfa_ch(:), &
                           no_int_frqs(:), no_freqs, no_tan_hts, jpm
d1099 1
a1099 1
Integer(i4), INTENT(OUT) :: ier, ld, ndx_sps(:,:)
d1101 1
a1101 1
Real(r8), INTENT(IN) :: freqs(:),freq_grid(:)
d1104 1
a1104 1
Type(path_vector), INTENT(IN) :: z_path(*),t_path(*)
d1106 1
a1106 1
Type (atmos_comp), INTENT(IN) :: atmospheric(*)
d1108 1
a1108 1
Type (pfa_slab), INTENT(INOUT) :: pfa_spectrum(6,*)
d1110 1
a1110 1
Real(r8), INTENT(OUT) :: filter_func(:,:), f_grid(:,:), f_grid_filter(:,:)
a1115 4
!  ----------------------
!  PARAMETER Declaration:
!  ----------------------
Real(r8), PARAMETER :: Tiny = epsilon(freqs(1))
d1119 3
a1121 2
Integer(i4) :: i, j, k, m, ch_i, sps_ind, sps_i, pb, no_sps, spectag, &
               j4, mch, band, ptg_i, frq_i, spectags(MAXSPS)
d1134 1
a1134 2

! begin code:
d1142 1
a1142 6

  DO ch_i = 1, no_pfa_ch

    mch = pfa_ch(ch_i)
    band = (mch + 14) / 15
    no_sps = pfa_spectrum(band,1)%no_sps
d1146 1
a1146 1
      Spectag = pfa_spectrum(band,sps_i)%sps_spectag
d1148 4
a1151 1
!  Build: ndx_sps, the index in the mixing ratio array:
d1153 1
a1153 5
      sps_ind = 1
      DO WHILE(sps_ind < no_atmos .AND. spectag /=  &
            atmospheric(sps_ind)%spectag)
        sps_ind = sps_ind + 1
      END DO
d1155 5
a1159 1
!  Check if sps is in the database
d1161 1
a1161 11
      IF(spectag /= atmospheric(sps_ind)%spectag) THEN
        ier = 1
        WRITE(6,900) spectag
        RETURN
      END IF

!  'sps_ind' locates the index in the mixing ratio array:

      ndx_sps(sps_i,ch_i) = sps_ind

      IF(.NOT.atmospheric(sps_ind)%fwd_calc(band)) CYCLE sps
d1165 5
a1169 5
      IF(pb > 0) THEN
        DO k = 1, pb
          IF(spectag == spectags(k)) CYCLE sps
        END DO
      END IF
d1171 7
a1177 7
      IF(pb == 9) THEN
        ier = 1
        PRINT *,'** Error in routine: read_EOS_db ..'
        PRINT *,'   This limited version does not support more then &
            &nine species..'
        RETURN
      END IF
d1179 8
a1186 8
      pb = pb + 1
      spectags(pb) = Spectag
      CALL read_eos_db(Spectag,sps_name,mdb_hdr(pb),mdb_rec,jpm,Ier)
      IF(ier /= 0) THEN
        PRINT *,'** Error in routine: read_EOS_db, Spectag:',spectag
        PRINT *,'   Called by routine: pfa_prep ..'
        RETURN
      END IF
d1190 1
a1190 1
      do ptg_i = 1, no_tan_hts
d1192 30
a1221 3
        m = ndx_path(ptg_i)%total_number_of_elements
        ALLOCATE(values(m),t_power(m),dbeta_dw(m),dbeta_dn(m), &
                 dbeta_dnu(m),STAT=ier)
d1225 1
a1225 1
          RETURN
d1228 5
a1232 1
        do frq_i = 1, no_freqs
d1234 1
a1234 24
          Frq = freq_grid(frq_i)
          CALL get_beta_path (Spectag, Frq, m, z_path(ptg_i), t_path(ptg_i), &
       &                mdb_hdr(pb), mdb_rec, values, t_power, dbeta_dw, &
       &                dbeta_dn,dbeta_dnu)
!
          ALLOCATE(beta_path(sps_ind,frq_i,ptg_i)%values(m),    &
       &           beta_path(sps_ind,frq_i,ptg_i)%t_power(m),   &
       &           beta_path(sps_ind,frq_i,ptg_i)%dbeta_dw(m),  &
       &           beta_path(sps_ind,frq_i,ptg_i)%dbeta_dn(m),  &
       &           beta_path(sps_ind,frq_i,ptg_i)%dbeta_dnu(m), &
                   STAT = ier)
          if(ier /= 0) then
            PRINT *,'** Allocation error in routine: pfa_prep..'
            PRINT *,'   IER =',ier
            RETURN
          endif
!
          beta_path(sps_ind,frq_i,ptg_i)%values(1:m) = values(1:m)
          beta_path(sps_ind,frq_i,ptg_i)%t_power(1:m) = t_power(1:m)
          beta_path(sps_ind,frq_i,ptg_i)%dbeta_dw(1:m) = dbeta_dw(1:m)
          beta_path(sps_ind,frq_i,ptg_i)%dbeta_dn(1:m) = dbeta_dn(1:m)
          beta_path(sps_ind,frq_i,ptg_i)%dbeta_dnu(1:m) = dbeta_dnu(1:m)
!
        end do
d1236 1
a1236 1
        DEALLOCATE(values,t_power,dbeta_dw,dbeta_dn,dbeta_dnu,STAT=i)
d1238 1
a1238 3
      end do

    END DO sps
d1240 1
a1240 1
  END DO
d1242 1
a1242 1
!  Find the species index in the l2pc mixing ratio database:
d1246 2
a1250 42
    band = (mch + 14) / 15
    no_sps = pfa_spectrum(band,1)%no_sps

    j4 = 4 * no_int_frqs(ch_i) + 1     ! Total # of Aitken's points

    IF(j4 > 1) THEN

      DO sps_i = 1, no_sps

        spectag = pfa_spectrum(band,sps_i)%sps_spectag
        spectags(sps_i) = spectag

!  Setup the spectrum record (structure), per band:

        j = 1
        k = spectag
        IF(k == 18999 .OR. k == 28964 .OR. k == 28965) j = -1

        IF(j >= 0 .AND. pb /= band) THEN

          k = -sps_i
          IF(sps_i > 1) k = sps_i

        END IF
!
!  Overwrite the pfa_spectrum data with the appropriate EOS Database
!
        j = 0
        k = -1
        DO WHILE(j < m .AND. k < 1)
          j = j + 1
          IF(mdb_hdr(j)%spectag == spectag) k = j
        END DO

        IF(k > 0) THEN
          j = mdb_hdr(k)%no_lines
          pfa_spectrum(band,sps_i)%no_lines = j
        END IF

      END DO

    END IF
d1257 1
a1257 1
      RETURN
d1275 1
a1275 1
    CALL dsimps(filter_func(1:,ch_i),df,no_filt_pts,q)
a1279 11
!  If needed, Get Aitken's grid points:

    IF(j4 > 1) THEN
      df = (xrhs - xlhs) / (j4 - 1)
      DO j = 1, j4
        q = xlhs + (j - 1) * df
        f_grid(j,ch_i) = frq + q
      END DO
      f_grid(j4+1,ch_i) = frq                 ! *** DEBUG
    END IF

d1294 2
a1295 1
  RETURN
d1299 1
a1299 1
!  This routine reads the EOS database and returns the structer holding
d1322 1
a1322 1
Integer(i4), save :: init = 0
d1335 2
a1336 2
type (eos_mdb_hdr), save :: mdb_zero_hdr
type (eos_mdb_rec), save :: mdb_zero_rec
d1408 1
d1410 10
a1419 3
  datdir(1:) = ' '
  if(jpm < 1) then
    datdir= '/home/zvi/temp/minus/'
d1421 3
a1423 1
    datdir= '/home/zvi/temp/plus/'
a1430 1
  CALL strlwr(fdt)
d1471 2
a1472 2
  RETURN
END SUBROUTINE read_eos_db
d1496 2
a1497 1
!-----------------------------------------------------------------------
d1499 1
a1499 1
Subroutine Rad_Tran(Frq,N_lvls,h_tan,band,n_sps, sps_tbl, &
d1502 1
a1502 1
      &    no_ele, mid, ilo, ihi, cse, Rs, t_script, tau, Rad, Ier)
d1504 1
a1504 3
    Integer(i4), intent(in) :: N_LVLS, BAND, N_SPS

    Integer(i4), intent(in) :: SPS_TBL(Nsps,*)
d1520 1
a1520 1
    Real(r8), intent(out) :: CSE, RS, RAD
d1524 1
d1557 1
a1557 1
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,sps_tbl(1:,band),Nlvl,    &
d1566 1
a1566 1
    CALL FAST_ZOPACITY(sps_tbl(1:,band), n_sps, Ngp1, N2lvl, brkpt, &
d1575 1
a1575 1
end Program l2_numder
@

