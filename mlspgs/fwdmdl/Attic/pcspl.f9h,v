head	2.6;
access;
symbols
	V3-43:2.5
	V3-41:2.5
	V3-40-PlusGM57:2.5.0.2
	V2-24-NRT-04:2.5
	V3-33:2.5
	V2-24:2.5
	V3-31:2.5
	V3-30-NRT-05:2.5
	cfm-01-00:2.5
	V3-30:2.5
	V3-20:2.5
	V3-10:2.5
	V2-23-NRT-02:2.5
	V2-23:2.5
	V2-22-NRT-01:2.5
	V2-22:2.5
	V2-21:2.5
	V2-20:2.5
	V2-11:2.5
	V2-10:2.5
	V2-00:2.5
	V1-51:2.4
	V1-50:2.4
	V1-45:2.4
	V1-44:2.4
	V1-43:2.4
	V1-32:2.4
	V1-31:2.4
	V1-30:2.3
	V1-13:2.3
	V1-12:2.3
	V1-11:2.3
	V1-10:2.3
	newfwm-feb03:2.3.0.2
	V1-04:2.0
	V1-03:2.0
	V1-02:2.0
	JointForwardModel:2.0.0.2
	V1-00:2.0
	newfwm-sep01:1.4.0.2
	V0-7:1.4
	V0-5-Level2:1.3
	V0-5-SIPS:1.3
	V0_1:1.1;
locks; strict;
comment	@# @;


2.6
date	2011.08.26.00.30.00;	author pwagner;	state dead;
branches;
next	2.5;

2.5
date	2005.06.22.18.14.01;	author pwagner;	state Exp;
branches;
next	2.4;

2.4
date	2003.11.08.02.17.30;	author vsnyder;	state Exp;
branches;
next	2.3;

2.3
date	2002.10.14.21.02.31;	author vsnyder;	state Exp;
branches;
next	2.2;

2.2
date	2002.10.04.23.27.59;	author vsnyder;	state Exp;
branches;
next	2.1;

2.1
date	2002.10.02.15.50.09;	author bwknosp;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.07.23.39.31;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.23.10.04;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.22.23.07.29;	author zvi;	state dead;
branches;
next	1.1;

1.1
date	2000.05.05.00.04.02;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.6
log
@Moved to lib or combined with MLSNumerics module
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id: pcspl.f9h,v 2.5 2005/06/22 18:14:01 pwagner Exp $
! $RCSfile: pcspl.f9h,v $

! subroutine ?_PCSPL ( TAU, C, N, IBCBEG, IBCEND )

!  From  * A Practical guide to splines *  by C. De Boor
!     ************************  input  ***************************
!     N = number of data points. assumed to be  >=  2.
!     (TAU(i), c(1,i), i=1,...,N) = abscissae and ordinates of the
!        data points. tau is assumed to be strictly increasing.
!     IBCBEG, IBCEND = boundary condition indicators, and
!     C(2,1), C(2,N) = boundary condition information. specifically,
!        IBCBEG = 0  means no boundary condition at TAU(1) is given.
!           in this case, the not-a-knot condition is used, i.e. the
!           jump in the third derivative across TAU(2) is forced to
!           zero, thus the first and the second cubic polynomial pieces
!           are made to coincide.)
!        IBCBEG = 1  means that the slope at TAU(1) is made to equal
!           C(2,1), supplied by input.
!        IBCBEG = 2  means that the second derivative at TAU(1) is
!           made to equal C(2,1), supplied by input.
!        IBCEND = 0, 1, or 2 has analogous meaning concerning the
!           boundary condition at TAU(N), with the additional infor-
!           mation taken from C(2,N).
!     ***********************  output  **************************
!     C(j,i), j=1,...,4; i=1,...,l (= N-1) = the polynomial coefficients
!        of the cubic interpolating spline with interior knots (or
!        joints) TAU(2), ..., TAU(N-1). Precisely, in the interval
!        (TAU(i), TAU(i+1)), the spline f is given by
!           f(x) = C(1,i) + h * (C(2,i) + h * (C(3,i) + h * C(4,i)/3.)/2.)
!        where h = x - TAU(i). the function program *ppvalu* may be
!        used to evaluate f or its derivatives from TAU, C, L = N-1,
!        and K=4.

    integer, intent(in) :: N, IBCBEG, IBCEND

    real(rk), intent(in) :: TAU(*)
    real(rk), intent(inout) :: C(4,*)

    integer :: L, M, J, I
    real(rk) :: DTAU, G, DIVDF1, DIVDF3

!****** A tridiagonal linear system for the unknown slopes s(i) of
!  f at TAU(i), i=1,...,N, is generated and then solved by gauss elim-
!  ination, with s(i) ending up in C(2,i), all i.
!  C(3,.) and C(4,.) are used initially for temporary storage.

    l = n - 1

! Compute first differences of tau sequence and store in c(3,.). Also,
! compute first divided difference of data and store in c(4,.).

    do m = 2, n
      dtau = tau(m) - tau(m-1)
      if ( abs(dtau) <= epsilon(tau) ) then
        print *,'** Warning: division by zero in routine: ?_PCSPL'
        print *,'   Subroutine ?CSPLINE(_DER) bombed out !!'
        return
      end if
      c(3,m) = dtau
      c(4,m) = (c(1,m) - c(1,m-1)) / dtau
    end do

! Construct first equation from the boundary condition, of the form
!             c(4,1)*s(1) + c(3,1)*s(2) = c(2,1)

    select case ( ibcbeg )
    case ( :0 )
      if ( n <= 2 ) then ! no condition at left end and n = 2.
        c(4,1) = 1.0
        c(3,1) = 1.0
        c(2,1) = 2.0*c(4,2)
      else             ! not-a-knot condition at left end and n  >  2.
        c(4,1) = c(3,3)
        c(3,1) = c(3,2) + c(3,3)
        c(2,1) = ((c(3,2)+2.0*c(3,1)) * c(4,2) * c(3,3) + &
          &       c(3,2)*c(3,2)*c(4,3)) / c(3,1)
      end if
    case ( 1 )         ! slope prescribed at left end.
      c(4,1) = 1.0
      c(3,1) = 0.0
    case ( 2: )        ! second derivative prescribed at left end.
      c(4,1) = 2.0
      c(3,1) = 1.0
      c(2,1) = 3.0*c(4,2) - 0.5*c(3,2)*c(2,1)
    end select

! If there are interior knots, generate the corresp. equations and carry
! out the forward pass of gauss elimination, after which the m-th
! equation reads    C(4,m)*s(m) + C(3,m)*s(m+1) = C(2,m).

    do m = 2, l
      g = -c(3,m+1)/c(4,m-1)
      c(2,m) = g*c(2,m-1) + 3.0*(c(3,m)*c(4,m+1)+c(3,m+1)*c(4,m))
      c(4,m) = g*c(3,m-1) + 2.0*(c(3,m) + c(3,m+1))
    end do

! Construct last equation from the second boundary condition, of the form
!  (-g*C(4,n-1))*s(n-1) + C(4,n)*s(n) = C(2,n).
! If slope is prescribed at right end, one can go directly to back-
! substitution, since C array happens to be set up just right for it
! at this point.

    if ( ibcend /= 1 ) then  ! slope not prescribed at right end point
      if ( ibcend > 1 ) then ! second derivative prescribed at right endpoint.
        c(2,n) = 3.0*c(4,n) + 0.5*c(3,n)*c(2,n)
        c(4,n) = 2.0
        g = 1.0
      else ! ibcend < 1      ! no condition at right end point
        if ( n <= 2 .and. ibcbeg < 1 ) then
          c(2,n) = c(4,n)
          go to 44
        end if
        if ( n <= 3 .and. ibcbeg < 1 .or. n <= 2 ) then

! Either (N=3 and not-a-knot also at left) or (N=2 and not not-a-
! knot at left end point).

          c(2,n) = 2.0*c(4,n)
          c(4,n) = 1.0
          g = 1.0
        else

! Not-a-knot and N >= 3, and either M > 3 or also not-a-knot at
! left end point.

          g = c(3,n-1) + c(3,n)
          c(2,n) = ((c(3,n)+2.0*g) * c(4,n) * c(3,n-1) + &
            &        c(3,n)*c(3,n) * (c(1,n-1) - c(1,n-2))/c(3,n-1)) / g
          c(4,n) = c(3,n-1)
        end if
      end if
      g = -g/c(4,n-1)

! Complete forward pass of gauss elimination.

      c(4,n) = g*c(3,n-1) + c(4,n)
      c(2,n) = (g*c(2,n-1) + c(2,n)) / c(4,n)
    end if ! ( ibcend /= 1 )

! Carry out back substitution

 44 do j = l, 1, -1
      c(2,j) = (c(2,j) - c(3,j)*c(2,j+1))/c(4,j)
    end do

!****** Generate cubic coefficients in each interval, i.e., the deriv's
!  at its left endpoint, from value and slope at its endpoints.

    do i = 2, n
      dtau = c(3,i)
      divdf1 = (c(1,i) - c(1,i-1)) / dtau
      divdf3 = c(2,i-1) + c(2,i) - 2.0*divdf1
      c(3,i-1) = (divdf1 - c(2,i-1) - divdf3) / dtau
      c(4,i-1) = (divdf3/dtau)/dtau
    end do

! end subroutine ?_PCSPL

! $Log: pcspl.f9h,v $
! Revision 2.5  2005/06/22 18:14:01  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.4  2003/11/08 02:17:30  vsnyder
! Simplification, polishing
!
! Revision 2.3  2002/10/14 21:02:31  vsnyder
! Replace CVS variables with comments
!
! Revision 2.2  2002/10/04 23:27:59  vsnyder
! Cosmetic changes
!
! Revision 2.1  2002/10/02 15:50:09  bwknosp
! Added Id and RCS info
!
@


2.5
log
@Reworded Copyright statement, moved rcs id
@
text
@d12 1
a12 1
! $Id: pcspl.f9h,v 2.4 2003/11/08 02:17:30 vsnyder Exp $
d172 3
@


2.4
log
@Simplification, polishing
@
text
@d1 10
a10 2
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d12 1
a12 1
! $Id: pcspl.f9h,v 2.3 2002/10/14 21:02:31 vsnyder Exp $
d172 3
@


2.3
log
@Replace CVS variables with comments
@
text
@d4 2
a5 2
! $Id: $
! $RCSfile: $
d8 1
a8 1
!
d33 1
a33 1
!           f(x) = C(1,i)+h*(C(2,i)+h*(C(3,i)+h*C(4,i)/3.)/2.)
d37 1
a37 1
!
d39 1
a39 1
!
d42 1
a42 1
!
d44 2
a45 2
    real(rk) :: DTAU, R, G, DIVDF1, DIVDF3
!
d50 1
a50 1
!
d52 1
a52 1
!
d55 1
a55 1
!
d66 1
a66 1
!
d69 1
a69 1
!
d79 2
a80 2
        r = c(3,2) * c(3,2)
        c(2,1) =((c(3,2)+2.0*c(3,1))*c(4,2)*c(3,3)+r*c(4,3))/c(3,1)
d88 1
a88 1
      c(2,1) = 3.0*c(4,2) - c(3,2)/2.0*c(2,1)
d90 1
a90 1
!
d94 1
a94 1
!
d100 1
a100 1
!
d106 1
a106 1
!
d118 1
a118 1
!
d121 1
a121 1
!
d126 1
a126 1
!
d129 1
a129 1
!
d131 2
a132 3
          r = c(3,n) * c(3,n)
          c(2,n) = ((c(3,n)+2.0*g)*c(4,n)*c(3,n-1) +     &
         &           r*(c(1,n-1)-c(1,n-2))/c(3,n-1)) / g
d137 1
a137 1
!
d139 1
a139 1
!
d141 3
a143 3
      c(2,n) = (g*c(2,n-1) + c(2,n))/c(4,n)
    end if
!
d145 1
a145 1
!
d149 1
a149 1
!
d152 1
a152 1
!
d155 1
a155 1
      divdf1 = (c(1,i) - c(1,i-1))/dtau
d157 2
a158 2
      c(3,i-1) = 2.0*(divdf1 - c(2,i-1) - divdf3)/dtau
      c(4,i-1) = (divdf3/dtau)*(6.0/dtau)
d160 1
a160 1
!
d164 3
@


2.2
log
@Cosmetic changes
@
text
@d4 2
a5 7
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    &  "$Id: $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = &
    & "$RCSfile: $"
!---------------------------------------------------------------------------
d165 3
@


2.1
log
@Added Id and RCS info
@
text
@d5 5
a9 3
  CHARACTER (LEN=256) :: Id = &
       "$Id: pcspl.f9h,v 2.1 2002/04/18 10:46:24 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: pcspl.f9h,v $"
a11 1

d63 1
a63 1
      if (abs(dtau) <= epsilon(tau)) then
d77 1
a77 1
      if (n <= 2) then ! no condition at left end and n = 2.
d120 1
a120 1
          goto 44
d169 4
a172 1
! $Log: d_cspline_m.f90,v $
@


2.0
log
@New forward model
@
text
@d4 7
d167 2
@


1.4
log
@Added Copyright statement
@
text
@@


1.3
log
@Re-add basic stuff
@
text
@d1 3
@


1.2
log
@New version
@
text
@d33 4
a36 4

    real(rk), intent(in) :: TAU(n)
    real(rk), intent(inout) :: C(4, n)

d109 1
a109 1
          goto 140
d141 1
a141 1
140 do j = l, 1, -1
@


1.1
log
@Initial conversion to Fortran 90
@
text
@@

