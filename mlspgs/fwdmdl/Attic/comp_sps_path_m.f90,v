head	2.1;
access;
symbols
	newfwm-sep01:1.1.0.2;
locks; strict;
comment	@# @;


2.1
date	2001.11.02.10.46.38;	author zvi;	state dead;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.26;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.10.10.09.43;	author zvi;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.10.10.09.43;	author zvi;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.09.12.21.38.43;	author zvi;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.09.12.21.47.23;	author zvi;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.09.13.22.51.20;	author zvi;	state Exp;
branches;
next	;


desc
@@


2.1
log
@No longer needed..
@
text
@!
! This is a new module to compute the sps path
!
MODULE comp_sps_path_m
!
  use MLSCommon, only: RP, IP
  USE get_eta_matrix_m, ONLY: get_eta_sparse
!
  IMPLICIT NONE

  Private
  Public :: comp_sps_path

!---------------------------- RCS Ident Info -------------------------------
  character (LEN=256) :: Id = &
 "$Id: comp_sps_path_m.f90,v 2.0 2001/09/17 20:26:26 livesey Exp $"
  character (LEN=*), parameter :: ModuleName= &
 "$RCSfile: comp_sps_path_m.f90,v $"
!-----------------------------------------------------------------
 CONTAINS
!-----------------------------------------------------------------
!
  SUBROUTINE comp_sps_path(z_basis,phi_basis,values,no_z,no_phi,lin_log, &
                      path_zeta,path_phi,path_values,do_calc,eta_zxp)
! Input:
!
  REAL(rp), INTENT(in) :: z_basis(:) ! a vector of zeta basis loaded
!                             sequentially ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: phi_basis(:) ! a vector of orbit plane projected
!                                      horizontal bases, entered squentially
!                             ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: values(:) ! A vector of coefficient break-point
!                         values entered sequentially according to the
!                         heirarch, z_basis, phi_basis, sps_number
  INTEGER(ip), INTENT(in) :: no_z(:) ! number of z_bases by sps number
  INTEGER(ip), INTENT(in) :: no_phi(:) ! number of phi_bases by sps number
  LOGICAL, INTENT(in) :: lin_log(:) ! species representation basis type
  REAL(rp), INTENT(in) :: path_zeta(:) ! zeta values along path for which
!                         species vmr is needed.
  REAL(rp), INTENT(in) :: path_phi(:) ! phi values along path for which
!                         species vmr is needed.
! Output:
!
  REAL(rp), INTENT(out) :: path_values(:,:) ! vmr values along the path
!                          by species number
  LOGICAL, INTENT(out) :: do_calc(:,:) !logical indicating whether there
!                         is a contribution for this state vector element
!                         This is the same length as values.
  REAL(rp), INTENT(out) :: eta_zxp(:,:) ! Eta_z x Eta_phi for each state
!                          vector element. This is the same length as values.
! Notes:
! units of z_basis must be same as zeta_path (usually -log(P)) and units of
! phi_basis must be the same as phi_path (either radians or degrees).
! Units of path_values = values.
!
! Internal declaritions
!
  INTEGER(ip) :: n_p, n_z, npxz
  INTEGER(ip) :: i_sps,n_sps,n_path,sv_i,sv_z,sv_p,sv_j
  INTEGER(ip) :: p_inda,z_inda,v_inda,p_indb,z_indb,v_indb

  REAL(rp), ALLOCATABLE :: eta_z(:,:),eta_p(:,:)
  LOGICAL, ALLOCATABLE :: not_zero_z(:,:), not_zero_p(:,:)
!
! Begin executable code:
!
  n_sps = SIZE(no_z)       ! = SIZE(no_phi) = SIZE(path_values,dim=2)
  n_path = SIZE(path_zeta) ! = SIZE(path_phi) = SIZE(path_values,dim=1)
!
  eta_zxp = 0.0
  do_calc = .false.
  path_values = 0.0_rp
!
  p_inda = 1
  z_inda = 1
  v_inda = 1
!
  DO i_sps = 1 , n_sps
!
    n_z = no_z(i_sps)
    n_p = no_phi(i_sps)
    npxz = n_z * n_p

    z_indb = z_inda + n_z
    p_indb = p_inda + n_p

    v_indb = v_inda + npxz
!
! There are two ways to do this (slow and easy vs quick but difficult)
! For ease lets do the slow and easy (and certainly more reliable)
!
    ALLOCATE(eta_p(1:n_path,1:n_p))
    ALLOCATE(eta_z(1:n_path,1:n_z))
    ALLOCATE(not_zero_p(1:n_path,1:n_p))
    ALLOCATE(not_zero_z(1:n_path,1:n_z))
!
! Compute etas
!
    CALL get_eta_sparse(z_basis(z_inda:z_indb-1),path_zeta,eta_z,not_zero_z)
    CALL get_eta_sparse(phi_basis(p_inda:p_indb-1),path_phi,eta_p,not_zero_p)
!
    IF(lin_log(i_sps)) THEN
!
      DO sv_i = 0 , npxz - 1
        sv_j = v_inda + sv_i
        sv_z = 1 + MODULO(sv_i,n_z)
        sv_p = 1 + sv_i / n_z
        WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
          do_calc(:,sv_j) = .true.
          eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
          path_values(:,i_sps) = path_values(:,i_sps) +  &
                              &  EXP(values(sv_j) * eta_zxp(:,sv_j))
        END WHERE
      END DO
!
    ELSE
!
      DO sv_i = 0 , npxz - 1
        sv_j = v_inda + sv_i
        sv_z = 1 + MODULO(sv_i,n_z)
        sv_p = 1 + sv_i / n_z
        WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
          do_calc(:,sv_j) = .true.
          eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
          path_values(:,i_sps) = path_values(:,i_sps) +  &
                             &   values(sv_j) * eta_zxp(:,sv_j)
        ENDWHERE
      END DO
!
    ENDIF

    z_inda = z_indb
    p_inda = p_indb
    v_inda = v_indb

    DEALLOCATE(not_zero_z)
    DEALLOCATE(not_zero_p)
    DEALLOCATE(eta_z)
    DEALLOCATE(eta_p)
!
  END DO
!
  END SUBROUTINE comp_sps_path
!
END MODULE comp_sps_path_m
!
! $Log: comp_sps_path_m.f90,v $
! Revision 2.0  2001/09/17 20:26:26  livesey
! New forward model
!
! Revision 1.1.2.4  2001/09/13 22:51:20  zvi
! Separating allocation stmts
!
! Revision 1.1.2.3  2001/09/12 21:47:23  zvi
! Adding CVS stuff
!
@


2.0
log
@New forward model
@
text
@d16 1
a16 1
 "$Id: comp_sps_path_m.f90,v 1.1.2.4 2001/09/13 22:51:20 zvi Exp $"
d148 3
@


1.1
log
@file comp_sps_path_m.f90 was initially added on branch newfwm-sep01.
@
text
@d1 153
@


1.1.2.1
log
@Major Design change..
@
text
@a0 131
!
! This is a new module to compute the sps path
!
MODULE comp_sps_path_m
!
  use MLSCommon, only: RP, IP
  USE get_eta_matrix_m, ONLY: get_eta_sparse
!
  IMPLICIT NONE
!
!-----------------------------------------------------------------
 CONTAINS
!-----------------------------------------------------------------
!
  SUBROUTINE comp_sps_path(z_basis,phi_basis,values,no_z,no_phi,lin_log, &
                      path_zeta,path_phi,path_values,do_calc,eta_zxp)
! Input:
!
  REAL(rp), INTENT(in) :: z_basis(:) ! a vector of zeta basis loaded
!                             sequentially ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: phi_basis(:) ! a vector of orbit plane projected
!                                      horizontal bases, entered squentially
!                             ie [basis_1,basis_2,..., basis_n]
  REAL(rp), INTENT(in) :: values(:) ! A vector of coefficient break-point
!                         values entered sequentially according to the
!                         heirarch, z_basis, phi_basis, sps_number
  INTEGER(ip), INTENT(in) :: no_z(:) ! number of z_bases by sps number
  INTEGER(ip), INTENT(in) :: no_phi(:) ! number of phi_bases by sps number
  LOGICAL, INTENT(in) :: lin_log(:) ! species representation basis type
  REAL(rp), INTENT(in) :: path_zeta(:) ! zeta values along path for which
!                         species vmr is needed.
  REAL(rp), INTENT(in) :: path_phi(:) ! phi values along path for which
!                         species vmr is needed.
! Output:
!
  REAL(rp), INTENT(out) :: path_values(:,:) ! vmr values along the path
!                          by species number
  LOGICAL, INTENT(out) :: do_calc(:,:) !logical indicating whether there
!                         is a contribution for this state vector element
!                         This is the same length as values.
  REAL(rp), INTENT(out) :: eta_zxp(:,:) ! Eta_z x Eta_phi for each state
!                          vector element. This is the same length as values.
! Notes:
! units of z_basis must be same as zeta_path (usually -log(P)) and units of
! phi_basis must be the same as phi_path (either radians or degrees).
! Units of path_values = values.
!
! Internal declaritions
!
  INTEGER(ip) :: n_p, n_z, npxz
  INTEGER(ip) :: i_sps,n_sps,n_path,sv_i,sv_z,sv_p,sv_j
  INTEGER(ip) :: p_inda,z_inda,v_inda,p_indb,z_indb,v_indb

  REAL(rp), ALLOCATABLE :: eta_z(:,:),eta_p(:,:)
  LOGICAL, ALLOCATABLE :: not_zero_z(:,:), not_zero_p(:,:)
!
! Begin executable code:
!
  n_sps = SIZE(no_z)       ! = SIZE(no_phi) = SIZE(path_values,dim=2)
  n_path = SIZE(path_zeta) ! = SIZE(path_phi) = SIZE(path_values,dim=1)
!
  eta_zxp = 0.0
  do_calc = .false.
  path_values = 0.0_rp
!
  p_inda = 1
  z_inda = 1
  v_inda = 1
!
  DO i_sps = 1 , n_sps
!
    n_z = no_z(i_sps)
    n_p = no_phi(i_sps)
    npxz = n_z * n_p

    z_indb = z_inda + n_z
    p_indb = p_inda + n_p

    v_indb = v_inda + npxz
!
! There are two ways to do this (slow and easy vs quick but difficult)
! For ease lets do the slow and easy (and certainly more reliable)
!
    ALLOCATE(eta_p(1:n_path,1:n_p),eta_z(1:n_path,1:n_z), &
          &  not_zero_p(1:n_path,1:n_p),not_zero_z(1:n_path,1:n_z))
!
! Compute etas
!
    CALL get_eta_sparse(z_basis(z_inda:z_indb-1),path_zeta,eta_z,not_zero_z)
    CALL get_eta_sparse(phi_basis(p_inda:p_indb-1),path_phi,eta_p,not_zero_p)
!
    IF(lin_log(i_sps)) THEN
!
      DO sv_i = 0 , npxz - 1
        sv_j = v_inda + sv_i
        sv_z = 1 + MODULO(sv_i,n_z)
        sv_p = 1 + sv_i / n_z
        WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
          do_calc(:,sv_j) = .true.
          eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
          path_values(:,i_sps) = path_values(:,i_sps) +  &
                              &  EXP(values(sv_j) * eta_zxp(:,sv_j))
        END WHERE
      END DO
!
    ELSE
!
      DO sv_i = 0 , npxz - 1
        sv_j = v_inda + sv_i
        sv_z = 1 + MODULO(sv_i,n_z)
        sv_p = 1 + sv_i / n_z
        WHERE(not_zero_z(:,sv_z) .AND. not_zero_p(:,sv_p))
          do_calc(:,sv_j) = .true.
          eta_zxp(:,sv_j) = eta_z(:,sv_z) * eta_p(:,sv_p)
          path_values(:,i_sps) = path_values(:,i_sps) +  &
                             &   values(sv_j) * eta_zxp(:,sv_j)
        ENDWHERE
      END DO
!
    ENDIF

    z_inda = z_indb
    p_inda = p_indb
    v_inda = v_indb
    DEALLOCATE(eta_p,eta_z,not_zero_p,not_zero_z)
!
  END DO
!
  END SUBROUTINE comp_sps_path
!
END MODULE comp_sps_path_m
@


1.1.2.2
log
@Added CVS stuff
@
text
@a9 3

  Private
  Public :: comp_sps_path
@


1.1.2.3
log
@Adding CVS stuff
@
text
@d13 1
a13 6

!---------------------------- RCS Ident Info -------------------------------
  character (LEN=256) :: Id = &
 "$Id: load_sps_data_m.f90,v 1.1.2.10 2001/09/12 21:38:51 zvi Exp $"
  character (LEN=*), parameter :: ModuleName= &
 "$RCSfile: load_sps_data_m.f90,v $"
a134 2
!
! $Log$
@


1.1.2.4
log
@Separating allocation stmts
@
text
@d16 1
a16 1
 "$Id: comp_sps_path_m.f90,v 1.1.2.3 2001/09/12 21:47:23 zvi Exp $"
d18 1
a18 1
 "$RCSfile: comp_sps_path_m.f90,v $"
d92 2
a93 4
    ALLOCATE(eta_p(1:n_path,1:n_p))
    ALLOCATE(eta_z(1:n_path,1:n_z))
    ALLOCATE(not_zero_p(1:n_path,1:n_p))
    ALLOCATE(not_zero_z(1:n_path,1:n_z))
d133 1
a133 5

    DEALLOCATE(not_zero_z)
    DEALLOCATE(not_zero_p)
    DEALLOCATE(eta_z)
    DEALLOCATE(eta_p)
d141 1
a141 4
! $Log: comp_sps_path_m.f90,v $
! Revision 1.1.2.3  2001/09/12 21:47:23  zvi
! Adding CVS stuff
!
@


