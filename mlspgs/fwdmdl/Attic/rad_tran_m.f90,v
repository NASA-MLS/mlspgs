head	2.53;
access;
symbols
	V2-21:2.51
	V2-20:2.51
	V2-11:2.51
	V2-10:2.51
	V2-00:2.50
	V1-51:2.41
	V1-50:2.41
	V1-45:2.39
	V1-44:2.39
	V1-43:2.38
	V1-32:2.33
	V1-31:2.33
	V1-30:2.20
	V1-13:2.12
	V1-12:2.12
	V1-11:2.12
	V1-10:2.12
	newfwm-feb03:2.12.0.2
	V1-04:2.3
	V1-03:2.3
	V1-02:2.3
	JointForwardModel:2.5.0.2
	V1-00:2.3
	newfwm-sep01:1.11.0.2
	V0-7:1.11
	V0-5-Level2:1.8
	V0-5-SIPS:1.8;
locks; strict;
comment	@# @;


2.53
date	2007.06.08.22.04.50;	author vsnyder;	state dead;
branches;
next	2.52;

2.52
date	2006.12.13.02.32.03;	author vsnyder;	state Exp;
branches;
next	2.51;

2.51
date	2006.07.20.01.09.27;	author vsnyder;	state Exp;
branches;
next	2.50;

2.50
date	2006.04.11.18.31.58;	author vsnyder;	state Exp;
branches;
next	2.49;

2.49
date	2006.02.08.01.02.01;	author vsnyder;	state Exp;
branches;
next	2.48;

2.48
date	2005.11.21.22.57.27;	author vsnyder;	state Exp;
branches;
next	2.47;

2.47
date	2005.11.01.23.02.21;	author vsnyder;	state Exp;
branches;
next	2.46;

2.46
date	2005.09.17.00.49.54;	author vsnyder;	state Exp;
branches;
next	2.45;

2.45
date	2005.06.22.18.08.19;	author pwagner;	state Exp;
branches;
next	2.44;

2.44
date	2005.04.26.15.35.54;	author livesey;	state Exp;
branches;
next	2.43;

2.43
date	2005.03.28.20.24.37;	author vsnyder;	state Exp;
branches;
next	2.42;

2.42
date	2005.03.03.02.07.42;	author vsnyder;	state Exp;
branches;
next	2.41;

2.41
date	2004.11.01.20.25.44;	author vsnyder;	state Exp;
branches;
next	2.40;

2.40
date	2004.10.06.21.18.24;	author vsnyder;	state Exp;
branches;
next	2.39;

2.39
date	2004.08.03.22.06.46;	author vsnyder;	state Exp;
branches;
next	2.38;

2.38
date	2004.04.17.00.37.00;	author vsnyder;	state Exp;
branches;
next	2.37;

2.37
date	2004.03.20.01.15.39;	author jonathan;	state Exp;
branches;
next	2.36;

2.36
date	2004.03.08.22.58.03;	author vsnyder;	state Exp;
branches;
next	2.35;

2.35
date	2004.02.03.02.47.55;	author vsnyder;	state Exp;
branches;
next	2.34;

2.34
date	2004.01.23.01.16.05;	author vsnyder;	state Exp;
branches;
next	2.33;

2.33
date	2003.12.08.17.52.47;	author jonathan;	state Exp;
branches;
next	2.32;

2.32
date	2003.12.03.00.25.32;	author vsnyder;	state Exp;
branches;
next	2.31;

2.31
date	2003.11.04.02.49.50;	author vsnyder;	state Exp;
branches;
next	2.30;

2.30
date	2003.11.04.01.55.50;	author vsnyder;	state Exp;
branches;
next	2.29;

2.29
date	2003.11.01.03.04.02;	author vsnyder;	state Exp;
branches;
next	2.28;

2.28
date	2003.10.30.20.36.41;	author vsnyder;	state Exp;
branches;
next	2.27;

2.27
date	2003.10.16.23.06.09;	author vsnyder;	state Exp;
branches;
next	2.26;

2.26
date	2003.10.15.02.04.08;	author vsnyder;	state Exp;
branches;
next	2.25;

2.25
date	2003.10.09.21.04.38;	author vsnyder;	state Exp;
branches;
next	2.24;

2.24
date	2003.10.09.15.30.58;	author livesey;	state Exp;
branches;
next	2.23;

2.23
date	2003.09.25.20.06.03;	author vsnyder;	state Exp;
branches;
next	2.22;

2.22
date	2003.09.24.22.19.55;	author vsnyder;	state Exp;
branches;
next	2.21;

2.21
date	2003.09.09.22.34.45;	author vsnyder;	state Exp;
branches;
next	2.20;

2.20
date	2003.09.09.00.02.55;	author vsnyder;	state Exp;
branches;
next	2.19;

2.19
date	2003.08.15.18.50.22;	author vsnyder;	state Exp;
branches;
next	2.18;

2.18
date	2003.06.27.22.05.48;	author vsnyder;	state Exp;
branches;
next	2.17;

2.17
date	2003.06.18.17.24.05;	author bill;	state Exp;
branches;
next	2.16;

2.16
date	2003.06.09.20.52.37;	author vsnyder;	state Exp;
branches;
next	2.15;

2.15
date	2003.05.20.00.04.28;	author vsnyder;	state Exp;
branches;
next	2.14;

2.14
date	2003.05.15.03.29.00;	author vsnyder;	state Exp;
branches;
next	2.13;

2.13
date	2003.05.05.23.00.26;	author livesey;	state Exp;
branches;
next	2.12;

2.12
date	2003.02.07.02.35.48;	author vsnyder;	state Exp;
branches
	2.12.2.1;
next	2.11;

2.11
date	2003.02.07.02.12.00;	author vsnyder;	state Exp;
branches;
next	2.10;

2.10
date	2003.02.03.19.00.52;	author bill;	state Exp;
branches;
next	2.9;

2.9
date	2003.01.08.00.15.42;	author vsnyder;	state Exp;
branches;
next	2.8;

2.8
date	2002.10.08.17.08.06;	author pwagner;	state Exp;
branches;
next	2.7;

2.7
date	2002.10.02.20.09.48;	author vsnyder;	state Exp;
branches;
next	2.6;

2.6
date	2002.07.05.07.52.52;	author zvi;	state Exp;
branches;
next	2.5;

2.5
date	2002.06.13.22.38.40;	author bill;	state Exp;
branches;
next	2.4;

2.4
date	2002.06.04.10.28.04;	author zvi;	state Exp;
branches;
next	2.3;

2.3
date	2002.02.16.06.38.05;	author zvi;	state Exp;
branches;
next	2.2;

2.2
date	2002.01.30.01.11.22;	author zvi;	state Exp;
branches;
next	2.1;

2.1
date	2002.01.27.08.37.51;	author zvi;	state Exp;
branches;
next	2.0;

2.0
date	2001.09.17.20.26.27;	author livesey;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.04.00.34.24;	author zvi;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.06.21.13.07.09;	author zvi;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.07.23.39.31;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.09.23.33.41;	author zvi;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.09.20.52.07;	author zvi;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.31.23.40.55;	author zvi;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.30.20.28.21;	author zvi;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.29.08.51.01;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.26.09.01.16;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.23.07.29;	author zvi;	state Exp;
branches;
next	;

1.11.2.1
date	2001.09.10.10.02.32;	author zvi;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.09.11.00.00.46;	author zvi;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.09.13.22.51.24;	author zvi;	state Exp;
branches;
next	;

2.12.2.1
date	2003.03.05.03.31.13;	author vsnyder;	state Exp;
branches;
next	2.12.2.2;

2.12.2.2
date	2003.03.20.01.42.26;	author vsnyder;	state Exp;
branches;
next	;


desc
@@


2.53
log
@Replaced by rad_tran_m.F90
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module RAD_TRAN_M

  implicit NONE
  private
  public :: RAD_TRAN, RAD_TRAN_POL
  public :: DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
  public :: Get_Do_Calc
  private ::  Get_Do_Calc_Indexed, Get_Inds

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: rad_tran_m.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------------

!------------------------------------------------------  Rad_tran  -----
! This is the radiative transfer model, radiances only !

  subroutine Rad_tran ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
                     &  alpha_path_c, ref_cor, incoptdepth, &
                     &  alpha_path_gl, ds_dz_gw, t_script, &
                     &  tau, inc_rad_path, rad, i_stop )

    use GLNP, only: NG
    use MLSKinds, only: RP, IP
    use SCRT_DN_M, ONLY: SCRT

  ! inputs

    integer, intent(in) :: Tan_pt            ! Tangent point index in Del_Zeta
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
  !                                            where GL is needed
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient on coarse
  !                                            grid.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
  !                                            length ratios.
    real(rp), intent(inout) :: incoptdepth(:) ! incremental path opacities
  !                            from one-sided layer calculation on output.
  !                            it is the full integrated layer opacity.
    real(rp), intent(in) :: alpha_path_gl(:) ! absorption coefficient on gl
  !                                            grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
    real(rp), intent(in) :: t_script(:)      ! differential temperatures (K)
  !                                            on coarse grid.
  ! outputs

    real(rp), intent(out) :: tau(:)          ! transmission function.
    real(rp), intent(out) :: inc_rad_path(:) ! incremental radiance along the
                                             ! path.  t_script * tau.
    real(rp), intent(out) :: rad             ! radiance (K)
    integer(ip), intent(out) :: i_stop       ! path stop index

  ! Internals

    integer :: A, AA, I
  !                                            where GL is needed

  ! Begin code

  ! see if anything needs to be gl-d

    if ( size(gl_inds) > 0 ) then

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt incoptdepth}.
      !  In the second integral, $G(\zeta)$ is {\tt alpha\_path\_gl} --
      !  which has already been evaluated at the appropriate abscissae -- and
      !  $G(\zeta_i)$ is {\tt alpha\_path\_c}.  The weights are {\tt gw}.

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        incoptdepth(more_inds(i)) = incoptdepth(more_inds(i)) + &
          & del_zeta(more_inds(i)) * &
          & dot_product( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))), &
               & ds_dz_gw(aa:aa+ng-1) )
        a = a + ng
      end do ! i

    end if

    incoptdepth = ref_cor * incoptdepth

    call scrt ( tan_pt, t_script, e_rflty, incoptdepth, tau, rad, inc_rad_path, &
      &         i_stop )

  end subroutine Rad_tran

!--------------------------------------------------  Rad_Tran_Pol  -----

  subroutine Rad_tran_Pol ( tan_pt, gl_inds, more_inds, e_rflty, del_zeta, &
                     &  alpha_path_c, ref_cor, incoptdepth_pol, deltau_pol, &
                     &  alpha_path_gl, ds_dz_gw, ct, stcp, stsp, t_script, &
                     &  prod_pol, tau_pol, rad_pol, p_stop )

    ! Polarized radiative transfer.  Radiances only, no derivatives.

    use CS_Expmat_m, only: CS_Expmat
    use DO_DELTA_M, ONLY: POLARIZED_PATH_OPACITY
    use GLNP, ONLY: Ng
    use MCRT_M, ONLY: MCRT
    use MLSKinds, only: RP, IP
    use Opacity_m, only: Opacity

  ! inputs

    integer, intent(in) :: Tan_pt            ! Tangent point index in Del_Zeta
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
  !                                            where GL is needed
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    complex(rp), intent(in) :: alpha_path_c(-1:,:)  ! absorption coefficient
      !              on coarse grid.
    complex(rp), intent(inout) :: deltau_pol(:,:,:) ! 2 X 2 X path.  Incremental
      !              transmissivity on the coarse path. Called E in some notes.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !              length ratios.
    complex(rp), intent(inout) :: incoptdepth_pol(:,:,:) ! incremental path
      !              opacities from one-sided layer calculation on output. it
      !              is the full integrated layer opacity. 2x2xPath
    complex(rp), intent(in) :: alpha_path_gl(-1:,:) ! absorption coefficient on
      !              gl grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: CT(:)            ! Cos theta          for Mag field
    real(rp), intent(in) :: STCP(:)          ! Sin theta Cos Phi  for Mag field
    real(rp), intent(in) :: STSP(:)          ! Sin theta Sin Phi  for Mag field
    real(rp), intent(in) :: T_script(:)      ! differential temperatures (K)
      !              on coarse path.

  ! outputs

    complex(rp), intent(out) :: prod_pol(:,:,:) ! product of E matrices. 2x2xPath
    complex(rp), intent(out) :: tau_pol(:,:,:)  ! transmission function. 2x2xPath
    complex(rp), intent(out) :: rad_pol(:,:)    ! radiance (K). 2x2.
    integer(ip), intent(out) :: p_stop       ! path stop index if >= 0, else
      !              -index in incoptdepth_pol where cs_expmat failed.

  ! Internals

    real(rp), save :: E_Stop  = 1.0_rp ! X for which Exp(X) is too small to worry
    complex(rp) :: gl_delta_polarized(-1:1,size(gl_inds)/ng)
    complex(rp) :: incoptdepth_pol_gl(2,2,size(gl_inds)/ng)
    integer(ip) :: N_PATH
    integer :: Status ! from cs_expmat

  ! Begin code

    n_path = size(del_zeta)

    if ( e_stop > 0.0_rp ) e_stop = log(epsilon(0.0_rp)) ! only once

  ! see if anything needs to be gl-d

    if ( size(gl_inds) > 0 ) then

      call polarized_path_opacity ( del_zeta,    &
                 &  alpha_path_c, alpha_path_gl, &
                 &  ds_dz_gw,                    &
                 &  gl_delta_polarized, more_inds, gl_inds )

      ! Turn sigma-, pi, sigma+ GL corrections into 2X2 matrix of
      ! GL corrections to incoptdepth_pol
      call opacity ( ct(more_inds), stcp(more_inds), stsp(more_inds), &
        & gl_delta_polarized, incoptdepth_pol_gl )

      ! add GL corrections to incoptdepth_pol
      incoptdepth_pol(:,:,more_inds) = incoptdepth_pol(:,:,more_inds) - &
        & incoptdepth_pol_gl

    end if

    ! At this point, incoptdepth_pol(:,:,1:tan_pt_c) should be nearly
    ! identical to incoptdepth_pol(:,:,1:tan_pt_c+1) (tan_pt_c is the
    ! zero-thickness tangent layer).

    do p_stop = 0, n_path-1
      incoptdepth_pol(:,:,p_stop+1) = incoptdepth_pol(:,:,p_stop+1) * &
        &                             ref_cor(p_stop+1)
      ! exp(A) = exp(s) * ((sinh d)/d (A - s I) + cosh d I) where
      ! s is the sum of A's eigenvalues and d is their difference.
      ! (sinh d)/d and cosh d can be large and positive even when
      ! s is large and negative, so we can't stop just because s
      ! is large and negative.  Well, we could if we knew d was small,
      ! but once we have both eigenvalues we've almost finished the
      ! exponential anyway.
      call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), &
        &              deltau_pol(:,:,p_stop+1), status )  
      if ( status /= 0 ) go to 99 ! because we can't change p_stop in the loop
    end do

    call mcrt ( t_script, sqrt(e_rflty), deltau_pol, &
      & tan_pt, p_stop, prod_pol, tau_pol, rad_pol )

    return

  ! Error exit if cs_expmat detected an overflow
  99 p_stop = - p_stop - 1

  end subroutine Rad_tran_Pol

!--------------------------------------------------  DRad_tran_df  -----
! This is the radiative transfer derivative wrt mixing ratio model

  subroutine DRad_tran_df ( indices_c, gl_inds, del_zeta, Grids_f,       &
                         &  beta_path_c, eta_zxp_f, sps_path, do_calc_f, &
                         &  beta_path_f, do_gl, del_s, ref_cor,          &
                         &  ds_dz_gw, inc_rad_path, tan_pt, i_stop,      &
                         &  d_delta_df, drad_df )

    use GLNP, only: NG
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP, IP
    use SCRT_DN_M, ONLY: DSCRT_DX
    use Where_M, only: Where

! Inputs

    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)   ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: beta_path_c(:,:) ! cross section for each species
      !                                        on coarse grid.
    real(rp), intent(in) :: eta_zxp_f(:,:)   ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero.
    real(rp), intent(in) :: beta_path_f(:,:) ! cross section for each species
      !                                        on gl grid.
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    integer, intent(in) :: tan_pt            ! path stop index
    integer(ip), intent(in) :: i_stop        ! path stop index

! Outputs

    real(rp), intent(out) :: d_delta_df(:,:) ! path x sve.  derivative of delta
      !              wrt mixing ratio state vector element. (K)
    real(rp), intent(out) :: drad_df(:)      ! derivative of radiances wrt
      !              mixing ratio state vector element. (K)
! Internals

    integer(ip) :: A, AA, GA(ng), I, II, III
    integer(ip) :: i_start, n_inds, no_to_gl, sps_i, sps_n, sv_i
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

     real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.
     logical :: do_calc(1:size(inc_rad_path)) ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).

! Begin code

    sps_n = ubound(Grids_f%l_z,1)

    do sps_i = 1, sps_n

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

        d_delta_df(:,sv_i) = 0.0_rp

! Skip the masked derivatives, according to the l2cf inputs

        if ( .not. Grids_f%deriv_flags(sv_i) ) then
          drad_df(sv_i) = 0.0
          cycle
        end if

        call get_do_calc_indexed ( do_calc_f(:,sv_i), indices_c, gl_inds, &
          & do_gl, do_calc )

! find where the non zeros are along the path

        n_inds = count(do_calc)
        if ( n_inds > 0 ) then

          inds => inds_B(1:n_inds)

          call where ( do_calc, inds )

          no_to_gl = count(do_gl(inds))

          if ( no_to_gl > 0 ) then

! see if anything needs to be gl-d

            all_inds => all_inds_B(1:ng*no_to_gl)
            more_inds => more_inds_B(1:no_to_gl)

            call get_inds ( do_gl, do_calc, more_inds, all_inds )
          end if

          if ( grids_f%lin_log(sps_i) ) then

            do i = 1, n_inds ! Don't trust the compiler to fuse loops
              ii = inds(i)
              iii = indices_c(ii)
              singularity(ii) = beta_path_c(ii,sps_i) &
                        & * eta_zxp_f(iii,sv_i) * sps_path(iii,sps_i)
              d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
            end do ! i

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
      !  sps\_path} -- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              aa = all_inds(a)
              ga = gl_inds(aa:aa+ng-1)
              ii = more_inds(i)
              d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                & del_zeta(ii) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) &
                     &   * eta_zxp_f(ga,sv_i) * sps_path(ga,sps_i) - &
                     &  singularity(ii)) * ds_dz_gw(ga) )
              a = a + ng
            end do

            ! Refraction correction
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) * &
                                  & exp(-grids_f%values(sv_i))

          else

            do i = 1, n_inds ! Don't trust the compiler to fuse loops
              ii = inds(i)
              singularity(ii) = beta_path_c(ii,sps_i) &
                        & * eta_zxp_f(indices_c(ii),sv_i)
              d_delta_df(ii,sv_i) = singularity(ii) * del_s(ii)
            end do ! i

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f *
      !  eta\_zxp\_f}~-- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              aa = all_inds(a)
              ga = gl_inds(aa:aa+ng-1)
              ii = more_inds(i)
              d_delta_df(ii,sv_i) = d_delta_df(ii,sv_i) + &
                & del_zeta(ii) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) * eta_zxp_f(ga,sv_i) - &
                     &  singularity(ii)) * ds_dz_gw(ga) )
              a = a + ng
            end do

            ! Refraction correction
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i)

          end if

          i_start = MIN(inds(1),i_stop)

          call dscrt_dx ( tan_pt, d_delta_df(:,sv_i), inc_rad_path, &
                       &  i_start, i_stop, drad_df(sv_i))

        else
          drad_df(sv_i) = 0.0
        end if

      end do ! sv_i

    end do ! sps_i

  end subroutine drad_tran_df

!--------------------------------------------------  drad_tran_dt  -----
! This is the radiative transfer derivative wrt temperature model

  subroutine DRad_tran_dt ( del_zeta, h_path_c, dh_dt_path_c, &
                         &  alpha_path_c, dAlpha_dT_path_c, &
                         &  eta_zxp_c, do_calc_t_c, &
                         &  do_calc_hyd_c, del_s, ref_cor, h_tan, dh_dt_tan, &
                         &  do_gl, gl_inds, h_path_f, t_path_f, dh_dt_path_f, &
                         &  alpha_path_f, dAlpha_dT_path_f, &
                         &  eta_zxp_f, do_calc_t_f, &
                         &  ds_dh, dh_dz_gw, ds_dz_gw, dt_scr_dt, &
                         &  tau, inc_rad_path, tan_pt, i_stop, deriv_flags, &
                         &  pfa_update, drad_dt )

    use GLNP, only: NG
    use MLSKinds, only: RP, IP
    use SCRT_DN_M, ONLY: DSCRT_DT, DSCRT_DX
    use Where_M, only: Where

! Inputs

    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: h_path_c(:)     ! path heights + req on main grid km.
    real(rp), intent(in) :: dh_dt_path_c(:,:) ! derivative of path height wrt
!                                               temperature(km/K) on main grid.
    real(rp), intent(in) :: alpha_path_c(:) ! path absorption(km^-1)
!                                             on main grid.
    real(rp), intent(in) :: dAlpha_dT_path_c(:) ! path dAlpha/dT on main grid
    real(rp), intent(in) :: eta_zxp_c(:,:)  ! representation basis function
!                                              main grid.
    logical, intent(in) :: do_calc_t_c(:,:) ! Indicates where the
!                    representation basis function is not zero on main grid.
    logical, intent(in) :: do_calc_hyd_c(:,:) ! Indicates where dh_dt is not
!                                             zero on main grid.
    real(rp), intent(in) :: del_s(:)        ! unrefracted path length.
    real(rp), intent(in) :: ref_cor(:)      ! refracted to unrefracted path
!                                             length ratios.
    real(rp), intent(in) :: h_tan           ! tangent height + req (km).
    real(rp), intent(in) :: dh_dt_tan(:)    ! derivative of path height wrt
!                                             temperature at the tangent (km/K).
    logical, intent(in) :: do_gl(:)         ! Indicates where on the coarse path
!                                             to do gl integrations.
    integer, intent(in) :: GL_Inds(:)       ! Where is do_gl true?
    real(rp), intent(in) :: h_path_f(:)     ! path heights + req on gl grid km.
    real(rp), intent(in) :: t_path_f(:)     ! path temperature(K) on gl grid.
    real(rp), intent(in) :: dh_dt_path_f(:,:) ! derivative of path height wrt
!                                               temperature(km/K) on gl grid.
    real(rp), intent(in) :: alpha_path_f(:) ! path absorption(km^-1) on gl grid.
    real(rp), intent(in) :: dAlpha_dT_path_f(:) ! path dAlpha/dT on gl grid
    real(rp), intent(in) :: eta_zxp_f(:,:)  ! representation basis function
!                                             gl grid.
    logical, intent(in) :: do_calc_t_f(:,:) ! Indicates where the
!                    representation basis function is not zero on gl grid.
    real(rp), intent(in) :: ds_dh(:)        ! path length wrt height derivative
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
    real(rp), intent(in) :: dh_dz_gw(:)     ! path height wrt zeta derivative * gw
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
    real(rp), intent(in) :: ds_dz_gw(:)     ! path length wrt zeta derivative * gw
!                                             on complete grid.  Only the
!                                             gl_inds part is used.
    real(rp), intent(in) :: dt_scr_dt(:,:)  ! d t_script / d T * d T / d eta.
    real(rp), intent(in) :: tau(:)          ! transmission function.
    real(rp), intent(in) :: inc_rad_path(:) ! incremental radiance along the
                                            ! path.  t_script * tau.
    integer, intent(in) :: Tan_pt           ! Tangent point index in Del_Zeta
    integer(ip), intent(in) :: i_stop       ! path stop index
    logical, intent(in) :: deriv_flags(:)   ! Indicates which temperature
!                                             derivatives to do
    logical, intent(in) :: PFA_Update       ! Use DSCRT_DX instead of DSCRT_DT.

! Output
    real(rp), intent(out) :: drad_dt(:)     ! derivative of radiances wrt
!                                             temperature state vector
!                                             element. (K)
! Internals

    integer(ip) :: A, AA, B, BB
    integer(ip) :: i, j, i_start, n_inds, n_path, no_to_gl, p_i, sv_i
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

    real(rp) :: d_delta_dt(size(eta_zxp_c,1),size(eta_zxp_c,2)) ! path x sve.
      ! derivative of delta (incremental opacity) wrt temperature. (K)

    real(rp) :: fa, fb
    real(rp) :: S_DEl_S                  ! Running sum of Del_S
    real(rp) :: singularity(1:size(del_zeta)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

    logical :: do_calc(1:size(del_zeta)) ! do_calc_t_c .or. ( do_gl .and. any
                                         ! of the corresponding do_calc_t_f ).
    logical :: NeedFA                    ! Need F(A) for hydrostatic

! Begin code

    n_path = size(del_zeta)

! compute the opacity derivative singularity value

    d_delta_dt = 0.0_rp

    do sv_i = 1 , size(eta_zxp_c,dim=2)
      drad_dt(sv_i) = 0.0
      if ( .not. deriv_flags(sv_i)) cycle
      i_start = 1

! do the absorption part
! combine non zeros flags for both the main and gl parts

      call get_do_calc ( do_calc_t_c(:,sv_i), do_calc_t_f(:,sv_i), do_gl, &
        & do_calc )

! find where the non zeros are along the path

      n_inds = count(do_calc)
      if ( n_inds > 0 ) then
        inds => inds_B(1:n_inds)

        call where ( do_calc, inds )
        i_start = max(inds(1)-1,1)

        do i = 1, n_inds ! Don't trust the compiler to fuse loops
          j = inds(i)
          singularity(j) = dAlpha_dT_path_c(j) * eta_zxp_c(j,sv_i)
          d_delta_dt(j,sv_i) = singularity(j) * del_s(j)
        end do ! i

! see if anything needs to be gl-d

        no_to_gl = count(do_gl(inds))
        if ( no_to_gl > 0 ) then

          all_inds => all_inds_B(1:ng*no_to_gl)
          more_inds => more_inds_B(1:no_to_gl)

          call get_inds ( do_gl, do_calc, more_inds, all_inds )

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_dt}.
      !  In the second integral, $G(\zeta)$ is {\tt alphaxn\_path\_f *
      !  eta\_zxp\_f / t\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

          a = 1
          do i = 1, no_to_gl
            aa = all_inds(a)
            bb = aa + ng - 1
            j = more_inds(i)
            d_delta_dt(j,sv_i) = d_delta_dt(j,sv_i) + &
              & del_zeta(j) * &
              & sum( (dAlpha_dT_path_f(aa:bb) * eta_zxp_f(aa:bb,sv_i) - &
                   &  singularity(j)) * &
                   & ds_dz_gw(gl_inds(aa:bb)) )
            a = a + ng
          end do
        end if ! no_to_gl > 0

      end if ! n_inds > 0

! now do the hydrostatic part
! combine boundaries flags

      do_calc = do_calc_hyd_c(:,sv_i)
      do_calc(2:tan_pt) =          do_calc(tan_pt)   .or. do_calc(2:tan_pt)          .or. do_calc(1:tan_pt-1)
      do_calc(tan_pt+1:n_path-1) = do_calc(tan_pt+1) .or. do_calc(tan_pt+1:n_path-1) .or. do_calc(tan_pt+2:n_path)

! since this is a layer boundary calculation we must require

      do_calc((/1,n_path/)) = .false.

! find where the non zeros are along the path

      n_inds = count(do_calc)
      needFA = .true.
      fa = 0.0_rp ! in case n_path <= 4
      if ( n_inds > 0 ) then
        inds => inds_B(1:n_inds)
        i = 1
        inds = 0
        s_del_s = sum(del_s(2:tan_pt))
        do p_i = 2 , tan_pt - 1
          if ( do_calc(p_i) ) then
            if ( needFA ) then ! only once in this loop
              fa = (h_path_c(p_i-1) * dh_dt_path_c(p_i-1,sv_i) - &
                 &  h_tan * dh_dt_tan(sv_i)) / s_del_s
              needFA = .false.
            end if
            s_del_s = s_del_s - del_s(p_i)
            fb = (h_path_c(p_i) * dh_dt_path_c(p_i,sv_i) - &
                & h_tan * dh_dt_tan(sv_i)) / s_del_s
            inds(i) = p_i
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              &                    alpha_path_c(p_i) * (fa - fb)
            fa = fb
            i = i + 1
          else
            s_del_s = s_del_s - del_s(p_i)
          end if
        end do ! p_i

! special processing at tangent.  fb is zero

        if ( do_calc(tan_pt) ) then
          d_delta_dt(tan_pt,sv_i) = d_delta_dt(tan_pt,sv_i) + alpha_path_c(tan_pt) * fa
          inds(i) = tan_pt
          i = i + 1
        end if

        needFA = .not. do_calc(tan_pt+1)
        s_del_s = del_s(tan_pt+1)
        if ( do_calc(tan_pt+1) ) then
          fa = (h_path_c(tan_pt+2) * dh_dt_path_c(tan_pt+2,sv_i) - &
              & h_tan * dh_dt_tan(sv_i)) / s_del_s
          d_delta_dt(tan_pt+1,sv_i) = d_delta_dt(tan_pt+1,sv_i) + &
            &                      alpha_path_c(tan_pt+1) * fa
          inds(i) = tan_pt + 1
          i = i + 1
        end if

        ! Several subscripts in this loop are offset by 1 from the nearly-
        ! identical loop above, and we use (fb-fa) here instead of (fa-fb).
        do p_i = tan_pt + 2, n_path - 1
          if ( do_calc(p_i) ) then
            if ( needFA ) then ! only once in this loop
              fa = (h_path_c(p_i) * dh_dt_path_c(p_i,sv_i) - &
                 &  h_tan * dh_dt_tan(sv_i)) / s_del_s
              needFA = .false.
            end if
            s_del_s = s_del_s + del_s(p_i)
            fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1,sv_i) - &
               &  h_tan * dh_dt_tan(sv_i)) / s_del_s
            inds(i) = p_i
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              &                    alpha_path_c(p_i) * (fb - fa)
            fa = fb
            i = i + 1
          else
            s_del_s = s_del_s + del_s(p_i)
          end if
        end do ! p_i

        ! Do GL for hydrostatic for any panels that need it; the singularity
        ! correction is alpha_path_c.
        a = 1
        do p_i = 2, n_path-1           ! along the path
          if ( do_gl(p_i) ) then
            b = a + ng
            ! Don't test do_calc: There may be GL corrections even if
            ! dh_dt_path_c (from whence came do_calc) is zero.
            d_delta_dt(p_i,sv_i) = d_delta_dt(p_i,sv_i) + &
              & del_zeta(p_i) * &
              & sum( ( alpha_path_f(a:b-1) - alpha_path_c(p_i) ) *   &
              & (((2.0_rp*h_path_f(a:b-1)**2 - 3.0_rp*h_tan**2)      &     
              &   * dh_dt_path_f(a:b-1,sv_i) +                       &     
              &   h_path_f(a:b-1) * h_tan * dh_dt_tan(sv_i)) /       &     
              &  (sqrt(h_path_f(a:b-1)**2 - h_tan**2))**3            &     
              &  + eta_zxp_f(a:b-1,sv_i) * ds_dh(gl_inds(a:b-1)) /   &     
              &  t_path_f(a:b-1)) * dh_dz_gw(gl_inds(a:b-1)) )
            a = b
          end if
        end do ! p_i

        i_start = min(i_start,inds(1))

      end if ! n_inds for hydrostatic > 0

! correct for path length refraction

      d_delta_dt(:,sv_i) = ref_cor(:) * d_delta_dt(:,sv_i)

! Accumulate the incremental opacity derivatives to get drad_dt

      if ( PFA_update ) then
        ! If we're doing a PFA update, we do not want to include
        ! dt_scr_dt again.

        call dscrt_dx ( tan_pt, d_delta_dt(:,sv_i), inc_rad_path, i_start, i_stop, &
                     &  drad_dt(sv_i) )
      else

        call dscrt_dt ( tan_pt, d_delta_dt(:,sv_i), tau, inc_rad_path, dt_scr_dt(:,sv_i), &
                      & i_start, i_stop, drad_dt(sv_i) )

      end if

    end do ! sv_i

  end subroutine DRad_tran_dt

!--------------------------------------------------  drad_tran_dx  -----
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )

  subroutine DRad_tran_dx ( indices_c, gl_inds, del_zeta, Grids_f,        &
                         &  eta_zxp_f, sps_path, sps_map, do_calc_f,      &
                         &  dbeta_path_c, dbeta_path_f, do_gl, del_s,     &
                         &  ref_cor, ds_dz_gw, inc_rad_path, tan_pt,      &
                         &  i_stop, drad_dx )
    use GLNP, only: NG
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSKinds, only: RP, IP
    use SCRT_DN_M, ONLY: DSCRT_DX
    use Where_M, only: Where

! Inputs

    integer(ip), intent(in) :: indices_c(:)  ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T), intent(in) :: Grids_f    ! All the coordinates
    real(rp), intent(in) :: eta_zxp_f(:,:)   ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function, path X species.
    integer, intent(in) :: sps_map(:)        ! second-dimension subscripts for sps_path.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
      !                                        representation basis function is
      !                                        not zero.
    real(rp), intent(in) :: dbeta_path_c(:,:) ! derivative of beta wrt dx
      !                                        on main grid.
    real(rp), intent(in) :: dbeta_path_f(:,:) ! derivative of beta wrt dx
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
      !                                        do gl integrations
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
      !                                        length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative *
      !              gw on the entire grid.  Only the gl_inds part is used.
    real(rp), intent(in) :: inc_rad_path(:)  ! incremental radiance along the
                                             ! path.  t_script * tau.
    integer, intent(in) :: Tan_pt            ! Tangent point index in inc_rad_path
    integer(ip), intent(in) :: i_stop        ! path stop index

! Outputs

    real(rp), intent(out) :: drad_dx(:)      ! derivative of radiances wrt x
!                                              state vector element. (K)
! Internals

    integer(ip) :: A, AA, GA(ng), I, II, III
    integer(ip) :: i_start, n_inds, no_to_gl, sps_i, sps_m, sps_n, sv_i
    integer(ip), target, dimension(1:Ng*size(inc_rad_path)) :: all_inds_B
    integer(ip), target, dimension(1:size(inc_rad_path)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

    real(rp) :: d_delta_dx(1:size(inc_rad_path))  ! derivative of delta
      !              wrt spectroscopy parameter. (K)

    real(rp) :: singularity(1:size(inc_rad_path)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

    logical :: do_calc(1:size(inc_rad_path))      ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).

! Begin code

    sps_n = ubound(grids_f%l_z,1)

    do sps_i = 1 , sps_n
      sps_m = sps_map(sps_i)

      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)

        d_delta_dx = 0.0_rp

        call get_do_calc_indexed ( do_calc_f(:,sv_i), indices_c, gl_inds, &
          & do_gl, do_calc )

! find where the non zeros are along the path

        n_inds = count(do_calc)
        if ( n_inds > 0 ) then

          inds => inds_B(1:n_inds)

          call where ( do_calc, inds )

          do i = 1, n_inds ! Don't trust the compiler to fuse loops
            ii = inds(i)
            iii = indices_c(ii)
            singularity(ii) = dbeta_path_c(ii,sps_i) &
                            &  * eta_zxp_f(iii,sv_i) * sps_path(iii,sps_m)
            d_delta_dx(ii) = singularity(ii) * del_s(ii)
          end do ! i

          no_to_gl = count(do_gl(inds))
          if ( no_to_gl > 0 ) then

! see if anything needs to be gl-d

            all_inds => all_inds_B(1:Ng*no_to_gl)
            more_inds => more_inds_B(1:no_to_gl)

            call get_inds ( do_gl, do_calc, more_inds, all_inds )

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_dx}.
      !  In the second integral, $G(\zeta)$ is {\tt dbeta\_path\_f *
      !  eta\_zxp\_f\_f * sps\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              ii = more_inds(i)
              aa = all_inds(a)
              ga = gl_inds(aa:aa+ng-1)
              d_delta_dx(ii) = d_delta_dx(ii) + &
                & del_zeta(ii) * &
                & sum( (dbeta_path_f(aa:aa+ng-1,sps_i) &
                     &   * eta_zxp_f(ga,sv_i) * sps_path(ga,sps_m) - &
                     &  singularity(ii)) * ds_dz_gw(ga) )
              a = a + ng
            end do

          end if

          ! Refraction correction
          d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)

          i_start = min(inds(1),i_stop)

          call dscrt_dx ( tan_pt, d_delta_dx, inc_rad_path, i_start, i_stop, &
                       &  drad_dx(sv_i) )

        else
          drad_dx(sv_i) = 0.0
        end if

      end do

    end do

  end subroutine DRad_tran_dx

  ! ------------------------------------------------  Get_Do_Calc  -----
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_f, Do_GL, Do_Calc )

  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do-Calc_f
  ! flags are set.

    use GLNP, ONLY: Ng

    logical, intent(in) :: Do_Calc_c(:) ! On the coarse grid
    logical, intent(in) :: Do_Calc_f(:) ! On the GL grid
    logical, intent(in) :: Do_GL(:)     ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)  ! Where on coarse grid to do calc.

    integer :: I, P_I

    i = 1
    do_calc = do_calc_c
    do p_i = 1 , size(do_gl)
      if ( do_gl(p_i) ) then
        if ( any(do_calc_f(i:i+ng-1)) ) do_calc(p_i)=.true.
        i = i + Ng
      end if
    end do

  end subroutine Get_Do_Calc

! =====     Private Procedures     =====================================

  ! ----------------------------------------  Get_Do_Calc_Indexed  -----
  subroutine Get_Do_Calc_Indexed ( Do_Calc_all, C_Inds, F_Inds, Do_GL, Do_Calc )

  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do-Calc_f
  ! flags are set.

    use GLNP, ONLY: Ng
    use MLSKinds, only: IP

    logical, intent(in) :: Do_Calc_all(:) ! On the entire path
    integer(ip), intent(in) :: C_Inds(:)  ! Indices in Do_Calc_All for coarse grid
    integer(ip), intent(in) :: F_Inds(:)  ! Indices in Do_Calc_All for find grid
    logical, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.

    integer :: I, P_I

    i = 1
!     do_calc = do_calc_all(c_inds)
    forall ( i = 1: size(do_calc) ) do_calc(i) = do_calc_all(c_inds(i))
    do p_i = 1 , size(do_gl)
      if ( do_gl(p_i) ) then
        if ( any(do_calc_all(f_inds(i:i+ng-1))) ) do_calc(p_i)=.true.
        i = i + Ng
      end if
    end do

  end subroutine Get_Do_Calc_Indexed

  ! ---------------------------------------------------  Get_Inds  -----
  subroutine Get_Inds ( Do_GL, Do_Calc, More_Inds, All_Inds )

    ! More_Inds are the places in the coarse path where both Do_Calc and Do_GL.
    ! All_Inds are the corresponding places in the GL-extracted fine path.

    use GLNP, ONLY: Ng
    use MLSKinds, only: IP

    implicit NONE

  ! Inputs
    logical, intent(in) :: Do_GL(:)          ! path flag indicating where to do
      !                                        gl integrations.
    logical, intent(in) :: Do_Calc(:)

  ! Outputs
    integer(ip), intent(out) :: More_Inds(:)
    integer(ip), intent(out) :: All_Inds(:)

    integer :: I, J, K, L, P_I

    i = 1
    j = 1
    l = 1
    do p_i = 2 , size(do_gl)-1
      if ( do_gl(p_i) ) then
        if ( do_calc(p_i) ) then
          more_inds(i) = p_i
! !         all_inds(j:j+ng-1) = (/ ( (p_i-2)*ng+k, k = 1, ng ) /)
!           all_inds(j:j+ng-1) = (/ ( l + k, k = 0, ng-1 ) /)
!           forall( k = 0: ng - 1 ) all_inds(j+k) = l + k
          ! OK, here be dragons.
          ! Van originally had this line:
          !         all_inds(j:j+ng-1) = (/ ( (p_i-2)*ng+k, k = 1, ng ) /)
          ! Then he replaced it with this one
          !         all_inds(j:j+ng-1) = (/ ( l + k, k = 0, ng-1 ) /)
          ! It turns out, through a bizarre and worrying series of discoveries about Lahey
          ! that that was really slow under some repeatable, but totally unjustifiable circumstances.
          ! hence the regular do loop below - NJL / WVS
          do k = 0, ng - 1
            all_inds(j+k) = l+k
          end do
          i = i + 1
          j = j + Ng
        end if
        l = l + Ng
      end if
    end do

  end subroutine Get_Inds

!----------------------------------------------------------------------
  logical function not_used_here()
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id: rad_tran_m.f90,v 2.52 2006/12/13 02:32:03 vsnyder Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
    not_used_here = (id(1:1) == ModuleName(1:1))
  end function not_used_here

end module RAD_TRAN_M

! $Log: rad_tran_m.f90,v $
! Revision 2.52  2006/12/13 02:32:03  vsnyder
! Drag the tangent point around instead of assuming it's the middle one
!
! Revision 2.51  2006/07/20 01:09:27  vsnyder
! Make sure drad_df gets a value
!
! Revision 2.50  2006/04/11 18:31:58  vsnyder
! Cannonball polishing
!
! Revision 2.49  2006/02/08 01:02:01  vsnyder
! More stuff for spectroscopy derivatives
!
! Revision 2.48  2005/11/21 22:57:27  vsnyder
! PFA derivatives stuff
!
! Revision 2.47  2005/11/01 23:02:21  vsnyder
! PFA Derivatives
!
! Revision 2.46  2005/09/17 00:49:54  vsnyder
! Revise arrays for spectroscopic derivatives, plus some cannonball polishing
!
! Revision 2.45  2005/06/22 18:08:19  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.44  2005/04/26 15:35:54  livesey
! Minor changes necessitated by wierdo problems with LF95.  Probably won't
! fix the problem but might as well keep them.
!
! Revision 2.43  2005/03/28 20:24:37  vsnyder
! Taus past the black-out are zero, not one!
!
! Revision 2.42  2005/03/03 02:07:42  vsnyder
! Remove USEs for unreferenced symbols
!
! Revision 2.41  2004/11/01 20:25:44  vsnyder
! Reorganization of representation for molecules and beta groups; PFA may be broken for now
!
! Revision 2.40  2004/10/06 21:18:24  vsnyder
! Add rad_tran_PFA
!
! Revision 2.39  2004/08/03 22:06:46  vsnyder
! Inching further toward PFA
!
! Revision 2.38  2004/04/17 00:37:00  vsnyder
! Analytic temperature derivatives
!
! Revision 2.37  2004/03/20 01:15:39  jonathan
!  remove rad_tran_cld
!
! Revision 2.36  2004/03/08 22:58:03  vsnyder
! Remove D_Delta_DT, which was schlepped from drad_tran_dt to
! Get_D_Delta_Pol_DT, but is no longer needed in the latter place.
!
! Revision 2.35  2004/02/03 02:47:55  vsnyder
! Progress (hopefully) on polarized temperature derivatives
!
! Revision 2.34  2004/01/23 01:16:05  vsnyder
! Repair mistakes in polarized radiance calculation:  CS_EXPMAT needs to be
! applied to incoptdepth_pol even if no GL is done, because the earlier
! calculation (in FullForwardModel) didn't have ref_cor.  We can't stop
! doing CS_EXPMAT when the sum of the eigenvalues gets large and negative,
! because the terms in the matrix are large if the difference of the
! eigenvalues is large.  If we had both eigenvalues, we'd be nearly done
! with CS_EXPMAT, so avoiding it would be as expensive as doing it.
!
! Revision 2.33  2003/12/08 17:52:47  jonathan
! update for 2d cldfwm
!
! Revision 2.32  2003/12/03 00:25:32  vsnyder
! Corrections to hydrostatic calculation
!
! Revision 2.31  2003/11/04 02:49:50  vsnyder
! Use GC_INDS calculated in FullForwardModel for more_inds
!
! Revision 2.30  2003/11/04 01:55:50  vsnyder
! Add 'FA = 0.0' in case n_path <= 4, cosmetic changes
!
! Revision 2.29  2003/11/01 03:04:02  vsnyder
! Use ds_dz_gw instead of ds_dh, dh_dz and gw; use del_zeta from FullForwardModel
!
! Revision 2.28  2003/10/30 20:36:41  vsnyder
! Get del_zeta from FullForwardModel
!
! Revision 2.27  2003/10/16 23:06:09  vsnyder
! Polish up some comments
!
! Revision 2.26  2003/10/15 02:04:08  vsnyder
! Simplifications possible after inlining path_opacity.  Cosmetic changes.
! Make Get_Del_Zeta_All public.  Don't bother checking do_calc(1) and
! do_calc(n_path) because we know it's false there.
!
! Revision 2.25  2003/10/09 21:04:38  vsnyder
! Fix typos generated while inlining path_opacity
!
! Revision 2.23  2003/09/25 20:06:03  vsnyder
! Insert TeXnicalities.  Insert many more comments too.  Inline path_opacity,
! which results in substantial savings in derivative calculations because it
! avoids constructing an array temp within a doubly-nested loop.  It doesn't
! make much differences for radiance calculations.
!
! Revision 2.22  2003/09/24 22:19:55  vsnyder
! Get rid of some array temps
!
! Revision 2.21  2003/09/09 22:34:45  vsnyder
! Don't look at status from cs_expmat if it isn't called
!
! Revision 2.20  2003/09/09 00:02:55  vsnyder
! Make deltau_pol inout, only compute it where needed
!
! Revision 2.19  2003/08/15 18:50:22  vsnyder
! Preparing the way for polarized vmr derivatives
!
! Revision 2.18  2003/06/27 22:05:48  vsnyder
! Check status from cs_expmat
!
! Revision 2.17  2003/06/18 17:24:05  bill
! added temperature derivative subsetting
!
! Revision 2.16  2003/06/09 20:52:37  vsnyder
! More work on polarized derivatives
!
! Revision 2.15  2003/05/20 00:04:28  vsnyder
! Collect common stuff into subroutines
!
! Revision 2.14  2003/05/15 03:29:00  vsnyder
! Moved some stuff up to FullForwardModel because Get_d_Deltau_pol_dT needs it
!
! Revision 2.13  2003/05/05 23:00:26  livesey
! Merged in feb03 newfwm branch
!
! Revision 2.12.2.2  2003/03/20 01:42:26  vsnyder
! Revise Grids_T structure
!
! Revision 2.12.2.1  2003/03/05 03:31:13  vsnyder
! Get rid of unused variables, use 'any' instead of 'count'
!
! Revision 2.12  2003/02/07 02:35:48  vsnyder
! OOPS, forgot to move one down
!
! Revision 2.11  2003/02/07 02:12:00  vsnyder
! Move some USE statements down
!
! Revision 2.10  2003/02/03 19:00:52  bill
! changed interface to rad tran to speed up program
!
! Revision 2.9  2003/01/08 00:15:42  vsnyder
! Moved path_contrib to its own module
!
! Revision 2.8  2002/10/08 17:08:06  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 2.7  2002/10/02 20:09:48  vsnyder
! Use automatic arrays to move allocate/deallocate out of loops.  Numerous
! cosmetic changes.
!
! Revision 2.6  2002/07/05 07:52:52  zvi
! Some cosmetic changes
!
! Revision 2.5  2002/06/13 22:38:40  bill
! some variable name changes--wgr
!
! Revision 2.4  2002/06/04 10:28:04  zvi
! rename n_sps to: no_mol, more correctly
!
! Revision 2.3  2002/02/16 06:38:05  zvi
! Some cosmetic changes..
!
! Revision 2.2  2002/01/30 01:11:22  zvi
! Fix bug in user selectable coeff. code
!
! Revision 2.1  2002/01/27 08:37:51  zvi
! Adding Users selected coefficients for derivatives
!
! Revision 2.0  2001/09/17 20:26:27  livesey
! New forward model
!
! Revision 1.11.2.3  2001/09/13 22:51:24  zvi
! Separating allocation stmts
!
! Revision 1.11.2.2  2001/09/11 00:00:46  zvi
! Adding dt_script code
!
! Revision 1.11.2.1  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
! Revision 1.1  2000/05/04 18:12:05  vsnyder
! Initial conversion to Fortran 90
@


2.52
log
@Drag the tangent point around instead of assuming it's the middle one
@
text
@d1031 1
a1031 1
       "$Id: rad_tran_m.f90,v 2.51 2006/07/20 01:09:27 vsnyder Exp $"
d1040 3
@


2.51
log
@Make sure drad_df gets a value
@
text
@d32 1
a32 1
  subroutine Rad_tran ( gl_inds, more_inds, e_rflty, del_zeta, &
d43 1
d111 2
a112 1
    call scrt ( t_script, e_rflty, incoptdepth, tau, rad, inc_rad_path, i_stop )
d118 3
a120 3
  subroutine Rad_tran_Pol ( gl_inds, more_inds, e_rflty, del_zeta, alpha_path_c, &
                     &  ref_cor, incoptdepth_pol, deltau_pol, alpha_path_gl, &
                     &  ds_dz_gw, ct, stcp, stsp, t_script, &
d134 1
d203 2
a204 2
    ! At this point, incoptdepth_pol(:,:,1:npc/2) should be nearly
    ! identical to incoptdepth_pol(:,:,1:npc/2+1) (npc/2 is the
d223 1
a223 1
      & p_stop, prod_pol, tau_pol, rad_pol )
d235 1
a235 1
  subroutine DRad_tran_df ( indices_c, gl_inds, del_zeta, Grids_f, &
d237 2
a238 2
                         &  beta_path_f, do_gl, del_s, ref_cor,    &
                         &  ds_dz_gw, inc_rad_path, i_stop,        &
d273 1
d431 2
a432 2
          call dscrt_dx ( d_delta_df(:,sv_i), inc_rad_path, &
                           &  i_start, i_stop, drad_df(sv_i))
d455 2
a456 2
                         &  tau, inc_rad_path, i_stop, deriv_flags, pfa_update, &
                         &  drad_dt )
d512 1
d525 1
a525 1
    integer(ip) :: i, j, i_start, mid, n_inds, n_path, no_to_gl, p_i, sv_i
a551 1
    mid = n_path / 2
d629 2
a630 2
      do_calc(2:mid) =          do_calc(mid)   .or. do_calc(2:mid)          .or. do_calc(1:mid-1)
      do_calc(mid+1:n_path-1) = do_calc(mid+1) .or. do_calc(mid+1:n_path-1) .or. do_calc(mid+2:n_path)
d645 2
a646 2
        s_del_s = sum(del_s(2:mid))
        do p_i = 2 , mid - 1
d668 3
a670 3
        if ( do_calc(mid) ) then
          d_delta_dt(mid,sv_i) = d_delta_dt(mid,sv_i) + alpha_path_c(mid) * fa
          inds(i) = mid
d674 4
a677 4
        needFA = .not. do_calc(mid+1)
        s_del_s = del_s(mid+1)
        if ( do_calc(mid+1) ) then
          fa = (h_path_c(mid+2) * dh_dt_path_c(mid+2,sv_i) - &
d679 3
a681 3
          d_delta_dt(mid+1,sv_i) = d_delta_dt(mid+1,sv_i) + &
            &                      alpha_path_c(mid+1) * fa
          inds(i) = mid + 1
d687 1
a687 1
        do p_i = mid + 2, n_path - 1
d742 2
a743 2
        call dscrt_dx ( d_delta_dt(:,sv_i), inc_rad_path, i_start, i_stop, &
                         &  drad_dt(sv_i) )
d746 2
a747 2
        call dscrt_dt ( d_delta_dt(:,sv_i), tau, inc_rad_path, dt_scr_dt(:,sv_i), &
                          & i_start, i_stop, drad_dt(sv_i) )
d762 2
a763 1
                         &  ref_cor, ds_dz_gw, inc_rad_path, i_stop, drad_dx )
d796 1
d905 1
a905 1
          call dscrt_dx ( d_delta_dx, inc_rad_path, i_start, i_stop, &
d1031 1
a1031 1
       "$Id: rad_tran_m.f90,v 2.50 2006/04/11 18:31:58 vsnyder Exp $"
d1040 3
@


2.50
log
@Cannonball polishing
@
text
@d311 4
a314 1
        if ( .not. Grids_f%deriv_flags(sv_i) ) cycle
d1025 1
a1025 1
       "$Id: rad_tran_m.f90,v 2.49 2006/02/08 01:02:01 vsnyder Exp $"
d1034 3
@


2.49
log
@More stuff for spectroscopy derivatives
@
text
@d383 4
a386 3
              singularity(inds(i)) = beta_path_c(inds(i),sps_i) &
                        & * eta_zxp_f(indices_c(inds(i)),sv_i)
              d_delta_df(inds(i),sv_i) = singularity(inds(i)) * del_s(inds(i))
d1022 1
a1022 1
       "$Id: rad_tran_m.f90,v 2.48 2005/11/21 22:57:27 vsnyder Exp $"
d1031 3
@


2.48
log
@PFA derivatives stuff
@
text
@d752 3
a754 4
                         &  eta_zxp_f, sps_path, do_calc_f, dbeta_path_c, &
                         &  dbeta_path_f, do_gl, del_s, ref_cor,          &
                         &  ds_dz_gw, inc_rad_path, i_stop, drad_dx )
use dump_0, only: Dump
d770 2
a771 1
    real(rp), intent(in) :: sps_path(:,:)    ! Path species function.
d796 1
a796 1
    integer(ip) :: i_start, n_inds, sps_n, no_to_gl, sps_i, sv_i
a821 3
call dump ( dbeta_path_c, name='dbeta_path_c' )
print *, 'sps_n =', sps_n

d823 1
a832 1
do_calc=.true.
d845 1
a845 1
                            &  * eta_zxp_f(iii,sv_i) * sps_path(iii,sps_i)
a847 4
call dump ( dbeta_path_c(:,sps_i), name='dbeta_path_c(:,sps_i)' )
call dump ( eta_zxp_f(indices_c,sv_i), name='eta_zxp_f(indices_c,sv_i)' )
call dump ( sps_path(indices_c,sps_i), name='sps_path(indices_c,sps_i)' )
call dump ( d_delta_dx, name='d_delta_dx' )
a849 1
no_to_gl=0
d883 1
a883 1
                     &   * eta_zxp_f(ga,sv_i) * sps_path(ga,sps_i) - &
d905 1
a905 1
stop
d1021 1
a1021 1
       "$Id: rad_tran_m.f90,v 2.47 2005/11/01 23:02:21 vsnyder Exp $"
d1030 3
@


2.47
log
@PFA Derivatives
@
text
@d276 1
a276 1
    real(rp), intent(inout) :: drad_df(:)    ! derivative of radiances wrt
d426 2
d510 1
a510 1
    real(rp), intent(inout) :: drad_dt(:)   ! derivative of radiances wrt
d550 1
d791 1
a791 1
    real(rp), intent(inout) :: drad_dx(:)    ! derivative of radiances wrt x
d906 2
d1029 1
a1029 1
       "$Id: rad_tran_m.f90,v 2.46 2005/09/17 00:49:54 vsnyder Exp $"
d1038 3
@


2.46
log
@Revise arrays for spectroscopic derivatives, plus some cannonball polishing
@
text
@d16 1
a16 1
  public :: RAD_TRAN, RAD_TRAN_PFA, RAD_TRAN_POL
d35 1
a35 1
                     &  tau, rad, i_stop )
d38 2
a39 2
    use MLSCommon, only: RP, IP
    use SCRT_DN_M, ONLY: SCRT_DN
d65 2
d101 2
a102 2
          & sum( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))) * &            
               & ds_dz_gw(aa:aa+ng-1) ) 
d110 1
a110 1
    call scrt_dn ( t_script, e_rflty, incoptdepth, tau, rad, i_stop )
a113 34
!--------------------------------------------------  Rad_Tran_PFA  -----

  ! Combine the Tau's for PFA and non-PFA models.

  subroutine Rad_Tran_PFA ( Channel, Tau_LBL, Tau_PFA, T_Script_PFA, RadV )

    use MLSCommon, only: RP
    use Tau_M, only: Tau_T

    integer, intent(in) :: Channel              ! Which channel in Tau_PFA?
                                                ! Index in channels stru, not chan#
    type(tau_t), intent(in) :: Tau_LBL, Tau_PFA ! Tau structures
    real(rp), intent(in) :: T_Script_PFA(:,:)   ! Delta B, Path X Channels
    real(rp), intent(out) :: RadV(:)            ! Radiances at frequencies
                                                ! within the channel

    integer :: FRQ_I                            ! Frequency index
    integer :: N_Tau_PFA                        ! Tau_PFA%i_stop(channel)
    integer :: PATH_I                           ! Path index

    n_tau_PFA = tau_PFA%i_stop(channel)

    do frq_i = 1, size(radV)
      radV(frq_i) = 0.0
      do path_i = 1, min(tau_LBL%i_stop(frq_i), n_tau_PFA)
        radV(frq_i) = radV(frq_i) + &
          & t_script_pfa(path_i,channel) * tau_lbl%tau(path_i,frq_i) * &
          &                                tau_pfa%tau(path_i,channel)
      end do ! path_i
      ! Tau's after i_stop are 0.0.
    end do ! frq_i

  end subroutine Rad_Tran_PFA

d127 1
a127 1
    use MLSCommon, only: RP, IP
d228 1
d235 1
a235 1
                         &  ds_dz_gw, t_script, tau, i_stop,       &
d240 2
a241 2
    use MLSCommon, only: RP, IP
    use SCRT_DN_M, ONLY: GET_DSCRT_NO_T_DN
d257 2
a258 1
      !              representation basis function is not zero.
d260 1
a260 1
      !              on gl grid.
d262 1
a262 1
      !              do gl integrations
d264 1
a264 1
      !              length ratios.
d268 2
a269 2
    real(rp), intent(in) :: t_script(:)      ! differential temperatures (K).
    real(rp), intent(in) :: tau(:)           ! transmission function.
d276 1
a276 1
    real(rp), intent(out) :: drad_df(:)      ! derivative of radiances wrt
d280 1
a280 1
    integer(ip) :: a, aa, ga(ng), i, ii, iii
d282 2
a283 2
    integer(ip), target, dimension(1:Ng*size(tau)) :: all_inds_B
    integer(ip), target, dimension(1:size(tau)) :: inds_B, more_inds_B
d293 1
a293 1
    real(rp) :: singularity(1:size(tau)) ! integrand on left edge of coarse
d295 1
a295 1
    logical :: do_calc(1:size(tau))      ! Flags on coarse path where do_calc_c
a300 2
    drad_df(:) = 0.0_rp

d307 2
a312 2
        d_delta_df(:,sv_i) = 0.0_rp

d343 1
a343 2
                        & * eta_zxp_f(iii,sv_i) &
                        & * sps_path(iii,sps_i)
d375 2
d415 2
d423 2
a424 2
          call get_dscrt_no_t_dn ( d_delta_df(:,sv_i), t_script, tau, &
                                &  i_start, i_stop, drad_df(sv_i))
d428 1
a428 1
      end do
d430 1
a430 1
    end do
a433 160
!--------------------------------------------------  drad_tran_dx  -----
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )

  subroutine DRad_tran_dx ( indices_c, gl_inds, del_zeta, Grids_f,        &
                         &  sps_path, eta_zxp_f, do_calc_f, dbeta_path_c, &
                         &  dbeta_path_f, do_gl, del_s, ref_cor,          &
                         &  ds_dz_gw, t_script, tau, i_stop, drad_dx )

    use GLNP, only: NG
    use LOAD_SPS_DATA_M, ONLY: GRIDS_T
    use MLSCommon, only: RP, IP
    use SCRT_DN_M, ONLY: GET_DSCRT_NO_T_DN
    use Where_M, only: Where

! Inputs

    integer(ip), intent(in) :: indices_c(:)  ! coarse grid indicies
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    type (Grids_T) :: Grids_f                ! All the coordinates
    real(rp), intent(in) :: sps_path(:,:)    ! species function
    real(rp), intent(in) :: eta_zxp_f(:,:)   ! representation basis function.
    logical, intent(in) :: do_calc_f(:,:)    ! A logical indicating where the
!                                              representation basis function is
!                                              not zero.
    real(rp), intent(in) :: dbeta_path_c(:,:) ! derivative of beta wrt dx
!                                              on main grid.
    real(rp), intent(in) :: dbeta_path_f(:,:) ! derivative of beta wrt dx
    logical, intent(in) :: do_gl(:)          ! A logical indicating where to
!                                              do rec_tan_inds gl integrations
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
!                                              length ratios.
    real(rp), intent(in) :: del_s(:)         ! unrefracted path length.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw
!                                              on entire grid.
    real(rp), intent(in) :: t_script(:)      ! differential temperatures (K).
    real(rp), intent(in) :: tau(:)           ! transmission function.
    integer(ip), intent(in) :: i_stop        ! path stop index

! Outputs

    real(rp), intent(out) :: drad_dx(:)      ! derivative of radiances wrt x
!                                              state vector element. (K)
! Internals

    integer(ip) :: A, AA, GA(ng), I, II, III
    integer(ip) :: i_start, n_inds, no_mol, no_to_gl, sps_i, sv_i, sv_j
    integer(ip), target, dimension(1:Ng*size(tau)) :: all_inds_B
    integer(ip), target, dimension(1:size(tau)) :: inds_B, more_inds_B
    integer(ip), pointer :: all_inds(:)  ! all_inds => part of all_inds_B;
                                         ! Indices on GL grid for stuff
                                         ! used to make GL corrections
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B;  Indices
                                         ! on coarse path where do_calc.
    integer(ip), pointer :: more_inds(:) ! more_inds => part of more_inds_B;
                                         ! Indices on the coarse path where GL
                                         ! corrections get applied.

    real(rp) :: d_delta_dx(1:size(tau))
    real(rp) :: singularity(1:size(tau)) ! integrand on left edge of coarse
                                         ! grid panel -- singular at tangent pt.

    logical :: do_calc(1:size(tau))      ! Flags on coarse path where do_calc_c
                                         ! or (do_gl and any corresponding
                                         ! do_calc_f).

! Begin code

    no_mol = ubound(grids_f%l_z,1)

    sv_i = 0
    drad_dx(:) = 0.0_rp

    do sps_i = 1 , no_mol

      do sv_j = 1 , (Grids_f%l_z(sps_i) - Grids_f%l_z(sps_i-1)) * &
        &           (Grids_f%l_p(sps_i) - Grids_f%l_p(sps_i-1))

        sv_i = sv_i + 1
        d_delta_dx = 0.0_rp

        call get_do_calc ( do_calc_f(indices_c,sv_i), do_calc_f(gl_inds,sv_i), &
          & do_gl, do_calc )

! find where the non zeros are along the path

        n_inds = count(do_calc)
        if ( n_inds > 0 ) then

          inds => inds_B(1:n_inds)

          call where ( do_calc, inds )

          do i = 1, n_inds ! Don't trust the compiler to fuse loops
            ii = inds(i)
            iii = indices_c(ii)
            singularity(ii) = dbeta_path_c(ii,sps_i) * eta_zxp_f(iii,sv_i) &
                            &  * sps_path(iii,sps_i)
            d_delta_dx(ii) = singularity(ii) * del_s(ii)
          end do ! i

          no_to_gl = count(do_gl(inds))
          if ( no_to_gl > 0 ) then

! see if anything needs to be gl-d

            all_inds => all_inds_B(1:Ng*no_to_gl)
            more_inds => more_inds_B(1:no_to_gl)

            call get_inds ( do_gl, do_calc, more_inds, all_inds )

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$.  Here, it is {\tt d\_delta\_dx}.
      !  In the second integral, $G(\zeta)$ is {\tt dbeta\_path\_f *
      !  eta\_zxp\_f\_f * sps\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              ii = more_inds(i)
              aa = all_inds(a)
              ga = gl_inds(aa:aa+ng-1)
              d_delta_dx(ii) = d_delta_dx(ii) + &
                & del_zeta(ii) * &
                & sum( (dbeta_path_f(aa:aa+ng-1,sps_i) &
                     &   * eta_zxp_f(ga,sv_i) * sps_path(ga,sps_i) - &
                     &  singularity(ii)) * ds_dz_gw(ga) )
              a = a + ng
            end do

          end if

          d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)

          i_start = min(inds(1),i_stop)

          call get_dscrt_no_t_dn ( d_delta_dx, t_script, tau, i_start, i_stop, &
                                &  drad_dx(sv_i) )

        end if

      end do

    end do

  end subroutine DRad_tran_dx

d438 1
a438 2
                         &  alpha_path_c, &
                         &  dAlpha_dT_path_c, &
d442 1
a442 2
                         &  alpha_path_f, &
                         &  dAlpha_dT_path_f, &
d444 3
a446 2
                         &  ds_dh, dh_dz_gw, ds_dz_gw, t_script, dt_scr_dt, &
                         &  tau, i_stop, deriv_flags, drad_dt )
d449 2
a450 2
    use MLSCommon, only: RP, IP
    use SCRT_DN_M, ONLY: GET_DSCRT_DN
a497 1
    real(rp), intent(in) :: t_script(:)     ! differential temperatures (K).
d500 2
d505 1
d507 3
a509 3
! Outputs
    real(rp), intent(out) :: drad_dt(:)     ! derivative of radiances wrt
!                                             mixing ratio state vector
d515 2
a516 2
    integer(ip), target, dimension(1:Ng*size(tau)) :: all_inds_B
    integer(ip), target, dimension(1:size(tau)) :: inds_B, more_inds_B
d526 3
a528 2
    real(rp) :: d_delta_dt(size(eta_zxp_c,1),size(eta_zxp_c,2)) ! incremental
                                         ! opacity derivatives
a545 1
    drad_dt(:) = 0.0_rp
d610 1
a610 1
        end if
d612 1
a612 1
      end if
d719 1
a719 1
      end if
d721 1
a721 1
! correct the whole thing for path length refraction
d723 1
a723 1
      d_delta_dt(:,sv_i) = ref_cor * d_delta_dt(:,sv_i)
d727 12
a738 2
      call get_dscrt_dn ( d_delta_dt(:,sv_i), t_script, tau, dt_scr_dt(:,sv_i), i_start, &
                       &  i_stop, drad_dt(sv_i) )
d744 167
d946 1
a946 1
    use MLSCommon, only: IP
d975 1
a975 1
    use MLSCommon, only: IP
d1024 1
a1024 1
       "$Id: rad_tran_m.f90,v 2.45 2005/06/22 18:08:19 pwagner Exp $"
d1033 3
@


2.45
log
@Reworded Copyright statement, moved rcs id
@
text
@d23 1
a23 1
       "$RCSfile: $"
d265 2
a266 2
                         &  beta_path_f, do_gl, del_s, ref_cor, &
                         &  ds_dz_gw, t_script, tau, i_stop,    &
d310 1
a311 1
    integer(ip) :: a, aa, i
d372 6
a377 4
              singularity(inds(i)) = beta_path_c(inds(i),sps_i) &
                        & * eta_zxp_f(indices_c(inds(i)),sv_i) &
                        & * sps_path(indices_c(inds(i)),sps_i)
              d_delta_df(inds(i),sv_i) = singularity(inds(i)) * del_s(inds(i))
d399 7
a405 7
              d_delta_df(more_inds(i),sv_i) = d_delta_df(more_inds(i),sv_i) + &
                & del_zeta(more_inds(i)) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) * &
                     &  eta_zxp_f(gl_inds(aa:aa+ng-1),sv_i) * &
                     &  sps_path(gl_inds(aa:aa+ng-1),sps_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dz_gw(gl_inds(aa:aa+ng-1)) )
d438 6
a443 6
              d_delta_df(more_inds(i),sv_i) = d_delta_df(more_inds(i),sv_i) + &
                & del_zeta(more_inds(i)) * &
                & sum( (beta_path_f(aa:aa+ng-1,sps_i) * &
                     &  eta_zxp_f(gl_inds(aa:aa+ng-1),sv_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dz_gw(gl_inds(aa:aa+ng-1)) )
d467 4
a470 4
  subroutine DRad_tran_dx ( del_zeta, Grids_f, dbeta_path_c, eta_zxp_f_c, &
                         &  sps_path_c, do_calc_f_c, dbeta_path_f, eta_zxp_f_f, &
                         &  sps_path_f, do_calc_f_f, do_gl, gl_inds, del_s, &
                         &  ref_cor, ds_dz_gw, t_script, tau, i_stop, drad_dx )
d480 3
a482 1
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
d486 5
a492 6
    real(rp), intent(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                              main grid.
    real(rp), intent(in) :: sps_path_c(:,:)  ! species function on  main grid.
    logical, intent(in) :: do_calc_f_c(:,:)  ! A logical indicating where the
!                                              representation basis function is
!                                              not zero on main grid.
a493 7
!                                              on gl grid.
    real(rp), intent(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                              gl grid.
    real(rp), intent(in) :: sps_path_f(:,:)  ! species function on gl grid.
    logical, intent(in) :: do_calc_f_f(:,:)  ! A logical indicating where the
!                                              representation basis function is
!                                              not zero on main grid.
a495 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d511 1
a511 1
    integer(ip) :: A, AA, I
d547 2
a548 2
        call get_do_calc ( do_calc_f_c(:,sv_i), do_calc_f_f(:,sv_i), do_gl, &
          & do_calc )
d560 5
a564 3
            singularity(inds(i)) = dbeta_path_c(inds(i),sps_i) * eta_zxp_f_c(inds(i),sv_i)  &
                       &  * sps_path_c(inds(i),sps_i)
            d_delta_dx(inds(i)) = singularity(inds(i)) * del_s(inds(i))
d595 1
d597 6
a602 7
              d_delta_dx(more_inds(i)) = d_delta_dx(more_inds(i)) + &
                & del_zeta(more_inds(i)) * &
                & sum( (dbeta_path_f(aa:aa+ng-1,sps_i) * &
                     &  eta_zxp_f_f(aa:aa+ng-1,sv_i) * &
                     &  sps_path_f(aa:aa+ng-1,sps_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dz_gw(gl_inds(aa:aa+ng-1)) )
d968 2
a969 1
    do_calc = do_calc_all(c_inds)
d1008 3
d1035 1
a1035 1
       "$Id: $"
d1044 3
@


2.44
log
@Minor changes necessitated by wierdo problems with LF95.  Probably won't
fix the problem but might as well keep them.
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d21 3
a23 5
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
    & "$Id: rad_tran_m.f90,v 2.43 2005/03/28 20:24:37 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = "$RCSfile: rad_tran_m.f90,v $"
d1032 5
d1043 4
@


2.43
log
@Taus past the black-out are zero, not one!
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.42 2005/03/03 02:07:42 vsnyder Exp $"
d1004 11
a1014 2
!         all_inds(j:j+ng-1) = (/ ( (p_i-2)*ng+k, k = 1, ng ) /)
          all_inds(j:j+ng-1) = (/ ( l + k, k = 0, ng-1 ) /)
d1032 3
@


2.42
log
@Remove USEs for unreferenced symbols
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.41 2004/11/01 20:25:44 vsnyder Exp $"
d108 1
a108 1
  ! Combine the tau's for PFA and non-PFA models.
d110 1
a110 3
  subroutine Rad_Tran_PFA ( KLo, KHi, Channel, &
    & Tau_LBL, Tau_PFA, T_Script_LBL, T_Script_PFA, &
    & RadV )
a114 1
    integer, intent(in) :: KLo, KHi             ! Frequency indices for Tau_LBL
a117 1
    real(rp), intent(in) :: T_Script_LBL(:,:)   ! Delta B, Path X Frequencies
d123 1
a123 2
    integer :: N_Tau_Min                        ! Min(N_Tau_LBL, N_Tau_PFA)
    integer :: N_Tau_LBL, N_Tau_PFA             ! Tau_*%i_stop(channel)
d128 3
a130 5
    do frq_i = klo, khi
      n_tau_LBL = tau_LBL%i_stop(frq_i)
      n_tau_min = min(n_tau_LBL, n_tau_PFA)
      radV(frq_i) = t_script_lbl(1,frq_i)
      do path_i = 2, n_tau_min
d132 2
a133 11
          & t_script_lbl(path_i,frq_i) * tau_lbl%tau(path_i,frq_i) * &
          &                              tau_pfa%tau(path_i,channel)
      end do ! path_i
      ! Tau's after i_stop are 1.0.  At most one of the next two loops does something.
      do path_i = n_tau_min+1, n_tau_PFA
        radV(frq_i) = radV(frq_i) + &
          & t_script_pfa(path_i,channel) * tau_PFA%tau(path_i,channel)
      end do ! path_i
      do path_i = n_tau_min+1, n_tau_LBL
        radV(frq_i) = radV(frq_i) + &
          & t_script_lbl(path_i,frq_i) * tau_LBL%tau(path_i,frq_i)
d135 1
d1023 3
@


2.41
log
@Reorganization of representation for molecules and beta groups; PFA may be broken for now
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.40 2004/10/06 21:18:24 vsnyder Exp $"
d114 1
a114 2
    use D_Hunt_m, only: Hunt
    use MLSCommon, only: RP, R8
d1038 3
@


2.40
log
@Add rad_tran_PFA
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.39 2004/08/03 22:06:46 vsnyder Exp $"
d276 1
a276 1
                         &  ds_dz_gw, t_script, tau, i_stop, pfa, &
a310 1
    logical, intent(in) :: PFA               ! "Doing PFA molecules"
d320 1
a320 1
    integer(ip) :: i_start, n_inds, no_to_gl, sps_i, sps_1, sps_n, sv_i
d343 1
a343 7
    if ( pfa ) then ! Doing PFA, which come after nonPFA in grids_f
      sps_1 = Grids_f%lastNonPFA + 1
      sps_n = ubound(Grids_f%l_z,1)
    else
      sps_1 = 1
      sps_n = Grids_f%lastNonPFA
    end if
d345 1
a345 1
    do sps_i = sps_1, sps_n
d1039 3
@


2.39
log
@Inching further toward PFA
@
text
@d8 2
a9 1
  public :: RAD_TRAN, RAD_TRAN_POL, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.38 2004/04/17 00:37:00 vsnyder Exp $"
d93 1
a93 1
          & sum( (alpha_path_gl(a:a+ng-1) -  alpha_path_c(more_inds(i))) * &            
d106 50
a642 2
!{\newpage

d1046 3
@


2.38
log
@Analytic temperature derivatives
@
text
@d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.37 2004/03/20 01:15:39 jonathan Exp $"
d225 2
a226 2
                         &  ds_dz_gw, t_script, tau, &
                         &  i_stop, d_delta_df, drad_df )
d260 1
d270 1
a270 1
    integer(ip) :: i_start, n_inds, no_mol, no_to_gl, sps_i, sv_i
d291 1
a291 1
    no_mol = ubound(Grids_f%l_z,1)
d293 7
a299 1
    drad_df(:) = 0.0_rp
d301 1
a301 1
    do sps_i = 1, no_mol
d997 3
@


2.37
log
@ remove rad_tran_cld
@
text
@d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.36 2004/03/08 22:58:03 vsnyder Exp $"
d26 1
a26 1
                     &  alpha_path_c, ref_cor, do_gl, incoptdepth, &
a46 2
    logical, intent(in) :: do_gl(:)          ! path flag indicating where to do
  !                                            gl integrations.
d108 1
a108 1
                     &  ref_cor, do_gl, incoptdepth_pol, deltau_pol, alpha_path_gl, &
a135 2
    logical, intent(in) :: do_gl(:)          ! path flag indicating where to do
      !              gl integrations.
d590 4
a593 2
  subroutine DRad_tran_dt ( del_zeta, h_path_c, t_path_c, dh_dt_path_c, &
                         &  alpha_path_c, alphaxn_path_c, eta_zxp_c, do_calc_t_c, &
d596 3
a598 1
                         &  alpha_path_f, alphaxn_path_f, eta_zxp_f, do_calc_t_f, &
a612 1
    real(rp), intent(in) :: t_path_c(:)     ! path temperature(K) on main grid.
d617 1
a617 2
    real(rp), intent(in) :: alphaxn_path_c(:) ! path absorption * temperature
!                                             exponent (km^-1) on main grid.
d638 1
a638 2
    real(rp), intent(in) :: alphaxn_path_f(:) ! path absorption * temperature
!                                             exponent (km^-1) on gl grid.
d720 1
a720 1
          singularity(j) = alphaxn_path_c(j) * eta_zxp_c(j,sv_i) / t_path_c(j)
d723 1
d757 1
a757 3
              & sum( (alphaxn_path_f(aa:bb) * &
                   &  eta_zxp_f(aa:bb,sv_i) / &
                   &  t_path_f(aa:bb) - &
a761 1

d990 3
@


2.36
log
@Remove D_Delta_DT, which was schlepped from drad_tran_dt to
Get_D_Delta_Pol_DT, but is no longer needed in the latter place.
@
text
@a8 1
  public :: RAD_TRAN_CLD
d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.35 2004/02/03 02:47:55 vsnyder Exp $"
a106 73
!--------------------------------------- Rad_tran_cld  -------------
! This is the radiative transfer model including cloud scattering !

  subroutine Rad_tran_cld ( gl_inds, more_inds, e_rflty, del_zeta, &
                     &  alpha_path_c, ref_cor, do_gl, incoptdepth, &
                     &  alpha_path_gl, ds_dz_gw, t_script, &
                     &  tau, rad, i_stop, tt_path, w0_path )

    use GLNP, only: NG
    use MLSCommon, only: RP, IP
    use CCRT_M, ONLY: CCRT

  ! inputs

    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
    integer(ip), intent(in) :: more_inds(:)  ! Places in the coarse path
  !                                            where GL is needed
    real(rp), intent(in) :: e_rflty          ! earth reflectivity value (0--1).
    real(rp), intent(in) :: del_zeta(:)      ! path -log(P) differences on the
      !              main grid.  This is for the whole coarse path, not just
      !              the part up to the black-out
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient on coarse
  !                                            grid.
    real(rp), intent(in) :: ref_cor(:)       ! refracted to unrefracted path
  !                                            length ratios.
    logical, intent(in) :: do_gl(:)          ! path flag indicating where to do
  !                                            gl integrations.
    real(rp), intent(inout) :: incoptdepth(:) ! incremental path opacities
  !                            from one-sided layer calculation on output.
  !                            it is the full integrated layer opacity.
    real(rp), intent(in) :: alpha_path_gl(:) ! absorption coefficient on gl
  !                                            grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
    real(rp), intent(in) :: t_script(:)      ! differential temperatures (K)
  !                                            on coarse grid.
    real(rp), intent(in) :: tt_path(:)       ! scattering source function
    real(rp), intent(in) :: w0_path(:)       ! single scattering albedo

  ! outputs

    real(rp), intent(out) :: tau(:)          ! transmission function.
    real(rp), intent(out) :: rad             ! radiance (K)
    integer(ip), intent(out) :: i_stop       ! path stop index

  ! Internals

    integer :: A, AA, I
  !                                            where GL is needed

  ! Begin code

  ! see if anything needs to be gl-d

    if ( size(gl_inds) > 0 ) then

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        incoptdepth(more_inds(i)) = incoptdepth(more_inds(i)) + &
          & del_zeta(more_inds(i)) * &
          & sum( (alpha_path_gl(a:a+ng-1) - alpha_path_c(more_inds(i))) * &            
               & ds_dz_gw(aa:aa+ng-1) ) 
        a = a + ng
      end do ! i

    end if

    incoptdepth = ref_cor * incoptdepth

    call ccrt ( t_script, e_rflty, incoptdepth, tau, rad, i_stop, tt_path, w0_path )

  end subroutine Rad_tran_cld

d995 4
@


2.35
log
@Progress (hopefully) on polarized temperature derivatives
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.31 2003/11/04 02:49:50 vsnyder Exp $"
d674 1
a674 1
                         &  tau, i_stop, deriv_flags, d_delta_dt, drad_dt )
a736 4

    real(rp), intent(out) :: d_delta_dt(:,:) ! incremental opacity derivatives,
!                                             in case the polarized model
!                                             needs them.  path x sve.
d755 2
d1069 3
@


2.34
log
@Repair mistakes in polarized radiance calculation:  CS_EXPMAT needs to be
applied to incoptdepth_pol even if no GL is done, because the earlier
calculation (in FullForwardModel) didn't have ref_cor.  We can't stop
doing CS_EXPMAT when the sum of the eigenvalues gets large and negative,
because the terms in the matrix are large if the difference of the
eigenvalues is large.  If we had both eigenvalues, we'd be nearly done
with CS_EXPMAT, so avoiding it would be as expensive as doing it.
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.33 2003/12/08 17:52:47 jonathan Exp $"
d168 1
a168 1
          & sum( (alpha_path_gl(a:a+ng-1) -  alpha_path_c(more_inds(i))) * &            
d258 2
a259 2
      ! Turn sigma-, pi, sigma+ GL corrections  into 2X2 matrix of
      ! GL corrections to to incoptdepth_pol
a675 1
    use DO_DELTA_M, ONLY: HYD_OPACITY
d746 1
a746 1
    integer(ip) :: A, AA
a758 1
    real(rp), target, dimension(1:size(tau)) :: gl_delta_B
a759 1
    real(rp), pointer :: gl_delta(:)     ! gl_delta => part_of_gl_delta_B
d761 1
a761 1
    real(rp) :: singularity(1:size(tau)) ! integrand on left edge of coarse
d764 1
a764 1
    logical :: do_calc(1:size(tau))      ! do_calc_t_c .or. ( do_gl .and. any
d810 1
a810 1
          call Get_Inds ( Do_GL, Do_Calc, More_Inds, All_Inds )
d831 1
d835 3
a837 3
              & sum( (alphaxn_path_f(aa:aa+ng-1) * &
                   &  eta_zxp_f(aa:aa+ng-1,sv_i) / &
                   &  t_path_f(aa:aa+ng-1) - &
d839 1
a839 1
                   & ds_dz_gw(gl_inds(aa:aa+ng-1)) )
d876 2
a877 2
            fb = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
              & - h_tan * dh_dt_tan(sv_i)) / s_del_s
d899 1
a899 1
          fa = (h_path_c(mid+2)*dh_dt_path_c(mid+2,sv_i) - &
d929 20
a948 22
        no_to_gl = count(do_gl(inds))
        if ( no_to_gl > 0 ) then

! see if anything needs to be gl-d

          all_inds => all_inds_B(1:ng*no_to_gl)
          gl_delta => gl_delta_B(1:no_to_gl)
          more_inds => more_inds_B(1:no_to_gl)

          call Get_Inds ( Do_GL, Do_Calc, More_Inds, All_Inds )

! add special hydrostatic gl routine here
! the singularity point is alpha_path_c(more_inds)

          call hyd_opacity ( del_zeta, alpha_path_c,         &                 
             & alpha_path_f, h_path_f,                       &
             & dh_dt_path_f(:,sv_i), t_path_f, h_tan,        &
             & dh_dt_tan(sv_i), eta_zxp_f(:,sv_i), ds_dh,    &
             & dh_dz_gw, gl_inds, more_inds, all_inds(::ng), gl_delta )

          d_delta_dt(more_inds,sv_i) = d_delta_dt(more_inds,sv_i) + gl_delta
        end if
d964 1
d1069 1
d1071 9
@


2.33
log
@update for 2d cldfwm
@
text
@d8 2
a9 1
  public :: RAD_TRAN, RAD_TRAN_POL, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX, rad_tran_cld
d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.32 2003/12/03 00:25:32 vsnyder Exp $"
a268 4
    do p_stop = 1, n_path
      incoptdepth_pol(:,:,p_stop) = incoptdepth_pol(:,:,p_stop) * ref_cor(p_stop)
    end do

d274 2
d277 9
a285 10
      ! s is the sum of A's eigenvalues, and d is their difference.
      ! The sum of A's eigenvalues is Tr(A).  So when the trace
      ! of Real(incoptdepth_pol) < e_stop, we can stop.
!     if ( real(incoptdepth_pol(1,1,p_stop+1)) + &
!       &  real(incoptdepth_pol(2,2,p_stop+1)) <= e_stop ) exit
      if ( do_gl(p_stop+1) ) then
        call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), & ! deltau = exp(incoptdepth_pol)
        &                  deltau_pol(:,:,p_stop+1), status )
        if ( status /= 0 ) go to 99 ! because we can't change p_stop in the loop
      end if
d1073 3
@


2.32
log
@Corrections to hydrostatic calculation
@
text
@d8 1
a8 1
  public :: RAD_TRAN, RAD_TRAN_POL, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.31 2003/11/04 02:49:50 vsnyder Exp $"
d107 73
d1075 3
@


2.31
log
@Use GC_INDS calculated in FullForwardModel for more_inds
@
text
@d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.30 2003/11/04 01:55:50 vsnyder Exp $"
d208 2
a209 2
      if ( real(incoptdepth_pol(1,1,p_stop+1)) + &
        &  real(incoptdepth_pol(2,2,p_stop+1)) <= e_stop ) exit
d677 1
a677 1
    integer(ip) :: i, j, i_start, mid, n_inds, n_path, no_to_gl, p_i, sv_i, sv_t
d702 1
a702 2
    n_path = size(tau)
    sv_t = size(eta_zxp_c,dim=2)
d710 1
a710 1
    do sv_i = 1 , sv_t
a733 1

d763 3
a765 2
            d_delta_dt(more_inds(i),sv_i) = d_delta_dt(more_inds(i),sv_i) + &
              & del_zeta(more_inds(i)) * &
d769 1
a769 1
                   &  singularity(more_inds(i))) * &
d827 1
a827 1
        needFA = .true.
a835 1
          needFA = .false.
a880 1

a896 1

d1002 3
@


2.30
log
@Add 'FA = 0.0' in case n_path <= 4, cosmetic changes
@
text
@d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.28 2003/10/30 20:36:41 vsnyder Exp $"
d25 1
a25 1
  subroutine Rad_tran ( gl_inds, e_rflty, del_zeta, &
a32 1
    use Where_M, only: Where
d37 2
d40 1
a40 1
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
a65 1
    integer(ip) ::  more_inds(size(gl_inds)/ng) ! Places in the coarse path
a73 2
      call where ( do_gl, more_inds )

d109 2
a110 2
  subroutine Rad_tran_Pol ( gl_inds, e_rflty, del_zeta, alpha_path_c, ref_cor, &
                     &  do_gl, incoptdepth_pol, deltau_pol, alpha_path_gl, &
a121 1
    use Where_M, only: Where
d126 2
d129 1
a129 1
    real(rp), intent(in) :: del_zeta(:)     ! path -log(P) differences on the
d166 1
a166 1
    integer(ip) ::  more_inds(size(gl_inds)/ng), N_PATH
a178 2
      call where ( do_gl, more_inds )

d1006 3
@


2.29
log
@Use ds_dz_gw instead of ds_dh, dh_dz and gw; use del_zeta from FullForwardModel
@
text
@d134 1
a134 1
  !                                            on coarse grid.
d136 1
a136 2
  !                                            transmissivity on the coarse path.
  !                                            Called E in some notes.
d138 1
a138 1
  !                                            length ratios.
d140 1
a140 1
  !                                            gl integrations.
d142 2
a143 3
  !                            opacities from one-sided layer calculation on
  !                            output. it is the full integrated layer opacity.
  !                            2x2xPath
d145 3
a147 2
  !                                            gl grid.
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
d152 1
a152 1
  !                                            on coarse path.
d160 1
a160 2
      !                                        -index in incoptdepth_pol where
      !                                        cs_expmat failed.
d247 1
a247 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d253 1
a253 1
!                                              on coarse grid.
d257 1
a257 2
!                                              representation basis function is
!                                              not zero.
d259 1
a259 1
!                                              on gl grid.
d261 1
a261 1
!                                              do gl integrations
d263 1
a263 1
!                                              length ratios.
d265 2
a266 1
    real(rp), intent(in) :: ds_dz_gw(:)      ! path length wrt zeta derivative * gw.
d274 1
a274 2
!                                              wrt mixing ratio state vector
!                                              element. (K)
d276 1
a276 2
!                                              mixing ratio state vector
!                                              element. (K)
d654 2
a655 1
!                                             on complete grid.
d657 2
a658 1
!                                             on complete grid.
d660 2
a661 1
!                                             on complete grid.
d797 1
d1009 3
@


2.28
log
@Get del_zeta from FullForwardModel
@
text
@a5 3
  use MLSCommon, only: RP, IP
  use GLNP, ONLY: Ng

d14 1
a14 1
    & "$Id: rad_tran_m.f90,v 2.27 2003/10/16 23:06:09 vsnyder Exp $"
d27 2
a28 2
                     &  alpha_path_gl, ds_dh, dh_dz, t_script, tau, &
                     &  rad, i_stop )
d30 2
a31 1
    use GLNP, only: NG, GW
d53 1
a53 2
    real(rp), intent(in) :: ds_dh(:)         ! path length wrt height derivative.
    real(rp), intent(in) :: dh_dz(:)         ! path height wrt zeta derivative.
d86 1
a86 1
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt incoptdepth}.
d95 1
a95 1
          & 0.5_rp * del_zeta(more_inds(i)) * &
d97 1
a97 1
               & ds_dh(aa:aa+ng-1) * dh_dz(aa:aa+ng-1) * gw ) 
d113 1
a113 1
                     &  ds_dh, dh_dz, ct, stcp, stsp, t_script, &
d120 1
d122 1
d148 1
a148 2
    real(rp), intent(in) :: ds_dh(:)         ! path length wrt height derivative.
    real(rp), intent(in) :: dh_dz(:)         ! path height wrt zeta derivative.
d186 1
a186 1
                 &  ds_dh, dh_dz,                &
d231 1
a231 1
!--------------------------------------------------  drad_tran_df  -----
d236 2
a237 2
                         &  beta_path_f, do_gl, del_s, ref_cor, ds_dh, &
                         &  dh_dz, t_script, tau, &
d240 1
a240 1
    use GLNP, only: NG, GW
d242 1
d268 1
a268 2
    real(rp), intent(in) ::  ds_dh(:)        ! path length wrt height derivative.
    real(rp), intent(in) :: dh_dz(:)         ! path height wrt zeta derivative.
d361 1
a361 1
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_df}.
d371 1
a371 1
                & 0.5_rp * del_zeta(i) * &
d376 1
a376 2
                     & ds_dh(gl_inds(aa:aa+ng-1)) * dh_dz(gl_inds(aa:aa+ng-1)) * &
                     & gw )
d400 1
a400 1
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_df}.
d410 1
a410 1
                & 0.5_rp * del_zeta(i) * &
d414 1
a414 2
                     & ds_dh(gl_inds(aa:aa+ng-1)) * dh_dz(gl_inds(aa:aa+ng-1)) * &
                     & gw )
d440 2
a441 2
                         &  sps_path_f, do_calc_f_f, do_gl, del_s, ref_cor,     &
                         &  ds_dh_gl, dh_dz_gl, t_script, tau, i_stop, drad_dx )
d443 1
a443 1
    use GLNP, only: NG, GW
d445 1
d473 1
d477 2
a478 4
    real(rp), intent(in) ::  ds_dh_gl(:)     ! path length wrt height derivative
!                                              on gl grid.
    real(rp), intent(in) :: dh_dz_gl(:)      ! path height wrt zeta derivative
!                                              on gl grid.
d563 1
a563 1
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_dx}.
d573 1
a573 1
                & 0.5_rp * del_zeta(i) * &
d578 1
a578 1
                     & ds_dh_gl(aa:aa+ng-1) * dh_dz_gl(aa:aa+ng-1) * gw )
d607 1
a607 1
                         &  do_gl, h_path_f, t_path_f, dh_dt_path_f, &
d609 1
a609 1
                         &  ds_dh_gl, dh_dz_gl, t_script, dt_scr_dt, &
d613 2
a614 1
    use GLNP, only: NG, GW
d645 1
d657 6
a662 4
    real(rp), intent(in) ::  ds_dh_gl(:)    ! path length wrt height derivative
!                                             on gl grid.
    real(rp), intent(in) :: dh_dz_gl(:)     ! path height wrt zeta derivative
!                                             on gl grid.
d760 1
a760 1
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_dt}.
d770 1
a770 1
              & 0.5_rp * del_zeta(more_inds(i)) * &
d775 1
a775 1
                   & ds_dh_gl(aa:aa+ng-1) * dh_dz_gl(aa:aa+ng-1) * gw )
d821 1
a821 1
        end do
d863 1
a863 1
        end do
d882 2
a883 2
             & dh_dt_tan(sv_i), eta_zxp_f(:,sv_i), ds_dh_gl, &
             & dh_dz_gl, more_inds, all_inds(::ng), gl_delta )
d941 1
d944 2
a945 2
    integer, intent(in) :: C_Inds(:)      ! Indices in Do_Calc_All for coarse grid
    integer, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for find grid
d969 1
a969 1
    use MLSCommon, only: RP
d979 2
a980 2
    integer, intent(out) :: More_Inds(:)
    integer, intent(out) :: All_Inds(:)
d1009 3
@


2.27
log
@Polish up some comments
@
text
@d12 2
a13 2
  public :: Get_Del_Zeta_All, Get_Do_Calc
  private ::  Get_Do_Calc_Indexed
d17 1
a17 1
    & "$Id: rad_tran_m.f90,v 2.26 2003/10/15 02:04:08 vsnyder Exp $"
d28 1
a28 1
  subroutine Rad_tran ( gl_inds, e_rflty, z_path_c, &
d35 1
d41 3
a43 1
    real(rp), intent(in) :: z_path_c(:)      ! path -log(P) on coarse grid.
a66 1
    real(rp) :: del_zeta(size(gl_inds)/ng)
d77 1
a77 1
      call where_GL ( do_gl, z_path_c, more_inds, del_zeta )
d98 1
a98 1
          & 0.5_rp * del_zeta(i) * &
d114 1
a114 1
  subroutine Rad_tran_Pol ( gl_inds, e_rflty, z_path_c, alpha_path_c, ref_cor, &
d125 1
d131 3
a133 1
    real(rp), intent(in) :: z_path_c(:)      ! path -log(P) on coarse grid.
a167 1
    real(rp) :: del_zeta(size(gl_inds)/ng)
d171 1
a171 1
    integer(ip) ::  more_inds(size(gl_inds)/ng)
d176 2
d184 1
a184 1
      call where_GL ( do_gl, z_path_c, more_inds, del_zeta )
d202 1
a202 1
    do p_stop = 1, size(z_path_c)
d210 1
a210 1
    do p_stop = 0, size(z_path_c)-1
d236 1
a236 1
  subroutine DRad_tran_df ( indices_c, gl_inds, z_path_c, Grids_f, &
d251 3
a253 1
    real(rp), intent(in) :: z_path_c(:)      ! -log(P) on main grid.
a297 2
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B
    real(rp), pointer :: del_zeta(:)     ! del_zeta => part_of_del_zeta_B
a338 1
            del_zeta => del_zeta_B(1:no_to_gl)
d341 1
a341 2
            call get_del_zeta_all ( do_gl, do_calc, z_path_c, &
              &                     more_inds, all_inds, del_zeta )
d442 1
a442 1
  subroutine DRad_tran_dx ( z_path_c, Grids_f, dbeta_path_c, eta_zxp_f_c, &
d454 3
a456 1
    real(rp), intent(in) :: z_path_c(:)      ! -log(P) on main grid.
a506 2
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B
    real(rp), pointer :: del_zeta(:)     ! del_zeta => part_of_del_zeta_B
a553 1
            del_zeta => del_zeta_B(1:no_to_gl)
d555 1
a555 2
            call Get_Del_Zeta_All ( Do_GL, Do_Calc, Z_path_c, &
              &                     More_Inds, All_Inds, Del_Zeta )
d603 2
d608 1
a608 1
  subroutine DRad_tran_dt ( z_path_c, h_path_c, t_path_c, dh_dt_path_c, &
d623 3
a625 1
    real(rp), intent(in) :: z_path_c(:)     ! path -log(P) on main grid.
d693 1
a693 2
    real(rp), pointer :: del_zeta(:)     ! del_zeta => part_of_del_zeta_B
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B, gl_delta_B
a745 1
          del_zeta => del_zeta_B(1:no_to_gl)
d748 1
a748 2
          call Get_Del_Zeta_All ( Do_GL, Do_Calc, Z_path_c, &
            &                     More_Inds, All_Inds, Del_Zeta )
d770 1
a770 1
              & 0.5_rp * del_zeta(i) * &
a871 1
          del_zeta => del_zeta_B(1:no_to_gl)
d874 1
a874 2
          call Get_Del_Zeta_All ( Do_GL, Do_Calc, Z_path_c, &
            &                     More_Inds, All_Inds, Del_Zeta )
a905 48
! =====     Would be private if Get_D_Deltau_Pol_d* were here     ======

  ! -------------------------------------------  Get_Del_Zeta_All  -----
  subroutine Get_Del_Zeta_All ( Do_GL, Do_Calc, Z_path_c, &
    &                           More_Inds, All_Inds, Del_Zeta )

    use GLNP, ONLY: Ng
    use MLSCommon, only: RP

    implicit NONE

  ! Inputs
    logical, intent(in) :: Do_GL(:)          ! path flag indicating where to do
      !                                        gl integrations.
    logical, intent(in) :: Do_Calc(:)
    real(rp), intent(in) :: Z_path_c(:)      ! path -log(P) on coarse grid.

  ! Outputs
    integer, intent(out) :: More_Inds(:)
    integer, intent(out) :: All_Inds(:)
    real(rp), intent(out) :: Del_Zeta(:)

    integer :: I, J, K, L, M, N_Path, P_I, P2

    i = 1
    j = 1
    l = 1
    n_path = size(do_gl)
    p_i = 2
    p2 = n_path / 2
    do m = -1, 1, 2
      do p_i = p_i , p2
        if ( do_gl(p_i) ) then
          if ( do_calc(p_i) ) then
            more_inds(i) = p_i
            all_inds(j:j+ng-1) = (/ (l + k, k = 0, ng-1 ) /)
            del_zeta(i) = z_path_c(p_i+m) - z_path_c(p_i)
            i = i + 1
            j = j + Ng
          end if
          l = l + Ng
        end if
      end do
      p2 = n_path - 1
    end do

  end subroutine Get_Del_Zeta_All

d961 2
a962 1
! -----------------------------------------------------  Where_GL  -----
d964 2
a965 1
  subroutine Where_GL ( DO_GL, Z_Path_c, More_Inds, Del_Zeta )
d967 2
a968 3
  ! Compute the indices More_Inds where more GL is needed and the
  ! corresponding Del_Z's.  If this is called when the caller's GL_Inds
  ! has zero size, you'll do a lot of work for nothing.
d970 1
a970 1
    use MLSCommon, only: RP, IP
d972 4
a975 3
    logical, intent(in) :: Do_gl(:)          ! path flag indicating where to do
  !                                            GL integrations.
    real(rp), intent(in) :: Z_path_c(:)      ! path -log(P) on coarse grid.
d977 3
a979 2
    integer(ip), intent(out) :: More_Inds(:) ! Where on coarse path is GL needed?
    real(rp), intent(out) :: Del_Zeta(:)     ! Differences of Z_Path_C
d981 1
a981 1
    integer(ip) :: i, m, n_path, p_i, p2
a982 5
  ! See if anything needs to be gl-d.  Compute del_zeta.

    n_path = size(z_path_c)
    p_i = 1
    p2 = n_path / 2
d984 5
a988 3
    do m = -1, 1, 2
      do p_i = p_i, p2
        if ( do_gl(p_i) ) then
d990 2
a991 1
          del_zeta(i) = z_path_c(p_i+m) - z_path_c(p_i)
d993 1
d995 2
a996 2
      end do
      p2 = n_path
d999 1
a999 1
  end subroutine Where_GL 
d1008 3
@


2.26
log
@Simplifications possible after inlining path_opacity.  Cosmetic changes.
Make Get_Del_Zeta_All public.  Don't bother checking do_calc(1) and
do_calc(n_path) because we know it's false there.
@
text
@d17 1
a17 1
    & "$Id: rad_tran_m.f90,v 2.25 2003/10/09 21:04:38 vsnyder Exp $"
d626 2
a627 2
    real(rp), intent(in) :: alphaxn_path_c(:) ! path absorption times
!                            temperature power(km^-1) on main grid.
d632 2
a633 2
    logical, intent(in) :: do_calc_hyd_c(:,:) ! Indicates where the dh_dt
!                    function is not zero on main grid.
d647 2
a648 2
    real(rp), intent(in) :: alphaxn_path_f(:) ! path absorption times
!                            temperature power(km^-1) on gl grid.
d1053 5
@


2.25
log
@Fix typos generated while inlining path_opacity
@
text
@d6 1
a6 1
  use MLSCommon, only: R8, RP, IP
d12 2
a13 2
  public :: Get_Do_Calc
  private ::  Get_Del_Zeta_All, Get_Do_Calc_Indexed
d17 1
a17 1
    & "$Id: rad_tran_m.f90,v 2.23 2003/09/25 20:06:03 vsnyder Exp $"
d370 3
a372 3
                & sum( (beta_path_f(all_inds(a:a+ng-1),sps_i) * &
                     &  eta_zxp_f(gl_inds(all_inds(a:a+ng-1)),sv_i) * &
                     &  sps_path(gl_inds(all_inds(a:a+ng-1)),sps_i) - &
d576 3
a578 3
                & sum( (dbeta_path_f(all_inds(a:a+ng-1),sps_i) * &
                     &  eta_zxp_f_f(all_inds(a:a+ng-1),sv_i) * &
                     &  sps_path_f(all_inds(a:a+ng-1),sps_i) - &
d640 2
a641 2
    logical, intent(in) :: do_gl(:)         ! Indicates where to do gl
!                                             integrations.
d675 1
a675 1
    integer(ip) :: i, i_start, mid, n_inds, n_path, no_to_gl, p_i, sv_i, sv_t
d696 1
a696 1
      !                                    of the corresponding do_calc_t_f).
d730 3
a732 3
          singularity(inds(i)) = alphaxn_path_c(inds(i)) * eta_zxp_c(inds(i),sv_i) &
                      / t_path_c(inds(i))
          d_delta_dt(inds(i),sv_i) = singularity(inds(i)) * del_s(inds(i))
d735 2
a739 2
! see if anything needs to be gl-d

d768 3
a770 3
              & sum( (alphaxn_path_f(all_inds(a:a+ng-1)) * &
                   &  eta_zxp_f(all_inds(a:a+ng-1),sv_i) / &
                   &  t_path_f(all_inds(a:a+ng-1)) - &
a906 28
  ! ------------------------------------------------  Get_Do_Calc  -----
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_f, Do_GL, Do_Calc )

  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do-Calc_f
  ! flags are set.

    use GLNP, ONLY: Ng

    logical, intent(in) :: Do_Calc_c(:) ! On the coarse grid
    logical, intent(in) :: Do_Calc_f(:) ! On the GL grid
    logical, intent(in) :: Do_GL(:)     ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)  ! Where on coarse grid to do calc.

    integer :: I, P_I

    i = 1
    do_calc = do_calc_c
    do p_i = 1 , size(do_gl)
      if ( do_gl(p_i) ) then
        if ( any(do_calc_f(i:i+ng-1)) ) do_calc(p_i)=.true.
        i = i + Ng
      end if
    end do

  end subroutine Get_Do_Calc

! =====     Private Procedures     =====================================

d927 1
a927 1
    integer :: I, J, K, L, M, Mid, N_Path, P_I, P2
d933 2
a934 3
    mid = n_path / 2
    p_i = 1
    p2 = mid
d948 1
a948 1
      p2 = n_path
d953 28
d1053 3
@


2.24
log
@Reverted to 2.22 for the moment
@
text
@d12 2
a13 1
  private ::  Get_Del_Zeta_All, Get_Do_Calc
d17 1
a17 1
    & "$Id: rad_tran_m.f90,v 2.22 2003/09/24 22:19:55 vsnyder Exp $"
d33 1
a33 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d38 1
a38 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d41 2
a42 2
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient
  !                                            on coarse grid.
d64 2
a65 1
    real(rp) :: gl_delta(size(gl_inds)/ng), del_zeta(size(gl_inds)/ng)
d77 24
a100 6
      call path_opacity ( del_zeta,             &
                &  alpha_path_c, alpha_path_gl, &
                &  ds_dh, dh_dz,                &
                &  gl_delta, more_inds, gl_inds )

      incoptdepth(more_inds) = incoptdepth(more_inds) + gl_delta
d126 1
a126 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d236 1
a236 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d277 2
a278 2
    integer(ip) :: sv_i, sps_i, n_inds, i_start, no_mol
    integer(ip) :: no_to_gl
d290 1
a290 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B, gl_delta_B
a291 1
    real(rp), pointer :: gl_delta(:)     ! gl_delta => part_of_gl_delta_B
d314 1
a314 1
        call get_do_calc ( do_calc_f(indices_c,sv_i), do_calc_f(gl_inds,sv_i), &
a332 1
            gl_delta => gl_delta_B(1:no_to_gl)
d342 38
a379 22
            singularity(inds) = beta_path_c(inds,sps_i) &
                      & * eta_zxp_f(indices_c(inds),sv_i) &
                      & * sps_path(indices_c(inds),sps_i)
            d_delta_df(inds,sv_i) = singularity(inds) * del_s(inds)

            if ( no_to_gl > 0 ) then

              ! Remember: beta_path_f is beta_path(gl_inds), while
              ! eta_zxp_f and sps_path are on the entire path grid.
              call path_opacity ( del_zeta, singularity, &
                 & beta_path_f(all_inds,sps_i)           &
                 &  * eta_zxp_f(gl_inds(all_inds),sv_i)  &
                 &  * sps_path(gl_inds(all_inds),sps_i), &
                 & ds_dh(gl_inds), dh_dz(gl_inds),       &     
                 & gl_delta, more_inds, all_inds )

              d_delta_df(more_inds,sv_i) = d_delta_df(more_inds,sv_i) + gl_delta

            end if

            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) / &
                                  & exp(grids_f%values(sv_i))
d383 34
a416 19
            singularity(inds) = beta_path_c(inds,sps_i) * &
                              & eta_zxp_f(indices_c(inds),sv_i)

            d_delta_df(inds,sv_i) = singularity(inds) * del_s(inds)

            if ( no_to_gl > 0 ) then

              ! Remember: beta_path_f is beta_path(gl_inds), while
              ! eta_zxp_f is on the entire path grid.
              call path_opacity( del_zeta, singularity,  &
                 & beta_path_f(all_inds,sps_i)           &
                 &  * eta_zxp_f(gl_inds(all_inds),sv_i), &
                 & ds_dh(gl_inds),dh_dz(gl_inds),        &
                 & gl_delta, more_inds, all_inds )

              d_delta_df(more_inds,sv_i) = d_delta_df(more_inds,sv_i) + gl_delta

            end if

d443 1
a443 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d487 2
a488 2
    integer(ip) :: sv_i, sv_j, sps_i, n_inds, i_start, no_mol
    integer(ip) :: no_to_gl
d501 1
a501 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B, gl_delta_B
a502 1
    real(rp), pointer :: gl_delta(:)     ! gl_delta => part_of_gl_delta_B
d537 5
a541 3
          singularity(inds) = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)  &
                     &  * sps_path_c(inds,sps_i)
          d_delta_dx(inds) = singularity(inds) * del_s(inds)
a549 1
            gl_delta => gl_delta_B(1:no_to_gl)
d555 28
a582 8
            call path_opacity ( del_zeta, singularity, & 
                &  dbeta_path_f(all_inds,sps_i)        & 
                &   * eta_zxp_f_f(all_inds,sv_i)       & 
                &   * sps_path_f(all_inds,sps_i),      & 
                &  ds_dh_gl, dh_dz_gl,                 & 
                &  gl_delta, more_inds, all_inds )

            d_delta_dx(more_inds) = d_delta_dx(more_inds) + gl_delta
d612 2
a613 1
    use DO_DELTA_M, ONLY: PATH_OPACITY, HYD_OPACITY
d640 2
a641 2
    logical, intent(in) :: do_gl(:)         ! A logical indicating where to do
!                                             gl integrations.
d650 1
a650 1
!                                              gl grid.
d661 2
a662 2
    logical, intent(in) :: deriv_flags(:)   ! A logical indicating which
!                                            temperature derivatives to do
d674 2
a675 2
    integer(ip) :: sv_i, sv_t, n_inds, i, i_start
    integer(ip) :: n_path, p_i, no_to_gl, mid
d729 5
a733 3
        singularity(inds) = alphaxn_path_c(inds) * eta_zxp_c(inds,sv_i) &
                    / t_path_c(inds)
        d_delta_dt(inds,sv_i) = singularity(inds) * del_s(inds)
a740 1
          gl_delta => gl_delta_B(1:no_to_gl)
d747 28
a774 8
          ! Get GL corrections
          call path_opacity ( del_zeta, singularity, &
            &  alphaxn_path_f(all_inds)              &
            &   * eta_zxp_f(all_inds,sv_i)           &
            &   / t_path_f(all_inds),                &
            &  ds_dh_gl, dh_dz_gl, gl_delta, more_inds, all_inds )

          d_delta_dt(more_inds,sv_i) = d_delta_dt(more_inds,sv_i) + gl_delta
d905 28
d982 2
a983 2
  ! ------------------------------------------------  Get_Do_Calc  -----
  subroutine Get_Do_Calc ( Do_Calc_c, Do_Calc_f, Do_GL, Do_Calc )
d990 5
a994 4
    logical, intent(in) :: Do_Calc_c(:) ! On the coarse grid
    logical, intent(in) :: Do_Calc_f(:) ! On the GL grid
    logical, intent(in) :: Do_GL(:)
    logical, intent(out) :: Do_Calc(:)  ! Where on coarse grid to do calc.
d999 1
a999 1
    do_calc = do_calc_c
d1002 1
a1002 1
        if ( any(do_calc_f(i:i+ng-1)) ) do_calc(p_i)=.true.
d1007 1
a1007 1
  end subroutine Get_Do_Calc
d1054 6
@


2.23
log
@Insert TeXnicalities.  Insert many more comments too.  Inline path_opacity,
which results in substantial savings in derivative calculations because it
avoids constructing an array temp within a doubly-nested loop.  It doesn't
make much differences for radiance calculations.
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.21 2003/09/09 22:34:45 vsnyder Exp $"
d32 1
a32 1
    use GLNP, only: NG, GW
d37 1
a37 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
d40 2
a41 2
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient on coarse
  !                                            grid.
d63 1
a63 2
    real(rp) :: del_zeta(size(gl_inds)/ng)
    integer :: A, AA, I
d75 6
a80 24
      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt incoptdepth}.
      !  In the second integral, $G(\zeta)$ is {\tt alpha\_path\_gl} --
      !  which has already been evaluated at the appropriate abscissae -- and
      !  $G(\zeta_i)$ is {\tt alpha\_path\_c}.  The weights are {\tt gw}.

      a = 1
      do i = 1, size(more_inds)
        aa = gl_inds(a)
        incoptdepth(more_inds(i)) = incoptdepth(more_inds(i)) + &
          & 0.5_rp * del_zeta(i) * &
          & sum( (alpha_path_gl(a:a+ng-1) -  alpha_path_c(more_inds(i))) * &            
               & ds_dh(aa:aa+ng-1) * dh_dz(aa:aa+ng-1) * gw ) 
        a = a + ng
      end do ! i
d106 1
a106 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indices
d216 1
a216 1
    use GLNP, only: NG, GW
d257 2
a258 2
    integer(ip) :: i_start, n_inds, no_mol, no_to_gl, sps_i, sv_i
    integer(ip) :: a, aa, i
d270 1
a270 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B
d272 1
d295 1
a295 1
        call get_do_calc_indexed ( do_calc_f(:,sv_i), indices_c, gl_inds, &
d314 1
d324 19
a342 36
            do i = 1, n_inds ! Don't trust the compiler to fuse loops
              singularity(i) = beta_path_c(inds(i),sps_i) &
                        & * eta_zxp_f(indices_c(inds(i)),sv_i) &
                        & * sps_path(indices_c(inds(i)),sps_i)
              d_delta_df(inds(i),sv_i) = singularity(i) * del_s(i)
            end do ! i

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f * eta\_zxp\_f *
      !  sps\_path} -- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              aa = all_inds(a)
              d_delta_df(more_inds(i),sv_i) = d_delta_df(more_inds(i),sv_i) + &
                & 0.5_rp * del_zeta(i) * &
                & sum( (beta_path_f(all_inds(a:a+ng-1),sps_i) * &
                     &  eta_zxp_f(gl_inds(all_inds(a:a+ng-1)),sv_i) * &
                     &  sps_path(gl_inds(all_inds(a:a+ng-1)),sps_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dh(gl_inds(aa:aa+ng-1)) * dh_dz(gl_inds(aa:aa+ng-1)) * &
                     & gw )
              a = a + ng
            end do
d344 2
a345 2
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) * &
                                  & exp(-grids_f%values(sv_i))
d349 18
a366 34
            do i = 1, n_inds ! Don't trust the compiler to fuse loops
              singularity(i) = beta_path_c(inds(i),sps_i) &
                        & * eta_zxp_f(indices_c(inds(i)),sv_i)
              d_delta_df(inds(i),sv_i) = singularity(i) * del_s(i)
            end do ! i

      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_df}.
      !  In the second integral, $G(\zeta)$ is {\tt beta\_path\_f *
      !  eta\_zxp\_f}~-- which have already been evaluated at the appropriate
      !  abscissae~-- and $G(\zeta_i)$ is {\tt singularity}.  The weights
      !  are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              aa = all_inds(a)
              d_delta_df(more_inds(i),sv_i) = d_delta_df(more_inds(i),sv_i) + &
                & 0.5_rp * del_zeta(i) * &
                & sum( (beta_path_f(all_inds(a:a+ng-1),sps_i) * &
                     &  eta_zxp_f(gl_inds(all_inds(a:a+ng-1)),sv_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dh(gl_inds(aa:aa+ng-1)) * dh_dz(gl_inds(aa:aa+ng-1)) * &
                     & gw )
              a = a + ng
            end do
d394 1
a394 1
    use GLNP, only: NG, GW
d438 2
a439 2
    integer(ip) :: A, AA, I
    integer(ip) :: i_start, n_inds, no_mol, no_to_gl, sps_i, sv_i, sv_j
d452 1
a452 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B
d454 1
d489 3
a491 5
          do i = 1, n_inds ! Don't trust the compiler to fuse loops
            singularity(inds(i)) = dbeta_path_c(inds(i),sps_i) * eta_zxp_f_c(inds(i),sv_i)  &
                       &  * sps_path_c(inds(i),sps_i)
            d_delta_dx(inds(i)) = singularity(inds(i)) * del_s(inds(i))
          end do ! i
d500 1
d506 8
a513 28
      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_dx}.
      !  In the second integral, $G(\zeta)$ is {\tt dbeta\_path\_f *
      !  eta\_zxp\_f\_f * sps\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

            a = 1
            do i = 1, no_to_gl
              aa = all_inds(a)
              d_delta_dx(more_inds(i)) = d_delta_dx(more_inds(i)) + &
                & 0.5_rp * del_zeta(i) * &
                & sum( (dbeta_path_f(all_inds(a:a+ng-1),sps_i) * &
                     &  eta_zxp_f_f(all_inds(a:a+ng-1),sv_i) * &
                     &  sps_path_f(all_inds(a:a+ng-1),sps_i) - &
                     &  singularity(more_inds(i))) * &
                     & ds_dh_gl(aa:aa+ng-1) * dh_dz_gl(aa:aa+ng-1) * gw )
              a = a + ng
            end do
d543 1
a543 2
    use DO_DELTA_M, ONLY: HYD_OPACITY
    use GLNP, only: NG, GW
d604 2
a605 2
    integer(ip) :: A, AA
    integer(ip) :: i, i_start, mid, n_inds, n_path, no_to_gl, p_i, sv_i, sv_t
d659 3
a661 5
        do i = 1, n_inds ! Don't trust the compiler to fuse loops
          singularity(inds(i)) = alphaxn_path_c(inds(i)) * eta_zxp_c(inds(i),sv_i) &
                      / t_path_c(inds(i))
          d_delta_dt(inds(i),sv_i) = singularity(inds(i)) * del_s(inds(i))
        end do ! i
d669 1
d676 8
a683 28
      !{ Apply Gauss-Legendre quadrature to the panels indicated by
      !  {\tt more\_inds}.  We remove a singularity (which actually only
      !  occurs at the tangent point) by writing
      !  $\int_{\zeta_i}^{\zeta_{i-1}} G(\zeta) \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta =
      !  G(\zeta_i) \int_{\zeta_i}^{\zeta_{i-1}} \frac{\text{d}s}{\text{d}h}
      !   \frac{\text{d}h}{\text{d}\zeta} \text{d}\zeta +
      !  \int_{\zeta_i}^{\zeta_{i-1}} \left[ G(\zeta) - G(\zeta_i) \right]
      !   \frac{\text{d}s}{\text{d}h} \frac{\text{d}h}{\text{d}\zeta}
      !   \text{d}\zeta$.  The first integral is easy -- it's just
      !  $G(\zeta_i) (\zeta_{i-1}-\zeta_i)$  Here, it is {\tt d\_delta\_dt}.
      !  In the second integral, $G(\zeta)$ is {\tt alphaxn\_path\_f *
      !  eta\_zxp\_f / t\_path\_f}~-- which have already been evaluated at
      !  the appropriate abscissae~-- and $G(\zeta_i)$ is {\tt
      !  singularity}.  The weights are {\tt gw}.

          a = 1
          do i = 1, no_to_gl
            aa = all_inds(a)
            d_delta_dt(more_inds(i),sv_i) = d_delta_dt(more_inds(i),sv_i) + &
              & 0.5_rp * del_zeta(i) * &
              & sum( (alphaxn_path_f(all_inds(a:a+ng-1)) * &
                   &  eta_zxp_f(all_inds(a:a+ng-1),sv_i) / &
                   &  t_path_f(all_inds(a:a+ng-1)) - &
                   &  singularity(more_inds(i))) * &
                   & ds_dh_gl(aa:aa+ng-1) * dh_dz_gl(aa:aa+ng-1) * gw )
            a = a + ng
          end do
d873 1
a873 1
    logical, intent(in) :: Do_GL(:)     ! Where on coarse grid to do GL
a888 27
  ! ----------------------------------------  Get_Do_Calc_Indexed  -----
  subroutine Get_Do_Calc_Indexed ( Do_Calc_all, C_Inds, F_Inds, Do_GL, Do_Calc )

  ! Set Do_Calc if Do_Calc_c or Do_GL and any of the corresponding Do-Calc_f
  ! flags are set.

    use GLNP, ONLY: Ng

    logical, intent(in) :: Do_Calc_all(:) ! On the entire path
    integer, intent(in) :: C_Inds(:)      ! Indices in Do_Calc_All for coarse grid
    integer, intent(in) :: F_Inds(:)      ! Indices in Do_Calc_All for find grid
    logical, intent(in) :: Do_GL(:)       ! Where on coarse grid to do GL
    logical, intent(out) :: Do_Calc(:)    ! Where on coarse grid to do calc.

    integer :: I, P_I

    i = 1
    do_calc = do_calc_all(c_inds)
    do p_i = 1 , size(do_gl)
      if ( do_gl(p_i) ) then
        if ( any(do_calc_all(f_inds(i:i+ng-1))) ) do_calc(p_i)=.true.
        i = i + Ng
      end if
    end do

  end subroutine Get_Do_Calc_Indexed

d934 3
@


2.22
log
@Get rid of some array temps
@
text
@d32 1
a32 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d37 1
a37 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d40 2
a41 2
    real(rp), intent(in) :: alpha_path_c(:)  ! absorption coefficient
  !                                            on coarse grid.
d63 2
a64 1
    real(rp) :: gl_delta(size(gl_inds)/ng), del_zeta(size(gl_inds)/ng)
d76 24
a99 6
      call path_opacity ( del_zeta,             &
                &  alpha_path_c, alpha_path_gl, &
                &  ds_dh, dh_dz,                &
                &  gl_delta, more_inds, gl_inds )

      incoptdepth(more_inds) = incoptdepth(more_inds) + gl_delta
d125 1
a125 1
    integer(ip), intent(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d235 1
a235 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d276 2
a277 2
    integer(ip) :: sv_i, sps_i, n_inds, i_start, no_mol
    integer(ip) :: no_to_gl
d289 1
a289 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B, gl_delta_B
a290 1
    real(rp), pointer :: gl_delta(:)     ! gl_delta => part_of_gl_delta_B
d313 1
a313 1
        call get_do_calc ( do_calc_f(indices_c,sv_i), do_calc_f(gl_inds,sv_i), &
a331 1
            gl_delta => gl_delta_B(1:no_to_gl)
d341 36
a376 19
            singularity(inds) = beta_path_c(inds,sps_i) &
                      & * eta_zxp_f(indices_c(inds),sv_i) &
                      & * sps_path(indices_c(inds),sps_i)
            d_delta_df(inds,sv_i) = singularity(inds) * del_s(inds)

            if ( no_to_gl > 0 ) then

              ! Remember: beta_path_f is beta_path(gl_inds), while
              ! eta_zxp_f and sps_path are on the entire path grid.
              call path_opacity ( del_zeta, singularity, &
                 & beta_path_f(all_inds,sps_i)           &
                 &  * eta_zxp_f(gl_inds(all_inds),sv_i)  &
                 &  * sps_path(gl_inds(all_inds),sps_i), &
                 & ds_dh(gl_inds), dh_dz(gl_inds),       &     
                 & gl_delta, more_inds, all_inds )

              d_delta_df(more_inds,sv_i) = d_delta_df(more_inds,sv_i) + gl_delta

            end if
d378 2
a379 2
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) / &
                                  & exp(grids_f%values(sv_i))
d383 34
a416 18
            singularity(inds) = beta_path_c(inds,sps_i) * &
                              & eta_zxp_f(indices_c(inds),sv_i)

            d_delta_df(inds,sv_i) = singularity(inds) * del_s(inds)

            if ( no_to_gl > 0 ) then

              ! Remember: beta_path_f is beta_path(gl_inds), while
              ! eta_zxp_f is on the entire path grid.
              call path_opacity( del_zeta, singularity,  &
                 & beta_path_f(all_inds,sps_i)           &
                 &  * eta_zxp_f(gl_inds(all_inds),sv_i), &
                 & ds_dh(gl_inds),dh_dz(gl_inds),        &
                 & gl_delta, more_inds, all_inds )

              d_delta_df(more_inds,sv_i) = d_delta_df(more_inds,sv_i) + gl_delta

            end if
d444 1
a444 1
    use DO_DELTA_M, ONLY: PATH_OPACITY
d488 2
a489 2
    integer(ip) :: sv_i, sv_j, sps_i, n_inds, i_start, no_mol
    integer(ip) :: no_to_gl
d502 1
a502 1
    real(rp), target, dimension(1:size(tau)) :: del_zeta_B, gl_delta_B
a503 1
    real(rp), pointer :: gl_delta(:)     ! gl_delta => part_of_gl_delta_B
d538 5
a542 3
          singularity(inds) = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)  &
                     &  * sps_path_c(inds,sps_i)
          d_delta_dx(inds) = singularity(inds) * del_s(inds)
a550 1
            gl_delta => gl_delta_B(1:no_to_gl)
d556 28
a583 8
            call path_opacity ( del_zeta, singularity, & 
                &  dbeta_path_f(all_inds,sps_i)        & 
                &   * eta_zxp_f_f(all_inds,sv_i)       & 
                &   * sps_path_f(all_inds,sps_i),      & 
                &  ds_dh_gl, dh_dz_gl,                 & 
                &  gl_delta, more_inds, all_inds )

            d_delta_dx(more_inds) = d_delta_dx(more_inds) + gl_delta
d613 2
a614 1
    use DO_DELTA_M, ONLY: PATH_OPACITY, HYD_OPACITY
d675 2
a676 2
    integer(ip) :: sv_i, sv_t, n_inds, i, i_start
    integer(ip) :: n_path, p_i, no_to_gl, mid
d730 5
a734 3
        singularity(inds) = alphaxn_path_c(inds) * eta_zxp_c(inds,sv_i) &
                    / t_path_c(inds)
        d_delta_dt(inds,sv_i) = singularity(inds) * del_s(inds)
a741 1
          gl_delta => gl_delta_B(1:no_to_gl)
d748 28
a775 8
          ! Get GL corrections
          call path_opacity ( del_zeta, singularity, &
            &  alphaxn_path_f(all_inds)              &
            &   * eta_zxp_f(all_inds,sv_i)           &
            &   / t_path_f(all_inds),                &
            &  ds_dh_gl, dh_dz_gl, gl_delta, more_inds, all_inds )

          d_delta_dt(more_inds,sv_i) = d_delta_dt(more_inds,sv_i) + gl_delta
d965 1
a965 1
    logical, intent(in) :: Do_GL(:)
d980 27
@


2.21
log
@Don't look at status from cs_expmat if it isn't called
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.20 2003/09/09 00:02:55 vsnyder Exp $"
d29 1
a29 1
                     &  alpha_path_gl, ds_dh_gl, dh_dz_gl, t_script, tau, &
d51 2
a52 4
    real(rp), intent(in) :: ds_dh_gl(:)      ! path length wrt height
  !                                            derivative on gl grid.
    real(rp), intent(in) :: dh_dz_gl(:)      ! path height wrt zeta derivative
  !                                            on gl grid.
d64 2
a65 1
    integer(ip) ::  more_inds(size(gl_inds)/ng)
d75 4
a78 4
      call path_opacity ( del_zeta, &
                &  alpha_path_c(more_inds), &
                &  alpha_path_gl, ds_dh_gl(gl_inds),  &
                &  dh_dz_gl(gl_inds), gl_delta )
d94 1
a94 1
                     &  ds_dh_gl, dh_dz_gl, ct, stcp, stsp, t_script, &
d124 2
a125 4
    real(rp), intent(in) :: ds_dh_gl(:)      ! path length wrt height
  !                                            derivative on gl grid.
    real(rp), intent(in) :: dh_dz_gl(:)      ! path height wrt zeta derivative
  !                                            on gl grid.
d160 4
a163 4
      call polarized_path_opacity ( del_zeta, &
                 &  alpha_path_c(:,more_inds), &
                 &  alpha_path_gl, ds_dh_gl(gl_inds),  &
                 &  dh_dz_gl(gl_inds), gl_delta_polarized )
d212 2
a213 2
                         &  beta_path_f, do_gl, del_s, ref_cor, ds_dh_gl, &
                         &  dh_dz_gl, t_script, tau, &
d241 2
a242 4
    real(rp), intent(in) ::  ds_dh_gl(:)     ! path length wrt height derivative
!                                              on gl grid.
    real(rp), intent(in) :: dh_dz_gl(:)      ! path height wrt zeta derivative
!                                              on gl grid.
d261 8
a268 3
    integer(ip), pointer :: all_inds(:)  ! all_inds => part_of_all_inds_B
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B
    integer(ip), pointer :: more_inds(:) ! more_inds => part_of_more_inds_B
d273 5
a277 3
    real(rp), target :: singularity_B(1:size(tau))
    real(rp), pointer :: singularity(:)  ! singularity => part_of_singularity_B
    logical :: do_calc(1:size(tau))
a303 1
          singularity => singularity_B(1:n_inds)
d324 1
a324 1
            singularity = beta_path_c(inds,sps_i) &
d327 1
a327 1
            d_delta_df(inds,sv_i) = singularity * del_s(inds)
d331 8
a338 7
              call path_opacity ( del_zeta,             &
                 & pack(singularity,do_gl(inds)),       &
                 & beta_path_f(all_inds,sps_i)          &
                 & * eta_zxp_f(gl_inds(all_inds),sv_i)  &
                 & * sps_path(gl_inds(all_inds),sps_i), &
                 & ds_dh_gl(gl_inds(all_inds)),         &     
                 & dh_dz_gl(gl_inds(all_inds)), gl_delta )  
d344 2
a345 2
            d_delta_df(inds,sv_i) = ref_cor(inds) * d_delta_df(inds,sv_i) &
                             / exp(grids_f%values(sv_i))
d349 2
a350 2
            singularity = beta_path_c(inds,sps_i) &
                      & * eta_zxp_f(indices_c(inds),sv_i)
d352 1
a352 1
            d_delta_df(inds,sv_i) = singularity * del_s(inds)
d356 7
a362 6
              call path_opacity( del_zeta,              &
                 & pack(singularity,do_gl(inds)),       &
                 & beta_path_f(all_inds,sps_i)          &
                 & * eta_zxp_f(gl_inds(all_inds),sv_i), &
                 & ds_dh_gl(gl_inds(all_inds)),         &
                 & dh_dz_gl(gl_inds(all_inds)), gl_delta)
d426 2
a427 2
    real(rp), intent(in) :: dh_dz_gl(:)      ! path height wrt zeta derivative on
!                                              gl grid.
d442 8
a449 3
    integer(ip), pointer :: all_inds(:)  ! all_inds => part_of_all_inds_B
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B
    integer(ip), pointer :: more_inds(:) ! more_inds => part_of_more_inds_B
d455 2
a456 2
    real(rp), target :: singularity_B(1:size(tau))
    real(rp), pointer :: singularity(:)  ! singularity => part_of_singularity_B
d458 3
a460 1
    logical :: do_calc(1:size(tau))
a485 1
          singularity => singularity_B(1:n_inds)
d489 1
a489 1
          singularity = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)  &
d491 1
a491 1
          d_delta_dx(inds) = singularity * del_s(inds)
d506 7
a512 5
            call path_opacity ( del_zeta, &
                &  pack(singularity,do_gl(inds)),        &
                &  dbeta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) * &
                &    sps_path_f(all_inds,sps_i), ds_dh_gl(all_inds),         &
                &  dh_dz_gl(all_inds), gl_delta )
d531 1
d560 1
a560 1
    logical, intent(in) :: do_calc_t_c(:,:) ! A logical indicating where the
d562 2
a563 2
    logical, intent(in) :: do_calc_hyd_c(:,:) ! A logical indicating where the
!                    dh_dt function is not zero on main grid.
d581 1
a581 1
    logical, intent(in) :: do_calc_t_f(:,:) ! A logical indicating where the
d608 8
a615 3
    integer(ip), pointer :: all_inds(:)  ! all_inds => part_of_all_inds_B
    integer(ip), pointer :: inds(:)      ! inds => part_of_inds_B
    integer(ip), pointer :: more_inds(:) ! more_inds => part_of_more_inds_B
d622 2
a623 2
    real(rp), pointer :: singularity(:)  ! singularity => part_of_singularity_B
    real(rp), target :: singularity_B(1:size(tau))
d625 3
a627 1
    logical :: do_calc(1:size(tau))
d641 1
a641 1
      IF(.NOT. deriv_flags(sv_i)) CYCLE
a654 1
        singularity => singularity_B(1:n_inds)
d659 1
a659 1
        singularity = alphaxn_path_c(inds)*eta_zxp_c(inds,sv_i) &
d661 1
a661 1
        d_delta_dt(inds,sv_i) = singularity * del_s(inds)
d677 6
a682 5
          call path_opacity ( del_zeta, &
            &  pack(singularity,do_gl(inds)), &
            &  alphaxn_path_f(all_inds)*eta_zxp_f(all_inds,sv_i)  &
            &    / t_path_f(all_inds), ds_dh_gl(all_inds), dh_dz_gl(all_inds), &
            &  gl_delta )
d703 1
d711 5
a715 2
            if ( i == 1) fa = (h_path_c(p_i-1) * dh_dt_path_c(p_i-1,sv_i) &
                           &   - h_tan * dh_dt_tan(sv_i)) / s_del_s
d721 1
a721 1
              &                    alpha_path_c(p_i)*(fa - fb)
d737 2
d741 1
a741 1
              & h_tan * dh_dt_tan(sv_i))/ del_s(mid+1)
d746 1
d749 3
a751 2
        s_del_s = del_s(mid+1)
        do p_i = mid + 2 , n_path - 1
d753 5
a757 3
            if ( inds(max(i-1,1)) < mid+1)  &
                       & fa = (h_path_c(p_i) * dh_dt_path_c(p_i,sv_i) &
                           & - h_tan * dh_dt_tan(sv_i)) / s_del_s
d759 2
a760 2
            fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1,sv_i) &
               - h_tan * dh_dt_tan(sv_i)) / s_del_s
d763 1
a763 1
              &                    alpha_path_c(p_i)*(fb - fa)
d776 4
a779 4
           all_inds => all_inds_B(1:ng*no_to_gl)
           gl_delta => gl_delta_B(1:no_to_gl)
           del_zeta => del_zeta_B(1:no_to_gl)
           more_inds => more_inds_B(1:no_to_gl)
d787 5
a791 5
           call hyd_opacity ( del_zeta, alpha_path_c(more_inds),                &
              & alpha_path_f(all_inds), h_path_f(all_inds),                    &
              & dh_dt_path_f(all_inds,sv_i), t_path_f(all_inds), h_tan,        &
              & dh_dt_tan(sv_i), eta_zxp_f(all_inds,sv_i), ds_dh_gl(all_inds), &
              & dh_dz_gl(all_inds), gl_delta )
d793 1
a793 1
           d_delta_dt(more_inds,sv_i) = d_delta_dt(more_inds,sv_i) + gl_delta
d810 1
a810 1
    end do
d836 1
a836 1
    integer :: I, J, K, L, Mid, N_Path, P_I
d843 11
a853 9
    do p_i = 1 , n_path
      if ( do_gl(p_i) ) then
        if ( do_calc(p_i) ) then
          more_inds(i) = p_i
          all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
          if ( p_i > mid ) then
            del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
          else
            del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
d855 1
a855 2
          i = i + 1
          j = j + Ng
d857 2
a858 2
        l = l + Ng
      end if
d906 1
a906 1
    integer(ip) :: i, n_path, p_i
d908 1
a908 1
  ! see if anything needs to be gl-d
d911 2
d914 6
a919 7
    do p_i = 1, n_path
      if ( do_gl(p_i) ) then
        more_inds(i) = p_i
        if ( p_i > n_path/2 ) then
          del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
        else
          del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
d921 2
a922 2
        i = i + 1
      end if
d934 3
@


2.20
log
@Make deltau_pol inout, only compute it where needed
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.19 2003/08/15 18:50:22 vsnyder Exp $"
d194 2
a195 2
      if ( do_gl(p_stop+1) ) &
        & call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), & ! deltau = exp(incoptdepth_pol)
d197 2
a198 1
      if ( status /= 0 ) go to 99 ! because we can't change p_stop in the loop
d903 3
@


2.19
log
@Preparing the way for polarized vmr derivatives
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.18 2003/06/27 22:05:48 vsnyder Exp $"
d94 1
a94 1
                     &  do_gl, incoptdepth_pol, alpha_path_gl, &
d112 3
a146 1
    complex(rp) :: deltau_pol(2,2,size(z_path_c))
d194 3
a196 2
      call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), & ! deltau = exp(incoptdepth_pol)
        &              deltau_pol(:,:,p_stop+1), status )
d902 3
@


2.18
log
@Check status from cs_expmat
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.17 2003/06/18 17:24:05 bill Exp $"
d212 2
a213 1
                         &  dh_dz_gl, t_script, tau, i_stop, drad_df )
d250 3
a265 1
    real(rp) :: d_delta_df(1:size(tau))
d287 1
a287 1
        d_delta_df = 0.0_rp
d322 1
a322 1
            d_delta_df(inds) = singularity * del_s(inds)
d334 1
a334 1
              d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta
d338 1
a338 1
            d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds) &
d346 1
a346 1
            d_delta_df(inds) = singularity * del_s(inds)
d357 1
a357 1
              d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta
d361 1
a361 1
            d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)
d367 2
a368 2
          call get_dscrt_no_t_dn ( d_delta_df, t_script, tau, i_start, i_stop, &
                                &  drad_df(sv_i))
d899 3
@


2.17
log
@added temperature derivative subsetting
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.16 2003/06/09 20:52:37 vsnyder Exp $"
d137 3
a139 1
    integer(ip), intent(out) :: p_stop       ! path stop index
d149 1
d192 3
a194 2
      call cs_expmat ( incoptdepth_pol(:,:,p_stop+1), &
        &              deltau_pol(:,:,p_stop+1) ) ! deltau = exp(incoptdepth_pol)
d200 5
d896 3
@


2.16
log
@More work on polarized derivatives
@
text
@d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.15 2003/05/20 00:04:28 vsnyder Exp $"
d513 1
a513 1
                         &  tau, i_stop, d_delta_dt, drad_dt )
d563 2
d606 1
a606 1

d887 3
@


2.15
log
@Collect common stuff into subroutines
@
text
@d11 1
a11 1
  public :: RAD_TRAN, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.14 2003/05/15 03:29:00 vsnyder Exp $"
d27 2
a28 2
  subroutine Rad_tran ( indices_c, gl_inds, frq, s_temp, e_rflty, z_path_c, &
                     &  t_path_c, alpha_path_c, ref_cor, do_gl, incoptdepth, &
a32 1
    use DO_T_SCRIPT_M, ONLY: TWO_D_T_SCRIPT
a36 1
    integer(ip), intent(in) :: indices_c(:) ! coarse grid indicies
a37 3
    real(r8), intent(in) :: frq              ! calculation frequency in MHz.
    real(rp), intent(in) :: s_temp           ! farside boundary temperature
  !                                            usually cosmic space (2.7K).
a39 1
    real(rp), intent(in) :: t_path_c(:)      ! path T(K) on coarse grid.
d55 2
d59 3
a61 4
    real(rp), intent(out) :: t_script(:) ! differential temperatures (K).
    real(rp), intent(out) :: tau(:) ! transmission function.
    real(rp), intent(out) :: rad    ! radiances (K)
    integer(ip), intent(out) :: i_stop ! path stop index
a64 2
    logical :: Do_It                   ! Saw one true element of Do_GL
    integer(ip) :: i, p_i, n_path
d72 1
a72 15
    do_it = .false.
    n_path = size(indices_c)
    i = 1
    do p_i = 1, n_path
      do_it = .true.
      if ( do_gl(p_i) ) then
        more_inds(i) = p_i
        if ( p_i > n_path/2 ) then
          del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
        else
          del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
        end if
        i = i + 1
      end if
    end do
d74 1
a74 1
    if ( do_it ) then ! Saw one true element of Do_GL
a86 2
    call two_d_t_script ( t_path_c, s_temp, frq, t_script )

d91 106
d513 1
a513 1
                         &  tau, i_stop, drad_dt )
d566 3
d582 1
a582 1
    real(rp) :: d_delta_dt(1:size(tau))
d584 1
a584 1
    real(rp), pointer :: del_zeta(:)     ! del_zeta => part_of_del_zeta_B
d586 2
a588 2
    real(rp), pointer :: singularity(:)  ! singularity => part_of_singularity_B
    real(rp) :: fa, fb
d600 1
a605 1
      d_delta_dt = 0.0_rp
d621 1
d625 1
a625 1
        d_delta_dt(inds) = singularity * del_s(inds)
d640 1
d646 1
a646 1
          d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
a649 2
        i_start = max(inds(1)-1,1)

d656 2
a657 14
      if ( do_calc_hyd_c(mid,sv_i) ) then
        do_calc(2:mid) = .true.
      else
        do p_i = 2 , mid
          if ( do_calc_hyd_c(p_i-1,sv_i)) do_calc(p_i) = .true.
        end do
      end if
      if ( do_calc_hyd_c(mid+1,sv_i) ) then
        do_calc(mid+1:n_path-1) = .true.
      else
        do p_i = mid + 1 , n_path - 1
          if ( do_calc_hyd_c(p_i+1,sv_i)) do_calc(p_i) = .true.
        end do
      end if
d670 1
d673 3
a675 2
            if ( i == 1) fa = (h_path_c(p_i-1)*dh_dt_path_c(p_i-1,sv_i) &
                          - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(p_i:mid))
d677 1
a677 1
               - h_tan * dh_dt_tan(sv_i)) /SUM(del_s(p_i+1:mid))
d679 2
a680 1
            d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fa - fb)
d683 2
d688 1
a688 1
! special processing at tangent
d691 1
a691 4
          d_delta_dt(mid) = d_delta_dt(mid) + alpha_path_c(mid) * fa

! fb is zero

d699 3
a701 5
          d_delta_dt(mid+1) = d_delta_dt(mid+1) + alpha_path_c(mid+1) * fa

! fb is 0.0

          inds(i) = mid+1
d705 1
d709 3
a711 2
                       & fa = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
                       &    - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(mid+1:p_i-1))
d713 1
a713 1
               - h_tan * dh_dt_tan(sv_i)) /sum(del_s(mid+1:p_i))
d715 2
a716 1
            d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fb - fa)
d719 2
d746 1
a746 1
           d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
d756 5
a760 2
      d_delta_dt = ref_cor * d_delta_dt
      call get_dscrt_dn ( d_delta_dt, t_script, tau, dt_scr_dt(:,sv_i), i_start, &
d841 37
d885 3
@


2.14
log
@Moved some stuff up to FullForwardModel because Get_d_Deltau_pol_dT needs it
@
text
@d12 1
d16 1
a16 1
    & "$Id: rad_tran_m.f90,v 2.13 2003/05/05 23:00:26 livesey Exp $"
d27 2
a28 2
  subroutine Rad_tran ( indicies_c, gl_inds, frq, s_temp, e_rflty, z_path, &
                     &  t_path, alpha_path_c, ref_cor, do_gl, incoptdepth, &
d38 1
a38 1
    integer(ip), intent(in) :: indicies_c(:) ! coarse grid indicies
d40 12
a51 12
    real(r8), intent(in) :: frq ! calculation frequency in MHz.
    real(rp), intent(in) :: s_temp ! farside boundary temperature
  !                                usually cosmic space (2.7K).
    real(rp), intent(in) :: e_rflty ! earth reflectivity value (0--1).
    real(rp), intent(in) :: z_path(:) ! path -log(P) on input grid.
    real(rp), intent(in) :: t_path(:) ! path T(K) on input grid.
    real(rp), intent(in) :: alpha_path_c(:) ! absorption coefficient
  !                         on input grid.
    real(rp), intent(in) :: ref_cor(:) ! refracted to unrefracted path
  !                                      length ratios.
    logical, intent(in) :: do_gl(:) ! path flag indicating where to do
  !                                   gl integrations.
d56 5
a60 5
  !                                        grid.
    real(rp), intent(in) :: ds_dh_gl(:) ! path length wrt height derivative on
  !                                        gl grid.
    real(rp), intent(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
  !                                       gl grid.
d70 1
a76 2
    call two_d_t_script ( t_path(indicies_c), s_temp, frq, t_script )

d79 11
a89 12
    if ( any(do_gl) ) then
      n_path = size(indicies_c)
      i = 1
      do p_i = 1, n_path
        if ( do_gl(p_i) ) then
          more_inds(i) = p_i
          if ( p_i > n_path/2 ) then
            del_zeta(i) = z_path(indicies_c(p_i+1)) - z_path(indicies_c(p_i))
          else
            del_zeta(i) = z_path(indicies_c(p_i-1)) - z_path(indicies_c(p_i))
          end if
          i = i + 1
d91 5
a95 1
      end do
d108 2
d117 1
a117 1
  subroutine DRad_tran_df ( indicies_c, gl_inds, z_path, Grids_f, &
d120 1
a120 2
                         &  dh_dz_gl, t_script, tau, i_stop, drad_df, ptg_i, &
                         &  frq_i)
d125 1
d129 1
a129 1
    integer(ip), intent(in) :: indicies_c(:) ! coarse grid indicies
d131 2
a132 2
    real(rp), intent(in) :: z_path(:) ! -log(P) on main grid.
    type (Grids_T), intent(in) :: Grids_f ! All the coordinates
d135 5
a139 5
    real(rp), intent(in) :: eta_zxp_f(:,:) ! representation basis function.
    real(rp), intent(in) :: sps_path(:,:) ! Path species function.
    logical, intent(in) :: do_calc_f(:,:) ! A logical indicating where the
!                                           representation basis function is
!                                           not zero.
d142 12
a153 13
    logical, intent(in) :: do_gl(:) ! A logical indicating where to do gl
!                                     integrations
    real(rp), intent(in) :: ref_cor(:) ! refracted to unrefracted path
!                                        length ratios.
    real(rp), intent(in) :: del_s(:) ! unrefracted path length.
    real(rp), intent(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                          gl grid.
    real(rp), intent(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                         gl grid.
    real(rp), intent(in) :: t_script(:) ! differential temperatures (K).
    real(rp), intent(in) :: tau(:) ! transmission function.
    integer(ip), intent(in) :: i_stop ! path stop index
    integer(ip), intent(in) :: ptg_i,frq_i ! debugger statements
d157 3
a159 3
    real(rp), intent(out) :: drad_df(:)    ! derivative of radiances wrt
!                                            mixing ratio statevector
!                                            element. (K)
d162 2
a163 2
    integer(ip) :: sv_i, sps_i, n_inds, i, j, k, l, i_start, no_mol
    integer(ip) :: n_path, p_i, no_to_gl, mid
a180 2
    n_path = size(tau)
    mid = n_path / 2
a191 1
        i = 1
d193 3
a195 7
        do_calc = do_calc_f(indicies_c,sv_i)
        do p_i = 1 , n_path
          if ( do_gl(p_i) ) then
            if ( any(do_calc_f(gl_inds(i:i+ng-1),sv_i))) do_calc(p_i)=.true.
            i = i + Ng
          end if
        end do
d205 16
a220 7
          i = 1
          do p_i = 1 , n_path
            if ( do_calc(p_i) ) then
              inds(i) = p_i
              i = i + 1
            end if
          end do
d225 2
a226 2
                      & * eta_zxp_f(indicies_c(inds),sv_i) &
                      & * sps_path(indicies_c(inds),sps_i)
a228 1
            no_to_gl = count(do_gl(inds))
d231 7
a237 1
! see if anything needs to be gl-d
a238 34
              all_inds => all_inds_B(1:ng*no_to_gl)
              gl_delta => gl_delta_B(1:no_to_gl)
              del_zeta => del_zeta_B(1:no_to_gl)
              more_inds => more_inds_B(1:no_to_gl)

              i = 1
              j = 1
              l = 1
              do p_i = 1 , n_path
                if ( do_gl(p_i) ) then
                  if ( do_calc(p_i) ) then
                    more_inds(i) = p_i
                    all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                    if ( p_i > mid ) then
                      del_zeta(i) = z_path(indicies_c(p_i+1)) &
                                & - z_path(indicies_c(p_i))
                    else
                      del_zeta(i) = z_path(indicies_c(p_i-1)) &
                                & - z_path(indicies_c(p_i))
                    end if
                    i = i + 1
                    j = j + Ng
                  end if
                  l = l + Ng
                end if
              end do

              call path_opacity ( del_zeta, &
                   pack(singularity,do_gl(inds)),     &
                   beta_path_f(all_inds,sps_i) &
                 & * eta_zxp_f(gl_inds(all_inds),sv_i) &
                 & * sps_path(gl_inds(all_inds),sps_i), &
                 &   ds_dh_gl(gl_inds(all_inds)), &
                 &   dh_dz_gl(gl_inds(all_inds)), gl_delta )
d243 1
a243 1
            d_delta_df(inds) = ref_cor(inds)*d_delta_df(inds) &
d249 2
a250 1
                      & * eta_zxp_f(indicies_c(inds),sv_i)
a252 1
            no_to_gl = count(do_gl(inds))
d255 6
a260 1
! see if anything needs to be gl-d
a261 33
              all_inds => all_inds_B(1:ng*no_to_gl)
              gl_delta => gl_delta_B(1:no_to_gl)
              del_zeta => del_zeta_B(1:no_to_gl)
              more_inds => more_inds_B(1:no_to_gl)

              i = 1
              j = 1
              l = 1
              do p_i = 1 , n_path
                if ( do_gl(p_i) ) then
                  if ( do_calc(p_i) ) then
                    more_inds(i) = p_i
                    all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                    if ( p_i > mid ) then
                      del_zeta(i) = z_path(indicies_c(p_i+1)) &
                                & - z_path(indicies_c(p_i))
                    else
                      del_zeta(i) = z_path(indicies_c(p_i-1)) &
                                & - z_path(indicies_c(p_i))
                    end if
                    i = i + 1
                    j = j + Ng
                  end if
                  l = l + Ng
                end if
              end do

              call path_opacity(del_zeta, &
                   pack(singularity,do_gl(inds)), &
                   beta_path_f(all_inds,sps_i) &
                 & * eta_zxp_f(gl_inds(all_inds),sv_i), &
                 & ds_dh_gl(gl_inds(all_inds)),dh_dz_gl(gl_inds(all_inds)), &
                 & gl_delta)
d290 1
a290 2
                         &  ds_dh_gl, dh_dz_gl, t_script, tau, i_stop, drad_dx, &
                         &  ptg_i, frq_i )
d295 1
d299 2
a300 2
    real(rp), intent(in) :: z_path_c(:) ! -log(P) on main grid.
    type (Grids_T) :: Grids_f           ! All the coordinates
d305 4
a308 4
    real(rp), intent(in) :: sps_path_c(:,:) ! species function on  main grid.
    logical, intent(in) :: do_calc_f_c(:,:) ! A logical indicating where the
!                                           representation basis function is
!                                           not zero on main grid.
d313 16
a328 17
    real(rp), intent(in) :: sps_path_f(:,:) ! species function on gl grid.
    logical, intent(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                           representation basis function is
!                                           not zero on main grid.
    logical, intent(in) :: do_gl(:) ! A logical indicating where to do gl
!                                     integrations
    real(rp), intent(in) :: ref_cor(:) ! refracted to unrefracted path
!                                        length ratios.
    real(rp), intent(in) :: del_s(:) ! unrefracted path length.
    real(rp), intent(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                          gl grid.
    real(rp), intent(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                         gl grid.
    real(rp), intent(in) :: t_script(:) ! differential temperatures (K).
    real(rp), intent(in) :: tau(:) ! transmission function.
    integer(ip), intent(in) :: i_stop ! path stop index
    integer(ip), intent(in) :: ptg_i,frq_i ! debugger statements
d332 2
a333 2
    real(rp), intent(out) :: drad_dx(:)    ! derivative of radiances wrt x
!                                            statevector element. (K)
d336 2
a337 2
    integer(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, no_mol
    integer(ip) :: n_path, p_i, no_to_gl, mid
a355 2
    n_path = size(tau)
    mid = n_path / 2
d368 2
a369 9
        do_calc = do_calc_f_c(:,sv_i)

        i = 1
        do p_i = 1 , n_path
          if ( do_gl(p_i) ) then
            if ( any(do_calc_f_f(i:i+Ng-1,sv_i))) do_calc(p_i) = .true.
            i = i + Ng
          end if
        end do
d379 1
a379 7
          i = 1
          do p_i = 1 , n_path
            if ( do_calc(p_i) ) then
              inds(i) = p_i
              i = i + 1
            end if
          end do
d395 2
a396 19
            i = 1
            j = 1
            l = 1
            do p_i = 1 , n_path
              if ( do_gl(p_i) ) then
                if ( do_calc(p_i) ) then
                  more_inds(i) = p_i
                  all_inds(j:j+Ng-1) = l + (/(k-1,k=1,Ng)/)
                  if ( p_i > mid ) then
                    del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                  else
                    del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                  end if
                  i = i + 1
                  j = j + Ng
                end if
                l = l + Ng
              end if
            end do
d430 1
a430 2
                         &  tau, i_stop, drad_dt,  &
                         &  ptg_i, frq_i )
a432 1
    use D_T_SCRIPT_DTNP_M, only: DT_SCRIPT_DT
d434 1
a479 1
    integer(ip), intent(in) :: ptg_i, frq_i ! debugger statements
d484 1
a484 1
!                                             mixing ratio statevector
d488 1
a488 1
    integer(ip) :: sv_i, sv_t, n_inds, i, j, k, l, i_start
d524 2
a525 9
      do_calc = do_calc_t_c(:,sv_i)

      i = 1
      do p_i = 1 , n_path
        if ( do_gl(p_i) ) then
          if ( any(do_calc_t_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
          i = i + Ng
        end if
      end do
d533 2
a534 7
        i = 1
        do p_i = 1 , n_path
          if ( do_calc(p_i) ) then
            inds(i) = p_i
            i = i + 1
          end if
        end do
d545 14
a558 31
           all_inds => all_inds_B(1:ng*no_to_gl)
           gl_delta => gl_delta_B(1:no_to_gl)
           del_zeta => del_zeta_B(1:no_to_gl)
           more_inds => more_inds_B(1:no_to_gl)

           i = 1
           j = 1
           l = 1
           do p_i = 1 , n_path
             if ( do_gl(p_i) ) then
               if ( do_calc(p_i) ) then
                 more_inds(i) = p_i
                 all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                 if ( p_i > mid ) then
                   del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                 else
                   del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                 end if
                 i = i + 1
                 j = j + Ng
               end if
               l = l + Ng
             end if
           end do

           call path_opacity ( del_zeta, &
             &  pack(singularity,do_gl(inds)), &
             &  alphaxn_path_f(all_inds)*eta_zxp_f(all_inds,sv_i)  &
             &    / t_path_f(all_inds), ds_dh_gl(all_inds), dh_dz_gl(all_inds), &
             &  gl_delta )
           d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
d655 2
a656 19
           i = 1
           j = 1
           l = 1
           do p_i = 1 , n_path
             if ( do_gl(p_i) ) then
               if ( do_calc(p_i) ) then
                 more_inds(i) = p_i
                 all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                 if ( p_i > mid ) then
                   del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                 else
                   del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                 end if
                 i = i + 1
                 j = j + Ng
               end if
               l = l + Ng
             end if
           end do
d685 74
d766 3
@


2.13
log
@Merged in feb03 newfwm branch
@
text
@d15 1
a15 1
    & "$Id$"
d17 1
a17 1
  character (len=*), parameter :: ModuleName = "$RCSfile$"
d511 1
a511 1
                         &  freq, do_gl, h_path_f, t_path_f, dh_dt_path_f, &
d513 2
a514 1
                         &  ds_dh_gl, dh_dz_gl, t_script, tau, i_stop, drad_dt,  &
d523 3
a525 3
    real(rp), intent(in) :: z_path_c(:) ! path -log(P) on main grid.
    real(rp), intent(in) :: h_path_c(:) ! path heights + req on main grid km.
    real(rp), intent(in) :: t_path_c(:) ! path temperature(K) on main grid.
d532 1
a532 1
    real(rp), intent(in) :: eta_zxp_c(:,:) ! representation basis function
d538 10
a547 11
    real(rp), intent(in) :: del_s(:) ! unrefracted path length.
    real(rp), intent(in) :: ref_cor(:) ! refracted to unrefracted path
!                                        length ratios.
    real(rp), intent(in) :: h_tan ! tangent height + req (km).
    real(rp), intent(in) :: dh_dt_tan(:) ! derivative of path height wrt
!                                       temperature at the tangent (km/K).
    real(r8), intent(in) :: freq ! calculation frequency (MHz).
    logical, intent(in) :: do_gl(:) ! A logical indicating where to do gl
!                                     integrations.
    real(rp), intent(in) :: h_path_f(:) ! path heights + req on gl grid km.
    real(rp), intent(in) :: t_path_f(:) ! path temperature(K) on gl grid.
d553 1
a553 1
    real(rp), intent(in) :: eta_zxp_f(:,:) ! representation basis function
d557 9
a565 8
    real(rp), intent(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                          gl grid.
    real(rp), intent(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                         gl grid.
    real(rp), intent(in) :: t_script(:) ! differential temperatures (K).
    real(rp), intent(in) :: tau(:) ! transmission function.
    integer(ip), intent(in) :: i_stop ! path stop index
    integer(ip), intent(in) :: ptg_i,frq_i ! debugger statements
d569 3
a571 3
    real(rp), intent(out) :: drad_dt(:)    ! derivative of radiances wrt
!                                            mixing ratio statevector
!                                            element. (K)
a582 1
    real(rp) :: dt_scr_dt(1:size(tau),1:size(eta_zxp_c,dim=2))
a597 4
! compute the t_script derivative

    call dt_script_dt ( t_path_c, eta_zxp_c, freq, dt_scr_dt )

d823 4
a826 1
! $Log$
@


2.12
log
@OOPS, forgot to move one down
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.11 2003/02/07 02:12:00 vsnyder Exp $"
d17 1
a17 1
  character (len=*), parameter :: ModuleName = "$RCSfile: rad_tran_m.f90,v $"
d69 1
a69 1
    integer(ip) :: i, j, k, p_i, n_path
a76 3
    n_path = size(indicies_c)
    if ( count(do_gl) > 0 ) then

d79 2
a81 1
      j = 1
a90 1
          j = j + Ng
d98 1
d158 2
a159 2
    integer(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, no_mol
    integer(ip) :: n_path, p_i, no_to_gl, mid, n_tot
d176 1
a176 1
    no_mol = size(Grids_f%no_z)
a179 1
    sv_i = 0
d184 1
a184 5
      n_tot = Grids_f%no_f(sps_i)*Grids_f%no_z(sps_i)*Grids_f%no_p(sps_i)

      do sv_j = 1, n_tot

        sv_i = sv_i + 1
d407 1
a407 1
    no_mol = size(grids_f%no_z)
d416 2
a417 1
      do sv_j = 1 , Grids_f%no_z(sps_i) * Grids_f%no_p(sps_i)
d827 10
a836 1
! $Log: rad_tran_m.f90,v $
@


2.12.2.1
log
@Get rid of unused variables, use 'any' instead of 'count'
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.12 2003/02/07 02:35:48 vsnyder Exp $"
d69 1
a69 1
    integer(ip) :: i, p_i, n_path
d77 3
a81 2
    if ( any(do_gl) ) then
      n_path = size(indicies_c)
d83 1
d93 1
a100 1

a833 3
! Revision 2.12  2003/02/07 02:35:48  vsnyder
! OOPS, forgot to move one down
!
@


2.12.2.2
log
@Revise Grids_T structure
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.12.2.1 2003/03/05 03:31:13 vsnyder Exp $"
d158 2
a159 2
    integer(ip) :: sv_i, sps_i, n_inds, i, j, k, l, i_start, no_mol
    integer(ip) :: n_path, p_i, no_to_gl, mid
d176 1
a176 1
    no_mol = ubound(Grids_f%l_z,1)
d180 1
d185 5
a189 1
      do sv_i = Grids_f%l_v(sps_i-1)+1, Grids_f%l_v(sps_i)
d412 1
a412 1
    no_mol = ubound(grids_f%l_z,1)
d421 1
a421 2
      do sv_j = 1 , (Grids_f%l_z(sps_i) - Grids_f%l_z(sps_i-1)) * &
        &           (Grids_f%l_p(sps_i) - Grids_f%l_p(sps_i-1))
a831 3
! Revision 2.12.2.1  2003/03/05 03:31:13  vsnyder
! Get rid of unused variables, use 'any' instead of 'count'
!
@


2.11
log
@Move some USE statements down
@
text
@d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.10 2003/02/03 19:00:52 bill Exp $"
d37 2
a38 2
    INTEGER(ip), intent(in) :: indicies_c(:) ! coarse grid indicies
    INTEGER(ip), INTENT(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d351 1
d606 1
a606 1
    call dt_script_dt(t_path_c,eta_zxp_c,freq,dt_scr_dt)
d834 3
@


2.10
log
@changed interface to rad tran to speed up program
@
text
@a7 3
  use DO_DELTA_M, ONLY: PATH_OPACITY, HYD_OPACITY
  use SCRT_DN_M, ONLY: SCRT_DN, GET_DSCRT_NO_T_DN, GET_DSCRT_DN
  use LOAD_SPS_DATA_M, ONLY: GRIDS_T
d15 1
a15 1
    & "$Id: rad_tran_m.f90,v 2.9 2003/01/08 00:15:42 vsnyder Exp $"
d26 1
a26 1
  SUBROUTINE Rad_tran ( indicies_c, gl_inds, frq, s_temp, e_rflty, z_path, &
d31 1
d33 1
d69 3
a71 3
    integer(ip) :: i, j, k, p_i, no_to_gl, n_path
    real(rp), allocatable :: gl_delta(:), del_zeta(:)
    integer(ip), allocatable :: all_inds(:), more_inds(:)
d78 1
a78 2
    no_to_gl = count(do_gl)
    if ( no_to_gl > 0 ) then
a81 5
      allocate ( all_inds(1:ng*no_to_gl) )
      allocate ( gl_delta(1:no_to_gl) )
      allocate ( del_zeta(1:no_to_gl) )
      allocate ( more_inds(1:no_to_gl) )

a86 1
          all_inds(j:j+ng-1) = (/(j + k, k=0,ng-1)/)
d99 2
a100 2
                &  alpha_path_gl(all_inds), ds_dh_gl(gl_inds(all_inds)),  &
                &  dh_dz_gl(gl_inds(all_inds)), gl_delta )
a102 5
      deallocate ( more_inds )
      deallocate ( del_zeta )
      deallocate ( gl_delta )
      deallocate ( all_inds )

d109 1
a109 1
  end subroutine rad_tran
d114 1
a114 1
  SUBROUTINE drad_tran_df ( indicies_c, gl_inds, z_path, Grids_f, &
d120 4
d125 3
a127 2
    INTEGER(ip), intent(in) :: indicies_c(:) ! coarse grid indicies
    INTEGER(ip), INTENT(in) :: gl_inds(:)    ! Gauss-Legendre grid indicies
d345 1
a345 1
  subroutine drad_tran_dx ( z_path_c, Grids_f, dbeta_path_c, eta_zxp_f_c, &
d351 3
d509 1
a509 1
  end subroutine drad_tran_dx
d513 1
a513 1
  subroutine drad_tran_dt ( z_path_c, h_path_c, t_path_c, dh_dt_path_c, &
d521 3
a523 1
  use D_T_SCRIPT_DTNP_M, only: DT_SCRIPT_DT
d824 1
a824 1
  end subroutine drad_tran_dt
d833 3
@


2.9
log
@Moved path_contrib to its own module
@
text
@d18 1
a18 1
    & "$Id: rad_tran_m.f90,v 2.8 2002/10/08 17:08:06 pwagner Exp $"
d29 4
a32 3
  subroutine Rad_tran ( frq, s_temp, e_rflty, z_path_c, t_path_c, alpha_path_c, &
                     &  ref_cor, do_gl, incoptdepth, alpha_path_gl, ds_dh_gl,   &
                     &  dh_dz_gl, t_script, tau, rad, i_stop )
d38 2
d44 2
a45 2
    real(rp), intent(in) :: z_path_c(:) ! path -log(P) on input grid.
    real(rp), intent(in) :: t_path_c(:) ! path T(K) on input grid.
d76 1
a76 1
    call two_d_t_script ( t_path_c, s_temp, frq, t_script )
d78 1
a78 1
    n_path = size(z_path_c)
d96 1
a96 1
            del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
d98 1
a98 1
            del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
d107 2
a108 2
                &  alpha_path_gl(all_inds), ds_dh_gl(all_inds),  &
                &  dh_dz_gl(all_inds), gl_delta )
d127 5
a131 5
  subroutine drad_tran_df ( z_path_c, Grids_f, &
                         &  beta_path_c, eta_zxp_f_c, sps_path_c, do_calc_f_c, &
                         &  beta_path_f, eta_zxp_f_f, sps_path_f, do_calc_f_f, &
                         &  do_gl, del_s, ref_cor, ds_dh_gl, dh_dz_gl, t_script,&
                         &  tau, i_stop, drad_df, ptg_i, frq_i )
d134 3
a136 2

    real(rp), intent(in) :: z_path_c(:) ! -log(P) on main grid.
d139 4
a142 5
!                                              on main grid.
    real(rp), intent(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                              main grid.
    real(rp), intent(in) :: sps_path_c(:,:) ! species function on  main grid.
    logical, intent(in) :: do_calc_f_c(:,:) ! A logical indicating where the
d144 1
a144 1
!                                           not zero on main grid.
a146 6
    real(rp), intent(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                              gl grid.
    real(rp), intent(in) :: sps_path_f(:,:) ! species function on gl grid.
    logical, intent(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                           representation basis function is
!                                           not zero on main grid.
d201 1
a201 1
! Skip the masked derivatives, accordiong to the l2cf inputs
d207 1
a207 1
        do_calc = do_calc_f_c(:,sv_i)
d210 1
a210 1
            if ( any(do_calc_f_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
d233 3
a235 2
            singularity = beta_path_c(inds,sps_i)*eta_zxp_f_c(inds,sv_i) &
                       &  * sps_path_c(inds,sps_i)
d257 2
a258 1
                      del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
d260 2
a261 1
                      del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
d272 5
a276 3
                   beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) &
                   * sps_path_f(all_inds,sps_i), ds_dh_gl(all_inds),      &
                   dh_dz_gl(all_inds), gl_delta )
d286 2
a287 1
            singularity = beta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)
d309 2
a310 1
                      del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
d312 2
a313 1
                      del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
d324 4
a327 2
                   beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i), &
                   ds_dh_gl(all_inds),dh_dz_gl(all_inds),gl_delta)
d458 2
a459 2
          singularity = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i) * &
                     &  sps_path_c(inds,sps_i)
d836 3
@


2.8
log
@Added idents to survive zealous Lahey optimizer
@
text
@d14 1
a14 1
  public :: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d18 1
a18 1
    & "$Id: rad_tran_m.f90,v 2.7 2002/10/02 20:09:48 vsnyder Exp $"
a25 63
!--------------------------------------------------  Path_Contrib  -----
! This routine computes the contributions (along the path) of each interval
! of the (coarse) pre-selected integration grid

  subroutine Path_Contrib ( alpha_path, del_s, e_rflty, tol, dtaudn, &
                      &     incoptdepth, do_gl )

  ! inputs

    real(rp), intent(in) :: alpha_path(:) ! absorption coefficient along the
  !                                         path
    real(rp), intent(in) :: del_s(:)       ! path lengths
    real(rp), intent(in) :: tol            ! accuracy target in K
    real(rp), intent(in) :: e_rflty        ! earth reflectivity

  ! outputs

    real(rp), intent(out) :: dtaudn(:) ! path derivative of the transmission
  !                                    function
    real(rp), intent(out) :: incoptdepth(:) ! layer optical depth
    logical(ip), intent(out) :: do_gl(:) ! set true for indicies to do
  !                                         gl computation
  ! Internal stuff

    integer(ip) :: i, i_tan, n_path
    real(rp), parameter :: temp = 250.0_rp

  ! start code
  ! compute the incoptdepth

    n_path = size(alpha_path)
    i_tan = n_path / 2

    incoptdepth = alpha_path * del_s

    dtaudn(1) = 0.0_rp
    do i = 2 , i_tan
      dtaudn(i) = dtaudn(i-1) - incoptdepth(i)
    end do

    dtaudn(i_tan+1) = dtaudn(i_tan)

    do i = i_tan+2, n_path
      dtaudn(i) = dtaudn(i-1) - incoptdepth(i-1)
    end do

  ! compute the tau path derivative

    dtaudn = 0.5_rp*(eoshift(dtaudn,1,dtaudn(n_path)) -             &
                     eoshift(dtaudn,-1,dtaudn(1))) * exp(dtaudn)

    dtaudn(i_tan+1:n_path) = dtaudn(i_tan+1:n_path) * e_rflty

  ! find the indicies

    do_gl = dtaudn < -tol/temp

  ! The first and last index must be false

    do_gl((/1,n_path/)) = .FALSE.

  end subroutine Path_Contrib

d829 3
@


2.7
log
@Use automatic arrays to move allocate/deallocate out of loops.  Numerous
cosmetic changes.
@
text
@d18 1
a18 1
    & "$Id: rad_tran_m.f90,v 2.6 2002/07/05 07:52:52 zvi Exp $"
d21 1
d886 4
d892 4
@


2.6
log
@Some cosmetic changes
@
text
@d1 3
d5 1
a5 1
!
d7 5
a11 6
  USE GLNP, ONLY: Ng
  USE DO_T_SCRIPT_M, ONLY: TWO_D_T_SCRIPT
  USE D_T_SCRIPT_DTNP_M, ONLY: DT_SCRIPT_DT
  USE DO_DELTA_M, ONLY: PATH_OPACITY,HYD_OPACITY
  USE SCRT_DN_M, ONLY: SCRT_DN, GET_DSCRT_NO_T_DN, GET_DSCRT_DN
  USE LOAD_SPS_DATA_M, ONLY: GRIDS_T
d14 2
a15 1
  PUBLIC :: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d17 4
a20 4
  CHARACTER (LEN=256) :: Id = &
       "$Id: rad_tran_m.f90,v 2.5 2002/06/13 22:38:40 bill Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
       "$RCSfile: rad_tran_m.f90,v $"
d23 3
a25 1
!----------------------------------------------------------------------
d29 60
a88 61
SUBROUTINE path_contrib(alpha_path,del_s,e_rflty,tol,dtaudn, &
                    &   incoptdepth,do_gl)
!
! inputs
!
  REAL(rp), INTENT(in) :: alpha_path(:) ! absorption coefficient along the
!                                         path
  REAL(rp), INTENT(in) :: del_s(:)       ! path lengths
  REAL(rp), INTENT(in) :: tol            ! accuracy target in K
  REAL(rp), INTENT(in) :: e_rflty        ! earth reflectivity
!
! outputs
!
  REAL(rp), INTENT(out) :: dtaudn(:) ! path derivative of the transmission
!                                    function
  REAL(rp), INTENT(out) :: incoptdepth(:) ! layer optical depth
  LOGICAL(ip), INTENT(out) :: do_gl(:) ! set true for indicies to do
!                                         gl computation
! Internal stuff
!
  INTEGER(ip) :: i, i_tan, n_path
  REAL(rp), PARAMETER :: temp = 250.0_rp
!
! start code
! compute the incoptdepth
!
  n_path = SIZE(alpha_path)
  i_tan = n_path / 2
!
  incoptdepth = alpha_path * del_s
!
  dtaudn(1) = 0.0_rp
  DO i = 2 , i_tan
    dtaudn(i) = dtaudn(i-1) - incoptdepth(i)
  ENDDO
!
  dtaudn(i_tan+1) = dtaudn(i_tan)
!
  DO i = i_tan+2,n_path
    dtaudn(i) = dtaudn(i-1) - incoptdepth(i-1)
  ENDDO
!
! compute the tau path derivative
!
  dtaudn = 0.5_rp*(EOSHIFT(dtaudn,1,dtaudn(n_path)) -             &
                   EOSHIFT(dtaudn,-1,dtaudn(1))) * EXP(dtaudn) *  &
           (/(1.0_rp,i=1,i_tan),(e_rflty,i=i_tan+1,n_path)/)
!
! find the indicies
!
  do_gl = .FALSE.
!
  WHERE(dtaudn < -tol/temp) do_gl = .TRUE.
!
! The first and last index must be false
!
  do_gl((/1,n_path/)) = .FALSE.
!
END SUBROUTINE path_contrib
!
!----------------------------------------------------------------------
d90 141
a230 35
!
SUBROUTINE rad_tran(frq,s_temp,e_rflty,z_path_c,t_path_c,alpha_path_c, &
                 &  ref_cor,do_gl,incoptdepth,alpha_path_gl,ds_dh_gl,  &
                 &  dh_dz_gl,t_script,tau,rad,i_stop)
!
! inputs
!
  REAL(r8), INTENT(in) :: frq ! calculation frequency in MHz.
  REAL(rp), INTENT(in) :: s_temp ! farside boundary temperature
!                                usually cosmic space (2.7K).
  REAL(rp), INTENT(in) :: e_rflty ! earth reflectivity value (0--1).
  REAL(rp), INTENT(in) :: z_path_c(:) ! path -log(P) on input grid.
  REAL(rp), INTENT(in) :: t_path_c(:) ! path T(K) on input grid.
  REAL(rp), INTENT(in) :: alpha_path_c(:) ! absorption coefficient
!                         on input grid.
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  LOGICAL, INTENT(in) :: do_gl(:) ! path flag indicating where to do
!                                   gl integrations.
  REAL(rp), INTENT(inout) :: incoptdepth(:) ! incremental path opacities
!                            from one-sided layer calculation on output.
!                            it is the full integrated layer opacity.
  REAL(rp), INTENT(in) ::  alpha_path_gl(:) ! absorption coefficient on gl
!                                        grid.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
! out puts
!
  REAL(rp), INTENT(out) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(out) :: tau(:) ! transmission function.
  REAL(rp), INTENT(out) :: rad    ! radiances (K)
  INTEGER(ip), INTENT(out) :: i_stop ! path stop index
!
d232 17
a248 5
!
  INTEGER(ip) :: i,j,k,p_i,no_to_gl,n_path
  REAL(rp), ALLOCATABLE :: gl_delta(:),del_zeta(:)
  INTEGER(ip), ALLOCATABLE :: all_inds(:),more_inds(:)
!
d250 102
a351 6
!
  Call two_d_t_script(t_path_c,s_temp,frq,t_script)
  n_path = SIZE(z_path_c)
  no_to_gl = COUNT(do_gl)
  IF(no_to_gl > 0) THEN
!
d353 61
a413 50
!
    ALLOCATE(all_inds(1:ng*no_to_gl))
    ALLOCATE(gl_delta(1:no_to_gl))
    ALLOCATE(del_zeta(1:no_to_gl))
    ALLOCATE(more_inds(1:no_to_gl))

    i = 1
    j = 1
    DO p_i = 1 , n_path
      IF(do_gl(p_i)) THEN
        more_inds(i) = p_i
        all_inds(j:j+ng-1) = j + (/(k-1,k=1,ng)/)
        IF(p_i > n_path/2) THEN
          del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
        ELSE
          del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
        ENDIF
        i = i + 1
        j = j + Ng
      ENDIF
    ENDDO
!
    Call path_opacity(del_zeta, &
              &  alpha_path_c(PACK((/(i,i=1,n_path)/),do_gl)), &
              &  alpha_path_gl(all_inds),ds_dh_gl(all_inds), &
              &  dh_dz_gl(all_inds),gl_delta)
    incoptdepth(more_inds) = incoptdepth(more_inds) + gl_delta

    DEALLOCATE(more_inds)
    DEALLOCATE(del_zeta)
    DEALLOCATE(gl_delta)
    DEALLOCATE(all_inds)
!
  ENDIF
!
  incoptdepth = ref_cor * incoptdepth
!
  Call scrt_dn(t_script,e_rflty,incoptdepth,tau,rad,i_stop)
!
END SUBROUTINE rad_tran
!
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt mixing ratio model
!
SUBROUTINE drad_tran_df(z_path_c,Grids_f, &
                     &  beta_path_c,eta_zxp_f_c,sps_path_c,do_calc_f_c, &
                     &  beta_path_f,eta_zxp_f_f,sps_path_f,do_calc_f_f, &
                     &  do_gl,del_s,ref_cor,ds_dh_gl,dh_dz_gl,t_script,tau, &
                     &  i_stop,drad_df,ptg_i,frq_i)
!
d415 33
a447 33
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! -log(P) on main grid.
  Type (Grids_T), INTENT(in) :: Grids_f ! All the coordinates
  REAL(rp), INTENT(in) :: beta_path_c(:,:) ! cross section for each species
!                                            on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                            main grid.
  REAL(rp), INTENT(in) :: sps_path_c(:,:) ! species function on  main grid.
  LOGICAL, INTENT(in) :: do_calc_f_c(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  REAL(rp), INTENT(in) :: beta_path_f(:,:) ! cross section for each species
!                                            on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                            gl grid.
  REAL(rp), INTENT(in) :: sps_path_f(:,:) ! species function on gl grid.
  LOGICAL, INTENT(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
d449 3
a451 4
!
  REAL(rp), INTENT(out) :: drad_df(:)    ! derivative of radiances wrt
!                                          mixing ratio statevector
!                                          element. (K)
d453 18
a470 10
!
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, no_mol
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid, n_tot
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_df(:),singularity(:),del_zeta(:),gl_delta(:)
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
a471 14
!
  no_mol = SIZE(Grids_f%no_z)
  n_path = SIZE(tau)
  mid = n_path / 2
!
  ALLOCATE(do_calc(1:n_path))
  ALLOCATE(d_delta_df(1:n_path))
!
  sv_i = 0
  drad_df(:) = 0.0_rp
!
  DO sps_i = 1 , no_mol
!
    n_tot = Grids_f%no_f(sps_i)*Grids_f%no_z(sps_i)*Grids_f%no_p(sps_i)
d473 23
a495 7
    DO sv_j = 1 , n_tot
!
      sv_i = sv_i + 1
!
! Skip the masked derivatives, accordiong to the l2cf inputs
!
      if(.NOT. Grids_f%deriv_flags(sv_i)) CYCLE
a496 10
      i = 1
      d_delta_df = 0.0_rp
      do_calc = do_calc_f_c(:,sv_i)
      DO p_i = 1 , n_path
        IF(do_gl(p_i)) THEN
          IF(ANY(do_calc_f_f(i:i+ng-1,sv_i))) do_calc(p_i) = .TRUE.
          i = i + Ng
        ENDIF
      ENDDO
!
a497 6
!
      n_inds = COUNT(do_calc)
      IF(n_inds > 0) THEN
!
        ALLOCATE(inds(1:n_inds))
        ALLOCATE(singularity(1:n_inds))
d499 21
a519 17
        i = 1
        DO p_i = 1 , n_path
          IF(do_calc(p_i)) THEN
            inds(i) = p_i
            i = i + 1
          ENDIF
        ENDDO
!
        IF(grids_f%lin_log(sps_i)) THEN
!
          singularity = beta_path_c(inds,sps_i)*eta_zxp_f_c(inds,sv_i) &
                     &  * sps_path_c(inds,sps_i)
          d_delta_df(inds) = singularity * del_s(inds)
!
          no_to_gl = COUNT(do_gl(inds))
          IF(no_to_gl > 0) THEN
!
d521 5
a525 5
!
            ALLOCATE(all_inds(1:ng*no_to_gl))
            ALLOCATE(gl_delta(1:no_to_gl))
            ALLOCATE(del_zeta(1:no_to_gl))
            ALLOCATE(more_inds(1:no_to_gl))
d530 3
a532 3
            DO p_i = 1 , n_path
              IF(do_gl(p_i)) THEN
                IF(do_calc(p_i)) THEN
d534 2
a535 2
                  all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                  IF(p_i > mid) THEN
d537 1
a537 1
                  ELSE
d539 1
a539 1
                  ENDIF
d542 1
a542 1
                ENDIF
d544 2
a545 2
              ENDIF
            ENDDO
d547 6
a552 11
            Call path_opacity(del_zeta, &
                 singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
                 beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) &
                 * sps_path_f(all_inds,sps_i),ds_dh_gl(all_inds), &
                 dh_dz_gl(all_inds),gl_delta)
            d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta

            DEALLOCATE(more_inds)
            DEALLOCATE(del_zeta)
            DEALLOCATE(gl_delta)
            DEALLOCATE(all_inds)
d554 12
a565 21
          ENDIF
!
          d_delta_df(inds) = ref_cor(inds)*d_delta_df(inds) &
                           / EXP(grids_f%values(sv_i))
!
        ELSE
!
          singularity = beta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)
          DO p_i = 1 , n_inds
            d_delta_df(inds(p_i)) = singularity(p_i) * del_s(inds(p_i))
          ENDDO
!
          no_to_gl = COUNT(do_gl(inds))
          IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
            ALLOCATE(all_inds(1:ng*no_to_gl))
            ALLOCATE(gl_delta(1:no_to_gl))
            ALLOCATE(del_zeta(1:no_to_gl))
            ALLOCATE(more_inds(1:no_to_gl))
d567 1
a567 19
            i = 1
            j = 1
            l = 1
            DO p_i = 1 , n_path
              IF(do_gl(p_i)) THEN
                IF(do_calc(p_i)) THEN
                  more_inds(i) = p_i
                  all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                  IF(p_i > mid) THEN
                    del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                  ELSE
                    del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                  ENDIF
                  i = i + 1
                  j = j + Ng
                ENDIF
                l = l + Ng
              ENDIF
            ENDDO
d569 3
a571 10
            Call path_opacity(del_zeta, &
                 singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
                 beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i), &
                 ds_dh_gl(all_inds),dh_dz_gl(all_inds),gl_delta)
            d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta

            DEALLOCATE(all_inds)
            DEALLOCATE(gl_delta)
            DEALLOCATE(del_zeta)
            DEALLOCATE(more_inds)
d573 7
a579 7
          ENDIF
!
          d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)
!
        ENDIF
!
        i_start = MIN(inds(1),i_stop)
d581 1
a581 2
        DEALLOCATE(inds)
        DEALLOCATE(singularity)
a582 24
        Call get_dscrt_no_t_dn(d_delta_df,t_script,tau,i_start,i_stop, &
                            &  drad_df(sv_i))
!
      ENDIF
!
    ENDDO
!
  ENDDO
!
  DEALLOCATE(do_calc)
  DEALLOCATE(d_delta_df)
!
END SUBROUTINE drad_tran_df
!
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )
!
SUBROUTINE drad_tran_dx(z_path_c,Grids_f,dbeta_path_c,eta_zxp_f_c, &
                     &  sps_path_c,do_calc_f_c,dbeta_path_f,eta_zxp_f_f, &
                     &  sps_path_f,do_calc_f_f,do_gl,del_s,ref_cor,      &
                     &  ds_dh_gl,dh_dz_gl,t_script,tau,i_stop,drad_dx,   &
                     &  ptg_i,frq_i)
!
d584 45
a628 33
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! -log(P) on main grid.
  Type (Grids_T) :: Grids_f           ! All the coordinates
  REAL(rp), INTENT(in) :: dbeta_path_c(:,:) ! derivative of beta wrt dx
!                                            on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                            main grid.
  REAL(rp), INTENT(in) :: sps_path_c(:,:) ! species function on  main grid.
  LOGICAL, INTENT(in) :: do_calc_f_c(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  REAL(rp), INTENT(in) :: dbeta_path_f(:,:) ! derivative of beta wrt dx
!                                            on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                            gl grid.
  REAL(rp), INTENT(in) :: sps_path_f(:,:) ! species function on gl grid.
  LOGICAL, INTENT(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
d630 4
a633 3
!
  REAL(rp), INTENT(out) :: drad_dx(:)    ! derivative of radiances wrt x
!                                          statevector element. (K)
d635 20
a654 10
!
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, no_mol
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_dx(:),singularity(:),del_zeta(:),gl_delta(:)
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
a655 10
!
  no_mol = SIZE(Grids_f%no_z)
  n_path = SIZE(tau)
  mid = n_path / 2
!
  ALLOCATE(d_delta_dx(1:n_path))
  ALLOCATE(do_calc(1:n_path))
!
  sv_i = 0
  drad_dx(:) = 0.0_rp
d657 19
a675 6
  DO sps_i = 1 , no_mol
!
    DO sv_j = 1 , Grids_f%no_z(sps_i) * Grids_f%no_p(sps_i)
!
      sv_i = sv_i + 1
      d_delta_dx = 0.0_rp
d677 1
a677 1
      do_calc = do_calc_f_c(:,sv_i)
d680 3
a682 3
      DO p_i = 1 , n_path
        IF(do_gl(p_i)) THEN
          IF(ANY(do_calc_f_f(i:i+Ng-1,sv_i))) do_calc(p_i) = .TRUE.
d684 3
a686 3
        ENDIF
      ENDDO
!
a687 6
!
      n_inds = COUNT(do_calc)
      IF(n_inds > 0) THEN
!
        ALLOCATE(inds(1:n_inds))
        ALLOCATE(singularity(1:n_inds))
d689 4
d694 2
a695 2
        DO p_i = 1 , n_path
          IF(do_calc(p_i)) THEN
d698 6
a703 18
          ENDIF
        ENDDO
!
        singularity = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i) * &
                   &  sps_path_c(inds,sps_i)
        DO p_i = 1 , n_inds
          d_delta_dx(inds(p_i)) = singularity(p_i) * del_s(inds(p_i))
        ENDDO
!
        no_to_gl = COUNT(do_gl(inds))
        IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
          ALLOCATE(all_inds(1:Ng*no_to_gl))
          ALLOCATE(gl_delta(1:no_to_gl))
          ALLOCATE(del_zeta(1:no_to_gl))
          ALLOCATE(more_inds(1:no_to_gl))
d705 2
a706 31
          i = 1
          j = 1
          l = 1
          DO p_i = 1 , n_path
            IF(do_gl(p_i)) THEN
              IF(do_calc(p_i)) THEN
                more_inds(i) = p_i
                all_inds(j:j+Ng-1) = l + (/(k-1,k=1,Ng)/)
                IF(p_i > mid) THEN
                  del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                ELSE
                  del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                ENDIF
                i = i + 1
                j = j + Ng
              ENDIF
              l = l + Ng
            ENDIF
          END DO

          Call path_opacity(del_zeta, &
              &  singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))),        &
              &  dbeta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) * &
              &  sps_path_f(all_inds,sps_i),ds_dh_gl(all_inds),            &
              &  dh_dz_gl(all_inds),gl_delta)
          d_delta_dx(more_inds) = d_delta_dx(more_inds) + gl_delta

          DEALLOCATE(more_inds)
          DEALLOCATE(del_zeta)
          DEALLOCATE(gl_delta)
          DEALLOCATE(all_inds)
d708 1
a708 5
        ENDIF
!
        d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)
!
        i_start = MIN(inds(1),i_stop)
d710 31
a740 2
        DEALLOCATE(singularity)
        DEALLOCATE(inds)
d742 1
a742 86
        Call get_dscrt_no_t_dn(d_delta_dx,t_script,tau,i_start,i_stop, &
                            &  drad_dx(sv_i))
!
      ENDIF
!
    ENDDO
!
  ENDDO
!
  DEALLOCATE(do_calc)
  DEALLOCATE(d_delta_dx)
!
END SUBROUTINE drad_tran_dx
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt temperature model
!
SUBROUTINE drad_tran_dt(z_path_c,h_path_c,t_path_c,dh_dt_path_c, &
                     &  alpha_path_c,alphaxn_path_c,eta_zxp_c,do_calc_t_c, &
                     &  do_calc_hyd_c,del_s,ref_cor,h_tan,dh_dt_tan, &
                     &  freq,do_gl,h_path_f,t_path_f,dh_dt_path_f, &
                     &  alpha_path_f,alphaxn_path_f,eta_zxp_f,do_calc_t_f, &
                     &  ds_dh_gl,dh_dz_gl,t_script,tau,i_stop,drad_dt,  &
                     &  ptg_i,frq_i)
!
! Inputs
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! path -log(P) on main grid.
  REAL(rp), INTENT(in) :: h_path_c(:) ! path heights + req on main grid km.
  REAL(rp), INTENT(in) :: t_path_c(:) ! path temperature(K) on main grid.
  REAL(rp), INTENT(in) :: dh_dt_path_c(:,:) ! derivative of path height wrt
!                                             temperature(km/K) on main grid.
  REAL(rp), INTENT(in) :: alpha_path_c(:) ! path absorption(km^-1)
!                                           on main grid.
  REAL(rp), INTENT(in) :: alphaxn_path_c(:) ! path absorption times
!                          temperature power(km^-1) on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_c(:,:) ! representation basis function
!                                            main grid.
  LOGICAL, INTENT(in) :: do_calc_t_c(:,:) ! A logical indicating where the
!                  representation basis function is not zero on main grid.
  LOGICAL, INTENT(in) :: do_calc_hyd_c(:,:) ! A logical indicating where the
!                  dh_dt function is not zero on main grid.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: h_tan ! tangent height + req (km).
  REAL(rp), INTENT(in) :: dh_dt_tan(:) ! derivative of path height wrt
!                                     temperature at the tangent (km/K).
  REAL(r8), INTENT(in) :: freq ! calculation frequency (MHz).
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations.
  REAL(rp), INTENT(in) :: h_path_f(:) ! path heights + req on gl grid km.
  REAL(rp), INTENT(in) :: t_path_f(:) ! path temperature(K) on gl grid.
  REAL(rp), INTENT(in) :: dh_dt_path_f(:,:) ! derivative of path height wrt
!                                             temperature(km/K) on gl grid.
  REAL(rp), INTENT(in) :: alpha_path_f(:) ! path absorption(km^-1) on gl grid.
  REAL(rp), INTENT(in) :: alphaxn_path_f(:) ! path absorption times
!                          temperature power(km^-1) on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f(:,:) ! representation basis function
!                                            gl grid.
  LOGICAL, INTENT(in) :: do_calc_t_f(:,:) ! A logical indicating where the
!                  representation basis function is not zero on gl grid.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
! Outputs
!
  REAL(rp), INTENT(out) :: drad_dt(:)    ! derivative of radiances wrt
!                                          mixing ratio statevector
!                                          element. (K)
! Internals
!
  INTEGER(ip) :: sv_i, sv_t, n_inds, i, j, k, l, i_start
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_dt(:),singularity(:)
  REAL(rp), ALLOCATABLE :: del_zeta(:),gl_delta(:),dt_scr_dt(:,:)
  REAL(rp) :: fa,fb
d744 1
a744 21
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
! Begin code
!
  n_path = SIZE(tau)
  sv_t = SIZE(eta_zxp_c,DIM=2)
  mid = n_path / 2
!
! allocate memory
!
  ALLOCATE(d_delta_dt(1:n_path))
  ALLOCATE(do_calc(1:n_path))
  ALLOCATE(dt_scr_dt(1:n_path,1:sv_t))
!
! compute the t_script derivative
!
  Call dt_script_dt(t_path_c,eta_zxp_c,freq,dt_scr_dt)
!
! compute the opacity derivative singularity value
!
  drad_dt(:) = 0.0_rp
d746 1
a746 9
  DO sv_i = 1 , sv_t
!
    i_start = 1
    d_delta_dt = 0.0_rp
!
! do the absorption part
! combine non zeros flags for both the main and gl parts
!
    do_calc = do_calc_t_c(:,sv_i)
a747 77
    i = 1
    DO p_i = 1 , n_path
      IF(do_gl(p_i)) THEN
        IF(ANY(do_calc_t_f(i:i+ng-1,sv_i))) do_calc(p_i) = .TRUE.
        i = i + Ng
      ENDIF
    ENDDO
!
! find where the non zeros are along the path
!
    n_inds = COUNT(do_calc)
    IF(n_inds > 0) THEN
      ALLOCATE(inds(1:n_inds))
      ALLOCATE(singularity(1:n_inds))
      i = 1
      DO p_i = 1 , n_path
        IF(do_calc(p_i)) THEN
          inds(i) = p_i
          i = i + 1
        ENDIF
      ENDDO
!
      singularity = alphaxn_path_c(inds)*eta_zxp_c(inds,sv_i) &
                  / t_path_c(inds)
      d_delta_dt(inds) = singularity * del_s(inds)
!
      no_to_gl = COUNT(do_gl(inds))
      IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
         ALLOCATE(all_inds(1:ng*no_to_gl))
         ALLOCATE(gl_delta(1:no_to_gl))
         ALLOCATE(del_zeta(1:no_to_gl))
         ALLOCATE(more_inds(1:no_to_gl))

         i = 1
         j = 1
         l = 1
         DO p_i = 1 , n_path
           IF(do_gl(p_i)) THEN
             IF(do_calc(p_i)) THEN
               more_inds(i) = p_i
               all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
               IF(p_i > mid) THEN
                 del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
               ELSE
                 del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
               ENDIF
               i = i + 1
               j = j + Ng
             ENDIF
             l = l + Ng
           ENDIF
         ENDDO
!
         Call path_opacity(del_zeta, &
           &  singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
           &  alphaxn_path_f(all_inds)*eta_zxp_f(all_inds,sv_i) &
           &  / t_path_f(all_inds),ds_dh_gl(all_inds),dh_dz_gl(all_inds), &
           &  gl_delta)
         d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
!
         DEALLOCATE(more_inds)
         DEALLOCATE(del_zeta)
         DEALLOCATE(gl_delta)
         DEALLOCATE(all_inds)
!
      ENDIF
!
      i_start = MAX(inds(1)-1,1)
!
      DEALLOCATE(singularity)
      DEALLOCATE(inds)
!
    ENDIF
!
d750 17
a766 17
!
    do_calc = do_calc_hyd_c(:,sv_i)
    IF(do_calc_hyd_c(mid,sv_i)) THEN
      do_calc(2:mid) = .TRUE.
    ELSE
      DO p_i = 2 , mid
        IF(do_calc_hyd_c(p_i-1,sv_i)) do_calc(p_i) = .TRUE.
      ENDDO
    ENDIF
    IF(do_calc_hyd_c(mid+1,sv_i)) THEN
      do_calc(mid+1:n_path-1) = .TRUE.
    ELSE
      DO p_i = mid + 1 , n_path - 1
        IF(do_calc_hyd_c(p_i+1,sv_i)) do_calc(p_i) = .TRUE.
      ENDDO
    ENDIF
!
d768 3
a770 3
!
    do_calc((/1,n_path/)) = .FALSE.
!
d772 19
a790 19
!
    n_inds = COUNT(do_calc)
    IF(n_inds > 0) THEN
      ALLOCATE(inds(1:n_inds))
      i = 1
      inds = 0
      DO p_i = 2 , mid - 1
        IF(do_calc(p_i)) THEN
          IF(i == 1) fa = (h_path_c(p_i-1)*dh_dt_path_c(p_i-1,sv_i) &
                        - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(p_i:mid))
          fb = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
             - h_tan * dh_dt_tan(sv_i)) /SUM(del_s(p_i+1:mid))
          inds(i) = p_i
          d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fa - fb)
          fa = fb
          i = i + 1
        ENDIF
      ENDDO
!
d792 4
a795 4
!
      IF(do_calc(mid)) THEN
        d_delta_dt(mid) = d_delta_dt(mid) + alpha_path_c(mid) * fa
!
d797 10
a806 10
!
        inds(i) = mid
        i = i + 1
      ENDIF
!
      IF(do_calc(mid+1)) THEN
        fa = (h_path_c(mid+2)*dh_dt_path_c(mid+2,sv_i) - &
            & h_tan * dh_dt_tan(sv_i))/ del_s(mid+1)
        d_delta_dt(mid+1) = d_delta_dt(mid+1) + alpha_path_c(mid+1) * fa
!
d808 2
a809 15
!
        inds(i) = mid+1
        i = i + 1
      ENDIF
!
      DO p_i = mid + 2 , n_path - 1
        IF(do_calc(p_i)) THEN
          IF(inds(MAX(i-1,1)) < mid+1)  &
                     & fa = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
                     &    - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(mid+1:p_i-1))
          fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1,sv_i) &
             - h_tan * dh_dt_tan(sv_i)) /SUM(del_s(mid+1:p_i))
          inds(i) = p_i
          d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fb - fa)
          fa = fb
d811 19
a829 6
        ENDIF
      ENDDO
!
      no_to_gl = COUNT(do_gl(inds))
      IF(no_to_gl > 0) THEN
!
d831 26
a856 26
!
         ALLOCATE(all_inds(1:ng*no_to_gl))
         ALLOCATE(gl_delta(1:no_to_gl))
         ALLOCATE(del_zeta(1:no_to_gl))
         ALLOCATE(more_inds(1:no_to_gl))

         i = 1
         j = 1
         l = 1
         DO p_i = 1 , n_path
           IF(do_gl(p_i)) THEN
             IF(do_calc(p_i)) THEN
               more_inds(i) = p_i
               all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
               IF(p_i > mid) THEN
                 del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
               ELSE
                 del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
               ENDIF
               i = i + 1
               j = j + Ng
             ENDIF
             l = l + Ng
           ENDIF
         ENDDO
!
a858 6
!
         Call hyd_opacity(del_zeta,alpha_path_c(more_inds),                &
            & alpha_path_f(all_inds),h_path_f(all_inds),                   &
            & dh_dt_path_f(all_inds,sv_i),t_path_f(all_inds),h_tan,        &
            & dh_dt_tan(sv_i),eta_zxp_f(all_inds,sv_i),ds_dh_gl(all_inds), &
            & dh_dz_gl(all_inds),gl_delta)
d860 14
a873 15
         d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
!
         DEALLOCATE(more_inds)
         DEALLOCATE(del_zeta)
         DEALLOCATE(gl_delta)
         DEALLOCATE(all_inds)
!
      ENDIF
!
      i_start = MIN(i_start,inds(1))
!
      DEALLOCATE(inds)
!
    ENDIF
!
d875 9
a883 13
!
    d_delta_dt = ref_cor * d_delta_dt
    Call get_dscrt_dn(d_delta_dt,t_script,tau,dt_scr_dt(:,sv_i),i_start, &
                   &  i_stop,drad_dt(sv_i))
!
  ENDDO
!
  DEALLOCATE(d_delta_dt)
  DEALLOCATE(do_calc)
  DEALLOCATE(dt_scr_dt)
!
END SUBROUTINE drad_tran_dt
!
d885 1
a885 1
End module RAD_TRAN_M
d887 3
@


2.5
log
@some variable name changes--wgr
@
text
@d15 1
a15 1
       "$Id: rad_tran_m.f90,v 2.4 2002/06/04 10:28:04 zvi Exp $"
d129 1
a129 1
  CALL two_d_t_script(t_path_c,s_temp,frq,t_script)
d157 1
a157 1
    CALL path_opacity(del_zeta, &
d172 1
a172 1
  CALL scrt_dn(t_script,e_rflty,incoptdepth,tau,rad,i_stop)
d321 1
a321 1
            CALL path_opacity(del_zeta, &
d375 1
a375 1
            CALL path_opacity(del_zeta, &
d397 1
a397 1
        CALL get_dscrt_no_t_dn(d_delta_df,t_script,tau,i_start,i_stop, &
d551 1
a551 1
          CALL path_opacity(del_zeta, &
d572 1
a572 1
        CALL get_dscrt_no_t_dn(d_delta_dx,t_script,tau,i_start,i_stop, &
d675 1
a675 1
  CALL dt_script_dt(t_path_c,eta_zxp_c,freq,dt_scr_dt)
d747 1
a747 1
         CALL path_opacity(del_zeta, &
d823 2
a824 2
        fa = (h_path_c(mid+2)*dh_dt_path_c(mid+2,sv_i) &
           - h_tan * dh_dt_tan(sv_i))/ del_s(mid+1)
d880 6
a885 5
         CALL hyd_opacity(del_zeta,alpha_path_c(more_inds), &
              alpha_path_f(all_inds),h_path_f(all_inds), &
              dh_dt_path_f(all_inds,sv_i),t_path_f(all_inds),h_tan, &
              dh_dt_tan(sv_i),eta_zxp_f(all_inds,sv_i),ds_dh_gl(all_inds), &
              dh_dz_gl(all_inds),gl_delta)
d904 1
a904 1
    CALL get_dscrt_dn(d_delta_dt,t_script,tau,dt_scr_dt(:,sv_i),i_start, &
d918 3
@


2.4
log
@rename n_sps to: no_mol, more correctly
@
text
@d15 1
a15 1
       "$Id: rad_tran_m.f90,v 2.3 2002/02/16 06:38:05 zvi Exp $"
d179 1
a179 1
SUBROUTINE drad_tran_df(z_path_c,Grids_f,lin_log,sps_values,            &
d188 1
a188 3
  Type (Grids_T) :: Grids_f           ! All the coordinates
  LOGICAL, INTENT(in) :: lin_log(:) ! kind of basis to use for each species.
  REAL(rp), INTENT(in) :: sps_values(:) ! sps basis break-point values.
d285 1
a285 1
        IF(lin_log(sps_i)) THEN
d336 1
a336 1
                           / EXP(sps_values(sv_i))
d917 3
@


2.3
log
@Some cosmetic changes..
@
text
@d15 1
a15 1
       "$Id: rad_tran_m.f90,v 2.2 2002/01/30 01:11:22 zvi Exp $"
d228 1
a228 1
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, n_sps
d239 1
a239 1
  n_sps = SIZE(Grids_f%no_z)
d249 1
a249 1
  DO sps_i = 1 , n_sps
d252 1
d256 3
d463 1
a463 1
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, n_sps
d474 1
a474 1
  n_sps = SIZE(Grids_f%no_z)
d484 1
a484 1
  DO sps_i = 1 , n_sps
d919 3
@


2.2
log
@Fix bug in user selectable coeff. code
@
text
@d4 1
a4 1
  USE GLNP, ONLY: NG
d15 1
a15 1
       "$Id: rad_tran_m.f90,v 2.1 2002/01/27 08:37:51 zvi Exp $"
d74 1
a74 1
  do_gl = .false.
d76 1
a76 1
  WHERE(dtaudn < -tol/temp) do_gl = .true.
d153 1
a153 1
        j = j + ng
d262 2
a263 2
          IF(ANY(do_calc_f_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
          i = i + ng
d313 1
a313 1
                  j = j + ng
d315 1
a315 1
                l = l + ng
d367 1
a367 1
                  j = j + ng
d369 1
a369 1
                l = l + ng
d492 1
a492 1
          IF(ANY(do_calc_f_f(i:i+Ng-1,sv_i))) do_calc(p_i) = .true.
d692 2
a693 2
        IF(ANY(do_calc_t_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
        i = i + ng
d739 1
a739 1
               j = j + ng
d741 1
a741 1
             l = l + ng
d771 1
a771 1
      do_calc(2:mid) = .true.
d774 1
a774 1
        IF(do_calc_hyd_c(p_i-1,sv_i)) do_calc(p_i) = .true.
d778 1
a778 1
      do_calc(mid+1:n_path-1) = .true.
d781 1
a781 1
        IF(do_calc_hyd_c(p_i+1,sv_i)) do_calc(p_i) = .true.
d787 1
a787 1
    do_calc((/1,n_path/)) = .false.
d869 1
a869 1
               j = j + ng
d871 1
a871 1
             l = l + ng
d915 3
@


2.1
log
@Adding Users selected coefficients for derivatives
@
text
@d15 1
a15 1
       "$Id: rad_tran_m.f90,v 2.0 2001/09/17 20:26:27 livesey Exp $"
d243 1
d245 1
a245 2
  ALLOCATE(do_calc(1:n_path))

d251 1
a251 1
    n_tot = Grids_f%no_f(sps_i)*Grids_f%no_p(sps_i)*Grids_f%no_p(sps_i)
d915 3
@


2.0
log
@New forward model
@
text
@a0 1
!
d9 1
d15 1
a15 1
       "$Id: rad_tran_m.f90,v 1.11.2.3 2001/09/13 22:51:24 zvi Exp $"
d179 1
a179 1
SUBROUTINE drad_tran_df(z_path_c,no_z_f,no_p_f,lin_log,sps_values, &
d188 1
a188 2
  INTEGER(ip), INTENT(in) :: no_z_f(:) ! number zeta bases for each species.
  INTEGER(ip), INTENT(in) :: no_p_f(:) ! number phi bases for each species.
d229 1
a229 1
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
d239 1
a239 1
  n_sps = SIZE(no_z_f)
d245 3
a248 1
  sv_i = 0
d251 2
a252 1
    DO sv_j = 1 , no_z_f(sps_i) * no_p_f(sps_i)
d255 3
a258 2
      drad_df(sv_i) = 0.0_rp

a259 1
      i = 1
d285 2
a286 2
          singularity = beta_path_c(inds,sps_i)*eta_zxp_f_c(inds,sv_i)* &
                     &  sps_path_c(inds,sps_i)
a335 1
!
d404 1
a405 1
  DEALLOCATE(do_calc)
d413 1
a413 1
SUBROUTINE drad_tran_dx(z_path_c,no_z_f,no_p_f,dbeta_path_c,eta_zxp_f_c, &
d422 1
a422 2
  INTEGER(ip), INTENT(in) :: no_z_f(:) ! number zeta bases for each species.
  INTEGER(ip), INTENT(in) :: no_p_f(:) ! number phi bases for each species.
d470 1
a470 1
  n_sps = SIZE(no_z_f)
d478 2
d482 1
a482 1
    DO sv_j = 1 , no_z_f(sps_i) * no_p_f(sps_i)
a485 1
      drad_dx(sv_i) = 0.0_rp
d488 1
d677 2
a682 1
    drad_dt(sv_i) = 0.0_rp
d688 1
d915 3
@


1.11
log
@Modified & new code(s) for better timing
@
text
@d1 1
a1 3
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

d3 7
a9 8
  use GLNP, only: NG
  use MLSCommon, only: I4, R8
  use EARTH_INTERSECTION_M, only: EARTH_INTERSECTION
  use ELLIPSE_M, only: ELLIPSE
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA
  use DO_T_SCRIPT_M, only: DO_T_SCRIPT
  use FAST_DELTA_ZOPACITY_M, only: FAST_DELTA_ZOPACITY
  use SCRT_DN_M, only: SCRT_DN
d12 1
a12 1
  public :: RAD_TRAN
d15 1
a15 1
       "$Id: rad_tran_m.f90,v 1.10 2001/06/21 13:07:09 zvi Exp $"
d21 64
a85 5

  Subroutine Rad_Tran(elvar,Frq,N_lvls,h_tan,n_sps,z_path,h_path,t_path, &
    &        dHdz_path,earth_ref,beta_path,spsfunc_path,ref_corr, &
    &        s_temp,brkpt,no_ele,mid,ilo,ihi,t_script,tau,midval_ndx,  &
    &        no_midval_ndx,gl_ndx,no_gl_ndx,midval_delta,Rad,Ier)
d87 91
a177 21
    Integer(i4), intent(in) :: N_LVLS, N_SPS, BRKPT, NO_ELE
    Integer(i4), intent(in) :: gl_ndx(:,:),midval_ndx(:,:)
    Integer(i4), intent(in) :: no_midval_ndx,no_gl_ndx

    Integer(i4), intent(out) :: MID, ILO, IHI, IER

    Real(r8), intent(in) :: FRQ, H_TAN, EARTH_REF, S_TEMP

    Real(r8), intent(in) :: REF_CORR(:)
    Real(r8), intent(in) :: midval_delta(:,:)   ! N2lvl,n_sps

    Type(ELLIPSE), intent(in out) :: elvar

    Type(path_beta), intent(in) :: BETA_PATH(:)   ! (Nsps)

    Type(path_vector), intent(in) :: Z_PATH,T_PATH,H_PATH,DHDZ_PATH

    Type(path_vector), intent(in) :: SPSFUNC_PATH(:)

    Real(r8), intent(out) :: RAD
    Real(r8), intent(out) :: T_SCRIPT(:), TAU(:)
d179 219
a397 4
    Integer(i4) :: Ngp1

    Real(r8) :: CSE, RS
    Real(r8) :: del_opacity(Size(tau))
d399 1
a399 19
! 'brkpt' is the index of the path break-point (when it change from
!         incoming ray to outgoing ray)
! 'no_ele' is the total number of entries in ?_path%values(1...no_ele)

    Ngp1 = Ng + 1
    elvar%EarthX = .false.
    elvar%ht = h_tan
    elvar%Rr = elvar%ht + elvar%RoC
    elvar%ht2 = elvar%Rr * elvar%Rr
    if (h_tan < -0.01) then
      elvar%Rr = elvar%Rr / elvar%RoC
      cse = earth_ref
      Call Earth_Intersection(elvar,Rs)
    else
      cse = 1.0
      elvar%Rr = 0.0d0
      elvar%Phi_s = elvar%Phi_tan
      elvar%NPhi_s = elvar%NPhi_tan
    end if
d401 1
a401 2
!  Compute the appropriate t_script & dt_scrpt_dnp along the integration
!  path of this tanget:
d403 2
a404 2
    CALL do_t_script(Ngp1, Frq, s_temp, brkpt, no_ele, t_path, &
   &                 mid, t_script)
d406 1
a406 1
! Initialize the tau & del_opacity arrays:
d408 3
a410 2
    tau(1:) = 0.0
    del_opacity(1:) = 0.0
d412 160
a571 5
    Call FAST_DELTA_ZOPACITY(mid,brkpt,no_ele,z_path,h_path,     &
 &       beta_path,dHdz_path,spsfunc_path,n_sps,N_lvls,ref_corr, &
 &       elvar,midval_ndx,no_midval_ndx,gl_ndx,no_gl_ndx,        &
 &       midval_delta,del_opacity,Ier)
    if (Ier /= 0) Return
d573 1
a573 2
    Call Scrt_dn(t_script, N_lvls, cse, del_opacity, tau, Rad, mid, &
   &             ilo, ihi)
d575 1
a575 7
    Return
  End Subroutine RAD_TRAN

end module RAD_TRAN_M
! $Log: rad_tran_m.f90,v $
! Revision 1.10  2001/06/21 13:07:09  zvi
! Speed enhancement MAJOR update
d577 2
a578 2
! Revision 1.9  2001/06/07 23:39:31  pwagner
! Added Copyright statement
d580 3
a582 2
! Revision 1.8  2001/04/09 23:33:41  zvi
! Initialize error flag
d584 321
a904 2
! Revision 1.7  2001/04/09 20:52:07  zvi
! Debugging Derivatives version
d906 1
a906 2
! Revision 1.6  2001/03/31 23:40:55  zvi
! Eliminate l2pcdim (dimension parameters) move to allocatable ..
d908 5
a912 2
! Revision 1.5  2001/03/30 20:28:21  zvi
! General fix-up to get rid of COMMON BLOCK (ELLIPSE)
d914 2
a915 2
! Revision 1.4  2001/03/29 08:51:01  zvi
! Changing the (*) toi (:) everywhere
d917 2
a918 2
! Revision 1.3  2001/02/26 09:01:16  zvi
! New version - Using "Super-Structures"
@


1.11.2.1
log
@Cleanup..comp_path_entities_m.f90
@
text
@d1 3
a3 1
!
d5 8
a12 6
!
  use MLSCommon, only: R8, RP, IP
  USE GLNP, ONLY: NG
  USE DO_T_SCRIPT_M, ONLY: TWO_D_T_SCRIPT
  USE DO_DELTA_M, ONLY: PATH_OPACITY,HYD_OPACITY
  USE SCRT_DN_M, ONLY: SCRT_DN, GET_DSCRT_NO_T_DN, GET_DSCRT_DN
d15 1
a15 1
  PUBLIC :: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF,DRAD_TRAN_DT,DRAD_TRAN_DX
d18 1
a18 1
       "$Id: rad_tran_m.f90,v 1.1 2000/08/30 18:12:05 Z.Shippony Exp $"
d24 14
a37 2
! This routine computes the contributions (along the path) of each interval
! of the (coarse) pre-selected integration grid
d39 13
a51 2
SUBROUTINE path_contrib(alpha_path,del_s,e_rflty,tol,dtaudn, &
                    &   incoptdepth,do_gl)
d53 4
a56 1
! inputs
d58 36
a93 5
  REAL(rp), INTENT(in) :: alpha_path(:) ! absorption coefficient along the
!                                         path
  REAL(rp), INTENT(in) :: del_s(:)       ! path lengths
  REAL(rp), INTENT(in) :: tol            ! accuracy target in K
  REAL(rp), INTENT(in) :: e_rflty        ! earth reflectivity
d95 2
a96 1
! outputs
d98 7
a104 34
  REAL(rp), INTENT(out) :: dtaudn(:) ! path derivative of the transmission
!                                    function
  REAL(rp), INTENT(out) :: incoptdepth(:) ! layer optical depth
  LOGICAL(ip), INTENT(out) :: do_gl(:) ! set true for indicies to do
!                                         gl computation
! Internal stuff
!
  INTEGER(ip) :: i, i_tan, n_path
  REAL(rp), PARAMETER :: temp = 250.0_rp
!
! start code
! compute the incoptdepth
!
  n_path = SIZE(alpha_path)
  i_tan = n_path / 2
!
  incoptdepth = alpha_path * del_s
!
  dtaudn(1) = 0.0_rp
  DO i = 2 , i_tan
    dtaudn(i) = dtaudn(i-1) - incoptdepth(i)
  ENDDO
!
  dtaudn(i_tan+1) = dtaudn(i_tan)
!
  DO i = i_tan+2,n_path
    dtaudn(i) = dtaudn(i-1) - incoptdepth(i-1)
  ENDDO
!
! compute the tau path derivative
!
  dtaudn = 0.5_rp*(EOSHIFT(dtaudn,1,dtaudn(n_path)) -             &
                   EOSHIFT(dtaudn,-1,dtaudn(1))) * EXP(dtaudn) *  &
           (/(1.0_rp,i=1,i_tan),(e_rflty,i=i_tan+1,n_path)/)
d106 2
a107 1
! find the indicies
d109 2
a110 1
  do_gl = .false.
d112 2
a113 1
  WHERE(dtaudn < -tol/temp) do_gl = .true.
d115 2
a116 1
! The first and last index must be false
d118 2
a119 1
  do_gl((/1,n_path/)) = .FALSE.
d121 2
a122 1
END SUBROUTINE path_contrib
d124 2
a125 289
!----------------------------------------------------------------------
! This is the radiative transfer model, radiances only !
!
SUBROUTINE rad_tran(frq,s_temp,e_rflty,z_path_c,t_path_c,alpha_path_c, &
                 &  ref_cor,do_gl,incoptdepth,alpha_path_gl,ds_dh_gl,  &
                 &  dh_dz_gl,t_script,tau,rad,i_stop)
!
! inputs
!
  REAL(r8), INTENT(in) :: frq ! calculation frequency in MHz.
  REAL(rp), INTENT(in) :: s_temp ! farside boundary temperature
!                                usually cosmic space (2.7K).
  REAL(rp), INTENT(in) :: e_rflty ! earth reflectivity value (0--1).
  REAL(rp), INTENT(in) :: z_path_c(:) ! path -log(P) on input grid.
  REAL(rp), INTENT(in) :: t_path_c(:) ! path T(K) on input grid.
  REAL(rp), INTENT(in) :: alpha_path_c(:) ! absorption coefficient
!                         on input grid.
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  LOGICAL, INTENT(in) :: do_gl(:) ! path flag indicating where to do
!                                   gl integrations.
  REAL(rp), INTENT(inout) :: incoptdepth(:) ! incremental path opacities
!                            from one-sided layer calculation on output.
!                            it is the full integrated layer opacity.
  REAL(rp), INTENT(in) ::  alpha_path_gl(:) ! absorption coefficient on gl
!                                        grid.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
! out puts
!
  REAL(rp), INTENT(out) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(out) :: tau(:) ! transmission function.
  REAL(rp), INTENT(out) :: rad    ! radiances (K)
  INTEGER(ip), INTENT(out) :: i_stop ! path stop index
!
! Internals
!
  INTEGER(ip) :: i,j,k,p_i,no_to_gl,n_path
  REAL(rp), ALLOCATABLE :: gl_delta(:),del_zeta(:)
  INTEGER(ip), ALLOCATABLE :: all_inds(:),more_inds(:)
!
! Begin code
!
  CALL two_d_t_script(t_path_c,s_temp,frq,t_script)
  n_path = SIZE(z_path_c)
  no_to_gl = COUNT(do_gl)
  IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
    ALLOCATE(all_inds(1:ng*no_to_gl),gl_delta(1:no_to_gl), &
             del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
    i = 1
    j = 1
    DO p_i = 1 , n_path
      IF(do_gl(p_i)) THEN
        more_inds(i) = p_i
        all_inds(j:j+ng-1) = j + (/(k-1,k=1,ng)/)
        IF(p_i > n_path/2) THEN
          del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
        ELSE
          del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
        ENDIF
        i = i + 1
        j = j + ng
      ENDIF
    ENDDO
!
    CALL path_opacity(del_zeta, &
              &  alpha_path_c(PACK((/(i,i=1,n_path)/),do_gl)), &
              &  alpha_path_gl(all_inds),ds_dh_gl(all_inds), &
              &  dh_dz_gl(all_inds),gl_delta)
    incoptdepth(more_inds) = incoptdepth(more_inds) + gl_delta
    DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
!
  ENDIF
!
  incoptdepth = ref_cor * incoptdepth
!
  CALL scrt_dn(t_script,e_rflty,incoptdepth,tau,rad,i_stop)
!
END SUBROUTINE rad_tran
!
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt mixing ratio model
!
SUBROUTINE drad_tran_df(z_path_c,no_z_f,no_p_f,lin_log,sps_values, &
                     &  beta_path_c,eta_zxp_f_c,sps_path_c,do_calc_f_c, &
                     &  beta_path_f,eta_zxp_f_f,sps_path_f,do_calc_f_f, &
                     &  do_gl,del_s,ref_cor,ds_dh_gl,dh_dz_gl,t_script,tau, &
                     &  i_stop,drad_df,ptg_i,frq_i)
!
! Inputs
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! -log(P) on main grid.
  INTEGER(ip), INTENT(in) :: no_z_f(:) ! number zeta bases for each species.
  INTEGER(ip), INTENT(in) :: no_p_f(:) ! number phi bases for each species.
  LOGICAL, INTENT(in) :: lin_log(:) ! kind of basis to use for each species.
  REAL(rp), INTENT(in) :: sps_values(:) ! sps basis break-point values.
  REAL(rp), INTENT(in) :: beta_path_c(:,:) ! cross section for each species
!                                            on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                            main grid.
  REAL(rp), INTENT(in) :: sps_path_c(:,:) ! species function on  main grid.
  LOGICAL, INTENT(in) :: do_calc_f_c(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  REAL(rp), INTENT(in) :: beta_path_f(:,:) ! cross section for each species
!                                            on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                            gl grid.
  REAL(rp), INTENT(in) :: sps_path_f(:,:) ! species function on gl grid.
  LOGICAL, INTENT(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
! Outputs
!
  REAL(rp), INTENT(out) :: drad_df(:)    ! derivative of radiances wrt
!                                          mixing ratio statevector
!                                          element. (K)
! Internals
!
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, n_sps
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_df(:),singularity(:),del_zeta(:),gl_delta(:)
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
! Begin code
!
  n_sps = SIZE(no_z_f)
  n_path = SIZE(tau)
  mid = n_path / 2
!
  ALLOCATE(d_delta_df(1:n_path),do_calc(1:n_path))
!
  sv_i = 0
  DO sps_i = 1 , n_sps
!
    DO sv_j = 1 , no_z_f(sps_i) * no_p_f(sps_i)
!
      sv_i = sv_i + 1
      d_delta_df = 0.0_rp
      drad_df(sv_i) = 0.0_rp

      do_calc = do_calc_f_c(:,sv_i)
      i = 1
      DO p_i = 1 , n_path
        IF(do_gl(p_i)) THEN
          IF(ANY(do_calc_f_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
          i = i + ng
        ENDIF
      ENDDO
!
! find where the non zeros are along the path
!
      n_inds = COUNT(do_calc)
      IF(n_inds > 0) THEN
!
        ALLOCATE(inds(1:n_inds),singularity(1:n_inds))
        i = 1
        DO p_i = 1 , n_path
          IF(do_calc(p_i)) THEN
            inds(i) = p_i
            i = i + 1
          ENDIF
        ENDDO
!
        IF(lin_log(sps_i)) THEN
!
          singularity = beta_path_c(inds,sps_i)*eta_zxp_f_c(inds,sv_i)* &
                     &  sps_path_c(inds,sps_i)
          d_delta_df(inds) = singularity * del_s(inds)
!
          no_to_gl = COUNT(do_gl(inds))
          IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
            ALLOCATE(all_inds(1:ng*no_to_gl),gl_delta(1:no_to_gl), &
                     del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
            i = 1
            j = 1
            l = 1
            DO p_i = 1 , n_path
              IF(do_gl(p_i)) THEN
                IF(do_calc(p_i)) THEN
                  more_inds(i) = p_i
                  all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                  IF(p_i > mid) THEN
                    del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                  ELSE
                    del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                  ENDIF
                  i = i + 1
                  j = j + ng
                ENDIF
                l = l + ng
              ENDIF
            ENDDO
            CALL path_opacity(del_zeta, &
                 singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
                 beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) &
                 * sps_path_f(all_inds,sps_i),ds_dh_gl(all_inds), &
                 dh_dz_gl(all_inds),gl_delta)
            d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta
            DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
          ENDIF
!
          d_delta_df(inds) = ref_cor(inds)*d_delta_df(inds) &
                           / EXP(sps_values(sv_i))
!
!
        ELSE
!
          singularity = beta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i)
          DO p_i = 1 , n_inds
            d_delta_df(inds(p_i)) = singularity(p_i) * del_s(inds(p_i))
          ENDDO
!
          no_to_gl = COUNT(do_gl(inds))
          IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
            ALLOCATE(all_inds(1:ng*no_to_gl),gl_delta(1:no_to_gl), &
                     del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
            i = 1
            j = 1
            l = 1
            DO p_i = 1 , n_path
              IF(do_gl(p_i)) THEN
                IF(do_calc(p_i)) THEN
                  more_inds(i) = p_i
                  all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
                  IF(p_i > mid) THEN
                    del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                  ELSE
                    del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                  ENDIF
                  i = i + 1
                  j = j + ng
                ENDIF
                l = l + ng
              ENDIF
            ENDDO
            CALL path_opacity(del_zeta, &
                 singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
                 beta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i), &
                 ds_dh_gl(all_inds),dh_dz_gl(all_inds),gl_delta)
            d_delta_df(more_inds) = d_delta_df(more_inds) + gl_delta
            DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
          ENDIF
!
          d_delta_df(inds) = ref_cor(inds) * d_delta_df(inds)
!
        ENDIF
!
        i_start = MIN(inds(1),i_stop)
        DEALLOCATE(inds,singularity)
        CALL get_dscrt_no_t_dn(d_delta_df,t_script,tau,i_start,i_stop, &
                            &  drad_df(sv_i))
!
      ENDIF
!
    ENDDO
!
  ENDDO
!
  DEALLOCATE(d_delta_df,do_calc)
a126 430
END SUBROUTINE drad_tran_df
!
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt spectroscopy model
!  (Here dx could be: dw, dn or dv (dNu0) )
!
SUBROUTINE drad_tran_dx(z_path_c,no_z_f,no_p_f,dbeta_path_c,eta_zxp_f_c, &
                     &  sps_path_c,do_calc_f_c,dbeta_path_f,eta_zxp_f_f, &
                     &  sps_path_f,do_calc_f_f,do_gl,del_s,ref_cor,      &
                     &  ds_dh_gl,dh_dz_gl,t_script,tau,i_stop,drad_dx,   &
                     &  ptg_i,frq_i)
!
! Inputs
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! -log(P) on main grid.
  INTEGER(ip), INTENT(in) :: no_z_f(:) ! number zeta bases for each species.
  INTEGER(ip), INTENT(in) :: no_p_f(:) ! number phi bases for each species.
  REAL(rp), INTENT(in) :: dbeta_path_c(:,:) ! derivative of beta wrt dx
!                                            on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_c(:,:) ! representation basis function
!                                            main grid.
  REAL(rp), INTENT(in) :: sps_path_c(:,:) ! species function on  main grid.
  LOGICAL, INTENT(in) :: do_calc_f_c(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  REAL(rp), INTENT(in) :: dbeta_path_f(:,:) ! derivative of beta wrt dx
!                                            on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f_f(:,:) ! representation basis function
!                                            gl grid.
  REAL(rp), INTENT(in) :: sps_path_f(:,:) ! species function on gl grid.
  LOGICAL, INTENT(in) :: do_calc_f_f(:,:) ! A logical indicating where the
!                                         representation basis function is
!                                         not zero on main grid.
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
! Outputs
!
  REAL(rp), INTENT(out) :: drad_dx(:)    ! derivative of radiances wrt x
!                                          statevector element. (K)
! Internals
!
  INTEGER(ip) :: sv_i, sv_j, sps_i, n_inds, i, j, k, l, i_start, n_sps
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_dx(:),singularity(:),del_zeta(:),gl_delta(:)
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
! Begin code
!
  n_sps = SIZE(no_z_f)
  n_path = SIZE(tau)
  mid = n_path / 2
!
  ALLOCATE(d_delta_dx(1:n_path),do_calc(1:n_path))
!
  sv_i = 0
  DO sps_i = 1 , n_sps
!
    DO sv_j = 1 , no_z_f(sps_i) * no_p_f(sps_i)
!
      sv_i = sv_i + 1
      d_delta_dx = 0.0_rp
      drad_dx(sv_i) = 0.0_rp

      do_calc = do_calc_f_c(:,sv_i)
      i = 1
      DO p_i = 1 , n_path
        IF(do_gl(p_i)) THEN
          IF(ANY(do_calc_f_f(i:i+Ng-1,sv_i))) do_calc(p_i) = .true.
          i = i + Ng
        ENDIF
      ENDDO
!
! find where the non zeros are along the path
!
      n_inds = COUNT(do_calc)
      IF(n_inds > 0) THEN
!
        ALLOCATE(inds(1:n_inds),singularity(1:n_inds))
        i = 1
        DO p_i = 1 , n_path
          IF(do_calc(p_i)) THEN
            inds(i) = p_i
            i = i + 1
          ENDIF
        ENDDO
!
        singularity = dbeta_path_c(inds,sps_i) * eta_zxp_f_c(inds,sv_i) * &
                   &  sps_path_c(inds,sps_i)
        DO p_i = 1 , n_inds
          d_delta_dx(inds(p_i)) = singularity(p_i) * del_s(inds(p_i))
        ENDDO
!
        no_to_gl = COUNT(do_gl(inds))
        IF(no_to_gl > 0) THEN
!
! see if anything needs to be gl-d
!
          ALLOCATE(all_inds(1:Ng*no_to_gl),gl_delta(1:no_to_gl), &
                   del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
          i = 1
          j = 1
          l = 1
          DO p_i = 1 , n_path
            IF(do_gl(p_i)) THEN
              IF(do_calc(p_i)) THEN
                more_inds(i) = p_i
                all_inds(j:j+Ng-1) = l + (/(k-1,k=1,Ng)/)
                IF(p_i > mid) THEN
                  del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
                ELSE
                  del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
                ENDIF
                i = i + 1
                j = j + Ng
              ENDIF
              l = l + Ng
            ENDIF
          END DO
          CALL path_opacity(del_zeta, &
              &  singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))),        &
              &  dbeta_path_f(all_inds,sps_i)*eta_zxp_f_f(all_inds,sv_i) * &
              &  sps_path_f(all_inds,sps_i),ds_dh_gl(all_inds),            &
              &  dh_dz_gl(all_inds),gl_delta)
          d_delta_dx(more_inds) = d_delta_dx(more_inds) + gl_delta
          DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
        ENDIF
!
        d_delta_dx(inds) = ref_cor(inds) * d_delta_dx(inds)
!
        i_start = MIN(inds(1),i_stop)
        DEALLOCATE(inds,singularity)
        CALL get_dscrt_no_t_dn(d_delta_dx,t_script,tau,i_start,i_stop, &
                            &  drad_dx(sv_i))
!
      ENDIF
!
    ENDDO
!
  ENDDO
!
  DEALLOCATE(d_delta_dx,do_calc)
!
END SUBROUTINE drad_tran_dx
!----------------------------------------------------------------------
! This is the radiative transfer derivative wrt temperature model
!
  SUBROUTINE drad_tran_dt(z_path_c,h_path_c,t_path_c,dh_dt_path_c, &
                     &  alpha_path_c,alphaxn_path_c,eta_zxp_c,do_calc_t_c, &
                     &  do_calc_hyd_c,del_s,ref_cor,h_tan,dh_dt_tan, &
                     &  freq,do_gl,h_path_f,t_path_f,dh_dt_path_f, &
                     &  alpha_path_f,alphaxn_path_f,eta_zxp_f,do_calc_t_f, &
                     &  ds_dh_gl,dh_dz_gl,t_script,tau,i_stop,drad_dt,ptg_i, &
                     &  frq_i)
!
! Inputs
!
  REAL(rp), INTENT(in) :: z_path_c(:) ! path -log(P) on main grid.
  REAL(rp), INTENT(in) :: h_path_c(:) ! path heights + req on main grid km.
  REAL(rp), INTENT(in) :: t_path_c(:) ! path temperature(K) on main grid.
  REAL(rp), INTENT(in) :: dh_dt_path_c(:,:) ! derivative of path height wrt
!                                             temperature(km/K) on main grid.
  REAL(rp), INTENT(in) :: alpha_path_c(:) ! path absorption(km^-1)
!                                           on main grid.
  REAL(rp), INTENT(in) :: alphaxn_path_c(:) ! path absorption times
!                          temperature power(km^-1) on main grid.
  REAL(rp), INTENT(in) :: eta_zxp_c(:,:) ! representation basis function
!                                            main grid.
  LOGICAL, INTENT(in) :: do_calc_t_c(:,:) ! A logical indicating where the
!                  representation basis function is not zero on main grid.
  LOGICAL, INTENT(in) :: do_calc_hyd_c(:,:) ! A logical indicating where the
!                  dh_dt function is not zero on main grid.
  REAL(rp), INTENT(in) :: del_s(:) ! unrefracted path length.
  REAL(rp), INTENT(in) :: ref_cor(:) ! refracted to unrefracted path
!                                      length ratios.
  REAL(rp), INTENT(in) :: h_tan ! tangent height + req (km).
  REAL(rp), INTENT(in) :: dh_dt_tan(:) ! derivative of path height wrt
!                                     temperature at the tangent (km/K).
  REAL(r8), INTENT(in) :: freq ! calculation frequency (MHz).
  LOGICAL, INTENT(in) :: do_gl(:) ! A logical indicating where to do gl
!                                   integrations.
  REAL(rp), INTENT(in) :: h_path_f(:) ! path heights + req on gl grid km.
  REAL(rp), INTENT(in) :: t_path_f(:) ! path temperature(K) on gl grid.
  REAL(rp), INTENT(in) :: dh_dt_path_f(:,:) ! derivative of path height wrt
!                                             temperature(km/K) on gl grid.
  REAL(rp), INTENT(in) :: alpha_path_f(:) ! path absorption(km^-1) on gl grid.
  REAL(rp), INTENT(in) :: alphaxn_path_f(:) ! path absorption times
!                          temperature power(km^-1) on gl grid.
  REAL(rp), INTENT(in) :: eta_zxp_f(:,:) ! representation basis function
!                                            gl grid.
  LOGICAL, INTENT(in) :: do_calc_t_f(:,:) ! A logical indicating where the
!                  representation basis function is not zero on gl grid.
  REAL(rp), INTENT(in) ::  ds_dh_gl(:) ! path length wrt height derivative on
!                                        gl grid.
  REAL(rp), INTENT(in) :: dh_dz_gl(:) ! path height wrt zeta derivative on
!                                       gl grid.
  REAL(rp), INTENT(in) :: t_script(:) ! differential temperatures (K).
  REAL(rp), INTENT(in) :: tau(:) ! transmission function.
  INTEGER(ip), INTENT(in) :: i_stop ! path stop index
  INTEGER(ip), INTENT(in) :: ptg_i,frq_i ! debugger statements
!
! Outputs
!
  REAL(rp), INTENT(out) :: drad_dt(:)    ! derivative of radiances wrt
!                                          mixing ratio statevector
!                                          element. (K)
! Internals
!
  INTEGER(ip) :: sv_i, sv_t, n_inds, i, j, k, l, i_start
  INTEGER(ip) :: n_path, p_i, no_to_gl, mid
  INTEGER(ip), ALLOCATABLE :: inds(:),all_inds(:),more_inds(:)
!
! use automatic allocations here
!
  REAL(rp), ALLOCATABLE :: d_delta_dt(:),singularity(:)
  REAL(rp), ALLOCATABLE :: del_zeta(:),gl_delta(:),dt_scr_dt(:,:)
  REAL(rp) :: fa,fb
  LOGICAL, ALLOCATABLE :: do_calc(:)
!
! Begin code
!
  n_path = SIZE(tau)
  sv_t = SIZE(eta_zxp_c,DIM=2)
  mid = n_path / 2
! allocate memory
  ALLOCATE(d_delta_dt(1:n_path),do_calc(1:n_path),dt_scr_dt(1:n_path,1:sv_t))
! compute the t_script derivative
  CALL dt_script_dt(t_path_c,eta_zxp_c,freq,dt_scr_dt)
! compute the opacity derivative singularity value
  DO sv_i = 1 , sv_t
    i_start = 1
    d_delta_dt = 0.0_rp
    drad_dt(sv_i) = 0.0_rp
! do the absorption part
! combine non zeros flags for both the main and gl parts
    do_calc = do_calc_t_c(:,sv_i)
    i = 1
    DO p_i = 1 , n_path
      IF(do_gl(p_i)) THEN
        IF(ANY(do_calc_t_f(i:i+ng-1,sv_i))) do_calc(p_i) = .true.
        i = i + ng
      ENDIF
    ENDDO
! find where the non zeros are along the path
    n_inds = COUNT(do_calc)
    IF(n_inds > 0) THEN
      ALLOCATE(inds(1:n_inds),singularity(1:n_inds))
      i = 1
      DO p_i = 1 , n_path
        IF(do_calc(p_i)) THEN
          inds(i) = p_i
          i = i + 1
        ENDIF
      ENDDO
      singularity = alphaxn_path_c(inds)*eta_zxp_c(inds,sv_i) &
                  / t_path_c(inds)
      d_delta_dt(inds) = singularity * del_s(inds)
      no_to_gl = COUNT(do_gl(inds))
      IF(no_to_gl > 0) THEN
! see if anything needs to be gl-d
         ALLOCATE(all_inds(1:ng*no_to_gl),gl_delta(1:no_to_gl), &
                  del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
         i = 1
         j = 1
         l = 1
         DO p_i = 1 , n_path
           IF(do_gl(p_i)) THEN
             IF(do_calc(p_i)) THEN
               more_inds(i) = p_i
               all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
               IF(p_i > mid) THEN
                 del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
               ELSE
                 del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
               ENDIF
               i = i + 1
               j = j + ng
             ENDIF
             l = l + ng
           ENDIF
         ENDDO
         CALL path_opacity(del_zeta, &
           &  singularity(PACK((/(i,i=1,n_inds)/),do_gl(inds))), &
           &  alphaxn_path_f(all_inds)*eta_zxp_f(all_inds,sv_i) &
           &  / t_path_f(all_inds),ds_dh_gl(all_inds),dh_dz_gl(all_inds), &
           &  gl_delta)
         d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
         DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
      ENDIF
      i_start = MAX(inds(1)-1,1)
      DEALLOCATE(inds,singularity)
    ENDIF
! now do the hydrostatic part
! combine boundaries flags
    do_calc = do_calc_hyd_c(:,sv_i)
    IF(do_calc_hyd_c(mid,sv_i)) THEN
      do_calc(2:mid) = .true.
    ELSE
      DO p_i = 2 , mid
        IF(do_calc_hyd_c(p_i-1,sv_i)) do_calc(p_i) = .true.
      ENDDO
    ENDIF
    IF(do_calc_hyd_c(mid+1,sv_i)) THEN
      do_calc(mid+1:n_path-1) = .true.
    ELSE
      DO p_i = mid + 1 , n_path - 1
        IF(do_calc_hyd_c(p_i+1,sv_i)) do_calc(p_i) = .true.
      ENDDO
    ENDIF
! since this is a layer boundary calculation we must require
    do_calc((/1,n_path/)) = .false.
! find where the non zeros are along the path
    n_inds = COUNT(do_calc)
    IF(n_inds > 0) THEN
      ALLOCATE(inds(1:n_inds))
      i = 1
      inds = 0
      DO p_i = 2 , mid - 1
        IF(do_calc(p_i)) THEN
          IF(i == 1) fa = (h_path_c(p_i-1)*dh_dt_path_c(p_i-1,sv_i) &
                        - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(p_i:mid))
          fb = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
             - h_tan * dh_dt_tan(sv_i)) /SUM(del_s(p_i+1:mid))
          inds(i) = p_i
          d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fa - fb)
          fa = fb
          i = i + 1
        ENDIF
      ENDDO
! special processing at tangent
      IF(do_calc(mid)) THEN
        d_delta_dt(mid) = d_delta_dt(mid) + alpha_path_c(mid) * fa
! fb is zero
        inds(i) = mid
        i = i + 1
      ENDIF
      IF(do_calc(mid+1)) THEN
        fa = (h_path_c(mid+2)*dh_dt_path_c(mid+2,sv_i) &
           - h_tan * dh_dt_tan(sv_i))/ del_s(mid+1)
        d_delta_dt(mid+1) = d_delta_dt(mid+1) + alpha_path_c(mid+1) * fa
! fb is 0.0
        inds(i) = mid+1
        i = i + 1
      ENDIF
      DO p_i = mid + 2 , n_path - 1
        IF(do_calc(p_i)) THEN
          IF(inds(MAX(i-1,1)) < mid+1)  &
                     & fa = (h_path_c(p_i)*dh_dt_path_c(p_i,sv_i) &
                     &    - h_tan * dh_dt_tan(sv_i)) / SUM(del_s(mid+1:p_i-1))
          fb = (h_path_c(p_i+1)*dh_dt_path_c(p_i+1,sv_i) &
             - h_tan * dh_dt_tan(sv_i)) /SUM(del_s(mid+1:p_i))
          inds(i) = p_i
          d_delta_dt(p_i) = d_delta_dt(p_i) + alpha_path_c(p_i)*(fb - fa)
          fa = fb
          i = i + 1
        ENDIF
      ENDDO
      no_to_gl = COUNT(do_gl(inds))
      IF(no_to_gl > 0) THEN
! see if anything needs to be gl-d
         ALLOCATE(all_inds(1:ng*no_to_gl),gl_delta(1:no_to_gl), &
                  del_zeta(1:no_to_gl),more_inds(1:no_to_gl))
         i = 1
         j = 1
         l = 1
         DO p_i = 1 , n_path
           IF(do_gl(p_i)) THEN
             IF(do_calc(p_i)) THEN
               more_inds(i) = p_i
               all_inds(j:j+ng-1) = l + (/(k-1,k=1,ng)/)
               IF(p_i > mid) THEN
                 del_zeta(i) = z_path_c(p_i+1) - z_path_c(p_i)
               ELSE
                 del_zeta(i) = z_path_c(p_i-1) - z_path_c(p_i)
               ENDIF
               i = i + 1
               j = j + ng
             ENDIF
             l = l + ng
           ENDIF
         ENDDO
! add special hydrostatic gl routine here
! the singularity point is alpha_path_c(more_inds)
         CALL hyd_opacity(del_zeta,alpha_path_c(more_inds), &
              alpha_path_f(all_inds),h_path_f(all_inds), &
              dh_dt_path_f(all_inds,sv_i),t_path_f(all_inds),h_tan, &
              dh_dt_tan(sv_i),eta_zxp_f(all_inds,sv_i),ds_dh_gl(all_inds), &
              dh_dz_gl(all_inds),gl_delta)
         d_delta_dt(more_inds) = d_delta_dt(more_inds) + gl_delta
         DEALLOCATE(all_inds,gl_delta,del_zeta,more_inds)
      ENDIF
      i_start = MIN(i_start,inds(1))
      DEALLOCATE(inds)
    ENDIF
! correct the whole thing for path length refraction
    d_delta_dt = ref_cor * d_delta_dt
        IF(ptg_i == 24 .and. frq_i == 1 .and. sv_i == 46) THEN
!        PRINT '(5f8.3)',dt_scr_dt(:,sv_i)
!        PRINT '(5e12.3)',d_delta_dt
!        PRINT '(5e12.3)',alpha_path_c
!        PRINT '(5e12.3)',dh_dt_path_c(:,sv_i)
!        PRINT '(2e12.3)',dh_dt_tan(sv_i),dh_dt_path_c(mid,sv_i)
!        PRINT *,do_calc_hyd_c(mid,sv_i)
!        PRINT *,'fine grid'
!        PRINT '(5e12.3)',dh_dt_path_f(:,sv_i)
        ENDIF
    CALL get_dscrt_dn(d_delta_dt,t_script,tau,dt_scr_dt(:,sv_i),i_start, &
                      i_stop,drad_dt(sv_i))
  ENDDO
  DEALLOCATE(d_delta_dt,do_calc,dt_scr_dt)
  END SUBROUTINE drad_tran_dt
!
!----------------------------------------------------------------------
End module RAD_TRAN_M
! $Log: rad_tran_m.f90,v $
@


1.11.2.2
log
@Adding dt_script code
@
text
@a6 1
  USE D_T_SCRIPT_DTNP_M, ONLY: DT_SCRIPT_DT
d14 1
a14 1
       "$Id: rad_tran_m.f90,v 1.11.2.1 2001/09/10 10:02:32 zvi Exp $"
a802 3
! Revision 1.11.2.1  2001/09/10 10:02:32  zvi
! Cleanup..comp_path_entities_m.f90
!
@


1.11.2.3
log
@Separating allocation stmts
@
text
@d12 1
a12 1
  PUBLIC :: PATH_CONTRIB, RAD_TRAN, DRAD_TRAN_DF, DRAD_TRAN_DT, DRAD_TRAN_DX
d15 1
a15 1
       "$Id: rad_tran_m.f90,v 1.11.2.2 2001/09/11 00:00:46 zvi Exp $"
d136 2
a137 5
    ALLOCATE(all_inds(1:ng*no_to_gl))
    ALLOCATE(gl_delta(1:no_to_gl))
    ALLOCATE(del_zeta(1:no_to_gl))
    ALLOCATE(more_inds(1:no_to_gl))

d159 1
a159 5

    DEALLOCATE(more_inds)
    DEALLOCATE(del_zeta)
    DEALLOCATE(gl_delta)
    DEALLOCATE(all_inds)
d237 1
a237 2
  ALLOCATE(d_delta_df(1:n_path))
  ALLOCATE(do_calc(1:n_path))
d262 1
a262 3
        ALLOCATE(inds(1:n_inds))
        ALLOCATE(singularity(1:n_inds))

d282 2
a283 5
            ALLOCATE(all_inds(1:ng*no_to_gl))
            ALLOCATE(gl_delta(1:no_to_gl))
            ALLOCATE(del_zeta(1:no_to_gl))
            ALLOCATE(more_inds(1:no_to_gl))

a302 1

d309 1
a309 6

            DEALLOCATE(more_inds)
            DEALLOCATE(del_zeta)
            DEALLOCATE(gl_delta)
            DEALLOCATE(all_inds)

d328 2
a329 5
            ALLOCATE(all_inds(1:ng*no_to_gl))
            ALLOCATE(gl_delta(1:no_to_gl))
            ALLOCATE(del_zeta(1:no_to_gl))
            ALLOCATE(more_inds(1:no_to_gl))

a348 1

d354 1
a354 6

            DEALLOCATE(all_inds)
            DEALLOCATE(gl_delta)
            DEALLOCATE(del_zeta)
            DEALLOCATE(more_inds)

d362 1
a362 4

        DEALLOCATE(inds)
        DEALLOCATE(singularity)

d372 1
a372 2
  DEALLOCATE(d_delta_df)
  DEALLOCATE(do_calc)
d442 1
a442 2
  ALLOCATE(d_delta_dx(1:n_path))
  ALLOCATE(do_calc(1:n_path))
d467 1
a467 3
        ALLOCATE(inds(1:n_inds))
        ALLOCATE(singularity(1:n_inds))

d487 2
a488 5
          ALLOCATE(all_inds(1:Ng*no_to_gl))
          ALLOCATE(gl_delta(1:no_to_gl))
          ALLOCATE(del_zeta(1:no_to_gl))
          ALLOCATE(more_inds(1:no_to_gl))

a507 1

d514 1
a514 6

          DEALLOCATE(more_inds)
          DEALLOCATE(del_zeta)
          DEALLOCATE(gl_delta)
          DEALLOCATE(all_inds)

d520 1
a520 4

        DEALLOCATE(singularity)
        DEALLOCATE(inds)

d530 1
a530 2
  DEALLOCATE(do_calc)
  DEALLOCATE(d_delta_dx)
d536 1
a536 1
SUBROUTINE drad_tran_dt(z_path_c,h_path_c,t_path_c,dh_dt_path_c, &
d541 2
a542 2
                     &  ds_dh_gl,dh_dz_gl,t_script,tau,i_stop,drad_dt,  &
                     &  ptg_i,frq_i)
a605 1

a612 1
!
d614 1
a614 5
!
  ALLOCATE(d_delta_dt(1:n_path))
  ALLOCATE(do_calc(1:n_path))
  ALLOCATE(dt_scr_dt(1:n_path,1:sv_t))
!
a615 1
!
a616 1
!
a617 1
!
a618 1
!
a621 1
!
a623 1
!
a631 1
!
a632 1
!
d635 1
a635 2
      ALLOCATE(inds(1:n_inds))
      ALLOCATE(singularity(1:n_inds))
a642 1
!
a645 1
!
a647 1
!
d649 2
a650 6
!
         ALLOCATE(all_inds(1:ng*no_to_gl))
         ALLOCATE(gl_delta(1:no_to_gl))
         ALLOCATE(del_zeta(1:no_to_gl))
         ALLOCATE(more_inds(1:no_to_gl))

a669 1
!
d676 1
a676 6
!
         DEALLOCATE(more_inds)
         DEALLOCATE(del_zeta)
         DEALLOCATE(gl_delta)
         DEALLOCATE(all_inds)
!
a677 1
!
d679 1
a679 4
!
      DEALLOCATE(singularity)
      DEALLOCATE(inds)
!
a680 1
!
a682 1
!
a697 1
!
a698 1
!
a699 1
!
a700 1
!
a717 1
!
a718 1
!
a720 1
!
a721 1
!
a724 1
!
a728 1
!
a729 1
!
a732 1
!
a745 1
!
a747 1
!
d749 2
a750 6
!
         ALLOCATE(all_inds(1:ng*no_to_gl))
         ALLOCATE(gl_delta(1:no_to_gl))
         ALLOCATE(del_zeta(1:no_to_gl))
         ALLOCATE(more_inds(1:no_to_gl))

a769 1
!
a771 1
!
d778 1
a778 6
!
         DEALLOCATE(more_inds)
         DEALLOCATE(del_zeta)
         DEALLOCATE(gl_delta)
         DEALLOCATE(all_inds)
!
a779 1
!
a780 1
!
a781 1
!
a782 1
!
a783 1
!
d785 10
d796 1
a796 2
                   &  i_stop,drad_dt(sv_i))
!
d798 2
a799 6
!
  DEALLOCATE(d_delta_dt)
  DEALLOCATE(do_calc)
  DEALLOCATE(dt_scr_dt)
!
END SUBROUTINE drad_tran_dt
a803 3
! Revision 1.11.2.2  2001/09/11 00:00:46  zvi
! Adding dt_script code
!
@


1.10
log
@Speed enhancement MAJOR update
@
text
@d9 1
a9 2
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA, &
                             PATH_INT_VECTOR_2D
d18 1
a18 1
       "$Id: rad_tran_m.f90,v 1.9 2001/06/07 23:39:31 pwagner Exp $"
d27 1
a27 1
    &        phi_path,dHdz_path,earth_ref,beta_path,spsfunc_path,ref_corr, &
d29 1
a29 2
    &        no_midval_ndx,gl_ndx,no_gl_ndx,midval_delta,Sps_zeta_loop, &
    &        Sps_phi_loop,Rad,Ier)
d46 1
a46 2
    Type(path_vector), intent(in) :: Z_PATH, T_PATH, H_PATH, PHI_PATH, &
                                  &  DHDZ_PATH
a49 3
    Type(path_int_vector_2d), intent(in) :: SPS_PHI_LOOP(:), &
                                            SPS_ZETA_LOOP(:)

d89 4
a92 4
    Call FAST_DELTA_ZOPACITY(mid,brkpt,no_ele,z_path,h_path,phi_path, &
   &     beta_path,dHdz_path,spsfunc_path,n_sps,N_lvls,ref_corr,elvar, &
   &     midval_ndx,no_midval_ndx,gl_ndx,no_gl_ndx,Sps_zeta_loop, &
   &     Sps_phi_loop,midval_delta,del_opacity,Ier)
d103 3
@


1.9
log
@Added Copyright statement
@
text
@d5 1
a5 1
  use GL6P, only: NG
d9 2
a10 1
  use PATH_ENTITIES_M, only: PATH_INDEX, PATH_VECTOR, PATH_BETA
d12 1
a12 2
  use FAST_DELTA_M, only: FAST_DELTA
  use FAST_ZOPACITY_M, only: FAST_ZOPACITY
d19 1
a19 1
       "$Id: rad_tran_m.f90,v 1.8 2001/04/09 23:33:41 zvi Exp $"
d27 9
a35 6
    Subroutine Rad_Tran(elvar,Frq,N_lvls,h_tan,n_sps, &
      &    ndx_path, z_path, h_path, t_path, phi_path, dHdz_path,     &
      &    earth_ref,beta_path, spsfunc_path, ref_corr, s_temp,brkpt, &
      &    no_ele, mid, ilo, ihi, t_script, tau, Rad, Ier)
!
    Integer(i4), intent(in) :: N_LVLS, N_SPS
d37 1
a37 1
    Integer(i4), intent(out) :: BRKPT, NO_ELE, MID, ILO, IHI, IER
d42 1
a47 1
    Type(path_index), intent(in)  :: NDX_PATH
d49 2
a50 1
   &                                 DHDZ_PATH
d53 4
a57 1
    Real(r8), intent(out) :: RAD
d59 1
a59 1
    Integer(i4) :: Ngp1, i
d62 1
a62 5

    Real(r8) :: del_opacity(2*(n_lvls+1))
    Real(r8) :: delta(2*(n_lvls+1),n_sps)
!
!  Begin code
d67 1
a67 2
   
    Ier = 0
a68 3
    brkpt = ndx_path%break_point_index
    no_ele = ndx_path%total_number_of_elements

a89 4
    Call FAST_DELTA(mid,brkpt,no_ele,z_path,h_path,phi_path,beta_path, &
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,ref_corr,elvar,delta,Ier)
    if (Ier /= 0) Return
!
d92 2
a93 2
    tau(:) = 0.0
    del_opacity(:) = 0.0
d95 5
a99 1
    CALL FAST_ZOPACITY(n_sps, Ngp1, brkpt, no_ele, delta, del_opacity)
a104 1

d109 3
@


1.8
log
@Initialize error flag
@
text
@d1 3
d19 1
a19 1
       "$Id: rad_tran_m.f90,v 1.7 2001/04/09 20:52:07 zvi Exp $"
d111 3
@


1.7
log
@Debugging Derivatives version
@
text
@d16 1
a16 1
       "$Id: rad_tran_m.f90,v 1.6 2001/03/31 23:40:55 zvi Exp $"
d61 2
a62 1

d108 3
@


1.6
log
@Eliminate l2pcdim (dimension parameters) move to allocatable ..
@
text
@d16 1
a16 1
       "$Id: rad_tran_m.f90,v 1.5 2001/03/30 20:28:21 zvi Exp $"
a52 3
!   Real(r8), allocatable, dimension(:) :: del_opacity     ! (N2lvl)
!   Real(r8), allocatable, dimension(:,:) :: delta         ! (N2lvl,Nsps)

a57 8
!   i = 2 * (n_lvls + 1)
!   ALLOCATE(del_opacity(i),delta(i,n_sps),STAT=ier)
!   IF(ier /= 0) THEN
!     PRINT *,'** ALLOCATION error in RAD_TRAN routine ..'
!     PRINT *,'   Allocation STAT =',ier
!     Return
!   ENDIF
!
a88 1
!   if (Ier /= 0) goto 99
d101 1
a101 1
!99  DEALLOCATE(del_opacity,delta,STAT=i)
a102 1
    Return
d104 1
d107 3
@


1.5
log
@General fix-up to get rid of COMMON BLOCK (ELLIPSE)
@
text
@a2 1
  use L2PCDim, only: NLVL, NSPS, N2LVL
d16 1
a16 1
       "$Id: rad_tran_m.f90,v 1.4 2001/03/29 08:51:01 zvi Exp $"
d49 1
a49 1
    Integer(i4) :: Ngp1
d52 16
a67 1
    Real(r8) :: del_opacity(N2lvl), delta(N2lvl,Nsps)
d99 2
a100 2
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,Nlvl,ref_corr,elvar, &
 &       delta,Ier)
d105 2
a106 2
    tau(1:N2lvl) = 0.0
    del_opacity(1:N2lvl) = 0.0
d108 1
a108 2
    CALL FAST_ZOPACITY(n_sps, Ngp1, N2lvl, brkpt, no_ele, delta, &
   &                   del_opacity)
d113 2
d119 3
@


1.4
log
@Changing the (*) toi (:) everywhere
@
text
@d6 1
a6 2
  use ELLIPSE, only: EARTHX, HT, HT2, NPHI_TAN, NPHI_S, PHI_S, PHI_TAN, &
                     ROC, RR
d17 1
a17 1
       "$Id: rad_tran_m.f90,v 1.3 2001/02/26 09:01:16 zvi Exp $"
d25 1
a25 1
    Subroutine Rad_Tran(Frq,N_lvls,h_tan,n_sps, &
d38 2
d63 4
a66 4
    EarthX = .false.
    ht = h_tan
    Rr = ht + RoC
    ht2 = Rr * Rr
d68 1
a68 1
      Rr = Rr / RoC
d70 1
a70 1
      Call Earth_Intersection(Rs)
d73 3
a75 3
      Rr = 0.0d0
      Phi_s = Phi_tan
      NPhi_s = NPhi_tan
d85 2
a86 1
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,Nlvl,ref_corr,delta,Ier)
d104 3
@


1.3
log
@New version - Using "Super-Structures"
@
text
@d18 1
a18 1
       "$Id: rad_tran_m.f90,v 1.1 2000/08/30 18:12:05 Z.Shippony Exp $"
d37 1
a37 1
    Real(r8), intent(in) :: REF_CORR(*)
d46 1
a46 1
    Real(r8), intent(out) :: T_SCRIPT(*), TAU(*)
d102 3
@


1.2
log
@New version of forward model
@
text
@d84 1
a84 2
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,Nlvl, &
 &       ref_corr,delta,Ier)
d92 2
a93 2
    CALL FAST_ZOPACITY(n_sps, Ngp1, N2lvl, brkpt, &
   &                   no_ele, delta, del_opacity)
@


1.1
log
@New version
@
text
@d26 1
a26 1
Subroutine Rad_Tran(Frq,N_lvls,h_tan,band,n_sps, sps_tbl, &
d29 1
a29 1
      &    no_ele, mid, ilo, ihi, cse, Rs, t_script, tau, Rad, Ier)
d31 1
a31 3
    Integer(i4), intent(in) :: N_LVLS, BAND, N_SPS

    Integer(i4), intent(in) :: SPS_TBL(Nsps,*)
d47 1
a47 1
    Real(r8), intent(out) :: CSE, RS, RAD
d51 1
d84 1
a84 1
 &       dHdz_path,spsfunc_path,n_sps,N_lvls,sps_tbl(1:,band),Nlvl, &
d93 1
a93 1
    CALL FAST_ZOPACITY(sps_tbl(1:,band), n_sps, Ngp1, N2lvl, brkpt, &
@

