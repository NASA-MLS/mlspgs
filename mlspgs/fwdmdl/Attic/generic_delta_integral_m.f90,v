head	1.9;
access;
symbols
	newfwm-sep01:1.8.0.2
	V0-7:1.8
	V0-5-Level2:1.4
	V0-5-SIPS:1.4;
locks; strict;
comment	@# @;


1.9
date	2001.09.17.20.26.27;	author livesey;	state dead;
branches;
next	1.8;

1.8
date	2001.07.04.00.34.24;	author zvi;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.06.22.04.05.28;	author zvi;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.21.13.07.08;	author zvi;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.07.23.30.34;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.30.20.28.21;	author zvi;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.29.08.51.01;	author zvi;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.31.01.08.48;	author zvi;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.22.23.07.27;	author zvi;	state Exp;
branches;
next	;

1.8.2.1
date	2001.09.10.10.00.29;	author zvi;	state dead;
branches;
next	;


desc
@@


1.9
log
@New forward model
@
text
@! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module GENERIC_DELTA_INTEGRAL_M
  use MLSCOmmon, only: I4, R8
  use GLNP, only: GW, NG
  use ELLIPSE_M, only: ELLIPSE
  use D_GET_ONE_ETA_M, only: GET_ONE_ETA
  use PATH_ENTITIES_M, only: PATH_VECTOR, PATH_INT_VECTOR_2D
  implicit NONE
  private
  public :: GENERIC_DELTA_INTEGRAL
!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
  "$Id: generic_delta_integral_m.f90,v 1.8 2001/07/04 00:34:24 zvi Exp $"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= &
  "$RCSfile: generic_delta_integral_m.f90,v $"
!---------------------------------------------------------------------------
contains
!---------------------------------------------------------------------
!  This routine computes a general form for the delta Integral.
!  Using the Gauss-Legendre method.
!
!  ** NOTE: This routine integrates in ZETA Space !
!
  Subroutine generic_delta_integral(mid, brkpt, no_ele, z_path, h_path,   &
 &           phi_path, dhdz_path, N_lvls, ref_corr, integrand, s_z_basis, &
 &           s_phi_basis,s_nz,s_np,iz,ip,fq,elvar,midval_delta,midval_ndx,&
 &           no_midval_ndx,gl_ndx,no_gl_ndx,Sps_zeta_loop,Sps_phi_loop,   &
 &           delta,Ier)
!
    Integer(i4), intent(in) :: N_LVLS, MID, BRKPT, NO_ELE, S_NZ, S_NP, &
   &             IZ, IP, no_midval_ndx,no_gl_ndx
!
   Integer(i4), intent(in) :: midval_ndx(:,:),gl_ndx(:,:)
!
    Type(path_vector), intent(in) :: Z_PATH, H_PATH, PHI_PATH, &
   &                                 DHDZ_PATH

    Type(path_int_vector_2d), intent(in) :: Sps_phi_loop, Sps_zeta_loop
!
    Real(r8), intent(in) :: midval_delta(:)
    Real(r8), intent(in) :: REF_CORR(:), INTEGRAND(:), FQ
    Real(r8), intent(in) :: S_Z_BASIS(:), S_PHI_BASIS(:)
!
    Type(ELLIPSE), intent(in out) :: elvar

    Real(r8), intent(out) :: DELTA(:)

    Integer(i4), intent(out) :: IER

    Integer(i4) :: J, K, L, MP, NGP1, H_I, HEND

    Real(r8) :: H_GL(Ng),GW_DHDZ(Ng),INTEGRAND_GL(Ng),DS_DH(Ng),VETA(Ng)

    Real(r8) :: ETAP, ETAZ, ZH, ZL, HD, HH, HL, HTAN2, PH, PL, RC, SA, &
             &  SB, SING, DS
!
    Ier = 0
!
!  Initialize the delta array:
!
    hend = 2 * N_lvls - 1
    delta(1:hend+1) = 0.0
!
! Load the mid_value delta into array: delta
!
    if(no_midval_ndx > 0) then
      do j = 1, no_midval_ndx
        h_i = midval_ndx(j,1)
        delta(h_i) = midval_delta(j)
      end do
    endif
!
    if(no_gl_ndx < 1) Return
!
! Now, do the GL deltas:
! First, do the right hand side of the ray path:
!
    k = 0
    integrand_GL = 0.0

    Ngp1 = Ng + 1
    elvar%ps = -1.0
    htan2 = elvar%ht2
!
    do j = 1, no_gl_ndx
!
      mp = gl_ndx(j,2)
      if (mp >= brkpt) EXIT
!
      h_i = gl_ndx(j,1)
      if(h_i >= mid) EXIT
!
      if(Sps_phi_loop%values(h_i,1) > ip  .or. &
     &   Sps_phi_loop%values(h_i,2) < ip  .or. &
     &   Sps_zeta_loop%values(h_i,1) > iz .or. &
     &   Sps_zeta_loop%values(h_i,2) < iz) CYCLE
!
      zl = z_path%values(mp)
      hl = h_path%values(mp)
      pl = phi_path%values(mp)
!
      hd = hl + elvar%RoC
      sa = Sqrt(abs(hd*hd-htan2))
!
      l = mp + Ngp1
      zh = z_path%values(l)
      hh = h_path%values(l)
      ph = phi_path%values(l)
!
      hd = hh + elvar%RoC
      sb = Sqrt(abs(hd*hd-htan2))
      ds = abs(sa-sb)
!
      if (ds < 0.05) EXIT
!
      k = j
      rc = ref_corr(h_i+1)
!
      call define_gl_grid_entities
!
!  Compute the value of the integrand at the starting point of the interval
!  (This is done in order to eliminate the singularities. We call these
!  the 'singularities factors')
!
      sing = 0.0
      Call get_one_eta(zh,s_z_basis,s_nz,iz,etaz)
      if (etaz > 0.0) then
        Call get_one_eta(ph,s_phi_basis,s_np,ip,etap)
        sing = etaz * etap * integrand(l)
      end if
!
! Define integrand on the Gauss-Legendre grid for the current sub-interval:
!
      integrand_GL(1:Ng) = integrand(mp+1:mp+Ng)
!
      Call gauss_legendre
!
    end do

    if(k == no_gl_ndx) Return
!
    j = max(1,k)
    l = gl_ndx(j,2)
    do
      j = j + 1
      if(j >= no_gl_ndx) EXIT
      mp = gl_ndx(j,2)
      if(mp - l == 1) EXIT
      l = mp
      k = j
    end do
!
! Second, do the left hand side of the ray path:
!
    do j = k+1, no_gl_ndx
!
      mp = gl_ndx(j,2)
      l = mp + Ngp1
      if (l > no_ele) EXIT
!
      h_i = gl_ndx(j,1)
      if(h_i >= hend) Return
!
      if(Sps_phi_loop%values(h_i,1) > ip  .or. &
     &   Sps_phi_loop%values(h_i,2) < ip  .or. &
     &   Sps_zeta_loop%values(h_i,1) > iz .or. &
     &   Sps_zeta_loop%values(h_i,2) < iz) CYCLE
!
      zl = z_path%values(mp)
      hl = h_path%values(mp)
      pl = phi_path%values(mp)
!
      hd = hl + elvar%RoC
      sa = Sqrt(abs(hd*hd-htan2))
!
      zh = z_path%values(l)
      hh = h_path%values(l)
      ph = phi_path%values(l)
!
      hd = hh + elvar%RoC
      sb = Sqrt(abs(hd*hd-htan2))
      ds = abs(sa-sb)
!
      if (ds < 0.05) EXIT
!
      rc = ref_corr(h_i)
!
      Call define_gl_grid_entities
!
!  Compute the value of the integrand at the starting point of the interval
!  (This is done in order to eliminate the singularities. We call these
!  the 'singularities factors')
!
      sing = 0.0
      Call get_one_eta(zl,s_z_basis,s_nz,iz,etaz)
      if (etaz > 0.0) then
        Call get_one_eta(pl,s_phi_basis,s_np,ip,etap)
        sing = etaz * etap * integrand(mp)
      end if
!
! Define integrand on the Gauss-Legendre grid for the current sub-interval:
!
      integrand_GL(1:Ng) = integrand(mp+1:mp+Ng)
!
      Call gauss_legendre
!
    end do
!
    Return
  ! *****     Internal procedures     **********************************
  contains
!
! --------------------------------     DEFINE_GL_GRID_ENTITIES     -----
    Subroutine DEFINE_GL_GRID_ENTITIES
!
    Integer :: i, j
    Real(r8) :: aym, q, v
!
! Define the various GL grid entities for this sub-interval:
!
      aym = 0.5 * abs(zh - zl)
      h_GL(1:Ng) = h_path%values(mp+1:mp+Ng) + elvar%RoC
      DS_DH(1:Ng) = h_GL(1:Ng) / Sqrt(h_GL(1:Ng)**2-htan2)
      Gw_dHdZ(1:Ng) = Gw(1:Ng) * dhdz_path%values(mp+1:mp+Ng) * aym
!
      do i = 1, Ng
        j = mp + i
        Call get_one_eta(z_path%values(j),s_z_basis,s_nz,iz,v)
        Call get_one_eta(phi_path%values(j),s_phi_basis,s_np,ip,q)
        veta(i) = v * q
      end do

    End subroutine DEFINE_GL_GRID_ENTITIES
! -----------------------------------------     GAUSS_LEGENDRE     -----
    Subroutine GAUSS_LEGENDRE
!
    Real(r8) :: fv, q
!
! Now compute the Gauss-Legendre quadrature, subtructing the 'singularities
! factors':
!
      q = SUM((integrand_GL(1:)*veta(1:)-sing)*DS_DH(1:)*Gw_dHdz(1:))
!
! Now add the 'singularities factors' back in, multiplied by their
! respective analytical integral:
!
      fv = q + sing * ds
!
! And Finally - define the delta:
!
      delta(h_i) = fv * rc * fq             ! for (iz,ip)
!
    End subroutine GAUSS_LEGENDRE

  End Subroutine generic_delta_integral

End module GENERIC_DELTA_INTEGRAL_M
! $Log: generic_delta_integral_m.f90,v $
! Revision 1.8  2001/07/04 00:34:24  zvi
! Modified & new code(s) for better timing
!
! Revision 1.7  2001/06/22 04:05:28  zvi
! Fixing indexing error
!
! Revision 1.6  2001/06/21 13:07:08  zvi
! Speed enhancement MAJOR update
!
! Revision 1.5  2001/06/07 23:30:34  pwagner
! Added Copyright statement
!
! Revision 1.4  2001/03/30 20:28:21  zvi
! General fix-up to get rid of COMMON BLOCK (ELLIPSE)
!
! Revision 1.3  2001/03/29 08:51:01  zvi
! Changing the (*) toi (:) everywhere
!
! Revision 1.2  2001/01/31 01:08:48  zvi
! New version of forward model
!
! Revision 1.1  2000/06/21 21:56:16  zvi
! First version D.P.
!
! Revision 1.1  2000/05/04 18:12:05  vsnyder
! Initial conversion to Fortran 90
@


1.8
log
@Modified & new code(s) for better timing
@
text
@d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.7 2001/06/22 04:05:28 zvi Exp $"
d261 3
@


1.8.2.1
log
@*** empty log message ***
@
text
@d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.8 2001/07/04 00:34:24 zvi Exp $"
a260 3
! Revision 1.8  2001/07/04 00:34:24  zvi
! Modified & new code(s) for better timing
!
@


1.7
log
@Fixing indexing error
@
text
@d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.6 2001/06/21 13:07:08 zvi Exp $"
d30 1
a30 1
 &           check_sps_loop,delta,Ier)
d33 1
a33 1
   &             IZ, IP, no_midval_ndx,no_gl_ndx, check_sps_loop
d52 1
a52 1
    Integer(i4) :: J, K, L, MP, NGP1, H_I, HEND, NZP
d54 1
a54 1
    Real(r8) :: H_GL(Ng), GW_DHDZ(Ng), INTEGRAND_GL(Ng), VETA(Ng)
d56 2
a57 2
    Real(r8) :: INTEGRAND_ZS, ETANP_SING, DS_DH, ETAP, ETAZ, FS, ZH, ZL, &
   &            ZS, HD, HH, HL, HTAN2, PH, PL, RC, SA, SB, SING, DS
a85 1
    nzp = s_nz * s_np * check_sps_loop
d95 4
a98 6
      if(nzp > 1) then
        if(Sps_phi_loop%values(h_i,1) > ip  .or. &
       &   Sps_phi_loop%values(h_i,2) < ip  .or. &
       &   Sps_zeta_loop%values(h_i,1) > iz .or. &
       &   Sps_zeta_loop%values(h_i,2) < iz) CYCLE
      endif
d127 2
a128 4
      zs = zh
      fs = ph
      etanp_sing = 0.0
      Call get_one_eta(zs,s_z_basis,s_nz,iz,etaz)
d130 2
a131 2
        Call get_one_eta(fs,s_phi_basis,s_np,ip,etap)
        etanp_sing = etaz * etap
a135 5
      integrand_zs = integrand(l)
      sing = integrand_zs * etanp_sing
!
! Define integrand on the Gauss-Legendre grid for the current sub-interval:
!
d166 4
a169 6
      if(nzp > 1) then
        if(Sps_phi_loop%values(h_i,1) > ip  .or. &
       &   Sps_phi_loop%values(h_i,2) < ip  .or. &
       &   Sps_zeta_loop%values(h_i,1) > iz .or. &
       &   Sps_zeta_loop%values(h_i,2) < iz) CYCLE
      endif
d196 2
a197 4
      zs = zl
      fs = pl
      etanp_sing = 0.0
      Call get_one_eta(zs,s_z_basis,s_nz,iz,etaz)
d199 2
a200 2
        Call get_one_eta(fs,s_phi_basis,s_np,ip,etap)
        etanp_sing = etaz * etap
a202 3
      integrand_zs = integrand(mp)
      sing = integrand_zs * etanp_sing
!
d219 1
a219 1
    Real(r8) :: aym, q, v, z, phi
d224 3
d230 2
a231 6
        z = z_path%values(j)
        phi = phi_path%values(j)
        h_GL(i) = h_path%values(j)
        Gw_dHdZ(i) = Gw(i) * dhdz_path%values(j) * aym
        Call get_one_eta(z,s_z_basis,s_nz,iz,v)
        Call get_one_eta(phi,s_phi_basis,s_np,ip,q)
d234 1
d239 1
a239 2
    Integer :: i
    Real(r8) :: Sum, fv, q
d244 1
a244 16
      Sum = 0.0
!
      do i = 1, Ng
!
! Compute the "Hydrostatic" contribution to the derivative:
!
        hd = h_GL(i) + elvar%RoC
        ds_dh = hd / Sqrt(hd*hd-htan2)
!
        q = integrand_GL(i) * veta(i)
!
! The final integrand:
!
        Sum = Sum + (q - sing) * ds_dh * Gw_dHdz(i)
!
      end do
d249 1
a249 1
      fv = Sum + sing * ds
d256 1
d258 1
d261 3
@


1.6
log
@Speed enhancement MAJOR update
@
text
@d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.5 2001/06/07 23:30:34 pwagner Exp $"
d121 1
a147 1
      k = j
d154 1
a154 1
    j = k
d292 3
@


1.5
log
@Added Copyright statement
@
text
@d6 1
a6 1
  use GL6P, only: GW, NG
d9 1
a9 1
  use PATH_ENTITIES_M, only: PATH_VECTOR
d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.4 2001/03/30 20:28:21 zvi Exp $"
d28 3
a30 1
 &           s_phi_basis, s_nz, s_np, iz, ip, fq, elvar, delta, Ier )
d33 3
a35 1
   &                           IZ, IP
d39 2
d42 1
a43 1

d52 1
a52 1
    Integer(i4) :: K, MP, NGP1, H_I, HEND
d56 2
a57 2
    Real(r8) :: INTEGRAND_ZS, ETANP_SING, DS_DH, ETAP, ETAZ, FS, ZH, &
   &            ZL, ZS, HD, HH, HL, HTAN2, PH, PL, RC, SA, SB, SING
a59 1
    htan2 = elvar%ht2
d61 1
a61 3
!  Initialize all arrays:
!
    integrand_GL = 0.0
d66 12
d80 4
a83 1
    mp = 1
d85 2
a86 7
    Ngp1 = Ng + 1
    zh = z_path%values(mp)
    hh = h_path%values(mp)
    ph = phi_path%values(mp)

    hd = hh + elvar%RoC
    sb = Sqrt(abs(hd*hd-htan2))
d88 1
a88 1
    do h_i = 1, mid
d90 2
a91 2
      mp = mp + Ngp1
      if (mp > brkpt) EXIT
d93 21
a113 3
      hl = hh
      hh = h_path%values(mp)
      if (hh < elvar%ht-0.001) EXIT
a114 7
      zl = zh
      zh = z_path%values(mp)
!
      pl = ph
      ph = phi_path%values(mp)
!
      sa = sb
d117 1
d119 1
a119 1
      if (abs(sa-sb) < 0.05) EXIT
d140 1
a140 2
      k = mp - Ngp1
      integrand_zs = integrand(mp)
d145 1
a145 1
      integrand_GL(1:Ng) = integrand(k+1:k+Ng)
d147 1
d151 2
d154 9
a162 10
! Second, do the left hand side of the ray path:
!
    elvar%ps = 1.0
    h_i = mid
    mp = brkpt + 1
    hh = h_path%values(mp)
    do while (hh < elvar%ht-0.0001)
      h_i = h_i + 1
      mp = mp + Ngp1
      hh = h_path%values(mp)
d165 1
a165 5
    zh = z_path%values(mp)
    ph = phi_path%values(mp)

    hd = hh + elvar%RoC
    sb = Sqrt(abs(hd*hd-htan2))
d167 1
a167 1
    do while (h_i < hend)
d169 24
a192 2
      mp = mp + Ngp1
      if(mp > no_ele) Return
a193 10
      hl = hh
      hh = h_path%values(mp)
!
      zl = zh
      zh = z_path%values(mp)
!
      pl = ph
      ph = phi_path%values(mp)
!
      sa = sb
d196 3
d217 1
a217 2
      k = mp - Ngp1
      Integrand_zs = integrand(k)
d222 1
a222 1
      integrand_GL(1:Ng) = integrand(k+1:k+Ng)
a225 2
      h_i = h_i + 1
!
a241 1
      j = mp - Ngp1
d243 1
a243 1
        j = j + 1
d282 1
a282 1
      fv = Sum + sing * abs(sb-sa)
d292 3
@


1.4
log
@General fix-up to get rid of COMMON BLOCK (ELLIPSE)
@
text
@d1 3
d15 1
a15 1
  "$Id: generic_delta_integral_m.f90,v 1.3 2001/03/29 08:51:01 zvi Exp $"
d259 3
@


1.3
log
@Changing the (*) toi (:) everywhere
@
text
@d4 1
a4 1
  use ELLIPSE, only: HT, HT2, PS, ROC
d12 1
a12 1
  "$Id: generic_delta_integral_m.f90,v 1.2 2001/01/31 01:08:48 zvi Exp $"
d25 1
a25 1
 &           s_phi_basis, s_nz, s_np, iz, ip, fq, delta, Ier )
d36 2
d51 1
a51 1
    htan2 = ht2
d63 1
a63 1
    ps = -1.0
d69 1
a69 1
    hd = hh + RoC
d79 1
a79 1
      if (hh < ht-0.001) EXIT
d88 1
a88 1
      hd = hh + RoC
d126 1
a126 1
    ps = 1.0
d130 1
a130 1
    do while (hh < ht-0.0001)
d139 1
a139 1
    hd = hh + RoC
d157 1
a157 1
      hd = hh + RoC
d232 1
a232 1
        hd = h_GL(i) + RoC
d256 3
@


1.2
log
@New version of forward model
@
text
@d12 1
a12 1
  "$Id: generic_delta_integral_m.f90,v 1.1 2000/06/21 21:56:16 zvi Exp $"
d33 1
a33 1
    Real(r8), intent(in) :: REF_CORR(*), INTEGRAND(*), FQ
d37 1
a37 1
    Real(r8), intent(out) :: DELTA(*)
d176 1
a176 1
      integrand_zs = integrand(k)
d254 3
@


1.1
log
@New version
@
text
@@

