head	1.9;
access;
symbols
	v5-02-NRT-19:1.9
	v6-00:1.9
	v5-02-NRT-18:1.9
	v5-02:1.9
	v5-01-NRT-17:1.9
	v5-01-NRT-16:1.9
	v5-01-NRT-15:1.9
	v5-01-NRT-14:1.9
	neuralnetworks-1-0:1.9.0.16
	cfm-single-freq-0-1:1.9.0.14
	v5-01:1.9
	v5-00:1.9
	v4-23-TA133:1.9.0.12
	mus-emls-1-70:1.9.0.10
	rel-1-0-englocks-work:1.9.0.8
	VUMLS1-00:1.9
	VPL1-00:1.9
	V4-22-NRT-08:1.9
	VAM1-00:1.9
	V4-21:1.9.0.6
	V4-13:1.9
	V4-12:1.9
	V4-11:1.9
	V4-10:1.9
	V3-43:1.9
	M4-00:1.9
	V3-41:1.9
	V3-40-PlusGM57:1.9.0.4
	V2-24-NRT-04:1.9
	V3-33:1.9
	V2-24:1.9
	V3-31:1.9
	V3-30-NRT-05:1.9
	cfm-01-00:1.9
	V3-30:1.9
	V3-20:1.9
	V3-10:1.9
	V2-23-NRT-02:1.9
	V2-23:1.9
	V2-22-NRT-01:1.9
	V2-22:1.9
	V2-21:1.9
	V2-20:1.9
	V2-11:1.9
	V2-10:1.9
	V2-00:1.9
	V1-51:1.9
	V1-50:1.9
	V1-45:1.9
	V1-44:1.9
	V1-43:1.9
	V1-42:1.9
	V1-41:1.9
	V1-32:1.9
	V1-40:1.9
	V1-31:1.9
	V1-30:1.9
	V1-13:1.9
	V1-12:1.9
	V1-11:1.9
	V1-10:1.9
	newfwm-feb03:1.9.0.2
	V1-04:1.9
	V1-03:1.9
	V1-02:1.9
	V1-00:1.9
	newfwm-sep01:1.2.0.2
	V0-7:1.2
	V0-5-Level2:1.2
	V0-5-SIPS:1.2;
locks; strict;
comment	@# @;


1.9
date	2001.12.08.23.29.34;	author pwagner;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.08.00.44.44;	author pwagner;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.04.00.24.32;	author pwagner;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.11.23.27.23;	author livesey;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.11.23.25.19;	author livesey;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.11.22.07.59;	author livesey;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.10.23.20.12;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.04.18.36.36;	author pumphrey;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.30.16.34.27;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Reset DEBUG params to FALSE
@
text
@! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

program sids_l1boa ! Generate simulated L1BOA data for MLS

  USE DUMP_0, only: DUMP
  use Hdf, only: DFACC_WRITE, SFEND, SFSTART
  use L1boa, only: L1BOA_FILL, L1BOA_NOFILL
  use MLSCommon, only: R8, TAI93_RANGE_T
  use MLSMessageModule, only: MLSMSG_ALLOCATE, MLSMSG_ERROR, MLSMSG_FILEOPEN, &
    & MLSMESSAGE
  use Orbit, only: ALTG, ALTT, ASCTAI, DSCTAI, ORBINCLINE, ORBITNUMBER, &
    & ORBIT_MET, NUMORB
  use Output_M, only: output
  use OutputL1B, only: L1BOAINDEX_T
  use Read, only: READ_SCAN, READ_UIF
  use Sd, only: SD_CREATE
  use SDPToolkit, only: PGS_PC_GETREFERENCE
  use Time, only: TIME_DAY, TIME_MAF, TIME_POST, TIME_PRE

  implicit none

  !------------------- RCS Ident Info -----------------------
  character(len=130) :: Id = &                                                    
    "$Id: sids_l1boa.f90,v 1.8 2001/12/08 00:44:44 pwagner Exp $"
  character(len=*), parameter :: ModuleName= "$RCSfile: sids_l1boa.f90,v $"
  !----------------------------------------------------------

  ! Brief description of program
  ! This program creates a  SIDS L1BOA file.

  ! Parameters
  logical, parameter :: DEBUG = .FALSE.
  logical, parameter :: PRINTPROGRESS = .TRUE.
   
  integer, parameter :: SD_OUTFILE = 333

  ! Variables
  type ( TAI93_Range_T ) :: times
  type( L1BOAindex_T) :: index

  character(len=27) :: endTime, startTime
  character(len=135) :: physicalFilename
  character(len=480) :: msr
  character(len=27), allocatable :: mafTime(:), postTimes(:), preTimes(:)
  character(len=27), allocatable :: scanTimes(:,:)

  integer :: alloc_err, dealloc_err, i, lenMAF, lenMIF, mifG, mifRate, mifT
  integer :: minSC, nPhaseG, nPhaseT, offsetMAF, opd, orbPerDay
  integer :: postMAF, preMAF, returnStatus, scansPerOrb, sd_id, status
  integer :: SD_VERSION
  integer, allocatable :: numMIFs(:), nV(:)
  integer, allocatable :: numValues(:,:)

  real, allocatable :: scRate(:), scRateT(:)

  real(r8) :: homeAlt, homeLat, mfps, spm
  real(r8), allocatable :: mafTAI(:), offsets(:), postTAI(:), preTAI(:)
  real(r8), allocatable :: scanTAI(:,:)
  real(r8), dimension(:), pointer :: deltaT

  ! Read SIDS input
  call Read_uif(altG, altT, times, endTime, homeAlt, homeLat, mifG, mifT, &
    mifRate, nPhaseG, nPhaseT, offsetMAF, scansPerOrb, startTime)

  allocate(scRate(mifG), scRateT(mifT), STAT=alloc_err)
  if ( alloc_err /= 0 ) then
    msr = MLSMSG_Allocate // '  scan rate variables.'
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  call Read_scan(mifG, mifT, nPhaseG, nPhaseT, scRate, scRateT)

  ! Get orbit metadata for entire day
  call Orbit_met(startTime, times, ascTAI, dscTAI, numOrb, orbitNumber)

  opd = numOrb+1

  ! Calculate MAF start times
  allocate( numMIFs(scansPerOrb), numValues(scansPerOrb,opd), &
    postTAI(scansPerOrb), postTimes(scansPerOrb), preTAI(scansPerOrb), &
    preTimes(scansPerOrb), scanTAI(scansPerOrb,opd), &
    scanTimes(scansPerOrb,opd), STAT=alloc_err )
  if ( alloc_err /= 0 ) then
    msr = MLSMSG_Allocate // '  MAF quantities.'
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  ! Need to zero numValues. The program does not set all the elements of 
  ! numValues(1:orbPerDay-1) before it calculates minSC. This may lead to 
  ! minSC being (e.g.) -28484737282 yucky consequences. This is doubtless
  ! compiler dependent -- it is needed for NAG f95 / linux. (HCP)
  numValues=0

  mfps = dble(mifRate)
  spm = 1/mfps

  call Time_MAF(startTime, times, homeAlt, homeLat, mifRate, scansPerOrb, &
    spm, scanTimes, scanTAI, numValues, orbPerDay)

  call Time_pre(numValues(:,1), scanTimes(1,1), times%startTime, scansPerOrb, &
    spm, preTimes, preTAI, numMIFs, preMAF)

  call Time_post(numValues(:,orbPerDay-1), scanTimes(1,orbPerDay), &
    times%endTime, scansPerOrb, spm, postTimes, postTAI, postMAF)

  ! Check the lengths of the given scans against the minimum # of MIFs per MAF
  minSC = minval( numValues(:,1:orbPerDay-1) )

  if ( mifG > minSC ) then
    print *, 'Desired GHz scan program is too long:'
    print *, 'Minimum number of MIFs per MAF = ', minSC
    print *, 'Number of MIFs in GHz scan = ', mifG
    stop
  endif

  if ( mifT > minSC ) then
    print *, 'Desired THz scan program is too long:'
    print *, 'Minimum number of MIFs per MAF = ', minSC
    print *, 'Number of MIFs in THz scan = ', mifT
    stop
  endif

  ! Calculate one-time values, outside of MAF/orbit loop(s)
  lenMIF = maxval(numValues)

  allocate( offsets(lenMIF), STAT=alloc_err )
  if ( alloc_err /= 0 ) then
    msr = MLSMSG_Allocate // '  offsets.'
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  do i = 1, lenMIF
    offsets(i) = (i-1)/mfps
  enddo

  orbIncline = 98.145

  ! Get filename from PCF
  SD_VERSION = 1

  returnStatus = Pgs_pc_getReference(SD_OUTFILE, SD_VERSION, physicalFilename)

  ! Open HDF-SD output file and create empty arrays; calculate # of MAFs in the
  ! day.
  call Sd_create(mifG, lenMIF, mifT, offsetMAF, orbPerDay, physicalFilename, &
    postMAF, preMAF, scansPerOrb, lenMAF)

!  print *, 'Num of MAFs in file = ', lenMAF
  if ( PRINTPROGRESS ) then
    call output('Num of MAFs in file = ', advance='no')
    call output(lenMAF, advance='yes')
  endif

  ! After creation, re-open the HDF file and initialize the SD interface for
  ! writing
  sd_id = sfstart(physicalFilename, DFACC_WRITE)
  if (sd_id == -1) then
    msr = MLSMSG_Fileopen // physicalFilename
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  ! Re-arrange time, number of values into single array for entire file
  allocate( mafTAI(lenMAF), mafTime(lenMAF), nV(lenMAF), STAT=alloc_err )
  if ( alloc_err /= 0 ) then
    msr = MLSMSG_Allocate // '  time variables.'
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  call Time_day(lenMAF, numMIFs, numValues, orbPerDay, postMAF, postTAI, &
    postTimes, preMAF, preTAI, preTimes, scansPerOrb, scanTAI, &
    scanTimes, mafTAI, mafTime, nV)

  if ( DEBUG ) then                  
     allocate( deltaT(lenMAF-1) )    
  endif                              
  ! For first MAF, calculate & write L1BOA data with fill values/settings
  if ( PRINTPROGRESS ) then
!   print *, 'Processing MAF 1 ... '
    call output('Processing MAF 1 ... ', advance='yes')
  endif
  index%MAFStartTimeUTC = mafTime(1)
  index%MAFStartTimeTAI = mafTAI(1)
  index%noMIFs = nV(1)
  index%counterMAF = 0

  call L1boa_fill(altG, altT, ascTAI, dscTAI, sd_id, mifG, mifT, index, 1, &
    numOrb, offsets, orbIncline, orbitNumber, scRate, scRateT)

  ! Close the file to set fill values
  status = sfend(sd_id)
  if (status == -1) then
    msr = 'Failed to close file ' // physicalFilename
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  ! Re-open the HDF file and initialize the SD interface for writing
  sd_id = sfstart(physicalFilename, DFACC_WRITE)
  if (sd_id == -1) then
    msr = MLSMSG_Fileopen // physicalFilename
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  ! For remaining MAFs, calculate & write L1BOA data
  do i = 2, lenMAF

!    print *, 'Processing MAF ', i, ' ... '
    if ( PRINTPROGRESS ) then
!     print *, 'Processing MAF 1 ... '
      call output('Processing MAF ', advance='no')
      call output(i, advance='no')
      call output(' ... ', advance='yes')
    endif
    if ( DEBUG ) deltaT(i-1) = mafTAI(i) - mafTAI(i-1)

    index%MAFStartTimeUTC = mafTime(i)
    index%MAFStartTimeTAI = mafTAI(i)
    index%noMIFs = nV(i)
    index%counterMAF = i-1

    call L1boa_nofill(altG, altT, ascTAI, dscTAI, sd_id, mifG, mifT, index, &
      i, numOrb, offsets, orbIncline, orbitNumber, scRate, scRateT)

  enddo

  if ( DEBUG ) then                  
     call dump(deltaT, 'MAF Time intervals')   
  endif                              
  ! Terminate access to the SD interface and close the file
  status = sfend(sd_id)
  if (status == -1) then
    msr = 'Failed to close file ' // physicalFilename
    call MLSMessage(MLSMSG_Error, ModuleName, msr)
  endif

  deallocate(offsets, numMIFs, numValues, postTAI, postTimes, preTAI, &
    preTimes, scanTAI, scanTimes, scRate, scRateT, mafTAI, mafTime, &
    nV, STAT=dealloc_err )
  if ( dealloc_err /= 0 ) call MLSMessage(MLSMSG_Error, ModuleName,&
    & 'Failed deallocation.')

  ! Detailed description of program
  ! The program creates a SIDS L1BOA SDS-HDF file.  It uses routines such that
  ! the fill value/modes are set only on writing the first record.

end program sids_l1boa

! $Log: sids_l1boa.f90,v $
! Revision 1.8  2001/12/08 00:44:44  pwagner
! Prints MAF Time intervals if DEBUG
!
! Revision 1.7  2001/12/04 00:24:32  pwagner
! Gets hdf stuff from hdf, not Sd
!
! Revision 1.6  2001/10/11 23:27:23  livesey
! Tried to change the chmod stuff
!
! Revision 1.5  2001/10/11 23:25:19  livesey
! Tidied up a bit
!
! Revision 1.4  2001/10/11 22:07:59  livesey
! Just tidied up a bit
!
! Revision 1.3  2001/10/10 23:20:12  pwagner
! Now compiles with latest l1/Orbit
!
! Revision 1.2  2000/12/04 18:36:36  pumphrey
! fixed a tiny bug
!
! Revision 1.1  2000/11/30 16:34:27  nakamura
! The SIDS L1BOA program.
@


1.8
log
@Prints MAF Time intervals if DEBUG
@
text
@d1 3
d14 1
d25 1
a25 1
    "$Id: sids_l1boa.f90,v 1.7 2001/12/04 00:24:32 pwagner Exp $"
d33 2
a34 1
  logical, parameter :: DEBUG = .TRUE.
d149 5
a153 1
  print *, 'Num of MAFs in file = ', lenMAF
d178 4
a181 2
  print *, 'Processing MAF 1 ... '

d207 7
a213 1
    print *, 'Processing MAF ', i, ' ... '
d249 3
@


1.7
log
@Gets hdf stuff from hdf, not Sd
@
text
@d3 1
d21 1
a21 1
    "$Id: sids_l1boa.f90,v 1.6 2001/10/11 23:27:23 livesey Exp $"
d29 2
d55 1
d165 3
d197 1
d209 3
d232 3
@


1.6
log
@Tried to change the chmod stuff
@
text
@d3 1
d5 3
a9 5
  use read, only: READ_SCAN, READ_UIF
  use Sd, only: DFACC_WRITE, SD_CREATE, SFEND, SFSTART
  use Time, only: TIME_DAY, TIME_MAF, TIME_POST, TIME_PRE
  use MLSMessageModule, only: MLSMSG_ALLOCATE, MLSMSG_ERROR, MLSMSG_FILEOPEN, &
    & MLSMESSAGE
d11 2
a12 1
  use MLSCommon, only: R8, TAI93_RANGE_T
d14 1
d20 1
a20 1
    "$Id: sids_l1boa.f90,v 1.5 2001/10/11 23:25:19 livesey Exp $"
d221 3
@


1.5
log
@Tidied up a bit
@
text
@d1 1
a1 2
!===================================================
program sids_l1boa ! End-to-end check on subroutines
d19 1
a19 1
    "$Id: sids_l1boa.f90,v 1.4 2001/10/11 22:07:59 livesey Exp $"
d220 3
@


1.4
log
@Just tidied up a bit
@
text
@d9 1
a9 1
  use Time, only: TAI93_RANGE_T, TIME_DAY, TIME_MAF, TIME_POST, TIME_PRE
d13 1
a13 1
  use MLSCommon, only: R8
d20 1
a20 1
    "$Id: sids_l1boa.f90,v 1.3 2001/10/10 23:20:12 pwagner Exp $"
d221 3
@


1.3
log
@Now compiles with latest l1/Orbit
@
text
@d2 1
a2 2
PROGRAM sids_l1boa ! End-to-end check on subroutines
!===================================================
d4 225
a228 247
   USE Hdf
   USE L1boa
   USE MLSCommon
   USE MLSMessageModule
   USE Orbit
   USE OutputL1B
   USE Read
   USE Sd
   USE SDPToolkit
   USE Time

   IMPLICIT NONE

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: sids_l1boa.f90,v 1.2 2000/12/04 18:36:36 pumphrey Exp $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: sids_l1boa.f90,v $"
!----------------------------------------------------------

! Brief description of program
! This program creates a  SIDS L1BOA file.

! Parameters

   INTEGER, PARAMETER :: SD_OUTFILE = 333

! Functions

! Variables

   TYPE ( TAI93_Range_T ) :: times
   TYPE( L1BOAindex_T) :: index

   CHARACTER (LEN=27) :: endTime, startTime
   CHARACTER (LEN=135) :: physicalFilename
   CHARACTER (LEN=480) :: msr
   CHARACTER (LEN=27), ALLOCATABLE :: mafTime(:), postTimes(:), preTimes(:)
   CHARACTER (LEN=27), ALLOCATABLE :: scanTimes(:,:)

   INTEGER :: alloc_err, dealloc_err, i, lenMAF, lenMIF, mifG, mifRate, mifT
   INTEGER :: minSC, nPhaseG, nPhaseT, offsetMAF, opd, orbPerDay
!   INTEGER :: minSC, nPhaseG, nPhaseT, numOrb, offsetMAF, opd, orbPerDay
   INTEGER :: postMAF, preMAF, returnStatus, scansPerOrb, sd_id, status
   INTEGER :: SD_VERSION
!   INTEGER :: orbitNumber(max_orbits)
   INTEGER, ALLOCATABLE :: numMIFs(:), nV(:)
   INTEGER, ALLOCATABLE :: numValues(:,:)

   REAL, ALLOCATABLE :: scRate(:), scRateT(:)

   REAL(r8) :: homeAlt, homeLat, mfps, spm
!   REAL(r8) :: altG, altT, homeAlt, homeLat, mfps, orbIncline, spm
!   REAL(r8) :: ascTAI(max_orbits), dscTAI(max_orbits)
   REAL(r8), ALLOCATABLE :: mafTAI(:), offsets(:), postTAI(:), preTAI(:)
   REAL(r8), ALLOCATABLE :: scanTAI(:,:)

! Read SIDS input

   CALL Read_uif(altG, altT, times, endTime, homeAlt, homeLat, mifG, mifT, &
                 mifRate, nPhaseG, nPhaseT, offsetMAF, scansPerOrb, startTime)

   ALLOCATE(scRate(mifG), scRateT(mifT), STAT=alloc_err)
   IF ( alloc_err /= 0 ) THEN
      msr = MLSMSG_Allocate // '  scan rate variables.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   CALL Read_scan(mifG, mifT, nPhaseG, nPhaseT, scRate, scRateT)

! Get orbit metadata for entire day

   CALL Orbit_met(startTime, times, ascTAI, dscTAI, numOrb, orbitNumber)

   opd = numOrb+1

! Calculate MAF start times

   ALLOCATE( numMIFs(scansPerOrb), numValues(scansPerOrb,opd), &
           postTAI(scansPerOrb), postTimes(scansPerOrb), preTAI(scansPerOrb), &
           preTimes(scansPerOrb), scanTAI(scansPerOrb,opd), &
           scanTimes(scansPerOrb,opd), STAT=alloc_err )
   IF ( alloc_err /= 0 ) THEN
      msr = MLSMSG_Allocate // '  MAF quantities.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   ! Need to zero numValues. The program does not set all the elements of 
   ! numValues(1:orbPerDay-1) before it calculates minSC. This may lead to 
   ! minSC being (e.g.) -28484737282 yucky consequences. This is doubtless
   ! compiler dependent -- it is needed for NAG f95 / linux. (HCP)
   numValues=0

   mfps = DBLE(mifRate)
   spm = 1/mfps

   CALL Time_MAF(startTime, times, homeAlt, homeLat, mifRate, scansPerOrb, &
                 spm, scanTimes, scanTAI, numValues, orbPerDay)

   CALL Time_pre(numValues(:,1), scanTimes(1,1), times%startTime, scansPerOrb, &
                 spm, preTimes, preTAI, numMIFs, preMAF)

   CALL Time_post(numValues(:,orbPerDay-1), scanTimes(1,orbPerDay), &
                  times%endTime, scansPerOrb, spm, postTimes, postTAI, postMAF)

! Check the lengths of the given scans against the minimum # of MIFs per MAF

   minSC = MINVAL( numValues(:,1:orbPerDay-1) )

   IF ( mifG > minSC ) THEN
      print *, 'Desired GHz scan program is too long:'
      print *, 'Minimum number of MIFs per MAF = ', minSC
      print *, 'Number of MIFs in GHz scan = ', mifG
      STOP
   ENDIF

   IF ( mifT > minSC ) THEN
      print *, 'Desired THz scan program is too long:'
      print *, 'Minimum number of MIFs per MAF = ', minSC
      print *, 'Number of MIFs in THz scan = ', mifT
      STOP
   ENDIF

! Calculate one-time values, outside of MAF/orbit loop(s)

   lenMIF = MAXVAL(numValues)

   ALLOCATE( offsets(lenMIF), STAT=alloc_err )
   IF ( alloc_err /= 0 ) THEN
      msr = MLSMSG_Allocate // '  offsets.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   DO i = 1, lenMIF
      offsets(i) = (i-1)/mfps
   ENDDO

   orbIncline = 98.145

! Get filename from PCF

   SD_VERSION = 1

   returnStatus = Pgs_pc_getReference(SD_OUTFILE, SD_VERSION, physicalFilename)

! Open HDF-SD output file and create empty arrays; calculate # of MAFs in the
! day.

   CALL Sd_create(mifG, lenMIF, mifT, offsetMAF, orbPerDay, physicalFilename, &
                  postMAF, preMAF, scansPerOrb, lenMAF)

   print *, 'Num of MAFs in file = ', lenMAF

! After creation, re-open the HDF file and initialize the SD interface for
! writing

   sd_id = sfstart(physicalFilename, DFACC_WRITE)
   IF (sd_id == -1) THEN
      msr = MLSMSG_Fileopen // physicalFilename
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

! Re-arrange time, number of values into single array for entire file

   ALLOCATE( mafTAI(lenMAF), mafTime(lenMAF), nV(lenMAF), STAT=alloc_err )
   IF ( alloc_err /= 0 ) THEN
      msr = MLSMSG_Allocate // '  time variables.'
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   CALL Time_day(lenMAF, numMIFs, numValues, orbPerDay, postMAF, postTAI, &
                 postTimes, preMAF, preTAI, preTimes, scansPerOrb, scanTAI, &
                 scanTimes, mafTAI, mafTime, nV)

! For first MAF, calculate & write L1BOA data with fill values/settings

   print *, 'Processing MAF 1 ... '

   index%MAFStartTimeUTC = mafTime(1)
   index%MAFStartTimeTAI = mafTAI(1)
   index%noMIFs = nV(1)
   index%counterMAF = 0

   CALL L1boa_fill(altG, altT, ascTAI, dscTAI, sd_id, mifG, mifT, index, 1, &
                   numOrb, offsets, orbIncline, orbitNumber, scRate, scRateT)

! Close the file to set fill values

   status = sfend(sd_id)
   IF (status == -1) THEN
      msr = 'Failed to close file ' // physicalFilename
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

! Re-open the HDF file and initialize the SD interface for writing

   sd_id = sfstart(physicalFilename, DFACC_WRITE)
   IF (sd_id == -1) THEN
      msr = MLSMSG_Fileopen // physicalFilename
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

! For remaining MAFs, calculate & write L1BOA data

   DO i = 2, lenMAF

      print *, 'Processing MAF ', i, ' ... '

      index%MAFStartTimeUTC = mafTime(i)
      index%MAFStartTimeTAI = mafTAI(i)
      index%noMIFs = nV(i)
      index%counterMAF = i-1

      CALL L1boa_nofill(altG, altT, ascTAI, dscTAI, sd_id, mifG, mifT, index, &
                  i, numOrb, offsets, orbIncline, orbitNumber, scRate, scRateT)

   ENDDO

! Terminate access to the SD interface and close the file

   status = sfend(sd_id)
   IF (status == -1) THEN
      msr = 'Failed to close file ' // physicalFilename
      CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
   ENDIF

   DEALLOCATE(offsets, numMIFs, numValues, postTAI, postTimes, preTAI, &
              preTimes, scanTAI, scanTimes, scRate, scRateT, mafTAI, mafTime, &
              nV, STAT=dealloc_err )
   IF ( dealloc_err /= 0 ) CALL MLSMessage(MLSMSG_Error, ModuleName, 'Failed &
                                                               &deallocation.')

! Detailed description of program
! The program creates a SIDS L1BOA SDS-HDF file.  It uses routines such that
! the fill value/modes are set only on writing the first record.

!=====================
END PROGRAM sids_l1boa
!=====================

!# $Log: sids_l1boa.f90,v $
!# Revision 1.2  2000/12/04 18:36:36  pumphrey
!# fixed a tiny bug
!#
!# Revision 1.1  2000/11/30 16:34:27  nakamura
!# The SIDS L1BOA program.
!#
!#
@


1.2
log
@fixed a tiny bug
@
text
@d20 1
a20 1
   "$Id: sids_l1boa.f90,v 1.1 2000/11/30 16:34:27 nakamura Exp $"
d45 2
a46 1
   INTEGER :: minSC, nPhaseG, nPhaseT, numOrb, offsetMAF, opd, orbPerDay
d49 1
a49 1
   INTEGER :: orbitNumber(max_orbits)
d55 3
a57 2
   REAL(r8) :: altG, altT, homeAlt, homeLat, mfps, orbIncline, spm
   REAL(r8) :: ascTAI(max_orbits), dscTAI(max_orbits)
d245 3
@


1.1
log
@The SIDS L1BOA program.
@
text
@d20 1
a20 1
   "$Id: sids_l1boa.f90,v 1.6 2000/06/13 20:04:15 nakamura Exp nakamura $"
d89 6
d242 4
a245 1
!# $Log: $
@

