head	1.2;
access;
symbols
	v5-02-NRT-19:1.2
	v6-00:1.2
	v5-02-NRT-18:1.2
	v5-02:1.2
	v5-01-NRT-17:1.2
	v5-01-NRT-16:1.2
	v5-01-NRT-15:1.2
	v5-01-NRT-14:1.2
	neuralnetworks-1-0:1.2.0.16
	cfm-single-freq-0-1:1.2.0.14
	v5-01:1.2
	v5-00:1.2
	v4-23-TA133:1.2.0.12
	mus-emls-1-70:1.2.0.10
	rel-1-0-englocks-work:1.2.0.8
	VUMLS1-00:1.2
	VPL1-00:1.2
	V4-22-NRT-08:1.2
	VAM1-00:1.2
	V4-21:1.2.0.6
	V4-13:1.2
	V4-12:1.2
	V4-11:1.2
	V4-10:1.2
	V3-43:1.2
	M4-00:1.2
	V3-41:1.2
	V3-40-PlusGM57:1.2.0.4
	V2-24-NRT-04:1.2
	V3-33:1.2
	V2-24:1.2
	V3-31:1.2
	V3-30-NRT-05:1.2
	cfm-01-00:1.2
	V3-30:1.2
	V3-20:1.2
	V3-10:1.2
	V2-23-NRT-02:1.2
	V2-23:1.2
	V2-22-NRT-01:1.2
	V2-22:1.2
	V2-21:1.2
	V2-20:1.2
	V2-11:1.2
	V2-10:1.2
	V2-00:1.2
	V1-51:1.2
	V1-50:1.2
	V1-45:1.2
	V1-44:1.2
	V1-43:1.2
	V1-42:1.2
	V1-41:1.2
	V1-32:1.2
	V1-40:1.2
	V1-31:1.2
	V1-30:1.2
	V1-13:1.2
	V1-12:1.2
	V1-11:1.2
	V1-10:1.2
	newfwm-feb03:1.2.0.2
	V1-04:1.2
	V1-03:1.2
	V1-02:1.2
	V1-00:1.2
	newfwm-sep01:1.1.0.2
	V0-7:1.1
	V0-5-Level2:1.1
	V0-5-SIPS:1.1;
locks; strict;
comment	@# @;


1.2
date	2001.10.11.23.25.08;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.30.16.28.18;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Tidied up a bit
@
text
@
! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module read

  use MLSCommon, only: R8, TAI93_RANGE_T
  use SDPToolkit, only: PGS_S_SUCCESS, PGSD_IO_GEN_RSEQFRM
  implicit none
  private

  public :: READ_UIF, READ_SCAN

  !------------------- RCS Ident Info -----------------------
  character(LEN=130) :: Id = &                                                    
    "$Id: Read.f90,v 1.1 2000/11/30 16:28:18 nakamura Exp $"
  !----------------------------------------------------------
  ! This module contains subroutines related to reading the SIDS L1BOA
  ! User Input File.

  ! Parameters
  character (LEN=*), parameter :: labelFmt = "(A77)"
  integer, parameter :: SIDS_UIF = 322

contains

  !------------------------------------------------Read_UIF -----
  subroutine Read_uif(altG, altT, times, endTime, homeAlt, homeLat, mifG, &
    mifT, mifRate, nPhaseG, nPhaseT, offsetMAF, &
    scansPerOrb, startTime)
    ! This subroutine reads the first (non-scan) portion of the UIF and skims the
    ! scan portion for information needed to allocate variables.
    
    ! Arguments
    type( TAI93_Range_T ), intent(OUT) :: times
    character (LEN=27), intent(OUT) :: endTime, startTime
    integer, intent(OUT) :: mifG, mifT, nPhaseG, nPhaseT
    integer, intent(OUT) :: mifRate, offsetMAF, scansPerOrb
    real(r8), intent(OUT) :: altG, altT, homeAlt, homeLat

    ! Parameters
    character (LEN=*), parameter :: dtFmt = "(A10, 1X, A15)"

    ! Functions
    integer :: Pgs_io_gen_openF, Pgs_io_gen_closeF, Pgs_td_utcToTAI

    ! Variables
    character (LEN=10) :: startDate, endDate
    character (LEN=15) :: startUTC, endUTC
    character (LEN=32) :: mnemonic
    character (LEN=77) :: label
    character (LEN=480) :: msg
    integer :: dur, i, ios, j, processUIF, returnStatus, version

    ! Executable code

    version = 1

    ! Open the UIF as a generic file for reading
    returnStatus = Pgs_io_gen_openF (SIDS_UIF, PGSd_IO_Gen_RSeqFrm, 0, &
      processUIF, version)
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
      print *, 'Error opening UIF:  ', mnemonic
      print *, msg
    endif

    ! Read date/time input
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    if (ios /= 0) print *, 'Error reading UIF file.'
    read(UNIT=processUIF, IOSTAT=ios, FMT=dtFmt) startDate, startUTC

    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=dtFmt) endDate, endUTC

    ! Convert to asciiUTC, TAI formats
    startTime = startDate // 'T' // startUTC // 'Z'
    endTime = endDate // 'T' // endUTC // 'Z'

    returnStatus = Pgs_td_utcToTAI(startTime, times%startTime)
    returnStatus = Pgs_td_utcToTAI(endTime, times%endTime)

    ! Read rest of non-scan input
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) mifRate
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) scansPerOrb
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) offsetMAF
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) homeLat
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) homeAlt

    ! Read GHz scan program input
    do i = 1, 4
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      if ( label(17:24) == 'Geod Alt' ) exit
    enddo

    read(UNIT=processUIF, IOSTAT=ios, FMT=*) altG
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) nPhaseG

    ! Calculate GHz scan length
    mifG = 0
    do i = 1, nPhaseG
      do j = 1, 4
        read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
        if ( label(9:11) == 'Dur' ) exit
      enddo
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) dur
      mifG = mifG + dur
    enddo

    ! Read THz scan program input
    do i = 1, 4
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      if ( label(17:24) == 'Geod Alt' ) exit
    enddo

    read(UNIT=processUIF, IOSTAT=ios, FMT=*) altT

    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
    read(UNIT=processUIF, IOSTAT=ios, FMT=*) nPhaseT

    ! Calculate THz scan length
    mifT = 0
    do i = 1, nPhaseT
      do j = 1, 4
        read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
        if ( label(9:11) == 'Dur' ) exit
      enddo
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) dur
      mifT = mifT + dur
    enddo

    ! Close UIF
    returnStatus = Pgs_io_gen_closeF (processUIF)
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
      print *, 'Error closing UIF:  ', mnemonic
      print *, msg
    endif

    ! Convert km (input) to m (used by Toolkit) for altitudes

    homeAlt = homeAlt * 1000
    altG = altG * 1000
    altT = altT * 1000

  end subroutine Read_uif

  !------------------------------------------- Read_Scan ---------------------
  subroutine Read_scan(mifG, mifT, nPhaseG, nPhaseT, scanRate, scanRateT)
    ! This subroutine reads the second (scan) portion of the UIF and calculates the
    ! GHz and THz scan rates.

    ! Arguments
    integer, intent(IN) :: mifG, mifT, nPhaseG, nPhaseT

    real, intent(OUT) :: scanRate(mifG), scanRateT(mifT)

    ! Functions
    integer :: Pgs_io_gen_openF, Pgs_io_gen_closeF

    ! Variables
    character (LEN=32) :: mnemonic
    character (LEN=77) :: label
    character (LEN=480) :: msg
    integer :: i, ios, processUIF, returnStatus, sum, version
    integer :: dur(nPhaseG)
    integer :: durT(nPhaseT)
    real(r8) :: rate(nPhaseG)
    real(r8) :: rateT(nPhaseT)

    ! Executable code

    version = 1

    ! Open the UIF as a generic file for reading
    returnStatus = Pgs_io_gen_openF (SIDS_UIF, PGSd_IO_Gen_RSeqFrm, 0, &
      processUIF, version)
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
      print *, 'Error opening UIF:  ', mnemonic
      print *, msg
    endif

    ! Find scan program phase section
    do i = 1, 20
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      if ( label(16:22) == 'Phases' ) exit
    enddo

    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label

    ! Read GHz scan information
    sum = 0
    do i = 1, nPhaseG
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) rate(i)
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) dur(i)

      ! Calculate GHz rate information
      scanRate(sum+1:sum+dur(i)) = rate(i)
      sum = sum + dur(i)
    enddo

    ! Find scan program phase section for THz
    do i = 1, 5
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      if ( label(16:22) == 'Phases' ) exit
    enddo
    read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label

    ! Read THz scan information
    sum = 0
    do i = 1, nPhaseT
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) rateT(i)
      read(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      read(UNIT=processUIF, IOSTAT=ios, FMT=*) durT(i)
      ! Calculate THz rate information
      scanRateT(sum+1:sum+durT(i)) = rateT(i)
      sum = sum + durT(i)
    enddo

    ! Close UIF
    returnStatus = Pgs_io_gen_closeF (processUIF)
    if (returnStatus /= PGS_S_SUCCESS) then
      call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
      print *, 'Error closing UIF:  ', mnemonic
      print *, msg
    endif

  end subroutine Read_scan

end module read

! $Log: Read.f90,v $
! Revision 1.1  2000/11/30 16:28:18  nakamura
! Module for reading the SIDS L1BOA User Input File.
@


1.1
log
@Module for reading the SIDS L1BOA User Input File.
@
text
@d5 1
a5 3
!===============================================================================
MODULE Read
!===============================================================================
d7 238
a244 312
   USE MLSCommon
   USE SDPToolkit
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &                                                    
   "$Id: Read.f90,v 1.8 2000/02/23 18:39:31 nakamura Exp nakamura $"
!----------------------------------------------------------

! Contents:

! Subroutines -- Read_uif
!                Read_scan

! Remarks:  This module contains subroutines related to reading the SIDS L1BOA
!           User Input File.

! Parameters

   CHARACTER (LEN=*), PARAMETER :: labelFmt = "(A77)"

   INTEGER, PARAMETER :: SIDS_UIF = 322

CONTAINS

!---------------------------------------------------------------------------
   SUBROUTINE Read_uif(altG, altT, times, endTime, homeAlt, homeLat, mifG, &
                       mifT, mifRate, nPhaseG, nPhaseT, offsetMAF, &
                       scansPerOrb, startTime)
!---------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine reads the first (non-scan) portion of the UIF and skims the
! scan portion for information needed to allocate variables.

! Arguments

      TYPE( TAI93_Range_T ), INTENT(OUT) :: times

      CHARACTER (LEN=27), INTENT(OUT) :: endTime, startTime

      INTEGER, INTENT(OUT) :: mifG, mifT, nPhaseG, nPhaseT
      INTEGER, INTENT(OUT) :: mifRate, offsetMAF, scansPerOrb

      REAL(r8), INTENT(OUT) :: altG, altT, homeAlt, homeLat

! Parameters

      CHARACTER (LEN=*), PARAMETER :: dtFmt = "(A10, 1X, A15)"

! Functions

      INTEGER :: Pgs_io_gen_openF, Pgs_io_gen_closeF, Pgs_td_utcToTAI

! Variables

      CHARACTER (LEN=10) :: startDate, endDate
      CHARACTER (LEN=15) :: startUTC, endUTC
      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=77) :: label
      CHARACTER (LEN=480) :: msg

      INTEGER :: dur, i, ios, j, processUIF, returnStatus, version

      version = 1

! Open the UIF as a generic file for reading

      returnStatus = Pgs_io_gen_openF (SIDS_UIF, PGSd_IO_Gen_RSeqFrm, 0, &
                                       processUIF, version)
      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         print *, 'Error opening UIF:  ', mnemonic
         print *, msg
      ENDIF
 
! Read date/time input

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      IF (ios /= 0) print *, 'Error reading UIF file.'
      READ(UNIT=processUIF, IOSTAT=ios, FMT=dtFmt) startDate, startUTC

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=dtFmt) endDate, endUTC

! Convert to asciiUTC, TAI formats

      startTime = startDate // 'T' // startUTC // 'Z'
      endTime = endDate // 'T' // endUTC // 'Z'

      returnStatus = Pgs_td_utcToTAI(startTime, times%startTime)
      returnStatus = Pgs_td_utcToTAI(endTime, times%endTime)

! Read rest of non-scan input

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) mifRate

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) scansPerOrb

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) offsetMAF

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) homeLat

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) homeAlt

! Read GHz scan program input

      DO i = 1, 4
         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         IF ( label(17:24) == 'Geod Alt' ) EXIT
      ENDDO

      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) altG

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) nPhaseG

! Calculate GHz scan length

      mifG = 0

      DO i = 1, nPhaseG

         DO j = 1, 4
            READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
            IF ( label(9:11) == 'Dur' ) EXIT
         ENDDO

         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) dur

         mifG = mifG + dur

      ENDDO
      
! Read THz scan program input

      DO i = 1, 4
         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         IF ( label(17:24) == 'Geod Alt' ) EXIT
      ENDDO

      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) altT

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
      READ(UNIT=processUIF, IOSTAT=ios, FMT=*) nPhaseT

! Calculate THz scan length

      mifT = 0

      DO i = 1, nPhaseT

         DO j = 1, 4
            READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
            IF ( label(9:11) == 'Dur' ) EXIT
         ENDDO

         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) dur

         mifT = mifT + dur

      ENDDO

! Close UIF

      returnStatus = Pgs_io_gen_closeF (processUIF)
      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         print *, 'Error closing UIF:  ', mnemonic
         print *, msg
      ENDIF

! Convert km (input) to m (used by Toolkit) for altitudes

      homeAlt = homeAlt * 1000
      altG = altG * 1000
      altT = altT * 1000

!-------------------------
   END SUBROUTINE Read_uif
!-------------------------

!-------------------------------------------------------------------------
   SUBROUTINE Read_scan(mifG, mifT, nPhaseG, nPhaseT, scanRate, scanRateT)
!-------------------------------------------------------------------------

! Brief description of subroutine
! This subroutine reads the second (scan) portion of the UIF and calculates the
! GHz and THz scan rates.

! Arguments

      INTEGER, INTENT(IN) :: mifG, mifT, nPhaseG, nPhaseT

      REAL, INTENT(OUT) :: scanRate(mifG), scanRateT(mifT)
 
! Parameters

! Functions

      INTEGER :: Pgs_io_gen_openF, Pgs_io_gen_closeF

! Variables

      CHARACTER (LEN=32) :: mnemonic
      CHARACTER (LEN=77) :: label
      CHARACTER (LEN=480) :: msg

      INTEGER :: i, ios, processUIF, returnStatus, sum, version
      INTEGER :: dur(nPhaseG)
      INTEGER :: durT(nPhaseT)

      REAL(r8) :: rate(nPhaseG)
      REAL(r8) :: rateT(nPhaseT)

      version = 1

! Open the UIF as a generic file for reading

      returnStatus = Pgs_io_gen_openF (SIDS_UIF, PGSd_IO_Gen_RSeqFrm, 0, &
                                       processUIF, version)
      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         print *, 'Error opening UIF:  ', mnemonic
         print *, msg
      ENDIF
 
! Find scan program phase section

      DO i = 1, 20
         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         IF ( label(16:22) == 'Phases' ) EXIT
      ENDDO

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label

! Read GHz scan information

      sum = 0

      DO i = 1, nPhaseG

         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) rate(i)

         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) dur(i)

! Calculate GHz rate information

         scanRate(sum+1:sum+dur(i)) = rate(i)

         sum = sum + dur(i)

      ENDDO

! Find scan program phase section for THz

      DO i = 1, 5
         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         IF ( label(16:22) == 'Phases' ) EXIT
      ENDDO

      READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label

! Read THz scan information

      sum = 0

      DO i = 1, nPhaseT

         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) rateT(i)

         READ(UNIT=processUIF, IOSTAT=ios, FMT=labelFmt) label
         READ(UNIT=processUIF, IOSTAT=ios, FMT=*) durT(i)

! Calculate THz rate information

         scanRateT(sum+1:sum+durT(i)) = rateT(i)

         sum = sum + durT(i)

      ENDDO

! Close UIF

      returnStatus = Pgs_io_gen_closeF (processUIF)
      IF (returnStatus /= PGS_S_SUCCESS) THEN
         call Pgs_smf_getMsg(returnStatus, mnemonic, msg)
         print *, 'Error closing UIF:  ', mnemonic
         print *, msg
      ENDIF

!--------------------------
   END SUBROUTINE Read_scan
!--------------------------

!==============
END MODULE Read
!==============

!# $Log: $
!#
@

