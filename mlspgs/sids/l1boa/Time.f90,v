head	1.7;
access;
symbols
	v5-02-NRT-19:1.7
	v6-00:1.7
	v5-02-NRT-18:1.7
	v5-02:1.7
	v5-01-NRT-17:1.7
	v5-01-NRT-16:1.7
	v5-01-NRT-15:1.7
	v5-01-NRT-14:1.7
	neuralnetworks-1-0:1.7.0.16
	cfm-single-freq-0-1:1.7.0.14
	v5-01:1.7
	v5-00:1.7
	v4-23-TA133:1.7.0.12
	mus-emls-1-70:1.7.0.10
	rel-1-0-englocks-work:1.7.0.8
	VUMLS1-00:1.7
	VPL1-00:1.7
	V4-22-NRT-08:1.7
	VAM1-00:1.7
	V4-21:1.7.0.6
	V4-13:1.7
	V4-12:1.7
	V4-11:1.7
	V4-10:1.7
	V3-43:1.7
	M4-00:1.7
	V3-41:1.7
	V3-40-PlusGM57:1.7.0.4
	V2-24-NRT-04:1.7
	V3-33:1.7
	V2-24:1.7
	V3-31:1.7
	V3-30-NRT-05:1.7
	cfm-01-00:1.7
	V3-30:1.7
	V3-20:1.7
	V3-10:1.7
	V2-23-NRT-02:1.7
	V2-23:1.7
	V2-22-NRT-01:1.7
	V2-22:1.7
	V2-21:1.7
	V2-20:1.7
	V2-11:1.7
	V2-10:1.7
	V2-00:1.7
	V1-51:1.7
	V1-50:1.7
	V1-45:1.7
	V1-44:1.7
	V1-43:1.7
	V1-42:1.7
	V1-41:1.7
	V1-32:1.7
	V1-40:1.7
	V1-31:1.7
	V1-30:1.7
	V1-13:1.7
	V1-12:1.7
	V1-11:1.7
	V1-10:1.7
	newfwm-feb03:1.7.0.2
	V1-04:1.7
	V1-03:1.7
	V1-02:1.7
	V1-00:1.7
	newfwm-sep01:1.1.0.2
	V0-7:1.1
	V0-5-Level2:1.1
	V0-5-SIPS:1.1;
locks; strict;
comment	@# @;


1.7
date	2001.12.11.00.54.36;	author livesey;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.08.23.29.34;	author pwagner;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.08.00.46.48;	author pwagner;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.06.01.02.30;	author pwagner;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.04.00.25.25;	author pwagner;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.11.23.27.23;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.30.16.31.13;	author nakamura;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Fixed bug with first and last orbits, (actully problem with noMIFs
that was the case for all orbits, but only visible on first and last).
@
text
@! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

module Time

  use MLSCommon, only: R8, TAI93_RANGE_T
  use MLSMessageModule, only: MLSMSG_ALLOCATE, MLSMSG_DeAllocate, &
    & MLSMSG_ERROR, MLSMSG_WARNING, MLSMESSAGE
  use SDPToolkit, only: PI, EARTHMODEL
  use Output_m, only: BLANKS, OUTPUT
  use OutputL1B, only: L1BOASC_T, LENCOORD
  use Scan, only: SCAN_GUESS
  use TkL1B, only: TKL1B_SC
  use Dump_0, only: Dump
  implicit none
  private

  public :: TIME_LAT, TIME_SEARCH, TIME_MAF, TIME_PRE, TIME_DAY, TIME_POST

  !------------------- RCS Ident Info -----------------------
  character(LEN=130) :: Id = &
    "$Id: Time.f90,v 1.6 2001/12/08 23:29:34 pwagner Exp $"
  character (LEN=*), parameter :: ModuleName= "$RCSfile: Time.f90,v $"
  !----------------------------------------------------------

  ! This module contains subroutines needed to calculate time
  ! information for the MLS scan programs.

  ! Parameters
  integer, parameter :: N_RECORDS = 148

contains

  !--------------------------------------------------------- Time_Lat ----
  subroutine Time_lat(asciiUTC, homeAlt, tpLat, converge)

    ! This subroutine takes an initial-guess view vector and iteratively runs the
    ! toolkit GrazingRay routine to find the actual view vector for a given
    ! tangent height.  The returned value is the latitude for the view vector.

    ! Arguments
    character(LEN=27), intent(IN) :: asciiUTC
    real(r8), intent(IN) :: homeAlt
    integer, intent(OUT) :: converge
    real(r8), intent(OUT) :: tpLat

    ! Parameters
    integer, parameter :: numValues = 1

    ! Functions
    integer :: Pgs_csc_geoToECR, Pgs_csc_grazingRay

    ! Variables
    type( L1BOAsc_T ) :: sc
    character (LEN=480) :: msr
    integer :: error, i, returnStatus
    real(r8) :: longitude, missAltitude, slantRange
    real(r8) :: ecr(3), initGuess(3), posNear(3), posSurf(3), ray(3)
    real(r8) :: time_offset(numValues)

    ! Executable code

    time_offset(numValues) = 0.0

    ! Get initial guess look-vector, initial s/c position, initial tp info
    call Scan_guess(asciiUTC, initGuess)

    allocate(sc%scECI(lenCoord,numValues), sc%scECR(lenCoord,numValues), &
      sc%scGeocAlt(numValues), sc%scGeocLat(numValues), &
      sc%scGeodAlt(numValues), sc%scGeodLat(numValues), sc%scLon(numValues), &
      sc%scGeodAngle(numValues), sc%scVelECI(lenCoord,numValues), &
      sc%scVelECR(lenCoord,numValues), sc%scOrbIncl(numValues), &
      sc%ypr(lenCoord,numValues), sc%yprRate(lenCoord,numValues), STAT=error)
    if ( error /= 0 ) then
      msr = MLSMSG_Allocate // '  s/c quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    call TkL1B_sc(numValues, time_offset, asciiUTC, sc)

    returnStatus = Pgs_csc_grazingRay(earthModel, sc%scECR, initGuess, &
      tpLat, longitude, missAltitude, slantRange, posNear, posSurf)

    ! Iterations on view vector to see given tangent height
    converge = -1
    do i = 1, 8
      if ( abs(missAltitude - homeAlt) < 1.0 ) then
        converge = 1
        exit
      endif
      returnStatus = Pgs_csc_geoToECR(longitude, tpLat, homeAlt, &
        earthModel, ecr)
      ray = ecr - sc%scECR(:,1)
      returnStatus = Pgs_csc_grazingRay(earthModel, sc%scECR, ray, tpLat, &
        longitude, missAltitude, slantRange, posNear, posSurf)
    enddo

    ! Not sure why these weren't deallocated
    ! but better late than never (pw)
    deallocate( sc%scECI, sc%scECR, sc%scGeocAlt, sc%scGeocLat, &
      sc%scGeodAlt, sc%scGeodLat, sc%scLon, &
      sc%scGeodAngle, sc%scOrbIncl, sc%scVelECI, &
      sc%scVelECR, &
      sc%ypr, sc%yprRate, &
      & STAT=error )
    if ( error /= 0 ) then
      msr = MLSMSG_DeAllocate // ' Failed to deallocate s/c quantities.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

  end subroutine Time_lat

  !--------------------------------------------- Time_Search -------------
  subroutine Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
    finalTime, finalTAI, finalLat)
    ! This program calculates the MIF starting times for the orbits.

    ! Arguments
    character (LEN=27), intent(IN) :: estTime
    integer, intent(IN) :: scansPerOrb
    real(r8), intent(IN) :: homeAlt, homeLat, spm
    character (LEN=27), intent(OUT) :: finalTime
    real(r8), intent(OUT) :: finalLat, finalTAI

    ! Parameters
    character (LEN=*), parameter :: GR_ERR = 'Iterations timed out before &
      &height converged for '

    ! Functions
    integer :: Pgs_td_utcToTAI, Pgs_td_taiToUTC

    ! Variables
    character (LEN=27) :: timeF
    character (LEN=480) :: msg

    integer :: back, converge, i, returnStatus

    real(r8) :: estTAI93, latE, latF, tai

    ! Exectuable code

    finalTime = estTime

    ! Get tp info for estTime
    call Time_lat(estTime, homeAlt, latE, converge)
    if ( converge /= 1 ) then
      msg = GR_ERR // estTime
      call MLSMessage(MLSMSG_Warning, ModuleName, msg)
    endif

    returnStatus = Pgs_td_utcToTAI (estTime, estTAI93)

    ! Set search direction
    if (latE < homeLat) then
      back = -1
    else
      back = 1
    endif

    ! Check determined direction in MIF steps
    do i = 1, scansPerOrb*N_RECORDS
      tai = estTAI93 - back * spm
      returnStatus = Pgs_td_taiToUTC(tai, timeF)
      call Time_lat(timeF, homeAlt, latF, converge)
      if ( converge /= 1 ) then
        msg = GR_ERR // timeF
        call MLSMessage(MLSMSG_Warning, ModuleName, msg)
        exit
      endif
      if ( abs(latF - homeLat) >= abs(latE - homeLat) ) then
        exit
      else
        latE = latF
        estTAI93 = tai
        finalTime = timeF
      endif
    enddo

    ! Add an MIF, if closest lat found is below homeLat
    if (latE < homeLat) then
      tai = estTAI93 + spm
      returnStatus = Pgs_td_taiToUTC(tai, timeF)
      call Time_lat(timeF, homeAlt, latF, converge)
      if ( converge /= 1 ) then
        msg = GR_ERR // timeF
        call MLSMessage(MLSMSG_Warning, ModuleName, msg)
      endif
      latE = latF
      estTAI93 = tai
      finalTime = timeF
    endif
    finalLat = latE
    finalTAI = estTAI93

  end subroutine Time_search

  !-------------------------------------------------- Time_MAF ------------------
  subroutine Time_MAF(startTime, times, homeAlt, homeLat, mifRate, &
    scansPerOrb, spm, scanTimes, scanTAI, numMIFs, orbPerDay)
    ! This program calculates the starting times for the orbits and their scans,
    ! and the number of MIFs per MAF.

    ! Arguments
    type( TAI93_Range_T ), intent(IN) :: times
    character (LEN=27), intent(IN) :: startTime
    integer, intent(IN) :: mifRate, scansPerOrb
    real(r8), intent(IN) :: homeAlt, homeLat, spm
    character (LEN=27), intent(OUT) :: scanTimes(:,:)
    integer, intent(OUT) :: orbPerDay
    integer, intent(INOUT) :: numMIFs(:,:)
    real(r8), intent(OUT) :: scanTAI(:,:)

    ! Parameters
    character (LEN=*), parameter ::GR_ERR = 'Iterations timed out before &
      &height converged for '
    real(r8), parameter :: minPerOrb = 98.9

    ! Functions
    integer :: Pgs_td_taiToUTC

    ! Variables
    character (LEN=27) :: estTime, timeF
    character (LEN=27), allocatable :: orbTime(:)
    character (LEN=480) :: msg, msr
    integer :: alloc_err, ascend, converge, dealloc_err, delMIF, delOrb, i, j
    integer :: k, opd, returnStatus
    real(r8) :: delAngle, delMAF, delTime, estLat, latF, orbRate, startLat
    real(r8) :: tai
    real(r8), allocatable :: orbTAI(:)

    ! Exectuable code

    orbRate = minPerOrb * 60 / (2*PI)
    delOrb = aint(minPerOrb * 60 * mifRate)
    opd = size(scanTimes,2)
    allocate( orbTime(opd), orbTAI(opd), STAT=alloc_err )
    if ( alloc_err /= 0 ) then
      msr = MLSMSG_Allocate // '  orbit variables.'
      call MLSMessage(MLSMSG_Error, ModuleName, msr)
    endif

    ! Get tp info for startTime
    call Time_lat(startTime, homeAlt, startLat, converge)
    if ( converge /= 1 ) then
      msg = GR_ERR // startTime
      call MLSMessage(MLSMSG_Warning, ModuleName, msg)
    endif

    ! Find whether ascending or descending at startTime
    ascend = -1
    tai = times%startTime + spm
    returnStatus = Pgs_td_taiToUTC(tai, timeF)
    call Time_lat(timeF, homeAlt, latF, converge)
    if ( converge /= 1 ) then
      msg = GR_ERR // timeF
      call MLSMessage(MLSMSG_Warning, ModuleName, msg)
    endif
    if ( (latF - startLat) > 0 ) ascend = 1

    ! Estimate MIF time of nearest ascending homeLat crossing
    if (ascend == 1) then
      if ( homeLat >= startLat ) then
        delAngle = homeLat - startLat
      else
        delAngle = 2*PI + homeLat - startLat
      endif
    else
      delAngle = PI + homeLat + startLat
    endif

    delTime = delAngle * orbRate
    delMIF = aint(delTime * mifRate)
    tai = times%startTime + delMIF * spm
    returnStatus = Pgs_td_taiToUTC(tai, estTime)

    ! Find MIF time of nearest ascending homeLat crossing
    orbTAI = 0.0

    call Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
      orbTime(1), orbTAI(1), estLat)

    ! Estimate time of remaining orbit crossings
    do i = 2, opd
      tai = orbTAI(i-1) + delOrb * spm
      if ( tai > times%endTime) then
        orbTAI(i) = 0.0
        orbPerDay = i-1
        exit
      endif
      returnStatus = Pgs_td_taiToUTC( tai, estTime)
      call Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
        orbTime(i), orbTAI(i), estLat)
      if ( orbTAI(i) > times%endTime) then
        orbTAI(i) = 0.0
        orbPerDay = i-1
        exit
      endif
    enddo

    ! Divide orbits into 240 MAFs
    scanTAI = 0.0
    do i = 1, orbPerDay
      if ( orbTAI(i+1) /= 0.0 ) then
        delMAF = ( orbTAI(i+1) - orbTAI(i) ) / scansPerOrb
        do j = 1, scansPerOrb
          delMIF = anint( (j-1) * delMAF * mifRate )
          scanTAI(j,i) = orbTAI(i) + delMIF * spm
          returnStatus = Pgs_td_taiToUTC( scanTAI(j,i), scanTimes(j,i) )
        enddo
      else
        scanTAI(1,i) = orbTAI(i)
        scanTimes(1,i) = orbTime(i)
        exit
      endif
    enddo

    ! Calculate number of MIFs
    do i = 1, orbPerDay-1
      do j = 1, scansPerOrb
        if ( j /= scansPerOrb) then
          numMIFs(j,i) = nint ( ( scanTAI(j+1,i) - scanTAI(j,i) ) / spm )
        else 
          numMIFs(j,i) = nint ( ( scanTAI(1,i+1) - scanTAI(j,i) ) / spm )
        endif
      enddo
    enddo

    deallocate( orbTime, orbTAI, STAT=dealloc_err )
    if ( dealloc_err /= 0 ) call MLSMessage(MLSMSG_Warning, ModuleName, &
      'Failed deallocation of orbit variables.')

  end subroutine Time_MAF

  !-------------------------------------------- Time_Pre -----------------
  subroutine Time_pre(numValues, orbTime, startTAI, scansPerOrb, spm, &
    preTimes, preTAI, numMIFs, preMAF)

    ! This subroutine fills in the time gap for a partial orbit at the beginning of
    ! a file.  It duplicates the scan pattern for the first MAF of the first full
    ! orbit.

    ! Arguments
    character(LEN=27), intent(IN) :: orbTime
    integer, intent(IN) :: scansPerOrb
    integer, intent(IN) :: numValues(scansPerOrb)
    real(r8), intent(IN) :: spm, startTAI
    character(LEN=27), intent(OUT) :: preTimes(scansPerOrb)
    integer, intent(OUT) :: preMAF
    integer, intent(OUT) :: numMIFs(scansPerOrb)
    real(r8), intent(OUT) :: preTAI(scansPerOrb)

    ! Functions
    integer :: Pgs_td_utcToTAI, Pgs_td_taiToUTC

    ! Variables
   
    character(LEN=27) :: backTimes(scansPerOrb)
    integer :: i, returnStatus
    real(r8) :: mafTAI, orbTAI
    real(r8) :: backTAI(scansPerOrb)

    ! Executable code

    preMAF = 0

    ! Calculate MAF times prior to first full orbit
    returnStatus = Pgs_td_utcToTAI (orbTime, orbTAI)
    mafTAI = orbTAI
    do i = 1, scansPerOrb
      mafTAI = mafTAI - numValues(scansPerOrb - (i-1))*spm
      if ( mafTAI < startTAI ) exit
      returnStatus = Pgs_td_taiToUTC( mafTAI, backTimes(i) )
      backTAI(i) = mafTAI
      preMAF = i
    enddo

    ! Reverse numbering of MAF times, numValues
    do i = 1, preMAF
      preTimes(i) = backTimes( preMAF - (i-1) )
      preTAI(i)   = backTAI ( preMAF - (i-1) )
      numMIFs(i) = numValues( scansPerOrb - (preMAF - i) )
    end do

  end subroutine Time_pre

  !--------------------------------------------Time_Pos ------------------
  subroutine Time_post(numValues, orbTime, endTAI, scansPerOrb, spm, &
    postTimes, postTAI, postMAF)
    ! This subroutine fills in the time gap for a partial orbit at the end of a
    ! file.  It duplicates the scan pattern for the last MAF of the last full
    ! orbit.

    ! Arguments
    character(LEN=27), intent(IN) :: orbTime
    integer, intent(IN) :: scansPerOrb
    integer, intent(IN) :: numValues(scansPerOrb)
    real(r8), intent(IN) :: endTAI, spm
    character(LEN=27), intent(OUT) :: postTimes(scansPerOrb)
    integer, intent(OUT) :: postMAF
    real(r8), intent(OUT) :: postTAI(scansPerOrb)

    ! Functions
    integer :: Pgs_td_utcToTAI, Pgs_td_taiToUTC

    ! Variables

    integer :: i, returnStatus
    real(r8) :: orbTAI, mafTAI

    ! Executable code

    postMAF = 0

    ! Calculate MAF times after the last full orbit
    returnStatus = Pgs_td_utcToTAI (orbTime, orbTAI)
    mafTAI = orbTAI
    do i = 1, scansPerOrb
      mafTAI = mafTAI + numValues(i)*spm
      if ( mafTAI > endTAI ) exit
      returnStatus = Pgs_td_taiToUTC( mafTAI, postTimes(i+1) )
      postTAI(i+1) = mafTAI
      postMAF = i + 1
    enddo

    postTimes(1) = orbTime
    postTAI(1) = orbTAI

  end subroutine Time_post

  !------------------------------------ Time_Day -----------------------------
  subroutine Time_day(lenMAF, numMIFs, numValues, orbPerDay, postMAF, &
    postTAI, postTimes, preMAF, preTAI, preTimes, &
    scansPerOrb, scanTAI, scanTimes, mafTAI, mafTime, nV)
    ! This program reorganizes the various time arrays into a single array for the
    ! entire day/file.

    ! Arguments
    integer, intent(IN) :: lenMAF, postMAF, preMAF, orbPerDay, scansPerOrb
    character (LEN=27), intent(IN) :: postTimes(postMAF)
    character (LEN=27), intent(IN) :: preTimes(preMAF)
    character (LEN=27), intent(IN) :: scanTimes(scansPerOrb,orbPerDay)
    integer, intent(IN) :: numMIFs(preMAF)
    integer, intent(IN) :: numValues(scansPerOrb,orbPerDay)
    real(r8), intent(IN) :: postTAI(postMAF)
    real(r8), intent(IN) :: preTAI(preMAF)
    real(r8), intent(IN) :: scanTAI(scansPerOrb,orbPerDay)
    character (LEN=27), intent(OUT) :: mafTime(lenMAF)
    integer, intent(OUT) :: nV(lenMAF)
    real(r8), intent(OUT) :: mafTAI(lenMAF)

    ! Variables
    integer :: i, j, k

    ! Executable code

    ! MAFs prior to first full orbit
    do i = 1, preMAF
      if ( i > lenMAF ) exit
      nV(i) = numMIFs(i)
      mafTime(i) = preTimes(i)
      mafTAI(i) = preTAI(i)
    enddo

    ! MAFs for full orbits
    do i = 1, orbPerDay-1
      do j = 1, scansPerOrb

        k = j + (i-1)*scansPerOrb + preMAF
        if ( k > lenMAF ) exit

        nV(k) = numValues(j,i)
        mafTime(k) = scanTimes(j,i)
        mafTAI(k) = scanTAI(j,i)

      enddo
    enddo

    ! MAFs after last full orbit
    do i = 1, postMAF
      j = i + (orbPerDay-1)*scansPerOrb + preMAF
      if ( j > lenMAF ) exit

      nV(j) = numValues(i,orbPerDay-1)
      mafTime(j) = postTimes(i)
      mafTAI(j) = postTAI(i)
    enddo

  end subroutine Time_day

end module Time

! $Log: Time.f90,v $
! Revision 1.6  2001/12/08 23:29:34  pwagner
! Reset DEBUG params to FALSE
!
! Revision 1.5  2001/12/08 00:46:48  pwagner
! ADDEXTRAMIF in Time_pre and Time_post; debugging stuff(latter should be ousted)
!
! Revision 1.4  2001/12/06 01:02:30  pwagner
! Now writes orbit incline angle in ECR
!
! Revision 1.3  2001/12/04 00:25:25  pwagner
! sc%scvelECI is new name of scvel
!
! Revision 1.2  2001/10/11 23:27:23  livesey
! Tried to change the chmod stuff
!
! Revision 1.1  2000/11/30 16:31:13  nakamura
! Module for calculating time information for the MLS scan programs.
@


1.6
log
@Reset DEBUG params to FALSE
@
text
@d14 1
d22 1
a22 1
    "$Id: Time.f90,v 1.5 2001/12/08 00:46:48 pwagner Exp $"
d210 1
a210 1
    integer, intent(OUT) :: numMIFs(:,:)
d321 1
a321 4
          do k = 1, N_RECORDS
            if ( scanTAI(j,i) + k*spm > scanTAI(j+1,i) ) exit
            numMIFs(j,i) = k
          enddo
d323 1
a323 4
          do k = 1, N_RECORDS
            if ( ( scanTAI(j,i) + k*spm ) > scanTAI(1,i+1) ) exit
            numMIFs(j,i) = k
          enddo
a355 2
    logical, parameter :: DEBUG = .FALSE.
    logical, parameter :: ADDEXTRAMIF = .TRUE.
a370 10
      if ( ADDEXTRAMIF ) mafTAI = mafTAI - spm
      if ( DEBUG  ) then
        call output('scan Number ', advance='no')
        call blanks(3, advance='no')
        call output(i, advance='no')
        call blanks(3, advance='no')
        call output('dt', advance='no')
        call blanks(3, advance='no')
        call output(mafTAI - startTAI, advance='yes')
      endif
a377 5
    if ( DEBUG ) then
      call output('Num of MAFs prior to first full orbit', advance='no')
      call blanks(3, advance='no')
      call output(preMAF, advance='yes')
    endif
d380 1
a380 1
      preTAI(i)   = backTAI (preMAF - (i-1) )
d382 1
a382 19
! Warning: The following was removed because it made a subscript
! go out of bounds in l1boa_fill
! However, w/o it the numbers won't add up
!      if ( ADDEXTRAMIF ) numMIFs(i) = numMIFs(i) + 1
      if ( DEBUG .and. i > 1) then
        call output('Major Frame ', advance='no')
        call blanks(3, advance='no')
        call output(i, advance='no')
        call blanks(3, advance='no')
        call output('Num of MIFs', advance='no')
        call blanks(3, advance='no')
        call output(numMIFs(i), advance='no')
        call blanks(3, advance='no')
        call output('delta time TAI', advance='no')
        call blanks(3, advance='no')
        call output(preTAI(i) - preTAI(i-1), advance='no')
        call blanks(3, advance='yes')
      endif
    enddo
a405 1
    logical, parameter :: ADDEXTRAMIF = .TRUE.
a418 1
      if ( ADDEXTRAMIF ) mafTAI = mafTAI + spm
d493 3
@


1.5
log
@ADDEXTRAMIF in Time_pre and Time_post; debugging stuff(latter should be ousted)
@
text
@d1 1
a1 2

! Copyright (c) 2000, California Institute of Technology.  ALL RIGHTS RESERVED.
d21 1
a21 1
    "$Id: Time.f90,v 1.4 2001/12/06 01:02:30 pwagner Exp $"
d361 1
a361 1
    logical, parameter :: DEBUG = .TRUE.
d535 3
@


1.4
log
@Now writes orbit incline angle in ECR
@
text
@d11 1
d22 1
a22 1
    "$Id: Time.f90,v 1.3 2001/12/04 00:25:25 pwagner Exp $"
d362 3
d379 10
d396 5
d405 18
d447 2
d461 1
d536 3
@


1.3
log
@sc%scvelECI is new name of scvel
@
text
@d8 2
a9 2
  use MLSMessageModule, only: MLSMSG_ALLOCATE, MLSMSG_ERROR, &
    & MLSMSG_WARNING, MLSMESSAGE
d21 1
a21 1
    "$Id: Time.f90,v 1.2 2001/10/11 23:27:23 livesey Exp $"
d71 1
d97 13
d496 3
@


1.2
log
@Tried to change the chmod stuff
@
text
@d21 1
a21 1
    "$Id: Time.f90,v 1.1 2000/11/30 16:31:13 nakamura Exp $"
d70 1
a70 1
      sc%scGeodAngle(numValues), sc%scVel(lenCoord,numValues), &
d482 3
@


1.1
log
@Module for calculating time information for the MLS scan programs.
@
text
@d5 1
a5 307
!===============================================================================
MODULE Time
!===============================================================================

   USE MLSCommon
   USE MLSMessageModule
   USE Scan
   USE TkL1B
   IMPLICIT NONE
   PUBLIC

   PRIVATE :: ID, ModuleName

!------------------- RCS Ident Info -----------------------
   CHARACTER(LEN=130) :: Id = &
   "$Id: Time.f90,v 1.8 2000/02/16 16:00:32 nakamura Exp nakamura $"
   CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile: Time.f90,v $"
!----------------------------------------------------------

! Contents:

! Subroutines -- Time_lat
!                Time_search
!                Time_MAF
!                Time_pre
!                Time_post
!                Time_day

! Remarks:  This module contains subroutines needed to calculate time
!           information for the MLS scan programs.

! Parameters

   INTEGER, PARAMETER :: N_RECORDS = 148

CONTAINS

!---------------------------------------------------------
   SUBROUTINE Time_lat(asciiUTC, homeAlt, tpLat, converge)
!---------------------------------------------------------

! Brief description of subroutine
! This subroutine takes an initial-guess view vector and iteratively runs the
! toolkit GrazingRay routine to find the actual view vector for a given
! tangent height.  The returned value is the latitude for the view vector.

! Arguments

      CHARACTER(LEN=27), INTENT(IN) :: asciiUTC

      REAL(r8), INTENT(IN) :: homeAlt

      INTEGER, INTENT(OUT) :: converge

      REAL(r8), INTENT(OUT) :: tpLat

! Parameters

      INTEGER, PARAMETER :: numValues = 1

! Functions

      INTEGER :: Pgs_csc_geoToECR, Pgs_csc_grazingRay

! Variables

      TYPE( L1BOAsc_T ) :: sc

      CHARACTER (LEN=480) :: msr

      INTEGER :: error, i, returnStatus

      REAL(r8) :: longitude, missAltitude, slantRange
      REAL(r8) :: ecr(3), initGuess(3), posNear(3), posSurf(3), ray(3)
      REAL(r8) :: time_offset(numValues)

      time_offset(numValues) = 0.0

! Get initial guess look-vector, initial s/c position, initial tp info

      CALL Scan_guess(asciiUTC, initGuess)

      ALLOCATE(sc%scECI(lenCoord,numValues), sc%scECR(lenCoord,numValues), &
       sc%scGeocAlt(numValues), sc%scGeocLat(numValues), &
       sc%scGeodAlt(numValues), sc%scGeodLat(numValues), sc%scLon(numValues), &
       sc%scGeodAngle(numValues), sc%scVel(lenCoord,numValues), &
       sc%ypr(lenCoord,numValues), sc%yprRate(lenCoord,numValues), STAT=error)
      IF ( error /= 0 ) THEN
         msr = MLSMSG_Allocate // '  s/c quantities.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

      CALL TkL1B_sc(numValues, time_offset, asciiUTC, sc)

      returnStatus = Pgs_csc_grazingRay(earthModel, sc%scECR, initGuess, &
                  tpLat, longitude, missAltitude, slantRange, posNear, posSurf)

! Iterations on view vector to see given tangent height

      converge = -1

      DO i = 1, 8

         IF ( ABS(missAltitude - homeAlt) < 1.0 ) THEN
            converge = 1
            EXIT
         ENDIF

         returnStatus = Pgs_csc_geoToECR(longitude, tpLat, homeAlt, &
                                         earthModel, ecr)

         ray = ecr - sc%scECR(:,1)

         returnStatus = Pgs_csc_grazingRay(earthModel, sc%scECR, ray, tpLat, &
                         longitude, missAltitude, slantRange, posNear, posSurf)

      ENDDO

!-------------------------
   END SUBROUTINE Time_lat
!-------------------------

!-----------------------------------------------------------------------
   SUBROUTINE Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
                          finalTime, finalTAI, finalLat)
!-----------------------------------------------------------------------

! Brief description of program
! This program calculates the MIF starting times for the orbits.

! Arguments

      CHARACTER (LEN=27), INTENT(IN) :: estTime

      INTEGER, INTENT(IN) :: scansPerOrb

      REAL(r8), INTENT(IN) :: homeAlt, homeLat, spm

      CHARACTER (LEN=27), INTENT(OUT) :: finalTime

      REAL(r8), INTENT(OUT) :: finalLat, finalTAI

! Parameters

      CHARACTER (LEN=*), PARAMETER :: GR_ERR = 'Iterations timed out before &
                                               &height converged for '

! Functions

      INTEGER :: Pgs_td_utcToTAI, Pgs_td_taiToUTC

! Variables

      CHARACTER (LEN=27) :: timeF
      CHARACTER (LEN=480) :: msg

      INTEGER :: back, converge, i, returnStatus

      REAL(r8) :: estTAI93, latE, latF, tai

      finalTime = estTime

! Get tp info for estTime

      CALL Time_lat(estTime, homeAlt, latE, converge)
      IF ( converge /= 1 ) THEN
         msg = GR_ERR // estTime
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msg)
      ENDIF

      returnStatus = Pgs_td_utcToTAI (estTime, estTAI93)

! Set search direction

      IF (latE < homeLat) THEN
         back = -1
      ELSE
         back = 1
      ENDIF

! Check determined direction in MIF steps
 
      DO i = 1, scansPerOrb*N_RECORDS

         tai = estTAI93 - back * spm

         returnStatus = Pgs_td_taiToUTC(tai, timeF)

         CALL Time_lat(timeF, homeAlt, latF, converge)
         IF ( converge /= 1 ) THEN
            msg = GR_ERR // timeF
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msg)
            EXIT
         ENDIF

         IF ( ABS(latF - homeLat) >= ABS(latE - homeLat) ) THEN
            EXIT
         ELSE
            latE = latF
            estTAI93 = tai
            finalTime = timeF
         ENDIF

      ENDDO

! Add an MIF, if closest lat found is below homeLat

      IF (latE < homeLat) THEN

         tai = estTAI93 + spm

         returnStatus = Pgs_td_taiToUTC(tai, timeF)

         CALL Time_lat(timeF, homeAlt, latF, converge)
         IF ( converge /= 1 ) THEN
            msg = GR_ERR // timeF
            CALL MLSMessage(MLSMSG_Warning, ModuleName, msg)
         ENDIF

         latE = latF
         estTAI93 = tai
         finalTime = timeF

      ENDIF

      finalLat = latE
      finalTAI = estTAI93

!----------------------------
   END SUBROUTINE Time_search
!----------------------------

!------------------------------------------------------------------------------
   SUBROUTINE Time_MAF(startTime, times, homeAlt, homeLat, mifRate, &
                      scansPerOrb, spm, scanTimes, scanTAI, numMIFs, orbPerDay)
!------------------------------------------------------------------------------

! Brief description of program
! This program calculates the starting times for the orbits and their scans,
! and the number of MIFs per MAF.

! Arguments

      TYPE( TAI93_Range_T ), INTENT(IN) :: times

      CHARACTER (LEN=27), INTENT(IN) :: startTime

      INTEGER, INTENT(IN) :: mifRate, scansPerOrb

      REAL(r8), INTENT(IN) :: homeAlt, homeLat, spm

      CHARACTER (LEN=27), INTENT(OUT) :: scanTimes(:,:)

      INTEGER, INTENT(OUT) :: orbPerDay
      INTEGER, INTENT(OUT) :: numMIFs(:,:)

      REAL(r8), INTENT(OUT) :: scanTAI(:,:)

! Parameters

      CHARACTER (LEN=*), PARAMETER ::GR_ERR = 'Iterations timed out before &
                                            &height converged for '

      REAL(r8), PARAMETER :: minPerOrb = 98.9

! Functions

      INTEGER :: Pgs_td_taiToUTC

! Variables

      CHARACTER (LEN=27) :: estTime, timeF
      CHARACTER (LEN=27), ALLOCATABLE :: orbTime(:)
      CHARACTER (LEN=480) :: msg, msr

      INTEGER :: alloc_err, ascend, converge, dealloc_err, delMIF, delOrb, i, j
      INTEGER :: k, opd, returnStatus

      REAL(r8) :: delAngle, delMAF, delTime, estLat, latF, orbRate, startLat
      REAL(r8) :: tai
      REAL(r8), ALLOCATABLE :: orbTAI(:)

      orbRate = minPerOrb * 60 / (2*PI)

      delOrb = AINT(minPerOrb * 60 * mifRate)

      opd = SIZE(scanTimes,2)

      ALLOCATE( orbTime(opd), orbTAI(opd), STAT=alloc_err )
      IF ( alloc_err /= 0 ) THEN
         msr = MLSMSG_Allocate // '  orbit variables.'
         CALL MLSMessage(MLSMSG_Error, ModuleName, msr)
      ENDIF

! Get tp info for startTime

      CALL Time_lat(startTime, homeAlt, startLat, converge)
      IF ( converge /= 1 ) THEN
         msg = GR_ERR // startTime
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msg)
      ENDIF

! Find whether ascending or descending at startTime

      ascend = -1

      tai = times%startTime + spm
d7 160
d168 280
a447 310

      CALL Time_lat(timeF, homeAlt, latF, converge)
      IF ( converge /= 1 ) THEN
         msg = GR_ERR // timeF
         CALL MLSMessage(MLSMSG_Warning, ModuleName, msg)
      ENDIF

      IF ( (latF - startLat) > 0 ) ascend = 1

! Estimate MIF time of nearest ascending homeLat crossing

      IF (ascend == 1) THEN

         IF ( homeLat >= startLat ) THEN
            delAngle = homeLat - startLat
         ELSE
            delAngle = 2*PI + homeLat - startLat
         ENDIF

      ELSE

         delAngle = PI + homeLat + startLat

      ENDIF

      delTime = delAngle * orbRate

      delMIF = AINT(delTime * mifRate)

      tai = times%startTime + delMIF * spm

      returnStatus = Pgs_td_taiToUTC(tai, estTime)

! Find MIF time of nearest ascending homeLat crossing

      orbTAI = 0.0

      CALL Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
                       orbTime(1), orbTAI(1), estLat)

! Estimate time of remaining orbit crossings

      DO i = 2, opd

         tai = orbTAI(i-1) + delOrb * spm

         IF ( tai > times%endTime) THEN
            orbTAI(i) = 0.0
            orbPerDay = i-1
            EXIT
         ENDIF

         returnStatus = Pgs_td_taiToUTC( tai, estTime)

         CALL Time_search(estTime, homeAlt, homeLat, scansPerOrb, spm, &
                          orbTime(i), orbTAI(i), estLat)

         IF ( orbTAI(i) > times%endTime) THEN
            orbTAI(i) = 0.0
            orbPerDay = i-1
            EXIT
         ENDIF

      ENDDO

! Divide orbits into 240 MAFs

      scanTAI = 0.0

      DO i = 1, orbPerDay

         IF ( orbTAI(i+1) /= 0.0 ) THEN

            delMAF = ( orbTAI(i+1) - orbTAI(i) ) / scansPerOrb

            DO j = 1, scansPerOrb

               delMIF = ANINT( (j-1) * delMAF * mifRate )
               scanTAI(j,i) = orbTAI(i) + delMIF * spm
               returnStatus = Pgs_td_taiToUTC( scanTAI(j,i), scanTimes(j,i) )

            ENDDO

         ELSE

            scanTAI(1,i) = orbTAI(i)
            scanTimes(1,i) = orbTime(i)
            EXIT

         ENDIF

      ENDDO

! Calculate number of MIFs

      DO i = 1, orbPerDay-1

         DO j = 1, scansPerOrb

            IF ( j /= scansPerOrb) THEN

               DO k = 1, N_RECORDS
                  IF ( scanTAI(j,i) + k*spm > scanTAI(j+1,i) ) EXIT
                  numMIFs(j,i) = k
               ENDDO

            ELSE 

               DO k = 1, N_RECORDS
                 IF ( ( scanTAI(j,i) + k*spm ) > scanTAI(1,i+1) ) EXIT
                 numMIFs(j,i) = k
               ENDDO

            ENDIF

         ENDDO

      ENDDO

      DEALLOCATE( orbTime, orbTAI, STAT=dealloc_err )
      IF ( dealloc_err /= 0 ) CALL MLSMessage(MLSMSG_Warning, ModuleName, &
                                  'Failed deallocation of orbit variables.')

!-------------------------
   END SUBROUTINE Time_MAF
!-------------------------

!-----------------------------------------------------------------------
   SUBROUTINE Time_pre(numValues, orbTime, startTAI, scansPerOrb, spm, &
                       preTimes, preTAI, numMIFs, preMAF)
!-----------------------------------------------------------------------

! Brief description of subroutine
! This subroutine fills in the time gap for a partial orbit at the beginning of
! a file.  It duplicates the scan pattern for the first MAF of the first full
! orbit.

! Arguments
 
      CHARACTER(LEN=27), INTENT(IN) :: orbTime

      INTEGER, INTENT(IN) :: scansPerOrb
      INTEGER, INTENT(IN) :: numValues(scansPerOrb)

      REAL(r8), INTENT(IN) :: spm, startTAI

      CHARACTER(LEN=27), INTENT(OUT) :: preTimes(scansPerOrb)

      INTEGER, INTENT(OUT) :: preMAF
      INTEGER, INTENT(OUT) :: numMIFs(scansPerOrb)

      REAL(r8), INTENT(OUT) :: preTAI(scansPerOrb)

! Parameters

! Functions

      INTEGER :: Pgs_td_utcToTAI, Pgs_td_taiToUTC
  
! Variables

      CHARACTER(LEN=27) :: backTimes(scansPerOrb)

      INTEGER :: i, returnStatus

      REAL(r8) :: mafTAI, orbTAI
      REAL(r8) :: backTAI(scansPerOrb)

      preMAF = 0

! Calculate MAF times prior to first full orbit

      returnStatus = Pgs_td_utcToTAI (orbTime, orbTAI)

      mafTAI = orbTAI

      DO i = 1, scansPerOrb

         mafTAI = mafTAI - numValues(scansPerOrb - (i-1))*spm

         IF ( mafTAI < startTAI ) EXIT

         returnStatus = Pgs_td_taiToUTC( mafTAI, backTimes(i) )
         backTAI(i) = mafTAI
         preMAF = i

      ENDDO

! Reverse numbering of MAF times, numValues

      DO i = 1, preMAF

         preTimes(i) = backTimes( preMAF - (i-1) )
         preTAI(i)   = backTAI (preMAF - (i-1) )
         numMIFs(i) = numValues( scansPerOrb - (preMAF - i) )

      ENDDO

!--------------------------
    END SUBROUTINE Time_pre
!--------------------------

!-----------------------------------------------------------------------
    SUBROUTINE Time_post(numValues, orbTime, endTAI, scansPerOrb, spm, &
                         postTimes, postTAI, postMAF)
!-----------------------------------------------------------------------

! Brief description of subroutine
! This subroutine fills in the time gap for a partial orbit at the end of a
! file.  It duplicates the scan pattern for the last MAF of the last full
! orbit.

! Arguments

      CHARACTER(LEN=27), INTENT(IN) :: orbTime

      INTEGER, INTENT(IN) :: scansPerOrb
      INTEGER, INTENT(IN) :: numValues(scansPerOrb)

      REAL(r8), INTENT(IN) :: endTAI, spm

      CHARACTER(LEN=27), INTENT(OUT) :: postTimes(scansPerOrb)

      INTEGER, INTENT(OUT) :: postMAF

      REAL(r8), INTENT(OUT) :: postTAI(scansPerOrb)

! Parameters

! Functions

      INTEGER :: Pgs_td_utcToTAI, Pgs_td_taiToUTC

! Variables

      INTEGER :: i, returnStatus

      REAL(r8) :: orbTAI, mafTAI

      postMAF = 0

! Calculate MAF times after the last full orbit

      returnStatus = Pgs_td_utcToTAI (orbTime, orbTAI)

      mafTAI = orbTAI

      DO i = 1, scansPerOrb

         mafTAI = mafTAI + numValues(i)*spm

         IF ( mafTAI > endTAI ) EXIT

         returnStatus = Pgs_td_taiToUTC( mafTAI, postTimes(i+1) )
         postTAI(i+1) = mafTAI

         postMAF = i + 1

      ENDDO

      postTimes(1) = orbTime
      postTAI(1) = orbTAI

!--------------------------
   END SUBROUTINE Time_post
!--------------------------

!---------------------------------------------------------------------------
   SUBROUTINE Time_day(lenMAF, numMIFs, numValues, orbPerDay, postMAF, &
                       postTAI, postTimes, preMAF, preTAI, preTimes, &
                       scansPerOrb, scanTAI, scanTimes, mafTAI, mafTime, nV)
!---------------------------------------------------------------------------

! Brief description of subroutine
! This program reorganizes the various time arrays into a single array for the
! entire day/file.

! Arguments

      INTEGER, INTENT(IN) :: lenMAF, postMAF, preMAF, orbPerDay, scansPerOrb

      CHARACTER (LEN=27), INTENT(IN) :: postTimes(postMAF)
      CHARACTER (LEN=27), INTENT(IN) :: preTimes(preMAF)
      CHARACTER (LEN=27), INTENT(IN) :: scanTimes(scansPerOrb,orbPerDay)

      INTEGER, INTENT(IN) :: numMIFs(preMAF)
      INTEGER, INTENT(IN) :: numValues(scansPerOrb,orbPerDay)

      REAL(r8), INTENT(IN) :: postTAI(postMAF)
      REAL(r8), INTENT(IN) :: preTAI(preMAF)
      REAL(r8), INTENT(IN) :: scanTAI(scansPerOrb,orbPerDay)

      CHARACTER (LEN=27), INTENT(OUT) :: mafTime(lenMAF)

      INTEGER, INTENT(OUT) :: nV(lenMAF)

      REAL(r8), INTENT(OUT) :: mafTAI(lenMAF)

! Parameters

! Functions

! Variables

   INTEGER :: i, j, k

! MAFs prior to first full orbit

   DO i = 1, preMAF
      IF ( i > lenMAF ) EXIT
d451 1
a451 9
   ENDDO

! MAFs for full orbits

   DO i = 1, orbPerDay-1
      DO j = 1, scansPerOrb

         k = j + (i-1)*scansPerOrb + preMAF
         IF ( k > lenMAF ) EXIT
d453 3
a455 3
         nV(k) = numValues(j,i)
         mafTime(k) = scanTimes(j,i)
         mafTAI(k) = scanTAI(j,i)
d457 2
a458 2
      ENDDO
   ENDDO
d460 3
a462 1
! MAFs after last full orbit
d464 2
a465 1
   DO i = 1, postMAF
d467 2
d470 1
a470 1
      IF ( j > lenMAF ) EXIT
d475 1
d477 1
a477 1
   ENDDO
d479 1
a479 7
!-------------------------
   END SUBROUTINE Time_day
!-------------------------

!==============
END MODULE Time
!==============
d481 3
a483 2
!# $Log: $
!#
@

