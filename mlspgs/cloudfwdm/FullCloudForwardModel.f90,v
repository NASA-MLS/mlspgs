head	1.144;
access;
symbols
	v5-02-NRT-19:1.144
	v6-00:1.144
	v5-02-NRT-18:1.144
	v5-02:1.144
	v5-01-NRT-17:1.144
	v5-01-NRT-16:1.144
	v5-01-NRT-15:1.144
	v5-01-NRT-14:1.144
	neuralnetworks-1-0:1.144.0.6
	cfm-single-freq-0-1:1.144.0.4
	v5-01:1.144
	v5-00:1.144
	v4-23-TA133:1.144.0.2
	mus-emls-1-70:1.143.0.4
	rel-1-0-englocks-work:1.143.0.2
	VUMLS1-00:1.143
	VPL1-00:1.143
	V4-22-NRT-08:1.143
	VAM1-00:1.143
	V4-21:1.142.0.2
	V4-13:1.142
	V4-12:1.142
	V4-11:1.142
	V4-10:1.142
	V3-43:1.141
	M4-00:1.142
	V3-41:1.141
	V3-40-PlusGM57:1.141.0.2
	V2-24-NRT-04:1.138
	V3-33:1.141
	V2-24:1.138
	V3-31:1.141
	V3-30-NRT-05:1.141
	cfm-01-00:1.141
	V3-30:1.141
	V3-20:1.141
	V3-10:1.141
	V2-23-NRT-02:1.138
	V2-23:1.138
	V2-22-NRT-01:1.138
	V2-22:1.138
	V2-21:1.136
	V2-20:1.136
	V2-11:1.136
	V2-10:1.136
	V2-00:1.136
	V1-51:1.135
	V1-50:1.135
	V1-45:1.129
	V1-44:1.129
	V1-43:1.127
	V1-32:1.123
	V1-31:1.123
	V1-30:1.120
	V1-13:1.108
	V1-12:1.108
	V1-11:1.108
	V1-10:1.108
	newfwm-feb03:1.108.0.2
	V1-04:1.91
	V1-03:1.91
	V1-02:1.91
	JointForwardModel:1.92.0.2
	V1-00:1.91
	newfwm-sep01:1.25.0.2
	V0-7:1.24;
locks; strict;
comment	@# @;


1.144
date	2018.08.06.19.57.34;	author vsnyder;	state Exp;
branches;
next	1.143;

1.143
date	2015.08.25.17.18.02;	author vsnyder;	state Exp;
branches;
next	1.142;

1.142
date	2011.07.29.01.47.07;	author vsnyder;	state Exp;
branches;
next	1.141;

1.141
date	2009.06.23.18.26.19;	author pwagner;	state Exp;
branches;
next	1.140;

1.140
date	2009.05.13.20.10.20;	author vsnyder;	state Exp;
branches;
next	1.139;

1.139
date	2008.10.03.21.04.26;	author livesey;	state Exp;
branches;
next	1.138;

1.138
date	2007.07.25.21.59.07;	author vsnyder;	state Exp;
branches;
next	1.137;

1.137
date	2007.06.29.19.35.06;	author vsnyder;	state Exp;
branches;
next	1.136;

1.136
date	2005.06.22.18.27.38;	author pwagner;	state Exp;
branches;
next	1.135;

1.135
date	2004.11.04.03.41.05;	author vsnyder;	state Exp;
branches;
next	1.134;

1.134
date	2004.11.03.01.26.32;	author vsnyder;	state Exp;
branches;
next	1.133;

1.133
date	2004.11.01.20.26.57;	author vsnyder;	state Exp;
branches;
next	1.132;

1.132
date	2004.10.21.01.33.35;	author vsnyder;	state Exp;
branches;
next	1.131;

1.131
date	2004.10.20.23.44.13;	author pwagner;	state Exp;
branches;
next	1.130;

1.130
date	2004.10.13.01.08.05;	author vsnyder;	state Exp;
branches;
next	1.129;

1.129
date	2004.08.05.21.03.07;	author vsnyder;	state Exp;
branches;
next	1.128;

1.128
date	2004.06.10.01.00.14;	author vsnyder;	state Exp;
branches;
next	1.127;

1.127
date	2004.02.07.00.45.49;	author livesey;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.05.23.30.20;	author livesey;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.08.00.52.43;	author jonathan;	state Exp;
branches;
next	1.124;

1.124
date	2004.01.08.00.24.32;	author jonathan;	state Exp;
branches;
next	1.123;

1.123
date	2003.11.21.19.17.40;	author dwu;	state Exp;
branches;
next	1.122;

1.122
date	2003.11.21.17.55.57;	author dwu;	state Exp;
branches;
next	1.121;

1.121
date	2003.11.20.20.30.58;	author dwu;	state Exp;
branches;
next	1.120;

1.120
date	2003.07.09.20.17.22;	author livesey;	state Exp;
branches;
next	1.119;

1.119
date	2003.05.29.16.38.03;	author livesey;	state Exp;
branches;
next	1.118;

1.118
date	2003.05.16.23.53.56;	author livesey;	state Exp;
branches;
next	1.117;

1.117
date	2003.05.15.22.48.28;	author dwu;	state Exp;
branches;
next	1.116;

1.116
date	2003.05.07.22.49.03;	author jonathan;	state Exp;
branches;
next	1.115;

1.115
date	2003.04.10.20.40.59;	author dwu;	state Exp;
branches;
next	1.114;

1.114
date	2003.04.08.20.03.55;	author dwu;	state Exp;
branches;
next	1.113;

1.113
date	2003.04.05.17.30.43;	author dwu;	state Exp;
branches;
next	1.112;

1.112
date	2003.04.03.22.38.05;	author dwu;	state Exp;
branches;
next	1.111;

1.111
date	2003.04.03.01.18.41;	author dwu;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.03.01.15.51;	author dwu;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.02.20.00.12;	author dwu;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.23.00.19.09;	author pwagner;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2003.01.17.07.19.33;	author dwu;	state Exp;
branches;
next	1.106;

1.106
date	2003.01.17.01.08.11;	author jonathan;	state Exp;
branches;
next	1.105;

1.105
date	2003.01.17.00.52.05;	author jonathan;	state Exp;
branches;
next	1.104;

1.104
date	2003.01.16.18.39.41;	author pwagner;	state Exp;
branches;
next	1.103;

1.103
date	2003.01.13.17.59.52;	author jonathan;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.09.21.08.09;	author dwu;	state Exp;
branches;
next	1.101;

1.101
date	2002.12.18.16.09.24;	author jonathan;	state Exp;
branches;
next	1.100;

1.100
date	2002.11.30.21.31.46;	author dwu;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.08.17.08.07;	author pwagner;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.04.00.02.15;	author vsnyder;	state Exp;
branches;
next	1.97;

1.97
date	2002.10.03.23.25.52;	author vsnyder;	state Exp;
branches;
next	1.96;

1.96
date	2002.09.11.17.43.39;	author pwagner;	state Exp;
branches;
next	1.95;

1.95
date	2002.08.22.00.14.17;	author jonathan;	state Exp;
branches;
next	1.94;

1.94
date	2002.08.19.22.22.03;	author jonathan;	state Exp;
branches;
next	1.93;

1.93
date	2002.08.08.22.46.30;	author jonathan;	state Exp;
branches;
next	1.92;

1.92
date	2002.05.08.17.03.39;	author jonathan;	state Exp;
branches;
next	1.91;

1.91
date	2002.01.14.19.30.16;	author jonathan;	state Exp;
branches;
next	1.90;

1.90
date	2001.11.16.00.49.05;	author jonathan;	state Exp;
branches;
next	1.89;

1.89
date	2001.11.16.00.47.13;	author jonathan;	state Exp;
branches;
next	1.88;

1.88
date	2001.11.16.00.41.00;	author jonathan;	state Exp;
branches;
next	1.87;

1.87
date	2001.11.15.23.52.12;	author jonathan;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.15.23.50.21;	author jonathan;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.09.18.12.13;	author jonathan;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.09.18.05.24;	author jonathan;	state Exp;
branches;
next	1.83;

1.83
date	2001.11.08.21.36.13;	author jonathan;	state Exp;
branches;
next	1.82;

1.82
date	2001.11.07.23.47.52;	author dwu;	state Exp;
branches;
next	1.81;

1.81
date	2001.11.07.05.22.06;	author dwu;	state Exp;
branches;
next	1.80;

1.80
date	2001.11.06.21.54.47;	author dwu;	state Exp;
branches;
next	1.79;

1.79
date	2001.11.06.20.06.31;	author dwu;	state Exp;
branches;
next	1.78;

1.78
date	2001.11.06.19.52.42;	author dwu;	state Exp;
branches;
next	1.77;

1.77
date	2001.11.06.18.28.06;	author dwu;	state Exp;
branches;
next	1.76;

1.76
date	2001.11.06.00.54.11;	author dwu;	state Exp;
branches;
next	1.75;

1.75
date	2001.11.06.00.29.38;	author dwu;	state Exp;
branches;
next	1.74;

1.74
date	2001.11.05.22.39.57;	author dwu;	state Exp;
branches;
next	1.73;

1.73
date	2001.11.05.20.25.14;	author dwu;	state Exp;
branches;
next	1.72;

1.72
date	2001.11.02.01.14.17;	author dwu;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.02.01.00.13;	author jonathan;	state Exp;
branches;
next	1.70;

1.70
date	2001.11.02.00.47.34;	author dwu;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.02.00.45.33;	author dwu;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.02.00.42.05;	author dwu;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.02.00.25.58;	author dwu;	state Exp;
branches;
next	1.66;

1.66
date	2001.10.30.05.25.48;	author dwu;	state Exp;
branches;
next	1.65;

1.65
date	2001.10.19.19.29.50;	author dwu;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.19.16.26.09;	author dwu;	state Exp;
branches;
next	1.63;

1.63
date	2001.10.18.22.17.02;	author dwu;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.18.06.06.24;	author dwu;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.12.16.58.31;	author dwu;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.11.22.44.01;	author dwu;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.11.17.01.11;	author jonathan;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.10.18.55.17;	author dwu;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.10.18.33.53;	author dwu;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.09.22.11.54;	author jonathan;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.09.17.50.17;	author jonathan;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.09.17.47.33;	author jonathan;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.08.23.43.00;	author dwu;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.08.21.46.39;	author jonathan;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.08.21.44.48;	author dwu;	state Exp;
branches;
next	1.50;

1.50
date	2001.10.08.21.42.29;	author dwu;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.08.21.35.33;	author dwu;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.08.20.57.05;	author dwu;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.08.20.46.26;	author dwu;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.08.20.34.18;	author dwu;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.08.20.23.54;	author jonathan;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.08.19.25.48;	author jonathan;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.07.23.42.17;	author jonathan;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.05.22.25.40;	author dwu;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.05.20.46.39;	author dwu;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.05.20.26.12;	author dwu;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.04.23.34.19;	author dwu;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.04.16.27.12;	author jonathan;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.04.00.29.36;	author dwu;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.02.17.08.02;	author jonathan;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.02.16.27.36;	author livesey;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.01.23.40.26;	author jonathan;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.28.21.45.50;	author dwu;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.28.15.54.39;	author jonathan;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.26.19.17.02;	author dwu;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.24.23.16.40;	author dwu;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.24.23.12.53;	author dwu;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.21.15.51.37;	author jonathan;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.19.16.46.22;	author dwu;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.19.00.25.59;	author dwu;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.04.15.59.44;	author jonathan;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.17.21.48.41;	author jonathan;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.07.17.17.50;	author jonathan;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.02.01.03.16;	author dwu;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.01.20.51.30;	author dwu;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.01.17.24.29;	author jonathan;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.01.00.20.22;	author dwu;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.31.18.24.15;	author dwu;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.27.22.12.13;	author jonathan;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.27.20.26.24;	author jonathan;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.27.15.17.58;	author jonathan;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.26.13.08.56;	author livesey;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.25.23.44.00;	author jonathan;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.25.18.00.29;	author jonathan;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.20.17.45.42;	author jonathan;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.20.16.44.48;	author jonathan;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.20.16.20.03;	author jonathan;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.18.23.52.19;	author jonathan;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.22.36.50;	author jonathan;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.17.18.12.56;	author jonathan;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.22.03.20;	author jonathan;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.15.47.57;	author jonathan;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.06.18.47.00;	author jonathan;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.31.22.58.24;	author livesey;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.29.22.19.12;	author livesey;	state Exp;
branches;
next	;

1.108.2.1
date	2003.04.08.23.42.12;	author jonathan;	state Exp;
branches;
next	;


desc
@@


1.144
log
@Use ASSOCIATE construct to avoid necessity for Lines database to have the
TARGET attribute.  Some cannonball polishing.
@
text
@! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

module FullCloudForwardModel

! ===========================================================================
! THIS MODULE CONTAINS THE FULL CLOUD FORWARD MODEL  
! ===========================================================================

  ! This one is here instead of inside FullCloudForwardModelWrapper because
  ! it has a dummy argument of the same name.
  use ForwardModelConfig,         only: ForwardModelConfig_t

  implicit none
  private

  public :: FullCloudForwardModelWrapper

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile: FullCloudForwardModel.f90,v $"
  private :: not_used_here 
!---------------------------------------------------------------------------

         ! ---------------------------------------------------------------------
contains ! THIS SUBPROGRAM CONTAINS THE WRAPPER ROUTINE FOR CALLING THE FULL
         ! CLOUD FORWARD MODEL
         ! ---------------------------------------------------------------------

  !----------------------------------------  FullCloudForwardModelWrapper  -----
  subroutine FullCloudForwardModelWrapper ( ForwardModelConfig, FwdModelIn,  &
                                            FwdModelExtra, FwdModelOut,      &
                                            fmStat, Jacobian                 )  

    use Allocate_deallocate,        only: Allocate_test, Deallocate_test
    use AntennaPatterns_m,          only: AntennaPatterns
    use CloudySkyModule,            only: Cloud_Model
    use CloudySkyRadianceModel,     only: CloudForwardModel
    use ForwardModelIntermediate,   only: ForwardModelStatus_t
    use ManipulateVectorQuantities, only: FindClosestInstances
    use MatrixModule_0,             only: MatrixElement_t, &
                                        & M_Full, CreateBlock
    use MatrixModule_1,             only: Matrix_t, FindBlock
    use MLSKinds,                   only: r8, rm, rp
    use MLSMessageModule,           only: MLSMessage, MLSMSG_Allocate, &
                                        & MLSMSG_Error, MLSMSG_Warning, &
                                        & MLSMSG_Deallocate
    use Molecules,                  only: L_H2O, L_N2O, L_O3
    use MLSSignals_m,               only: AreSignalsSuperset, GetNameOfSignal, &
                                        & GetSidebandStartStop, Signal_t
    use MLSNumerics,                only: InterpolateValues
!   use Output_m,                   only: Output
    use Physics,                    only: C => SpeedOfLight
    use SpectroscopyCatalog_m,      only: Catalog, Catalog_t, Empty_Cat, &
                                        & Lines, MostLines
    use String_table,               only: Get_String
    use Toggles,                    only: Emit, Levels, Toggle
    use Trace_M,                    only: Trace_begin, Trace_end
    use Constants,                  only: Deg2Rad                         
    use VectorsModule,              only: GetVectorQuantityByType, Vector_t, &
                                        & VectorValue_t, ValidateVectorQuantity

! ----------------------------------------------------------
! DEFINE INTRINSIC CONSTANTS NEEDED FROM Init_Tables_Module
! ----------------------------------------------------------

    use Intrinsic, only: &
                       & L_CloudExtinction,                                    &
                       & L_CloudInducedRadiance,                               &
                       & L_CloudRadSensitivity,                                &
                       & L_CloudWater,                                         &
                       & L_EarthRadius,                                        &
                       & L_EffectiveOpticalDepth,                              &
                       & L_ElevOffset,                                         &
                       & L_GPH,                                                &
                       & L_IWC_High_Height,                                    &
                       & L_IWC_Low_Height,                                     &
                       & L_LimbSidebandFraction,                               &
                       & L_LOSTransFunc,                                       &
                       & L_LOSVEL,                                             &
                       & L_MassMeanDiameterIce,                                & 
                       & L_MassMeanDiameterWater,                              &
                       & L_None,                                               &
                       & L_Ptan,                                               &
                       & L_Radiance,                                           &
                       & L_SCGeocAlt,                                          &
                       & L_SizeDistribution,                                   &
                       & L_SurfaceType,                                        &
                       & L_Temperature,                                        &
                       & L_TotalExtinction,                                    &
                       & L_VMR,                                                &
                       & Lit_Indices,                                          &
                       & PHYQ_Profiles

    use Molecules, only: L_CLOUDICE

    ! Dummy arguments
    type(forwardModelConfig_T),       intent(inout) :: ForwardModelConfig
    type(vector_T),                   intent(in)    :: FwdModelIn, FwdModelExtra
    type(vector_T),                   intent(inout) :: FwdModelOut             ! Radiances, etc.
    type(forwardModelStatus_t),       intent(inout) :: FMStat                  ! Reverse comm. stuff
    type(matrix_T),                   intent(inout), optional :: Jacobian


    ! Local parameters ---------------------------------------------------------
    character(len=*), parameter :: InvalidQuantity = &
     & "Invalid vector quantity for "

    ! Local variables
    type (VectorValue_T), pointer :: CloudIce                   ! Profiles
    type (VectorValue_T), pointer :: CloudWater                 ! Profiles
    type (VectorValue_T), pointer :: CloudExtinction            ! Profiles
    type (VectorValue_T), pointer :: ModelCloudRadiance         ! modelled cloud radiance
!   type (VectorValue_T), pointer :: ConstrainCldRad            ! observed cloud radiance
    type (VectorValue_T), pointer :: CloudRadSensitivity        ! Like radiance
    type (VectorValue_T), pointer :: EffectiveOpticalDepth      ! Quantity
    type (VectorValue_T), pointer :: GPH                        ! Geop height
    type (VectorValue_T), pointer :: MassMeanDiameterIce        ! Quantity
    type (VectorValue_T), pointer :: MassMeanDiameterWater      ! Quantity
    type (VectorValue_T), pointer :: Ptan                       ! Tgt pressure
    type (VectorValue_T), pointer :: Radiance                   ! Quantity
    type (VectorValue_T), pointer :: SizeDistribution           ! Integer really
    type (VectorValue_T), pointer :: EarthRadius                ! Scalar 
    type (VectorValue_T), pointer :: SurfaceType                ! Integer really
    type (VectorValue_T), pointer :: Temp                       ! Temperature 
    type (VectorValue_T), pointer :: TotalExtinction            ! Profile
    type (VectorValue_T), pointer :: VMR                        ! Quantity
    type (VectorValue_T), pointer :: SCGeocAlt                  ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: ElevOffset                 ! Elevation offset quantity
    type (VectorValue_T), pointer :: LOSVEL                     ! Line of sight velocity
    type (Signal_T)               :: Signal                     ! A signal
    type (VectorValue_T), pointer :: State_Ext                  ! A state vector quantity
    type (VectorValue_T), pointer :: State_Los                  ! A state vector quantity
    type (VectorValue_T), pointer :: SidebandFraction           ! The sideband ratio to use
    type (VectorValue_T), pointer :: LowerSidebandFraction      ! From the state vector
    type (VectorValue_T), pointer :: UpperSidebandFraction      ! From the state vector

    type (catalog_T), dimension(:,:), pointer :: My_Catalog 

    ! for jacobian
    type(MatrixElement_T), pointer :: JBlock       ! A block from the jacobian
    integer :: ColJBlock                           ! Column index in jacobian
    integer :: RowJBlock                           ! Row index in jacobian
    integer :: NoInstances                         ! no of instance
    integer :: NoMIFs                              ! Number of minor frames
    integer :: NoSgrid                             ! no of elements in S grid
    integer :: NoSurf                              ! Number of pressure levels
    integer :: NovmrSurf                           ! Number of vmr levels
    integer :: NoExtSurf                           ! Number of cloud ext levels
    integer :: NoIWCSurf                           ! Number of cloud IWC levels
    integer :: NoLWCSurf                           ! Number of cloud LWC levels
    integer :: NoPSDSurf                           ! Number of size dist. levels
    integer :: NoFreqs                             ! Number of frequencies
    integer :: Direction                           ! Direction of channel numbering

    integer :: I                                   ! Loop counter
    integer :: J                                   ! Loop counter
    integer :: K                                   ! Loop counter
    integer :: IER                                 ! Status flag from allocates
    integer :: MIF
    integer :: MAF                                 ! major frame counter
    integer :: Instance                            ! Relevant instance for temperature
    integer :: MinInst                             ! lower bound of instance
    integer :: MaxInst                             ! upper bound of instance
    integer :: Nfine                               ! no of fine resolution grids
    integer :: NNear                               ! no of nearest profiles
    integer :: Status                              ! allocation status 
    integer :: SidebandStart                       ! For sideband loop
    integer :: SidebandStop                        ! For sideband loop
    integer :: ThisSideband                        ! Loop counter for sidebands
    integer :: SIGIND                              ! Signal index, loop counter
    integer :: Nspec                               ! no of species in cloud fw model
    integer :: Ispec                               ! species index in cloud fw model

    integer :: iCloudHeight                        ! Index for Cloud Top Height

    integer, dimension(:), pointer :: ClosestInstances 

    integer :: WHICHChannel                        ! which single channel is used
    integer :: WHICHPATTERN                        ! Index of antenna pattern
    integer :: MAXSUPERSET                         ! Max. value of superset
    integer, dimension(:), pointer :: SUPERSET     ! Result of AreSignalsSuperset
    integer, dimension(1) :: WHICHPATTERNASARRAY   ! Result of minloc

    real(r8), dimension(:,:), pointer :: A_ClearSkyRadiance
    real(r8), dimension(:,:), pointer :: A_CloudInducedRadiance
    real(r8), dimension(:,:), pointer :: A_CloudExtinction
    real(r8), dimension(:,:), pointer :: A_CloudRadSensitivity
    real(r8), dimension(:,:), pointer :: A_EffectiveOpticalDepth
    real(r8), dimension(:,:), pointer :: A_MassMeanDiameter
    real(r8), dimension(:,:), pointer :: A_TotalExtinction
    real(r8), dimension(:,:), pointer :: VMRARRAY  ! The VMRs
    real(r8), dimension(:), allocatable :: Slevl   ! S grid
    real(r8), dimension(:), allocatable :: Zt      ! tangent height
    real(r8), dimension(:), pointer :: ThisFraction ! Sideband ratio values
    real(rp) :: Vel_Cor                 ! Velocity correction due to Vel_z

    real(r8), dimension(:), pointer :: Phi_fine    ! Fine resolution for phi 
    real(r8), dimension(:), pointer :: Z_fine      ! Fine resolution for z
    real(r8), dimension(:), pointer :: Zp_fine     ! Fine resolution for zp
    real(r8), dimension(:), pointer :: S_fine      ! Fine resolution for s
    real(r8), dimension(:), pointer :: Ds_fine     ! Fine resolution for ds
    real(r8), dimension(:), pointer :: W_fine      ! weight along s_fine

    real(r8), dimension(:,:,:), allocatable  :: A_Trans
    real(r8), dimension(:), pointer :: Frequencies 
    real(r8), dimension(:,:), allocatable :: WC
    real(r8), dimension(:), allocatable :: PSD

    real(r8) :: dz                                 ! thickness of state quantity
    real(r8) :: dphi                               ! phi interval of state quantity
    real(r8) :: tLat                               ! temperature 'window' latitude
    real(r8) :: CloudHeight                        ! Cloud Top Height

    logical, dimension(:), pointer :: doChannel    ! Do this channel?
    logical :: DoThis                              ! Flag for lines
    logical :: FOUNDINFIRST                        ! Flag to indicate derivatives
    logical, dimension(:), pointer :: LineFlag     ! Use this line (noLines per species)
    logical, target :: MaxLineFlag(mostLines)
    logical :: prt_log = .false.

    character :: Cloudtype                         ! cloud profile type
    character (len=32) :: MolName                  ! Name of a molecule
    character (len=32) :: SignalName               ! Name of a signal

    !---------------------------------------------------------------------------
    ! >>>>>>>>>>>>>>>>>>>>>>>>>>> Executable code  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    !---------------------------------------------------------------------------

    if ( toggle(emit) ) call trace_begin ( 'FullCloudForwardModel' )

    !--------------------------
    ! Nullify all the pointers
    !--------------------------

    nullify( a_clearSkyradiance, a_cloudExtinction, a_cloudInducedradiance,   &
             a_cloudRadsensitivity, a_effectiveOpticaldepth,                  &
             a_massMeandiameter, a_totalExtinction, cloudExtinction,          &
             cloudIce, cloudRadsensitivity, closestInstances, cloudWater,     &
             doChannel, earthradius, effectiveOpticaldepth, frequencies, gph, &
             jblock, losvel, massMeandiameterice,                             &
             massMeandiameterwater, modelCloudradiance, my_catalog,           &
!            constrainCldRad, &
             & ptan,  radiance, sizeDistribution, state_ext,                  &
             state_los, superset, surfaceType, temp, thisFraction,  &
             totalExtinction, vmr, vmrarray )
 
    ! ------------------------------------
    ! Find which maf is called at present
    ! ------------------------------------
    maf = fmStat%maf

    ! --------------------------------------------
    ! Get the quantities we need and don't depend on
    ! the signal from the vectors
    ! --------------------------------------------

    ! --------
    ! Outputs:
    ! --------
    cloudExtinction => GetVectorQuantityByType ( fwdModelOut,            & 
        & quantityType=l_cloudExtinction, noerror=.true.)
    totalExtinction => GetVectorQuantityByType ( fwdModelOut,            &
      & quantityType=l_totalExtinction, noerror=.true.)
    massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,        &
      & quantityType=l_massMeanDiameterIce, noerror=.true. )
    massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,      &
      & quantityType=l_massMeanDiameterWater, noerror=.true. )

    ! -------
    ! Inputs:
    ! -------
    temp => GetVectorQuantityByType ( fwdModelExtra,                     &
      & quantityType=l_temperature )
    gph => GetVectorQuantityByType ( fwdModelExtra,                      &
      & quantityType=l_gph )
    cloudIce => GetVectorQuantityByType ( fwdModelExtra,                 &
      & quantityType=l_cloudIce )
    cloudWater => GetVectorQuantityByType ( fwdModelExtra,               &
      & quantityType=l_cloudWater )
    surfaceType => GetVectorQuantityByType ( fwdModelExtra,              &
      & quantityType=l_surfaceType )
    sizeDistribution=>GetVectorQuantityByType(fwdModelExtra,             &
      & quantityType=l_sizeDistribution )
    earthradius=>GetVectorQuantityByType ( fwdModelExtra,                &
      & quantityType=l_earthradius ) 
    scGeocAlt => GetVectorQuantityByType ( fwdModelExtra,                &
      & quantityType=l_scGeocAlt )

    !-----------------------------------------
    ! Make sure the quantities we need are got and with correct format
    !-----------------------------------------
    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
       & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true.,  &
       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
       & ModuleName, InvalidQuantity//'temperature' )

    ! ----------------------------
    ! Get some basic dimensions
    ! ----------------------------
    noSurf  = temp%template%noSurfs     ! Number of model layers
    if ( noSurf /= GPH%template%nosurfs ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & 'number of levels in gph does not match no of levels in temp' )

    !----------------------------
    ! get state quantity type (need both ext and los quantities for Jacobians)
    !----------------------------
    state_ext => GetVectorQuantityByType(FwdModelIn,quantityType=l_cloudExtinction)
    state_los => GetVectorQuantityByType(FwdModelIn,quantityType=l_LosTransFunc)

    ! Get s dimension
    noSgrid = state_los%template%noChans

    allocate ( Slevl(noSgrid), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'Slevl' )
    Slevl = state_los%template%frequencies

    ! Get number of cloud surfaces for retrieval
    noPSDSurf=sizeDistribution%template%noSurfs
    noIWCSurf=cloudice%template%noSurfs
    noLWCSurf=cloudwater%template%noSurfs
    noExtSurf=state_ext%template%noSurfs

    ! use Temp vGrid for all cloud variables
    allocate ( WC(ForwardModelConfig%no_cloud_species,NoSurf), STAT=status )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'WC' )
    allocate ( PSD(NoSurf), STAT=status )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, moduleName, &
      & MLSMSG_Allocate // 'PSD' )

    ! check if these dimensions are same
    if ( noIWCSurf /= noLWCSurf .or. noIWCSurf /= noExtSurf ) then
      call MLSMessage(MLSMSG_Error, ModuleName, &
      &'IWC, LWC and Extinction profiles have different vertical grids')
    end if

    nspec = size(forwardModelConfig%molecules)
    if ( nspec < 2 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )

    call allocate_test ( vmrArray, nspec, noSurf, 'vmrArray', ModuleName )
    vmrarray = 0._r8

    allocate ( My_Catalog(-1:1,nspec), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Allocate//'my_catalog' )   

    call allocate_test ( superset, size(antennaPatterns), &
      & 'superset', ModuleName )
    call Allocate_test ( a_massMeanDiameter, 2, noSurf, &
      & 'a_massMeanDiameter', ModuleName )

    !--------------------------------------------
    ! Loop over signals
    !--------------------------------------------
    do sigInd = 1, size(forwardModelConfig%signals)

    ! -------------------------------------
    ! Identify the signal (band)
    ! -------------------------------------

      signal = forwardModelConfig%signals(sigInd)

      if ( prt_log ) print*,'signal%index', signal%index

      ! find which channel is used
      noFreqs = size (signal%frequencies)
      do i=1, noFreqs
        if ( signal%channels(i) ) whichChannel=i    
      end do

      !-----------------------
      ! Think about sidebands
      !-----------------------
      call getSidebandStartStop ( signal, sidebandStart, sidebandStop ) 

      ! --------------------------------------------
      ! Get the quantities we need and that do depend
      ! on the signal from the vectors
      ! --------------------------------------------

      ! --------
      ! Outputs:
      ! --------
      radiance => GetVectorQuantityByType ( fwdModelOut,                   &
        & quantityType=l_radiance,                                         &
        & signal=signal%index, sideband=signal%sideband )
      modelCloudRadiance => GetVectorQuantityByType ( fwdModelOut,         &
        & quantityType=l_cloudInducedRadiance,                             &
        & signal=signal%index, sideband=signal%sideband )
      cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut,        &
        & quantityType=l_cloudRADSensitivity, noerror=.true.,              &
        & signal=signal%index, sideband=signal%sideband )
      effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut,      &
        & quantityType=l_effectiveOpticalDepth, noerror=.true.,            &
        & signal=signal%index, sideband=signal%sideband )

      ! -------
      ! Inputs:
      ! -------
      ptan => GetVectorQuantityByType ( fwdModelExtra,                     &
        & quantityType=l_ptan, instrumentModule = Signal%instrumentModule )
      losVel => GetVectorQuantityByType ( fwdModelExtra,                   &
        & quantityType=l_losVel, instrumentModule=Signal%instrumentModule )

      !-----------------------------------------
      ! Make sure the quantities we need are got and with correct format
      !-----------------------------------------
      if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true.,               &
         & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
         & ModuleName, InvalidQuantity//'ptan' )

      !----------------------------------
      ! Set up some temporary quantities
      !----------------------------------

      call Allocate_test ( closestInstances, radiance%template%noInstances,    &
        & 'closestInstances', ModuleName )      

      !------------------------
      ! Assemble the vmr array
      !------------------------
      !---------------------------------------------------------
      ! Work out the closest instances from temperature
      !---------------------------------------------------------
      call FindClosestInstances ( temp, radiance, closestInstances )
      instance = closestInstances(maf)
      tLat = temp%template%geodLat(1,instance)    ! get latitude for each instance

      ! ----------------------------
      ! Get some basic dimensions
      ! ----------------------------
      noMIFs  = radiance%template%noSurfs

      ! Interpolate PSD surfaces onto temperature vGrid if necessary
      if ( sizeDistribution%template%vGridIndex /= temp%template%vGridIndex ) then
        call InterpolateValues ( &
         & reshape(sizeDistribution%template%surfs(:,1),(/noPSDSurf/)), & ! Old X
         & reshape(sizeDistribution%values(:,instance),(/noPSDSurf/)),  & ! Old Y
         & reshape(temp%template%surfs(:,1),(/noSurf/)),                & ! New X
         & PSD, 'Linear')                                                 ! New Y
        call MLSMessage(MLSMSG_Warning, ModuleName, &
        &'Particle size dist vGrid is NOT same as Temperature and interpolation is enforced')
      else
          PSD = sizeDistribution%values(:,instance)
      end if

      if ( radiance%template%nosurfs /= ptan%template%nosurfs ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'number of levels in radiance does not match number of levels in ptan' )

      allocate ( a_Trans(noSgrid, noMIFs, noFreqs), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Allocate//'a_Trans' )

      ! now checking spectroscopy

      ! When using Bill's Spectral data, work out which spectroscopy we're going to need
      if ( forwardModelConfig%default_spectroscopy ) then  !Bill's clear-sky spectroscopy

        my_catalog = empty_cat
        do thisSideband = sidebandStart, sidebandStop, 2
          do j = 1, nspec      ! Loop over species
            ! ForwardModelSupport prevents beta grouping for cloud models.
            k = forwardModelConfig%molecules(j)
            if ( catalog(k)%molecule == l_none ) then
              call get_string ( lit_indices(k), molName )
              Call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'No spectroscopy catalog for '//trim(molName) )
            end if

            if ( associated ( catalog(k)%lines ) ) then
              ! Now subset the lines according to the signal we're using
              lineFlag => maxLineFlag(:size(catalog(k)%lines))
              lineFlag = .FALSE.
              do k = 1, size ( catalog(k)%lines )
                associate ( thisLine => lines(catalog(k)%lines(k)) )
                  if ( associated(thisLine%signals) ) then
                    doThis = any ( ( thisLine%signals == signal%index ) .and. &
                        & ( ( thisLine%sidebands == 0 ) .or. &
                        &   ( thisLine%sidebands == thisSideband ) ) )
                      ! If we're only doing one sideband, maybe we can remove some more lines
                      if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                      & any( ( thisLine%sidebands == sidebandStart ) .or. &
                      & ( thisLine%sidebands == 0 ) )
                    lineFlag(k) = lineFlag(k) .or. doThis
                  end if
                end associate
              end do               ! End loop over lines

              My_Catalog(thisSideband,j) = catalog(k)
              nullify ( my_catalog(thisSideband,j)%lines ) ! Don't deallocate it by mistake 

              ! Check we have at least one line for this

              call allocate_test ( my_catalog(thisSideband,j)%lines, count(lineFlag),&
                & 'my_catalog(?,?)%lines', ModuleName )
              my_catalog(thisSideband,j)%lines = pack ( catalog(k)%lines, lineFlag )
            else
              ! No lines for this species
              lineFlag => maxLineFlag(1:0)
              my_catalog(thisSideband,j) = catalog(k)
              nullify ( my_catalog(thisSideband,j)%lines ) ! Don't deallocate it by mistake
              call Allocate_test ( my_catalog(thisSideband,j)%lines, 0, &
                & 'my_catalog(?,?)%lines(0)', ModuleName )
            end if

            if ( count(lineFlag) == 0 ) then
              call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), &
                & molName )
              call getNameOfSignal ( signal, SignalName, sideband=thisSideband )
              call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'No lines for '//trim(molName)//' and '//trim(signalName) )
            end if

          end do ! End of Loop over species
        end do ! Loop over sidebands

      else          ! cloudy-sky spectroscopy

        do j = 1, nspec      ! Loop over species
          select case ( forwardModelConfig%molecules(j) )
          case ( l_h2o )
            ispec = 1
          case ( l_o3 )
            ispec = 2
          case ( l_n2o )
            ispec = 3
          case default
            cycle
          end select

          vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
            & quantityType=l_vmr, molecule=forwardModelConfig%molecules(j) )

          if ( .not.ValidateVectorQuantity( vmr, stacked=.true., coherent=.true., &
             & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,  &
             & ModuleName, InvalidQuantity//'vmr' )

          novmrSurf = vmr%template%nosurfs

          ! Interpolate vmr onto same grid as temperature if necessary
          if ( vmr%template%vGridIndex /= temp%template%vGridIndex ) then
            call InterpolateValues ( &
            & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
            & reshape(vmr%values(:,instance),(/novmrSurf/)),  &    ! Old Y
            & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
            & vmrArray(ispec,:),                              &    ! New Y
            & 'Linear', extrapolate='Clamp' )
          else
            vmrArray(ispec,:) = vmr%values(:,instance)
          end if

        end do ! End of Loop over species
      end if

      call allocate_test ( doChannel, noFreqs, 'doChannel', ModuleName )

      allocate ( zt(noMifs) )

      doChannel = .true.
      if ( associated ( signal%channels ) ) doChannel = signal%channels

      !-----------------------------------------------------
      ! Make temporary arrays for the cloud forward model
      !-----------------------------------------------------
      call Allocate_test ( a_clearSkyRadiance,                                 &
        & radiance%template%noSurfs, noFreqs,                                  &
        & 'a_clearSkyRadiance', ModuleName )
      call Allocate_test ( a_cloudInducedRadiance,                             &
        & radiance%template%noSurfs, noFreqs,                                  &
        & 'a_cloudInducedRadiance', ModuleName )
      call Allocate_test ( a_effectiveOpticalDepth,                            &
        & radiance%template%noSurfs, noFreqs,                                  &
        & 'a_effectiveOpticalDepth', ModuleName )
      call Allocate_test ( a_cloudRADSensitivity,                              &
        & radiance%template%noSurfs, noFreqs,                                  &
        & 'a_cloudRADSensitivity', ModuleName )
      call Allocate_test ( a_totalExtinction,                                  &
        & temp%template%noSurfs, noFreqs,                                      &
        & 'a_totalExtinction', ModuleName )
      call Allocate_test ( a_cloudExtinction,                                  &
        & temp%template%noSurfs, noFreqs,                                      &
        & 'a_cloudExtinction', ModuleName )

      do i = 1, ForwardModelConfig%no_cloud_species
        if ( noSurf == noIWCSurf ) then
          if ( i == 1 ) WC (i,:) = CloudIce%values(:,instance)
          if ( i == 2 ) WC (i,:) = CloudWater%values(:,instance)
        else
          if ( i == 1 ) &
            & call InterpolateValues ( &
            & reshape(CloudIce%template%surfs(:,1),(/noIWCSurf/)), &  ! Old X
            & reshape(CloudIce%values(:,instance),(/noIWCSurf/)),  &  ! Old Y
            & reshape(temp%template%surfs(:,1),(/noSurf/)),      &    ! New X
            & WC (i,:), 'Linear' )                                    ! New Y
          if ( i == 2 ) &
            & call InterpolateValues ( &
            & reshape(CloudWater%template%surfs(:,1),(/noLWCSurf/)), & ! Old X
            & reshape(CloudWater%values(:,instance),(/noLWCSurf/)),  & ! Old Y
            & reshape(temp%template%surfs(:,1),(/noSurf/)),          & ! New X
            & WC (i,:), 'Linear' )                                     ! New Y
        end if      
      end do

      if ( prt_log ) print*, 'jacobian is true'

      ! get tangent height from tangent pressure
      call InterpolateValues ( &
        & reshape(gph%template%surfs(:,1),(/noSurf/)), &    ! Old X
        & reshape(gph%values(:,instance),(/noSurf/)),  &    ! Old Y
        & reshape(ptan%values(:,maf),(/noMifs/)),      &    ! New X
        & zt, &                                             ! New Y
        & 'Linear' )

      if ( present(jacobian) ) then
        ! transmission functions for retrieval are calculated using artificial
        ! cloud profiles depending on where the measurement is taken in latitude
        if ( tLat >= -30._r8 .and. tLat <= 30._r8 ) then
          CloudType='Convective'
        else
          CloudType='Frontal'
        end if

        ! find cloud top index from observed Tcir, threshold to be determined
        !     for high Zt, use Tcir(maf)
        !     for low Zt, use Tcir(maf-2)
        ! --------------------------------------------------------------------
        ! find the cloud top using the cloudRadiance in fwdModelExtra 
        ! (should be only one cloud radiance quantity there)
        ! --------------------------------------------------------------------
!       constrainCldRad => GetVectorQuantityByType ( fwdModelExtra,     &           
!           & quantityType=l_cloudInducedRadiance)                                  

!       if ( .not. associated(constrainCldRad) ) then
!          call MLSMessage( MLSMSG_Error, ModuleName,                             & 
!                       'Need cloud radiances to estimate cloud top in retrieval' ) 
!       else                                                                        
        iCloudHeight = 0
!       if ( forwardModelConfig%cloud_der == l_iwc_high_height ) then
!         do mif = 1, noMifs
!           if ( constrainCldRad%values(whichchannel+(mif-1)*noFreqs,maf) /= 0.0_r8) &
!                & iCloudHeight = mif
!         end do
!       else
!         do mif = 1, noMifs
!           if ( constrainCldRad%values(whichchannel+(mif-1)*noFreqs,maf) /= 0.0_r8) & 
!                & iCloudHeight = mif
!         end do
!       end if
        ! if no cloud is found, cloud top is 20 km
        CloudHeight = 20.e3_r8     ! meters
        if ( iCloudHeight /= 0 ) CloudHeight = min(zt(iCloudHeight),CloudHeight)

        ! set up artificial cloud profile for retrieval use only
        call CLOUD_MODEL (CloudType, CloudHeight, gph%values(:,instance), &
          & noSurf, WC, ForwardModelConfig%no_cloud_species)
!       end if
      
      end if

      call Allocate_test ( frequencies, noFreqs, 'frequencies', ModuleName )

      ! It is equavelent to shift either spectral line frequencies or filter frequencies
      ! but the sign is opposite.
      ! Vel_Cor = 1.0_rp - losVel%values(1,maf)/c  ! for shift spectral lines
      Vel_Cor = 1.0_rp + losVel%values(1,maf)/c    ! for shift spectral channnels

      !--------------------------------------------
      ! Loop over sidebands 
      !--------------------------------------------

      call allocate_test ( thisFraction, noFreqs, 'thisFraction', ModuleName )

      if ( signal%sideband == 0 .or. forwardModelConfig%forceSidebandFraction ) then
        sidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_limbSidebandFraction, signal=signal%index, noError=.true. )
        lowerSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_limbSidebandFraction, signal=signal%index, &
          & sideband=-1, noError=.true. )
        upperSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType = l_limbSidebandFraction, signal=signal%index, &
          & sideband=1, noError=.true. )
        if ( .not. associated (sidebandFraction) .and. .not. &
          & ( associated ( lowerSidebandFraction) .and. associated ( upperSidebandFraction ) ) ) &
          & call MLSMessage(MLSMSG_Error,ModuleName, &
          & "No sideband ratio supplied")
      end if

      if ( toggle(emit) .and. levels(emit) > 0 ) then
        call Trace_Begin ( 'FullCloudForwardModel.SidebandLoop' )
      end if

      do thisSideband = sidebandStart, sidebandStop, 2

        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call Trace_Begin ( 'FullCloudForwardModel.Sideband ', index=thisSideband )

        !-----------------------------
        ! Setup a sideband ratio array
        !------------------------------

        elevOffset => GetVectorQuantityByType ( fwdModelExtra,               &
          & quantityType=l_elevOffset, signal=Signal%index, sideband=thisSideband )

        if ( signal%sideband == 0 .or. forwardModelConfig%forceSidebandFraction ) then
            if ( thisSideband == -1 ) then
              thisFraction = lowerSidebandFraction%values(:,1)
            else
              thisFraction = upperSidebandFraction%values(:,1)
            end if
        else                  ! Otherwise, want just unfolded signal
          thisFraction = 1.0
        end if

        direction = signal%direction

        frequencies = signal%centerFrequency + direction*signal%frequencies 

        if ( signal%sideband == 0 ) &
        frequencies = signal%lo + thisSideband * frequencies    ! double sideband cases

        if ( signal%sideband /= 0 ) &
        frequencies = signal%lo + signal%sideband * frequencies    ! signal sideband cases

        !--------------------------------------------
        ! VELOCITY shift correction to frequencies
        !--------------------------------------------

        frequencies =  Vel_Cor * frequencies

        if ( prt_log ) then
           print*, ' '
           print*,'No. of Frequencies:', noFreqs 
           print*,'Frequency=', frequencies/1e3_r8
        end if

        do j = 1, size(antennaPatterns)
          superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
               & ForwardModelConfig%signals( (/sigInd/) ), sideband=thisSideband, channel =1 )
        end do

        whichPattern = 1
        maxSuperset = maxval ( superset )
        where ( superset < 0 )
              superset = maxSuperset + 1
        end where
        whichPatternAsArray = minloc ( superset )
        whichPattern = whichPatternAsArray(1)
!        if ( toggle(emit) .and. levels(emit) > 2 ) then
!           call output ( 'Using antenna pattern: ' )    
!           call output ( whichPattern, advance='yes' )  
!        end if                                          

        !---------------------------------------------
        ! Now call the Full CloudForwardModel routine
        !---------------------------------------------
        !print*,instance,maxval(wc)

        call CloudForwardModel ( doChannel,                               &
          & noFreqs,                                                      &
          & noSurf,                                                       & 
          & noMifs,                                                       &
          & nspec,                                                        &
          & ForwardModelConfig%no_cloud_species,                          &
          & ForwardModelConfig%no_model_surfs,                            &
          & frequencies/1e3_r8,                                           &
          & signal%lo/1e3_r8,                                             &
          & 10.0**(-temp%template%surfs),                                 &
          & gph%values(:, instance),                                      &
          & temp%values(:,instance),                                      &
          & vmrArray,                                                     &
          & WC,                                                           &
          & int(PSD),                                                     &
          & zt,                                                           &
          & earthradius%values(1,1),                                      &
          & int(surfaceType%values(1, instance)),                         &
          & forwardModelConfig%cloud_der,                                 &
          & forwardModelConfig%i_saturation,                              &
          & forwardModelConfig%do_conv,                                   &
          & forwardModelConfig%default_spectroscopy,                      &
          & scGeocAlt%values(1,1),                                        &
          & elevOffset%values(1,1),                                       &
          & antennaPatterns(whichPattern),                                &
          & a_clearSkyRadiance,                                           &
          & a_cloudInducedRadiance,                                       &
          & a_trans,                                                      &
          & a_totalExtinction,                                            &
          & a_cloudExtinction,                                            &
          & a_massMeanDiameter,                                           &
          & a_effectiveOpticalDepth,                                      &
          & a_cloudRADSensitivity,                                        &
          & forwardModelConfig%NUM_SCATTERING_ANGLES,                     &  
          & forwardModelConfig%NUM_AZIMUTH_ANGLES,                        &
          & forwardModelConfig%NUM_AB_TERMS,                              &
          & forwardModelConfig%NUM_SIZE_BINS,                             &
          & Slevl*1000._r8, noSgrid,                                      &
          & My_Catalog(thisSideband,:),                                   &
          & losVel%values(1,1) )   
!          & losVel%values(1,maf) )
                                
        if ( prt_log ) print*, 'Successfully done with Full Cloud Foward Model ! '

        ! Output minor frame quantities if they are asked: check channel and type

        if ( sidebandStart == sidebandStop ) then
          radiance%values ( :, maf) =                                              &
            & reshape ( transpose(a_clearSkyRadiance),                             &
            & (/radiance%template%instanceLen/) )
          modelCloudRadiance%values ( :, maf ) =                                   &
            & reshape ( transpose(a_cloudInducedRadiance),                         &
            & (/modelCloudRadiance%template%instanceLen/) )
          if ( associated(effectiveOpticalDepth) )                                 &
            & effectiveOpticalDepth%values ( :, maf ) =                            &
            & reshape ( transpose(a_effectiveOpticalDepth),                        &
            & (/effectiveOpticalDepth%template%instanceLen/) )
          if ( associated(cloudRADSensitivity) )                                   &
            & cloudRADSensitivity%values ( :, maf ) =                              &
            & reshape ( transpose(a_cloudRADSensitivity),                          &
            & (/cloudRADSensitivity%template%instanceLen/) )
!          print*,maf,thissideband,a_clearSkyRadiance(:,25)
        else

          do i =1 , noFreqs
            if ( doChannel(i) ) then
              do mif=1, noMIFs

                radiance%values (i+(mif-1)*noFreqs, maf) =                         &
                  &               radiance%values (i+(mif-1)*noFreqs, maf)         &
                  &             + thisFraction(i)*a_clearSkyRadiance(mif,i) 

                modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) =              &
                  &        modelCloudRadiance%values (i+(mif-1)*noFreqs, maf )     &
                  &      + thisFraction(i)*a_cloudInducedRadiance(mif,i)

                if ( associated(effectiveOpticalDepth) )                              &
                  & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) =       &
                  &        effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf )  &
                  &      + thisFraction(i)*a_effectiveOpticalDepth(mif,i)

                if ( associated(cloudRADSensitivity) )                                &
                  & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =         &
                  &        cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf )    &  
                  &      + thisFraction(i)*a_cloudRADSensitivity(mif,i)

              end do
!   print*,maf,thissideband,i,thisFraction(i),a_cloudRADSensitivity(1,i),a_clearSkyRadiance(1,i)
            end if
          end do
! print*,maf,thissideband,a_clearSkyRadiance(:,25)
        end if

        if ( toggle(emit) .and. levels(emit) > 1 ) &
          & call Trace_End ( 'FullCloudForwardModel.Sideband ',index=thisSideband )

      !--------------------------------------------
      ! End of sideband loop 
      !--------------------------------------------
      end do

      if ( toggle(emit) .and. levels(emit) > 0 ) &      
        & call Trace_End ( 'FullCloudForwardModel.SidebandLoop' )

      ! -----------------------------------------------------------------------------
      ! output L2GP quantities
      ! -----------------------------------------------------------------------------

      ! To save disk space, we output one channel per band (first true doChannel)
      ! in the last signal (band) will over write all the previous signals (bands)

      FOUNDINFIRST = .true.
      do i=1, noFreqs
        if ( doChannel(i) .and. FOUNDINFIRST ) then
          FOUNDINFIRST = .false.
          if ( associated(cloudExtinction) ) &
            & cloudExtinction%values (:, instance )    = a_cloudExtinction(:,i)
          if ( associated(totalExtinction) ) &
            & totalExtinction%values (:, instance )    = a_totalExtinction (:,i)
        end if
      end do

      if ( associated(massMeanDiameterIce) ) &
        & massMeanDiameterIce%values (:,instance)   = a_massMeanDiameter(1,:)
      if ( associated(massMeanDiameterWater) ) &
        & massMeanDiameterWater%values(:, instance) =  a_massMeanDiameter(2,:)

      !-----------------------
      ! Start output Jacobian
      !-----------------------

        noInstances = state_ext%template%noInstances

      !--------------------------------------------
      ! Jacobian for high tangent height retrieval (only one frequency)
      !--------------------------------------------

      if ( forwardModelConfig%cloud_der == l_iwc_high_height &
        & .and. present(jacobian) ) then
      ! do not handle multiple signals and channels  
        if ( size(forwardModelConfig%signals) > 1 .and. size(doChannel) > 1 ) then
           print*,'only one frequency and one signal is allowed'
           stop
        end if

        colJBlock = FindBlock ( Jacobian%col, state_ext%index, maf)
        rowJBlock = FindBlock ( jacobian%row, radiance%index, maf)
        fmStat%rows(rowJBlock) = .true.

        jBlock => jacobian%block(rowJblock,colJblock)

          call CreateBlock ( jBlock, noMIFs, noExtSurf*noInstances, M_Full )
          jBlock%values = 0._rm

        !-------------------------------------------------------------------
        ! we use 100 times better resolution to compute weighting functions
        !-------------------------------------------------------------------
        nfine = 100
        if ( ForwardModelConfig%windowUnits /= PHYQ_Profiles ) &
          & call MLSMessage ( MLSMSG_Error, moduleName, &
            & 'Phi window units for full cloud forward model must be profiles' )
        nNear = sum(ForwardModelConfig%phiWindow)+1         ! default = 5
        ! only nearest instances are mattered
        minInst = max ( 1, instance - nint(ForwardModelConfig%phiWindow(1)) )
        maxInst = min ( instance + nint(ForwardModelConfig%phiWindow(2)), &
                      & noInstances )

        allocate( phi_fine(nfine*nNear), stat=status )
        allocate( z_fine(nfine*nNear), stat=status )
        allocate( zp_fine(nfine*nNear), stat=status )
        allocate( s_fine(nfine*nNear), stat=status )
        allocate( w_fine(nfine*nNear), stat=status )
        allocate( ds_fine(nfine*nNear), stat=status )

        do i=1,nNear*nfine
         phi_fine(i) = state_ext%template%phi(1,minInst) + &
           & (i-1._r8)/nfine/nNear*(state_ext%template%phi(1,maxInst) - &
           & state_ext%template%phi(1,minInst))
        end do

        !----------------------------------
        ! find vertical and horizontal intervals of stateQ at maf
        !----------------------------------
        ! vertical
        dz = abs(state_ext%template%surfs(2,1)-state_ext%template%surfs(1,1))
        ! horiozontal: in case of the last instance, use the previous one
        if ( instance < noInstances ) then
           dphi = abs(state_ext%template%phi(1,instance+1)-state_ext%template%phi(1,instance))
        else
           dphi = abs(state_ext%template%phi(1,instance-1)-state_ext%template%phi(1,instance))
        end if

        do mif = 1, noMIFs
          ! Jacobians at only tangent heights less than the top level of retrieval are calculated
          if ( state_ext%template%surfs(noExtSurf,1) > ptan%values(mif,maf) .and. &
             & state_ext%template%surfs(1,1) < ptan%values(mif,maf) ) then
            !------------------------------
            ! find z for given phi_fine
            !------------------------------
            z_fine = (earthradius%values(1,maf)+ zt(mif)) / &
             & cos((phi_fine - radiance%template%phi(mif,maf))*Deg2Rad) - &
             & earthradius%values(1,maf)
             ! convert back to log tangent pressure
             call InterpolateValues ( &
                & reshape(gph%values(:,instance),(/noSurf/)), &     ! Old X
                & reshape(gph%template%surfs(:,1),(/noSurf/)), &    ! Old Y
                & z_fine, &                                         ! New X
                & zp_fine, &                                        ! New Y
                & 'Linear' )

            !--------------------------------
            ! find ds and weight for each (z,phi) pair
            !--------------------------------
            s_fine = (earthradius%values(1,maf)+ zt(mif)) * &
             & sin((phi_fine - radiance%template%phi(mif,maf))*Deg2Rad)
            ds_fine = 0._r8    ! initialize it
            do i=1,nfine*nNear-1
             ds_fine(i) = s_fine(i+1) - s_fine(i)
            end do

             call InterpolateValues ( &
                & sLevl, &                                               ! Old X
                & reshape(a_trans(:,mif,whichChannel),(/noSgrid/)), &    ! Old Y
                & s_fine, &                                              ! New X
                & w_fine, &                                              ! New Y
                & 'Linear' )

            ! ds needs to be weighted by transmission function

            ds_fine = ds_fine*w_fine    ! ds is in meters

            !----------------------------------------------------------
            ! determine weights by the length inside each state domain
            !----------------------------------------------------------

             do i = minInst,maxInst             ! loop over closer profiles
             do j = 1,noExtSurf                 ! loop over cloudQty surface
             do k = 1,nfine*nNear               ! sum up all the lengths
               if ( abs(zp_fine(k) - state_ext%template%surfs(j,1)) < dz/2._r8 &
               & .AND. abs(phi_fine(k) - state_ext%template%phi(1,i)) < dphi/2._r8 ) &
               & jBlock%values(mif,j+(i-1)*noExtSurf) = &
               & jBlock%values(mif,j+(i-1)*noExtSurf) + ds_fine(k)/1.e3_r8
             end do
             end do
             end do
          end if
        end do         ! mif

        Deallocate( phi_fine, stat=status )
        Deallocate( z_fine, stat=status )
        Deallocate( zp_fine, stat=status )
        Deallocate( ds_fine, stat=status )
        Deallocate( w_fine, stat=status )
        Deallocate( s_fine, stat=status )

      end if     ! high tangent height case

      !--------------------------------------------
      ! Jacobian for low tangent height retrieval
      !--------------------------------------------
      if ( forwardModelConfig%cloud_der == l_iwc_low_height &
        & .and. present(jacobian) ) then

        colJBlock = FindBlock ( Jacobian%col, state_los%index, maf )
        rowJBlock = FindBlock ( jacobian%row, radiance%index, maf)
        fmStat%rows(rowJBlock) = .true.

        jBlock => jacobian%block(rowJblock,colJblock)

      ! to save space, the jacobian is packed in a full rectangle matrix
        call CreateBlock ( jBlock, noFreqs, noSgrid*noMIFs, M_Full )
        jBlock%values = 0.0_rm

        do j = 1, noFreqs
          if ( doChannel(j) ) then
             do mif = 1, noMIFs
               do i=1,noSgrid
               ! now we normalize cloud extinction weighting functions at 200GHz 
               ! and output the transmission functions via Jacobian
                 jBlock%values(j,i+(mif-1)*noSgrid)= a_trans(i,mif,j)* &
                    & (frequencies(j)/200000._r8)**4
               end do
             end do
          end if  ! doChannel
        end do    ! channel

      end if      ! low tangent height case

      !------------------------------
      ! End of output jacobian
      !------------------------------

      !------------------------------
      ! Remove temporary quantities
      !------------------------------

      call Deallocate_test ( a_cloudExtinction,       'a_cloudExtinction',       ModuleName )
      call Deallocate_test ( a_totalExtinction,       'a_totalExtinction',       ModuleName )
      call Deallocate_test ( a_cloudRADSensitivity,   'a_cloudRADSensitivity',   ModuleName )
      call Deallocate_test ( a_effectiveOpticalDepth, 'a_effectiveOpticalDepth', ModuleName )
      call Deallocate_test ( a_cloudInducedRadiance,  'a_cloudInducedRadiance',  ModuleName )
      call Deallocate_test ( a_clearSkyRadiance,      'a_clearSkyRadiance',      ModuleName )
      call Deallocate_test ( closestInstances,        'closestInstances',        ModuleName )
      call Deallocate_test ( doChannel,               'doChannel',               ModuleName )
      call Deallocate_test ( thisFraction,            'thisFraction',            ModuleName )
      call Deallocate_test ( frequencies,             'frequencies',             ModuleName )
      deallocate (a_trans, Zt, stat=ier )
      if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
        & MLSMSG_Deallocate//'a_trans or Zt' )

      if ( prt_log ) then
        print*, ' '
        print*, 'Time Instance: ', instance
      end if

    end do  ! End of signals

    call deallocate_test ( a_massMeanDiameter, 'a_massMeanDiameter', ModuleName )
    call deallocate_test ( superset,           'superset',           ModuleName )
    call deallocate_test ( vmrArray,           'vmrArray',           ModuleName )

    deallocate (PSD, Slevl, WC, stat=ier )
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'PSD, Slevl, WC, or Zt' )

    do i = 1, size(my_catalog,2)
      do thisSideband = sidebandStart, sidebandStop, 2
        call deallocate_test ( my_catalog(thisSideband,i)%lines, &
          & 'my_catalog(?,?)%lines', ModuleName )
        ! Note that we don't deallocate the signals/sidebands stuff for each line
        ! as these are shallow copies of the main spectroscopy catalog stuff
      end do
    end do
    deallocate ( my_catalog, stat=ier )
    if ( ier /= 0 ) Call MLSMessage ( MLSMSG_Error, ModuleName, &
      & MLSMSG_Deallocate//'my_catalog' )

    if ( toggle(emit) ) call trace_end ( 'FullCloudForwardModel' )

    if ( prt_log ) print*, 'Successfully done with full cloud forward wrapper !'

  end subroutine FullCloudForwardModelWrapper

!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id: FullCloudForwardModel.f90,v 1.143 2015/08/25 17:18:02 vsnyder Exp $"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module FullCloudForwardModel


! $Log: FullCloudForwardModel.f90,v $
! Revision 1.143  2015/08/25 17:18:02  vsnyder
! Allow PhiWindow to be a tuple, with the first element specifying the
! number of profiles/MAFs before the tangent point, and the second
! specifying the number after.  Require the PhiWindow units to be profiles.
!
! Revision 1.142  2011/07/29 01:47:07  vsnyder
! Make CloudIce a molecule
!
! Revision 1.141  2009/06/23 18:26:19  pwagner
! Prevent Intel from optimizing ident string away
!
! Revision 1.140  2009/05/13 20:10:20  vsnyder
! Move USE from module scope, get constants from Constants, kinds from MLSKINDS
!
! Revision 1.139  2008/10/03 21:04:26  livesey
! Added fixes to support EXTINCTIONV2 stuff
!
! Revision 1.138  2007/07/25 21:59:07  vsnyder
! Delete declaration for unused variable
!
! Revision 1.137  2007/06/29 19:35:06  vsnyder
! Make ForwardModelIntermediate_t private to ScanModelModule
!
! Revision 1.136  2005/06/22 18:27:38  pwagner
! Cant have access declared outside module scope
!
! Revision 1.135  2004/11/04 03:41:05  vsnyder
! Index spectroscopy catalog by molecule instead of searching
!
! Revision 1.134  2004/11/03 01:26:32  vsnyder
! Missed one size(molecules)-1 that should be size(molecules)
!
! Revision 1.133  2004/11/01 20:26:57  vsnyder
! Reorganization of representation for molecules and beta groups
!
! Revision 1.132  2004/10/21 01:33:35  vsnyder
! Move fetching of elevOffset to after trace_begin, some cannonball polishing
!
! Revision 1.131  2004/10/20 23:44:13  pwagner
! elevOffset Vector now found by signal, sideband
!
! Revision 1.130  2004/10/13 01:08:05  vsnyder
! Moved some checking to ForwardModelSupport
!
! Revision 1.129  2004/08/05 21:03:07  vsnyder
! Add sentinel at end of %molecules
!
! Revision 1.128  2004/06/10 01:00:14  vsnyder
! Move FindFirst, FindNext from MLSCommon to MLSSets
!
! Revision 1.127  2004/02/07 00:45:49  livesey
! Minor typo
!
! Revision 1.126  2004/02/05 23:30:20  livesey
! Finally turned on code to do correct handing of single sideband
! radiometers and their SB fractions.
!
! Revision 1.125  2004/01/08 00:52:43  jonathan
! delet output Using antenna pattern: etc
!
! Revision 1.124  2004/01/08 00:24:32  jonathan
! add tracing signals
!
! Revision 1.123  2003/11/21 19:17:40  dwu
! fix a bug from the last modification
!
! Revision 1.122  2003/11/21 17:55:57  dwu
! add vGrid check for size distribution
!
! Revision 1.121  2003/11/20 20:30:58  dwu
! fit the problem when IWC and Temp vGrid mismatch
!
! Revision 1.120  2003/07/09 20:17:22  livesey
! Anticipative bug fix in sideband fraction
!
! Revision 1.119  2003/05/29 16:38:03  livesey
! Renamed sideband fraction
!
! Revision 1.118  2003/05/16 23:53:56  livesey
! Removed reference to spectags
!
! Revision 1.117  2003/05/15 22:48:28  dwu
! changes
!
! Revision 1.116  2003/05/07 22:49:03  jonathan
! some clean-up and cosmetic changes
!
! Revision 1.115  2003/04/10 20:40:59  dwu
! make i_saturation and cloud_der as a verbal argument
!
! Revision 1.114  2003/04/08 20:03:55  dwu
! fix a bug in handling no of cloud species. now this number is meanful
!
! Revision 1.113  2003/04/05 17:30:43  dwu
! clean up
!
! Revision 1.112  2003/04/03 22:38:05  dwu
! change the way vmr and molecule are handled
!
! Revision 1.111  2003/04/03 01:18:41  dwu
! allow molecules in random order
!
! Revision 1.110  2003/04/03 01:15:51  dwu
! allow molecules in random order
!
! Revision 1.109  2003/04/02 20:00:12  dwu
! some clearup and replace ifov with do_conv
!
! Revision 1.108  2003/01/23 00:19:09  pwagner
! Some cosmetic only (or so I hope) changes
!
! Revision 1.107  2003/01/17 07:19:33  dwu
! properly initialize vmrArray
!
! Revision 1.106  2003/01/17 01:08:11  jonathan
! add vmrArray=0. after allocate
!
! Revision 1.105  2003/01/17 00:52:05  jonathan
! if specices missing, set VMR=0 accordingly
!
! Revision 1.104  2003/01/16 18:39:41  pwagner
! Removed some unused variables
!
! Revision 1.103  2003/01/13 17:59:52  jonathan
!  change cloud_width to i_saturation
!
! Revision 1.102  2003/01/09 21:08:09  dwu
! drop orbI
!
! Revision 1.101  2002/12/18 16:09:24  jonathan
! add phi_tan
!
! Revision 1.100  2002/11/30 21:31:46  dwu
! fix signal loop and move constrainCldRad inside jacobian loop
!
! Revision 1.99  2002/10/08 17:08:07  pwagner
! Added idents to survive zealous Lahey optimizer
!
! Revision 1.98  2002/10/04 00:02:15  vsnyder
! Change handling of GOT variable, some cosmetic changes
!
! Revision 1.97  2002/10/03 23:25:52  vsnyder
! Move USE statements from module scope to procedure scope
!
! Revision 1.96  2002/09/11 17:43:39  pwagner
! Began changes needed to conform with matrix%values type move to rm from r8
!
! Revision 1.95  2002/08/22 00:14:17  jonathan
! upgrade to include more molecules
!
! Revision 1.94  2002/08/19 22:22:03  jonathan
! debug stuff
!
! Revision 1.93  2002/08/08 22:46:30  jonathan
! newly improved version
!
! Revision 1.92  2002/05/08 17:03:39  jonathan
! use earthradius(1,1) for now
!
! Revision 1.91  2002/01/14 19:30:16  jonathan
! minor changes
!
! Revision 1.90  2001/11/16 00:49:05  jonathan
! clean log
!
! Revision 1.89  2001/11/16 00:47:13  jonathan
! change ptan from radiance%template%instrumentModule to Signal%instrumentModule
!
! Revision 1.88  2001/11/16 00:41:00  jonathan
! add losVel
!
! Revision 1.87  2001/11/15 23:52:12  jonathan
! rename DF_spectroscopy to default_spectroscopy
!
! Revision 1.86  2001/11/15 23:50:21  jonathan
! add DF_spectroscopy
!
! Revision 1.85  2001/11/09 18:12:13  jonathan
! add deallocate my_catalog
!
! Revision 1.84  2001/11/09 18:05:24  jonathan
! pass spectra catalog into CloudySkyRadianceModel
!
! Revision 1.83  2001/11/08 21:36:13  jonathan
! add SpectroscopyCatalog
!
! Revision 1.82  2001/11/07 23:47:52  dwu
! some minor changes
!
! Revision 1.81  2001/11/07 05:22:06  dwu
! fixed a bug in computing dphi
!
! Revision 1.80  2001/11/06 21:54:47  dwu
! use phiWindow to save time
!
! Revision 1.79  2001/11/06 20:06:31  dwu
! speed up Jacobian calculation for high tangent heights
!
! Revision 1.78  2001/11/06 19:52:42  dwu
! speed up Jacobian calculation for high tangent heights
!
! Revision 1.77  2001/11/06 18:28:06  dwu
! some cleanups
!
! Revision 1.76  2001/11/06 00:54:11  dwu
! add two cloud radiances: modelled and observed
!
! Revision 1.75  2001/11/06 00:29:38  dwu
! set up cloud height estimation using DTcir
!
! Revision 1.74  2001/11/05 22:39:57  dwu
! high Zt Jacobian
!
! Revision 1.73  2001/11/05 20:25:14  dwu
! *** empty log message ***
!
! Revision 1.72  2001/11/02 01:14:17  dwu
! correction in high cloud Jacobian
!
! Revision 1.71  2001/11/02 01:00:13  jonathan
! add IWC1
!
! Revision 1.70  2001/11/02 00:47:34  dwu
! correction in high cloud Jacobian
!
! Revision 1.69  2001/11/02 00:45:33  dwu
! correction in high cloud Jacobian
!
! Revision 1.68  2001/11/02 00:42:05  dwu
! correction in high cloud Jacobian
!
! Revision 1.67  2001/11/02 00:25:58  dwu
! correction in high cloud Jacobian
!
! Revision 1.66  2001/10/30 05:25:48  dwu
! assign whichchannle
!
! Revision 1.65  2001/10/19 19:29:50  dwu
! initialize output quantities
!
! Revision 1.64  2001/10/19 16:26:09  dwu
! some minors
!
! Revision 1.63  2001/10/18 22:17:02  dwu
! pretection for sensitivity=0
!
! Revision 1.62  2001/10/18 06:06:24  dwu
! minor
!
! Revision 1.61  2001/10/12 16:58:31  dwu
! distinguish number surfaces between model temperature grid and retrieval ext grid
!
! Revision 1.60  2001/10/11 22:44:01  dwu
! modify high zt Jacobian and use cloud_der as the switch between high and low Zt
!
! Revision 1.59  2001/10/11 17:01:11  jonathan
! for (cloud/total)extinction/output one channel per band
!
! Revision 1.58  2001/10/10 18:55:17  dwu
! why elevOffset is not maf-dependent?
!
! Revision 1.57  2001/10/10 18:33:53  dwu
! normalize cloud extinction weighting function to 200GHz
!
! Revision 1.56  2001/10/09 22:11:54  jonathan
! *** empty log message ***
!
! Revision 1.55  2001/10/09 17:50:17  jonathan
! *** empty log message ***
!
! Revision 1.54  2001/10/09 17:47:33  jonathan
! some changes
!
! Revision 1.53  2001/10/08 23:43:00  dwu
! fix jBlock%kind initialization
!
! Revision 1.52  2001/10/08 21:46:39  jonathan
! add CloudySkyModule
!
! Revision 1.50  2001/10/08 21:42:29  dwu
! *** empty log message ***
!
! Revision 1.49  2001/10/08 21:35:33  dwu
! *** empty log message ***
!
! Revision 1.48  2001/10/08 20:57:05  dwu
! change coljBlock finder
!
! Revision 1.47  2001/10/08 20:46:26  dwu
! add default cloudheight as 18km
!
! Revision 1.46  2001/10/08 20:34:18  dwu
! *** empty log message ***
!
! Revision 1.45  2001/10/08 20:23:54  jonathan
! some changes
!
! Revision 1.44  2001/10/08 19:25:48  jonathan
! delet vmrINS
!
! Revision 1.43  2001/10/07 23:42:17  jonathan
! add CloudProfile module
!
! Revision 1.42  2001/10/05 22:25:40  dwu
! allow multiple signals
!
! Revision 1.41  2001/10/05 20:46:39  dwu
! clean up input statements
!
! Revision 1.40  2001/10/05 20:26:12  dwu
! make sure the model output fields are associated
!
! Revision 1.39  2001/10/04 23:34:19  dwu
! *** empty log message ***
!
! Revision 1.38  2001/10/04 16:27:12  jonathan
! added framework for double sideband calculation, unfinished
!
! Revision 1.37  2001/10/04 00:29:36  dwu
! fix coljBlock
!
! Revision 1.36  2001/10/02 17:08:02  jonathan
! some adjustment due to construction
!
! Revision 1.35  2001/10/02 16:27:36  livesey
! Removed reference to fmStat%finished
!
! Revision 1.34  2001/10/01 23:40:26  jonathan
! construct codes for double sideband
!
! Revision 1.33  2001/09/28 21:45:50  dwu
! modify low cloud Jacobian output format
!
! Revision 1.32  2001/09/28 15:54:39  jonathan
! minor
!
! Revision 1.31  2001/09/26 19:17:02  dwu
! normalize weights for high tangent retrieval
!
! Revision 1.30  2001/09/24 23:16:40  dwu
! add derivatives for high tangent height retrievals
!
! Revision 1.29  2001/09/24 23:12:53  dwu
! add derivatives for high tangent height retrievals
!
! Revision 1.28  2001/09/21 15:51:37  jonathan
! modified F95 version
!
! Revision 1.27  2001/09/19 16:46:22  dwu
! some minor
!
! Revision 1.26  2001/09/19 00:25:59  dwu
! add M_banded to Jacobian
!
! Revision 1.25  2001/09/04 15:59:44  jonathan
! add cloud_fov, jonathan
!
! Revision 1.24  2001/08/17 21:48:41  jonathan
! Added FOV average, Jonathan
!
! Revision 1.23  2001/08/07 17:17:50  jonathan
! add radiance%template%instrumentModule to ptan
!
! Revision 1.22  2001/08/02 01:03:16  dwu
! add doChannel to frequency loop
!
! Revision 1.21  2001/08/01 20:51:30  dwu
! add delTau100
!
! Revision 1.20  2001/08/01 17:24:29  jonathan
! updated version
!
! Revision 1.19  2001/08/01 00:20:22  dwu
! add Jacobian -Jonathan/Wu
!
! Revision 1.17  2001/07/27 22:12:13  jonathan
! fixed bug in output extinction
!
! Revision 1.16  2001/07/27 20:26:24  jonathan
! jonathan
!
! Revision 1.15  2001/07/27 15:17:58  jonathan
! First Successful f90 runs
!



@


1.143
log
@Allow PhiWindow to be a tuple, with the first element specifying the
number of profiles/MAFs before the tangent point, and the second
specifying the number after.  Require the PhiWindow units to be profiles.
@
text
@d20 1
a20 1
  use ForwardModelConfig,         only: FORWARDMODELCONFIG_T   
d44 2
a45 2
    use AntennaPatterns_m,          only: ANTENNAPATTERNS
    use CloudySkyModule,            only: CLOUD_MODEL
d47 1
a47 1
    use ForwardModelIntermediate,   only: FORWARDMODELSTATUS_T
d49 3
a51 3
    use MatrixModule_0,             only: MATRIXELEMENT_T, &
                                        & M_FULL, CREATEBLOCK
    use MatrixModule_1,             only: MATRIX_T, FINDBLOCK
d57 2
a58 2
    use MLSSignals_m,               only: ARESIGNALSSUPERSET, GetNameOfSignal, &
                                        & GetSidebandStartStop, SIGNAL_T
d60 1
a60 1
!   use Output_m,                   only: OUTPUT
d62 3
a64 3
    use SpectroscopyCatalog_m,      only: CATALOG, CATALOG_T, EMPTY_CAT, &
                                        & LINE_T, LINES, MostLines
    use String_table,               only: GET_STRING
d68 2
a69 2
    use VectorsModule,              only: GETVECTORQUANTITYBYTYPE, VECTOR_T, &
                                        & VECTORVALUE_T, VALIDATEVECTORQUANTITY
d76 7
a82 7
                       & L_CLOUDEXTINCTION,                                    &
                       & L_CLOUDINDUCEDRADIANCE,                               &
                       & L_CLOUDRADSENSITIVITY,                                &
                       & L_CLOUDWATER,                                         &
                       & L_EARTHRADIUS,                                        &
                       & L_EFFECTIVEOPTICALDEPTH,                              &
                       & L_ELEVOFFSET,                                         &
d84 4
a87 4
                       & L_IWC_HIGH_HEIGHT,                                    &
                       & L_IWC_LOW_HEIGHT,                                     &
                       & L_LIMBSIDEBANDFRACTION,                               &
                       & L_LOSTRANSFUNC,                                       &
d89 10
a98 10
                       & L_MASSMEANDIAMETERICE,                                & 
                       & L_MASSMEANDIAMETERWATER,                              &
                       & L_NONE,                                               &
                       & L_PTAN,                                               &
                       & L_RADIANCE,                                           &
                       & L_SCGEOCALT,                                          &
                       & L_SIZEDISTRIBUTION,                                   &
                       & L_SURFACETYPE,                                        &
                       & L_TEMPERATURE,                                        &
                       & L_TOTALEXTINCTION,                                    &
d100 1
a100 1
                       & LIT_INDICES,                                          &
d106 5
a110 5
    type(forwardModelConfig_T),       intent(inout) :: FORWARDMODELCONFIG
    type(vector_T),                   intent(in)    :: FWDMODELIN, FwdModelExtra
    type(vector_T),                   intent(inout) :: FWDMODELOUT             ! Radiances, etc.
    type(forwardModelStatus_t),       intent(inout) :: FMSTAT                  ! Reverse comm. stuff
    type(matrix_T),                   intent(inout), optional :: JACOBIAN
d114 1
a114 1
    character(len=*), parameter :: INVALIDQUANTITY = &
d118 7
a124 7
    type (VectorValue_T), pointer :: CLOUDICE                   ! Profiles
    type (VectorValue_T), pointer :: CLOUDWATER                 ! Profiles
    type (VectorValue_T), pointer :: CLOUDEXTINCTION            ! Profiles
    type (VectorValue_T), pointer :: modelCLOUDRADIANCE         ! modelled cloud radiance
!   type (VectorValue_T), pointer :: constrainCldRad            ! observed cloud radiance
    type (VectorValue_T), pointer :: CLOUDRADSENSITIVITY        ! Like radiance
    type (VectorValue_T), pointer :: EFFECTIVEOPTICALDEPTH      ! Quantity
d126 9
a134 9
    type (VectorValue_T), pointer :: MASSMEANDIAMETERICE        ! Quantity
    type (VectorValue_T), pointer :: MASSMEANDIAMETERWATER      ! Quantity
    type (VectorValue_T), pointer :: PTAN                       ! Tgt pressure
    type (VectorValue_T), pointer :: RADIANCE                   ! Quantity
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION           ! Integer really
    type (VectorValue_T), pointer :: EARTHRADIUS                ! Scalar 
    type (VectorValue_T), pointer :: SURFACETYPE                ! Integer really
    type (VectorValue_T), pointer :: TEMP                       ! Temperature 
    type (VectorValue_T), pointer :: TOTALEXTINCTION            ! Profile
d136 2
a137 2
    type (VectorValue_T), pointer :: SCGEOCALT                  ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: ELEVOFFSET                 ! Elevation offset quantity
d139 6
a144 6
    type (Signal_T)               :: signal                     ! A signal
    type (VectorValue_T), pointer :: STATE_ext                  ! A state vector quantity
    type (VectorValue_T), pointer :: STATE_los                  ! A state vector quantity
    type (VectorValue_T), pointer :: SIDEBANDFRACTION              ! The sideband ratio to use
    type (VectorValue_T), pointer :: LOWERSIDEBANDFRACTION         ! From the state vector
    type (VectorValue_T), pointer :: UPPERSIDEBANDFRACTION         ! From the state vector
d146 1
a146 2
    type (catalog_T), dimension(:,:), pointer :: MY_CATALOG 
    type (line_T),    pointer :: thisLine
d149 18
a166 18
    type(MatrixElement_T), pointer :: JBLOCK       ! A block from the jacobian
    integer :: COLJBLOCK                           ! Column index in jacobian
    integer :: ROWJBLOCK                           ! Row index in jacobian
    integer :: noInstances                         ! no of instance
    integer :: noMIFs                              ! Number of minor frames
    integer :: noSgrid                             ! no of elements in S grid
    integer :: noSurf                              ! Number of pressure levels
    integer :: novmrSurf                           ! Number of vmr levels
    integer :: noExtSurf                           ! Number of cloud ext levels
    integer :: noIWCSurf                           ! Number of cloud IWC levels
    integer :: noLWCSurf                           ! Number of cloud LWC levels
    integer :: noPSDSurf                           ! Number of size dist. levels
    integer :: NOFREQS                             ! Number of frequencies
    integer :: DIRECTION                           ! Direction of channel numbering

    integer :: i                                   ! Loop counter
    integer :: j                                   ! Loop counter
    integer :: k                                   ! Loop counter
d168 1
a168 1
    integer :: mif
d170 1
a170 1
    integer :: INSTANCE                            ! Relevant instance for temperature
d173 6
a178 6
    integer :: nfine                               ! no of fine resolution grids
    integer :: nNear                               ! no of nearest profiles
    integer :: status                              ! allocation status 
    integer :: SIDEBANDSTART                       ! For sideband loop
    integer :: SIDEBANDSTOP                        ! For sideband loop
    integer :: THISSIDEBAND                        ! Loop counter for sidebands
d180 2
a181 2
    integer :: nspec                               ! no of species in cloud fw model
    integer :: ispec                               ! species index in cloud fw model
d185 1
a185 1
    integer, dimension(:), pointer :: closestInstances 
d193 7
a199 7
    real(r8), dimension(:,:), pointer :: A_CLEARSKYRADIANCE
    real(r8), dimension(:,:), pointer :: A_CLOUDINDUCEDRADIANCE
    real(r8), dimension(:,:), pointer :: A_CLOUDEXTINCTION
    real(r8), dimension(:,:), pointer :: A_CLOUDRADSENSITIVITY
    real(r8), dimension(:,:), pointer :: A_EFFECTIVEOPTICALDEPTH
    real(r8), dimension(:,:), pointer :: A_MASSMEANDIAMETER
    real(r8), dimension(:,:), pointer :: A_TOTALEXTINCTION
d203 1
a203 1
    real(r8), dimension(:), pointer :: thisFraction ! Sideband ratio values
d206 6
a211 6
    real(r8), dimension(:), pointer :: phi_fine    ! Fine resolution for phi 
    real(r8), dimension(:), pointer :: z_fine      ! Fine resolution for z
    real(r8), dimension(:), pointer :: zp_fine     ! Fine resolution for zp
    real(r8), dimension(:), pointer :: s_fine      ! Fine resolution for s
    real(r8), dimension(:), pointer :: ds_fine     ! Fine resolution for ds
    real(r8), dimension(:), pointer :: w_fine      ! weight along s_fine
d213 2
a214 2
    real(r8), dimension(:,:,:), allocatable  :: A_TRANS
    real(r8), dimension(:), pointer :: FREQUENCIES 
d226 1
a226 1
    logical, dimension(:), pointer :: LINEFLAG     ! Use this line (noLines per species)
d253 1
a253 1
             state_los, superset, surfaceType, temp, thisLine, thisFraction,  &
d490 12
a501 11
                thisLine => lines(catalog(k)%lines(k))
                if ( associated(thisLine%signals) ) then
                  doThis = any ( ( thisLine%signals == signal%index ) .and. &
                      & ( ( thisLine%sidebands == 0 ) .or. &
                      &   ( thisLine%sidebands == thisSideband ) ) )
                    ! If we're only doing one sideband, maybe we can remove some more lines
                    if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                    & any( ( thisLine%sidebands == sidebandStart ) .or. &
                    & ( thisLine%sidebands == 0 ) )
                  lineFlag(k) = lineFlag(k) .or. doThis
                end if
d1119 1
a1119 1
       "$Id: FullCloudForwardModel.f90,v 1.142 2011/07/29 01:47:07 vsnyder Exp $"
d1130 5
@


1.142
log
@Make CloudIce a molecule
@
text
@d100 2
a101 1
                       & LIT_INDICES
d931 4
a934 1
        nNear = ForwardModelConfig%phiWindow         ! default = 5
d936 3
a938 4
          minInst = instance - (nNear-1)/2
          maxInst = instance + (nNear-1)/2
           if ( minInst < 1 ) minInst = 1
           if ( maxInst > noInstances ) maxInst = noInstances
d1119 1
a1119 1
       "$Id: FullCloudForwardModel.f90,v 1.141 2009/06/23 18:26:19 pwagner Exp $"
d1130 3
@


1.141
log
@Prevent Intel from optimizing ident string away
@
text
@d29 1
a29 1
       "$RCSfile: $"
a76 1
                       & L_CLOUDICE,                                           &
d102 1
d1116 1
a1116 1
       "$Id: read_apriori.f90 is it here $"
d1127 3
@


1.140
log
@Move USE from module scope, get constants from Constants, kinds from MLSKINDS
@
text
@d29 1
a29 1
       "$RCSfile: FullCloudForwardModel.f90,v $"
d1113 1
a1114 1
!---------------------------- RCS Ident Info -------------------------------
d1116 2
a1117 3
       "$Id: FullCloudForwardModel.f90,v 1.139 2008/10/03 21:04:26 livesey Exp $"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------
d1119 1
d1121 1
d1127 3
@


1.139
log
@Added fixes to support EXTINCTIONV2 stuff
@
text
@d52 1
a52 1
    use MLSCommon,                  only: r8, rm, rp
d67 1
a67 1
    use Units,                      only: Deg2Rad                         
d1116 1
a1116 1
       "$Id: FullCloudForwardModel.f90,v 1.138 2007/07/25 21:59:07 vsnyder Exp $"
d1126 3
@


1.138
log
@Delete declaration for unused variable
@
text
@d780 1
d1116 1
a1116 1
       "$Id: FullCloudForwardModel.f90,v 1.137 2007/06/29 19:35:06 vsnyder Exp $"
d1126 3
@


1.137
log
@Make ForwardModelIntermediate_t private to ScanModelModule
@
text
@a145 1
    type (catalog_T), pointer :: thisCatalogEntry
d1115 1
a1115 1
       "$Id: FullCloudForwardModel.f90,v 1.136 2005/06/22 18:27:38 pwagner Exp $"
d1125 3
@


1.136
log
@Cant have access declared outside module scope
@
text
@d29 1
a29 1
       "$RCSfile: $"
d40 1
a40 1
                                            FwdModelExtra, FwdModelOut, Ifm, &
d47 1
a47 2
    use ForwardModelIntermediate,   only: FORWARDMODELINTERMEDIATE_T, &
                                        & FORWARDMODELSTATUS_T
a107 1
    type(forwardModelIntermediate_T), intent(inout) :: IFM                     ! Workspace
d1116 1
a1116 1
       "$Id: $"
d1126 3
@


1.135
log
@Index spectroscopy catalog by molecule instead of searching
@
text
@d1 10
a10 2
! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.
d27 3
a29 6
 !---------------------------- RCS Ident Info -------------------------------
  character (len=*), private, parameter :: IdParm =                          &
    "$Id: FullCloudForwardModel.f90,v 1.134 2004/11/03 01:26:32 vsnyder Exp $"
  character (len=len(idParm)), private :: Id = idParm
  character (len=*), private, parameter :: ModuleName=                       &
    "$RCSfile: FullCloudForwardModel.f90,v $"
d31 1
a31 1
 !---------------------------------------------------------------------------
d1116 5
d1128 3
@


1.134
log
@Missed one size(molecules)-1 that should be size(molecules)
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.133 2004/11/01 20:26:57 vsnyder Exp $"
a52 1
    use MLSSets,                    only: FINDFIRST
d251 2
a252 2
             state_los, superset, surfaceType, temp, thisCatalogentry,        &
             thisLine, thisFraction, totalExtinction, vmr, vmrarray )
d475 4
a478 5
            ! ForwardModelSupport prevents beta grouping.
            k = FindFirst ( catalog%molecule, forwardModelConfig%molecules(j) )
            if ( k == 0 ) then
              call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), &
                & molName )
a481 1
            thisCatalogEntry => Catalog ( k )
d483 1
a483 1
            if ( associated ( thisCatalogEntry%lines ) ) then
d485 1
a485 1
              lineFlag => maxLineFlag(:size(thisCatalogEntry%lines))
d487 2
a488 2
              do k = 1, size ( thisCatalogEntry%lines )
                thisLine => lines(thisCatalogEntry%lines(k))
d501 1
a501 1
              My_Catalog(thisSideband,j) = thisCatalogEntry
d508 1
a508 1
              my_catalog(thisSideband,j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
d512 1
a512 1
              my_catalog(thisSideband,j) = thisCatalogEntry
d1118 3
@


1.133
log
@Reorganization of representation for molecules and beta groups
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.132 2004/10/21 01:33:35 vsnyder Exp $"
d349 1
a349 3
    nspec = size(forwardModelConfig%molecules) - 1 ! Last one is a huge
    ! sentinel used by Get_Species_Data, not a molecule
    ! make sure we have enough molecules
d1121 3
@


1.132
log
@Move fetching of elevOffset to after trace_begin, some cannonball polishing
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.131 2004/10/20 23:44:13 pwagner Exp $"
d44 1
a44 5
    use MLSCommon,                  only: r8, rm, rp
    use MLSMessageModule,           only: MLSMessage, MLSMSG_Error, &
                                        & MLSMSG_Warning, MLSMSG_Deallocate
    use MLSSets,                    only: FINDFIRST
    use MLSSignals_m,               only: SIGNAL_T, ARESIGNALSSUPERSET
d48 8
a55 1
    use ManipulateVectorQuantities, only: FindClosestInstances
a56 1
    use Molecules,                  only: L_H2O, L_N2O, L_O3
d59 2
a60 1
    use SpectroscopyCatalog_m,      only: CATALOG_T, LINE_T, LINES, CATALOG
d119 1
a119 1
    type (VectorValue_T), pointer :: constrainCldRad            ! observed cloud radiance
d143 1
a143 1
    type (catalog_T), dimension(:), pointer :: MY_CATALOG 
a175 1
    integer :: SIDEBANDSTEP                        ! For sideband loop
d223 1
a223 1
    logical :: prt_log = .false.
d226 2
a227 1
    logical :: doThis                              ! Flag for lines
d229 3
a231 2
    character :: cloudtype                         ! cloud profile type
    character (len=32) :: molName       ! Name of a molecule
d248 1
a248 1
             jblock, lineFlag, losvel, massMeandiameterice,                   &
d250 2
a251 1
             constrainCldRad, ptan,  radiance, sizeDistribution, state_ext,   &
d260 107
d370 1
a370 1
    DO sigInd = 1, size(forwardModelConfig%signals)
d388 2
a389 30
      !----------------------- 

      if ( ( Signal%sideband == 0 ) .and.&
        &  ( Signal%singleSideband == 0 ) ) then     ! =1 only if R1A, R1B
         ! Do a folded measurement
         sidebandStart = -1
         sidebandStop = 1
         sidebandStep = 2
      else
         ! It's either a single sideband radiometer, or the user requested a
         ! specific sideband.
         ! Check sanity, if they are both non zero they should be the same.
         if ( ( Signal%singleSideband /= 0 ) .and. &
           &  ( Signal%sideband /= 0 ) .and. &
           &  ( Signal%singleSideband /= &
           &    Signal%sideband ) ) Call MLSMessage ( &
           & MLSMSG_Error, ModuleName, &
           & "User requested a sideband that doesn't exist" )
         ! OK, use whichever one is given
         if ( Signal%singleSideband /= 0 ) then
           sidebandStart = Signal%singleSideband           ! ==0 in case of R1A,B
         else
           sidebandStart = Signal%sideband                 ! \=0 all other cases
         end if
         sidebandStop = sidebandStart
         sidebandStep = 1
      end if
      !---------------------------
      ! END of thinking sidebands
      !---------------------------
d392 2
a393 1
      ! Get the quantities we need from the vectors
a404 2
      cloudExtinction => GetVectorQuantityByType ( fwdModelOut,            & 
          & quantityType=l_cloudExtinction, noerror=.true.)
a407 2
      totalExtinction => GetVectorQuantityByType ( fwdModelOut,            &
        & quantityType=l_totalExtinction, noerror=.true.)
a410 4
      massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,        &
        & quantityType=l_massMeanDiameterIce, noerror=.true. )
      massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,      &
        & quantityType=l_massMeanDiameterWater, noerror=.true. )
a416 16
      temp => GetVectorQuantityByType ( fwdModelExtra,                     &
        & quantityType=l_temperature )
      gph => GetVectorQuantityByType ( fwdModelExtra,                      &
        & quantityType=l_gph )
      cloudIce => GetVectorQuantityByType ( fwdModelExtra,                 &
        & quantityType=l_cloudIce )
      cloudWater => GetVectorQuantityByType ( fwdModelExtra,               &
        & quantityType=l_cloudWater )
      surfaceType => GetVectorQuantityByType ( fwdModelExtra,              &
        & quantityType=l_surfaceType )
      sizeDistribution=>GetVectorQuantityByType(fwdModelExtra,             &
        & quantityType=l_sizeDistribution )
      earthradius=>GetVectorQuantityByType ( fwdModelExtra,                &
        & quantityType=l_earthradius ) 
      scGeocAlt => GetVectorQuantityByType ( fwdModelExtra,                &
        & quantityType=l_scGeocAlt )
d419 1
a422 7

      if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
         & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
         & ModuleName, InvalidQuantity//'temperature' )
      if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true.,  &
         & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
         & ModuleName, InvalidQuantity//'temperature' )
a436 6
      nspec = size(forwardModelConfig%molecules) - 1 ! Last one is a huge
        ! sentinel used by Get_Species_Data, not a molecule
      ! make sure we have enough molecules
      if ( nspec < 2 ) &
        & call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
    
a447 1
      noSurf  = temp%template%noSurfs     ! Number of model layers
d449 2
a450 24
      !----------------------------
      ! get state quantity type (need both ext and los quantities for Jacobians)
      !----------------------------
      state_ext => GetVectorQuantityByType(FwdModelIn,quantityType=l_cloudExtinction)
      state_los => GetVectorQuantityByType(FwdModelIn,quantityType=l_LosTransFunc)

      ! Get number of cloud surfaces for retrieval
      noPSDSurf=sizeDistribution%template%noSurfs
      noIWCSurf=cloudice%template%noSurfs
      noLWCSurf=cloudwater%template%noSurfs
      noExtSurf=state_ext%template%noSurfs

      ! use Temp vGrid for all cloud variables
      allocate ( WC(ForwardModelConfig%no_cloud_species,NoSurf), STAT=status )
      allocate ( PSD(NoSurf), STAT=status )

      ! check if these dimensions are same
      if ( noIWCSurf /= noLWCSurf &
        & .or. noIWCSurf /= noExtSurf ) then
        call MLSMessage(MLSMSG_Error, ModuleName, &
        &'IWC, LWC and Extinction profiles have different vertical grids')
      end if

      if ( noPSDSurf /= noSurf ) then
d452 4
a455 4
         & reshape(sizeDistribution%template%surfs(:,1),(/noPSDSurf/)), &    ! Old X
         & reshape(sizeDistribution%values(:,instance),(/noPSDSurf/)),  &    ! Old Y
         & reshape(temp%template%surfs(:,1),(/noSurf/)),      &    ! New X
         & PSD, 'Linear')                                   ! New Y
d462 3
a464 7
      if ( noSurf /= GPH%template%nosurfs ) then
        call MLSMessage ( MLSMSG_Error, ModuleName,                            &
        & 'number of levels in gph does not match no of levels in temp' )
        else if ( radiance%template%nosurfs /= ptan%template%nosurfs ) then
        call MLSMessage ( MLSMSG_Error, ModuleName,                          &
        & 'number of levels in radiance does not match no of levels in ptan' )
      end if
d466 3
a468 7
      ! Get s dimension
      noSgrid=state_los%template%noChans

      Allocate( a_Trans(noSgrid, noMIFs, noFreqs))          
      Allocate( Slevl(noSgrid))

      Slevl = state_los%template%frequencies
a470 6
      call allocate_test ( vmrArray, nspec, noSurf, 'vmrArray', ModuleName )
      vmrarray = 0._r8

      allocate ( My_Catalog(nspec), stat=ier )
      if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
       & 'Unable to allocate my_catalog' )   
d472 2
a473 2
      do j = 1, nspec      ! Loop over species
        call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), molName )
d475 12
a486 2
        ! When using Bill's Spectral data, work out which spectroscopy we're going to need
        if ( forwardModelConfig%default_spectroscopy ) then  !Bill's clear-sky spectroscopy
d488 33
a520 6
          ! Skip if the next molecule is negative (indicates that this one is a parent)
          if ( forwardModelConfig%molecules(j) > 0 ) then
            if ( forwardModelConfig%molecules(j+1) < 0 ) then
              Call Allocate_test ( my_catalog(j)%lines, 0, &
                                & 'my_catalog(?)%lines(0)', ModuleName )
              cycle
a521 27
          end if

          thisCatalogEntry => Catalog ( FindFirst ( catalog%molecule, &
            & forwardModelConfig%molecules(j) ) )

          if ( associated ( thisCatalogEntry%lines ) ) then
            ! Now subset the lines according to the signal we're using
            Call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                             &  'lineFlag', ModuleName )
            lineFlag = .FALSE.
            do k = 1, size ( thisCatalogEntry%lines )
              thisLine => lines(thisCatalogEntry%lines(k))
              if ( associated(thisLine%signals) ) then
                doThis = any ( thisLine%signals == &
                  & signal%index )
                  ! If we're only doing one sideband, maybe we can remove some more lines
                  if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                  & any( ( thisLine%sidebands == sidebandStart ) .or. &
                  & ( thisLine%sidebands == 0 ) )
                lineFlag(k) = lineFlag(k) .or. doThis
              end if
            end do               ! End loop over lines

            My_Catalog(j) = thisCatalogEntry
            nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake 

            ! Check we have at least one line for this
d524 5
a528 2
              Call MLSMessage ( MLSMSG_Warning, ModuleName, &
                & 'No relevant lines for '//trim(molName) )
a529 11
            Call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
              & 'my_catalog(?)%lines', ModuleName )
            my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
            Call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
          else
            ! No lines for this species
            my_catalog(j) = thisCatalogEntry
            nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
            Call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
              & ModuleName )
          end if
d531 4
a534 1
        else          ! cloudy-sky spectroscopy
d536 3
a538 1
          if ( forwardModelConfig%molecules(j) == l_h2o ) then
d540 1
a540 1
          else if ( forwardModelConfig%molecules(j) == l_o3 ) then
d542 1
a542 1
          else if ( forwardModelConfig%molecules(j) == l_n2o ) then
d544 1
a544 1
          else
d546 1
a546 1
          end if
d557 11
a567 6
          call InterpolateValues ( &
          & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
          & reshape(vmr%values(:,instance),(/novmrSurf/)),  &    ! Old Y
          & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
          & vmrArray(ispec,:),                              &    ! New Y
          & 'Linear', extrapolate='Clamp' )
d569 2
a570 2
        end if
      end do ! End of Loop over species
a599 3
      call Allocate_test ( a_massMeanDiameter,                                 &
        & 2, temp%template%noSurfs,                                            &
        & 'a_massMeanDiameter', ModuleName )
a620 3
      call allocate_test ( superset, size(antennaPatterns), &
           & 'superset', ModuleName )

d709 1
a709 1
      do thisSideband = sidebandStart, sidebandStop, sidebandStep
d775 40
a814 39
        call CloudForwardModel ( doChannel,                                      &
          & noFreqs,                                                             &
          & noSurf,                                                              & 
          & noMifs,                                                              &
          & nspec,                                                               &
          & ForwardModelConfig%no_cloud_species,                                 &
          & ForwardModelConfig%no_model_surfs,                                   &
          & frequencies/1e3_r8,                                                  &
          & 10.0**(-temp%template%surfs),                                        &
          & gph%values(:, instance),                                             &
          & temp%values(:,instance),                                             &
          & vmrArray,                                                            &
          & WC,                                                                  &
          & int(PSD),                            &
          & zt,                                                                  &
          & earthradius%values(1,1),                                             &
          & int(surfaceType%values(1, instance)),                                &
          & forwardModelConfig%cloud_der,                                        &
          & forwardModelConfig%i_saturation,                                     &
          & forwardModelConfig%do_conv,                                          &
          & forwardModelConfig%default_spectroscopy,                             &
          & scGeocAlt%values(1,1),                                               &
          & elevOffset%values(1,1),                                              &
          & antennaPatterns(whichPattern),                                       &
          & a_clearSkyRadiance,                                                  &
          & a_cloudInducedRadiance,                                              &
          & a_trans,                                                             &
          & a_totalExtinction,                                                   &
          & a_cloudExtinction,                                                   &
          & a_massMeanDiameter,                                                  &
          & a_effectiveOpticalDepth,                                             &
          & a_cloudRADSensitivity,                                               &
          & forwardModelConfig%NUM_SCATTERING_ANGLES,                            &  
          & forwardModelConfig%NUM_AZIMUTH_ANGLES,                               &
          & forwardModelConfig%NUM_AB_TERMS,                                     &
          & forwardModelConfig%NUM_SIZE_BINS,                                    &
          & Slevl*1000._r8, noSgrid,                                             &
          & My_Catalog, losVel%values(1,1) )   
!          & My_Catalog, losVel%values(1,maf) )                    
d1068 13
a1080 14
      call deallocate_test ( superset, 'superset',          ModuleName )
      call Deallocate_test ( a_massMeanDiameter,'a_massMeanDiameter',ModuleName )
      call Deallocate_test ( a_cloudExtinction,'a_cloudExtinction',ModuleName )
      call Deallocate_test ( a_totalExtinction,'a_totalExtinction',ModuleName )
      call Deallocate_test ( a_cloudRADSensitivity,'a_cloudRADSensitivity',ModuleName )
      call Deallocate_test ( a_effectiveOpticalDepth,'a_effectiveOpticalDepth',ModuleName )
      call Deallocate_test ( a_cloudInducedRadiance,'a_cloudInducedRadiance',ModuleName )
      call Deallocate_test ( a_clearSkyRadiance,'a_clearSkyRadiance',ModuleName )
      call Deallocate_test ( vmrArray,'vmrArray',ModuleName )
      call Deallocate_test ( closestInstances,'closestInstances',ModuleName )
      call Deallocate_test ( doChannel, 'doChannel',        ModuleName )
      call Deallocate_test ( thisFraction, 'thisFraction',        ModuleName )
      call Deallocate_test (frequencies,'frequencies',ModuleName )
      Deallocate (a_trans, Slevl, Zt )
d1087 5
a1091 2
      Deallocate (WC, stat=ier )
      Deallocate (PSD, stat=ier )
d1093 3
a1095 1
    end do  ! End of signals
d1097 7
a1103 3
    do i = 1, size(my_catalog)
      call deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
        & ModuleName )
a1105 3
    ! Note that we don't deallocate the signals/sidebands stuff for each line
    ! as these are shallow copies of the main spectroscopy catalog stuff

d1123 3
@


1.131
log
@elevOffset Vector now found by signal, sideband
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.130 2004/10/13 01:08:05 vsnyder Exp $"
d56 1
d134 5
a138 5
    type(VectorValue_T),  pointer :: STATE_ext                  ! A state vector quantity
    type(VectorValue_T),  pointer :: STATE_los                  ! A state vector quantity
    type(VectorValue_T),  pointer :: SIDEBANDFRACTION              ! The sideband ratio to use
    type(VectorValue_T),  pointer :: LOWERSIDEBANDFRACTION         ! From the state vector
    type(VectorValue_T),  pointer :: UPPERSIDEBANDFRACTION         ! From the state vector
d239 10
a248 10
    nullify( a_clearSkyradiance, a_cloudExtinction, a_cloudInducedradiance,  &
             a_cloudRadsensitivity, a_effectiveOpticaldepth,                 &
             a_massMeandiameter, a_totalExtinction, cloudExtinction,         &
             cloudIce, cloudRadsensitivity, closestInstances, cloudWater, doChannel,           &
             earthradius, effectiveOpticaldepth, frequencies, gph, jblock,   &
             lineFlag, losvel, massMeandiameterice, massMeandiameterwater,   &
             modelCloudradiance, my_catalog, constrainCldRad, ptan,         &
             radiance, sizeDistribution, state_ext, state_los, superset,     &
             surfaceType, temp, thisCatalogentry, thisLine, thisFraction,       &
             totalExtinction, vmr, vmrarray )
d264 1
a264 1
       signal = forwardModelConfig%signals(sigInd)
d266 1
a266 1
       if (prt_log) print*,'signal%index', signal%index
d271 1
a271 1
        if (signal%channels(i)) whichChannel=i    
d274 10
a283 23
 !-----------------------
 ! Think about sidebands
 !----------------------- 

   if ( ( Signal%sideband == 0 ) .and.&
     &  ( Signal%singleSideband == 0 ) ) then     ! =1 only if R1A, R1B
      ! Do a folded measurement
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
   else
      ! It's either a single sideband radiometer, or the user requested a
      ! specific sideband.
      ! Check sanity, if they are both non zero they should be the same.
      if ( ( Signal%singleSideband /= 0 ) .and. &
        &  ( Signal%sideband /= 0 ) .and. &
        &  ( Signal%singleSideband /= &
        &    Signal%sideband ) ) Call MLSMessage ( &
        & MLSMSG_Error, ModuleName, &
        & "User requested a sideband that doesn't exist" )
      ! OK, use whichever one is given
      if ( Signal%singleSideband /= 0 ) then
        sidebandStart = Signal%singleSideband           ! ==0 in case of R1A,B
d285 17
a301 1
        sidebandStart = Signal%sideband                 ! \=0 all other cases
d303 84
a386 87
      sidebandStop = sidebandStart
      sidebandStep = 1
   end if
 !---------------------------
 ! END of thinking sidebands
 !---------------------------

    ! --------------------------------------------
    ! Get the quantities we need from the vectors
    ! --------------------------------------------

    ! --------
    ! Outputs:
    ! --------
        radiance => GetVectorQuantityByType ( fwdModelOut,                   &
          & quantityType=l_radiance,                                         &
          & signal=signal%index, sideband=signal%sideband )
        modelCloudRadiance => GetVectorQuantityByType ( fwdModelOut,         &
          & quantityType=l_cloudInducedRadiance,                             &
          & signal=signal%index, sideband=signal%sideband )
        cloudExtinction => GetVectorQuantityByType ( fwdModelOut,            & 
            & quantityType=l_cloudExtinction, noerror=.true.)
        cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut,        &
          & quantityType=l_cloudRADSensitivity, noerror=.true.,              &
          & signal=signal%index, sideband=signal%sideband )
        totalExtinction => GetVectorQuantityByType ( fwdModelOut,            &
          & quantityType=l_totalExtinction, noerror=.true.)
        effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut,      &
          & quantityType=l_effectiveOpticalDepth, noerror=.true.,            &
          & signal=signal%index, sideband=signal%sideband )
        massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,        &
          & quantityType=l_massMeanDiameterIce, noerror=.true. )
        massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,      &
          & quantityType=l_massMeanDiameterWater, noerror=.true. )

    ! -------
    ! Inputs:
    ! -------
        ptan => GetVectorQuantityByType ( fwdModelExtra,                     &
          & quantityType=l_ptan, instrumentModule = Signal%instrumentModule )
        temp => GetVectorQuantityByType ( fwdModelExtra,                     &
          & quantityType=l_temperature )
        gph => GetVectorQuantityByType ( fwdModelExtra,                      &
          & quantityType=l_gph )
        cloudIce => GetVectorQuantityByType ( fwdModelExtra,                 &
          & quantityType=l_cloudIce )
        cloudWater => GetVectorQuantityByType ( fwdModelExtra,               &
          & quantityType=l_cloudWater )
        surfaceType => GetVectorQuantityByType ( fwdModelExtra,              &
          & quantityType=l_surfaceType )
        sizeDistribution=>GetVectorQuantityByType(fwdModelExtra,             &
          & quantityType=l_sizeDistribution )
        earthradius=>GetVectorQuantityByType ( fwdModelExtra,                &
          & quantityType=l_earthradius ) 
        scGeocAlt => GetVectorQuantityByType ( fwdModelExtra,                &
          & quantityType=l_scGeocAlt )
        losVel => GetVectorQuantityByType ( fwdModelExtra,                   &
          & quantityType=l_losVel, instrumentModule=Signal%instrumentModule )
    !-----------------------------------------
    ! Make sure the quantities we need are got and with correct format
    !-----------------------------------------

    if ( .not. ValidateVectorQuantity(temp, stacked=.true., coherent=.true., &
       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
       & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true.,  &
       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
       & ModuleName, InvalidQuantity//'temperature' )
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true.,               &
       & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,   &
       & ModuleName, InvalidQuantity//'ptan' )

    !----------------------------------
    ! Set up some temporary quantities
    !----------------------------------

    call Allocate_test ( closestInstances, radiance%template%noInstances,    &
      & 'closestInstances', ModuleName )      

    !------------------------
    ! Assemble the vmr array
    !------------------------
    nspec = size(forwardModelConfig%molecules) - 1 ! Last one is a huge
      ! sentinel used by Get_Species_Data, not a molecule
    ! make sure we have enough molecules
    if ( nspec < 2 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
d388 61
a448 47
    !---------------------------------------------------------
    ! Work out the closest instances from temperature
    !---------------------------------------------------------
    call FindClosestInstances ( temp, radiance, closestInstances )
    instance = closestInstances(maf)
    tLat = temp%template%geodLat(1,instance)    ! get latitude for each instance

    ! ----------------------------
    ! Get some basic dimensions
    ! ----------------------------
    noMIFs  = radiance%template%noSurfs
    noSurf  = temp%template%noSurfs     ! Number of model layers

    !----------------------------
    ! get state quantity type (need both ext and los quantities for Jacobians)
    !----------------------------
       state_ext => GetVectorQuantityByType(FwdModelIn,quantityType=l_cloudExtinction)
       state_los => GetVectorQuantityByType(FwdModelIn,quantityType=l_LosTransFunc)

        ! Get number of cloud surfaces for retrieval
        noPSDSurf=sizeDistribution%template%noSurfs
        noIWCSurf=cloudice%template%noSurfs
        noLWCSurf=cloudwater%template%noSurfs
        noExtSurf=state_ext%template%noSurfs

        ! use Temp vGrid for all cloud variables
        allocate ( WC(ForwardModelConfig%no_cloud_species,NoSurf), STAT=status )
        allocate ( PSD(NoSurf), STAT=status )

        ! check if these dimensions are same
        if(noIWCSurf .ne. noLWCSurf &
          & .or. noIWCSurf .ne. noExtSurf) then
          call MLSMessage(MLSMSG_Error, ModuleName, &
          &'IWC, LWC and Extinction profiles have different vertical grids')
        endif
        
        if(noPSDSurf .ne. noSurf) then
          call InterpolateValues ( &
           & reshape(sizeDistribution%template%surfs(:,1),(/noPSDSurf/)), &    ! Old X
           & reshape(sizeDistribution%values(:,instance),(/noPSDSurf/)),  &    ! Old Y
           & reshape(temp%template%surfs(:,1),(/noSurf/)),      &    ! New X
           & PSD, 'Linear')                                   ! New Y
          call MLSMessage(MLSMSG_Warning, ModuleName, &
          &'Particle size dist vGrid is NOT same as Temperature and interpolation is enforced')
        else
            PSD = sizeDistribution%values(:,instance)
        endif
d450 1
a450 29
        if (noSurf .ne. GPH%template%nosurfs) then
         call MLSMessage ( MLSMSG_Error, ModuleName,                            &
         & 'number of levels in gph does not match no of levels in temp' )
         else if (radiance%template%nosurfs .ne. ptan%template%nosurfs) then
         call MLSMessage ( MLSMSG_Error, ModuleName,                          &
         & 'number of levels in radiance does not match no of levels in ptan' )
         endif
         
        ! Get s dimension
        noSgrid=state_los%template%noChans
        
          Allocate( a_Trans(noSgrid, noMIFs, noFreqs))          
          Allocate( Slevl(noSgrid))

          Slevl = state_los%template%frequencies

! now checking spectroscopy
    call allocate_test ( vmrArray, nspec, noSurf, 'vmrArray', ModuleName )
    vmrarray = 0._r8

    allocate ( My_Catalog(nspec), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     & 'Unable to allocate my_catalog' )   
     
    do j = 1, nspec      ! Loop over species
      call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), molName )
    
      ! When using Bill's Spectral data, work out which spectroscopy we're going to need
      if(forwardModelConfig%default_spectroscopy) then  !Bill's clear-sky spectroscopy
d452 21
a472 6
        ! Skip if the next molecule is negative (indicates that this one is a parent)
        if ( (j < nspec) .and. (forwardModelConfig%molecules(j)>0)) then
          if ( forwardModelConfig%molecules(j+1) < 0 ) then
            Call Allocate_test ( my_catalog(j)%lines, 0, &
                              & 'my_catalog(?)%lines(0)', ModuleName )
            CYCLE
a473 1
        end if
d475 2
a476 2
        thisCatalogEntry => Catalog ( FindFirst ( catalog%molecule, &
          & forwardModelConfig%molecules(j) ) )
d478 8
a485 8
        if ( associated ( thisCatalogEntry%lines ) ) then
          ! Now subset the lines according to the signal we're using
          Call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                           &  'lineFlag', ModuleName )
          lineFlag = .FALSE.
          do k = 1, size ( thisCatalogEntry%lines )
            thisLine => lines(thisCatalogEntry%lines(k))
            if ( associated(thisLine%signals) ) then
d493 11
d505 11
a515 1
          end do               ! End loop over lines
d517 1
a517 2
          My_Catalog(j) = thisCatalogEntry
          nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake 
d519 9
a527 17
          ! Check we have at least one line for this

          if ( count(lineFlag) == 0 ) then
            Call MLSMessage ( MLSMSG_Warning, ModuleName, &
              & 'No relevant lines for '//trim(molName) )
          endif
          Call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
            & 'my_catalog(?)%lines', ModuleName )
          my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
          Call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
        else
          ! No lines for this species
          my_catalog(j) = thisCatalogEntry
          nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
          Call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
            & ModuleName )
        end if
d529 2
a530 1
      else          ! cloudy-sky spectroscopy
d532 3
a534 9
        if ( forwardModelConfig%molecules(j) == l_h2o ) then
          ispec = 1
        else if ( forwardModelConfig%molecules(j) == l_o3 ) then
          ispec = 2
        else if ( forwardModelConfig%molecules(j) == l_n2o ) then
          ispec = 3
        else
          cycle
        end if
d536 1
a536 2
        vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
          & quantityType=l_vmr, molecule=forwardModelConfig%molecules(j) )
d538 6
a543 3
        if (.not.ValidateVectorQuantity( vmr, stacked=.true., coherent=.true., &
           & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,  &
           & ModuleName, InvalidQuantity//'vmr' )
d545 2
a546 1
        novmrSurf = vmr%template%nosurfs
d548 1
a548 6
        call InterpolateValues ( &
        & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
        & reshape(vmr%values(:,instance),(/novmrSurf/)),  &    ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
        & vmrArray(ispec,:),                              &    ! New Y
        & 'Linear', extrapolate='Clamp' )
d550 1
a550 6
      end if
    end do ! End of Loop over species
     
    call allocate_test ( doChannel, noFreqs, 'doChannel', ModuleName )
    
    allocate ( zt(noMifs) )
d552 2
a553 2
    doChannel = .true.
    if ( associated ( signal%channels ) ) doChannel = signal%channels
d555 44
a598 44
    !-----------------------------------------------------
    ! Make temporary arrays for the cloud forward model
    !-----------------------------------------------------
    call Allocate_test ( a_clearSkyRadiance,                                 &
      & radiance%template%noSurfs, noFreqs,                                  &
      & 'a_clearSkyRadiance', ModuleName )
    call Allocate_test ( a_cloudInducedRadiance,                             &
      & radiance%template%noSurfs, noFreqs,                                  &
      & 'a_cloudInducedRadiance', ModuleName )
    call Allocate_test ( a_effectiveOpticalDepth,                            &
      & radiance%template%noSurfs, noFreqs,                                  &
      & 'a_effectiveOpticalDepth', ModuleName )
    call Allocate_test ( a_cloudRADSensitivity,                              &
      & radiance%template%noSurfs, noFreqs,                                  &
      & 'a_cloudRADSensitivity', ModuleName )
    call Allocate_test ( a_totalExtinction,                                  &
      & temp%template%noSurfs, noFreqs,                                      &
      & 'a_totalExtinction', ModuleName )
    call Allocate_test ( a_cloudExtinction,                                  &
      & temp%template%noSurfs, noFreqs,                                      &
      & 'a_cloudExtinction', ModuleName )
    call Allocate_test ( a_massMeanDiameter,                                 &
      & 2, temp%template%noSurfs,                                            &
      & 'a_massMeanDiameter', ModuleName )
    
    do i=1,ForwardModelConfig%no_cloud_species
     if(noSurf .eq. noIWCSurf) then
      if(i .eq. 1) WC (i,:) = CloudIce%values(:,instance)
      if(i .eq. 2) WC (i,:) = CloudWater%values(:,instance)
     else
      if(i .eq. 1) &
        & call InterpolateValues ( &
        & reshape(CloudIce%template%surfs(:,1),(/noIWCSurf/)), &    ! Old X
        & reshape(CloudIce%values(:,instance),(/noIWCSurf/)),  &    ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)),      &    ! New X
        & WC (i,:), 'Linear' )                                   ! New Y
      if(i .eq. 2) &
        & call InterpolateValues ( &
        & reshape(CloudWater%template%surfs(:,1),(/noLWCSurf/)), &    ! Old X
        & reshape(CloudWater%values(:,instance),(/noLWCSurf/)),  &    ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)),      &    ! New X
        & WC (i,:), 'Linear' )                                   ! New Y
     endif      
    enddo
d600 2
a601 2
    call allocate_test ( superset, size(antennaPatterns), &
         & 'superset', ModuleName )
d603 1
a603 1
    if (prt_log) print*, 'jacobian is true'
d605 1
a605 1
     ! get tangent height from tangent pressure
d613 4
a616 4
     IF ( present(jacobian) ) THEN
      ! transmission functions for retrieval are calculated using artificial
      ! cloud profiles depending on where the measurement is taken in latitude
       if (tLat .ge. -30._r8 .and. tLat .le. 30._r8) then
d618 1
a618 1
       else
d620 1
a620 1
       endif
d622 16
a637 16
    ! find cloud top index from observed Tcir, threshold to be determined
    !     for high Zt, use Tcir(maf)
    !     for low Zt, use Tcir(maf-2)
    ! --------------------------------------------------------------------
    ! find the cloud top using the cloudRadiance in fwdModelExtra 
    ! (should be only one cloud radiance quantity there)
    ! --------------------------------------------------------------------
!      constrainCldRad => GetVectorQuantityByType ( fwdModelExtra,     &
!          & quantityType=l_cloudInducedRadiance)

!      if(.not. associated(constrainCldRad)) then
!         call MLSMessage( MLSMSG_Error, ModuleName,                             &
!                      'Need cloud radiances to estimate cloud top in retrieval' )
!      else
       iCloudHeight = 0
!       if(forwardModelConfig%cloud_der == l_iwc_high_height) then
d639 1
a639 1
!           if(constrainCldRad%values(whichchannel+(mif-1)*noFreqs,maf) .ne. 0.0_r8) &
d641 1
a641 1
!         enddo
d644 1
a644 1
!           if(constrainCldRad%values(whichchannel+(mif-1)*noFreqs,maf) .ne. 0.0_r8) & 
d646 9
a654 1
!         enddo
a655 8
       ! if no cloud is found, cloud top is 20 km
       CloudHeight = 20.e3_r8     ! meters
       if(iCloudHeight .ne. 0) CloudHeight = min(zt(iCloudHeight),CloudHeight)

      ! set up artificial cloud profile for retrieval use only
       call CLOUD_MODEL (CloudType, CloudHeight, gph%values(:,instance), &
         & noSurf, WC, ForwardModelConfig%no_cloud_species)
!      end if
d657 1
a657 1
    ENDIF
d659 1
a659 1
    call Allocate_test ( frequencies, noFreqs, 'frequencies', ModuleName )
d661 8
a668 4
    ! It is equavelent to shift either spectral line frequencies or filter frequencies
    ! but the sign is opposite.
    ! Vel_Cor = 1.0_rp - losVel%values(1,maf)/299792458.3_rp    ! for shift spectral lines
    Vel_Cor = 1.0_rp + losVel%values(1,maf)/299792458.3_rp  ! for shift spectral channnels
d670 25
a694 3
    !--------------------------------------------
    ! Loop over sidebands 
    !--------------------------------------------
d696 3
a698 1
    call allocate_test ( thisFraction, noFreqs, 'thisFraction', ModuleName )
d700 2
a701 29
    if ( signal%sideband == 0 .or. forwardModelConfig%forceSidebandFraction ) then
      sidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, noError=.true. )
      lowerSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, &
        & sideband=-1, noError=.true. )
      upperSidebandFraction => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_limbSidebandFraction, signal=signal%index, &
        & sideband=1, noError=.true. )
      if (.not. associated (sidebandFraction) .and. .not. &
        & ( associated ( lowerSidebandFraction) .and. associated ( upperSidebandFraction ) ) ) &
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
    end if

   if ( toggle(emit) .and. levels(emit) > 0 ) then
      call Trace_Begin ( 'FullCloudForwardModel.SidebandLoop' )
    end if

    do thisSideband = sidebandStart, sidebandStop, sidebandStep

      elevOffset => GetVectorQuantityByType ( fwdModelExtra,               &
        & quantityType=l_elevOffset, signal=Signal%index, sideband=thisSideband )
      if ( toggle(emit) .and. levels(emit) > 1 ) &
        & call Trace_Begin ( 'FullCloudForwardModel.Sideband ', index=thisSideband )

    !-----------------------------
    ! Setup a sideband ratio array
    !------------------------------
d703 9
a711 9
      if ( signal%sideband == 0 .or. forwardModelConfig%forceSidebandFraction ) then
          if ( thisSideband == -1 ) then
            thisFraction = lowerSidebandFraction%values(:,1)
          else
            thisFraction = upperSidebandFraction%values(:,1)
          end if
      else                  ! Otherwise, want just unfolded signal
        thisFraction = 1.0
      end if
d713 1
a713 1
    direction = signal%direction
d715 1
a715 1
    frequencies = signal%centerFrequency + direction*signal%frequencies 
d717 1
a717 1
        if(signal%sideband == 0) &
d720 1
a720 1
        if(signal%sideband /= 0) &
d723 16
a738 16
!--------------------------------------------
! VELOCITY shift correction to frequencies
!--------------------------------------------

          frequencies =  Vel_Cor * frequencies
        
    if (prt_log) then
       print*, ' '
       print*,'No. of Frequencies:', noFreqs 
       print*,'Frequency=', frequencies/1e3_r8
    endif

    do j = 1, size(antennaPatterns)
      superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
           & ForwardModelConfig%signals( (/sigInd/) ), sideband=thisSideband, channel =1 )
    end do
d740 56
a795 56
    whichPattern = 1
    maxSuperset = maxval ( superset )
    where ( superset < 0 )
          superset = maxSuperset + 1
    end where
    whichPatternAsArray = minloc ( superset )
    whichPattern = whichPatternAsArray(1)
!    if ( toggle(emit) .and. levels(emit) > 2 ) then
!       call output ( 'Using antenna pattern: ' )
!       call output ( whichPattern, advance='yes' )
!    end if

    !---------------------------------------------
    ! Now call the Full CloudForwardModel routine
    !---------------------------------------------
    !print*,instance,maxval(wc)
 
    call CloudForwardModel ( doChannel,                                      &
      & noFreqs,                                                             &
      & noSurf,                                                              & 
      & noMifs,                                                              &
      & nspec,                                                               &
      & ForwardModelConfig%no_cloud_species,                                 &
      & ForwardModelConfig%no_model_surfs,                                   &
      & frequencies/1e3_r8,                                                  &
      & 10.0**(-temp%template%surfs),                                        &
      & gph%values(:, instance),                                             &
      & temp%values(:,instance),                                             &
      & vmrArray,                                                            &
      & WC,                                                                  &
      & int(PSD),                            &
      & zt,                                                                  &
      & earthradius%values(1,1),                                             &
      & int(surfaceType%values(1, instance)),                                &
      & forwardModelConfig%cloud_der,                                        &
      & forwardModelConfig%i_saturation,                                     &
      & forwardModelConfig%do_conv,                                          &
      & forwardModelConfig%default_spectroscopy,                             &
      & scGeocAlt%values(1,1),                                               &
      & elevOffset%values(1,1),                                              &
      & antennaPatterns(whichPattern),                                       &
      & a_clearSkyRadiance,                                                  &
      & a_cloudInducedRadiance,                                              &
      & a_trans,                                                             &
      & a_totalExtinction,                                                   &
      & a_cloudExtinction,                                                   &
      & a_massMeanDiameter,                                                  &
      & a_effectiveOpticalDepth,                                             &
      & a_cloudRADSensitivity,                                               &
      & forwardModelConfig%NUM_SCATTERING_ANGLES,                            &  
      & forwardModelConfig%NUM_AZIMUTH_ANGLES,                               &
      & forwardModelConfig%NUM_AB_TERMS,                                     &
      & forwardModelConfig%NUM_SIZE_BINS,                                    &
      & Slevl*1000._r8, noSgrid,                                             &
      & My_Catalog, losVel%values(1,1) )   
!      & My_Catalog, losVel%values(1,maf) )                    
d797 1
a797 1
    if (prt_log) print*, 'Successfully done with Full Cloud Foward Model ! '
d799 1
a799 1
    ! Output minor frame quantities if they are asked: check channel and type
d801 39
a839 39
   if ( sidebandStart == sidebandStop ) then
     radiance%values ( :, maf) =                                              &
       & reshape ( transpose(a_clearSkyRadiance),                             &
       & (/radiance%template%instanceLen/) )
     modelCloudRadiance%values ( :, maf ) =                                   &
       & reshape ( transpose(a_cloudInducedRadiance),                         &
       & (/modelCloudRadiance%template%instanceLen/) )
     if(associated(effectiveOpticalDepth))                                    &
       & effectiveOpticalDepth%values ( :, maf ) =                            &
       & reshape ( transpose(a_effectiveOpticalDepth),                        &
       & (/effectiveOpticalDepth%template%instanceLen/) )
     if(associated(cloudRADSensitivity))                                      &
       & cloudRADSensitivity%values ( :, maf ) =                              &
       & reshape ( transpose(a_cloudRADSensitivity),                          &
       & (/cloudRADSensitivity%template%instanceLen/) )
!     print*,maf,thissideband,a_clearSkyRadiance(:,25)
   else
    
     do i =1 , noFreqs
       if (doChannel(i)) then
         do mif=1, noMIFs

           radiance%values (i+(mif-1)*noFreqs, maf) =                         &
             &               radiance%values (i+(mif-1)*noFreqs, maf)         &
             &             + thisFraction(i)*a_clearSkyRadiance(mif,i) 

           modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) =              &
             &        modelCloudRadiance%values (i+(mif-1)*noFreqs, maf )     &
             &      + thisFraction(i)*a_cloudInducedRadiance(mif,i)

           if(associated(effectiveOpticalDepth))                              &
             & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) =       &
             &        effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf )  &
             &      + thisFraction(i)*a_effectiveOpticalDepth(mif,i)

           if(associated(cloudRADSensitivity))                                &
             & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =         &
             &        cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf )    &  
             &      + thisFraction(i)*a_cloudRADSensitivity(mif,i)
d841 1
a841 1
         enddo
d843 2
a844 2
       endif
     enddo
d846 4
a849 1
   ENDIF
d851 4
a854 2
    if ( toggle(emit) .and. levels(emit) > 1 ) &
      & call Trace_End ( 'FullCloudForwardModel.Sideband ',index=thisSideband )
d856 2
a857 4
    !--------------------------------------------
    ! End of sideband loop 
    !--------------------------------------------
    enddo
d859 3
a861 2
    if ( toggle(emit) .and. levels(emit) > 0 ) &      
      & call Trace_End ( 'FullCloudForwardModel.SidebandLoop' )
d863 2
a864 3
    ! -----------------------------------------------------------------------------
    ! output L2GP quantities
    ! -----------------------------------------------------------------------------
d866 10
a875 22
    ! To save disk space, we output one channel per band (first true doChannel)
    ! in the last signal (band) will over write all the previous signals (bands)
    
    FOUNDINFIRST = .true.
    do i=1, noFreqs
    if( doChannel(i) .and. FOUNDINFIRST ) then 
      FOUNDINFIRST = .false.
      if(associated(cloudExtinction)) &
        & cloudExtinction%values (:, instance )    = a_cloudExtinction(:,i)
      if(associated(totalExtinction)) &
        & totalExtinction%values (:, instance )    = a_totalExtinction (:,i)
    endif
    enddo

    if(associated(massMeanDiameterIce)) &
      & massMeanDiameterIce%values (:,instance)   = a_massMeanDiameter(1,:)
    if(associated(massMeanDiameterWater)) &
      & massMeanDiameterWater%values(:, instance) =  a_massMeanDiameter(2,:)

    !-----------------------
    ! Start output Jacobian
    !-----------------------
d877 22
a898 1
      noInstances = state_ext%template%noInstances
d900 3
a902 3
    !--------------------------------------------
    ! Jacobian for high tangent height retrieval (only one frequency)
    !--------------------------------------------
d904 1
a904 7
    if (forwardModelConfig%cloud_der == l_iwc_high_height &
      & .and. present(jacobian)) then      
    ! do not handle multiple signals and channels  
      if(size(forwardModelConfig%signals) > 1 .and. size(doChannel) > 1) then
         print*,'only one frequency and one signal is allowed'
         stop
      end if
d906 2
a907 32
      colJBlock = FindBlock ( Jacobian%col, state_ext%index, maf)
      rowJBlock = FindBlock ( jacobian%row, radiance%index, maf)
      fmStat%rows(rowJBlock) = .true.

      jBlock => jacobian%block(rowJblock,colJblock)

        call CreateBlock ( jBlock, noMIFs, noExtSurf*noInstances, M_Full )
        jBlock%values = 0._rm

      !-------------------------------------------------------------------
      ! we use 100 times better resolution to compute weighting functions
      !-------------------------------------------------------------------
      nfine = 100
      nNear = ForwardModelConfig%phiWindow         ! default = 5
      ! only nearest instances are mattered
        minInst = instance - (nNear-1)/2
        maxInst = instance + (nNear-1)/2
         if(minInst < 1) minInst = 1
         if(maxInst > noInstances) maxInst = noInstances
         
      allocate( phi_fine(nfine*nNear), stat=status )
      allocate( z_fine(nfine*nNear), stat=status )
      allocate( zp_fine(nfine*nNear), stat=status )
      allocate( s_fine(nfine*nNear), stat=status )
      allocate( w_fine(nfine*nNear), stat=status )
      allocate( ds_fine(nfine*nNear), stat=status )
      
      do i=1,nNear*nfine
       phi_fine(i) = state_ext%template%phi(1,minInst) + &
         & (i-1._r8)/nfine/nNear*(state_ext%template%phi(1,maxInst) - &
         & state_ext%template%phi(1,minInst))
      end do
d909 22
a930 38
      !----------------------------------
      ! find vertical and horizontal intervals of stateQ at maf
      !----------------------------------
      ! vertical
      dz = abs(state_ext%template%surfs(2,1)-state_ext%template%surfs(1,1))
      ! horiozontal: in case of the last instance, use the previous one
      if(instance < noInstances) then
         dphi = abs(state_ext%template%phi(1,instance+1)-state_ext%template%phi(1,instance))
      else
         dphi = abs(state_ext%template%phi(1,instance-1)-state_ext%template%phi(1,instance))
      end if
      
      do mif = 1, noMIFs
      ! Jacobians at only tangent heights less than the top level of retrieval are calculated
      if(  state_ext%template%surfs(noExtSurf,1) > ptan%values(mif,maf) .and. &
         & state_ext%template%surfs(1,1) < ptan%values(mif,maf)) then
        !------------------------------
        ! find z for given phi_fine
        !------------------------------
        z_fine = (earthradius%values(1,maf)+ zt(mif)) / &
         & cos((phi_fine - radiance%template%phi(mif,maf))*Deg2Rad) - &
         & earthradius%values(1,maf)
         ! convert back to log tangent pressure
         call InterpolateValues ( &
            & reshape(gph%values(:,instance),(/noSurf/)), &     ! Old X
            & reshape(gph%template%surfs(:,1),(/noSurf/)), &    ! Old Y
            & z_fine, &                                         ! New X
            & zp_fine, &                                        ! New Y
            & 'Linear' )

        !--------------------------------
        ! find ds and weight for each (z,phi) pair
        !--------------------------------
        s_fine = (earthradius%values(1,maf)+ zt(mif)) * &
         & sin((phi_fine - radiance%template%phi(mif,maf))*Deg2Rad)
        ds_fine = 0._r8    ! initialize it
        do i=1,nfine*nNear-1
         ds_fine(i) = s_fine(i+1) - s_fine(i)
d933 82
a1014 36
         call InterpolateValues ( &
            & sLevl, &                                               ! Old X
            & reshape(a_trans(:,mif,whichChannel),(/noSgrid/)), &    ! Old Y
            & s_fine, &                                              ! New X
            & w_fine, &                                              ! New Y
            & 'Linear' )
            
        ! ds needs to be weighted by transmission function
        
        ds_fine = ds_fine*w_fine    ! ds is in meters

        !----------------------------------------------------------
        ! determine weights by the length inside each state domain
        !----------------------------------------------------------
        
         do i = minInst,maxInst             ! loop over closer profiles
         do j = 1,noExtSurf                 ! loop over cloudQty surface
         do k = 1,nfine*nNear               ! sum up all the lengths
           if(abs(zp_fine(k) - state_ext%template%surfs(j,1)) < dz/2._r8 &
           & .AND. abs(phi_fine(k) - state_ext%template%phi(1,i)) < dphi/2._r8) &
           & jBlock%values(mif,j+(i-1)*noExtSurf) = &
           & jBlock%values(mif,j+(i-1)*noExtSurf) + ds_fine(k)/1.e3_r8
         end do
         end do
         end do
      end if
      end do         ! mif
     
      Deallocate( phi_fine, stat=status )
      Deallocate( z_fine, stat=status )
      Deallocate( zp_fine, stat=status )
      Deallocate( ds_fine, stat=status )
      Deallocate( w_fine, stat=status )
      Deallocate( s_fine, stat=status )
      
    end if     ! high tangent height case
a1015 6
    !--------------------------------------------
    ! Jacobian for low tangent height retrieval
    !--------------------------------------------
    if (forwardModelConfig%cloud_der == l_iwc_low_height &
      & .and. present(jacobian)) then
    
d1029 6
a1034 6
             do i=1,noSgrid
             ! now we normalize cloud extinction weighting functions at 200GHz 
             ! and output the transmission functions via Jacobian
               jBlock%values(j,i+(mif-1)*noSgrid)= a_trans(i,mif,j)* &
                  & (frequencies(j)/200000._r8)**4
             end do
d1039 1
a1039 1
    endif      ! low tangent height case
d1041 27
a1067 27
    !------------------------------
    ! End of output jacobian
    !------------------------------

    !------------------------------
    ! Remove temporary quantities
    !------------------------------

    call deallocate_test ( superset, 'superset',          ModuleName )
    call Deallocate_test ( a_massMeanDiameter,'a_massMeanDiameter',ModuleName )
    call Deallocate_test ( a_cloudExtinction,'a_cloudExtinction',ModuleName )
    call Deallocate_test ( a_totalExtinction,'a_totalExtinction',ModuleName )
    call Deallocate_test ( a_cloudRADSensitivity,'a_cloudRADSensitivity',ModuleName )
    call Deallocate_test ( a_effectiveOpticalDepth,'a_effectiveOpticalDepth',ModuleName )
    call Deallocate_test ( a_cloudInducedRadiance,'a_cloudInducedRadiance',ModuleName )
    call Deallocate_test ( a_clearSkyRadiance,'a_clearSkyRadiance',ModuleName )
    call Deallocate_test ( vmrArray,'vmrArray',ModuleName )
    call Deallocate_test ( closestInstances,'closestInstances',ModuleName )
    call Deallocate_test ( doChannel, 'doChannel',        ModuleName )
    call Deallocate_test ( thisFraction, 'thisFraction',        ModuleName )
    call Deallocate_test (frequencies,'frequencies',ModuleName )
    Deallocate (a_trans, Slevl, Zt )

    if (prt_log) then
      print*, ' '
      print*, 'Time Instance: ', instance
    endif
d1069 2
a1070 2
    Deallocate (WC, stat=ier )
    Deallocate (PSD, stat=ier )
d1072 1
a1072 1
    END DO  ! End of signals
d1075 1
a1075 2
      if ( associated ( my_catalog(i)%lines ) ) &
        & Call Deallocate_test ( my_catalog(i)%lines, 'my_catalog(?)%lines', &
d1087 1
a1087 1
    if(prt_log) print*, 'Successful done with full cloud forward wapper !'
d1099 3
@


1.130
log
@Moved some checking to ForwardModelSupport
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.129 2004/08/05 21:03:07 vsnyder Exp $"
a354 2
        elevOffset => GetVectorQuantityByType ( fwdModelExtra,               &
          & quantityType=l_elevOffset, radiometer=Signal%radiometer )
d692 2
d1098 3
@


1.129
log
@Add sentinel at end of %molecules
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.128 2004/06/10 01:00:14 vsnyder Exp $"
d54 1
a54 4
    use Molecules,                  only: FIRST_MOLECULE, &
                                        & L_H2O, L_H2O_18, L_N2, L_N2O, &
                                        & L_O2, L_O_18_O, L_O3, &
                                        & LAST_MOLECULE
a219 1
    logical :: Got( FIRST_MOLECULE : LAST_MOLECULE )
a453 1
    got = .false.
d462 1
a462 1
       Call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), molName )
d464 2
a465 11
    ! When using Bill's Spectral data, work out which spectroscopy we're going to need
    if(forwardModelConfig%default_spectroscopy) then  !Bill's clear-sky spectroscopy
    
      ! Skip if the next molecule is negative (indicates that this one is a parent)
      if ( (j < nspec) .and. (forwardModelConfig%molecules(j)>0)) then
        if ( forwardModelConfig%molecules(j+1) < 0 ) then
          Call Allocate_test ( my_catalog(j)%lines, 0, &
                            & 'my_catalog(?)%lines(0)', ModuleName )
          CYCLE
        end if
      end if
d467 6
a472 18
      thisCatalogEntry => Catalog ( FindFirst ( catalog%molecule, &
        & forwardModelConfig%molecules(j) ) )

      if ( associated ( thisCatalogEntry%lines ) ) then
        ! Now subset the lines according to the signal we're using
        Call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                         &  'lineFlag', ModuleName )
        lineFlag = .FALSE.
        do k = 1, size ( thisCatalogEntry%lines )
          thisLine => lines(thisCatalogEntry%lines(k))
          if ( associated(thisLine%signals) ) then
              doThis = any ( thisLine%signals == &
                & signal%index )
                ! If we're only doing one sideband, maybe we can remove some more lines
                if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                & any( ( thisLine%sidebands == sidebandStart ) .or. &
                & ( thisLine%sidebands == 0 ) )
              lineFlag(k) = lineFlag(k) .or. doThis
d474 1
a474 1
        end do               ! End loop over lines
d476 2
a477 2
        My_Catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake 
d479 38
a516 1
        ! Check we have at least one line for this
d518 1
a518 15
        if ( count(lineFlag) == 0 ) then
          Call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No relevant lines for '//trim(molName) )
        endif
        Call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
          & 'my_catalog(?)%lines', ModuleName )
        my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
        Call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
      else
        ! No lines for this species
        my_catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
        Call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
          & ModuleName )
      end if
d520 9
a528 24
    else          ! cloudy-sky spectroscopy
      select case (forwardModelConfig%molecules(j))
        case ( L_H2O, L_O3, L_N2O ) 
            ispec = 0
            if(forwardModelConfig%molecules(j) == l_h2o) ispec = 1
            if(forwardModelConfig%molecules(j) == l_o3) ispec = 2
            if(forwardModelConfig%molecules(j) == l_n2o) ispec = 3
            if(forwardModelConfig%molecules(j) == l_h2o) got(L_H2O) = .true.
            if(forwardModelConfig%molecules(j) == l_o3) got(L_O3) = .true.

         vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
           & quantityType=l_vmr, molecule=forwardModelConfig%molecules(j) )
         if (.not.ValidateVectorQuantity( vmr, stacked=.true., coherent=.true., &
            & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,  &
            & ModuleName, InvalidQuantity//'vmr' )

            novmrSurf = vmr%template%nosurfs

            call InterpolateValues ( &
            & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
            & reshape(vmr%values(:,instance),(/novmrSurf/)),  &    ! Old Y
            & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
            & vmrArray(ispec,:),                              &    ! New Y
            & 'Linear', extrapolate='Clamp' )
d530 2
a531 10
        case ( L_N2, L_O2, L_H2O_18, L_O_18_O)
          call MLSMessage(MLSMSG_Warning, ModuleName, &
          &'cloud fwd model internally has this molecule: '//trim(molName))
        case default
          call MLSMessage(MLSMSG_Error, ModuleName, &
          &'cloud fwd model currently cannot accept this molecule: '//trim(molName))
      end select
      
    endif
    enddo ! End of Loop over species
d533 12
d546 2
a547 4
    if ( .not. got(l_h2o) .or. .not. got(l_o3) ) then
    !make sure we have at least two molecules h2o and o3. 
      call MLSMessage(MLSMSG_Error, ModuleName,'Missing molecules H2O or O3 in cloud FM')
    endif
d1098 3
@


1.128
log
@Move FindFirst, FindNext from MLSCommon to MLSSets
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.127 2004/02/07 00:45:49 livesey Exp $"
d54 3
a56 3
    use Molecules,                  only: L_H2O, L_O3, L_N2O, L_HNO3, L_N2, &
                                        & L_O2, FIRST_MOLECULE, &
                                        & L_H2O_18, L_O_18_O, &
d58 1
a58 1
    use Output_m,                   only: OUTPUT
d83 1
a83 1
                       & L_IWP,                                                &
a91 1
                       & L_LIMBSIDEBANDFRACTION,                               &
a99 1

d118 1
a118 1
    type (VectorValue_T), pointer :: constrainCldRad           ! observed cloud radiance
d387 5
a391 4
    if ( size(forwardModelConfig%molecules) .lt. 2 ) then
!   make sure we have enough molecules
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
    endif
a458 1
    nspec = size(forwardModelConfig%molecules)
d462 1
a462 1
    allocate ( My_Catalog(size(forwardModelConfig%molecules)), stat=ier )
d473 1
a473 1
      if ( (j < size(forwardModelConfig%molecules)) .and. (forwardModelConfig%molecules(j)>0)) then
a474 1
          nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
d1114 3
@


1.127
log
@Minor typo
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.126 2004/02/05 23:30:20 livesey Exp $"
d44 1
a44 1
    use MLSCommon,                  only: r8, rm, rp, FINDFIRST
d47 1
d484 1
a484 1
      thisCatalogEntry => Catalog ( FindFirst ( catalog%molecule == &
d1117 3
@


1.126
log
@Finally turned on code to do correct handing of single sideband
radiometers and their SB fractions.
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.125 2004/01/08 00:52:43 jonathan Exp $"
d865 1
a865 1
      & call Trace_End ( 'FullCloudForwardModel.Sideband',index=thisSideband )
d1116 4
@


1.125
log
@delet output Using antenna pattern: etc
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.124 2004/01/08 00:24:32 jonathan Exp $"
d691 1
a691 3
    if ( sidebandStart /= sidebandStop ) then 
      ! Change to this if statement later !????
      ! if ( signal%sideband == 0 ) then
d719 1
a719 1
      if ( sidebandStart /= sidebandStop ) then   ! We're folding
d1116 3
@


1.124
log
@add tracing signals
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.123 2003/11/21 19:17:40 dwu Exp $"
d765 4
a768 4
    if ( toggle(emit) .and. levels(emit) > 2 ) then
       call output ( 'Using antenna pattern: ' )
       call output ( whichPattern, advance='yes' )
    end if
d1118 3
@


1.123
log
@fix a bug from the last modification
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.122 2003/11/21 17:55:57 dwu Exp $"
d262 1
a262 1
    do sigInd = 1, size(forwardModelConfig%signals)
d708 4
d714 3
d866 3
d874 3
d1090 1
a1090 1
    end do  ! End of signals
d1118 3
@


1.122
log
@add vGrid check for size distribution
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.121 2003/11/20 20:30:58 dwu Exp $"
d378 22
a456 22
    !----------------------------------
    ! Set up some temporary quantities
    !----------------------------------

    call Allocate_test ( closestInstances, radiance%template%noInstances,    &
      & 'closestInstances', ModuleName )      

    !------------------------
    ! Assemble the vmr array
    !------------------------
    if ( size(forwardModelConfig%molecules) .lt. 2 ) then
!   make sure we have enough molecules
      call MLSMessage ( MLSMSG_Error, ModuleName, 'Not enough molecules' )
    endif
    
    !---------------------------------------------------------
    ! Work out the closest instances from temperature
    !---------------------------------------------------------
    call FindClosestInstances ( temp, radiance, closestInstances )
    instance = closestInstances(maf)
    tLat = temp%template%geodLat(1,instance)    ! get latitude for each instance

d1105 3
@


1.121
log
@fit the problem when IWC and Temp vGrid mismatch
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.120 2003/07/09 20:17:22 livesey Exp $"
d159 1
d203 1
a203 1
    real (r8), dimension(:), pointer :: thisFraction ! Sideband ratio values
d216 1
d391 1
d396 4
d406 12
d419 8
a598 10
    if (noSurf /= GPH%template%nosurfs) then
      call MLSMessage ( MLSMSG_Error, ModuleName,                            &
      & 'number of levels in gph does not match no of levels in temp' )
     else if (radiance%template%nosurfs /= ptan%template%nosurfs) then
        call MLSMessage ( MLSMSG_Error, ModuleName,                          &
        & 'number of levels in radiance does not match no of levels in ptan' )
    endif

    allocate ( WC(ForwardModelConfig%no_cloud_species,NoSurf), STAT=status )

d608 1
a608 1
        & reshape(temp%values(:,instance),(/noSurf/)),      &    ! New X
d612 3
a614 3
        & reshape(CloudWater%template%surfs(:,1),(/noIWCSurf/)), &    ! Old X
        & reshape(CloudWater%values(:,instance),(/noIWCSurf/)),  &    ! Old Y
        & reshape(temp%values(:,instance),(/noSurf/)),      &    ! New X
d781 1
a781 1
      & int(sizeDistribution%values(:,instance)),                            &
d1075 1
d1105 3
@


1.120
log
@Anticipative bug fix in sideband fraction
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.119 2003/05/29 16:38:03 livesey Exp $"
d156 3
a158 1
    integer :: noCldSurf                           ! Number of cloud ext levels
d389 11
a399 1
        noCldSurf=state_ext%template%noSurfs
d583 1
d586 14
d894 1
a894 1
        call CreateBlock ( jBlock, noMIFs, noCldSurf*noInstances, M_Full )
d935 1
a935 1
      if(  state_ext%template%surfs(noCldSurf,1) > ptan%values(mif,maf) .and. &
d977 1
a977 1
         do j = 1,noCldSurf                 ! loop over cloudQty surface
d981 2
a982 2
           & jBlock%values(mif,j+(i-1)*noCldSurf) = &
           & jBlock%values(mif,j+(i-1)*noCldSurf) + ds_fine(k)/1.e3_r8
d1087 3
@


1.119
log
@Renamed sideband fraction
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.118 2003/05/16 23:53:56 livesey Exp $"
d648 2
d1060 3
@


1.118
log
@Removed reference to spectags
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.117 2003/05/15 22:48:28 dwu Exp $"
d91 1
a91 1
                       & L_SIDEBANDRATIO,                                      &
d139 3
a141 3
    type(VectorValue_T),  pointer :: SIDEBANDRATIO              ! The sideband ratio to use
    type(VectorValue_T),  pointer :: LOWERSIDEBANDRATIO         ! From the state vector
    type(VectorValue_T),  pointer :: UPPERSIDEBANDRATIO         ! From the state vector
d200 1
a200 1
    real (r8), dimension(:), pointer :: thisRatio ! Sideband ratio values
d247 1
a247 1
             surfaceType, temp, thisCatalogentry, thisLine, thisRatio,       &
d645 1
a645 1
    call allocate_test ( thisRatio, noFreqs, 'thisRatio', ModuleName )
d648 4
a651 4
      sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, noError=.true. )
      lowerSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, &
d653 2
a654 2
      upperSidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
        & quantityType = l_sidebandRatio, signal=signal%index, &
d656 2
a657 2
      if (.not. associated (sidebandRatio) .and. .not. &
        & ( associated ( lowerSidebandRatio) .and. associated ( upperSidebandRatio ) ) ) &
d670 1
a670 1
            thisRatio = lowerSidebandRatio%values(:,1)
d672 1
a672 1
            thisRatio = upperSidebandRatio%values(:,1)
d675 1
a675 1
        thisRatio = 1.0
d790 1
a790 1
             &             + thisRatio(i)*a_clearSkyRadiance(mif,i) 
d794 1
a794 1
             &      + thisRatio(i)*a_cloudInducedRadiance(mif,i)
d799 1
a799 1
             &      + thisRatio(i)*a_effectiveOpticalDepth(mif,i)
d804 1
a804 1
             &      + thisRatio(i)*a_cloudRADSensitivity(mif,i)
d807 1
a807 1
!   print*,maf,thissideband,i,thisRatio(i),a_cloudRADSensitivity(1,i),a_clearSkyRadiance(1,i)
d1019 1
a1019 1
    call Deallocate_test ( thisRatio, 'thisRatio',        ModuleName )
d1058 3
@


1.117
log
@changes
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.116 2003/05/07 22:49:03 jonathan Exp $"
d54 1
a54 1
                                        & L_O2, spec_tags, FIRST_MOLECULE, &
a176 1
    integer :: SPECTAG                             ! A single spectag
d444 2
a445 2
      Spectag = spec_tags( abs(forwardModelConfig%molecules(j)) )
      thisCatalogEntry => Catalog(FindFirst(catalog%spec_tag == spectag ) )
d1058 3
@


1.116
log
@some clean-up and cosmetic changes
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.115 2003/04/10 20:40:59 dwu Exp $"
d119 1
a119 1
    type (VectorValue_T), pointer :: obsCLOUDRADIANCE           ! observed cloud radiance
d243 1
a243 1
             cloudIce, cloudRadsensitivity, cloudWater, doChannel,           &
d246 1
a246 1
             modelCloudradiance, my_catalog, obsCloudRadiance, ptan,         &
a253 1

d598 3
a600 3
      ! find cloud top index from observed Tcir, threshold to be determined
      !     for high Zt, use Tcir(maf)
      !     for low Zt, use Tcir(maf-2)
d602 2
a603 1
    ! find the last cloudRadiance in fwdModelExtra for cloud top indicator
d605 2
a606 3
      obsCloudRadiance => GetVectorQuantityByType ( fwdModelExtra,     &
          & quantityType=l_cloudInducedRadiance,                     &
          & signal=signal%index, sideband=signal%sideband )
d608 4
a611 4
      if(.not. associated(obsCloudRadiance)) then
         call MLSMessage( MLSMSG_Error, ModuleName,                             &
                      'Need cloud radiances to estimate cloud top in retrieval' )
      else
d613 11
a623 11
       if(forwardModelConfig%cloud_der == l_iwc_high_height) then
         do mif = 1, noMifs
           if(obsCloudRadiance%values(whichchannel+(mif-1)*noFreqs,maf) .ne. 0.0_r8) &
                & iCloudHeight = mif
         enddo
       else
         do mif = 1, noMifs
           if(obsCloudRadiance%values(whichchannel+(mif-1)*noFreqs,maf) .ne. 0.0_r8) & 
                & iCloudHeight = mif
         enddo
       end if
d629 3
a631 2
       call CLOUD_MODEL (CloudType, CloudHeight, gph%values(:,instance), noSurf, WC)
      end if
d1059 3
d1108 1
a1108 1
! fix signal loop and move obsCloudRadiance inside jacobian loop
@


1.115
log
@make i_saturation and cloud_der as a verbal argument
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.114 2003/04/08 20:03:55 dwu Exp $"
a57 1
!   use PointingGrid_m,             only: POINTINGGRIDS
a214 1
!    real(r8) :: phi_tan
a221 1
!   logical :: dee_bug = .true.  
a341 1
!          & quantityType=l_ptan, instrumentModule = radiance%template%instrumentModule)
a380 1
!    noChans = radiance%template%noChans
a419 1

d510 1
a510 1
            & vmrArray(ispec,:),                                  &    ! New Y
a576 2
!    phi_tan = Deg2Rad * temp%template%phi(1,instance)

d601 1
a601 1
       !     for low Zt, use Tcir(maf-2)
d637 3
a639 3
! It is equavelent to shift either spectral line frequencies or filter frequencies
! but the sign is opposite.
!    Vel_Cor = 1.0_rp - losVel%values(1,maf)/299792458.3_rp    ! for shift spectral lines
a662 1

a688 1

d721 2
a722 1
!print*,instance,maxval(wc)
d727 1
a727 1
      & nspec,                                  &
a760 1

d775 1
a775 1
       & effectiveOpticalDepth%values ( :, maf ) =                                &
d779 1
a779 1
       & cloudRADSensitivity%values ( :, maf ) =                                  &
d789 2
a790 2
           radiance%values (i+(mif-1)*noFreqs, maf) =                               &
             &               radiance%values (i+(mif-1)*noFreqs, maf)               &
d793 2
a794 2
           modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) =                    &
             &        modelCloudRadiance%values (i+(mif-1)*noFreqs, maf )           &
d797 3
a799 3
           if(associated(effectiveOpticalDepth))                                    &
             & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) =             &
             &        effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf )        &
d802 3
a804 3
           if(associated(cloudRADSensitivity))                                      &
             & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =               &
             &        cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf )          &  
a841 1

d1059 3
@


1.114
log
@fix a bug in handling no of cloud species. now this number is meanful
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.113 2003/04/05 17:30:43 dwu Exp $"
d81 3
a222 2
    logical :: DoHighZt                            ! Flag
    logical :: DoLowZt                             ! Flag
a259 10
    !------------------------------------------
    ! Determine which retrieval is to be used
    !    cloud_der = 0     high tangent height
    !    cloud_der = 1     low tangent height
    !------------------------------------------
    doHighZt = .false.
    doLowZt  = .false.
    if (forwardModelConfig%cloud_der == 1) doHighZt = .true.
    if (forwardModelConfig%cloud_der == 2) doLowZt  = .true.

d622 1
a622 1
       if(doHighZt) then
d863 2
a864 1
    if (doHighZt .and. present(jacobian)) then      
d979 1
a979 1
    end if     ! doHighZt
d984 2
a985 1
    if (doLowZt .and. present(jacobian)) then
d1010 1
a1010 1
    endif      ! doLowZt
d1070 3
@


1.113
log
@clean up
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.112 2003/04/03 22:38:05 dwu Exp $"
d585 1
a585 1
    allocate ( WC(2,NoSurf), STAT=status )
d587 4
a590 2
    WC (1,:) = CloudIce%values(:,instance)
    WC (2,:) = CloudWater%values(:,instance)
d1077 3
@


1.112
log
@change the way vmr and molecule are handled
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.111 2003/04/03 01:18:41 dwu Exp $"
d266 2
a267 2
    if (forwardModelConfig%cloud_der == 0) doHighZt = .true.
    if (forwardModelConfig%cloud_der == 1) doLowZt  = .true.
d738 1
a738 1

d1075 3
@


1.111
log
@allow molecules in random order
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.110 2003/04/03 01:15:51 dwu Exp $"
d55 1
a85 1
                       & L_NONE,                                               &
d176 2
a177 1
    integer :: ispec                             ! species
a320 64
 !----------------------------------------------------------------------------------
 ! When using Bill's Spectral data, work out which spectroscopy we're going to need
 !----------------------------------------------------------------------------------
    allocate ( My_Catalog(size(forwardModelConfig%molecules)), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
     & 'Unable to allocate my_catalog' )

    do j = 1, size(forwardModelConfig%molecules)      ! Loop over species

      ! Skip if the next molecule is negative (indicates that this one is a parent)
      if ( (j < size(forwardModelConfig%molecules)) .and. (forwardModelConfig%molecules(j)>0)) then
        if ( forwardModelConfig%molecules(j+1) < 0 ) then
          nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
          Call Allocate_test ( my_catalog(j)%lines, 0, &
                            & 'my_catalog(?)%lines(0)', ModuleName )
          CYCLE
        end if
      end if

      Spectag = spec_tags( abs(forwardModelConfig%molecules(j)) )
      thisCatalogEntry => Catalog(FindFirst(catalog%spec_tag == spectag ) )

      if ( associated ( thisCatalogEntry%lines ) ) then
        ! Now subset the lines according to the signal we're using
        Call Allocate_test ( lineFlag, size(thisCatalogEntry%lines), &
                         &  'lineFlag', ModuleName )
        lineFlag = .FALSE.
        do k = 1, size ( thisCatalogEntry%lines )
          thisLine => lines(thisCatalogEntry%lines(k))
          if ( associated(thisLine%signals) ) then
              doThis = any ( thisLine%signals == &
                & signal%index )
                ! If we're only doing one sideband, maybe we can remove some more lines
                if ( sidebandStart==sidebandStop ) doThis = doThis .and. &
                & any( ( thisLine%sidebands == sidebandStart ) .or. &
                & ( thisLine%sidebands == 0 ) )
              lineFlag(k) = lineFlag(k) .or. doThis
          end if
        end do               ! End loop over lines

        My_Catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake 

        ! Check we have at least one line for this

        if ( count(lineFlag) == 0 ) then
          Call get_string ( lit_indices( abs(forwardModelConfig%molecules(j)) ), molName )
          Call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'No relevant lines for '//trim(molName) )
        endif
        Call Allocate_test ( my_catalog(j)%lines, count(lineFlag),&
          & 'my_catalog(?)%lines', ModuleName )
        my_catalog(j)%lines = pack ( thisCatalogEntry%lines, lineFlag )
        Call Deallocate_test ( lineFlag, 'lineFlag', ModuleName )
      else
        ! No lines for this species
        my_catalog(j) = thisCatalogEntry
        nullify ( my_catalog(j)%lines ) ! Don't deallocate it by mistake
        Call Allocate_test ( my_catalog(j)%lines, 0, 'my_catalog(?)%lines(0)', &
          & ModuleName )
      end if

    enddo ! End of Loop over species

d426 1
a426 4
    call allocate_test ( vmrArray,                                           &
      & size(forwardModelConfig%molecules), noSurf,                          &
      & 'vmrArray', ModuleName )
    vmrarray = 0._r8
d434 2
d437 44
a480 24
    do i = 1, size(forwardModelConfig%molecules)
      select case (forwardModelConfig%molecules(i))
        case ( L_H2O ) 
            ispec = 1
            got(L_H2O) = .true.
        case ( L_O3 )
            ispec = 2
            got(L_O3) = .true.
        case ( L_N2O )
            ispec = 3
            got(L_N2O) = .true.
        case ( L_HNO3 )
            ispec = 4
            got(L_HNO3) = .true.
        case ( L_N2 )
            ispec = 5
            got(L_N2) = .true.
        case ( L_O2 )
            ispec = 6
            got(L_O2) = .true.
        case default
            print*,'cloud fwd model does not allow this molecule:', forwardModelConfig%molecules(i)
          stop
      end select
d482 2
a483 5
      vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
        & quantityType=l_vmr, molecule=forwardModelConfig%molecules(i) )
      if (.not.ValidateVectorQuantity( vmr, stacked=.true., coherent=.true., &
        & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,  &
        & ModuleName, InvalidQuantity//'vmr' )
d485 1
a485 1
       novmrSurf = vmr%template%nosurfs
d487 15
a501 6
      call InterpolateValues ( &
        & reshape(vmr%template%surfs(:,1),(/novmrSurf/)), &    ! Old X
        & reshape(vmr%values(:,instance),(/novmrSurf/)),  &    ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)),   &    ! New X
        & vmrArray(ispec,:),                                  &    ! New Y
        & 'Linear', extrapolate='Clamp' )
d503 35
a537 1
    end do
a538 4
    if ( .not. got(l_n2o)) vmrArray(3,:) = 0._r8
    if ( .not. got(l_hno3)) vmrArray(4,:) = 0._r8
    if ( .not. got(l_n2)) vmrArray(5,:) = 0.805_r8
    if ( .not. got(l_o2)) vmrArray(6,:) = 0.2095_r8
d542 1
a542 1
      call MLSMessage(MLSMSG_Error, ModuleName,'Missing the required molecules')
d743 1
a743 1
      & size(ForwardModelConfig%molecules),                                  &
d1075 3
@


1.110
log
@allow molecules in random order
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.109 2003/04/02 20:00:12 dwu Exp $"
d505 1
a505 1
            got(i) = .true.
d508 1
a508 1
            got(i) = .true.
d511 1
a511 1
            got(i) = .true.
d514 1
a514 1
            got(i) = .true.
d517 1
a517 1
            got(i) = .true.
d520 1
a520 1
            got(i) = .true.
d1083 3
@


1.109
log
@some clearup and replace ifov with do_conv
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.108 2003/01/23 00:19:09 pwagner Exp $"
d176 1
a270 1

d503 18
a520 2
        case ( L_H2O, L_O3, L_N2O, L_HNO3, L_N2, L_O2 )
          got(forwardModelConfig%molecules(i)) = .true.
d522 2
a523 1
          cycle
d538 1
a538 1
        & vmrArray(i,:),                                  &    ! New Y
d542 1
d546 1
a546 1
    if ( .not. got(l_o2)) vmrArray(5,:) = 0.2095_r8
a657 1

d833 1
a833 1
   print*,maf,thissideband,i,thisRatio(i),a_cloudRADSensitivity(1,i),a_clearSkyRadiance(1,i)
d1083 3
@


1.108
log
@Some cosmetic only (or so I hope) changes
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.107 2003/01/17 07:19:33 dwu Exp $"
d749 1
a749 1
      & forwardModelConfig%cloud_fov,                                        &
d816 1
d1066 3
@


1.108.2.1
log
@change cloud_fov to do_conv
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.108 2003/01/23 00:19:09 pwagner Exp $"
d749 1
a749 1
      & forwardModelConfig%do_conv,                                          &
a1064 3
! Revision 1.108  2003/01/23 00:19:09  pwagner
! Some cosmetic only (or so I hope) changes
!
@


1.107
log
@properly initialize vmrArray
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.106 2003/01/17 01:08:11 jonathan Exp $"
a743 1
      & 10.0**(-ptan%values(:,maf)),                                         &
d1065 3
@


1.106
log
@add vmrArray=0. after allocate
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.105 2003/01/17 00:52:05 jonathan Exp $"
d523 1
d525 5
d1066 3
@


1.105
log
@if specices missing, set VMR=0 accordingly
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.104 2003/01/16 18:39:41 pwagner Exp $"
d470 1
a470 2
          Allocate( a_Trans(noSgrid, noMIFs, noFreqs))
          
d492 1
a492 1

d503 1
a503 1
        case ( L_H2O, L_O3, L_N2O, L_HNO3, L_N2, L_O2)
a528 5
    if (.not. got(L_N2O) )  vmrArray(i,:) = 0._r8
    if (.not. got(L_HNO3))  vmrArray(i,:) = 0._r8
    if (.not. got(L_N2)  )  vmrArray(i,:) = 0._r8
    if (.not. got(L_O2)  )  vmrArray(i,:) = 0._r8

d1060 3
@


1.104
log
@Removed some unused variables
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.103 2003/01/13 17:59:52 jonathan Exp $"
a524 1

d526 2
a527 3
!   make sure we have at least two molecules h2o and o3. 
      call MLSMessage( MLSMSG_Error, ModuleName,          &
                      'Missing the required molecules' )
d530 5
d1066 3
@


1.103
log
@ change cloud_width to i_saturation
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.102 2003/01/09 21:08:09 dwu Exp $"
d33 1
d42 5
a46 6
    use ForwardModelIntermediate,   only: FORWARDMODELINTERMEDIATE_T, FORWARDMODELSTATUS_T
    use Hdf,                        only: DFACC_READ, DFACC_CREATE
    use HDFEOS,                     only: SWOPEN, SWCLOSE
    use L2GPData,                   only: L2GPData_T, ReadL2GPData, WriteL2GPData
    use MLSCommon,                  only: NameLen, FileNameLen, r8, rm, rp, FINDFIRST
    use MLSMessageModule,           only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, MLSMSG_Allocate, MLSMSG_Deallocate
d48 2
a49 2
    use MatrixModule_0,             only: M_Absent, M_BANDED, MATRIXELEMENT_T, &
                                        & M_COLUMN_SPARSE, M_FULL, CREATEBLOCK
d53 3
a55 2
    use Molecules,                  only: L_H2O, L_O3, L_N2O, L_HNO3, L_N2, L_O2, &
                                        & spec_tags, FIRST_MOLECULE, LAST_MOLECULE
d57 1
a57 1
    use PointingGrid_m,             only: POINTINGGRIDS
d59 1
a59 1
    use String_table,               only: GET_STRING, DISPLAY_STRING
a70 1
                       & L_CHANNEL,                                            &
a92 1
                       & L_TNGTGEOCALT,                                        &
d95 1
a95 2
                       & LIT_INDICES,                                          &
                       & L_ORBITINCLINATION
d109 2
a110 1
    character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "
a133 1
    type (VectorValue_T), pointer :: ORBINCLINE                 ! Orbital inclination
a155 1
    integer :: NOFREQS0                            ! Number of frequencies of the last signal
a169 1
    integer :: SIDEBAND                            ! Loop index    
d221 1
a221 1
    logical :: dee_bug = .true.  
d324 2
a325 1
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, 'my_catalog' )
d1063 3
@


1.102
log
@drop orbI
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.101 2002/12/18 16:09:24 jonathan Exp $"
d749 1
a749 1
      & forwardModelConfig%cloud_width,                                      &
d1066 3
@


1.101
log
@add phi_tan
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.100 2002/11/30 21:31:46 dwu Exp $"
a438 2
        orbIncline => GetVectorQuantityByType ( fwdModelExtra, &
          & quantityType=l_orbitInclination )	
d768 1
a768 1
      & My_Catalog, losVel%values(1,1), orbIncline%values(1,1)*Deg2Rad )   
d1066 3
@


1.100
log
@fix signal loop and move obsCloudRadiance inside jacobian loop
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.99 2002/10/08 17:08:07 pwagner Exp $"
d96 4
a99 1
                       & LIT_INDICES
d135 1
d140 2
a141 2
    type(VectorValue_T), pointer :: LOWERSIDEBANDRATIO ! From the state vector
    type(VectorValue_T), pointer :: UPPERSIDEBANDRATIO ! From the state vector
d438 3
a440 1
          & quantityType=l_elevOffset, radiometer=Signal%radiometer )	
d770 1
a770 1
      & My_Catalog, losVel%values(1,1) )   
d1068 3
@


1.99
log
@Added idents to survive zealous Lahey optimizer
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.98 2002/10/04 00:02:15 vsnyder Exp $"
d267 11
a277 3
    !--------------------------------------------------------------------
    
    signal = forwardModelConfig%signals(size(forwardModelConfig%signals))
d279 1
a279 6
    ! --------------------------------------------------------------------
    ! find the last cloudRadiance in fwdModelExtra for cloud top indicator
    ! --------------------------------------------------------------------
    obsCloudRadiance => GetVectorQuantityByType ( fwdModelExtra,     &
          & quantityType=l_cloudInducedRadiance,                     &
          & signal=signal%index, sideband=signal%sideband )
a348 1
            do sigInd = 1, size(forwardModelConfig%signals)
d350 1
a350 1
                & forwardModelConfig%signals(sigInd)%index )
a355 1
            end do ! End loop over signals requested in fwm
a382 14
    !--------------------------------------------
    ! Loop over signals
    !--------------------------------------------

    do sigInd = 1, size(forwardModelConfig%signals)

    ! -------------------------------------
    ! Identify the signal (band)
    ! -------------------------------------

       signal = forwardModelConfig%signals(sigInd)

       if (prt_log) print*,'signal%index', signal%index

d397 1
a397 1
            & quantityType=l_cloudExtinction, noerror=.true. )
d402 1
a402 1
          & quantityType=l_totalExtinction, noerror=.true. )
d603 7
d721 1
a721 1
 
d779 2
a780 1
     effectiveOpticalDepth%values ( :, maf ) =                                &
d783 2
a784 1
     cloudRADSensitivity%values ( :, maf ) =                                  &
d1062 3
@


1.98
log
@Change handling of GOT variable, some cosmetic changes
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.97 2002/10/03 23:25:52 vsnyder Exp $"
d25 1
d1058 4
d1066 3
@


1.97
log
@Move USE statements from module scope to procedure scope
@
text
@d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.96 2002/09/11 17:43:39 pwagner Exp $"
a159 1
    integer :: ivmr
d219 1
a219 1
    logical :: Got( LAST_MOLECULE - FIRST_MOLECULE + 1 ) = .false.  
d239 11
a249 14
    nullify( CLOUDICE, CLOUDWATER, CLOUDEXTINCTION, modelCLOUDRADIANCE,         &
             CLOUDRADSENSITIVITY, EFFECTIVEOPTICALDEPTH, obsCLOUDRADIANCE, GPH, &
             MASSMEANDIAMETERICE, MASSMEANDIAMETERWATER, PTAN,                  &
             RADIANCE, SIZEDISTRIBUTION, EARTHRADIUS, SURFACETYPE,              &
             TEMP, TOTALEXTINCTION, VMR, VMRARRAY,closestInstances,             &
             A_CLEARSKYRADIANCE, A_CLOUDINDUCEDRADIANCE,                        &
             A_CLOUDEXTINCTION, A_CLOUDRADSENSITIVITY,                          &
             A_EFFECTIVEOPTICALDEPTH, A_MASSMEANDIAMETER,                       &
             A_TOTALEXTINCTION,FREQUENCIES, thisRatio,                          &
             superset, JBLOCK, state_ext, state_los,                            &
             MY_CATALOG, thisCatalogEntry, thisLine, LOSVEL )
             
    nullify ( doChannel, lineFlag )
    
d263 2
a264 2
    if(forwardModelConfig%cloud_der == 0) doHighZt = .true.
    if(forwardModelConfig%cloud_der == 1) doLowZt  = .true.
d512 1
a512 1
    ivmr=0
d515 2
a516 12
        case(L_H2O)
          ivmr=1
        case(L_O3)
          ivmr=2
        case(L_N2O)
          ivmr=3
        case(L_HNO3)
          ivmr=4
        case(L_N2)
          ivmr=5
        case(L_O2)
          ivmr=6
d518 1
a518 1
          ivmr=0
a519 3
      if(ivmr==0) then
        cycle
      endif
a534 1
      Got(ivmr)=.true.
d537 1
a537 1
    if ( .not. got(1) .or. .not. got(2) ) then
d545 1
a545 1
         allocate(zt(noMifs))
d1061 3
@


1.96
log
@Began changes needed to conform with matrix%values type move to rm from r8
@
text
@d10 3
a12 56
  use Allocate_deallocate,          only: Allocate_test, Deallocate_test
  use AntennaPatterns_m,            only: ANTENNAPATTERNS
  use CloudySkyModule,              only: CLOUD_MODEL
  use CloudySkyRadianceModel,       only: CloudForwardModel
  use Hdf,                          only: DFACC_READ, DFACC_CREATE
  use HDFEOS,                       only: SWOPEN, SWCLOSE
  use L2GPData,                     only: L2GPData_T, ReadL2GPData, WriteL2GPData
  use MLSCommon,                    only: NameLen, FileNameLen, r8, rm, rp, FINDFIRST
  use MLSMessageModule,             only: MLSMessage, MLSMSG_Error, MLSMSG_Warning, MLSMSG_Allocate, MLSMSG_Deallocate
  use MLSSignals_m,                 only: SIGNAL_T, ARESIGNALSSUPERSET
  use MatrixModule_0,               only: M_Absent, M_BANDED, MATRIXELEMENT_T, M_BANDED, &
                                        & M_COLUMN_SPARSE, CREATEBLOCK, M_FULL
  use MatrixModule_1,               only: MATRIX_T, FINDBLOCK
  use ManipulateVectorQuantities,   only: FindClosestInstances
  use MLSNumerics,                  only: InterpolateValues
  use Molecules,                    only: L_H2O, L_O3, L_N2O, L_HNO3, L_N2, L_O2, spec_tags, FIRST_MOLECULE, &
                                        & LAST_MOLECULE
  use Output_m,                     only: OUTPUT
  use PointingGrid_m,               only: POINTINGGRIDS
  use String_table,                 only: GET_STRING, DISPLAY_STRING
  use SpectroscopyCatalog_m,        only: CATALOG_T, LINE_T, LINES, CATALOG
  use Toggles,                      only: Emit, Levels, Toggle
  use Trace_M,                      only: Trace_begin, Trace_end
  use Units,                        only: Deg2Rad                         
  use VectorsModule,                only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T, &
                                        & VALIDATEVECTORQUANTITY

  use ForwardModelConfig,           only: FORWARDMODELCONFIG_T   
  use ForwardModelIntermediate,     only: FORWARDMODELINTERMEDIATE_T, FORWARDMODELSTATUS_T

! ----------------------------------------------------------
! DEFINE INTRINSIC CONSTANTS NEEDED BY Init_Tables_Module
! ----------------------------------------------------------

  use Intrinsic, only: L_TEMPERATURE,L_PTAN,L_VMR,L_GPH,L_RADIANCE,L_NONE,   &
                     & L_CLOUDINDUCEDRADIANCE,                               &
                     & L_EFFECTIVEOPTICALDEPTH,                              &
                     & L_CLOUDRADSENSITIVITY,                                &
                     & L_TOTALEXTINCTION,                                    &
                     & L_CLOUDEXTINCTION,                                    &
                     & L_MASSMEANDIAMETERICE,                                & 
                     & L_MASSMEANDIAMETERWATER,                              &
                     & L_SURFACETYPE,                                        &
                     & L_SIZEDISTRIBUTION,                                   &
                     & L_TNGTGEOCALT,                                        &
                     & L_EARTHRADIUS,                                        &
                     & L_CLOUDICE,                                           &
                     & L_CLOUDWATER,                                         &
                     & L_LOSTRANSFUNC,                                       &
                     & L_SCGEOCALT,                                          &
                     & L_ELEVOFFSET,                                         &
                     & L_SIDEBANDRATIO,                                      &
                     & L_CHANNEL,                                            &
                     & L_NONE,                                               &
                     & L_LOSVEL,                                             &
                     & LIT_INDICES
d21 1
a21 1
    "$Id: FullCloudForwardModel.f90,v 1.95 2002/08/22 00:14:17 jonathan Exp $"
a26 4
 ! Local parameters ---------------------------------------------------------

  character, parameter :: INVALIDQUANTITY = "Invalid vector quantity for "

d35 62
d105 4
d1079 3
@


1.95
log
@upgrade to include more molecules
@
text
@d1 1
a1 1
! Copyright (c) 1999, California Institute of Technology.  ALL RIGHTS RESERVED.
d17 1
a17 1
  use MLSCommon,                    only: NameLen, FileNameLen, r8, rp, FINDFIRST
d74 1
a74 1
    "$Id: FullCloudForwardModel.f90,v 1.94 2002/08/19 22:22:03 jonathan Exp $"
d883 1
a883 1
        jBlock%values = 0._r8
d999 1
a999 1
        jBlock%values = 0.0_r8
d1070 3
@


1.94
log
@debug stuff
@
text
@d25 2
a26 1
  use Molecules,                    only: L_H2O, L_O3, spec_tags
d74 1
a74 1
    "$Id: FullCloudForwardModel.f90,v 1.93 2002/08/08 22:46:30 jonathan Exp $"
d211 1
a211 1
    logical :: Got(2)  = .false.  
d493 1
a493 1
!    if ( size(forwardModelConfig%molecules) .lt. 1 ) then
d514 8
a534 1

d547 1
a547 1
!    if ( .not. got(1) ) then
d1070 3
@


1.93
log
@newly improved version
@
text
@d32 1
a32 1
  use Units
d73 1
a73 1
    "$Id: FullCloudForwardModel.f90,v 1.92 2002/05/08 17:03:39 jonathan Exp $"
d201 1
a201 1
    real(r8) :: phi_tan
a280 3
!     print*,'Signal%sideband', Signal%sideband
!     print*,'Signal%singleSideband', Signal%singleSideband

d287 1
a287 1
    else
d305 1
a305 1
    end if
a490 1

d492 1
d539 1
d589 1
a589 1
    phi_tan = Deg2Rad * temp%template%phi(1,instance)
a593 17
        do j = 1, size(antennaPatterns)
          superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
           & ForwardModelConfig%signals, sideband=signal%sideband , channel=1 )
        end do

    whichPattern = 1
    maxSuperset = maxval ( superset )
    where ( superset < 0 )
          superset = maxSuperset + 1
    end where
    whichPatternAsArray = minloc ( superset )
    whichPattern = whichPatternAsArray(1)
    if ( toggle(emit) .and. levels(emit) > 2 ) then
       call output ( 'Using antenna pattern: ' )
       call output ( whichPattern, advance='yes' )
    end if

a687 2
!      print*, thisRatio

a691 3
!    print*,frequencies
!    print*, signal%lo

a701 5
!          print*, vel_cor
!          print*,' '
!          print*,frequencies

!        IF (.NOT. forwardModelConfig%default_spectroscopy) THEN
a704 6
!        ENDIF

!          print*,' '
!          print*,frequencies
!          stop

d710 17
a753 1
      & phi_tan,                                                             &
a777 9
!    do i =1 , noFreqs
!    do mif=1, noMIFs
!      a_clearSkyRadiance(mif,i)      = thisRatio(i)*a_clearSkyRadiance(mif,i)
!      a_cloudInducedRadiance(mif,i)  = thisRatio(i)*a_cloudInducedRadiance(mif,i)
!      a_effectiveOpticalDepth(mif,i) = thisRatio(i)*a_cloudRADSensitivity(mif,i)
!      a_cloudRADSensitivity(mif,i)   = thisRatio(i)*a_cloudRADSensitivity(mif,i)
!    enddo
!    enddo

d791 1
a793 18
   IF ( thisSideband == sidebandStart ) THEN
     do i =1 , noFreqs
       if (doChannel(i)) then
         do mif=1, noMIFs
           radiance%values (i+(mif-1)*noFreqs, maf) =                               &
             &                       thisRatio(i)*a_clearSkyRadiance(mif,i)
           modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) =                    &
             &                       thisRatio(i)*a_cloudInducedRadiance(mif,i)
           if(associated(effectiveOpticalDepth))                                    &
             & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) =             &
             &                       thisRatio(i)*a_effectiveOpticalDepth(mif,i)
           if(associated(cloudRADSensitivity))                                      &
             & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =               &
             &                       thisRatio(i)*a_cloudRADSensitivity(mif,i)
         end do
       endif
     enddo
   ELSE
d819 1
a819 1
   endif
d1062 3
@


1.92
log
@use earthradius(1,1) for now
@
text
@d17 2
a18 2
  use MLSCommon,                    only: NameLen, FileNameLen, r8,  FINDFIRST
  use MLSMessageModule,             only: MLSMessage, MLSMSG_Error
d28 1
d63 2
a64 1
                     & L_LOSVEL
d73 1
a73 1
    "$Id: FullCloudForwardModel.f90,v 1.91 2002/01/14 19:30:16 jonathan Exp $"
d124 3
a126 1
    type(VectorValue_T),  pointer :: SIDEBANDRATIO              ! From the state vector
d144 1
d159 1
a159 1
    integer :: SIDEBAND                            ! Loop index
d187 2
a188 1
    real (r8), dimension(:), pointer :: thisRatio  ! Sideband ratio values
d198 1
a198 1
    real(r8), dimension(:), pointer :: FREQUENCIES
d214 2
d218 1
d238 2
a239 2
             A_TOTALEXTINCTION,FREQUENCIES,                                     &
             superset, thisRatio, JBLOCK, state_ext, state_los,                 &
d242 1
a242 1
    nullify ( doChannel )
d249 1
a249 1
  
d260 2
d270 5
a274 3
      noFreqs0 = size (signal%frequencies)
      do i=1, noFreqs0
        if (signal%channels(i)) whichChannel=i
d277 105
a386 2
      
     signal = forwardModelConfig%signals(sigInd)
d388 3
a390 1
     if (prt_log) print*,signal%index
a463 1
    noFreqs = size (signal%frequencies) ! Note: noFreq and noChans should be the same
d465 18
a528 3
!      call FindClosestInstances ( vmr, radiance, closestInstances )
!      vmrInst = closestInstances(maf)
!      instance = closestInstances(maf)
d530 1
a530 1
	   novmrSurf = vmr%template%nosurfs
d545 1
a545 2

    call allocate_test ( thisRatio, noFreqs, 'thisRatio', ModuleName )
d547 2
a548 1
    allocate(zt(noMifs))
a552 40
    !----------------------------------------------------------
    ! Old version has only single sideband
    ! Now changed to double sideband, Oct 2, 2001
    !----------------------------------------------------------
    ! if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
    !   & 'Only single sidebands allowed in FullForwardCloudModel for now' )
    !----------------------------------------------------------

    !-------------------------------------------------
    ! Allow folded double sideband
    !-------------------------------------------------

    if ( signal%sideband == 0 ) then
       sidebandStart = -1
       sidebandStop  = 1
       sidebandStep  = 2
       sidebandRatio => GetVectorQuantityByType ( fwdModelExtra, &
                     & quantityType = l_sidebandRatio, signal=signal%index )
       thisRatio = sidebandRatio%values(:,1)
    else
       sidebandStart = 0
       sidebandStop  = 0
       sidebandStep  = 1
    endif

    !--------------------------------------------
    ! Loop over sidebands 
    !--------------------------------------------

    do sideband = sidebandStart, sidebandStop, sidebandStep

    !-----------------------------
    ! Setup a sideband ratio array
    !------------------------------

    if ( sidebandStart /= sidebandStop ) then
       thisRatio = sidebandRatio%values(:,1)
       if ( sideband == 1 ) thisRatio = 1.0 - thisRatio
    end if

d586 1
a586 1
    allocate ( WC(2,NOsurf), STAT=status )
a612 28

    call Allocate_test ( frequencies, noFreqs, 'frequencies', ModuleName )

    frequencies = signal%sideband * ( signal%centerFrequency +   &
                  signal%frequencies)
   
        select case ( sideband )
        case ( -1 )
          frequencies = signal%lo - frequencies
        case ( +1 )
          frequencies = signal%lo + frequencies
        case ( 0 )
          frequencies = signal%lo + frequencies
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName,            &
            & 'Bad value of signal%sideband' )
        end select

        ! frequencies = signal%lo + signal%sideband * ( signal%centerFrequency +   &
        !               signal%frequencies)

    if (prt_log) then
       print*, ' '
       print*,'No. of Frequencies:', noFreqs 
       print*,'Frequency=', frequencies/1e3_r8
    endif


a614 16
    !----------------------------
    ! get state quantity type (need both ext and los quantities for Jacobians)
    !----------------------------
       state_ext => GetVectorQuantityByType(FwdModelIn,quantityType=l_cloudExtinction)
       state_los => GetVectorQuantityByType(FwdModelIn,quantityType=l_LosTransFunc)

        ! Get number of cloud surfaces for retrieval
        noCldSurf=state_ext%template%noSurfs
        ! Get s dimension
        noSgrid=state_los%template%noChans
        
        Allocate( a_Trans(noSgrid, noMIFs, noFreqs))
        Allocate( Slevl(noSgrid))

        Slevl = state_los%template%frequencies

d634 1
a634 1
      !     for low Zt, use Tcir(maf-2)
d642 1
a642 1
           if(obsCloudRadiance%values(whichchannel+(mif-1)*noFreqs0,maf) .ne. 0.0_r8) &
d647 1
a647 1
           if(obsCloudRadiance%values(whichchannel+(mif-1)*noFreqs0,maf) .ne. 0.0_r8) & 
a660 3
    ! Work out which spectroscopy we're going to need ------------------------
    allocate ( My_Catalog(size(forwardModelConfig%molecules)), stat=ier )
    if ( ier /= 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, 'my_catalog' )
d662 77
a738 6
    do j = 1, size(forwardModelConfig%molecules)
      Spectag = spec_tags(forwardModelConfig%molecules(j))
!      print*, Spectag
      thisCatalogEntry => Catalog(FindFirst(catalog%spec_tag == spectag ) )
      My_Catalog(j) = thisCatalogEntry
    enddo
d740 6
a749 18
    ! all demensions are in meters
!    if (instance .gt. size(gph%values, 2)) then
!      print*, 'gph values array size exceeded ' , instance
!    else if (instance .gt. size(temp%values, 2)) then
!      print*, 'temp values array size exceeded ' , instance
!    else if (maf .gt. size(ptan%values, 2)) then
!      print*, 'ptan ' , maf
!    else if (maf .gt. size(earthradius%values, 2)) then
!      print*, 'earthradius ' , maf
!      print*, 'ptansize ' , size(ptan%values, 2)
!    else if (instance .gt. size(sizeDistribution%values, 2)) then
!      print*, 'sizeDistribution ' , instance
!    else if (instance .gt. size(surfacetype%values, 2)) then
!      print*, 'surfacetype ' , instance
!    else if (maf .gt. size(losVel%values, 2)) then
!      print*, 'losVel ' , maf
!    endif

d790 1
a792 1

d796 74
a869 18
   
    do i =1 , noFreqs
    if (doChannel(i)) then
    do mif=1, noMIFs
    radiance%values (i+(mif-1)*noFreqs, maf) = a_clearSkyRadiance(mif,i) 

    modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) =                    &
      & a_cloudInducedRadiance(mif,i)

    if(associated(effectiveOpticalDepth))                                    &
      & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) =             &
      & a_effectiveOpticalDepth(mif,i)

    if(associated(cloudRADSensitivity))                                      &
      & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =               &
      & a_cloudRADSensitivity(mif,i)
    enddo
    endif
a1059 2
    Deallocate (WC, a_trans, Slevl, Zt )
    Deallocate ( my_catalog, stat=ier )
d1072 3
a1074 4
    !--------------------------------------------
    ! End of sideband loop 
    !--------------------------------------------
    enddo
d1081 2
d1084 13
a1096 1
    
d1107 3
@


1.91
log
@minor changes
@
text
@a0 1

d71 1
a71 1
    "$Id: FullCloudForwardModel.f90,v 1.90 2001/11/16 00:49:05 jonathan Exp $"
d91 1
a91 1
    type(vector_T),                   intent(in) ::  FWDMODELIN, FwdModelExtra
d119 4
a122 4
    type (Signal_T) :: signal                                   ! A signal
    type(VectorValue_T), pointer :: STATE_ext                   ! A state vector quantity
    type(VectorValue_T), pointer :: STATE_los                   ! A state vector quantity
    type(VectorValue_T), pointer :: SIDEBANDRATIO               ! From the state vector
a127 1

d241 1
a241 1
    !-------------------------------------------------------
d245 1
a245 1
    !-------------------------------------------------------
d247 1
a247 1
    doLowZt = .false.
d249 1
a249 1
    if(forwardModelConfig%cloud_der == 1) doLowZt = .true.
d253 1
d255 1
d257 1
a257 1
          & quantityType=l_cloudInducedRadiance, &
a372 2
!   print*,'Lat=',tLat

d399 1
a484 1

a508 3
    !    if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
    !           & "No matching antenna patterns." )

d624 3
a626 3
    !------------------------------------------
    ! Now call the full CloudForwardModel code
    !------------------------------------------
d629 17
d662 1
a662 1
      & earthradius%values(1,maf),                                           &
d685 3
a687 1
      & My_Catalog, losVel%values(1,maf) )                                                         
d936 3
@


1.90
log
@clean log
@
text
@d7 1
a7 1
! -------------------------------------------------------------------------
d9 23
a31 28
! Jonathan Jiang,  Paul Wagner, July 16, 2001 
! Jonathan Jiang,  Dong Wu, add Jacobian, August 3, 2001
! Jonathan Jiang,  add Field Of View Convolution, August 16, 2001  
! Jonathan Jiang,  add sideband ratio, October 4, 2001 
! Jonathan Jiang,  add CloudProfile module, October 5, 2001 
! -------------------------------------------------------------------------

  use Allocate_deallocate, only: Allocate_test, Deallocate_test
  use AntennaPatterns_m, only: ANTENNAPATTERNS
  use CloudySkyModule, only: CLOUD_MODEL
  use CloudySkyRadianceModel, only: CloudForwardModel
  use Hdf, only: DFACC_READ, DFACC_CREATE
  use HDFEOS, only: SWOPEN,     SWCLOSE
  use L2GPData, only: L2GPData_T, ReadL2GPData, WriteL2GPData
  use MLSCommon,only: NameLen, FileNameLen, r8,  FINDFIRST
  use MLSMessageModule, only: MLSMessage, MLSMSG_Error
  use MLSSignals_m, only: SIGNAL_T, ARESIGNALSSUPERSET
  use MatrixModule_0, only: M_Absent, M_BANDED, MATRIXELEMENT_T, M_BANDED,   &
                          & M_COLUMN_SPARSE, CREATEBLOCK, M_FULL
  use MatrixModule_1, only: MATRIX_T, FINDBLOCK
  use ManipulateVectorQuantities, only: FindClosestInstances
  use MLSNumerics, only: InterpolateValues
  use Molecules, only: L_H2O, L_O3, spec_tags
  use Output_m, only: OUTPUT
  use PointingGrid_m, only: POINTINGGRIDS
  use SpectroscopyCatalog_m, only: CATALOG_T, LINE_T, LINES, CATALOG
  use Toggles, only: Emit, Levels, Toggle
  use Trace_M, only: Trace_begin, Trace_end
d33 5
a37 11
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE,                          &
                         & VECTOR_T, VECTORVALUE_T,                          &
                         & VALIDATEVECTORQUANTITY
  
! -----------------------------------------------------------------------
! THE FOLLOWING IS MODIFICATIONS FOR THE CLOUD FORWARD MODEL PARAMETERS
! -----------------------------------------------------------------------

  use ForwardModelConfig, only: FORWARDMODELCONFIG_T   
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T,            &
                                    & FORWARDMODELSTATUS_T
d72 1
a72 1
    "$Id: FullCloudForwardModel.f90,v 1.89 2001/11/16 00:47:13 jonathan Exp $"
d91 6
a96 6
    type(forwardModelConfig_T), intent(inout) :: FORWARDMODELCONFIG
    type(vector_T), intent(in) ::  FWDMODELIN, FwdModelExtra
    type(vector_T), intent(inout) :: FWDMODELOUT                ! Radiances, etc.
    type(forwardModelIntermediate_T), intent(inout) :: IFM      ! Workspace
    type(forwardModelStatus_t), intent(inout) :: FMSTAT         ! Reverse comm. stuff
    type(matrix_T), intent(inout), optional :: JACOBIAN
d117 7
a123 7
    type (VectorValue_T), pointer :: SCGEOCALT     ! Geocentric spacecraft altitude
    type (VectorValue_T), pointer :: ELEVOFFSET    ! Elevation offset quantity
    type (VectorValue_T), pointer :: LOSVEL        ! Line of sight velocity
    type (Signal_T) :: signal                      ! A signal
    type(VectorValue_T), pointer :: STATE_ext      ! A state vector quantity
    type(VectorValue_T), pointer :: STATE_los      ! A state vector quantity
    type(VectorValue_T), pointer :: SIDEBANDRATIO  ! From the state vector
d132 15
a146 15
    integer :: COLJBLOCK                ! Column index in jacobian
    integer :: ROWJBLOCK                ! Row index in jacobian
    integer :: noInstances              ! no of instance
    integer :: noMIFs                   ! Number of minor frames
    integer :: noSgrid                  ! no of elements in S grid
    integer :: noSurf                   ! Number of pressure levels
    integer :: novmrSurf                   ! Number of vmr levels
    integer :: noCldSurf                   ! Number of cloud ext levels
    integer :: NOFREQS                  ! Number of frequencies
    integer :: NOFREQS0                  ! Number of frequencies of the last signal

    integer :: i                        ! Loop counter
    integer :: j                        ! Loop counter
    integer :: k                        ! Loop counter
    integer :: IER                      ! Status flag from allocates
d149 14
a162 14
    integer :: MAF                      ! major frame counter
    integer :: INSTANCE                 ! Relevant instance for temperature
    integer :: MinInst                  ! lower bound of instance
    integer :: MaxInst                  ! upper bound of instance
    integer :: nfine                    ! no of fine resolution grids
    integer :: nNear                    ! no of nearest profiles
    integer :: status                   ! allocation status 
    integer :: SIDEBAND                 ! Loop index
    integer :: SIDEBANDSTART            ! For sideband loop
    integer :: SIDEBANDSTEP             ! For sideband loop
    integer :: SIDEBANDSTOP             ! For sideband loop
    integer :: THISSIDEBAND             ! Loop counter for sidebands
    integer :: SIGIND                   ! Signal index, loop counter
    integer :: SPECTAG                  ! A single spectag
d164 1
a164 1
    integer :: iCloudHeight                          ! Index for Cloud Top Height
d168 5
a172 5
    integer :: WHICHChannel                           ! which single channel is used
    integer :: WHICHPATTERN                           ! Index of antenna pattern
    integer :: MAXSUPERSET                            ! Max. value of superset
    integer, dimension(:), pointer :: SUPERSET        ! Result of AreSignalsSuperset
    integer, dimension(1) :: WHICHPATTERNASARRAY      ! Result of minloc
d181 11
a191 11
    real(r8), dimension(:,:), pointer :: VMRARRAY     ! The VMRs
    real(r8), dimension(:), allocatable :: Slevl      ! S grid
    real(r8), dimension(:), allocatable :: Zt         ! tangent height
    real (r8), dimension(:), pointer :: thisRatio     ! Sideband ratio values

    real(r8), dimension(:), pointer :: phi_fine       ! Fine resolution for phi 
    real(r8), dimension(:), pointer :: z_fine         ! Fine resolution for z
    real(r8), dimension(:), pointer :: zp_fine         ! Fine resolution for zp
    real(r8), dimension(:), pointer :: s_fine        ! Fine resolution for s
    real(r8), dimension(:), pointer :: ds_fine        ! Fine resolution for ds
    real(r8), dimension(:), pointer :: w_fine        ! weight along s_fine
d198 8
a205 8
    real(r8) :: dz                                    ! thickness of state quantity
    real(r8) :: dphi                                  ! phi interval of state quantity
    real(r8) :: tLat                                  ! temperature 'window' latitude
    real(r8) :: CloudHeight                           ! Cloud Top Height

    logical, dimension(:), pointer :: doChannel       ! Do this channel?
    logical :: DoHighZt                               ! Flag
    logical :: DoLowZt                                ! Flag
d209 1
a209 1
    logical :: FOUNDINFIRST                           ! Flag to indicate derivatives
d211 1
a211 1
    character :: cloudtype                            ! cloud profile type
d281 2
a282 2
        radiance => GetVectorQuantityByType ( fwdModelOut,                 &
          & quantityType=l_radiance,                                       &
d284 2
a285 2
        modelCloudRadiance => GetVectorQuantityByType ( fwdModelOut,     &
          & quantityType=l_cloudInducedRadiance,                           &
d287 1
a287 1
        cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          & 
d289 2
a290 2
        cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut,      &
          & quantityType=l_cloudRADSensitivity, noerror=.true.,            &
d292 1
a292 1
        totalExtinction => GetVectorQuantityByType ( fwdModelOut,          &
d294 2
a295 2
        effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut,    &
          & quantityType=l_effectiveOpticalDepth, noerror=.true.,          &
d297 1
a297 1
        massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,      &
d299 1
a299 1
        massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,    &
d305 1
a305 1
        ptan => GetVectorQuantityByType ( fwdModelExtra,       &
d308 1
a308 1
        temp => GetVectorQuantityByType ( fwdModelExtra,      &
d310 1
a310 1
        gph => GetVectorQuantityByType ( fwdModelExtra,       &
d312 1
a312 1
        cloudIce => GetVectorQuantityByType ( fwdModelExtra,   &
d314 1
a314 1
        cloudWater => GetVectorQuantityByType ( fwdModelExtra, &
d316 1
a316 1
        surfaceType => GetVectorQuantityByType ( fwdModelExtra, &
d318 1
a318 1
        sizeDistribution=>GetVectorQuantityByType(fwdModelExtra,&
d320 1
a320 1
        earthradius=>GetVectorQuantityByType ( fwdModelExtra,  &
d322 1
a322 1
        scGeocAlt => GetVectorQuantityByType ( fwdModelExtra, &
d324 1
a324 1
        elevOffset => GetVectorQuantityByType ( fwdModelExtra, &
d326 1
a326 1
        losVel => GetVectorQuantityByType ( fwdModelExtra, &
d353 1
a353 1
    call Allocate_test ( closestInstances, radiance%template%noInstances,   &
d364 1
a364 1
      & size(forwardModelConfig%molecules), noSurf,           &
d403 3
a405 3
        & reshape(vmr%values(:,instance),(/novmrSurf/)), &     ! Old Y
        & reshape(temp%template%surfs(:,1),(/noSurf/)), &   ! New X
        & vmrArray(i,:), &                     ! New Y
d411 1
a411 1
      call MLSMessage( MLSMSG_Error, ModuleName,                             &
d540 1
a540 1
          call MLSMessage ( MLSMSG_Error, ModuleName, &
d575 3
a577 3
        & reshape(gph%values(:,instance),(/noSurf/)), &            ! Old Y
        & reshape(ptan%values(:,maf),(/noMifs/)), &   ! New X
        & zt, &                     ! New Y
d633 1
d684 1
a684 1
    modelCloudRadiance%values (i+(mif-1)*noFreqs, maf ) = &
d687 2
a688 2
    if(associated(effectiveOpticalDepth)) &
      & effectiveOpticalDepth%values (i+(mif-1)*noFreqs, maf ) = &
d691 2
a692 2
    if(associated(cloudRADSensitivity)) &
      & cloudRADSensitivity%values (i+(mif-1)*noFreqs, maf ) =   &
d796 1
a796 1
            & reshape(gph%values(:,instance),(/noSurf/)), &    ! Old X
d798 2
a799 2
            & z_fine, &   ! New X
            & zp_fine, &                     ! New Y
d813 1
a813 1
            & sLevl, &            ! Old X
d815 2
a816 2
            & s_fine, &   ! New X
            & w_fine, &                     ! New Y
d828 2
a829 2
         do j = 1,noCldSurf               ! loop over cloudQty surface
         do k = 1,nfine*nNear             ! sum up all the lengths
d922 3
@


1.89
log
@change ptan from radiance%template%instrumentModule to Signal%instrumentModule
@
text
@d83 1
a83 1
    "$Id: FullCloudForwardModel.f90,v 1.88 2001/11/16 00:41:00 jonathan Exp $"
d932 3
d939 1
a939 1
! add default_spectroscopy
d942 1
a942 1
! rename DF_spectroscopy to default_spectroscopy
@


1.88
log
@add losVel
@
text
@d83 1
a83 1
    "$Id: FullCloudForwardModel.f90,v 1.87 2001/11/15 23:52:12 jonathan Exp $"
d317 2
a318 1
          & quantityType=l_ptan, instrumentModule = radiance%template%instrumentModule)
d932 3
@


1.87
log
@add default_spectroscopy
@
text
@d73 2
a74 1
                     & L_NONE
d83 1
a83 1
    "$Id: FullCloudForwardModel.f90,v 1.86 2001/11/15 23:50:21 jonathan Exp $"
d130 1
d244 1
a244 1
             MY_CATALOG, thisCatalogEntry, thisLine )
d336 2
a337 1

d682 1
a682 1
      & My_Catalog )                                                         
d931 3
@


1.86
log
@rename DF_spectroscopy to default_spectroscopy
@
text
@d82 1
a82 1
    "$Id: FullCloudForwardModel.f90,v 1.85 2001/11/09 18:12:13 jonathan Exp $"
d643 1
a643 1
      & noMifs,                                           &
d928 3
@


1.85
log
@add deallocate my_catalog
@
text
@d82 1
a82 1
    "$Id: FullCloudForwardModel.f90,v 1.84 2001/11/09 18:05:24 jonathan Exp $"
d655 1
a655 1
      & zt, &
d661 1
d928 3
@


1.84
log
@pass spectra catalog into CloudySkyRadianceModel
@
text
@d82 1
a82 1
    "$Id: FullCloudForwardModel.f90,v 1.83 2001/11/08 21:36:13 jonathan Exp $"
d892 2
a893 1
     
d927 3
@


1.83
log
@add SpectroscopyCatalog
@
text
@d23 1
a23 1
  use MLSCommon,only: NameLen,    FileNameLen, r8
d31 1
a31 1
  use Molecules, only: L_H2O, L_O3
d82 1
a82 1
    "$Id: FullCloudForwardModel.f90,v 1.82 2001/11/07 23:47:52 dwu Exp $"
d155 1
d171 1
d625 11
d677 2
a678 1
      & Slevl*1000._r8, noSgrid )
d926 3
@


1.82
log
@some minor changes
@
text
@d34 1
d69 2
a70 2
          		      & L_SCGEOCALT,                                          &
         		      & L_ELEVOFFSET,                                         &
d82 1
a82 1
    "$Id: FullCloudForwardModel.f90,v 1.81 2001/11/07 05:22:06 dwu Exp $"
d132 5
a137 1
    type(VectorValue_T), pointer :: SIDEBANDRATIO  ! From the state vector
d230 11
a240 10
    nullify( CLOUDICE, CLOUDWATER, CLOUDEXTINCTION, modelCLOUDRADIANCE,    &
             CLOUDRADSENSITIVITY, EFFECTIVEOPTICALDEPTH, obsCLOUDRADIANCE,GPH, &
             MASSMEANDIAMETERICE, MASSMEANDIAMETERWATER, PTAN,               &
             RADIANCE, SIZEDISTRIBUTION, EARTHRADIUS, SURFACETYPE,           &
             TEMP, TOTALEXTINCTION, VMR, VMRARRAY,closestInstances,          &
             A_CLEARSKYRADIANCE, A_CLOUDINDUCEDRADIANCE,                     &
             A_CLOUDEXTINCTION, A_CLOUDRADSENSITIVITY,                       &
             A_EFFECTIVEOPTICALDEPTH, A_MASSMEANDIAMETER,                    &
             A_TOTALEXTINCTION,FREQUENCIES,                         &
             superset, thisRatio, JBLOCK, state_ext, state_los )
d912 3
d1110 3
@


1.81
log
@fixed a bug in computing dphi
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.80 2001/11/06 21:54:47 dwu Exp $"
d145 1
d254 10
a263 4
    !------------------------------------------------------------------------
    ! Current version can only have one signal for FullCloudForwardModel
    ! This will be updated soon
    !------------------------------------------------------------------------
a311 3
        obsCloudRadiance => GetVectorQuantityByType ( fwdModelExtra,     &
          & quantityType=l_cloudInducedRadiance, noerror=.true.,  &
          & signal=signal%index, sideband=signal%sideband )
d597 3
a599 2
         do i = 1, noMifs
            if(obsCloudRadiance%values(i,maf) .ne. 0.0_r8) iCloudHeight = i
d602 3
a604 2
         do i = 1, noMifs
            if(obsCloudRadiance%values(i,maf) .ne. 0.0_r8) iCloudHeight = i
d607 3
a609 4

       ! if no cloud is found, cloud top is 18 km
       CloudHeight = 18.e3_r8     ! meters
       if(iCloudHeight .ne. 0) CloudHeight = zt(iCloudHeight)
d663 1
d689 1
a722 3
      do i=1, noFreqs
        if (doChannel(i)) whichChannel=i
      end do
d793 3
a795 2
        ds_fine(1:nfine*nNear-1) = s_fine(2:nfine*nNear) - &
         & s_fine(1:nfine*nNear-1)
d906 3
@


1.80
log
@use phiWindow to save time
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.79 2001/11/06 20:06:31 dwu Exp $"
d569 1
a569 1
        & reshape(temp%template%surfs,(/noSurf/)), &    ! Old X
d748 3
a750 3
       phi_fine(i) = minval(state_ext%template%phi(1,minInst:maxInst)) + &
         & (i-1._r8)/nfine/nNear*(maxval(state_ext%template%phi(1,minInst:maxInst)) - &
         & minval(state_ext%template%phi(1,minInst:maxInst)))
d759 5
a763 2
      if(instance < noInstances) &
         & dphi = abs(state_ext%template%phi(1,instance+1)-state_ext%template%phi(1,instance))
d767 2
a768 1
      if(gph%values(noCldSurf,instance) > zt(mif)) then
d777 2
a778 2
            & reshape(gph%values(:,instance),(/noSurf/)), &            ! Old X
            & reshape(temp%template%surfs,(/noSurf/)), &    ! Old Y
d819 1
a819 1
      
d901 3
@


1.79
log
@speed up Jacobian calculation for high tangent heights
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.78 2001/11/06 19:52:42 dwu Exp $"
d733 1
a733 1
      nNear = 5
d785 2
a786 2
        ds_fine(1:nfine*noInstances-1) = s_fine(2:nfine*noInstances) - &
         & s_fine(1:nfine*noInstances-1)
d805 1
a805 1
         do k = 1,nfine*noInstances       ! sum up all the lengths
d897 3
@


1.78
log
@speed up Jacobian calculation for high tangent heights
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.77 2001/11/06 18:28:06 dwu Exp $"
d156 1
d732 14
a745 7
      nfine=100
      allocate( phi_fine(nfine*noInstances), stat=status )
      allocate( z_fine(nfine*noInstances), stat=status )
      allocate( zp_fine(nfine*noInstances), stat=status )
      allocate( s_fine(nfine*noInstances), stat=status )
      allocate( w_fine(nfine*noInstances), stat=status )
      allocate( ds_fine(nfine*noInstances), stat=status )
d747 4
a750 3
      do i=1,noInstances*nfine
       phi_fine(i) = minval(state_ext%template%phi(1,:)) + (i-1._r8)/nfine/noInstances* &
         & (maxval(state_ext%template%phi(1,:)) - minval(state_ext%template%phi(1,:)))
a802 6
        ! only nearest instances are mattered
        minInst = instance - 2
        maxInst = instance + 2
         if(minInst < 1) minInst = 1
         if(maxInst > noInstances) maxInst = noInstances
         
d897 3
@


1.77
log
@some cleanups
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.76 2001/11/06 00:54:11 dwu Exp $"
a145 1
    integer :: chan
d153 2
a154 2
    integer :: GPHINST                  ! Relevant instance for GPH
    integer :: NOLAYERS                 ! temp.noSurfs - 1
a161 1
    integer :: NOUSEDCHANNELS           ! How many channels are we considering
a163 3
    integer :: quantity_type, L_quantity_type       ! added on Jul 13
    integer :: L_state_type

a172 2
    integer, dimension(:), pointer :: USEDCHANNELS    ! Which channel is this
    integer, dimension(:), pointer :: USEDSIGNALS     ! Which signal is this channel from
a206 1
    logical :: QGot(8) = .false.  
d232 1
a232 2
             superset, usedchannels, usedsignals, thisRatio,                 &
             JBLOCK, state_ext, state_los )
d775 1
a777 1
        ds_fine(nfine*noInstances) = 0._r8
d793 8
a800 1
         do i = 1,noInstances             ! loop over profile
d837 2
a838 2
        do chan = 1, noFreqs
          if ( doChannel(chan) ) then
d843 2
a844 2
               jBlock%values(chan,i+(mif-1)*noSgrid)= a_trans(i,mif,chan)* &
                  & (frequencies(chan)/200000._r8)**4
d848 1
a848 1
        end do    ! chan
d894 3
@


1.76
log
@add two cloud radiances: modelled and observed
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.75 2001/11/06 00:29:38 dwu Exp $"
a198 1
    real(r8) :: ds_tot                                ! Total length of all ds
d251 10
d584 2
a585 1

d592 1
a592 1
      ! find cloud top index from Tcir, threshold to be determined
d595 1
a595 1
      if(.not. associated(effectiveOpticalDepth)) then
d600 9
a608 3
       do i = 1, noMifs
         if(obsCloudRadiance%values(i,maf) .ne. 0.0_r8) iCloudHeight = i
       enddo
d610 1
d665 1
a665 10
    !------------------------------------------------------------------------
    ! Now store results in relevant vectors
    ! Vectors are stored (noChannels*noSurfaces, noInstances), so transpose
    ! and reshape temporary variables to be in the right form.
    !------------------------------------------------------------------------
    
    !------------------------------
    ! First the minor frame stuff
    !------------------------------

d686 1
a686 1
    ! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
d690 1
a690 1
    ! and the last signal (band) will over write the previous signals (bands)
d696 1
a696 1
        & cloudExtinction%values ( :, instance )    = a_cloudExtinction(:,i)
d698 1
a698 1
        & totalExtinction%values ( :, instance )    = a_totalExtinction (:,i)
a711 10
    !-------------------------------------------------------
    ! Determine which retrieval is to be used
    !    cloud_der = 0     high tangent height
    !    cloud_der = 1     low tangent height
    !-------------------------------------------------------
    doHighZt = .false.
    doLowZt = .false.
    if(forwardModelConfig%cloud_der == 0) doHighZt = .true.
    if(forwardModelConfig%cloud_der == 1) doLowZt = .true.

d728 1
a728 1
      colJBlock = FindBlock ( Jacobian%col, state_ext%index, maf )
d735 1
a735 1
        jBlock%values = 0.0_r8
d749 1
a749 2
       phi_fine(i) = minval(state_ext%template%phi(1,:)) + &
         & 1._r8*(i-1)/nfine/noInstances * &
d754 1
a754 1
      ! find intervals of stateQ at maf
d756 1
d758 1
d763 1
a763 1
      ! only for tangent heights less than the top level of retrieval
d797 1
a797 7
        ds_fine = ds_fine*w_fine

        !-----------------------------------------------
        ! find the total length for this tangent height
        !-----------------------------------------------
        ds_tot = 2._r8*sqrt(2._r8*earthradius%values(1,maf)* & 
            & (gph%values(noCldSurf,instance)-zt(mif)))
d861 1
a861 1
    deallocate (WC, stat=status)
d864 9
a872 22

    call Deallocate_test ( a_massMeanDiameter,                               &
                          'a_massMeanDiameter',           ModuleName )
    call Deallocate_test ( a_cloudExtinction,                                &
                          'a_cloudExtinction',            ModuleName )
    Deallocate ( a_trans, Slevl )

    call Deallocate_test ( a_totalExtinction,                                &
                          'a_totalExtinction',            ModuleName )
    call Deallocate_test ( a_cloudRADSensitivity,                            &
                          'a_cloudRADSensitivity',        ModuleName )
    call Deallocate_test ( a_effectiveOpticalDepth,                          &
                          'a_effectiveOpticalDepth',      ModuleName )
    call Deallocate_test ( a_cloudInducedRadiance,                           &
                          'a_cloudInducedRadiance',       ModuleName )
    call Deallocate_test ( a_clearSkyRadiance,                               &
                          'a_clearSkyRadiance',           ModuleName )
    call Deallocate_test ( vmrArray,                                         &
                          'vmrArray',                     ModuleName )
    call Deallocate_test ( closestInstances,                                 &
                          'closestInstances',             ModuleName )

a873 1
    deallocate(zt)
d896 3
@


1.75
log
@set up cloud height estimation using DTcir
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.74 2001/11/05 22:39:57 dwu Exp $"
d111 2
a112 1
    type (VectorValue_T), pointer :: CLOUDINDUCEDRADIANCE       ! Like radiance
d232 2
a233 2
    nullify( CLOUDICE, CLOUDWATER, CLOUDEXTINCTION, CLOUDINDUCEDRADIANCE,    &
             CLOUDRADSENSITIVITY, EFFECTIVEOPTICALDEPTH, GPH,                &
d277 1
a277 1
        cloudInducedRadiance => GetVectorQuantityByType ( fwdModelOut,     &
d304 3
d585 4
d591 1
a591 1
         if(cloudInducedRadiance%values(i,maf) .ne. 0.0_r8) iCloudHeight = i
d599 2
a600 1

d663 1
a663 2
    if(associated(cloudInducedRadiance)) &
      & cloudInducedRadiance%values (i+(mif-1)*noFreqs, maf ) = &
d917 3
@


1.74
log
@high Zt Jacobian
@
text
@d68 2
a69 2
   		     & L_SCGEOCALT,                                          &
		     & L_ELEVOFFSET,                                         &
d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.73 2001/11/05 20:25:14 dwu Exp $"
a108 1
    type (VectorValue_T), pointer :: IWC1 
d241 1
a241 1
             JBLOCK, state_ext, state_los, IWC1 )
a304 2
        IWC1 => GetVectorQuantityByType ( fwdModelExtra,   &
          & quantityType=l_cloudExtinction )
d562 8
d578 3
a580 1
      ! find cloud top index from state_ext that is defaulted as zero
d582 2
a583 7
       do i = 1, noCldSurf
!          if(state_ext%values(i,instance) > 1.e-6_r8) then
         if(instance > 2) then
          if(IWC1%values(i,instance-2) > 0.0_r8) then
            iCloudHeight = i                    ! FIND INDEX FOR CLOUD-TOP
          endif
         endif
d587 1
a587 1
       if(iCloudHeight .ne. 0) CloudHeight = gph%values(iCloudHeight, instance)
d589 2
a590 2
       call CLOUD_MODEL ( CloudType, CloudHeight, gph%values(:,instance),   &
	     &            noSurf, WC )
a593 8
! get tangent height from tangent pressure
      call InterpolateValues ( &
        & reshape(temp%template%surfs,(/noSurf/)), &    ! Old X
        & reshape(gph%values(:,instance),(/noSurf/)), &            ! Old Y
        & reshape(ptan%values(:,maf),(/noMifs/)), &   ! New X
        & zt, &                     ! New Y
        & 'Linear' )

d601 1
a601 1
      & radiance%template%noSurfs,                                           &
d804 2
a805 2
           if(abs(zp_fine(k) - state_ext%template%surfs(j,1)) < dz/2. &
           & .AND. abs(phi_fine(k) - state_ext%template%phi(1,i)) < dphi/2.) &
d807 1
a807 1
           & jBlock%values(mif,j+(i-1)*noCldSurf) + ds_fine(k)/ds_tot
d909 3
@


1.73
log
@*** empty log message ***
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.72 2001/11/02 01:14:17 dwu Exp $"
d785 1
d915 3
@


1.72
log
@correction in high cloud Jacobian
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.71 2001/11/02 01:00:13 jonathan Exp $"
d577 1
d579 1
a579 1
            iCloudHeight = i                    ! FIND INDEX FOR CLOUD-TOP              
d581 1
d753 7
d761 3
a763 7
      do mif = 1, noMIFs      
        !----------------------------------
        ! find intervals of stateQ at maf
        !----------------------------------
        dz = abs(state_ext%template%surfs(2,instance)-state_ext%template%surfs(1,instance))
        dphi = abs(state_ext%template%phi(1,instance+1)-state_ext%template%phi(1,instance))

d800 2
a801 3
        ds_tot = 2._r8*sqrt((earthradius%values(1,maf)+ & 
            & gph%values(noCldSurf,instance))**2 - &
            & (earthradius%values(1,maf)+zt(mif))**2)
d807 3
a809 3
         do j = 1,noCldSurf                  ! loop over surface
         do k = 1, nfine*noInstances      ! sum up all the lengths
           if(abs(zp_fine(k) - state_ext%template%surfs(j,i)) < dz/2. &
d815 2
a816 1
         end do 
d825 1
a825 1

d914 3
@


1.71
log
@add IWC1
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.70 2001/11/02 00:47:34 dwu Exp $"
d806 1
a806 1
           & .AND. abs(phi_fine(k) - state_ext%template%phi(j,i)) < dphi/2.) &
d909 3
@


1.70
log
@correction in high cloud Jacobian
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.69 2001/11/02 00:45:33 dwu Exp $"
d109 1
d242 1
a242 1
             JBLOCK, state_ext, state_los )
d306 2
a324 8
        if(.not. (associated(ptan) .and. associated(temp) .and. associated(gph) &
           & .and. associated(cloudIce) .and. associated(cloudWater) &
           & .and. associated(surfaceType) .and. associated(sizeDistribution) &
           & .and. associated(earthradius) .and. associated(scGeocAlt) &
           & .and. associated(elevOffset) ) ) &
          call MLSMessage ( MLSMSG_Error, ModuleName,                        &
                            'Cloud Model inputs are not sufficient')

d576 2
a577 1
          if(state_ext%values(i,instance) > 1.e-6_r8) then
d909 3
@


1.69
log
@correction in high cloud Jacobian
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.68 2001/11/02 00:42:05 dwu Exp $"
d800 1
a800 1
            & gph%template%surfs(noCldSurf,instance))**2 - &
d913 3
@


1.68
log
@correction in high cloud Jacobian
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.67 2001/11/02 00:25:58 dwu Exp $"
d800 1
a800 1
            & state_ext%template%surfs(noCldSurf,instance))**2 - &
d913 3
@


1.67
log
@correction in high cloud Jacobian
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.66 2001/10/30 05:25:48 dwu Exp $"
d760 2
a761 2
        dz = abs(state_ext%template%surfs(2,maf)-state_ext%template%surfs(1,maf))
        dphi = abs(state_ext%template%phi(2,maf)-state_ext%template%phi(1,maf))
d913 3
@


1.66
log
@assign whichchannle
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.65 2001/10/19 19:29:50 dwu Exp $"
d811 2
a812 2
           & jBlock%values(mif,j+(i-1)*noInstances) = &
           & jBlock%values(mif,j+(i-1)*noInstances) + ds_fine(k)/ds_tot
d913 3
@


1.65
log
@initialize output quantities
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.64 2001/10/19 16:26:09 dwu Exp $"
d371 1
a371 1
    print*,'Lat=',tLat
d726 4
a729 1
      
d913 3
@


1.64
log
@some minors
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.63 2001/10/18 22:17:02 dwu Exp $"
a686 1
      whichChannel = i
d910 3
@


1.63
log
@pretection for sensitivity=0
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.62 2001/10/18 06:06:24 dwu Exp $"
d370 2
a550 2
    tLat = temp%template%geodLat(1,instance)

d578 1
d581 1
a581 1
          if(state_ext%values(i,instance) .ne. 0.) then
d584 1
a584 1
        enddo
d586 2
a587 2
        CloudHeight = 20.e3_r8     ! meters  as a default
        if(iCloudHeight .ne. 0) CloudHeight = gph%values(iCloudHeight, instance)
d589 1
a589 1
        call CLOUD_MODEL ( CloudType, CloudHeight, gph%values(:,instance),   &
a646 2
    deallocate (WC, stat=status)
     
a845 1
             if(a_trans(i,mif,chan) .ne. 0._r8) then
a847 4
             else    ! in case of very tiny IWC
               jBlock%values(chan,i+(mif-1)*noSgrid) = -106._r8 * &
                  & (frequencies(chan)/200000._r8)**4
             end if
d862 2
d911 3
@


1.62
log
@minor
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.61 2001/10/12 16:58:31 dwu Exp $"
d194 1
d396 1
a396 1
	novmrSurf = vmr%template%nosurfs
d744 1
d773 1
a773 1
            & z_fine, &                     ! New Y
d808 1
a808 1
           if(abs(z_fine(k) - state_ext%template%surfs(j,i)) < dz/2. &
d819 1
d847 1
d850 4
d915 3
@


1.61
log
@distinguish number surfaces between model temperature grid and retrieval ext grid
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.60 2001/10/11 22:44:01 dwu Exp $"
d141 1
d296 1
a296 1
        ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,       &
d298 1
a298 1
        temp => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,      &
d300 1
a300 1
        gph => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,       &
d302 1
a302 1
        cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,   &
d304 1
a304 1
        cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d306 1
a306 1
        surfaceType => GetVectorQuantityByType ( fwdModelIn,fwdModelExtra, &
d308 1
a308 1
        sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra,&
d310 1
a310 1
        earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,  &
d312 1
a312 1
	     scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d314 1
a314 1
        elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d339 7
d361 1
a361 1
      & size(forwardModelConfig%molecules), temp%template%noSurfs,           &
d395 1
d397 3
a399 3
        & vmr%template%surfs(:,1), &    ! Old X
        & vmr%values(:,instance), &            ! Old Y
        & temp%template%surfs(:,1), &   ! New X
a409 7
    ! ----------------------------
    ! Get some basic dimensions
    ! ----------------------------
    noMIFs  = radiance%template%noSurfs
    noFreqs = size (signal%frequencies) ! Note: noFreq and noChans should be the same
    noSurf  = temp%template%noSurfs     ! Number of model layers

d433 1
a433 1
       sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d584 1
a584 1
        CloudHeight = 18.e3_r8     ! meters  as a default
d907 3
@


1.60
log
@modify high zt Jacobian and use cloud_der as the switch between high and low Zt
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.59 2001/10/11 17:01:11 jonathan Exp $"
d141 1
d557 2
d576 1
a576 1
       do i = 1, noSurf  
a725 3
    ! Get dimension
      noSurf = state_ext%template%noSurfs
      
d732 1
a732 1
        call CreateBlock ( jBlock, noMIFs, noSurf*noInstances, M_Full )
d795 1
a795 1
            & state_ext%template%surfs(noSurf,instance))**2 - &
d802 1
a802 1
         do j = 1,noSurf                  ! loop over surface
d905 3
@


1.59
log
@for (cloud/total)extinction/output one channel per band
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.58 2001/10/10 18:55:17 dwu Exp $"
a136 1
    integer :: XINSTANCE                ! Instance in x corresponding to xStarInstance
a137 1
    integer :: noChans                  ! Dimension
a140 2
    integer :: NQ1
    integer :: NQ2                      ! no of quantities in extraModelIn
a141 1
    integer :: noNonZero                ! Number of nonzero values in Jacobian
d170 1
d186 2
a187 1
    real(r8), dimension(:), allocatable :: Slevl
d192 1
d194 1
a402 1
    noChans = radiance%template%noChans
d407 1
a407 1
    call allocate_test ( thisRatio, noChans, 'thisRatio', ModuleName )
d409 1
d551 1
a551 1
    ! get state quantity type 
d587 8
d614 1
d682 1
a698 1
    IF ( present(jacobian) ) THEN
d702 2
d705 5
d713 1
a713 1
    ! Jacobian for high tangent height retrieval
a714 4
    !doHighZt = present(jacobian) .and. (l_stateQ_type == l_cloudExtinction)

    doHighZt = .false.
    if (doHighZt) then      
d716 7
a731 2
      select case ( jBlock%kind )
      case ( M_Absent )
d741 2
d749 1
a749 1
      end do 
d751 1
a751 2
      do mif = 1, noMIFs
        
d761 2
a762 3
        z_fine = (earthradius%values(1,maf)+ &
         & (ptan%values(mif,maf)+3.)*16.) / &
         & cos((phi_fine - radiance%template%phi(mif,maf))*pi/180._r8) - &
d764 7
a770 1
        z_fine = z_fine/16._r8 - 3._r8    ! convert back to log pressure
d773 1
a773 1
        ! find ds for each (z,phi) pair
d775 15
a789 3
        ds_fine = (earthradius%values(1,maf)+ &
         & (ptan%values(mif,maf)+3.)*16.) / &
         & cos((phi_fine - radiance%template%phi(mif,maf))*pi/180._r8)**2
d794 3
a796 1
        ds_tot = sum(ds_fine)
d811 1
a811 1
      end do
d816 2
d819 1
a819 5
      case default
         call MLSMessage(MLSMSG_Error, ModuleName, &
                 & "Invalid matrix block kind in CreateBlock")              
      end select
    end if
d824 1
a824 4
    ! doLowZt = present(jacobian) .and. (l_stateQ_type == l_LosTransFunc)

    doLowZt = .true.
    if (doLowZt) then
d833 1
a833 1
        call CreateBlock ( jBlock, noChans, noSgrid*noMIFs, M_Full )
d836 1
a836 1
        do chan = 1, noChans
d846 2
d849 1
a850 6
          end if
        end do

    endif

    ENDIF   
d882 1
a882 1

d905 3
@


1.58
log
@why elevOffset is not maf-dependent?
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.57 2001/10/10 18:33:53 dwu Exp $"
d668 13
a680 2
    if(associated(cloudExtinction)) &
      & cloudExtinction%values ( :, instance )    = a_cloudExtinction(:,1)
d685 1
a685 2
    if(associated(totalExtinction)) &
      & totalExtinction%values ( :, instance )    = a_totalExtinction (:,1)
d877 3
@


1.57
log
@normalize cloud extinction weighting function to 200GHz
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.56 2001/10/09 22:11:54 jonathan Exp $"
d613 2
a614 2
      & scGeocAlt%values(1,maf),                                               &
      & elevOffset%values(1,maf),                                              &
d867 3
@


1.56
log
@*** empty log message ***
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.55 2001/10/09 17:50:17 jonathan Exp $"
a127 2
    type(MatrixElement_T), pointer :: JBLOCK       ! A block from the jacobian
    !type(VectorValue_T), pointer :: STATEQ        ! A state vector quantity
d134 1
a154 1
!    integer :: VMRINST                  ! Instance index
a255 4
    !    if ( size ( forwardModelConfig%signals ) /= 1 )                        &
    !       & call MLSMessage ( MLSMSG_Error, ModuleName,                       &
    !       & 'Cannot call the full cloud forward model with multiple signals' )

a258 2

    !signal = forwardModelConfig%signals(1)
d613 2
a614 2
      & scGeocAlt%values(1,1),                                               &
      & elevOffset%values(1,1),                                              &
d791 1
a791 8
        select case ( jBlock%kind )

        case ( M_Absent )

        ! ---------------------------------------------------------------
        ! In the absent case, the jacobian is stored in a special format
        !----------------------------------------------------------------

a794 5
         jBlock%kind = M_Absent     ! createBlock has changed jBlock%kind

        !------------------------------------------
        ! Now fill the jacobian, case ( M_Absent )
        !------------------------------------------
d799 4
a802 2
               jBlock%values(chan, & 
                & i+(mif-1)*noSgrid)= a_trans(i,mif,chan)
a809 5
         case default
               call MLSMessage(MLSMSG_Error, ModuleName, &
                 & "Invalid matrix block kind in CreateBlock")              
         end select
               
d867 3
@


1.55
log
@*** empty log message ***
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.54 2001/10/09 17:47:33 jonathan Exp $"
d192 1
a192 1

d200 1
a200 1
    real(r8), dimension(:,:), pointer :: A_TRANS
d203 1
a203 1
    real(r8), dimension(:,:), allocatable :: TransOnS
d239 1
a239 1
             A_TOTALEXTINCTION, A_TRANS,FREQUENCIES,                         &
d487 1
a487 3
    call Allocate_test ( a_Trans,                                            &
      & temp%template%noSurfs, noFreqs,                                      &
      & 'a_trans', ModuleName )
a555 1
    IF ( present(jacobian) ) THEN
d565 10
d635 2
a636 1
      & forwardModelConfig%NUM_SIZE_BINS )
a792 3
        ! Get dimension
        noSgrid=state_los%template%noChans

a810 1
        allocate( TransOnS(noSgrid, noMIFs), stat=status )
d817 8
a824 21
          !-----------------------------------------------------------------
          ! now, we define beta as transmission function in Sensitivity.f90
          ! and we interpolate it onto Sgrid
          !-----------------------------------------------------------------
          call FindTransForSgrid (                                   &
                      &     ptan%values(:,maf),                      &
                      &     earthradius%values(1,maf)*1.e-3_r8,      &
                      &     noMIFs,                                  &
                      &     temp%template%noSurfs,                   &
                      &     noSgrid,                                 &
                      &     gph%template%Surfs,                      &
                      &     a_trans(:,chan),               &
                      &     state_los%template%frequencies,             &
                      &     TRANSonS )                

                    do mif = 1, noMIFs
                    do i=1,noSgrid
                     jBlock%values(chan, & 
                       & i+(mif-1)*noSgrid)= TransOnS(i,mif)
                    end do
                    end do
a827 48
        Deallocate(TransOnS,stat=status)

        case ( M_Banded )     
        
        noNonZero = noSgrid*noMIFs*noInstances
        
        call CreateBlock ( jBlock, noChans*noMIFs, &
                         & noSgrid*noMIFs*noInstances, &
                         & M_Banded, noNonZero )

        allocate( TransOnS(noSgrid, noMIFs), stat=status )

       !------------------------------------------
       ! Now fill the jacobian, case ( M_Banded )
       !------------------------------------------
        do chan = 1, noChans
          if ( doChannel(chan) ) then
          !-----------------------------------------------------------------
          ! now, we define beta as transmission function in Sensitivity.f90
          ! and we interpolate it onto Sgrid
          !-----------------------------------------------------------------
          call FindTransForSgrid (                                   &
                      &     ptan%values(:,maf),                      &
                      &     earthradius%values(1,maf)*1.e-3_r8,      &
                      &     noMIFs,                                  &
                      &     temp%template%noSurfs,                   &
                      &     noSgrid,                                 &
                      &     gph%template%Surfs,                      &
                      &     a_trans(:,chan),                         &
                      &     state_los%template%frequencies,             &
                      &     TRANSonS )                

            jBlock%values = 0.0_r8
            jBlock%r2(0) = 0
            
            do i=1,noSgrid
            do mif=1,noMIFs
            jBlock%r1(i+(mif-1)*noSgrid) = noChans*(mif-1)
            jBlock%r2(i+(mif-1)*noSgrid) = noChans* & 
               & (i+(mif-1)*noSgrid+(maf-1)*noInstances)
            jBlock%values(i+(mif-1)*noSgrid,1) = TransOnS(i,mif)
            enddo
            enddo

         end if
         end do

              Deallocate(TransOnS,stat=status)
d849 2
a850 2
    call Deallocate_test ( a_trans,                                          &
                          'a_trans',                      ModuleName )
a888 33
subroutine FindTransForSgrid ( PT, Re, NT, NZ, NS, Zlevel, TRANSonZ, Slevel, TRANSonS)

  use MLSCommon,only: r8
  use MLSNumerics, only: INTERPOLATEVALUES
 
  integer :: NT                 ! No. of tangent pressures
  integer :: NZ                 ! No. of pressure levels
  integer :: NS                 ! No. of S levels
  integer :: mif
  
  real(r8) :: PT(NT)            ! this -log10 pressure
  real(r8) :: Re                ! in km
  real(r8) :: Zlevel(NZ)
  real(r8) :: Slevel(NS)
  real(r8) :: TRANSonZ(NZ)
  real(r8) :: TRANSonS(NS,NT)

  real(r8) :: zt(nt),x_out(ns)
    TransOns = 0._r8
    zt = (pt+3.)*16.                      ! converted to height in km
    do mif=1,nt

      ! find altitude of each s grid
      x_out = Slevel**2/2./(re + zt(mif))
      ! converted to zeta
      x_out = x_out/16. + pt(mif)

      CALL INTERPOLATEVALUES(Zlevel,TransOnZ,x_out,TransOnS(:,mif),method='Linear')

     enddo

end subroutine FindTransForSgrid

d890 3
@


1.54
log
@some changes
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.53 2001/10/08 23:43:00 dwu Exp $"
d647 1
a647 1
    radiance%values (i+(mif-1)*noFreqs, maf) = a_clearSkyRadiance(i, mif) 
d651 1
a651 1
      & a_cloudInducedRadiance(i, mif)
d655 1
a655 1
      & a_effectiveOpticalDepth(i, mif)
d659 1
a659 1
      & a_cloudRADSensitivity(i, mif)
d980 3
@


1.53
log
@fix jBlock%kind initialization
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.52 2001/10/08 21:46:39 jonathan Exp $"
d644 4
a647 3
    radiance%values ( :, maf) =                                              &
      & reshape ( transpose(a_clearSkyRadiance),                             &
      & (/radiance%template%instanceLen/) )
d650 2
a651 3
      & cloudInducedRadiance%values ( :, maf ) =                             &
      & reshape ( transpose(a_cloudInducedRadiance),                         &
      & (/cloudInducedRadiance%template%instanceLen/) )
d654 2
a655 3
      & effectiveOpticalDepth%values ( :, maf ) =                            &
      & reshape ( transpose(a_effectiveOpticalDepth),                        &
      & (/effectiveOpticalDepth%template%instanceLen/) )
d658 5
a662 3
      & cloudRADSensitivity%values ( :, maf ) =                              &
      & reshape ( transpose(a_cloudRADSensitivity),                          &
      & (/cloudRADSensitivity%template%instanceLen/) )
d980 3
@


1.52
log
@add CloudySkyModule
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.50 2001/10/08 21:42:29 dwu Exp $"
a699 5
!      colJBlock = 0
!      do while (colJBlock <= jacobian%col%nb .and. &
!           jacobian%col%inst(colJBlock) /= maf)
!           colJBlock = colJBlock +1 
!      end do
d801 1
a801 2
        call CreateBlock ( jBlock, noChans, &
            & noSgrid*noMIFs, M_Full )
d804 1
d979 3
@


1.51
log
@*** empty log message ***
@
text
@@


1.50
log
@*** empty log message ***
@
text
@d18 1
a18 1
  use CloudSkyModule, only: CLOUD_MODEL
d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.49 2001/10/08 21:35:33 dwu Exp $"
d984 3
@


1.49
log
@*** empty log message ***
@
text
@d18 1
a18 1
  use CloudProfile, only: CLOUD_MODEL
d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.48 2001/10/08 20:57:05 dwu Exp $"
d581 1
a581 1
        CloudHeight = 18.e3_r8     ! m  as a default
d984 3
@


1.48
log
@change coljBlock finder
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.47 2001/10/08 20:46:26 dwu Exp $"
d569 1
a569 1
          CloudType='convective'
d571 1
a571 1
          CloudType='frontal'
d581 1
a581 1
        CloudHeight = 18.     ! km  as a default
d984 3
@


1.47
log
@add default cloudheight as 18km
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.46 2001/10/08 20:34:18 dwu Exp $"
d697 1
d700 5
a704 5
      colJBlock = 0
      do while (colJBlock <= jacobian%col%nb .and. &
           jacobian%col%inst(colJBlock) /= maf)
           colJBlock = colJBlock +1 
      end do
d792 1
a792 1
        colJBlock = FindBlock ( Jacobian%col, ptan%index, maf )
d984 3
@


1.46
log
@*** empty log message ***
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.45 2001/10/08 20:23:54 jonathan Exp $"
d574 1
d581 2
a582 1
        CloudHeight = gph%values(iCloudHeight, instance)
d983 3
@


1.45
log
@some changes
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.44 2001/10/08 19:25:48 jonathan Exp $"
d364 7
d391 1
a391 1
      call FindClosestInstances ( vmr, radiance, closestInstances )
d393 1
a393 1
      instance = closestInstances(maf)
a408 6
    !---------------------------------------------------------
    ! Work out the closest instances for the other quantities
    !---------------------------------------------------------
    call FindClosestInstances ( temp, radiance, closestInstances )
    instance = closestInstances(maf)

d981 3
@


1.44
log
@delet vmrINS
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.43 2001/10/07 23:42:17 jonathan Exp $"
d389 1
a389 1
        & vmr%template%surfs(:,instance), &    ! Old X
d391 1
a391 1
        & temp%template%surfs(:,instance), &   ! New X
d980 3
@


1.43
log
@add CloudProfile module
@
text
@d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.42 2001/10/05 22:25:40 dwu Exp $"
d156 1
a156 1
    integer :: VMRINST                  ! Instance index
d385 2
a386 1
      vmrInst = closestInstances(maf)
d389 4
a392 4
        & vmr%template%surfs(:,1), &    ! Old X
        & vmr%values(:,vmrInst), &      ! Old Y
        & temp%template%surfs(:,1), &   ! New X
        & vmrArray(i,:), &              ! New Y
d555 1
a555 1
    tLat = temp%template%geodLat(1,1)
d567 1
a567 1
       if (tLat .ge. -25._r8 .and. tLat .le. 25._r8) then
d980 3
@


1.42
log
@allow multiple signals
@
text
@d12 2
d18 1
d26 1
a26 1
  use MatrixModule_0, only: M_Absent, M_BANDED, MATRIXELEMENT_T, M_BANDED, &
a50 1
! I'm not sure anything else is needed !
d81 1
a81 1
    "$Id: FullCloudForwardModel.f90,v 1.41 2001/10/05 20:46:39 dwu Exp $"
d95 1
d129 4
a132 1
    type(VectorValue_T), pointer :: STATEQ         ! A state vector quantity
a160 1
    character :: reply
d171 3
a173 1
    integer :: L_stateQ_type
d177 3
a179 3
    integer :: WHICHPATTERN             ! Index of antenna pattern
    integer :: MAXSUPERSET              ! Max. value of superset
    integer, dimension(:), pointer :: SUPERSET ! Result of AreSignalsSuperset
d191 1
a191 1
    real(r8), dimension(:,:), pointer :: VMRARRAY               ! The VMRs
d193 1
a193 1
    real (r8), dimension(:), pointer :: thisRatio ! Sideband ratio values
d195 4
a198 4
    real(r8), dimension(:), pointer :: phi_fine  !fine resolution for phi 
    real(r8), dimension(:), pointer :: z_fine  !fine resolution for z
    real(r8), dimension(:), pointer :: ds_fine  !fine resolution for ds
    real(r8) :: ds_tot     ! total length of all ds
d205 9
a213 7
    real(r8) :: dz                        ! thickness of state quantity
    real(r8) :: dphi                      ! phi interval of state quantity
    
    logical, dimension(:), pointer :: doChannel ! Do this channel?
    logical :: DoHighZt                   ! Flag
    logical :: DoLowZt                    ! Flag
    logical :: Got(2) = .false.  
d216 4
a219 1
    logical :: FOUNDINFIRST               ! Flag to indicate derivatives
d241 1
a241 1
             JBLOCK, stateQ )
d258 3
a260 3
!    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
!       & call MLSMessage ( MLSMSG_Error, ModuleName,                         &
!       & 'Cannot call the full cloud forward model with multiple signals' )
d266 1
a266 1
!    signal = forwardModelConfig%signals(1)
d269 2
a270 14
     print*,signal%index
    ! -------------------------------------------------------------------------
    ! Make sure all the signals we're dealing with are same module, radiometer 
    ! and sideband. This will be used later in multi signal version
    !--------------------------------------------------------------------------

!    if ( any( forwardModelConfig%signals%sideband .ne. &
!      & signal%sideband ) ) &
!      & call MLSMessage ( MLSMSG_Error, ModuleName, &
!      &  "Can't have mixed sidebands in forward model config")
!    if ( any( forwardModelConfig%signals%radiometer .ne. &
!      & signal%radiometer ) ) &
!      & call MLSMessage ( MLSMSG_Error, ModuleName, &
!      &  "Can't have mixed radiometers in forward model config")
d280 1
a280 1
          & quantityType=l_radiance,                                         &
d283 1
a283 1
          & quantityType=l_cloudInducedRadiance,                             &
d288 1
a288 1
          & quantityType=l_cloudRADSensitivity, noerror=.true.,   &
d293 1
a293 1
          & quantityType=l_effectiveOpticalDepth, noerror=.true.,   &
d303 1
a303 1
        ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,      &
d315 1
a315 1
        sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra, &
d317 1
a317 1
        earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d447 1
a447 1
    ! --------- Loop over sidebands ------------
d512 2
a513 2
!    if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
!           & "No matching antenna patterns." )
d548 37
a587 3
!    print*, ' '
!    print*,'No. of Frequencies:', noFreqs 
!    print*, frequencies/1e3_r8
d626 1
a626 1
!    print*, 'Successfully done with Full Cloud Foward Model ! '
a627 1
!    print*, 'about to deallocate'
d645 1
a645 1
      & cloudInducedRadiance%values ( :, maf ) =                                 &
d655 1
a655 1
      & cloudRADSensitivity%values ( :, maf ) =                                  &
d659 3
a661 3
! -----------------------------------------------------------------------------
! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
! -----------------------------------------------------------------------------
d672 4
a675 9
! ------------------
! output Jacobian
! ------------------

    !---------------------------------------------------------------------
    ! get state quantity type and determine which retrieval is to be used
    !---------------------------------------------------------------------
    l_stateQ_type = fwdModelIn%quantities(1)%template%quantityType
    stateQ => GetVectorQuantityByType (FwdModelIn,quantityType = l_stateQ_type )
d678 1
a678 1
    ! Get some dimensions that are common for both methods
d680 1
a680 1
      noInstances = stateQ%template%noInstances
d685 1
a685 1
    doHighZt = present(jacobian) .and. (l_stateQ_type == l_cloudExtinction)
d687 2
a688 1
    if (doHighZt) then
d691 1
a691 1
      noSurf = stateQ%template%noSurfs
d717 1
a717 1
       phi_fine(i) = minval(stateQ%template%phi(1,:)) + &
d719 1
a719 1
         & (maxval(stateQ%template%phi(1,:)) - minval(stateQ%template%phi(1,:)))
d727 2
a728 2
        dz = abs(stateQ%template%surfs(2,maf)-stateQ%template%surfs(1,maf))
        dphi = abs(stateQ%template%phi(2,maf)-stateQ%template%phi(1,maf))
d750 1
d757 2
a758 2
           if(abs(z_fine(k) - stateQ%template%surfs(j,i)) < dz/2. &
           & .AND. abs(phi_fine(k) - stateQ%template%phi(j,i)) < dphi/2.) &
d779 1
a779 1
    doLowZt = present(jacobian) .and. (l_stateQ_type == l_LosTransFunc)
d781 1
d785 1
a785 1
        noSgrid=stateQ%template%noChans
d824 1
a824 1
                      &     stateQ%template%frequencies,             &
d865 1
a865 1
                      &     stateQ%template%frequencies,             &
d891 5
d899 1
a899 1
    call deallocate_test ( superset, 'superset', ModuleName )
d906 1
a906 1
                          'a_trans',            ModuleName )
d921 2
a922 1
    call Deallocate_test ( doChannel, 'doChannel', ModuleName )
d925 1
a925 1
    !       End of sideband loop 
d929 4
a932 2
!    print*, ' '
!    print*, 'Time Instance: ', instance
d938 1
a938 1
!    print*, 'Successful done with full cloud forward wapper !'
d979 3
a1059 2


@


1.41
log
@clean up input statements
@
text
@d79 1
a79 1
    "$Id: FullCloudForwardModel.f90,v 1.40 2001/10/05 20:26:12 dwu Exp $"
d244 5
a248 3
    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
       & call MLSMessage ( MLSMSG_Error, ModuleName,                         &
       & 'Cannot call the full cloud forward model with multiple signals' )
d254 4
a257 2
    signal = forwardModelConfig%signals(1)

d263 8
a270 8
    if ( any( forwardModelConfig%signals%sideband .ne. &
      & signal%sideband ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed sidebands in forward model config")
    if ( any( forwardModelConfig%signals%radiometer .ne. &
      & signal%radiometer ) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      &  "Can't have mixed radiometers in forward model config")
d285 2
a286 2
          cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          & 
            & quantityType=l_cloudExtinction )
d288 1
a288 1
          & quantityType=l_cloudRADSensitivity,                              &
d291 1
a291 1
          & quantityType=l_totalExtinction )
d293 1
a293 1
          & quantityType=l_effectiveOpticalDepth,                            &
d296 1
a296 1
          & quantityType=l_massMeanDiameterIce )
d298 1
a298 1
          & quantityType=l_massMeanDiameterWater )
d512 2
a513 2
    if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
           & "No matching antenna patterns." )
d515 1
d895 2
d940 3
@


1.40
log
@make sure the model output fields are associated
@
text
@d79 1
a79 1
    "$Id: FullCloudForwardModel.f90,v 1.39 2001/10/04 23:34:19 dwu Exp $"
a271 3
   !-------------------------------------------------------------
    if(dee_bug) then                    ! use jonathan's version
   !-------------------------------------------------------------
d275 1
a275 7

    do quantity_type = 1, fwdModelOut%template%noQuantities
      l_quantity_type = fwdModelOut%quantities(quantity_type)%template%quantityType

      select case (l_quantity_type)
        case (l_radiance) 
          radiance => GetVectorQuantityByType ( fwdModelOut,                 &
d278 1
a278 3
          qgot(1) = .true.
        case (l_cloudInducedRadiance)
          cloudInducedRadiance => GetVectorQuantityByType ( fwdModelOut,     &
a280 2
          qgot(2) = .true.
        case (l_cloudExtinction)
d283 1
a283 3
          qgot(3) = .true.
        case (l_cloudRADSensitivity)
          cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut,      &
d286 1
a286 3
          qgot(4) = .true.
        case (l_totalExtinction)
          totalExtinction => GetVectorQuantityByType ( fwdModelOut,          &
d288 1
a288 3
          qgot(5) = .true.
        case (l_effectiveOpticalDepth)
          effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut,    &
d291 1
a291 3
          qgot(6) = .true.
        case (l_massMeanDiameterIce)
          massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,      &
d293 1
a293 3
          qgot(7) = .true.
        case (l_massMeanDiameterWater)
          massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,    &
a294 11
          qgot(8) = .true.
        case default
          print*, 'l_radiance: ', l_radiance
          print*, 'l_cloudInducedRadiance: ', l_cloudInducedRadiance
          print*, 'l_cloudextinction: ', l_cloudextinction
          print*, 'l_massmeandiameterice: ', l_massmeandiameterice
          print*, 'l_cloudRADSensitivity: ', l_cloudRADSensitivity
          print*, 'l_totalExtinction: ', l_totalExtinction
          print*, 'l_effectiveOpticalDepth: ', l_effectiveOpticalDepth
          print*, 'l_massMeanDiameterWater: ', l_massMeanDiameterWater
          print*, 'l_quantity_type: ', l_quantity_type
a295 4
          call MLSMessage ( MLSMSG_Error, ModuleName,                        &
                            'Did not understand output l_quantity_types')
      end select
    enddo
d299 1
a299 9
    
    NQ2 = fwdModelExtra%template%noQuantities

    do quantity_type = 1, NQ2
      l_quantity_type = fwdModelExtra%quantities(quantity_type)%template%quantityType

      select case (l_quantity_type)
        case (l_ptan)
          ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,      &
d301 1
a301 2
        case (l_temperature)
          temp => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,      &
d303 1
a303 2
        case (l_gph)
          gph => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,       &
d305 1
a305 2
        case (l_cloudIce)
          cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,   &
d307 1
a307 2
        case (l_cloudWater)
          cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d309 1
a309 2
        case (l_surfaceType)
          surfaceType => GetVectorQuantityByType ( fwdModelIn,fwdModelExtra, &
d311 1
a311 2
        case (l_sizeDistribution)
          sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra, &
d313 1
a313 2
        case (l_earthradius)
          earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d315 1
a315 2
	case (l_scGeocAlt)
	  scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d317 1
a317 2
	case (l_elevOffset)
          elevOffset => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
a318 69
        case (l_vmr)
          ! need to do nothing, will be treated below.
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName,                        &
                            'Did not understand Input l_quantity_types')
      end select
    enddo

    ! check Qgot for all outputs
    if ( any( .not. qgot ) ) then
      print*, 'have only some outputs',qgot
      print*, 'Tb, DTcir, Beta, SS, BetaC, TAUeff, Dmi, Dmw'
    endif
   !----------------------------
   ! End of jonathan's version
   !----------------------------

   !-----------------------------------------------------------------
    else                               ! use N. Livesey's version
   !-----------------------------------------------------------------
    ! --------
    ! Outputs:
    ! --------
    radiance => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_radiance, &
      & signal=signal%index, sideband=signal%sideband )
    cloudInducedRadiance => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_radiance, &
      & signal=signal%index, sideband=signal%sideband )
    cloudExtinction => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_cloudExtinction )
    cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_radiance, &
      & signal=signal%index, sideband=signal%sideband )
    totalExtinction => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_totalExtinction )
    effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_radiance, &
      & signal=signal%index, sideband=signal%sideband )
    massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_massMeanDiameterIce )
    massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_massMeanDiameterWater )
    ! -------
    ! Inputs:
    ! -------
    ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, instrumentModule = radiance%template%instrumentModule)
    temp => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra, &
      & quantityType=l_temperature )
    gph => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra, &
      & quantityType=l_gph )
    cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_cloudIce )
    cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_cloudWater )
    surfaceType => GetVectorQuantityByType ( fwdModelIn,fwdModelExtra, &
      & quantityType=l_surfaceType )
    sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra, &
      & quantityType=l_sizeDistribution )
    earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_earthradius ) 
    scGeocAlt => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_scGeocAlt )

    endif
   !-------------------------------
   ! End of N. Livesey's version
   !------------------------------
d321 1
a321 1
    ! Make sure the quantities we have are OK
d324 8
d933 3
@


1.39
log
@*** empty log message ***
@
text
@d79 1
a79 1
    "$Id: FullCloudForwardModel.f90,v 1.38 2001/10/04 16:27:12 jonathan Exp $"
d722 2
a723 1
    cloudInducedRadiance%values ( :, maf ) =                                 &
d727 2
a728 1
    effectiveOpticalDepth%values ( :, maf ) =                                &
d732 2
a733 1
    cloudRADSensitivity%values ( :, maf ) =                                  &
d741 8
a748 9
    cloudExtinction%values(:,instance) =       0.0_r8
    massMeanDiameterIce%values(:,instance) =   0.0_r8
    massMeanDiameterWater%values(:,instance) = 0.0_r8
    totalExtinction%values(:,instance) =       0.0_r8

    cloudExtinction%values ( :, instance )    = a_cloudExtinction(:,1)
    massMeanDiameterIce%values (:,instance)   = a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(:, instance) =  a_massMeanDiameter(2,:)
    totalExtinction%values ( :, instance )    = a_totalExtinction (:,1)
d1049 3
@


1.38
log
@added framework for double sideband calculation, unfinished
@
text
@d79 1
a79 1
    "$Id: FullCloudForwardModel.f90,v 1.37 2001/10/04 00:29:36 dwu Exp $"
d662 3
a664 3
    print*, ' '
    print*,'No. of Frequencies:', noFreqs 
    print*, frequencies/1e3_r8
d703 1
a703 1
    print*, 'Successfully done with Full Cloud Foward Model ! '
d705 1
a705 1
    print*, 'about to deallocate'
d1001 2
a1002 2
    print*, ' '
    print*, 'Time Instance: ', instance
d1006 1
a1006 1
    print*, 'Successful done with full cloud forward wapper !'
d1047 3
@


1.37
log
@fix coljBlock
@
text
@d32 1
d68 3
a70 1
                     & L_SIDEBANDRATIO
d79 1
a79 1
    "$Id: FullCloudForwardModel.f90,v 1.36 2001/10/02 17:08:02 jonathan Exp $"
d117 1
a117 1
    type (VectorValue_T), pointer :: EARTHRADIUS              ! Scalar 
d124 1
a124 3

    type (Signal_T) :: signal                      ! I don't know how to define this!

a126 1

d134 2
a135 2
    integer :: noChans
    integer :: noMIFs
d146 1
a146 1
    integer :: k
d162 2
d174 2
d209 10
d227 3
a229 1
             A_TOTALEXTINCTION, A_TRANS,FREQUENCIES, superset )
d233 3
a235 4
    ! Check the model configuration 
    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
      & call MLSMessage ( MLSMSG_Error, ModuleName,                          &
      & 'Cannot call the full cloud forward model with multiple signals' )
a236 3
    signal = forwardModelConfig%signals(1)

    !Find which maf is called at present
d238 5
a242 1
    !print*, maf
d244 3
a246 23
    ! For the moment make it only single sideband
    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
     & 'Only single sidebands allowed in FullForwardCloudModel for now' )

!j    if ( signal%sideband == 0 ) then
!j      if (.not. associated (sidebandRatio) ) &
!j        & call MLSMessage(MLSMSG_Error,ModuleName, &
!j        & "No sideband ratio supplied")
!j      sidebandStart = -1
!j      sidebandStop = 1
!j      sidebandStep = 2
!j    else
!j      sidebandStart = signal%sideband
!j      sidebandStop = sideBandStart
!j      sidebandStep = 1
!j    endif

!j    sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!j      & quantityType=l_sidebandRatio, signal= signal%index, noError=.true. )

    noFreqs = size (signal%frequencies)
    call Allocate_test ( frequencies, noFreqs,             &
      & 'frequencies', ModuleName )
d248 3
a250 2
    frequencies = signal%lo + signal%sideband * ( signal%centerFrequency +   &
      signal%frequencies)
d252 1
a252 1
    call allocate_test ( doChannel, noFreqs, 'doChannel', ModuleName )
d254 13
a266 3
    doChannel = .true.

    if ( associated ( signal%channels ) ) doChannel = signal%channels
d268 1
d270 1
d272 3
a274 3
!---------------------------------------------------------------------------
   if(dee_bug) then                    ! use jonathan's version
!---------------------------------------------------------------------------
d281 1
a281 2
!      print*,'quantity_type: ', 'outputs', quantity_type
!      print*,'l_quantity_type: ', 'outputs', l_quantity_type
a341 2
!      print*,'quantity_type: ', 'inputs', quantity_type
!      print*,'l_quantity_type: ', 'inputs', l_quantity_type
d375 1
a375 1
!          need to do nothing, will be treated below.
a385 1
!      stop
d387 10
a396 9
!----------------------------
! end of jonathan's version
!---------------------------
!----------------------------------------------------------------------
   else                               ! use N. Livesey's version
!----------------------------------------------------------------------
! --------
! Outputs:
! --------
a437 4
   endif
!-------------------------------
! end of N. Livesey's version
!------------------------------
d439 6
d446 2
d449 2
a450 2
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
      & ModuleName, InvalidQuantity//'temperature' )
d452 2
a453 2
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
      & ModuleName, InvalidQuantity//'temperature' )
d455 2
a456 2
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
      & ModuleName, InvalidQuantity//'ptan' )
d458 1
d460 3
a462 1
    call Allocate_test ( closestInstances, radiance%template%noInstances,    &
d465 1
d467 1
d489 1
a489 1
!      print*, 'i: ', i, 'about to get vmr for molecule of i'
a494 1
!      print*, 'i: ', i, 'got vmr for molecule of i'
d513 1
d515 1
a517 1
    noLayers = temp%template%noSurfs 
d519 55
d575 1
d597 2
a598 2
    call Allocate_test ( a_Trans,                                 &
      & temp%template%noSurfs, noFreqs,                                   &
a600 3
    ! Now call the full CloudForwardModel code

    noSurf=temp%template%noSurfs
d614 1
a614 1
     phi_tan = Deg2Rad * temp%template%phi(1,instance)
d619 4
a622 4
    do j = 1, size(antennaPatterns)
       superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
           & ForwardModelConfig%signals, sideband=signal%sideband , channel=chan )
    end do
d638 27
a664 3
!    print*, ' '
!    print*,'No. of Frequencies:', noFreqs 
!    print*, frequencies/1e3_r8
a703 1
!    stop    !successful !
d708 1
d712 3
d716 1
a716 3

    print*, 'about to assign radiance value'
    print*, 'radiance instance length: ', radiance%template%instanceLen
a721 5
    print*, 'Successfully assigned radiance value!'

    print*, 'about to assign cloud inducedradiance values'
    print*, 'radiance instance length: ', cloudInducedRadiance%template%instanceLen

d734 3
a736 1
!     print*, 'about to zero cloud extinction'   
a737 1
! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
a742 12
!     print*, 'about to assign cloud extinction values'   
!    cloudExtinction%values ( :, instance ) =                        &
!      & reshape ( transpose(a_cloudExtinction),                     &
!      & (/noLayers*noFreqs/) )
!    massMeanDiameterIce%values (:,instance)=                        &
!      & a_massMeanDiameter(1,:)
!    massMeanDiameterWater%values(:, instance)=                      &
!      & a_massMeanDiameter(2,:)
!    totalExtinction%values ( :, instance ) =                        &
!      & reshape ( transpose(a_totalExtinction),                     &
!      &         (/noLayers*noFreqs/) )

d751 4
a754 2
        
! get state quantity type and determine which retrieval is to be used
d757 4
a760 2
! Get some dimensions that are common for both methods
      noMIFs = radiance%template%noSurfs
d763 3
a765 1
! Jacobian for high tangent height retrieval
d769 2
a770 1
    ! Get some dimensions
d787 5
a791 1
! we use 100 times better resolution to compute weighting functions
d803 2
d806 1
d809 2
d812 1
d818 2
d821 1
d825 2
d828 1
d830 1
d832 3
a834 2
         do i = 1,noInstances  ! loop over profile
         do j = 1,noSurf       ! loop over surface
d855 3
a857 1
! Jacobian for low tangent height retrieval
d861 2
a862 3

    ! Get some dimensions
        noChans = radiance%template%noChans
d872 1
d874 5
a878 5
! In the absent case, the jacobian is stored in a special format
!  
!
!
!
d885 4
a888 3
       ! Now fill the jacobian
            
          do chan = 1, noChans
d890 1
d893 1
a893 1
                    
d911 2
a912 2
         end if
         end do
d914 1
a914 1
         Deallocate(TransOnS,stat=status)
d916 1
a916 1
        case ( M_Banded )
d926 4
a929 3
       ! Now fill the jacobian
            
          do chan = 1, noChans
d931 1
d934 1
a934 1
                    
d967 1
a967 2
      endif

d969 1
d971 1
a971 1

d995 6
d1004 2
a1005 1
!    if ( maf == radiance%template%noInstances ) fmStat%finished = .true.
d1047 3
d1113 2
@


1.36
log
@some adjustment due to construction
@
text
@d76 1
a76 1
    "$Id: FullCloudForwardModel.f90,v 1.35 2001/10/02 16:27:36 livesey Exp $"
d269 1
d762 1
a764 5
        colJBlock = 0
        do while (colJBlock <= jacobian%col%nb .and. &
           jacobian%col%inst(colJBlock) /= maf)
           colJBlock = colJBlock +1 
        end do
a767 1

d932 3
@


1.35
log
@Removed reference to fmStat%finished
@
text
@d76 1
a76 1
    "$Id: FullCloudForwardModel.f90,v 1.34 2001/10/01 23:40:26 jonathan Exp $"
d198 1
a198 1
    logical :: DoHighZt                    ! Flag
d203 1
a203 1
    logical :: FOUNDINFIRST                     ! Flag to indicate derivatives
d218 3
a220 3
!j    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
!j      & call MLSMessage ( MLSMSG_Error, ModuleName,                          &
!j      & 'Cannot call the full cloud forward model with multiple signals' )
d228 16
a243 16
!j    ! For the moment make it only single sideband
!j    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
!j     & 'Only single sidebands allowed in FullForwardCloudModel for now' )

    if ( signal%sideband == 0 ) then
      if (.not. associated (sidebandRatio) ) &
        & call MLSMessage(MLSMSG_Error,ModuleName, &
        & "No sideband ratio supplied")
      sidebandStart = -1
      sidebandStop = 1
      sidebandStep = 2
    else
      sidebandStart = signal%sideband
      sidebandStop = sideBandStart
      sidebandStep = 1
    endif
d245 2
a246 2
    sidebandRatio => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sidebandRatio, signal= signal%index, noError=.true. )
a260 22
    call allocate_test ( superset, size(antennaPatterns), &
         & 'superset', ModuleName )

    do j = 1, size(antennaPatterns)
       superset(j) = AreSignalsSuperset ( antennaPatterns(j)%signals, &
           & ForwardModelConfig%signals, sideband=signal%sideband , channel=chan )
    end do

    if ( all( superset < 0 ) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
           & "No matching antenna patterns." )

    maxSuperset = maxval ( superset )
    where ( superset < 0 )
          superset = maxSuperset + 1
    end where
    whichPatternAsArray = minloc ( superset )
    whichPattern = whichPatternAsArray(1)
    if ( toggle(emit) .and. levels(emit) > 2 ) then
       call output ( 'Using antenna pattern: ' )
       call output ( whichPattern, advance='yes' )
    end if

d547 22
a892 2
!    print*, 'Successful done with full cloud forward wapper !'
!    stop
d894 1
a930 1

d936 3
@


1.34
log
@construct codes for double sideband
@
text
@d76 1
a76 1
    "$Id: FullCloudForwardModel.f90,v 1.33 2001/09/28 21:45:50 dwu Exp $"
a895 1
    if ( maf == radiance%template%noInstances ) fmStat%finished = .true.
d938 3
@


1.33
log
@modify low cloud Jacobian output format
@
text
@d66 2
a67 1
		     & L_ELEVOFFSET
d76 1
a76 1
    "$Id: FullCloudForwardModel.f90,v 1.32 2001/09/28 15:54:39 jonathan Exp $"
d127 2
d157 6
a162 1
    
d182 2
d218 4
a221 3
    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
      & call MLSMessage ( MLSMSG_Error, ModuleName,                          &
      & 'Cannot call the full cloud forward model with multiple signals' )
d223 2
a224 1
!  find which maf is called at present
d226 21
a246 1
!    print*, maf
a247 1
    ! For the moment make it only single sideband
a248 2
    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
      & 'Only single sidebands allowed in FullForwardCloudModel for now' )
a251 3
!    frequencies = signal%lo + signal%sideband * ( signal%centerFrequency +   &
!      & pack ( signal%frequencies, signal%channels ) )

d256 1
d258 1
a935 1
                    
d939 3
@


1.32
log
@minor
@
text
@d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.31 2001/09/26 19:17:02 dwu Exp $"
d746 7
a752 2
        call CreateBlock ( jBlock, noChans*noMIFs, &
            & noSgrid*noMIFs*noInstances, M_Full )
d777 2
a778 2
                     jBlock%values(chan+(mif-1)*noChans, & 
                       & i+(mif-1)*noSgrid+(maf-1)*noInstances)= TransOnS(i,mif)
d784 1
a784 1
              Deallocate(TransOnS,stat=status)
d912 3
@


1.31
log
@normalize weights for high tangent retrieval
@
text
@d65 2
a66 2
   		            & L_SCGEOCALT,                                          &
		               & L_ELEVOFFSET
d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.30 2001/09/24 23:16:40 dwu Exp $"
d279 1
a279 1
          cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          &             
d805 1
a805 1
                      &     a_trans(:,chan),               &
d841 1
a841 1
    call Deallocate_test ( a_trans,                                &
d907 3
@


1.30
log
@add derivatives for high tangent height retrievals
@
text
@d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.29 2001/09/24 23:12:53 dwu Exp $"
d177 1
d699 2
d708 1
a708 1
           & jBlock%values(mif,j+(i-1)*noInstances) + ds_fine(k)
d907 3
@


1.29
log
@add derivatives for high tangent height retrievals
@
text
@d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.28 2001/09/21 15:51:37 jonathan Exp $"
d694 1
a694 1
        ! fine ds for each (z,phi) pair
d701 1
a701 1
         do k = 1, nfine*noInstances
d904 3
@


1.28
log
@modified F95 version
@
text
@d32 1
a32 1
  use Units, only: Deg2Rad
d65 2
a66 2
		     & L_SCGEOCALT,                                          &
		     & L_ELEVOFFSET
d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.27 2001/09/19 16:46:22 dwu Exp $"
d130 1
a130 1
    integer :: INSTANCELEN              ! For the state quantity
d133 7
a139 1
    integer :: noSgrid
a140 1

d143 1
a144 2
    integer :: NQ1
    integer :: NQ2
d146 1
a146 1
    integer :: MAF                      ! The major frame 
d151 1
a151 3
    integer :: NOFREQS                  ! Number of frequencies
    integer :: noSurf                   ! Number of pressure levels
    integer :: noNonZero                ! Number of nonzero values in Jacobian
d156 1
d174 4
d183 2
d187 2
a188 1
    logical :: DODERIVATIVES                    ! Flag
d211 1
a320 5
    l_quantity_type = fwdModelIn%quantities(1)%template%quantityType

        stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
                  & quantityType = l_LosTransFunc )
!                  & foundInFirst = foundInFirst, noError=.true. )
d618 1
a618 1
 ! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
d644 76
a719 2
    doDerivatives = present(jacobian) .and. &
      (fwdModelIn%quantities(1)%template%quantityType == l_LosTransFunc)
d721 2
a722 1
    if (doDerivatives) then
d724 1
a724 1
    ! Set some dimensions
d726 1
a727 1
        noMIFs = radiance%template%noSurfs
a739 1
        instanceLen = noSurf*noMIFs
d743 2
a744 3
        call CreateBlock ( jBlock, &
                         & noChans*noMIFs, noSgrid*noMIFs, &
                         & M_Full )
d769 2
a770 2
                     jBlock%values(chan+(mif-1)*noChans,i+(mif-1)*noSgrid) &
                       & = TransOnS(i,mif)
d780 1
a780 1
        noNonZero = noSgrid*noMIFs
d782 2
a783 2
        call CreateBlock ( jBlock, &
                         & noChans*noMIFs, noSgrid*noMIFs, &
d812 2
a813 1
            jBlock%r2(i+(mif-1)*noSgrid) = noChans*(i+(mif-1)*noSgrid)
d904 3
@


1.27
log
@some minor
@
text
@d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.26 2001/09/19 00:25:59 dwu Exp $"
d824 3
a859 4




@


1.26
log
@add M_banded to Jacobian
@
text
@d16 1
d75 1
a75 1
    "$Id: FullCloudForwardModel.f90,v 1.25 2001/09/04 15:59:44 jonathan Exp $"
d824 3
@


1.25
log
@add cloud_fov, jonathan
@
text
@d74 1
a74 1
    "$Id: FullCloudForwardModel.f90,v 1.24 2001/08/17 21:48:41 jonathan Exp $"
d148 1
d698 38
d737 8
a744 5
              case ( M_Banded, M_Column_Sparse )
                call MLSMessage( MLSMSG_Error, ModuleName, &
                  & "Not written code for adding to non full blocks" )
              case default
              end select
d823 3
@


1.24
log
@Added FOV average, Jonathan
@
text
@d74 1
a74 1
    "$Id: FullCloudForwardModel.f90,v 1.23 2001/08/07 17:17:50 jonathan Exp $"
d555 1
d781 3
@


1.23
log
@add radiance%template%instrumentModule to ptan
@
text
@d9 3
a11 1
! Jonathan Jiang, Paul Wagner, Jul 16, 2001 
d15 3
a17 2
  use Hdf,      only: DFACC_READ, DFACC_CREATE
  use HDFEOS,   only: SWOPEN,     SWCLOSE
d21 1
a21 1
  use MLSSignals_m, only: SIGNAL_T
d28 4
d63 3
a65 1
                     & L_LOSTRANSFUNC
d74 1
a74 1
    "$Id: FullCloudForwardModel.f90,v 1.22 2001/08/02 01:03:16 dwu Exp $"
d117 2
d120 1
a120 1
    type (Signal_T) :: signal               ! I don't know how to define this!
d122 2
a123 2
    type(MatrixElement_T), pointer :: JBLOCK     ! A block from the jacobian
    type(VectorValue_T), pointer :: STATEQ ! A state vector quantity
d136 1
d155 5
a169 1

a171 1

d173 1
d190 1
a190 1
             A_TOTALEXTINCTION, A_TRANS,FREQUENCIES )
d208 1
d211 1
d219 22
d346 6
d414 2
a415 1

d530 2
d555 4
d561 1
a561 1
      & a_trans,                                                   &
a585 1
!   the following will cause error if only 1 channel is specified
a590 1
!    stop  ! successful!
d607 1
a607 2
     print*, 'about to zero cloud extinction'   
!     stop
a615 2
!     stop

d707 3
d731 2
a732 2
!    print*, ' '
!    print*, 'Time Instance: ', instance
d737 1
d780 3
@


1.22
log
@add doChannel to frequency loop
@
text
@d65 1
a65 1
    "$Id: FullCloudForwardModel.f90,v 1.21 2001/08/01 20:51:30 dwu Exp $"
d187 1
d190 1
a190 1
    call Allocate_test ( frequencies, count ( signal%channels ),             &
a195 1
    noFreqs = size (frequencies)
d225 2
a226 1
          cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          &             & quantityType=l_cloudExtinction )
d284 1
a284 2
          & quantityType=l_ptan,radiometer=signal%radiometer)
        
d728 3
@


1.21
log
@add delTau100
@
text
@d65 1
a65 1
    "$Id: FullCloudForwardModel.f90,v 1.20 2001/08/01 17:24:29 jonathan Exp $"
d159 1
d175 3
a177 1

d191 2
d194 1
a194 1
      & pack ( signal%frequencies, signal%channels ) )
d197 4
d225 1
a225 2
          cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          &
          & quantityType=l_cloudExtinction )
d283 1
a283 1
          & quantityType=l_ptan, instrumentModule = radiance%template%instrumentModule)
d487 1
a487 1
    call CloudForwardModel (                                                 &
d502 1
a502 1
      & earthradius%values(1,1),                                             &
d622 1
d628 1
a628 1
                      &     earthradius%values(1,maf)*1.e-3_r8,               &
d643 1
d679 1
d728 3
@


1.20
log
@updated version
@
text
@d65 1
a65 1
    "$Id: FullCloudForwardModel.f90,v 1.19 2001/08/01 00:20:22 dwu Exp $"
d181 1
a181 1
    print*, maf
d403 1
a403 1
      print*, 'i: ', i, 'about to get vmr for molecule of i'
d409 1
a409 1
      print*, 'i: ', i, 'got vmr for molecule of i'
a448 1

d455 3
d475 2
a476 2
    print*, ' '
    print*,'No. of Frequencies:', noFreqs 
d500 1
d588 1
a588 1
        noSgrid=stateQ%template%nosurfs
d597 1
a597 1
!       colJBlock = FindBlock ( jacobian%col, stateQ%index, maf)
d609 1
a609 2
!        allocate(TransOnS,noSgrid,noMIFs,stat=status)     !this is wrond
         allocate( TransOnS(noSgrid, noMIFs), stat=status )
d619 1
a619 1
                      &     earthradius%values(1,maf),               &
d621 1
a621 1
                      &     gph%template%noSurfs,                    &
d624 1
a624 1
                      &     a_totalExtinction(:,chan),               &
d628 1
a628 1
            do mif = 1, noMIFs
d634 3
a636 2
                  end do
               Deallocate(TransOnS,stat=status)
d653 2
d669 3
a671 3
    print*, ' '
    print*, 'Time Instance: ', instance
    print*, 'Successful done with full cloud forward wapper !'
d699 1
a699 1

a709 1
    enddo
d711 3
d717 3
@


1.19
log
@add Jacobian -Jonathan/Wu
@
text
@d20 1
a20 1
        & M_COLUMN_SPARSE, CREATEBLOCK, M_FULL
a57 1

d63 1
a63 1
  !---------------------------- RCS Ident Info -------------------------------
d65 1
a65 1
    "$Id: FullCloudForwardModel.f90,v 1.17 2001/07/27 22:12:13 jonathan Exp $"
d69 1
a69 1
  !---------------------------------------------------------------------------
d71 1
a71 1
  ! Local parameters ---------------------------------------------------------
d150 1
a150 1
    real(r8), dimension(:,:), pointer :: VMRARRAY               ! The vmr's
d159 1
a159 1
    logical :: DODERIVATIVES            ! Flag
d168 1
a168 1
             RADIANCE, SIZEDISTRIBUTION, EARTHRADIUS, SURFACETYPE,         &
d197 3
a199 2
    ! Outputs
    ! -------
d256 4
d261 4
a264 3
    ! Inputs
    ! ------
    NQ1 = fwdModelIn%template%noQuantities
d266 1
a266 2
     if (quantity_type .le. NQ1) &
      l_quantity_type = fwdModelIn%quantities(quantity_type)%template%quantityType
d276 1
a276 1

d312 3
a314 1

d318 3
a320 3

! Outputs
! -------
d341 2
a342 2

    ! Inputs
a559 1

a563 1

d573 3
a575 2
!output Jacobian

d583 3
a585 7
            stateQ => GetVectorQuantityByType ( FwdModelIn, FwdModelExtra,&
              & quantityType = l_LosTransFunc, &
              & foundInFirst = foundInFirst, noError=.true. )

    noChans = radiance%template%noChans
    noMIFs = radiance%template%noSurfs
    noSgrid=stateQ%template%nosurfs
d588 17
a604 19
            fmStat%rows(rowJBlock) = .true.
            colJBlock = 0
            do while (colJBlock <= jacobian%col%nb .and. &
              jacobian%col%inst(colJBlock) /= maf)
              colJBlock = colJBlock +1 
            end do
!            colJBlock = FindBlock ( jacobian%col, stateQ%index, maf)
            jBlock => jacobian%block(rowJblock,colJblock)

            instanceLen = noSurf*noMIFs

              select case ( jBlock%kind )
              case ( M_Absent )
                call CreateBlock ( jBlock, &
                  & noChans*noMIFs, noSgrid*noMIFs, &
                  & M_Full )
                jBlock%values = 0.0_r8

!               allocate(TransOnS,noSgrid,noMIFs,stat=status)     !this is wrond
d606 2
a607 1
                allocate( TransOnS(noSgrid, noMIFs), stat=status )
d609 1
a609 1
              ! Now fill the jacobian
d611 3
a613 3
                  do chan = 1, noChans
                    ! now, we define beta as transmission function in Sensitivity.f90
                    ! and we interpolate it onto Sgrid
d615 1
a615 1
                    call FindTransForSgrid (                         &
d626 1
a626 1
                    do mif = 1, noMIFs
d710 3
@


1.18
log
@sorry
@
text
@d19 3
a21 1
  use MatrixModule_1, only: MATRIX_T
d53 1
a53 1
                     & L_EARTHRADIUS,                                      &
d55 3
a57 1
                     & L_CLOUDWATER 
d112 12
d129 1
d136 1
a136 1
    integer :: NOsurf                   ! Number of pressure levels
d153 1
d158 3
d164 1
d174 1
a174 1
             A_TOTALEXTINCTION, FREQUENCIES )
d261 1
a261 2
    do quantity_type = 1, NQ1+NQ2
      if (quantity_type .le. NQ1) &
d263 2
a264 2
      if (quantity_type .gt. NQ1) &
      l_quantity_type = fwdModelExtra%quantities(quantity_type-NQ1)%template%quantityType
d443 1
d453 2
a454 2
    NOsurf=temp%template%noSurfs
    if (Nosurf /= GPH%template%nosurfs) then
a466 10
!    print*, noFreqs, noSurf, radiance%template%noSurfs, 
!    print*, size( ForwardModelConfig%molecules)
!    print*, 10.0**(-temp%template%surfs)
!    print*,int(sizeDistribution%values(1,instance))
!     print*,ForwardModelConfig%no_model_surfs
!    print*, 10.0**(-ptan%values(:,maf))
!    print*, gph%values(:, instance)
!     print*, temp%values(:,instance)
!    stop

a469 1
!    stop
a501 9
!    print*, a_clearskyradiance
!    print*, 'a_cloudinducedradiance'
!    print*, a_cloudinducedradiance

!    print*, a_totalExtinction

!    print*, size(a_totalExtinction)
!    stop

a504 3
!    read *, reply
!    if (reply(1:1) /= 'o') stop

a550 16

    cloudExtinction%values ( :, instance ) =                        &
      & reshape ( transpose(a_cloudExtinction),                     &
      & (/noLayers*noFreqs/) )

    massMeanDiameterIce%values (:,instance)=                        &
      &                                  a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(:, instance)=                      &
      &                                  a_massMeanDiameter(2,:)

    totalExtinction%values ( :, instance ) =                        &
      & reshape ( transpose(a_totalExtinction),                     &
      &         (/noLayers*noFreqs/) )



d564 79
a642 5
    cloudExtinction%values ( :, instance ) = a_cloudExtinction(:,1)
    massMeanDiameterIce%values (:,instance)= a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(:, instance)=  a_massMeanDiameter(2,:)
    totalExtinction%values ( :, instance ) = a_totalExtinction (:,1)

a644 2
! stop

d675 34
a708 1
!
@


1.17
log
@fixed bug in output extinction
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.16 2001/07/27 20:26:24 jonathan Exp $"
d552 16
d622 3
@


1.16
log
@jonathan
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.15 2001/07/27 15:17:58 jonathan Exp $"
d404 1
a404 1
    noLayers = temp%template%noSurfs - 1
d497 2
d552 19
a570 9
    cloudExtinction%values ( 1:noLayers, instance ) =                        &
      & reshape ( transpose(a_cloudExtinction), (/noLayers*noFreqs/) )
    massMeanDiameterIce%values (1:noLayers,instance)=                        &
      &                                  a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(1:noLayers,instance)=                       &
      &                                  a_massMeanDiameter(2,:)
    totalExtinction%values ( 1:noLayers, instance ) =                        &
      & reshape ( transpose(a_totalExtinction),                              &
      &         (/noLayers*noFreqs/) )
a603 1

d606 3
d612 4
@


1.15
log
@First Successful f90 runs
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.12 2001/07/25 18:00:29 jonathan Exp $"
d452 1
a452 1
     print*, temp%values(:,instance)
d457 2
d476 1
a476 1
      & int(surfaceType%values(1, instance)),                                     &
d495 3
d550 9
a558 9
!    cloudExtinction%values ( 1:noLayers, instance ) =                        &
!      & reshape ( transpose(a_cloudExtinction), (/noLayers*noFreqs/) )
!    massMeanDiameterIce%values (1:noLayers,instance)=                        &
!      &                                  a_massMeanDiameter(1,:)
!    massMeanDiameterWater%values(1:noLayers,instance)=                       &
!      &                                  a_massMeanDiameter(2,:)
!    totalExtinction%values ( 1:noLayers, instance ) =                        &
!      & reshape ( transpose(a_totalExtinction),                              &
!      &         (/noLayers*noFreqs/) )
d595 3
@


1.14
log
@Simplified the selection of vector components.
@
text
@d7 4
a10 4
  ! -------------------------------------------------------------------------
  ! THIS MODULE CONTAINS THE FULL CLOUD FORWARD MODEL  
  ! Jonathan Jiang, Paul Wagner, Jul 16, 2001 
  ! -------------------------------------------------------------------------
d23 7
a29 7
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE, &
    & VECTOR_T, VECTORVALUE_T, &
    & VALIDATEVECTORQUANTITY

  ! -----------------------------------------------------------------------
  ! THE FOLLOWING IS MODIFICATIONS FOR THE CLOUD FORWARD MODEL PARAMETERS
  ! -----------------------------------------------------------------------
d32 2
a33 2
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, &
    & FORWARDMODELSTATUS_T
d35 19
a53 19
  ! ----------------------------------------------------------
  ! DEFINE INTRINSIC CONSTANTS NEEDED BY Init_Tables_Module
  ! I'm not sure anything else is needed !
  ! ----------------------------------------------------------

  use Intrinsic, only: L_TEMPERATURE,L_PTAN,L_VMR,L_GPH,L_RADIANCE,L_NONE, &
    & L_CLOUDINDUCEDRADIANCE, &
    & L_EFFECTIVEOPTICALDEPTH, &
    & L_CLOUDRADSENSITIVITY, &
    & L_TOTALEXTINCTION, &
    & L_CLOUDEXTINCTION, &
    & L_MASSMEANDIAMETERICE, & 
    & L_MASSMEANDIAMETERWATER, &
    & L_SURFACETYPE, &
    & L_SIZEDISTRIBUTION, &
    & L_TNGTGEOCALT, &
    & L_EARTHRADIUS, &
    & L_CLOUDICE, &
    & L_CLOUDWATER 
d61 2
a62 2
  character (len=*), private, parameter :: IdParm = &
    "$Id: FullCloudForwardModel.f90,v 1.13 2001/07/25 23:44:00 jonathan Exp $"
d64 1
a64 1
  character (len=*), private, parameter :: ModuleName= &
d72 1
a72 1
  ! ---------------------------------------------------------------------
d74 5
a78 5
  ! CLOUD FORWARD MODEL
  ! ---------------------------------------------------------------------
  subroutine FullCloudForwardModelWrapper ( ForwardModelConfig, FwdModelIn, &
    FwdModelExtra, FwdModelOut, Ifm, &
    fmStat, Jacobian                 )  
a107 1
    real(r8), dimension(:,:), pointer :: VMRARRAY               ! The vmr's
d122 1
a122 1

d134 2
d141 2
d144 9
a152 9
    nullify( CLOUDICE, CLOUDWATER, CLOUDEXTINCTION, CLOUDINDUCEDRADIANCE, &
      CLOUDRADSENSITIVITY, EFFECTIVEOPTICALDEPTH, GPH, &
      MASSMEANDIAMETERICE, MASSMEANDIAMETERWATER, PTAN, &
      RADIANCE, SIZEDISTRIBUTION, EARTHRADIUS, SURFACETYPE, &
      TEMP, TOTALEXTINCTION, VMR, VMRARRAY,closestInstances, &
      A_CLEARSKYRADIANCE, A_CLOUDINDUCEDRADIANCE, &
      A_CLOUDEXTINCTION, A_CLOUDRADSENSITIVITY, &
      A_EFFECTIVEOPTICALDEPTH, A_MASSMEANDIAMETER, &
      A_TOTALEXTINCTION, FREQUENCIES )
d155 2
a156 2
    if ( size ( forwardModelConfig%signals ) /= 1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d160 1
d163 1
a163 1
    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d165 1
a165 1
    call Allocate_test ( frequencies, count ( signal%channels ), &
d167 1
a167 1
    frequencies = signal%lo + signal%sideband * ( signal%centerFrequency + &
d172 122
a314 2
    !-------------------------------------------------------------------

d316 1
d334 5
d341 1
a341 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d343 2
a344 2
    if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d346 2
a347 2
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d351 1
a351 1
    call Allocate_test ( closestInstances, radiance%template%noInstances, &
d359 2
a360 2
    call allocate_test ( vmrArray, &
      & size(forwardModelConfig%molecules), temp%template%noSurfs, &
d366 6
a371 6
      case(L_H2O)
        ivmr=1
      case(L_O3)
        ivmr=2
      case default
        ivmr=0
d377 1
a377 1
      vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d380 1
a380 1
        & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d397 2
a398 2
      call MLSMessage( MLSMSG_Error, ModuleName, &
        'Missing the required molecules' )
d407 2
a408 2
    call Allocate_test ( a_clearSkyRadiance, &
      & radiance%template%noSurfs, noFreqs, &
d410 2
a411 2
    call Allocate_test ( a_cloudInducedRadiance, &
      & radiance%template%noSurfs, noFreqs, &
d413 2
a414 2
    call Allocate_test ( a_effectiveOpticalDepth, &
      & radiance%template%noSurfs, noFreqs, &
d416 2
a417 2
    call Allocate_test ( a_cloudRADSensitivity, &
      & radiance%template%noSurfs, noFreqs, &
d419 2
a420 2
    call Allocate_test ( a_totalExtinction, &
      & temp%template%noSurfs, noFreqs, &
d422 2
a423 2
    call Allocate_test ( a_cloudExtinction, &
      & temp%template%noSurfs, noFreqs, &
d425 2
a426 2
    call Allocate_test ( a_massMeanDiameter, &
      & 2, temp%template%noSurfs, &
d428 1
a428 1

d433 4
a436 4
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & 'number of levels in gph does not match no of levels in temp' )
    else if (radiance%template%nosurfs /= ptan%template%nosurfs) then
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d445 42
a486 38
    !    print*, noFreqs, noSurf, radiance%template%noSurfs, 
    !    print*, size( ForwardModelConfig%molecules)
    !    print*, 10.0**(-temp%template%surfs)
    !    print*,int(sizeDistribution%values(1,instance))
    !     print*,ForwardModelConfig%no_model_surfs
    !    print*, real(10.0**(-ptan%values(:,maf)))
    !    print*,real(gph%values(:, instance))
    !    stop

    call CloudForwardModel ( &
      & noFreqs, &
      & noSurf, & 
      & radiance%template%noSurfs, &
      & size(ForwardModelConfig%molecules), &
      & ForwardModelConfig%no_cloud_species, &
      & ForwardModelConfig%no_model_surfs, &
      & frequencies/1e3_r8, &
      & 10.0**(-temp%template%surfs), &
      & gph%values(:, instance), &
      & temp%values(:,instance), &
      & vmrArray, &
      & WC, &
      & sizeDistribution%values(:,instance), &
      & 10.0**(-ptan%values(:,maf)), &
      & earthradius%values(1,1), &
      & surfaceType%values(1, instance), &
      & forwardModelConfig%cloud_der, &
      & forwardModelConfig%cloud_width, &
      & a_clearSkyRadiance, &
      & a_cloudInducedRadiance, &
      & a_totalExtinction, &
      & a_cloudExtinction, &
      & a_massMeanDiameter, &
      & a_effectiveOpticalDepth, &
      & a_cloudRADSensitivity, &
      & forwardModelConfig%NUM_SCATTERING_ANGLES, &  
      & forwardModelConfig%NUM_AZIMUTH_ANGLES, &
      & forwardModelConfig%NUM_AB_TERMS, &
d489 10
a498 4
    !    stop
    print*, 'done with call to cloudfwm'
    !    read *, reply
    !    if (reply(1:1) /= 'o') stop
a499 1

d501 1
a501 1

d508 5
a512 3
    !!    print*, 'radiance instance length: ', radiance%template%instanceLen
    radiance%values ( :, maf) = &
      & reshape ( transpose(a_clearSkyRadiance), &
a513 8
    !    stop
    print*, 'about to assign radiance values'
    !!    print*, 'cloudinducedradiance instance length: ', cloudInducedRadiance%template%instanceLen
    !    stop
    cloudInducedRadiance%values ( :, maf ) = &
      & reshape ( transpose(a_cloudInducedRadiance), &
      & (/radiance%template%instanceLen/) )
    stop
d515 17
a531 6
    effectiveOpticalDepth%values ( :, maf ) = &
      & reshape ( transpose(a_effectiveOpticalDepth), &
      & (/radiance%template%instanceLen/) )
    cloudRADSensitivity%values ( :, maf ) = &
      & reshape ( transpose(a_cloudRADSensitivity), &
      & (/radiance%template%instanceLen/) )
d533 2
a534 2
    !     print*, 'about to zero cloud extinction'   
    !     stop
d536 1
a536 1
    ! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
d542 2
a543 2
    !     print*, 'about to assign cloud extinction values'   
    !     stop
d545 9
a553 9
    cloudExtinction%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_cloudExtinction), (/noLayers*noFreqs/) )
    massMeanDiameterIce%values (1:noLayers,instance)= &
      &                                  a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(1:noLayers,instance)= &
      &                                  a_massMeanDiameter(2,:)
    totalExtinction%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_totalExtinction), &
      &         (/noLayers*noFreqs/) )
d555 1
a555 1
    ! stop
d558 24
a581 18
    call Deallocate_test ( a_massMeanDiameter, &
      'a_massMeanDiameterModuleName', ModuleName )
    call Deallocate_test ( a_cloudExtinction, &
      'a_cloudExtinction',            ModuleName )
    call Deallocate_test ( a_totalExtinction, &
      'a_totalExtinction',            ModuleName )
    call Deallocate_test ( a_cloudRADSensitivity, &
      'a_cloudRADSensitivity',        ModuleName )
    call Deallocate_test ( a_effectiveOpticalDepth, &
      'a_effectiveOpticalDepth',      ModuleName )
    call Deallocate_test ( a_cloudInducedRadiance, &
      'a_cloudInducedRadiance',       ModuleName )
    call Deallocate_test ( a_clearSkyRadiance, &
      'a_clearSkyRadiance',           ModuleName )
    call Deallocate_test ( vmrArray, &
      'vmrArray',                     ModuleName )
    call Deallocate_test ( closestInstances, &
      'closestInstances',             ModuleName )
a582 2
    print*, 'done with full cloud forward wapper'
    !    stop
d588 2
@


1.13
log
@new f90 version of cloudfwm, jonathan
@
text
@d7 4
a10 4
! -------------------------------------------------------------------------
! THIS MODULE CONTAINS THE FULL CLOUD FORWARD MODEL  
! Jonathan Jiang, Paul Wagner, Jul 16, 2001 
! -------------------------------------------------------------------------
d23 7
a29 7
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE,                          &
                         & VECTOR_T, VECTORVALUE_T,                          &
                         & VALIDATEVECTORQUANTITY
  
! -----------------------------------------------------------------------
! THE FOLLOWING IS MODIFICATIONS FOR THE CLOUD FORWARD MODEL PARAMETERS
! -----------------------------------------------------------------------
d32 2
a33 2
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T,            &
                                    & FORWARDMODELSTATUS_T
d35 19
a53 19
! ----------------------------------------------------------
! DEFINE INTRINSIC CONSTANTS NEEDED BY Init_Tables_Module
! I'm not sure anything else is needed !
! ----------------------------------------------------------

  use Intrinsic, only: L_TEMPERATURE,L_PTAN,L_VMR,L_GPH,L_RADIANCE,L_NONE,   &
                     & L_CLOUDINDUCEDRADIANCE,                               &
                     & L_EFFECTIVEOPTICALDEPTH,                              &
                     & L_CLOUDRADSENSITIVITY,                                &
                     & L_TOTALEXTINCTION,                                    &
                     & L_CLOUDEXTINCTION,                                    &
                     & L_MASSMEANDIAMETERICE,                                & 
                     & L_MASSMEANDIAMETERWATER,                              &
                     & L_SURFACETYPE,                                        &
                     & L_SIZEDISTRIBUTION,                                   &
                     & L_TNGTGEOCALT,                                        &
                     & L_EARTHRADIUS,                                      &
                     & L_CLOUDICE,                                           &
                     & L_CLOUDWATER 
d61 2
a62 2
  character (len=*), private, parameter :: IdParm =                          &
    "$Id: FullCloudForwardModel.f90,v 1.12 2001/07/25 18:00:29 jonathan Exp $"
d64 1
a64 1
  character (len=*), private, parameter :: ModuleName=                       &
d72 1
a72 1
         ! ---------------------------------------------------------------------
d74 5
a78 5
         ! CLOUD FORWARD MODEL
         ! ---------------------------------------------------------------------
  subroutine FullCloudForwardModelWrapper ( ForwardModelConfig, FwdModelIn,  &
                                            FwdModelExtra, FwdModelOut, Ifm, &
                                            fmStat, Jacobian                 )  
d123 1
a123 1
    
d141 9
a149 9
    nullify( CLOUDICE, CLOUDWATER, CLOUDEXTINCTION, CLOUDINDUCEDRADIANCE,    &
             CLOUDRADSENSITIVITY, EFFECTIVEOPTICALDEPTH, GPH,                &
             MASSMEANDIAMETERICE, MASSMEANDIAMETERWATER, PTAN,               &
             RADIANCE, SIZEDISTRIBUTION, EARTHRADIUS, SURFACETYPE,         &
             TEMP, TOTALEXTINCTION, VMR, VMRARRAY,closestInstances,          &
             A_CLEARSKYRADIANCE, A_CLOUDINDUCEDRADIANCE,                     &
             A_CLOUDEXTINCTION, A_CLOUDRADSENSITIVITY,                       &
             A_EFFECTIVEOPTICALDEPTH, A_MASSMEANDIAMETER,                    &
             A_TOTALEXTINCTION, FREQUENCIES )
d152 2
a153 2
    if ( size ( forwardModelConfig%signals ) /= 1 )                          &
      & call MLSMessage ( MLSMSG_Error, ModuleName,                          &
d159 1
a159 1
    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName,  &
d161 1
a161 1
    call Allocate_test ( frequencies, count ( signal%channels ),             &
d163 1
a163 1
    frequencies = signal%lo + signal%sideband * ( signal%centerFrequency +   &
d168 20
d189 1
a189 51
    ! Outputs
    do quantity_type = 1, fwdModelOut%template%noQuantities
      l_quantity_type = fwdModelOut%quantities(quantity_type)%template%quantityType
!      print*,'quantity_type: ', 'outputs', quantity_type
!      print*,'l_quantity_type: ', 'outputs', l_quantity_type
      select case (l_quantity_type)
        case (l_radiance) 
          radiance => GetVectorQuantityByType ( fwdModelOut,                 &
          & quantityType=l_radiance,                                         &
          & signal=signal%index, sideband=signal%sideband )
        case (l_cloudInducedRadiance)
          cloudInducedRadiance => GetVectorQuantityByType ( fwdModelOut,     &
          & quantityType=l_radiance,                             &
          & signal=signal%index, sideband=signal%sideband )
        case (l_cloudExtinction)
          cloudExtinction => GetVectorQuantityByType ( fwdModelOut,          &
          & quantityType=l_cloudExtinction )
        case (l_cloudRADSensitivity)
          cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut,      &
          & quantityType=l_radiance,                              &
          & signal=signal%index, sideband=signal%sideband )
        case (l_totalExtinction)
          totalExtinction => GetVectorQuantityByType ( fwdModelOut,          &
          & quantityType=l_totalExtinction )
        case (l_effectiveOpticalDepth)
          effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut,    &
          & quantityType=l_radiance,                            &
          & signal=signal%index, sideband=signal%sideband )
        case (l_massMeanDiameterIce)
          massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut,      &
          & quantityType=l_massMeanDiameterIce )
        case (l_massMeanDiameterWater)
          massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut,    &
          & quantityType=l_massMeanDiameterWater )
        case default
          print*, 'l_radiance: ', l_radiance
          print*, 'l_cloudInducedRadiance: ', l_cloudInducedRadiance
          print*, 'l_cloudextinction: ', l_cloudextinction
          print*, 'l_massmeandiameterice: ', l_massmeandiameterice
          print*, 'l_cloudRADSensitivity: ', l_cloudRADSensitivity
          print*, 'l_totalExtinction: ', l_totalExtinction
          print*, 'l_effectiveOpticalDepth: ', l_effectiveOpticalDepth
          print*, 'l_massMeanDiameterWater: ', l_massMeanDiameterWater
          print*, 'l_quantity_type: ', l_quantity_type

          call MLSMessage ( MLSMSG_Error, ModuleName,                        &
                            'Did not understand output l_quantity_types')
      end select
    enddo

!-------------------------------------------------------------------
d192 16
a207 42
    NQ1 = fwdModelIn%template%noQuantities
    NQ2 = fwdModelExtra%template%noQuantities
    do quantity_type = 1, NQ1+NQ2
      if (quantity_type .le. NQ1) &
      l_quantity_type = fwdModelIn%quantities(quantity_type)%template%quantityType
      if (quantity_type .gt. NQ1) &
      l_quantity_type = fwdModelExtra%quantities(quantity_type-NQ1)%template%quantityType
!      print*,'quantity_type: ', 'inputs', quantity_type
!      print*,'l_quantity_type: ', 'inputs', l_quantity_type

      select case (l_quantity_type)
        case (l_ptan)
          ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,      &
          & quantityType=l_ptan, instrumentModule = radiance%template%instrumentModule)
        case (l_temperature)
          temp => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,      &
          & quantityType=l_temperature )
        case (l_gph)
          gph => GetVectorQuantityByType ( fwdModelIn,  fwdModelExtra,       &
          & quantityType=l_gph )
        case (l_cloudIce)
          cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,   &
          & quantityType=l_cloudIce )
        case (l_cloudWater)
          cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_cloudWater )
        case (l_surfaceType)
          surfaceType => GetVectorQuantityByType ( fwdModelIn,fwdModelExtra, &
          & quantityType=l_surfaceType )
        case (l_sizeDistribution)
          sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra, &
          & quantityType=l_sizeDistribution )
        case (l_earthradius)
          earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
          & quantityType=l_earthradius ) 
        case (l_vmr)
!          need to do nothing, will be treated below.
        case default
          call MLSMessage ( MLSMSG_Error, ModuleName,                        &
                            'Did not understand Input l_quantity_types')
      end select
    enddo
d211 1
a211 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
d213 2
a214 2
    if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true.,  &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
d216 2
a217 2
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true.,               &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,    &
d221 1
a221 1
    call Allocate_test ( closestInstances, radiance%template%noInstances,    &
d229 2
a230 2
    call allocate_test ( vmrArray,                                           &
      & size(forwardModelConfig%molecules), temp%template%noSurfs,           &
d236 6
a241 6
        case(L_H2O)
          ivmr=1
        case(L_O3)
          ivmr=2
        case default
          ivmr=0
d247 1
a247 1
      vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,            &
d250 1
a250 1
        & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error,  &
d267 2
a268 2
      call MLSMessage( MLSMSG_Error, ModuleName,                             &
                      'Missing the required molecules' )
d277 2
a278 2
    call Allocate_test ( a_clearSkyRadiance,                                 &
      & radiance%template%noSurfs, noFreqs,                                  &
d280 2
a281 2
    call Allocate_test ( a_cloudInducedRadiance,                             &
      & radiance%template%noSurfs, noFreqs,                                  &
d283 2
a284 2
    call Allocate_test ( a_effectiveOpticalDepth,                            &
      & radiance%template%noSurfs, noFreqs,                                  &
d286 2
a287 2
    call Allocate_test ( a_cloudRADSensitivity,                              &
      & radiance%template%noSurfs, noFreqs,                                  &
d289 2
a290 2
    call Allocate_test ( a_totalExtinction,                                  &
      & temp%template%noSurfs, noFreqs,                                      &
d292 2
a293 2
    call Allocate_test ( a_cloudExtinction,                                  &
      & temp%template%noSurfs, noFreqs,                                      &
d295 2
a296 2
    call Allocate_test ( a_massMeanDiameter,                                 &
      & 2, temp%template%noSurfs,                                            &
d298 1
a298 1
    
d303 4
a306 4
      call MLSMessage ( MLSMSG_Error, ModuleName,                            &
      & 'number of levels in gph does not match no of levels in temp' )
     else if (radiance%template%nosurfs /= ptan%template%nosurfs) then
        call MLSMessage ( MLSMSG_Error, ModuleName,                          &
d315 38
a352 38
!    print*, noFreqs, noSurf, radiance%template%noSurfs, 
!    print*, size( ForwardModelConfig%molecules)
!    print*, 10.0**(-temp%template%surfs)
!    print*,int(sizeDistribution%values(1,instance))
!     print*,ForwardModelConfig%no_model_surfs
!    print*, real(10.0**(-ptan%values(:,maf)))
!    print*,real(gph%values(:, instance))
!    stop

    call CloudForwardModel (                                                 &
      & noFreqs,                                                             &
      & noSurf,                                                              & 
      & radiance%template%noSurfs,                                           &
      & size(ForwardModelConfig%molecules),                                  &
      & ForwardModelConfig%no_cloud_species,                                 &
      & ForwardModelConfig%no_model_surfs,                                   &
      & frequencies/1e3_r8,                                                  &
      & 10.0**(-temp%template%surfs),                                        &
      & gph%values(:, instance),                                             &
      & temp%values(:,instance),                                             &
      & vmrArray,                                                            &
      & WC,                                                                  &
      & sizeDistribution%values(:,instance),                                 &
      & 10.0**(-ptan%values(:,maf)),                                         &
      & earthradius%values(1,1),                                             &
      & surfaceType%values(1, instance),                                     &
      & forwardModelConfig%cloud_der,                                        &
      & forwardModelConfig%cloud_width,                                      &
      & a_clearSkyRadiance,                                                  &
      & a_cloudInducedRadiance,                                              &
      & a_totalExtinction,                                                   &
      & a_cloudExtinction,                                                   &
      & a_massMeanDiameter,                                                  &
      & a_effectiveOpticalDepth,                                             &
      & a_cloudRADSensitivity,                                               &
      & forwardModelConfig%NUM_SCATTERING_ANGLES,                            &  
      & forwardModelConfig%NUM_AZIMUTH_ANGLES,                               &
      & forwardModelConfig%NUM_AB_TERMS,                                     &
d355 1
a355 1
!    stop
d357 2
a358 2
!    read *, reply
!    if (reply(1:1) /= 'o') stop
d362 1
a362 1
     
d369 3
a371 3
!!    print*, 'radiance instance length: ', radiance%template%instanceLen
    radiance%values ( :, maf) =                                              &
      & reshape ( transpose(a_clearSkyRadiance),                             &
d373 1
a373 1
!    stop
d375 4
a378 4
!!    print*, 'cloudinducedradiance instance length: ', cloudInducedRadiance%template%instanceLen
!    stop
    cloudInducedRadiance%values ( :, maf ) =                                 &
      & reshape ( transpose(a_cloudInducedRadiance),                         &
d382 2
a383 2
    effectiveOpticalDepth%values ( :, maf ) =                                &
      & reshape ( transpose(a_effectiveOpticalDepth),                        &
d385 2
a386 2
    cloudRADSensitivity%values ( :, maf ) =                                  &
      & reshape ( transpose(a_cloudRADSensitivity),                          &
d389 2
a390 2
!     print*, 'about to zero cloud extinction'   
!     stop
d392 1
a392 1
 ! For layer(noTempSurfs-1) stuff make sure all are zero to start, then do rest
d398 2
a399 2
!     print*, 'about to assign cloud extinction values'   
!     stop
d401 1
a401 1
    cloudExtinction%values ( 1:noLayers, instance ) =                        &
d403 1
a403 1
    massMeanDiameterIce%values (1:noLayers,instance)=                        &
d405 1
a405 1
    massMeanDiameterWater%values(1:noLayers,instance)=                       &
d407 2
a408 2
    totalExtinction%values ( 1:noLayers, instance ) =                        &
      & reshape ( transpose(a_totalExtinction),                              &
d411 1
a411 1
! stop
d414 19
a432 19
    call Deallocate_test ( a_massMeanDiameter,                               &
                          'a_massMeanDiameterModuleName', ModuleName )
    call Deallocate_test ( a_cloudExtinction,                                &
                          'a_cloudExtinction',            ModuleName )
    call Deallocate_test ( a_totalExtinction,                                &
                          'a_totalExtinction',            ModuleName )
    call Deallocate_test ( a_cloudRADSensitivity,                            &
                          'a_cloudRADSensitivity',        ModuleName )
    call Deallocate_test ( a_effectiveOpticalDepth,                          &
                          'a_effectiveOpticalDepth',      ModuleName )
    call Deallocate_test ( a_cloudInducedRadiance,                           &
                          'a_cloudInducedRadiance',       ModuleName )
    call Deallocate_test ( a_clearSkyRadiance,                               &
                          'a_clearSkyRadiance',           ModuleName )
    call Deallocate_test ( vmrArray,                                         &
                          'vmrArray',                     ModuleName )
    call Deallocate_test ( closestInstances,                                 &
                          'closestInstances',             ModuleName )
   
d434 1
a434 1
!    stop
@


1.12
log
@Jonathan
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.11 2001/07/20 17:45:42 jonathan Exp $"
d121 1
d384 1
a384 1
      & size( ForwardModelConfig%molecules),                                 &
d387 8
a394 8
      & real(frequencies/1e3_r8),                                            &
      & real(10.0**(-temp%template%surfs)),                                  &
      & real(gph%values(:, instance)),                                       &
      & real(temp%values(:,instance)),                                       &
      & real(vmrArray),                                                      &
      & real(WC),                                                            &
      & int(sizeDistribution%values(1,instance)),                            &
      & real(10.0**(-ptan%values(:,maf))),                                   &
d396 1
a396 1
      & int(surfaceType%values(1, instance)),                                &
d399 7
a405 7
      & real(a_clearSkyRadiance),                                            &
      & real(a_cloudInducedRadiance),                                        &
      & real(a_totalExtinction),                                             &
      & real(a_cloudExtinction),                                             &
      & real(a_massMeanDiameter),                                            &
      & real(a_effectiveOpticalDepth),                                       &
      & real(a_cloudRADSensitivity),                                         &
d411 5
a415 1
    stop
d418 1
a418 1

d423 3
d429 4
d435 3
a437 1
      & (/cloudInducedRadiance%template%instanceLen/) )
d440 1
a440 1
      & (/effectiveOpticalDepth%template%instanceLen/) )
d443 4
a446 1
      & (/cloudRADSensitivity%template%instanceLen/) )
d453 4
a456 1
    
d488 3
a490 1

@


1.11
log
@input real not real(r8) in call to cloudforwardmodel, jonathan
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.10 2001/07/20 16:44:48 jonathan Exp $"
d370 2
a371 1
!    print*, noFreqs, noSurf, radiance%template%noSurfs, size( ForwardModelConfig%molecules)
d373 5
d392 1
a392 1
      & sizeDistribution%values(1,instance),                                 &
d398 7
a404 7
      & a_clearSkyRadiance,                                                  &
      & a_cloudInducedRadiance,                                              &
      & a_totalExtinction,                                                   &
      & a_cloudExtinction,                                                   &
      & a_massMeanDiameter,                                                  &
      & a_effectiveOpticalDepth,                                             &
      & cloudRADSensitivity,                                                 &
d410 2
d439 4
a442 2
    massMeanDiameterIce%values (1:noLayers,instance)=a_massMeanDiameter(1,:)
    massMeanDiameterWater%values(1:noLayers,instance)=a_massMeanDiameter(2,:)
d444 4
a447 1
      & reshape ( transpose(a_totalExtinction), (/noLayers*noFreqs/) )
d472 1
@


1.10
log
@fix bug,jonathan
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.9 2001/07/20 16:20:03 jonathan Exp $"
d171 2
a172 2
      print*,'quantity_type: ', 'outputs', quantity_type
      print*,'l_quantity_type: ', 'outputs', l_quantity_type
d228 2
a229 2
      print*,'quantity_type: ', 'inputs', quantity_type
      print*,'l_quantity_type: ', 'inputs', l_quantity_type
d370 3
d380 6
a385 6
      & frequencies/1e3_r8,                                                  &
      & 10.0**(-temp%template%surfs),                                        &
      & gph%values(:, instance),                                             &
      & temp%values(:,instance),                                             &
      & vmrArray,                                                            &
      & WC,                                                                  &
d387 3
a389 3
      & 10.0**(-ptan%values(:,maf)),                                         &
      & earthradius%values(1,1),                                           &
      & surfaceType%values(1, instance),                                     &
@


1.9
log
@fix bugs, jonathan/dwu
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.8 2001/07/18 23:52:19 jonathan Exp $"
d180 1
a180 1
          & quantityType=l_cloudInducedRadiance,                             &
d184 1
a184 2
          & quantityType=l_cloudExtinction,                                  &
          & signal=signal%index, sideband=signal%sideband )
d187 1
a187 1
          & quantityType=l_cloudRADSensitivity,                              &
d191 1
a191 2
          & quantityType=l_totalExtinction,                                  &
          & signal=signal%index, sideband=signal%sideband )
d194 1
a194 1
          & quantityType=l_effectiveOpticalDepth,                            &
@


1.8
log
@change radiusofearth to earthradius
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.7 2001/07/17 22:36:50 jonathan Exp $"
d112 2
d170 3
a172 1
      l_quantity_type = fwdModelOut%template%quantities(quantity_type)
d205 10
d216 1
a216 1
                            'Did not understand l_quantity_types')
d223 10
a232 2
    do quantity_type = 1, fwdModelIn%template%noQuantities
      l_quantity_type = fwdModelIn%template%quantities(quantity_type)
d234 3
a236 3
        case (l_ptan) 
          ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,       &
          & quantityType=l_ptan, radiometer=signal%radiometer )
d238 1
a238 1
          temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,       &
d241 1
a241 1
          gph => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,        &
d250 1
a250 1
          surfaceType => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,&
d253 1
a253 1
          sizeDistribution=>GetVectorQuantityByType(fwdModelIn,fwdModelExtra,&
d256 4
a259 2
          earthradius=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,&
          & quantityType=l_tngtgeocalt ) 
d262 1
a262 1
                            'Did not understand l_quantity_types')
d290 1
a291 1

d303 1
a303 1

d309 1
d313 1
@


1.7
log
@add cloud_width, jonathan/paul
@
text
@d51 1
a51 1
                     & L_RADIUSOFEARTH,                                      &
d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.6 2001/07/17 18:12:56 jonathan Exp $"
d100 1
a100 1
    type (VectorValue_T), pointer :: RADIUSOFEARTH              ! Scalar 
d141 1
a141 1
             RADIANCE, SIZEDISTRIBUTION, RADIUSOFEARTH, SURFACETYPE,         &
d233 2
a234 2
        case (l_radiusofearth)
          radiusofearth=>GetVectorQuantityByType ( fwdModelIn, fwdModelExtra,&
d361 1
a361 1
      & radiusofearth%values(1,1),                                           &
@


1.6
log
@add select cases, jonathan/paul
@
text
@d62 1
a62 1
    "$Id: FullCloudForwardModel.f90,v 1.5 2001/07/09 22:03:20 jonathan Exp $"
d364 1
a364 1
      & forwardModelConfig%phiWINDOW,                                        &
@


1.5
log
@fix mlsmess bug
@
text
@d1 1
d9 1
a12 1
!  use CloudForwardModelConfig, only: CloudForwardModelConfig_T
d22 3
a24 1
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T, &
d26 1
a26 1

d32 1
a32 1
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, &
d40 13
a52 13
  use Intrinsic, only: L_TEMPERATURE,L_PTAN,L_VMR,L_GPH,L_RADIANCE,L_NONE, &
                     & L_CLOUDINDUCEDRADIANCE,                             &
                     & L_EFFECTIVEOPTICALDEPTH,                            &
                     & L_CLOUDRADSENSITIVITY,                              &
                     & L_TOTALEXTINCTION,                                  &
                     & L_CLOUDEXTINCTION,                                  &
                     & L_MASSMEANDIAMETERICE,                              & 
                     & L_MASSMEANDIAMETERWATER,                            &
                     & L_SURFACETYPE,                                      &
                     & L_SIZEDISTRIBUTION,                                 &
                     & L_TNGTGEOCALT,                                      &
                     & L_RADIUSOFEARTH,                                    &
                     & L_CLOUDICE,                                         &
a53 1
  
d61 2
a62 2
  character (len=*), private, parameter :: IdParm = &
    "$Id: FullCloudForwardModel.f90,v 1.4 2001/07/09 15:47:57 jonathan Exp $"
d64 1
a64 1
  character (len=*), private, parameter :: ModuleName= &
d111 1
d120 2
d136 11
d149 2
a150 2
    if ( size ( forwardModelConfig%signals ) /= 1 ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
d156 1
a156 1
    if ( signal%sideband == 0 ) call MLSMessage ( MLSMSG_Error, ModuleName, &
d158 1
a158 1
    call Allocate_test ( frequencies, count ( signal%channels ), &
d160 1
a160 1
    frequencies = signal%lo + signal%sideband * ( signal%centerFrequency + &
d164 77
a240 44
    ! Get the quantities we need from the vectors, outputs first
    radiance => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_radiance, signal=signal%index, sideband=signal%sideband )
    cloudInducedRadiance => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_cloudInducedRadiance, &
      & signal=signal%index, sideband=signal%sideband )
    cloudExtinction => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_cloudExtinction, &
      & signal=signal%index, sideband=signal%sideband )
    cloudRADSensitivity => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_cloudRADSensitivity, &
      & signal=signal%index, sideband=signal%sideband )
    totalExtinction => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_totalExtinction, &
      & signal=signal%index, sideband=signal%sideband )
    effectiveOpticalDepth => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_effectiveOpticalDepth, &
      & signal=signal%index, sideband=signal%sideband )

    massMeanDiameterIce => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_massMeanDiameterIce )
    massMeanDiameterWater => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_massMeanDiameterWater )

    ptan => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_ptan, radiometer=signal%radiometer )
    temp => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_temperature )
    gph => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_gph )
    cloudIce => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_cloudIce )
    cloudWater => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_cloudWater )
    surfaceType => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_surfaceType )
    sizeDistribution => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_sizeDistribution )
!    radiusofearth => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
!      & quantityType=l_radiusofearth )
    radiusofearth => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
      & quantityType=l_tngtgeocalt ) 
   
    ! Do the vmr's one by one later on.
d244 1
a244 1
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d246 2
a247 2
    if ( .not. ValidateVectorQuantity(gph, stacked=.true., coherent=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d249 2
a250 2
    if ( .not. ValidateVectorQuantity(ptan, minorFrame=.true., &
      & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d254 1
a254 1
    call Allocate_test ( closestInstances, radiance%template%noInstances, &
d258 6
a263 2
    call allocate_test ( vmrArray, &
      & size(forwardModelConfig%molecules), temp%template%noSurfs, &
d267 14
a280 1
      vmr => GetVectorQuantityByType ( fwdModelIn, fwdModelExtra, &
d282 2
a283 2
      if (.not. ValidateVectorQuantity ( vmr, stacked=.true., coherent=.true., &
        & frequencyCoordinate=(/l_none/)) ) call MLSMessage ( MLSMSG_Error, &
d294 1
d297 5
d308 2
a309 2
    call Allocate_test ( a_clearSkyRadiance, &
      & radiance%template%noSurfs, noFreqs, &
d311 2
a312 2
    call Allocate_test ( a_cloudInducedRadiance, &
      & radiance%template%noSurfs, noFreqs, &
d314 2
a315 2
    call Allocate_test ( a_effectiveOpticalDepth, &
      & radiance%template%noSurfs, noFreqs, &
d317 2
a318 2
    call Allocate_test ( a_cloudRADSensitivity, &
      & radiance%template%noSurfs, noFreqs, &
d320 2
a321 2
    call Allocate_test ( a_totalExtinction, &
      & temp%template%noSurfs, noFreqs, &
d323 2
a324 2
    call Allocate_test ( a_cloudExtinction, &
      & temp%template%noSurfs, noFreqs, &
d326 2
a327 2
    call Allocate_test ( a_massMeanDiameter, &
      & 2, temp%template%noSurfs, &
d334 1
a334 1
      call MLSMessage ( MLSMSG_Error, ModuleName, &
d337 1
a337 1
        call MLSMessage ( MLSMSG_Error, ModuleName, &
d339 1
a339 2
 
   endif
d341 1
a341 1
   allocate ( WC(2,NOsurf), STAT=status )
d343 2
a344 2
   WC (1,:) = CloudIce%values(:,instance)
   WC (2,:) = CloudWater%values(:,instance)
d346 29
a374 29
    call CloudForwardModel ( &
      & noFreqs, &
      & noSurf,  & 
      & radiance%template%noSurfs, &
      & size( ForwardModelConfig%molecules), &
      & ForwardModelConfig%no_cloud_species, &
      & ForwardModelConfig%no_model_surfs, &
      & frequencies/1e3_r8, &
      & 10.0**(-temp%template%surfs), &
      & gph%values(:, instance), &
      & temp%values(:,instance), &
      & vmrArray, &
      & WC, &
      & sizeDistribution%values(1,instance), &
      & 10.0**(-ptan%values(:,maf)), &
      & radiusofearth%values(1,1), &
      & surfaceType%values(1, instance), &
      & forwardModelConfig%cloud_der, &
      & forwardModelConfig%phiWINDOW, &
      & a_clearSkyRadiance, &
      & a_cloudInducedRadiance, &
      & a_totalExtinction, &
      & a_cloudExtinction, &
      & a_massMeanDiameter, &
      & a_effectiveOpticalDepth, &
      & cloudRADSensitivity, &
      & forwardModelConfig%NUM_SCATTERING_ANGLES, & 
      & forwardModelConfig%NUM_AZIMUTH_ANGLES, &
      & forwardModelConfig%NUM_AB_TERMS, &
d380 1
a380 1
    ! Vectors are stored ( noChannels * noSurfaces, noInstances ), so transpose
d383 2
a384 2
    radiance%values ( :, maf) = &
      & reshape ( transpose(a_clearSkyRadiance), &
d386 2
a387 2
    cloudInducedRadiance%values ( :, maf ) = &
      & reshape ( transpose(a_cloudInducedRadiance), &
d389 2
a390 2
    effectiveOpticalDepth%values ( :, maf ) = &
      & reshape ( transpose(a_effectiveOpticalDepth), &
d392 2
a393 2
    cloudRADSensitivity%values ( :, maf ) = &
      & reshape ( transpose(a_cloudRADSensitivity), &
d402 1
a402 1
    cloudExtinction%values ( 1:noLayers, instance ) = &
d404 3
a406 3
    massMeanDiameterIce%values ( 1:noLayers, instance ) = a_massMeanDiameter(1,:)
    massMeanDiameterWater%values ( 1:noLayers, instance ) = a_massMeanDiameter(2,:)
    totalExtinction%values ( 1:noLayers, instance ) = &
d410 18
a427 9
    call Deallocate_test ( a_massMeanDiameter, 'a_massMeanDiameterModuleName', ModuleName )
    call Deallocate_test ( a_cloudExtinction, 'a_cloudExtinction', ModuleName )
    call Deallocate_test ( a_totalExtinction, 'a_totalExtinction', ModuleName )
    call Deallocate_test ( a_cloudRADSensitivity, 'a_cloudRADSensitivity', ModuleName )
    call Deallocate_test ( a_effectiveOpticalDepth, 'a_effectiveOpticalDepth', ModuleName )
    call Deallocate_test ( a_cloudInducedRadiance, 'a_cloudInducedRadiance', ModuleName )
    call Deallocate_test ( a_clearSkyRadiance, 'a_clearSkyRadiance', ModuleName )
    call Deallocate_test ( vmrArray, 'vmrArray', ModuleName )
    call Deallocate_test ( closestInstances, 'closestInstances', ModuleName )
@


1.4
log
@use tnggeocalt for earth radius
@
text
@d60 1
a60 1
    "$Id: FullCloudForwardModel.f90,v 1.3 2001/07/06 18:47:00 jonathan Exp $"
d262 1
a262 1
      call MLSMessageModule ( MLSMSG_Error, ModuleName, &
d265 1
a265 1
        call MLSMessageModule ( MLSMSG_Error, ModuleName, &
@


1.3
log
@Modified July, 6, Jonathan
@
text
@d47 1
d51 1
d60 1
a60 1
    "$Id: FullCloudForwardModel.f90,v 1.2 2001/05/31 22:58:24 livesey Exp $"
d186 2
d189 2
a190 2
      & quantityType=l_radiusofearth )
    
@


1.2
log
@Version that compiles
@
text
@d6 3
a8 3
  ! This module will contain the full cloud forward model.  Currently it only
  ! contains a wrapper, but eventually will contain the top level routine for
  ! the model itself.
d11 5
a15 1
  use MLSCommon, only: r8
a17 5
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T, &
    & VALIDATEVECTORQUANTITY
  use ForwardModelConfig, only: FORWARDMODELCONFIG_T
  use ForwardModelIntermediate, only: FORWARDMODELINTERMEDIATE_T, &
    & FORWARDMODELSTATUS_T
a18 5
  use Intrinsic, only: L_TEMPERATURE, L_PTAN, L_VMR, L_GPH, L_RADIANCE, L_NONE, &
    & L_CLOUDINDUCEDRADIANCE, L_EFFECTIVEOPTICALDEPTH, L_CLOUDSENSITIVITY, &
    & L_TOTALEXTINCTION, L_CLOUDEXTINCTION, L_MASSMEANDIAMETERICE, &
    & L_MASSMEANDIAMETERWATER, L_SURFACETYPE, L_SIZEDISTRIBUTION, &
    & L_CLOUDICE, L_CLOUDWATER
d21 29
d58 1
a58 1
    "$Id: FullCloudForwardModel.f90,v 1.1 2001/05/29 22:19:12 livesey Exp $"
d68 7
a74 8
  
contains ! ============= Public Procedures ==========================

  subroutine FullCloudForwardModelWrapper ( ForwardModelConfig, FwdModelIn, FwdModelExtra, &
        FwdModelOut, Ifm, fmStat, Jacobian )
    ! This is simply a wrapper for Jonathan's full up forward model.  Hopefully
    ! we won't need to wrap it in the long run, but will call it directly.
    
d78 3
a80 3
    type(vector_T), intent(inout) :: FWDMODELOUT  ! Radiances, etc.
    type(forwardModelIntermediate_T), intent(inout) :: IFM ! Workspace
    type(forwardModelStatus_t), intent(inout) :: FMSTAT ! Reverse comm. stuff
d84 17
d102 1
a102 18
    type (VectorValue_T), pointer :: CLOUDICE ! Profiles
    type (VectorValue_T), pointer :: CLOUDWATER ! Profiles
    type (VectorValue_T), pointer :: CLOUDEXTINCTION ! Like radiance too
    type (VectorValue_T), pointer :: CLOUDINDUCEDRADIANCE ! Like radiance
    type (VectorValue_T), pointer :: CLOUDSENSITIVITY ! Vector quantity
    type (VectorValue_T), pointer :: EFFECTIVEOPTICALDEPTH ! Another quantity
    type (VectorValue_T), pointer :: GPH ! Geopotential height sv qty
    type (VectorValue_T), pointer :: MASSMEANDIAMETERICE ! Quantity
    type (VectorValue_T), pointer :: MASSMEANDIAMETERWATER ! Quantity
    type (VectorValue_T), pointer :: PTAN ! Tangent pressure
    type (VectorValue_T), pointer :: RADIANCE ! Radiance quantity
    type (VectorValue_T), pointer :: SIZEDISTRIBUTION ! Integer really
    type (VectorValue_T), pointer :: SURFACETYPE ! Integer really
    type (VectorValue_T), pointer :: TEMP ! Temperature state vector quantity
    type (VectorValue_T), pointer :: TOTALEXTINCTION ! Vector quantity
    type (VectorValue_T), pointer :: VMR ! One vmr quantity

    type (Signal_T) :: signal           ! The signal we're working on.
d104 1
a104 1
    real(r8), dimension(:,:), pointer :: VMRARRAY ! The vmr's
d107 1
a107 1
    integer :: MAF                      ! The major frame we're working on.
d113 2
d116 1
a116 1
    integer, dimension(:), pointer :: closestInstances ! From find routine
d121 1
a121 1
    real(r8), dimension(:,:), pointer :: A_CLOUDSENSITIVITY
d127 1
a128 1
    ! Executable code
d130 1
a130 1
    ! Check the configuration we've been given, and deduce some stuff
d155 2
a156 2
    cloudSensitivity => GetVectorQuantityByType ( fwdModelOut, &
      & quantityType=l_cloudSensitivity, &
d184 2
d212 1
a212 1
      if (.not. ValidateVectorQuantity ( vmr,  stacked=.true., coherent=.true., &
d231 1
a231 1
    ! Make temporary arrays for Jonathan's stuff
d241 1
a241 1
    call Allocate_test ( a_cloudSensitivity, &
d243 1
a243 1
      & 'a_cloudSensitivity', ModuleName )
d254 16
a269 1
    ! Now call Jonathan's f77 code
d272 6
d283 2
d286 1
a286 4
      & noFreqs, &
      & temp%template%noSurfs, &
      & radiance%template%noSurfs, &
      & sizeDistribution%values(1,instance), &
d289 1
d296 7
a302 1
      & cloudSensitivity )
d317 3
a319 3
    cloudSensitivity%values ( :, maf ) = &
      & reshape ( transpose(a_cloudSensitivity), &
      & (/cloudSensitivity%template%instanceLen/) )
d321 1
a321 1
    ! For layer (noTempSurfs-1) stuff make sure all are zero to start, then do rest
d338 1
a338 1
    call Deallocate_test ( a_cloudSensitivity, 'a_cloudSensitivity', ModuleName )
@


1.1
log
@First, non compiling version.
@
text
@d13 3
a15 1
  use VectorsModule, only: GETVECTORQUANTITYBYTYPE, VECTOR_T, VECTORVALUE_T
d20 5
a24 1
  use Intrinsic, only: L_TEMPERATURE, L_PTAN, L_VMR, L_GPH
d26 1
d35 1
a35 1
    "$Id: ForwardModelWrappers.f90,v 2.4 2001/05/03 23:42:48 livesey Exp $"
d38 1
a38 1
    "$RCSfile: ForwardModelWrappers.f90,v $"
d63 6
d70 2
d74 2
d77 1
d89 2
d96 1
a96 1
    real(r8), dimension(:,:), pointer :: A_CLOUDOPTICALDEPTH
d100 1
a100 1
    real(r8), dimension(:,:), pointer :: A_TOTALOPTICALDEPTH
d110 1
a110 1
    signal = forwardModelConfig%signal(1)
d120 1
d122 1
a122 1
    ! Get the quantities we need from thevectors
d128 17
d152 9
d193 3
a195 3
        & vmr%template%surfs, &         ! Old X
        & vmr%values(:,vmrInst), &         ! Old Y
        & temp%template%surfs, &        ! New X
d197 1
a197 1
        & method='Linear', extrapolate='Clamp' )
d218 1
a218 1
    call Allocate_test ( a_totalOpticalDepth, &
d220 2
a221 2
      & 'a_totalOpticalDepth', ModuleName )
    call Allocate_test ( a_cloudOpticalDepth, &
d223 1
a223 1
      & 'a_cloudOpticalDepth', ModuleName )
d226 1
a226 1
      & 'a_massMeanDiameterModuleName', ModuleName )
d231 2
a232 2
      & frequency/1e3_r8, &
      & 10.0^(-temp%template%surfs), &
d236 2
a237 2
      & 10.0^(-ptan%values(:,maf)), &
      & size(frequency), &
d240 1
a240 3
      & WCscale%values(1,wcScaleInst), &
      & cloudType%values(1,instance), &
      & PSDtype%values(1,instance), &
a242 2
      & saturatedBelowClouds%values(1, instance), &
      & cloudHeight%values(1, instance), &
d245 2
a246 3
      & a_totalOpticalDepth, &
      & a_cloudOpticalDepth, &
      & layerThickness%value( 1:noLayers, instance ), &
a250 2
    effectiveOpticalDeptmassMeanDiameterIce%values(:,instance) = 0.0_r8

d257 1
a257 1
      & (/clearSkyRadiance%template%instanceLen/) )
d269 1
a269 2
    cloudOpticalDepth%values(:,instance) =     0.0_r8
    layerThickness%value( :, instance) =       0.0_r8
d272 1
a272 1
    totalOpticalDepth%values(:,instance) =     0.0_r8
d274 6
a279 8
    cloudOpticalDepth%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_cloudOpticalDepth), (/noLayers*noFreqs/) )
    massMeanDiameterIce%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_massMeanDiameterIce), (/noLayers*noFreqs/) )
    massMeanDiameterWater%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_massMeanDiameterWater), (/noLayers*noFreqs/) )
    totalOpticalDepth%values ( 1:noLayers, instance ) = &
      & reshape ( transpose(a_totalOpticalDepth), (/noLayers*noFreqs/) )
d283 2
a284 2
    call Deallocate_test ( a_cloudOpticalDepth, 'a_cloudOpticalDepth', ModuleName )
    call Deallocate_test ( a_totalOpticalDepth, 'a_totalOpticalDepth', ModuleName )
@

