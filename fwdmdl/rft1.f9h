! subroutine ?RFT1 (A, MODE, M, MS, S)
!>> 1997-03-31 DFFT1 Krogh  Increased KEDIM, more sine table checks.
!>> 1996-01-23 DRFT1 Krogh  Changes to simplify conversion to C.
!>> 1994-11-11 DRFT1 Krogh  Declared all vars.
!>> 1994-10-20 DRFT1 Krogh  Changes to use M77CON
!>> 1989-05-07 DRFT1 FTK & CLL
!>> 1989-04-21 FTK & CLL
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!
!     This subroutine computes Fourier transforms of real data using
!     the Cooley-Tukey fast Fourier transform.
!
!     Variables in the calling sequence have the following types
    real(rk), intent(inout) :: A(*), S(*)
    integer, intent(in) ::     M
    integer, intent(inout) ::  MS
    character, intent(in) ::   MODE
!
!     Programmed by Fred T. Krogh at the Jet Propulsion Laboratory,
!     Pasadena, Calif.   August 1, 1969.
!     Revised for portability by Krogh -- January 22, 1988
!
!     In describing the usage the following notation is used
!     N = 2 ** M
!     W = EXP(2*PI*I/N), where I = SQRT(-1) and PI = 3.14159...
!
!     The usage is as follows
!
! A() is an array of function values if one is doing Fourier analysis,
!  and is an array of Fourier coefficients if one is doing Fourier
!  synthesis.  In our description here we assume that A is a real
!  array with dimension A(N) when A contains the real data, X, and
!  that A is a complex array with dimension A(N/2) when A contains
!  complex Fourier coefficients, C.  (C(k) for k > N/2 need not be
!  saved since for 0 < k < N, C(N-k) = conjugate of C(k).  It is
!  assumed that the imaginary part of a complex number is stored
!  in the cell immediately following its real part, except that
!  A(1) = C(0), and A(2) = C(N/2).  This is possible since these
!  values of C are real and by doing this both X and C require the
!  same storage in A. Of course the storage required for A can be
!  reserved by the user in any way that works.
!
! MODE  Selects Synthesis or Analysis.
!  If MODE = 'A' or 'a', do Fourier analysis, which amounts to setting
!  C(k) = sum for j=0 to N-1 of X(j)*T(M,j,k), for k = 0, N/2
!  with  T(M,j,k) = (1/N) * W ** (-j*k).
!  If MODE = 'S' or 's', do Fourier synthesis, which amounts to setting
!  X(j) = sum for k=0 to N-1 of C(k)*T(M,j,k), for j = 0, N - 1
!  with  T(M,j,k) = W ** (j*k)
!  (Recall that C(N-k) is the conjugate of C(k).)
!
! M is used to indicate N = 2**M, the number of real points.  The
!  number of points must satisfy 1 <= N <= 2**21.
!  M = 0 gives an immediate return.
!
! MS gives the state of the sine table.  If MS > 0, there are NT =
!    2 ** (MS-2) good entries in the sine table.  On the initial call,
!    MS must be set to 0, and when the return is made, it will be set
!    to M, which is the value of MS required for computing a
!    transform of size N.  If MS = -1, the sine table will be computed
!    as for the case MS = 0, and then a return to the user will be made
!    with MS set as before, but no transform will be computed.  This
!    option is useful if the user would like access to the sine table
!    before computing the FFT.
!    On detected errors the error message subrs are called and
!    execution stops.  If the user overrides the stop to cause
!    continuation, then this subr will return with MS = -2.
!
! S() is a vector, S(j) = sin(pi*j/2*NT)), j = 1, 2, ..., NT-1, where
!  NT is defined in the description of MS above.  S is computed by the
!  subroutine if M > MS.  (If S is altered, set MS=0 so that S
!  is recomputed.)
!
!     ------------------------------------------------------------------
!                Notes on COMMON, PARAMETER's, and local variables
!
!     MMAX is the largest value allowed for M
!     The dimension of KE must be at least as large as MMAX-1.
!     The subroutine ?FFT which computes a one dimensional complex
!     Fourier transform and computes the sine table.
!
!     ANAL = .TRUE. when doing Fourier analysis, and .false. otherwise.
!
!     N1 = 2 ** M
!     ------------------------------------------------------------------
!--D replaces "?": ?RFT1, ?FFT, C?FFTC
!     Both versions use ERMSG, ERM1
!     and need ERFIN, IERV1
!     ------------------------------------------------------------------
    logical :: ANAL
    real(rk) :: FN
    integer, parameter :: MMAX = KEDIM+1
    integer :: I, II, II1, II2, IR, IR1, IR2
    integer :: J, JDIF, JJ
    integer :: K1, K1N, KN2
    integer :: L
    integer :: MA
    character(len=*), parameter :: ME = prec//'RFT1'
    character(len=*), parameter :: MSG = 'Bad MODE.  MODE =  '
    character(len=len(msg)) :: MSG1 = MSG
    integer :: MSI
    integer :: N1, N1P
    real(rk) :: T, TI, TT, TTI, WI, WR

!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id$"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
!---------------------------------------------------------------------------

!
!     ------------------------------------------------------------------
!
    if( mode == 'A' .or. mode == 'a') then
      anal = .true.
    else if( mode == 'S' .or. mode == 's') then
      anal = .false.
    else
      msg1(19:19) = mode
      call ermsg(me, 2, 2, msg1, '.')
      ms = -2
      return
    end if
    ma = m
    if (ma > mmax .or. ma < 0) then
!                          Fatal error, default is to stop in ERM1
      call erm1 (me, 1, 2, 'Require 0 <= M <= 31', 'M', M, '.')
      ms = -2
      return
    end if
    msi = ms
    needst = ma > msi
    if (.not. needst) then
!   Check internal parameters to catch certain user errors.
      if (MT < KEDIM) then
        if (MA <= MT + 2) then
!         Skip sine table computation if all appears O.K.
          if (mt <= 0) go to 10
          if (abs(s(nt/2) - spi4) <= 1.d-7) go to 10
        end if
      end if
      needst = .true.
      call ermsg (me, 3, 1, 'Invalid sine table (re)computed', '.')
      end if
      ms = ma
      mt = ma - 2
      call fft (a, a, s)
!                   Return if user requested it.
      if (msi == -1) return
!                   All setup for computation now
   10 if (ma /= 0) then
        mm = ma - 1
        n1 = 2 ** ma
        n1p = n1 + 2
        kn2 = n1 / 2
        jdif = (4 * nt) / n1
        ks = 2
        if (anal) then
!                               Set flags for Fourier analysis
          ir = 2
          ii = 1
          fn = half / dble(n1)
!         Doing Fourier analysis, so multiply by 2 ** M
          do i = 1, n1
            a(i) = a(i) * fn
          end do
        else
!                              Set flags for Fourier synthesis
          ir = 1
          ii = 2
          go to 50
        end if

!                              Compute complex Fourier transform
 30    do  l = 1, mm
         kee(l+1) = kee(l) / 2
       end do
       call fft (a(ir:n1), a(ii:n1), s)
!                              End of computing complex transform
!
       if (.not. anal) go to 70
!
!      Beginning of calculations relating coefficients of real data
!      with coefficients of associated complex data
!
!      Special case --  K1 = 0
   50  t = a(1) + a(2)
       ti = a(1) - a(2)
       if (anal) then
         t = two * t
         ti = two * ti
       end if
       a(1) = t
       a(2) = ti
       if (mm > 0) then
!                         Special kase -- K1 = N1 / 4
         a(kn2+1) = two * a(kn2+1)
         a(kn2+2) = -two * a(kn2+2)
         if (mm > 1) then
           j = 0
           do k1 = 3, kn2, 2
             k1n = n1p - k1
             if (anal) then
                ir1 = k1n
                ir2 = k1
             else
                ir1 = k1
                ir2 = k1n
             end if
             ii2 = ir2 + 1
             ii1 = ir1 + 1
             j = j + jdif
             wi = s(j)
             jj = nt - j
             wr = s(jj)
             t = a(ir1) - a(ir2)
             ti = a(ii1) + a(ii2)
             tt = t * wi + ti * wr
             tti = t * wr - ti * wi
             t = a(ir1) + a(ir2)
             ti = a(ii1) - a(ii2)
             a(ir1) = t - tt
             a(ir2) = t + tt
             a(ii1) = tti + ti
             a(ii2) = tti - ti
          end do
        end if
      end if
      if (.not. anal) go to 30
    end if
 70 return
!
! end subroutine ?RFT1

! $Log$
