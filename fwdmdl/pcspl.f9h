! subroutine ?_PCSPL ( TAU, C, N, IBCBEG, IBCEND )
!
!  From  * A Practical guide to splines *  by C. De Boor
!     ************************  input  ***************************
!     N = number of data points. assumed to be  >=  2.
!     (TAU(i), c(1,i), i=1,...,N) = abscissae and ordinates of the
!        data points. tau is assumed to be strictly increasing.
!     IBCBEG, IBCEND = boundary condition indicators, and
!     C(2,1), C(2,N) = boundary condition information. specifically,
!        IBCBEG = 0  means no boundary condition at TAU(1) is given.
!           in this case, the not-a-knot condition is used, i.e. the
!           jump in the third derivative across TAU(2) is forced to
!           zero, thus the first and the second cubic polynomial pieces
!           are made to coincide.)
!        IBCBEG = 1  means that the slope at TAU(1) is made to equal
!           C(2,1), supplied by input.
!        IBCBEG = 2  means that the second derivative at TAU(1) is
!           made to equal C(2,1), supplied by input.
!        IBCEND = 0, 1, or 2 has analogous meaning concerning the
!           boundary condition at TAU(N), with the additional infor-
!           mation taken from C(2,N).
!     ***********************  output  **************************
!     C(j,i), j=1,...,4; i=1,...,l (= N-1) = the polynomial coefficients
!        of the cubic interpolating spline with interior knots (or
!        joints) TAU(2), ..., TAU(N-1). Precisely, in the interval
!        (TAU(i), TAU(i+1)), the spline f is given by
!           f(x) = C(1,i)+h*(C(2,i)+h*(C(3,i)+h*C(4,i)/3.)/2.)
!        where h = x - TAU(i). the function program *ppvalu* may be
!        used to evaluate f or its derivatives from TAU, C, L = N-1,
!        and K=4.
!
    integer, intent(in) :: N, IBCBEG, IBCEND

    real(rk), intent(in) :: TAU(n)
    real(rk), intent(inout) :: C(4, n)

    integer :: L, M, J, I
    real(rk) :: DTAU, R, G, DIVDF1, DIVDF3
!
!****** A tridiagonal linear system for the unknown slopes s(i) of
!  f at TAU(i), i=1,...,N, is generated and then solved by gauss elim-
!  ination, with s(i) ending up in C(2,i), all i.
!  C(3,.) and C(4,.) are used initially for temporary storage.
!
    l = n - 1
!
! Compute first differences of tau sequence and store in c(3,.). Also,
! compute first divided difference of data and store in c(4,.).
!
    do m = 2, n
      dtau = tau(m) - tau(m-1)
      if (abs(dtau) <= epsilon(tau)) then
        print *,'** Warning: division by zero in routine: ?_PCSPL'
        print *,'   Subroutine ?CSPLINE(_DER) bombed out !!'
        return
      end if
      c(3,m) = dtau
      c(4,m) = (c(1,m) - c(1,m-1)) / dtau
    end do
!
! Construct first equation from the boundary condition, of the form
!             c(4,1)*s(1) + c(3,1)*s(2) = c(2,1)
!
    select case ( ibcbeg )
    case ( :0 )
      if (n <= 2) then ! no condition at left end and n = 2.
        c(4,1) = 1.0
        c(3,1) = 1.0
        c(2,1) = 2.0*c(4,2)
      else             ! not-a-knot condition at left end and n  >  2.
        c(4,1) = c(3,3)
        c(3,1) = c(3,2) + c(3,3)
        r = c(3,2) * c(3,2)
        c(2,1) =((c(3,2)+2.0*c(3,1))*c(4,2)*c(3,3)+r*c(4,3))/c(3,1)
      end if
    case ( 1 )         ! slope prescribed at left end.
      c(4,1) = 1.0
      c(3,1) = 0.0
    case ( 2: )        ! second derivative prescribed at left end.
      c(4,1) = 2.0
      c(3,1) = 1.0
      c(2,1) = 3.0*c(4,2) - c(3,2)/2.0*c(2,1)
    end select
!
! If there are interior knots, generate the corresp. equations and carry
! out the forward pass of gauss elimination, after which the m-th
! equation reads    C(4,m)*s(m) + C(3,m)*s(m+1) = C(2,m).
!
    do m = 2, l
      g = -c(3,m+1)/c(4,m-1)
      c(2,m) = g*c(2,m-1) + 3.0*(c(3,m)*c(4,m+1)+c(3,m+1)*c(4,m))
      c(4,m) = g*c(3,m-1) + 2.0*(c(3,m) + c(3,m+1))
    end do
!
! Construct last equation from the second boundary condition, of the form
!  (-g*C(4,n-1))*s(n-1) + C(4,n)*s(n) = C(2,n).
! If slope is prescribed at right end, one can go directly to back-
! substitution, since C array happens to be set up just right for it
! at this point.
!
    if ( ibcend /= 1 ) then  ! slope not prescribed at right end point
      if ( ibcend > 1 ) then ! second derivative prescribed at right endpoint.
        c(2,n) = 3.0*c(4,n) + 0.5*c(3,n)*c(2,n)
        c(4,n) = 2.0
        g = 1.0
      else ! ibcend < 1      ! no condition at right end point
        if ( n <= 2 .and. ibcbeg < 1 ) then
          c(2,n) = c(4,n)
          goto 140
        end if
        if ( n <= 3 .and. ibcbeg < 1 .or. n <= 2 ) then
!
! Either (N=3 and not-a-knot also at left) or (N=2 and not not-a-
! knot at left end point).
!
          c(2,n) = 2.0*c(4,n)
          c(4,n) = 1.0
          g = 1.0
        else
!
! Not-a-knot and N >= 3, and either M > 3 or also not-a-knot at
! left end point.
!
          g = c(3,n-1) + c(3,n)
          r = c(3,n) * c(3,n)
          c(2,n) = ((c(3,n)+2.0*g)*c(4,n)*c(3,n-1) +     &
         &           r*(c(1,n-1)-c(1,n-2))/c(3,n-1)) / g
          c(4,n) = c(3,n-1)
        end if
      end if
      g = -g/c(4,n-1)
!
! Complete forward pass of gauss elimination.
!
      c(4,n) = g*c(3,n-1) + c(4,n)
      c(2,n) = (g*c(2,n-1) + c(2,n))/c(4,n)
    end if
!
! Carry out back substitution
!
140 do j = l, 1, -1
      c(2,j) = (c(2,j) - c(3,j)*c(2,j+1))/c(4,j)
    end do
!
!****** Generate cubic coefficients in each interval, i.e., the deriv's
!  at its left endpoint, from value and slope at its endpoints.
!
    do i = 2, n
      dtau = c(3,i)
      divdf1 = (c(1,i) - c(1,i-1))/dtau
      divdf3 = c(2,i-1) + c(2,i) - 2.0*divdf1
      c(3,i-1) = 2.0*(divdf1 - c(2,i-1) - divdf3)/dtau
      c(4,i-1) = (divdf3/dtau)*(6.0/dtau)
    end do
!
! end subroutine ?_PCSPL
