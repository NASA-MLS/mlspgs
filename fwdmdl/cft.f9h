! subroutine ?CFT (A, MODE, M, ND, MS, S)
!>> 1997-03-31 DCFT Krogh  Increased KEDIM, more sine table checks.
!>> 1994-10-20 DCFT Krogh  Change CERROR to simplify conversion to C.
!>> 1994-10-20 DCFT Krogh  Changes to use M77CON
!>> 1994-04-19 DCFT CLL Edited to make DP & SP files similar.
!>> 1989-06-16 FTK Fix error message on MODE.
!>> 1989-06-05 WVS Change length of MODE from *(ND) to *(*).
!>> 1989-05-07 FTK & CLL
!>> 1989-04-21 FTK & CLL
!     .  Copyright (C) 1989, California Institute of Technology.
!     .  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.
!
!     This subroutine computes complex Fourier transforms in up to 6
!     dimensions using the Cooley-Tukey fast Fourier transform.
!
!     Variables in the calling sequence have the following types.
    real(rk), intent(inout) ::      A(*), S(*)
    integer, intent(in) ::          ND, M(ND)
    integer, intent(inout) ::       MS
    character(len=*), intent(in) :: MODE
!
!     Programmed by Fred T. Krogh at the Jet Propulsion Laboratory,
!     Pasadena, Calif.   August 1, 1969.
!
!     Values for A, MODE, M, ND, and MS must be specified before
!     calling the subroutine.
!
!     In describing the usage the following notation is used
!     N(K) = 2**M(K)
!     WK = EXP(2*PI*I/N(K)), where I = sqrt(-1) and PI = 3.14159...
!     MA = M(1) + M(2) + ... + M(ND)
!     NA = 2**MA
!     MX = MAX(M(1), M(2), ..., M(ND))
!     NX = 2**MX
!
! The usage is as follows
!
! A() on input is an array of function values, X, if one is doing
!   Fourier analysis, and is an array of Fourier coefficients, C, if one
!   is doing Fourier synthesis.  On output, A contains C if doing
!   analysis, and contains X if doing synthesis.  In our description
!   here, we assume that A has been declared by the user as a complex
!   array with dimension A(N(1),N(2),...,N(ND)). (Of course this is not
!   necessary as long as one declares enough storage for A, and keeps in
!   mind that the array is treated in this subroutine as if it had been
!   specified in this way.)  It is assumed that the imaginary part of a
!   complex number is stored in the cell immediately following its real
!   part.
!
! MODE  A character variable of length at least ND.
!   The k-th character must be 'A' or 'a' to select Analysis in the
!   k-th dimension, or 'S' or 's' to select Synthesis in the
!   k-th dimension.
!   The subroutine sets  A(j1+1, j2+1, ..., jND+1) to the sum
!  over 0 <= k1 <= N(1)-1, 0 <= k2 <= N(2)-1, ...,
!  0 <= kND <= N(ND)-1 of A(k1+1, k2+1, ..., kND+1) * T(1,j1,k1) *
!  T(2,j2,k2) * ... * T(ND,jND,kND), 0 <= j1 <= N(1)-1, ...,
!  0 <= jnd <= N(ND)-1
!  with T(L,j,k) =
!        WL ** (j*k)               if MODE(L:L) = 'S' or 's'
!        (1/N(L)) * WL ** (-j*k)   if MODE(L:L) = 'A' or 'a'
!
! M() is a vector used to indicate N(k) = 2**M(k), the number of
!  complex points in the k-th variable.  M must be such that MX < 21.
!  If M(L)=0, no change is made with respect to the L-th dimension.
!
! ND is the dimension of (i.e. the number of subscripts in) the
!    array A.  ND must satisfy 1 <= ND <= 6
!
! MS gives the state of the sine table.  If MS > 0, there are NT =
!    2 ** (MS-2) good entries in the sine table.  On the initial call,
!    MS must be set to 0, and when the return is made, it will be set
!    to MX, which is the value of MS required for computing a
!    transform of size NX.  If MS = -1, the sine table will be computed
!    as for the case MS = 0, and then a return to the user will be made
!    with MS set as before, but no transform will be computed.  This
!    option is useful if the user would like access to the sine table
!    before computing the FFT.
!
! S is a vector, S(j) = sin(pi*j/(2*NT)), j = 1, 2, ..., NT-1, where
!  NT is defined in the description of MS above.  S is computed by the
!  subroutine if MX > MS.  (If S is altered, set MS=0 so that S
!  is recomputed.)
!     ------------------------------------------------------------------
!                Notes on PARAMETERs, and variables
!
!     NDMAX = the maximum value for ND, and MAXM = the maximum
!     permitted for M(1), ..., M(ND)
!     The dimension of KE must be at least as large as MAXM.
!
!     NF(1) = 2, NF(K+1) = 2**(1+M(1)+...+M(K)), K = 1,..., ND
!     ------------------------------------------------------------------
!--D replaces "?": ?CFT, ?FFT
!     Both versions use ERM1
!     ------------------------------------------------------------------
    integer, parameter :: NDMAX = 6

    character(len=13) :: CERROR = 'MODE(K:K) =  '
    real(rk) :: FN
    integer :: I, II, IIC, IR, IRC
    integer :: J, JL
    integer :: K, KSM
    integer :: L
    integer :: MA
    integer, parameter :: MAXM = KEDIM
    character(len=*), parameter :: ME = prec//'CFT'
    integer ::MMAX, MSI
    integer :: NDD
    integer :: NF(NDMAX+1), NTOT2
    real(rk), parameter :: ONE = 1.0_rk

!---------------------------- RCS Ident Info -------------------------------
  CHARACTER (LEN=256) :: Id = &
       "$Id$"
  CHARACTER (LEN=*), PARAMETER :: ModuleName= "$RCSfile$"
!---------------------------------------------------------------------------
!
!     ------------------------------------------------------------------
!
    ndd = nd
    if ((ndd <= 0) .or. (ndd > ndmax)) then
!                            fatal error, default is to stop in erm1
      call erm1 (me, 1, 2, 'Bad ND', 'ND', ND, '.')
      ms = -2
      return
    end if
    nf(1) = 2
    ma = 0
    mmax = 0
    fn = one
    do k = 1, ndd
       mm = m(k)
       mmax = max(mm, mmax)
       ma = ma + mm
       i = 2**mm
       if ((mm < 0) .or. (mm > maxm)) then
!                             Fatal error, default is to stop in ERM1
       call erm1(me,2,2,'Need 0 <= M(K) <= 30','M(K)',MM,'.')
       ms = -2
       return
       end if
       nf(k+1) = nf(k) * i
       if (mode(k:k) == 'a' .or. mode(k:k) == 'a') then
         fn = fn / i
       else if (mode(k:k) /= 's' .and. mode(k:k) /= 's') then
         cerror(13:13) = mode(k:k)
         call erm1 (me,3,2,cerror, 'for K =',K,'.')
         ms = -2
         return
       end if
    end do
    msi = ms
    needst = mmax > msi
    if (.not. needst) then
!   Check internal parameters to catch certain user errors.
      if (mt < kedim) then
        if (mmax <= mt + 2) then
!         Skip sine table computation if all appears O.K.
          if (mt <= 0) go to 20
          if (abs(s(nt/2) - spi4) <= 1.d-7) go to 20
        end if
      end if
      needst = .true.
      call ermsg(prec//'RFT1', 3, 1,'Invalid sine table (re)computed', '.')
    end if
    ms = mmax
    mt = mmax - 2
    call fft (a, a, s)
    if (msi == -1) return
!                 All set up for computation now
 20 ntot2 = nf(ndd+1)
    if (fn /= one) then
      do i = 1, ntot2
        a(i) = a(i) * fn
      end do
    end if
!   Beginning of loop for computing multiple sum
    do k = 1, ndd
      if(mode(k:k) == 'A' .or. mode(k:k) == 'a') then
        irc = 1
        iic = 0
      else
        irc = 0
        iic = 1
      end if
      mm = m(k)
      ks = nf(k)
      ksm = ks - 1
      ilast = nf(k+1)
      do l = 1, mm
        kee(l+1) = kee(l) / 2
      end do
      do j = 1, ntot2, ilast
        jl = j + ksm
        do i = j, jl, 2
          ir = i + irc
          ii = i + iic
          call fft (a(ir:2*nd), a(ii:2*nd), s)
        end do
      end do
    end do
    return
!        End of loop for computing multiple sum
!
! end subroutine ?CFT

! $Log$
