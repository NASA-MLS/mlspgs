! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! subroutine Interpolate_Regular_To_Irregular_r* ( XOld, YOld, ZOld, &
!   & XNew, YNew, ZNew )
    ! Given XOld, YOld, ZOld, XNew, YNew, interpolate to ZNew.
    ! The shape of ZOld must be (size(xOld),size(yOld)).
    ! The shape of ZNew must be the same as Xnew and Ynew
    ! The only method supported is linear with constant extrapolation.
!   real(rk), intent(in) :: XOld(:)
!   real(rk), intent(in) :: YOld(:)
!   real(rk), intent(in) :: ZOld(:,:)
!   real(rk), intent(in) :: XNew(:,:), YNew(:,:)
!   real(rk), intent(out) :: ZNew(:,:)

  real(rk) :: DX(2), DY(2) ! Interpolation factors.  Xi, Eta in wvs-083.
  integer, dimension(merge(0,size(zNew,1),size(xOld)==1),size(zNew,2)) :: HX, HY
  integer :: I, IX, IY, J

  ! Unlike the Interpolate_2d_Composite case, there is no point to
  ! precompute a coefficients array and use it in each loop because the
  ! coordinates in xNew are unique.

  if ( size(xOld) == 1 ) then
    ! Interpolate the only column of zOld onto every column of zNew.
    ! There's only one X with one column of zOld, so we only interpolate in Y
    do i = lbound(yNew,1), uBound(yNew,1)
      call interpolateValues ( yOld, zOld(:,1), yNew(i,:), zNew(i,:), &
        & Method='Linear', Extrapolate='Constant' )
    end do
  else
    ! Get hunt indices
    do j = 1, size(xNew,2)
      call hunt ( xOld, xNew(:,j), hx(:,j), allowTopValue=.true., allowBelowValue=.true. )
    end do
    do i = 1, size(yNew,1)
      call hunt ( yOld, yNew(i,:), hy(i,:), allowTopValue=.true., allowBelowValue=.true. )
    end do
    ! Interpolate to zNew.  See wvs-083.  zOld here is z^T in wvs-083.
    do i = 1, size(xNew,1)
      do j = 1, size(xNew,2)
        ix = hx(i,j)
        iy = hy(i,j)
        if ( ix < 1 ) then
          dx(1) = 1 ! Constant extrapolation
        else if ( ix > size(xOld) ) then
          dx(1) = 0 ! Constant extrapolation
        else
          dx(1) = ( xNew(i,j) - xOld(ix) ) / ( xOld(ix+1) - xOld(ix) )
        end if
        if ( iy < 1 ) then
          dy(1) = 1 ! Constant extrapolation
        else if ( iy > size(yOld) ) then
          dy(1) = 0 ! Constant extrapolation
        else
          dy(1) = ( yNew(i,j) - yOld(iy) ) / ( yOld(iy+1) - yOld(iy) )
        end if
        dx(2) = 1.0 - dx(1)
        dy(2) = 1.0 - dy(1)
        ix = max(1, min(ix, size(xOld)-1) ) ! Constant extrapolation
        iy = max(1, min(iy, size(yOld)-1) ) ! Constant extrapolation
        zNew(j,i) = &
          & dy(1) * ( dx(1) * zOld(iy,ix)   + dx(2) * zOld(iy,ix+1)   ) + &
          & dy(2) * ( dx(1) * zOld(iy+1,ix) + dx(2) * zOld(iy+1,ix+1) )
      end do
    end do

  end if

! end subroutine Interpolate_Regular_To_Irregular_r*

! $Log$
! Revision 1.2  2013/02/01 21:25:09  vsnyder
! Correct incorrect subscript order for zOld, zNew
!
! Revision 1.1  2012/12/20 01:02:39  vsnyder
! Initial commit
!
