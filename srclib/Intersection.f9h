! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

  ! ---------------------------------------------  Intersection  -----
  ! This family of routines finds the intersection between
  ! two sets represented by arrays

  ! function IntersectionCharacter ( A, B, options ) result ( C )
    ! method:
    ! Go though a, checking for each element whether a match is found in (b)
    ! If  so found, add the element
    ! options, if present, can modify this behavior: 
    !   char    effect
    !  ------   ------
    !    r      The set of elements in a or b but not in both
    !            which is Union(A, B) - Intersection(A, B)
    !    c      The set of elements in a but not in b
    !            which is A - B, or as our notation has it, RC ( B, A )
    ! The 'c' option exists only to allow the family of functions
    ! to be reused internally for finding the relative complement of two sets
  
    ! use MLSMessageModule, only: MLSMessage, MLSMSG_Allocate, MLSMSG_Error

    ! character(len=*), dimension(:), intent(in) :: A(:), B(:)
    ! character(len=len(a)), dimension(:), pointer :: C(:) ! Intent(out) -- nullified and then allocated here
    ! character(len=*), optional, intent(in) :: options
    ! Local variables
    ! integer :: i, j, size_c, status
    ! character(len=len(a)), dimension(size(a)+size(b)) :: TC
    ! logical :: myComplement
    ! logical :: myReverse
    ! logical :: stdIntersection
    
    ! Executable
    myComplement = .false.
    myReverse = .false.
    if ( present(options) ) myComplement = index( options, 'c' ) > 0
    if ( present(options) ) myReverse = index( options, 'r' ) > 0
    stdIntersection = .not. (myComplement .or. myReverse )
    size_c = 0
    do i=1, size(a)
      ! Don't redo a repeated element
      if ( i > 1 ) then
        j = findFirst( a(:i-1), a(i) )
        if ( j > 0 ) cycle
      endif
      j = findFirst( b, a(i) )
      if ( (stdIntersection .and. j > 0) .or. &
        & (.not. stdIntersection .and. j < 1) ) then
        size_c = size_c + 1
        TC(size_c) = a(i)
      endif
    enddo
    ! Now switch to looping over B
    if ( myReverse ) then
      do i=1, size(b)
        ! Don't redo a repeated element
        if ( i > 1 ) then
          j = findFirst( b(:i-1), b(i) )
          if ( j > 0 ) cycle
        endif
        j = findFirst( a, b(i) )
        if ( j < 1 ) then
          size_c = size_c + 1
          TC(size_c) = b(i)
        endif
      enddo
    endif
    c = tc(:size_c)
!  end function IntersectionCharacter
! $Log$
! Revision 1.3  2017/03/10 00:41:56  vsnyder
! Make result of Intersection allocatable
!
! Revision 1.2  2012/12/04 17:23:45  pwagner
! Consistent with new api
!
! Revision 1.1  2008/11/24 19:24:16  pwagner
! First commit
!
