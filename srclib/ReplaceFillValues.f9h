! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$
!   subroutine ReplaceFill* ( values, FillValue, newValues, newFill, options )
!     real(r8), dimension(:, :, :), intent(inout) :: values
!     real(r8), intent(in) :: FillValue
!     real(r8), dimension(:, :, :), optional, intent(in) :: newvalues
!     real(r8), optional, intent(in) :: newFill
!     character(len=*), optional, intent(in) :: options
!     !
!     ! Local variables

  ! local working space
   character(len=8) :: myOptions
   myOptions = ''
   if ( present(options) ) myOptions = lowercase(options)
   DONTINTERPOLATE = .false.
   ! So far the only options I can think of are
   ! -n : replace fillValues and also any < 0
   ! -p : replace fillValues and also any > 0
   ! -i : interpolate between non-fill values
   ! -s : "stutter': repeating neighboring non-fill values to replace Fills
   ! -u : interpolate between non-monotonically increasing values
   ! -d : interpolate between non-monotonically decreasing values
   ! 1st: handle 'n' and 'p' options by replacing candidate values,
   ! < 0 or > 0, as the case may be, with Fill values
   if ( index(myOptions, 'n') > 0 ) then
     where (values < 0.0)
       values = FillValue
     end where
   endif
   if ( index(myOptions, 'p') > 0 ) then
     where (values > 0.0)
       values = FillValue
     end where
   endif
   ! Do we bridge the chassm by interpolating across?
   if ( index(myOptions, 'i') > 0 ) then
      call BridgeMissingValues(values, FillValue)
      return
   endif
   ! Do we bridge the chassm by stuttering across?
   if ( index(myOptions, 's') > 0 ) then
      DONTINTERPOLATE = .true.
      call BridgeMissingValues(values, FillValue)
      DONTINTERPOLATE = .false.
      return
   endif
   ! Do we monotonize 'u'pward or 'd'ownward?
   if ( index(myOptions, 'u') > 0 ) then
      call Monotonize(values)
      return
   endif
   if ( index(myOptions, 'd') > 0 ) then
      values = - values
      call Monotonize(values)
      values = - values
      return
   endif
   ! Do we replace the Fill values with replacements we supply somehow?
   if ( present(newValues) ) then
     if ( any( shape(values) /= shape(newValues) ) ) &
      & call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Arrays in ReplaceFillValues must have same shapes" )
     where (values == FillValue)
       values = newValues
     end where
   elseif ( present(newFill) ) then
     where (values == FillValue)
       values = newFill
     end where
   else
      call MLSMessage ( MLSMSG_Error, &
      & ModuleName, "Either newValues or newFill must be supplied in ReplaceFillValues" )
   endif
! end subroutine ReplaceFill*

! $Log$
! Revision 1.3  2005/08/15 20:37:07  pwagner
! -u and -d monotonize options now recognized
!
! Revision 1.2  2005/08/05 20:35:26  pwagner
! ReplaceFillValues can now to interpolate to bridge across MissingValues
!
! Revision 1.1  2005/08/03 16:35:16  pwagner
! First commit
!
