! Copyright (c) 2004, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

! $Id$

!  subroutine HuntArray_r* ( list, values, indices, start, allowTopValue, allowBelowValue, &
!    & nearest )
    ! Local variables
    real(rk) :: thisValue
    real(rk) :: logThisValue
    integer :: listLen, valuesLen       ! Array sizes
    integer :: valueIndex               ! Loop counters
    integer :: index                    ! Temporary result
    integer :: alternativeIndex         ! Used in 'nearest' case
    integer :: originalIndex            ! Used in 'nearest' case

    logical :: useAllowTopValue, useAllowBelowValue, useNearest, useLogSpace
    logical :: wentUp, wentDown         ! Flags
    integer :: useStart
    integer :: upperLimit       ! Highest value that can be returned
    integer :: stride           ! Value to step by
    logical :: expanding        ! Whether we're expanding or reducing our search
    logical :: lowerBelow       ! Flag
    logical :: upperAbove       ! Another flag

    integer :: listDirection    ! +1 if list ascends, -1 descends
    integer :: searchDirection  ! (in index space) 
    integer :: oldSearchDirection ! Previous value of above
    integer :: oldIndex                 ! Previous value of index


    ! Executable code

    if ( present(allowTopValue) ) then
      useAllowTopValue = allowTopValue
    else
      useAllowTopValue = .false.
    end if

    if ( present(allowBelowValue) ) then
      useAllowBelowValue = allowBelowValue
    else
      useAllowBelowValue = .false.
    end if

    if ( present(nearest) ) then
      useNearest = nearest
    else
      useNearest = .false.
    end if

    if ( present(logSpace) ) then
      useLogSpace = logSpace
    else
      useLogSpace = .false.
    end if

    if ( present(start) ) then
      useStart = start
    else
      useStart = 1
    end if

    listLen = size(list)
    valuesLen = size(values)
    if ( useNearest .and. useAllowBelowValue ) then
      call dump(values, 'values')
      call dump(list, 'list')
      call MLSMessage ( MLSMSG_Error, &
        & ModuleName, "Can't set nearest and allowBelowValue in Hunt" )
    elseif ( size(indices) < valuesLen ) then
      call dump(values, 'values')
      call dump(list, 'list')
      call MLSMessage ( MLSMSG_Error, ModuleName, &
        & "Result array is too small" )
    endif

    ! Try to work out the direction, also skip if there's only one value

    if ( size(list) == 0 ) then
      indices = 0
      return
    else if ( size(list) == 1 ) then
      indices = 1
      if ( useAllowBelowValue ) then
        where ( values < list(1) )
          indices = 0
        end where
      end if
      return
    else
      if ( list(size(list)) >= list(1) ) then
        listDirection = 1
      else
        listDirection = -1
      end if
    end if

    ! Some last bits of setup before we get going.

    if ( useAllowTopValue ) then
      upperLimit = listLen
    else
      upperLimit = listLen-1
    end if

    ! Now we're ready to hit the road, loop over all the values to hunt for

    index = max(1,min(useStart,upperLimit))
    do valueIndex = 1, valuesLen
      thisValue = values(valueIndex)
      expanding = .true.
      searchDirection = 0
      stride = 1
      HuntLoop: do
        oldIndex = index
        lowerBelow= (thisValue-list(index))*listDirection >= 0.0
        if ( index<listLen ) then 
          upperAbove = (list(index+1)-thisValue)*listDirection > 0.0
        else ! We're off the end of the list
          upperAbove = .true.   
        end if

        ! Now we know what the state of play is, what does it mean?

        ! First see if we've found the place
        if ( lowerBelow .and. upperAbove ) exit HuntLoop

        ! The other cases are a little more complex
        oldSearchDirection = searchDirection

        if ( lowerBelow .and. (.not. upperAbove) ) then
          ! If we're at the end, get out
          if ( index == upperLimit ) exit HuntLoop
          ! We're too low, keep looking upwards
          index = index+stride
          searchDirection = 1
        end if

        if ( (.not. lowerBelow) .and. upperAbove ) then
          ! If we're at the begning, get out
          if ( index == 1 ) exit HuntLoop

          ! We're too high but not at begining, look back downwards
          index = index-stride
          searchDirection = -1
        end if

        if ( (.not. lowerBelow) .and. (.not. upperAbove) ) then
          ! The list is really screwey
          call dump(values, 'values')
          call dump(list, 'list')
          call MLSMessage ( MLSMSG_Error, ModuleName, &
            & 'List out of order in Hunt (case 1)' )
        end if
        
        ! Now the very first change of direction is the end of the
        ! `expanding' phase

        if ( (searchDirection /= oldSearchDirection) .and. &
          & (oldSearchDirection /= 0) .and. (expanding) ) &
          & expanding = .false.

        if ( expanding ) then
          stride = min ( stride*2, listLen/2 )
        else
          stride = max ( stride/2, 1)
        end if

        ! Make sure we don't fall off an end
        index = min(max(index,1),upperLimit)

        ! Now check the list hasn't reversed direction
        wentUp =   ( list(index) - list(oldIndex) ) * listDirection > 0.0
        wentDown = ( list(index) - list(oldIndex) ) * listDirection < 0.0
        if ( ( searchDirection == 1  .and. wentDown ) .or. &
          &  ( searchDirection == -1 .and. wentUp ) ) then
           call dump(values, 'values')
           call dump(list, 'list')
           ! print*, 'valueIndex ', valueIndex
           ! print*, 'thisValue ', thisValue
           ! print*, 'lowerBelow ', lowerBelow
           ! print*, 'upperAbove ', upperAbove
           ! print*, 'searchDirection ', searchDirection
           ! print*, 'listDirection ', listDirection
           ! print*, 'oldindex ', oldindex
           ! print*, 'list(oldindex) ', list(oldindex)
           ! print*, 'index ', index
           ! print*, 'list(index) ', list(index)
           call MLSMessage ( MLSMSG_Error, ModuleName, &
             & 'List out of order in Hunt (case 2)' )
        endif
      end do HuntLoop

      ! If user asked for nearest then check to see if one above is closer
      originalIndex = index
      if ( useNearest ) then
        alternativeIndex = index
        ! Look for the next higher value
        nearestLoop: do
          if ( alternativeIndex >= upperLimit ) exit nearestLoop
          alternativeIndex = alternativeIndex + 1
          if ( list(alternativeIndex) > list(index) ) exit nearestLoop
        end do nearestLoop
        ! If this is closer, use it
        if ( useLogSpace ) then
          ! Check for errors in log space case
          if ( any ( (/ list(index), list(alternativeIndex), thisValue /) &
            &                    <= 0.0 ) ) then
            call dump(values, 'values')
            call dump(list, 'list')
            call MLSMessage ( MLSMSG_Error, ModuleName, &
              & 'Non positive value in logSpace nearest hunt' )
          endif
          logThisValue = log ( thisValue )
          if ( abs ( log ( list(alternativeIndex) ) - logThisValue ) < &
            &  abs ( log ( list(index) ) - logThisValue ) ) then
            index = alternativeIndex
          end if
        else
          if ( abs ( list(alternativeIndex) - thisValue ) < &
            &  abs ( list(index) - thisValue ) ) then
            index = alternativeIndex
          end if
        end if
      end if

      ! Final check for off the bottom of the list

      if ( useAllowBelowValue ) then
        if ( (thisValue-list(index))*listDirection<0.0D0) index = 0
      end if

      indices(valueIndex) = index

      ! In the 'nearest' case it might make sense to check from the
      ! originalIndex
      index = originalIndex
    end do
! end subroutine HuntArray_r*

! $Log$
! Revision 1.5  2004/09/10 23:52:13  livesey
! Added the logSpace option for nearest (turns out I didn't need it
! anyway but never mind!)
!
! Revision 1.4  2004/07/31 19:22:53  livesey
! Some checking against infiniate looping.
!
! Revision 1.3  2003/07/07 20:29:22  livesey
! Now handles zero length arrays
!
! Revision 1.2  2002/10/04 00:46:12  vsnyder
! Move declarations of local variables here
!
! Revision 1.1  2002/09/13 18:01:33  pwagner
! First commit
!
