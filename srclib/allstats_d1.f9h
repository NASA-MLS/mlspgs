! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$
!   subroutine allstats*( values, &
!        & nbins, bounds, addedData, fillValue, precision, &
!        & count, fillcount, min, max, mean, stddev, rms, median, bincount, &
!        & doDump )
        ! Args
        real(rk), dimension(:), intent(in)             :: values
        integer, optional, intent(in)                  :: nbins
        real(rk), dimension(2), optional, intent(in)   :: bounds
        logical, optional, intent(in)                  :: addeddata
        real(rk), optional, intent(in)                 :: fillValue
        real(rk), dimension(:), optional, intent(in)   :: precision
        integer, optional, intent(inout)               :: count
        integer, optional, intent(inout)               :: fillcount
        real(rk), optional, intent(out)                :: min
        real(rk), optional, intent(out)                :: max
        real(rk), optional, intent(out)                :: mean
        real(rk), optional, intent(out)                :: stddev
        real(rk), optional, intent(out)                :: rms
        real(rk), optional, intent(out)                :: median
        integer, dimension(:), optional, intent(out)   :: bincount
        logical , optional, intent(in)                 :: doDump
        ! Internal variables
        character(len=64)                              :: fields
        logical                                        :: myAddedData
        logical                                        :: myDump
        real(rk)                                       :: myRMS
        integer                                        :: ncells
        integer                                        :: n
        integer                                        :: nx
        real(rk), dimension(5)                         :: stats
        real(rk)                                       :: x1, x2
        real(rk), dimension(:), pointer                :: xtab => null()
        real(rk), dimension(:), pointer                :: xmed1 => null()
        real(rk), dimension(:), pointer                :: xmed2 => null()
        real(rk)                                       :: absMu, sigma
        ! logical, parameter :: DEEBUG = .true.
        ! Executable
        myDump = .false.
        if ( present(doDump) ) myDump = doDump
        ncells = 1
        if ( present(nbins) .and. present(bincount) ) ncells = nbins
        x1 = 1.
        x2 = 1.
        if ( present(bounds) ) then
          x1 = bounds(1)
          x2 = bounds(2)
        endif
        myAddedData = .false.
        if ( present(addedData) ) myAddedData = addedData
        if ( myAddedData ) then
          stats(1) = MLSStat%count
          stats(2) = MLSStat%min
          stats(3) = MLSStat%max
          stats(4) = MLSStat%mean
          stats(5) = MLSStat%stddev
          if ( DEEBUG ) then
          call output('Merging with existing stats count min max mean stddev ', advance='yes')
          call output(stats, advance='yes')
          endif
        else
          stats = 0  ! Reset count to start again
          MLSStat%Count = 0
          MLSStat%fillCount = 0
          if ( DEEBUG ) call output('Resetting counts to 0', advance='yes')
        endif
        if ( present(fillValue) ) then
          call filterValues(values, XTAB, NX, fillValue=fillValue)
          if ( DEEBUG ) then
            call outputNamedValue( 'shape(values)', shape(values) )
            call outputNamedValue( 'shape(xtab)', shape(xtab) )
            call outputNamedValue( 'nx', nx )
            call outputNamedValue( 'fillvalue', fillvalue )
            call outputNamedValue( 'fillvaluerelation', fillvaluerelation )
            call outputNamedValue( 'max(values)', maxval(values) )
            call outputNamedValue( 'min(values)', minval(values) )
            call outputNamedValue( 'count(values == fillvalue)', shcount(values == fillvalue) )
            call outputNamedValue( 'count(values /= fillvalue)', shcount(values /= fillvalue) )
          endif
          call STAT1(XTAB, NX, STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1 with fillvalue', advance='yes')
          MLSStat%fillCount = MLSStat%fillCount + size(values) - size(XTAB)
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( XTAB, NX, MLSStat%median )
          call Deallocate_test ( XTAB, 'XTAB', ModuleName )
        elseif ( present(precision) ) then
          call filterValues(values, XTAB, NX, precision=precision)
          call STAT1(XTAB, NX, STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1 with precision', advance='yes')
          MLSStat%fillCount = MLSStat%fillCount + size(values) - size(XTAB)
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( XTAB, NX, MLSStat%median )
          call Deallocate_test ( XTAB, 'XTAB', ModuleName )
        else
          call STAT1(values, size(values), STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1', advance='yes')
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( values, size(values), MLSStat%median )
        endif
        ! Side calculation in case we need rms
        n = stats(1)
        absMu = ABS(stats(4))
        sigma = stats(5)
        if ( n == 0 .or. (absMu == 0. .and. sigma == 0.) ) then
          myRMS = 0.
        elseif ( sigma < absMu ) then
          myRMS = absMu*sqrt( ((n-1.)/n)*(sigma/absMu)**2 + 1. )
        else
          myRMS = sigma*sqrt( ((n-1.)/n) + (absMu/sigma)**2 )
        endif
        if ( DEEBUG ) then
          call output( 'stats: ', advance='no' )
          call output( stats, advance='yes' )
        endif
!         call output('n: ')
!         call output(n, advance='yes')
!         call output('absMu: ')
!         call output(absMu, advance='yes')
!         call output('sigma: ')
!         call output(sigma, advance='yes')
!         call output('rms: ')
!         call output(myRMS, advance='yes')
        MLSStat%count  = stats(1)
        MLSStat%min    = stats(2)
        MLSStat%max    = stats(3)
        MLSStat%mean   = stats(4)
        MLSStat%stddev = stats(5)
        MLSStat%rms    = myRMS
        if ( present(count ) ) count  = stats(1)
        if ( present(fillcount) ) fillcount = MLSStat%fillcount
        if ( present(min   ) ) min    = stats(2)
        if ( present(max   ) ) max    = stats(3)
        if ( present(mean  ) ) mean   = stats(4)
        if ( present(stddev) ) stddev = stats(5)
        if ( present(rms   ) ) rms    = myRMS
        if ( present(median) ) median = MLSStat%median
        ! Have we been asked to dump the calculated stats?
        if ( .not. myDump ) return
        call output('Combined statistics')
        if ( present(fillValue) ) then
          call output(' (ignoring any fill values ')
          call output(fillvaluerelation // ' ')
          call output(fillValue)
          call output(')')
        endif
        if ( present(precision) ) then
          call output(' (ignoring any values where supplied precision < 0')
        endif
        call newline
        fields = ' '
        if ( present(count ) ) fields = catLists(fields, 'count')
        if ( present(min   ) ) fields = catLists(fields, 'min  ')
        if ( present(max   ) ) fields = catLists(fields, 'max  ')
        if ( present(mean  ) ) fields = catLists(fields, 'mean ')
        if ( present(stddev) ) fields = catLists(fields, 'stddev')
        if ( present(rms   ) ) fields = catLists(fields, 'rms  ')
        if ( present(median) ) fields = catLists(fields, 'median')
        if ( present(bincount) ) fields = catLists(fields, 'bin')
        if ( present(fillcount) ) fields = catLists(fields, 'fillcount')
        ! call output('fields: ' // trim(fields), advance='yes')
        call dump( MLSStat, fields )
contains
  subroutine FindMedian( array, N, median )
    ! Find the median of the values contained in array
    ! By either of two methods:
    ! (1) deleting both max and mins on successive paths; or
    ! (2) sorting the array
    ! Dummy args
    real(rk), dimension(:), intent(in) :: array
    integer, intent(in)                :: N
    real(r8), intent(out)              :: median
    ! Executable
    if ( medianmethod == 1 ) then
      call FindMedian_1( array, N, median )
    else
      call FindMedian_2( array, N, median )
    endif
  end subroutine FindMedian

  subroutine FindMedian_1( array, N, median )
    ! Find the median of the values contained in array
    ! Method:
    ! At each step, delete the high and low values of the array
    ! Until left with an array of length either 2 or 1
    ! (depending on whether the starting length was even or odd)
    ! The 1st element of this shrunken array is our median
    
    ! (If even, would you prefer to split: median = (x1 +x2)/2?)
    ! No, because then the median value wouldn't actually be in the array
    
    ! This method is so slow it's been superseded by method 2

    ! Dummy args
    real(rk), dimension(:), intent(in) :: array
    integer, intent(in)                :: N
    real(r8), intent(out)              :: median
    ! Local variables
    logical :: done
    integer, dimension(1) :: low, high
    integer :: newsize
    ! Executable
    nullify(xmed1, xmed2)
    call allocate_test( xmed1, N, 'xmed1', trim(Modulename) // '/FindMedian' )
    call allocate_test( xmed2, N, 'xmed2', trim(Modulename) // '/FindMedian' )
    xmed1(1:N) = array(1:N)
    newsize = N
    done = (N < 3)
    do
      if ( done ) exit
      low = minloc( xmed1(1:newsize) )
      high = maxloc( xmed1(1:newsize) )
      newsize = shrinkArray( xmed1(1:newsize), (/ low(1), high(1) /), xmed2 )
      xmed1 = xmed2
      done = (newsize < 3)
    enddo
    median = xmed1(1)
    call deallocate_test(xmed1, 'xmed1', trim(Modulename) // '/FindMedian' )
    call deallocate_test(xmed2, 'xmed2', trim(Modulename) // '/FindMedian' )
  end subroutine FindMedian_1

  subroutine FindMedian_2( array, N, median )
    ! Find the median of the values contained in array
    ! Method:
    ! sort he array, then choose its middle element
    
    ! Dummy args
    real(rk), dimension(:), intent(in) :: array
    integer, intent(in)                :: N
    real(r8), intent(out)              :: median
    ! Local variables
    real(rk), dimension(n)             :: sorted
    ! Executable
    if ( size(array) < 1 ) then
      return
    elseif ( size(array) < 3 ) then
      median = array(1)
    endif
    sorted = array(1:n)
    call sort(sorted, 1, n)
    median = sorted(n/2)
  end subroutine FindMedian_2
! end subroutine sllstats*

! $Log$
! Revision 1.5  2007/02/06 17:52:21  pwagner
! Correctly tracks fillcount
!
! Revision 1.4  2006/08/22 00:04:25  pwagner
! speedier median algorithm
!
! Revision 1.3  2006/07/11 00:25:44  pwagner
! Show relation of ignored fill values
!
! Revision 1.2  2006/03/08 17:10:48  pwagner
! Now finds median, too
!
! Revision 1.1  2006/02/01 23:43:24  pwagner
! First commit
!
