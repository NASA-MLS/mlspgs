! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$
!   subroutine allstats*( values, &
!        & nbins, bounds, addedData, fillValue, precision, &
!        & count, fillcount, min, max, mean, stddev, rms, median, &
!        & bincount, indexing, doDump )
        ! Args
        real(rk), dimension(:), intent(in)             :: values
        integer, optional, intent(in)                  :: nbins
        real(rk), dimension(2), optional, intent(in)   :: bounds
        logical, optional, intent(in)                  :: addeddata
        real(rk), optional, intent(in)                 :: fillValue
        real(rk), dimension(:), optional, intent(in)   :: precision
        integer, optional, intent(inout)               :: count
        integer, optional, intent(inout)               :: fillcount
        real(rk), optional, intent(out)                :: min
        real(rk), optional, intent(out)                :: max
        real(rk), optional, intent(out)                :: mean
        real(rk), optional, intent(out)                :: stddev
        real(rk), optional, intent(out)                :: rms
        real(rk), optional, intent(out)                :: median
        integer, dimension(:), optional, intent(out)   :: bincount
        integer, dimension(3), optional, intent(out)   :: indexing
        logical , optional, intent(in)                 :: doDump
        ! Internal variables
        character(len=64)                              :: fields
        logical                                        :: myAddedData
        logical                                        :: myDump
        real(rk)                                       :: myRMS
        integer                                        :: ncells
        integer                                        :: n
        integer                                        :: nx
        real(rk), dimension(FN_STDDEV)                 :: stats
        real(rk)                                       :: x1, x2
        real(rk), dimension(:), pointer                :: xtab => null()
        real(rk)                                       :: absMu, sigma
!        logical, parameter :: DEEBUG = .true.
        ! Executable
        myDump = .false.
        if ( present(doDump) ) myDump = doDump
        ncells = 1
        if ( present(nbins) .and. present(bincount) ) ncells = nbins
        x1 = 1.
        x2 = 1.
        if ( present(bounds) ) then
          x1 = bounds(1)
          x2 = bounds(2)
        endif
        myAddedData = .false.
        if ( present(addedData) ) myAddedData = addedData
        if ( myAddedData ) then
          stats(FN_COUNT ) = MLSStat%count
          stats(FN_MIN   ) = MLSStat%min
          stats(FN_MAX   ) = MLSStat%max
          stats(FN_MEAN  ) = MLSStat%mean
          stats(FN_STDDEV) = MLSStat%stddev
          if ( DEEBUG ) then
          call output('Merging with existing stats count min max mean stddev ', advance='yes')
          call output(stats, advance='yes')
          endif
        else
          stats = 0  ! Reset count to start again
          MLSStat%Count = 0
          MLSStat%fillCount = 0
          if ( DEEBUG ) call output('Resetting counts to 0', advance='yes')
        endif
        if ( present(fillValue) ) then
          call filterValues(values, XTAB, NX, fillValue=fillValue)
          if ( DEEBUG ) then
            call outputNamedValue( 'shape(values)', shape(values) )
            call outputNamedValue( 'shape(xtab)', shape(xtab) )
            call outputNamedValue( 'nx', nx )
            call outputNamedValue( 'fillvalue', fillvalue )
            call outputNamedValue( 'fillvaluerelation', fillvaluerelation )
            call outputNamedValue( 'max(values)', maxval(values) )
            call outputNamedValue( 'min(values)', minval(values) )
            call outputNamedValue( 'count(values == fillvalue)', shcount(values == fillvalue) )
            call outputNamedValue( 'count(values /= fillvalue)', shcount(values /= fillvalue) )
          endif
          call STAT1(XTAB, NX, STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1 with fillvalue', advance='yes')
          MLSStat%fillCount = MLSStat%fillCount + size(values) - size(XTAB)
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( XTAB, NX, MLSStat%median )
          call Deallocate_test ( XTAB, 'XTAB', ModuleName )
        elseif ( present(precision) ) then
          call filterValues(values, XTAB, NX, precision=precision)
          call STAT1(XTAB, NX, STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1 with precision', advance='yes')
          MLSStat%fillCount = MLSStat%fillCount + size(values) - size(XTAB)
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( XTAB, NX, MLSStat%median )
          call Deallocate_test ( XTAB, 'XTAB', ModuleName )
        else
          call STAT1(values, size(values), STATS, bincount, NCELLS, X1, X2)
          if ( DEEBUG ) call output('Back from stat1', advance='yes')
          ! Find median (only if not adding data)
          if ( .not. myAddedData ) call FindMedian( values, size(values), MLSStat%median )
        endif
        ! Side calculation in case we need rms
        n = stats(1)
        absMu = ABS(stats(4))
        sigma = stats(5)
        if ( n == 0 .or. (absMu == 0. .and. sigma == 0.) ) then
          myRMS = 0.
        elseif ( sigma < absMu ) then
          myRMS = absMu*sqrt( ((n-1.)/n)*(sigma/absMu)**2 + 1. )
        else
          myRMS = sigma*sqrt( ((n-1.)/n) + (absMu/sigma)**2 )
        endif
        if ( DEEBUG ) then
          call output( 'stats: ', advance='no' )
          call output( stats, advance='yes' )
        endif
        MLSStat%count  = stats(FN_COUNT )
        MLSStat%min    = stats(FN_MIN   )
        MLSStat%max    = stats(FN_MAX   )
        MLSStat%mean   = stats(FN_MEAN  )
        MLSStat%stddev = stats(FN_STDDEV)
        MLSStat%rms    = myRMS
        if ( .not. myAddedData ) then
          if ( DEEBUG ) then
            call output( 'shape(values) ', advance='no' )
            call output( shape(values), advance='yes' )
            call output( 'shape(indexing) ', advance='no' )
            call output( shape(MLSStat%indexing), advance='yes' )
          endif
          MLSStat%indexing(1) = FindFirst( values == stats(3) )
          MLSStat%indexing(2) = FindFirst( values == stats(2) )
          MLSStat%indexing(3) = FindFirst( values == real(MLSStat%median,rk) )
          if ( DEEBUG ) then
            call output( 'locations of max, min, median: ', advance='no' )
            call output( MLSStat%indexing, advance='yes' )
          endif
        endif
        if ( present(fillcount) ) fillcount = MLSStat%fillcount
        if ( present(count ) ) count  = stats(FN_COUNT )
        if ( present(min   ) ) min    = stats(FN_MIN   )
        if ( present(max   ) ) max    = stats(FN_MAX   )
        if ( present(mean  ) ) mean   = stats(FN_MEAN  )
        if ( present(stddev) ) stddev = stats(FN_STDDEV)
        if ( present(rms   ) ) rms    = myRMS
        if ( present(median) ) median = MLSStat%median
        if ( present(indexing) ) indexing = MLSStat%indexing
        ! Have we been asked to dump the calculated stats?
        if ( .not. myDump ) return
        call output('Combined statistics', advance='no' )
        if ( present(fillValue) ) then
          call output(' (ignoring any fill values ', advance='no' )
          call output(fillvaluerelation // ' ', advance='no' )
          call output(fillValue, advance='no' )
          call output(')', advance='no' )
        endif
        if ( present(precision) ) then
          call output(' (ignoring any values where supplied precision < 0', advance='no' )
        endif
        call newline
        fields = ' '
        if ( present(count ) ) fields = catLists(fields, 'count')
        if ( present(min   ) ) fields = catLists(fields, 'min  ')
        if ( present(max   ) ) fields = catLists(fields, 'max  ')
        if ( present(mean  ) ) fields = catLists(fields, 'mean ')
        if ( present(stddev) ) fields = catLists(fields, 'stddev')
        if ( present(rms   ) ) fields = catLists(fields, 'rms  ')
        if ( present(median) ) fields = catLists(fields, 'median')
        if ( present(bincount) ) fields = catLists(fields, 'bin')
        if ( present(indexing) ) fields = catLists(fields, 'indexing')
        if ( present(fillcount) ) fields = catLists(fields, 'fillcount')
        ! call output('fields: ' // trim(fields), advance='yes')
        call dump( MLSStat, fields )
contains
  subroutine FindMedian( array, N, median )
    ! Find the median of the values contained in array(1:N)
    ! Method:
    ! sort he array, then choose its middle element
    
    ! Dummy args
    real(rk), dimension(:), intent(in) :: array
    integer, intent(in)                :: N
    real(r8), intent(out)              :: median
    ! Local variables
    real(rk), dimension(n)             :: sorted
    ! Executable
    if ( size(array) < 1 ) then
      return
    elseif ( size(array) < 3 .or. N < 3 ) then
      median = array(1)
      return
    endif
    sorted = array(1:n)
    call sort(sorted, 1, n)
    ! The index should be the middle element if n is odd
    ! and the smaller of the two middle elements if n is even
    ! E.g., the median of [1,2,..,99] is 50
    ! ans so is the median of [1,2,..,100] (and not 50.5 or 51 or ..]
    median = sorted( (n+1)/2  )
  end subroutine FindMedian
! end subroutine sllstats*

! $Log$
! Revision 1.12  2012/06/22 20:27:44  pwagner
! Specify advance arg because we may now set default to 'yes'
!
! Revision 1.11  2011/07/27 00:04:11  pwagner
! Removed obsolete code; use FN_names to enumerate stats array
!
! Revision 1.10  2007/10/24 23:56:11  pwagner
! Changed name of component to 'indexing'
!
! Revision 1.9  2007/10/24 00:19:06  pwagner
! Added mindexes component to MLSStat to hold index of max, min, median
!
! Revision 1.8  2007/08/23 22:15:40  pwagner
! Fixed another bug in median computation
!
! Revision 1.7  2007/07/18 00:07:46  pwagner
! Fixed bug afflicting median when array has length 1
!
! Revision 1.6  2007/03/07 21:00:34  pwagner
! Some small changes unrelated to real bugs elsewhere
!
! Revision 1.5  2007/02/06 17:52:21  pwagner
! Correctly tracks fillcount
!
! Revision 1.4  2006/08/22 00:04:25  pwagner
! speedier median algorithm
!
! Revision 1.3  2006/07/11 00:25:44  pwagner
! Show relation of ignored fill values
!
! Revision 1.2  2006/03/08 17:10:48  pwagner
! Now finds median, too
!
! Revision 1.1  2006/02/01 23:43:24  pwagner
! First commit
!
