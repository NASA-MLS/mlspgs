! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

!  subroutine InterpolateUsingSetup_r* ( coeffs, oldX, oldY, newX, newY, &
!    & method, extrapolate, badValue, missingRegions, dyByDx, skipNewY, IntYdX )
    ! Local variables
    real(rk) :: Fill               ! Fill value for dyByDx or intYdX
    character :: extrapolateMethod ! Tidy copy of extrapolate parameter
    integer :: ind, col            ! Loop counters
    real(rk), dimension(:,:), pointer :: oldSecond
    real(rk), dimension(:,:), pointer :: oldSecondLower
    real(rk), dimension(:,:), pointer :: oldSecondUpper
    real(rk), dimension(:,:), pointer :: oldYlower
    real(rk), dimension(:,:), pointer :: oldYupper
!   real(rk), dimension(size(newX,1),size(oldY,2)) :: oldYlower, oldYupper
    integer :: noOld, noNew, width ! Dimensions
    real(rk) :: p                  ! For second derivative guesser
    real(rk) :: R1, R2             ! Ratios of oldY/oldX
    logical :: spline              ! Flag
    real(rk), dimension(:,:), pointer :: temp ! For 2nd der. guess
    logical :: useMissingRegions   ! Copy of missing regions
    logical :: doNewY              ! Not skipNewY (or true if absent)

    ! Executable code

    nullify ( oldSecond, oldSecondLower, oldSecondUpper, temp )
    nullify ( oldYlower, oldYupper )

    ! Size the problem, check sanity, set up arrays etc.

    noOld=size(oldX,1)
    noNew=size(newX,1)
    width=size(oldY,2)

    extrapolateMethod="A"
    if ( present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))

    doNewY = .true.
    if ( present(skipNewY)) doNewY = .not. skipNewY

    ! Special case where only one input point
    if ( noOld == 1 ) then
      ! If extrapolating allowed or clamped, out values same as in
      if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
        if ( doNewY ) then
          do ind = 1, noNew
            newY(ind,:) = oldY(1,:)
          end do
        end if
        ! Note these next two aren't totally gracefull with respect to 
        ! the missingRegions flag.
        if ( present(dyByDx) ) dyByDx = 0.0
      else
        ! Else extrapolation forbidden
        do ind = 1, noNew
          if ( newX(ind) == oldX(1) ) then
            if ( doNewY ) newY(ind,:) = oldY(1,:)
            if ( present(dyByDx) ) dyByDx = 0.0
          else
            if ( doNewY) newY(ind,:) = badValue
            if ( present(dyByDx) ) dyByDx = badValue
          end if
        end do
      end if
      return
    end if

    spline = (Capitalize(method(1:1))=="S")

    useMissingRegions = .false.
    if ( present(missingRegions)) useMissingRegions = missingRegions

    if ( useMissingRegions .and. spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot use missing regions with spline")

    call Allocate_Test ( oldYlower, noNew, width, "oldYlower", ModuleName )
    call Allocate_Test ( oldYupper, noNew, width, "oldYupper", ModuleName )

    ! Do special stuff for the case of spline, allocate arrays, find 2nd
    ! derivatives etc.

    if ( spline ) then
      call Allocate_Test ( oldSecondlower, noNew, width, "oldSecondlower", ModuleName )
      call Allocate_Test ( oldSecondupper, noNew, width, "oldSecondupper", ModuleName )
      call Allocate_Test ( oldSecond, noOld, width, "oldSecond", ModuleName )
      call Allocate_Test ( temp, noOld, width, "temp", ModuleName )

      ! Here we have to solve a tridiagonal equation
      ! This is a straight copy of my (Nathaniel's) IDL code, devectorized
      ! to avoid the need for array temporary values.  The quantities
      ! r1 and r2 are computed as they are so as to avoid dividing 0/0
      ! if there are identical abscissae having identical corresponding
      ! ordinates.  If abscissae are identical but ordinates are not, x/0
      ! occurs.
      oldSecond(1,:) = 0.0
      temp(1,:) = 0.0
      do col = 1, width
        r2 = oldY(2,col) - oldY(1,col)
        if ( r2 /= 0.0 ) r2 = r2 / (oldX(2)-oldX(1))
        do ind = 2, noOld-1
          p = 1.0 / (coeffs%sig(ind)*oldSecond(ind-1,col)+2.0)
          oldSecond(ind,col) = (coeffs%sig(ind)-1.0) * p
          r1 = r2
          r2 = oldY(ind+1,col) - oldY(ind,col)
          if ( r2 /= 0.0 ) r2 = r2 / (oldX(ind+1)-oldX(ind))
          temp(ind,col) = (6.0_rk*(r2 - r1)/(oldX(ind+1)-oldX(ind-1)) - &
            & coeffs%sig(ind)*temp(ind-1,col)) * p
        end do
      end do
      oldSecond(noOld,:) = 0.0

      ! Now do the back substitution
      do ind = noOld-1, 1, -1
        oldSecond(ind,:) = oldSecond(ind,:)*oldSecond(ind+1,:)+temp(ind,:)
      end do

      oldSecondLower = oldSecond(coeffs%lowerInds,:)
      oldSecondUpper = oldSecond(coeffs%upperInds,:)

      call Deallocate_test ( temp, "Temp", ModuleName ) 
      call Deallocate_Test ( oldSecond, "oldSecond", ModuleName )
    end if

    ! Now we're ready to begin the real work.

    if ( extrapolateMethod=="B" ) then
      ! Extrapolate mode is "B"ad; deal with that
      if ( doNewY ) then
        do ind = 1, noNew
          if ( coeffs%badValue(ind) ) then
            newY(ind,:) = badValue
          else
            newY(ind,:) = 0.0
          end if
        end do
      end if
      if ( present(dyByDx) ) then
        do ind = 1, noNew
          if ( coeffs%badValue(ind) ) then
            dyByDx(ind,:) = badValue
          else
            dyByDx(ind,:) = 0.0
          end if
        end do
      end if
      if ( present(intYdX) ) then
        do ind = 1, noNew
          if ( coeffs%badValue(ind) ) then
            intYdX(ind,:) = badValue
          else
            intYdX(ind,:) = 0.0
          end if
        end do
      end if
    else
      ! Clear the result array(s)
      if ( doNewY ) newY = 0.0
      if ( present(dyByDx) ) dyByDx = 0.0
      if ( present(intYdX) ) intYdX = 0.0
    end if

    oldYlower = oldY(coeffs%lowerInds,:)
    oldYupper = oldY(coeffs%upperInds,:)

    ! Now do the linear interpolation calculation.
    ! If we were to spread coeffs%badValue, coeffs%a, coeffs%b and coeffs%gap,
    ! the DO's could be WHERE's.
    if ( useMissingRegions ) then ! worry about the missing regions flag
      if ( doNewY ) then
        do ind = 1, noNew
          if ( coeffs%badValue(coeffs%lowerInds(ind)) .or. &
            &  coeffs%badValue(coeffs%upperInds(ind)) ) then
            newY(ind,:) = badValue
          else
            newY(ind,:) = newY(ind,:) + coeffs%a(ind)*oldYlower(ind,:) + &
              &                         coeffs%b(ind)*oldYupper(ind,:)
          end if
        end do
      end if
      if ( present(dyByDx) ) then
        do ind = 1, noNew
          if ( coeffs%badValue(coeffs%lowerInds(ind)) .or. &
            &  coeffs%badValue(coeffs%upperInds(ind)) ) then
            dyByDx(ind,:) = badValue
          else
            dyByDx(ind,:) = (oldYupper(ind,:)-oldYlower(ind,:)) / &
              &                       coeffs%gap(ind)
          end if
        end do
      end if
      if ( present(intYdX) ) then
        do ind = 1, noNew
          if ( coeffs%badValue(coeffs%lowerInds(ind)) .or. &
            &  coeffs%badValue(coeffs%upperInds(ind)) ) then
            intYdX(ind,:) = badValue
          else
            intYdX(ind,:) = coeffs%ai(ind)*oldYlower(ind,:) + &
              &             coeffs%bi(ind)*oldYupper(ind,:)
          end if
        end do
      end if
    else  ! Don't worry about missing regions flag
      if ( doNewY ) then
        do ind = 1, noNew
          newY(ind,:) = newY(ind,:) + coeffs%a(ind)*oldYlower(ind,:) + &
            &                         coeffs%b(ind)*oldYupper(ind,:)
        end do
      end if
      if ( present(dyByDx) ) then
        do ind = 1, noNew
          dyByDx(ind,:) = (oldYupper(ind,:)-oldYlower(ind,:))/coeffs%gap(ind)
        end do
      end if
      if ( present(intYdX) ) then
        do ind = 1, noNew
          intYdX(ind,:) = coeffs%ai(ind) * oldYlower(ind,:) + &
            &             coeffs%bi(ind) * oldYupper(ind,:)
        end do
      end if
    end if

    ! Now do the spline calculation
    if ( spline ) then
      if ( doNewY ) then
        do ind = 1, noNew
          newY(ind,:) = newY(ind,:) + coeffs%c(ind) * oldSecondLower(ind,:) + &
            &                         coeffs%d(ind) * oldSecondUpper(ind,:)
        end do
      end if
      if ( present(dyByDx)) then
        do ind = 1, noNew
          dyByDx(ind,:) = dyByDx(ind,:) + (coeffs%Gap(ind)/6.0)*( &
            &   coeffs%f(ind) * oldSecondUpper(ind,:) - &
            &   coeffs%e(ind) * oldSecondLower(ind,:))
        end do
      end if
      if ( present(intYdX) ) then
        do ind = 1, noNew
          intYdX(ind,:) = intYdX(ind,:) + &
            &   coeffs%ci(ind) * oldSecondLower(ind,:) + &
            &   coeffs%di(ind) * oldSecondUpper(ind,:)
        end do
      end if
    end if

    ! Now make sure the dyByDX's are correct for extrapolated regions
    if ( ( present (dyByDx) .or. present(intYdX) ) &
      &  .and. scan(extrapolateMethod(1:1),"BC") > 0) then
      select case ( extrapolateMethod(1:1) )
      case ( "C" )
        Fill = 0.0
      case ( "B" )
        Fill = badValue
      end select
      if ( present(dyByDx) ) then
        do ind = 1, noNew
          if ( ( newX(ind) >= oldX(noOld) ) .or. ( newX(ind) < oldX(1) ) ) &
            & dyByDx ( ind, : ) = Fill
        end do
      end if
      if ( present(intYdX) ) then
        do ind = 1, noNew
          if ( ( newX(ind) >= oldX(noOld) ) .or. ( newX(ind) < oldX(1) ) ) &
            & intYdX ( ind, : ) = Fill
        end do
      end if
    end if

    ! Tidy up
    call Deallocate_Test ( oldYlower, "oldYlower", ModuleName )
    call Deallocate_Test ( oldYupper, "oldYupper", ModuleName )

    if ( spline ) then
      call Deallocate_Test ( oldSecondlower, "oldSecondlower", ModuleName )
      call Deallocate_Test ( oldSecondupper, "oldSecondupper", ModuleName )
    end if

! end subroutine InterpolateUsingSetup_r*

! $Log$
! Revision 1.6  2005/08/06 01:27:06  vsnyder
! Corrections to antiderivatives
!
! Revision 1.5  2005/08/03 17:54:35  vsnyder
! Add antiderivatives
!
! Revision 1.4  2005/06/22 20:03:56  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.3  2003/09/11 23:09:50  livesey
! Added handling of skipNewY argument
!
! Revision 1.2  2002/11/23 02:32:09  vsnyder
! Modifications to accomodate InterpolateScalarUsingSetup
!
! Revision 1.1  2002/11/22 23:58:49  vsnyder
! Initial Commit
