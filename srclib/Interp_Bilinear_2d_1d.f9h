! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! subroutine Interp_Bilinear_2d_1d_r* ( XOld, Xnew, YOld, YNew, Zold, Znew, &
!   & Update )

  ! Given ZOld on coordinates (XOld x YOld), interpolate to (XNew,YNew)
  ! to give ZNew.  ZOld must have shape (size(xOld),size(yOld)), while
  ! XNew, YNew and ZNew must have the same shape.

  real(rk) :: DX, DY ! Interpolation factors
  real(rk) :: Z      ! Interpolated result
  integer, dimension(size(zNew)) :: HX, HY ! Hunt indices
  integer :: I, IX, IY
  logical :: U

  u = .false.
  if ( present(update) ) u = update

  ! Hunt for xNew, yNew in xOld, zOld
  call hunt ( xOld, xNew, hx )
  call hunt ( yOld, yNew, hy )
  do i = 1, size(zNew)
    ix = hx(i)
    iy = hy(i)
    dx = ( xNew(i) - xOld(ix) ) / ( xOld(ix+1) - xOld(ix) )
    dy = ( yNew(i) - yOld(iy) ) / ( yOld(iy+1) - yOld(iy) )
    z = &
      & ( 1.0 - dy ) * (( 1.0 - dx ) * zOld(ix,iy) + dx * zOld(ix+1,iy)) + &
      & dy * (( 1.0 - dx ) * zOld(ix,iy+1) + dx * zOld(ix+1,iy+1) )
    if ( u ) then
      zNew(i) = zNew(i) + z
    else
      zNew = z
    end if
  end do

! end subroutine Interp_Bilinear_2d_1d_r*

! $Log$
