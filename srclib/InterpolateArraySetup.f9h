! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! subroutine InterpolateArraySetup_r* ( OldX, NewX, Method, Coeffs, &
!   & Extrapolate, Width, DyByDx, dNewByDOld, intYdX, fail )

    ! Method = S for spline, else linear
    ! ExtrapolateMethod = C for constant, B for bad, P for periodic
    !   continuity if Method = S, else linear

    ! If ExtrapolateMethod == P, make OldX one element longer than you
    ! would otherwise, with OldX(last) = OldX(first) + Period.  NewX is
    ! then put within the range OldX(1)..OldX(last) using
    !   NewX_P = modulo(NewX - OldX(1),Period)
    !   where ( NewX_P < 0 ) NewX_P = NewX_P + Period
    !   NewX_P = NewX_P + OldX(1)

    target :: NewX

    ! Local variables
    logical :: ComputeDNewByDOld
    character :: ExtrapolateMethod
    real(rk) :: Gap2(size(newX,1)), Period
    real(rk), pointer :: NewX_P(:) ! NewX reduced modulo Period, or => NewX
    integer :: Ind, NewInd, NoNew, NoOld
    integer :: LB, UB              ! Bounds for Coeffs%P
    integer, parameter :: RA = kind(coeffs%a)
    real(rm), pointer :: TempDNewByDOld(:,:)
!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id$"
  character (len=len(idParm)), save :: Id = idParm
!---------------------------------------------------------------------------

    ! Size the problem, check sanity, set up arrays etc.

    extrapolateMethod = "A"
    if ( present(extrapolate)) extrapolateMethod = Capitalize(extrapolate(1:1))

    noNew = size(newX,1)
    noOld = size(oldX,1)

    computeDNewByDOld = present(dNewByDOld)
    if ( computeDNewByDOld .and. .not. present(width) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot compute dNewByDOld without knowing Width" )

    ! Components of coeffs spring into existence nullified, not undefined
    call allocate_test ( coeffs%a, noNew, "Coeffs%A", ModuleName )
    call allocate_test ( coeffs%b, noNew, "Coeffs%B", ModuleName )
    call allocate_test ( coeffs%gap, noNew, "Coeffs%Gap", ModuleName )
    call allocate_test ( coeffs%lowerInds, noNew, "Coeffs%LowerInds", ModuleName )

    lb = 1
    ub = noOld-2
    if ( extrapolateMethod /= "P" .or. capitalize(method(1:1)) /= 'S' ) then
      newX_P => newX
    else
      lb = 0
      nullify ( newX_P )
      call allocate_test ( newX_P, noNew, "NewX_P", moduleName )
      period = oldX(noOld)-oldX(1)
      NewX_P = modulo(NewX - OldX(1),Period)
      where ( NewX_P < 0 ) NewX_P = NewX_P + Period
      NewX_P = NewX_P + OldX(1)
    end if
    call Hunt ( oldX, newX_P, coeffs%lowerInds, fail=fail )
    if ( present(fail) ) then
      if ( fail ) return
    endif
    coeffs%gap = oldX(coeffs%lowerInds+1) - oldX(coeffs%lowerInds)
    coeffs%A = (oldX(coeffs%lowerInds+1)-newX_P)/coeffs%gap

    ! If extrapolate is "C"onstant, deal with that
    if ( extrapolateMethod == "C" ) coeffs%A = max(min(coeffs%A,1.0_rA),0.0_rA)

    coeffs%B = 1.0 - coeffs%A

    ! If extrapolate mode is "B"ad, deal with that
    if ( extrapolateMethod == "B" ) then
      call Allocate_Test ( coeffs%badValue, noNew, "maskVector", ModuleName )
      coeffs%badValue = (coeffs%A<0.0) .or. (coeffs%A>1.0)
      where ( coeffs%badValue )
        coeffs%A = 0.0
        coeffs%B = 0.0
      end where
    end if

    ! Spline stuff
    if ( capitalize(method(1:1)) == 'S' ) then
      if ( computeDNewByDOld ) call MLSMessage &
        & ( MLSMSG_Error, ModuleName, "Cannot get dNewBydOld from spline")
      call allocate_test ( coeffs%c, noNew, "Coeffs%C", ModuleName )
      call allocate_test ( coeffs%d, noNew, "Coeffs%D", ModuleName )
      call allocate_test ( coeffs%dX, noOld-1, "Coeffs%dX", ModuleName )
      call allocate_test ( coeffs%o, ub-1, "Coeffs%O", ModuleName )
      call allocate_test ( coeffs%p, ub, "Coeffs%P", ModuleName, lowBound=lb )
      ! Note the extrapolate bad case is covered as A=B=0.0
      gap2 = coeffs%gap ** 2 / 6.0
      coeffs%C = (coeffs%A**3-coeffs%A) * gap2
      coeffs%D = (coeffs%B**3-coeffs%B) * gap2
      coeffs%dX = oldX(2:noOld)-oldX(1:noOld-1)

      ! Set up the system to solve
      coeffs%p(1:noOld-2) = 2.0 * ( coeffs%dx(1:noOld-2) + coeffs%dx(2:noOld-1) )
      ! Factor the system
      if ( extrapolateMethod /= "P" ) then ! Not periodic continuity
        call factor_symm_tri ( coeffs%p(1:ub), coeffs%dx(2:ub), coeffs%o )
      else
        call allocate_test ( coeffs%row, ub, "Coeffs%Row", ModuleName )
        call allocate_test ( coeffs%col, ub, "Coeffs%Col", ModuleName )
      ! coeffs%dx(noOld-1) = coeffs%dx(noOld-1) ! Corners of the matrix
        coeffs%p(0) = 2.0 * ( coeffs%dx(1) + coeffs%dx(noOld-1) )
        call factor_symm_tri ( coeffs%p, coeffs%dx, &
          & coeffs%row, coeffs%o, coeffs%col )
      end if

      ! Compute some more coefficients for splines if DyByDx is present
      if ( present(dyByDx) ) then
        if ( dyByDx ) then
          call allocate_test ( coeffs%e, noNew, "Coeffs%C", ModuleName )
          call allocate_test ( coeffs%f, noNew, "Coeffs%D", ModuleName )
          coeffs%e = 3.0*coeffs%a**2 - 1.0
          coeffs%f = 3.0*coeffs%b**2 - 1.0
        end if
      end if
    end if

    ! Write the output derivative matrix if needed
    if ( computeDNewByDOld ) then
      call CreateBlock ( dNewByDOld, noNew*width, noOld*width, M_Absent )
      ! While the matrix is ideally suited to row sparse, our storage method
      ! is column sparse, so to be lazy we'll create it full and then sparsify
      ! it.

      call Allocate_Test ( tempDNewByDOld, noNew*width, noOld*width, &
        & "tempDNewByDOld", ModuleName )
      do newInd = 1, noNew
        do ind = 1, width
          tempDNewByDOld(newInd+ind*noNew,coeffs%lowerInds(newInd)+ind*noOld) = &
            &  coeffs%A(newInd)
          tempDNewByDOld(newInd+ind*noNew,coeffs%lowerInds(newInd)+1+ind*noOld) = &
            &  coeffs%B(newInd)
        end do
      end do
      call Sparsify ( tempDNewByDOld, dNewbyDOld, &
        & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
      call Deallocate_Test ( tempDNewByDOld, "tempDNewByDOld", ModuleName )
    end if

    if ( present(intYdX) ) then
      if ( intYdX ) then
        call allocate_test ( coeffs%ai, noNew, "Coeffs%AI", ModuleName )
        call allocate_test ( coeffs%bi, noNew, "Coeffs%BI", ModuleName )
        call allocate_test ( coeffs%ci, noNew, "Coeffs%CI", ModuleName )
        call allocate_test ( coeffs%di, noNew, "Coeffs%DI", ModuleName )
        coeffs%AI = newX_P * (oldX(coeffs%lowerInds+1) - 0.5 * newX_P) / coeffs%gap
        coeffs%BI = newX_P - coeffs%AI
        coeffs%CI = -gap2 * ( coeffs%AI + 0.25 * coeffs%gap * coeffs%A**4 )
        coeffs%DI = -gap2 * ( coeffs%BI - 0.25 * coeffs%gap * coeffs%B**4 )
      end if
    end if

    if ( extrapolateMethod == "P" .and. capitalize(method(1:1)) == 'S' ) &
      & call deallocate_test ( newX_P, "newX_P", moduleName )

! end subroutine InterpolateArraySetup_r*

! $Log$
! Revision 1.8  2010/02/02 01:32:11  vsnyder
! Deallocate TempDNewByDOld to plug a memory leak
!
! Revision 1.7  2009/12/10 02:56:14  vsnyder
! Put NewX into the period of OldX correctly
!
! Revision 1.6  2009/12/08 21:44:21  vsnyder
! Provide splines with periodic boundary conditions, use Symm_Tri
!
! Revision 1.5  2009/06/20 02:32:44  vsnyder
! Precompute more stuff, handle identical abscissae, in spline case
!
! Revision 1.4  2005/08/06 01:35:47  vsnyder
! Cannonball polishing
!
! Revision 1.3  2005/08/03 16:34:20  pwagner
! InterpolateArray optionally finds antiderivatives
!
! Revision 1.2  2005/06/22 20:03:55  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.1  2002/11/22 23:58:48  vsnyder
! Initial Commit
!
