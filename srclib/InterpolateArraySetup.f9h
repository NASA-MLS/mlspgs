! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! subroutine InterpolateArraySetup_r* ( OldX, NewX, Method, Coeffs, &
!   & Extrapolate, Width, DyByDx, dNewByDOld, intYdX )

    ! Local variables
    logical :: ComputeDNewByDOld
    character :: ExtrapolateMethod
    real(rk) :: Gap2(size(newX,1))
    integer :: Ind, NewInd, NoNew, NoOld
    integer, parameter :: RA = kind(coeffs%a)
    real(rm), pointer :: TempDNewByDOld(:,:)

    ! Size the problem, check sanity, set up arrays etc.

    noNew = size(newX,1)
    noOld = size(oldX,1)

    extrapolateMethod = "A"
    if ( present(extrapolate)) extrapolateMethod = Capitalize(extrapolate(1:1))

    computeDNewByDOld = present(dNewByDOld)
    if ( computeDNewByDOld .and. .not. present(width) ) &
      & call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Cannot compute dNewByDOld without knowing Width" )

    ! Components of coeffs spring into existence nullified, not undefined
    call allocate_test ( coeffs%a, noNew, "Coeffs%A", ModuleName )
    call allocate_test ( coeffs%b, noNew, "Coeffs%B", ModuleName )
    call allocate_test ( coeffs%gap, noNew, "Coeffs%Gap", ModuleName )
    call allocate_test ( coeffs%lowerInds, noNew, "Coeffs%LowerInds", ModuleName )
    call allocate_test ( coeffs%upperInds, noNew, "Coeffs%UpperInds", ModuleName )

    call Hunt ( oldX, newX, coeffs%lowerInds )
    coeffs%upperInds = coeffs%lowerInds + 1
    coeffs%gap = oldX(coeffs%upperInds) - oldX(coeffs%lowerInds)

    coeffs%A = (oldX(coeffs%upperInds)-newX)/coeffs%gap

    ! If extrapolate is "C"onstant, deal with that
    if ( extrapolateMethod == "C" ) coeffs%A = max(min(coeffs%A,1.0_rA),0.0_rA)

    coeffs%B = 1.0 - coeffs%A

    ! If extrapolate mode is "B"ad, deal with that
    if ( extrapolateMethod == "B" ) then
      call Allocate_Test ( coeffs%badValue, noNew, "maskVector", ModuleName )
      coeffs%badValue = (coeffs%A<0.0) .or. (coeffs%A>1.0)
      where ( coeffs%badValue )
        coeffs%A = 0.0
        coeffs%B = 0.0
      end where
    end if

    ! Spline stuff
    if ( capitalize(method(1:1)) == 'S' ) then
      if ( computeDNewByDOld ) call MLSMessage &
        & ( MLSMSG_Error, ModuleName, "Cannot get dNewBydOld from spline")
      call allocate_test ( coeffs%c, noNew, "Coeffs%C", ModuleName )
      call allocate_test ( coeffs%d, noNew, "Coeffs%D", ModuleName )
      call allocate_test ( coeffs%sig, noOld-1, "Coeffs%Sig", ModuleName, &
        & lowBound=2 )
      ! Note the extrapolate bad case is covered as A=B=0.0
      gap2 = coeffs%gap ** 2 / 6.0
      coeffs%C = (coeffs%A**3-coeffs%A) * gap2
      coeffs%D = (coeffs%B**3-coeffs%B) * gap2
      coeffs%sig = (oldX(2:noOld-1)-oldX(1:noOld-2)) / &
        &          (oldX(3:noOld)-oldX(1:noOld-2))

      ! Compute some more coefficients for splines if DyByDx is present
      if ( present(dyByDx) ) then
        if ( dyByDx ) then
          call allocate_test ( coeffs%e, noNew, "Coeffs%C", ModuleName )
          call allocate_test ( coeffs%f, noNew, "Coeffs%D", ModuleName )
          coeffs%e = 3.0*coeffs%a**2 - 1.0
          coeffs%f = 3.0*coeffs%b**2 - 1.0
        end if
      end if
    end if

    ! Write the output derivative matrix if needed
    if ( computeDNewByDOld ) then
      call CreateBlock ( dNewByDOld, noNew*width, noOld*width, M_Absent )
      ! While the matrix is ideally suited to row sparse, our storage method
      ! is column sparse, so to be lazy we'll create it full and then sparsify
      ! it.

      call Allocate_Test ( tempDNewByDOld, noNew*width, noOld*width, &
        & "tempDNewByDOld", ModuleName )
      do newInd = 1, noNew
        do ind = 1, width
          tempDNewByDOld(newInd+ind*noNew,coeffs%lowerInds(newInd)+ind*noOld) = &
            &  coeffs%A(newInd)
          tempDNewByDOld(newInd+ind*noNew,coeffs%upperInds(newInd)+ind*noOld) = &
            & coeffs%B(newInd)
        end do
      end do
      call Sparsify ( tempDNewByDOld, dNewbyDOld, &
        & "tempDNewByDOld", ModuleName ) ! dNewbyDOld := tempDNewByDOld
    end if

    if ( present(intYdX) ) then
      if ( intYdX ) then
        call allocate_test ( coeffs%ai, noNew, "Coeffs%AI", ModuleName )
        call allocate_test ( coeffs%bi, noNew, "Coeffs%BI", ModuleName )
        call allocate_test ( coeffs%ci, noNew, "Coeffs%CI", ModuleName )
        call allocate_test ( coeffs%di, noNew, "Coeffs%DI", ModuleName )
        coeffs%AI = newX * (oldX(coeffs%upperInds)-0.5 * newX)/coeffs%gap
        coeffs%BI = newX - coeffs%AI
        coeffs%CI = -gap2 * ( coeffs%AI + 0.25 * coeffs%gap * coeffs%A**4 )
        coeffs%DI = -gap2 * ( coeffs%BI - 0.25 * coeffs%gap * coeffs%B**4 )
      end if
    end if
        
! end subroutine InterpolateArraySetup_r*

! $Log$
! Revision 1.2  2005/06/22 20:03:55  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 1.1  2002/11/22 23:58:48  vsnyder
! Initial Commit
!
