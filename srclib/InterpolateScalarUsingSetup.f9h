! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

! $Id$

!  subroutine InterpolateScalarUsingSetup_r* ( coeffs, oldX, oldY, newX, newY, &
!    & method, extrapolate, badValue, missingRegions, dyByDx )
    ! Local variables
    real(rk) :: dyByDxFill         ! Fill value for dyByDx
    character :: extrapolateMethod ! Tidy copy of extrapolate parameter
    integer :: ind                 ! Loop counter
    real(rk), dimension(:), pointer :: oldSecond
    real(rk), dimension(:), pointer :: oldSecondLower
    real(rk), dimension(:), pointer :: oldSecondUpper
    real(rk), dimension(:), pointer :: oldYlower
    real(rk), dimension(:), pointer :: oldYupper
!   real(rk), dimension(size(newX,1)) :: oldYlower, oldYupper
    integer :: noOld, noNew        ! Dimensions
    real(rk) :: p                  ! For second derivative guesser
    logical :: spline              ! Flag
    real(rk), dimension(:), pointer :: temp ! For 2nd der. guess
    logical :: useMissingRegions   ! Copy of missing regions
    logical :: doNewY              ! Not skipNewY (or true if absent)

    ! Executable code

    nullify ( oldSecond, oldSecondLower, oldSecondUpper, temp )
    nullify ( oldYlower, oldYupper )

    ! Size the problem, check sanity, set up arrays etc.

    noOld=size(oldX,1)
    noNew=size(newX,1)

    extrapolateMethod="A"
    if ( present(extrapolate)) extrapolateMethod=Capitalize(extrapolate(1:1))

    doNewY = .true.
    if ( present(skipNewY)) doNewY = .not. skipNewY

    ! Special case where only one input point
    if ( noOld == 1 ) then
      ! If extrapolating allowed or clamped, out values same as in
      if ( extrapolateMethod=="A" .or. extrapolateMethod=="C" ) then
        if ( doNewY ) newY = oldY(1)
        ! Note these next two aren't totally gracefull with respect to 
        ! the missingRegions flag.
        if ( present(dyByDx) ) dyByDx = 0.0_rk
      else
        ! Else extrapolation forbidden
        if ( doNewY ) then
          where ( newX == oldX(1) )
            newY = oldY(1)
          elsewhere
            newY = badValue
          endwhere
        end if
        if ( present(dyByDx) ) then
          where ( newX == oldX(1) )
            dyByDx = 0.0_rk
          elsewhere
            dyByDx = badValue
          end where
        end if
      end if
      return
    end if

    spline = (Capitalize(method(1:1))=="S")

    useMissingRegions = .false.
    if ( present(missingRegions)) useMissingRegions = missingRegions

    if ( useMissingRegions .and. spline ) call MLSMessage &
      & ( MLSMSG_Error, ModuleName, "Cannot use missing regions with spline")

    call Allocate_Test ( oldYlower, noNew, "oldYlower", ModuleName )
    call Allocate_Test ( oldYupper, noNew, "oldYupper", ModuleName )

    ! Do special stuff for the case of spline, allocate arrays, find 2nd
    ! derivatives etc.

    if ( spline ) then
      call Allocate_Test ( oldSecondlower, noNew, "oldSecondlower", ModuleName )
      call Allocate_Test ( oldSecondupper, noNew, "oldSecondupper", ModuleName )
      call Allocate_Test ( oldSecond, noOld, "oldSecond", ModuleName )
      call Allocate_Test ( temp, noOld, "temp", ModuleName )

      ! Here we have to solve a tridiagonal equation
      ! This is a straight copy of my (Nathaniel's) IDL code, devectorized
      ! to avoid the need for array temporary values.
      oldSecond(1) = 0.0_rk
      temp(1) = 0.0_rk
      do ind = 2, noOld-1
        p = 1.0_rk / (coeffs%sig(ind)*oldSecond(ind-1)+2.0_rk)
        oldSecond(ind) = (coeffs%sig(ind)-1.0_rk) * p
        temp(ind) = (oldY(ind+1)-oldY(ind))/(oldX(ind+1)-oldX(ind)) - &
          & (oldY(ind)-oldY(ind-1))/(oldX(ind)-oldX(ind-1))
        temp(ind) = (6.0_rk*temp(ind)/(oldX(ind+1)-oldX(ind-1)) - &
          & coeffs%sig(ind)*temp(ind-1)) * p
      end do
      oldSecond(noOld) = 0.0_rk

      ! Now do the back substitution
      do ind = noOld-1, 1, -1
        oldSecond(ind) = oldSecond(ind)*oldSecond(ind+1)+temp(ind)
      end do

      oldSecondLower = oldSecond(coeffs%lowerInds)
      oldSecondUpper = oldSecond(coeffs%upperInds)

      call Deallocate_test ( temp, "Temp", ModuleName ) 
      call Deallocate_Test ( oldSecond, "oldSecond", ModuleName )
    end if

    ! Now we're ready to begin the real work.

    if ( extrapolateMethod=="B" ) then
      ! Extrapolate mode is "B"ad; deal with that
      if ( doNewY ) then
        where ( coeffs%badValue )
          newY = badValue
        elsewhere
          newY = 0.0_rk
        end where
      end if
      if ( present(dyByDx) ) then
        where ( coeffs%badValue )
          dyByDx = badValue
        elsewhere
          dyByDx = 0.0_rk
        end where
      end if
    else
      ! Clear the result array(s)
      if ( doNewY ) newY = 0.0_rk
      if ( present(dyByDx) ) dyByDx = 0.0_rk
    end if

    oldYlower = oldY(coeffs%lowerInds)
    oldYupper = oldY(coeffs%upperInds)

    ! Now do the linear interpolation calculation.
    ! If we were to spread coeffs%badValue, coeffs%a, coeffs%b and coeffs%gap,
    ! the DO's could be WHERE's.
    if ( useMissingRegions ) then ! worry about the missing regions flag
      if ( doNewY ) then
        where ( coeffs%badValue(coeffs%lowerInds) .or. coeffs%badValue(coeffs%upperInds) )
          newY = badValue
        elsewhere
          newY = newY + coeffs%a*oldYlower + coeffs%b*oldYupper
        end where
      end if
      if ( present(dyByDx) ) then
        where ( coeffs%badValue(coeffs%lowerInds) .or. coeffs%badValue(coeffs%upperInds) )
          dyByDx = badValue
        elsewhere
          dyByDx = (oldYupper-oldYlower) / coeffs%gap
        end where
      end if
    else  ! Don't worry about missing regions flag
      if ( doNewY ) newY = newY + coeffs%a*oldYlower + coeffs%b*oldYupper
      if ( present(dyByDx) ) dyByDx = (oldYupper-oldYlower)/coeffs%gap
    end if

    ! Now do the spline calculation
    if ( spline ) then
      if ( doNewY ) &
        & newY = newY + coeffs%C*oldSecondLower + coeffs%D*oldSecondUpper
      if ( present(dyByDx)) &
        & dyByDx = dyByDx + (coeffs%Gap/6.0_rk) * &
        &   ( coeffs%f*oldSecondUpper - coeffs%e*oldSecondLower )
    end if

    ! Now make sure the dyByDX's are correct for extrapolated regions
    if ( present ( dyByDx ) .and. scan(extrapolateMethod(1:1),"BC") > 0) then
      select case ( extrapolateMethod(1:1) )
      case ( "C" )
        dyByDxFill = 0.0_rk
      case ( "B" )
        dyByDxFill = badValue
      end select
      where ( ( newX >= oldX(noOld) ) .or. ( newX < oldX(1) ) ) &
          & dyByDx = dyByDXFill
    end if

    ! Tidy up
    call Deallocate_Test ( oldYlower, "oldYlower", ModuleName )
    call Deallocate_Test ( oldYupper, "oldYupper", ModuleName )

    if ( spline ) then
      call Deallocate_Test ( oldSecondlower, "oldSecondlower", ModuleName )
      call Deallocate_Test ( oldSecondupper, "oldSecondupper", ModuleName )
    end if

! end subroutine InterpolateScalarUsingSetup_r*

! $Log$
! Revision 1.1  2002/11/23 02:31:15  vsnyder
! Initial commit
!
