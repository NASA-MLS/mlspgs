\documentclass[11pt]{article}
\usepackage[fleqn]{amsmath}\textwidth 6.25in
\oddsidemargin -0.25in
%\evensidemargin -0.5in
\topmargin -0.5in
\textheight 9.00in

\begin{document}

%\tracingcommands=1
\newlength{\hW} % heading box width
\settowidth{\hW}{\bf wvs-004r2}
%\settowidth{\hW}{Page \pageref{lastpage}\ of \pageref{lastpage}}
\makeatletter
\def\@biblabel#1{#1.}
\newcommand{\ps@twolines}{%
  \renewcommand{\@oddhead}{%
    1 May 2000\hfill\parbox[t]{\hW}{{\bf wvs-004r2}\newline
                          Page \thepage\ of \pageref{lastpage}}}%
\renewcommand{\@evenhead}{}%
\renewcommand{\@oddfoot}{}%
\renewcommand{\@evenfoot}{}%
}%
\makeatother
\pagestyle{twolines}

\vspace{-10pt}
\begin{tabbing}
\phantom{References: }\= \\
To: \>Dave, Nathaniel\\
Subject: \>Grammar for the L2CF\\
From: \>Van Snyder\\
\end{tabbing}

\parindent 0pt \parskip 3pt
\vspace{-20pt}

\section{Crash course in language analysis}

An \emph{alphabet} is a set of symbols.  We will use upper-case letters
from the second half of the Latin alphabet, e.g. $T$, to denote these sets.

A \emph{language over an alphabet}, or more simply a \emph{language} is a
set of sequences of symbols from that alphabet.  A \emph{sentence} is a
sequence in the language.  The simplest language, containing all others,
is the reflexive and transitive closure of the alphabet.  It contains all
possible sequences, including the sequence of zero length.  The reflexive
and transitive closure is denoted by a postfix superscript asterisk, e.g.
$T^*$.  The empty sequence is variously denoted by $\lambda$ and
$\epsilon$.  We will use $\lambda$.

A \emph{grammar} is a set of rules for producing a language. 
Mathematically, a grammar $G$ is a 4-tuple $G = (T,N,P,S)$, in which $T$
and $N$ are alphabets, $P$ is a set of productions (to be described below)
and $S \in N$ is a distinguished symbol called the \emph{starting symbol}.

We will use the following notational conventions:
\begin{itemize}
\item Upper-case letters from the beginning of the Latin alphabet
 (and $S$\,) denote symbols from $N$.
\item Lower-case letters from the beginning of the Latin alphabet denote
  symbols from $T$.
\item Lower-case letters from the end of the Latin alphabet denote
  sequences from $T^*$.
\item Lower-case letters from the Greek alphabet denote
  sequences from $(T \cup N)^*$.
\end{itemize}

A \emph{production} is a statement of the form $A \rightarrow \alpha$.
If one has a sequence of symbols from $(T \cup N)^*$ in which $A$ appears,
the production $A \rightarrow \alpha$ indicates that it is permissible to
replace $A$ by $\alpha$.

A \emph{derivation} consists of this replacement.  It is denoted by the
$\Rightarrow$ symbol.  Thus the definition of a production is ``If $A
\rightarrow \alpha \in P$ then $\beta A \gamma \Rightarrow \beta \alpha
\gamma$ is a derivation permitted by the grammar.''  $A$ ``produces''
$\alpha$ in the derivation, hence the term ``production.''

A \emph{derivation sequence} consists of a sequence of zero or more
derivations.  It is denoted by $\Rightarrow^*$.

A \emph{leftmost derivation sequence} is a derivation sequence in which
the leftmost nonterminal is chosen for replacement at every step.

A \emph{sentential form} is a sequence $\xi \in (T \cup N)^*$ such that
$S \Rightarrow^* \xi$.  A sentence is a sentential form consisting only
of symbols from $T$.  Thus, the definition of the language generated by a
grammar is $L(G) = \{ x \mid S \Rightarrow^* x \}$.

If a symbol $A \in N$ appears in a sentential form, and $A \rightarrow
\alpha \in P$, $A$ can be replaced by $\alpha$.  That is, symbols from
$N$ do not terminate the replacement process.  Thus, the set $N$ is
called the set of \emph{nonterminal symbols} of the grammar.  If a symbol
$a \in T$ appears in a sentential form, it cannot be replaced.  Therefore
the set $T$ is called the set of \emph{terminal symbols} of the grammar. 
Terminal symbols are also called ``tokens.'' The grouping of characters
into tokens is deduced by a procedure called the ``Lexer.''  The lexer
also skips comments, and produces tokens for things that aren't character
sequences, e.g. end-of-statement if there is no continuation mark, and
end-of-file.

The \emph{first set} of a sequence is the set of terminal symbols that
can appear as the first symbol of a sentence derivable from that
sequence.  Mathematically, $\text{First}(\alpha) = \{ a \mid \alpha
\Rightarrow^* ax \}.$  The first set of a set of sequences is the union of
the first sets of the individual sequences.

The \emph{follow set} of a nonterminal symbol is the set of terminal
symbols that can appear immediately after that symbol in a sentential
form.  Mathematically, $\text{Follow}(A) = \{ a \mid S \Rightarrow^* \beta
A a \gamma \}$.

\section{Notation for the grammar}

Things in quotes must appear literally, or are the names of categories
of things deduced by the Lexer.  We extend the notation for grammars to
allow a more compact representation, called \emph{regular right-part
grammars}.

\begin{itemize}
\item[$\rightarrow$] is pronounced ``is defined to be'' or ``produces''.
\item[*] means ``zero or more of the preceeding single item or parenthesized group''
\item[+] means ``one or more of the preceeding single item or parenthesized group''
\item[?] means ``zero or one of the preceeding single item or parenthesized group''
\item[$\mid$] means ``or''
\end{itemize}
Parentheses are used for grouping.

\section{The grammar}\label{gram}

\begin{tabular}{|l|}
     \hline
{\bf Productions} $P$ \\
     \hline
     \hline
cf $\rightarrow$ one\_cf + `EOF' \\
     \hline
one\_cf $\rightarrow$ ( `begin' `name' `EOS' spec + `end' `name' ) ? `EOS' \\
     \hline
spec $\rightarrow$ ( `name' spec\_rest ) ? `EOS' \\
     \hline
spec\_rest $\rightarrow \lambda$ \\
     \phantom{spec\_rest}
          $\rightarrow$ `=' expr + \\
     \phantom{spec\_rest}
          $\rightarrow$ ( `,' spec\_list ) + \\
     \hline
spec\_list $\rightarrow$ expr ( `=' expr + ) ? \\
     \phantom{spec\_list}
          $\rightarrow$ `/' `name' \\
     \hline
expr $\rightarrow$ `string' + \\
     \phantom{expr}
     $\rightarrow$ value \\
     \hline
value $\rightarrow$ limit ( `..' limit ) ? \\
     \hline
limit $\rightarrow$ term ( ( `+' $\mid$ `-' ) term ) * \\
     \hline
term $\rightarrow$ primary ( ( `*' $\mid$ `/' ) primary ) * \\
     \hline
primary $\rightarrow$ `name' ( `.' `name' ) ? \\
     \phantom{primary}
        $\rightarrow$ `number' `unit' ? \\
     \phantom{primary}
        $\rightarrow$ `(' value `)' \\
     \hline
\end{tabular}

$T$ = \{ `begin' `EOF' `EOS' `end' `name' `number' `string' `unit' `(' `)'
         `+' `-' `*' `/' `.' `..' `=' \}

$N$ = \{ cf one\_cf spec spec\_rest spec\_list expr value limit term primary \}

$S$ = cf.

\section{Organization of the Parser}

The parser reads a sequence of tokens, deduces that they constitute a
sentence in the language, and produces a (perhaps preliminary) translation
of the sequence of tokens into a form more suitable for subsequent
analysis.

The parser described here consists of a collection of potentially
recursive procedures.  There are other parsing strategies that are not
described here.

There is one procedure for each nonterminal symbol in the grammar shown in
section \ref{gram}.

Within each procedure, there is a selection process:  If the next token
is within the selection set for a production with a left-hand side
nonterminal symbol that corresponds to that procedure, that production is
applied.  If the next token is not within the selection set for any
production with a left-hand side symbol that corresponds to that
procedure, an error is announced.

``Applying'' a production consists of executing the procedures that
correspond to nonterminal symbols encountered in the right-hand side, or
``consuming'' the next token if the next symbol in the right-hand side is
a terminal symbol, in the order these entities appear.

``Consuming'' a token consists of comparing it to the expected token,
fetching a new token if they are equal, and announcing an error otherwise.

A grammar that permits a parser to be implemented in this way is called
$LL(1)$.  The first $L$ means that the input is examined left-to-right. 
The second $L$ means that a leftmost derivation sequence is traced out. 
The $(1)$ means that one can decide what to do by looking at one symbol
from the unconsumed input.

The \emph{selection set} for a production is the set of symbols that
unambiguously indicate that the production should be applied at a certain
instant during the analysis.  Taking the liberty of concatenating a set
with a sequence to generate a set of sequences, we have $\text{Select}(
A \rightarrow \alpha) = \text{First}( \alpha \text{Follow}( A ) )$.  If
the selection sets for all the productions with a given left-hand side
are disjoint, the grammar ls LL(1).  The $\text{Follow}(A)$ part comes
from wanting to apply $A \rightarrow \alpha$ if $\alpha \Rightarrow^*
\lambda$.  The $\text{First}(\alpha)$ part comes from wanting to apply $A
\rightarrow \alpha$ otherwise.

In the abbreviated form of the grammar in section \ref{gram}, the * turns
into {\tt do while}, the + turns into {\tt do until}, and the ? and
$\mid$ turn into {\tt if}.

It is necessary to have a selection process for these optional or
repeated parts within the right-hand side.  These selection sets are
derived by transforming the grammar so as not to include regular right
parts.

The selection sets for the transformed grammar are tabulated in part
\ref{extend}.  The correspondence between selection sets for productions
in section \ref{extend} and the selection sets for optional or repeated
parts within the right-hand sides of the grammar in section \ref{gram}
should be obvious.

\section{Extended form of the grammar}\label{extend}

\begin{tabular}{|l|l|}
     \hline
{\bf Productions} & {\bf Selection Sets} \\
     \hline
     \hline
cf $\rightarrow$ one\_cf more\_cfs `EOF'         & `begin' \\
     \hline
more\_cfs $\rightarrow \lambda$                  & `EOF' \\
     \phantom{more\_cfs}
         $\rightarrow$ one\_cf                   & `begin' \\
     \hline
one\_cf $\rightarrow$ `EOS'                      & `EOS' \\
      \phantom{one\_cf}
        $\rightarrow$ `begin' `name' `EOS'
                      spec specs
                      `end' `name' `EOS'  & `begin' \\
     \hline
specs $\rightarrow \lambda$                      & `end' \\
     \phantom{specs}
      $\rightarrow$ spec specs                   & `name' \\
     \hline
spec $\rightarrow$ 'EOS'                          & `EOS'  \\
     \phantom{spec}
     $\rightarrow$ `name' spec\_rest `EOS'        & `name' \\
     \hline
spec\_rest $\rightarrow \lambda$                 & `EOS' \\
     \phantom{spec\_rest}
          $\rightarrow$ `=' expr exprs           & `=' \\
     \phantom{spec\_rest}
          $\rightarrow$ `,' spec\_list more\_specs     & `,' \\
     \hline
more\_specs $\rightarrow \lambda$                & `EOS' \\
     \phantom{more\_specs}
            $\rightarrow$ `,' spec\_list more\_specs     & `,' \\
     \hline
spec\_list $\rightarrow$ `name' more\_spec\_list & `name' \\
     \phantom{spec\_list}
          $\rightarrow$ `/' `name'               & `/' \\
     \hline
more\_spec\_list $\rightarrow \lambda$           & \{ `,' `EOS' \} \\
     \phantom{more\_spec\_list}
                 $\rightarrow$ `=' expr exprs    & `=' \\
     \hline
exprs $\rightarrow \lambda$                      & \{ `,' `EOS' \} \\
     \phantom{exprs}
      $\rightarrow$ expr exprs                   & \{ `name' `number'
                                                      `string' `(' \} \\
     \hline
expr $\rightarrow$ `string' strings              & `string' \\
     \phantom{expr}
     $\rightarrow$ value                         & \{ `name' `number' `(' \} \\
     \hline
strings $\rightarrow \lambda$                    & \{ `,' `EOS' \} \\
     \phantom{strings}
        $\rightarrow$ `string'                   & `string' \\
     \hline
value $\rightarrow$ limit range                  & \{ `name', `number', `(' \} \\
     \hline
range $\rightarrow \lambda$                      & \{ `,' `EOS' ')' \} \\
     \phantom{range}
      $\rightarrow$ `..' limit                   & \{ `name', `number', `(' \} \\
     \hline
limit $\rightarrow$ term term\_list              & \{ `name', `number', `(' \} \\
     \hline
term\_list $\rightarrow \lambda$                 & \{ `..' `,' `EOS' ')' \} \\
     \phantom{term\_list}
           $\rightarrow$ ( `+' $\mid$ `-' ) term term\_list & \{ `+' `-' \} \\
     \hline
term $\rightarrow$ primary primary\_list         & \{ `name', `number', `(' \} \\
     \hline
primary\_list $\rightarrow \lambda$              & \{ `+' `-' `..' `,'
                                                      `EOS' ')' \}\\
     \phantom{primary\_list}
              $\rightarrow$ ( `*' $\mid$ `/' ) primary & \{ `*' `/' \} \\
     \hline
primary $\rightarrow$ `name' field               & `name' \\
     \phantom{primary}
        $\rightarrow$ `number' `unit' ?          & `number' \\
     \phantom{primary}
        $\rightarrow$ `(' expr `)'               & `(' \\
     \hline
field $\rightarrow \lambda$                      & \{  `*' `/' `+' `-' `..'
                                                       `,' `EOS' ')'\} \\
     \phantom{field}
      $\rightarrow$ `.' `name'                   & `.' \\
     \hline
\end{tabular}

\section{Output of the Parser}

A form of output from the parser that is particularly tractable for
subsequent analysis is an \emph{abstract syntax tree}.  This is a tree
that represents the input, it is related to the syntax, but it does not
include all the details of the spelling of the input (hence the
\emph{abstract} part).

The grammar in section \ref{gram} is augmented with \emph{tree generation
rules} in order to produce the abstract syntax tree:

\begin{tabular}{|l|}
     \hline
{\bf Productions} $P$ \\
     \hline
     \hline
cf$_x$ $\rightarrow$ one\_cf$_z$ + `EOF'
       \{ $x \leftarrow < \text{n\_cfs} $ list of $z$'s $>$ \} \\
     \hline
one\_cf$_x$ $\rightarrow$ block$_y$ \{ $x \leftarrow y$ \} \\
     \phantom{one\_cf$_x$} `EOS` \{ $x \leftarrow \lambda$ \} \\
     \hline
block$_x$ $\rightarrow$ `begin' `name'$_y$ `EOS' spec$_z$ + `end' `name'$_w$
     `EOS` \\
     \phantom{block$_x$} \{ $x \leftarrow < \text{n\_cf} \ y $ list of $z$'s $w \ >$ \} \\
     \hline
spec$_x$ $\rightarrow$ one\_spec$_{y}$ `EOS' \{ $x \leftarrow y$ \} \\
     \phantom{spec$_x$} $\rightarrow$ `EOS' \{ $x \leftarrow \lambda$ \} \\
     \hline
one\_spec$_x$ $\rightarrow$ 
     `name'$_y$ spec\_rest$_{yz}$ \{ $x \leftarrow z$ \} `EOS' \\
     \hline
spec\_rest$_{xy}$ $\rightarrow \lambda$ \{ $ y \leftarrow x$ \} \\
     \phantom{spec\_rest}
          $\rightarrow$ `=' expr$_z$ +
            \{ $y \leftarrow < \ \text{n\_asg} \ x $ list of $z$'s $>$ \}\\
     \phantom{spec\_rest}
          $\rightarrow$ ( `,' spec\_list$_z$ ) + 
            \{ $y \leftarrow < \ \text{n\_spec\_args} \ x $ list of $z$'s $>$ \}\\
     \hline
spec\_list$_x$ $\rightarrow$ expr$_y$ spec\_value$_{yz}$
      \{ $x \leftarrow z$ \} \\
     \phantom{spec\_list}
          $\rightarrow$ `/' `name'$_z$
          \{ $x \leftarrow < \ \text{n\_set\_one} \ z \ >$ \} \\
     \hline
spec\_value$_{xy}$ $\rightarrow \lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{spec\_value$_{xy}$} $\rightarrow$
       `=' expr$_z$ + \{ $y \leftarrow < \text{n\_equal} \ x $ list of $z$'s
       $>$ \} \\
     \hline
expr$_x$ $\rightarrow$ `string'$_z$ + \{ $x \leftarrow$ list of the $z$'s \} \\
     \phantom{expr$_x$}
     $\rightarrow$ value$_z$ + \{ $x \leftarrow$ list of the $z$'s \} \\
     \hline
value$_z$ $\rightarrow$ limit$_x$ range$_{xy}$ \{ $ z \leftarrow y$ \} \\
     \hline
range$_{xy}$ $\rightarrow \lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{range$_{xy}$} $\rightarrow$ `..' limit$_z$ ;
        $ y \leftarrow < \ \text{n\_dot\_dot} \ x \ z \ > $ \\
     \hline
limit$_z$ $\rightarrow$ term$_x$ ( pterm\_list$_{xy}$ $\mid$
                                   mterm\_list$_{xy}$ ) \{
                        $z \leftarrow y$ \} \\
     \hline
pterm\_list$_{xy}$ $\rightarrow$ $\lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{pterm\_list$_{xy}$}
            $\rightarrow$ `+' term$_z$
              \{ $v \leftarrow < \ \text{n\_plus} \ x \ z \ >$ \}
            ( pterm\_list$_{vw}$ $\mid$ pterm\_list$_{vw}$ ) \\
     \phantom{pterm\_list$_{xy}$} \{ $y \leftarrow w$ \} \\
     \hline
mterm\_list$_{xy}$ $\rightarrow$ $\lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{mterm\_list$_{xy}$}
            $\rightarrow$ `-' term$_z$
              \{ $v \leftarrow < \ \text{n\_minus} \ x \ z \ >$ \}
            ( mterm\_list$_{vw}$ $\mid$ mterm\_list$_{vw}$ ) \\
     \phantom{mterm\_list$_{xy}$} \{ $y \leftarrow w$ \} \\
     \hline
term$_z$ $\rightarrow$ primary$_x$ ( mpri\_list$_{xy}$ $\mid$
                                     dpri\_list$_{xy}$ ) \{
                                     $z \leftarrow y$ \} \\
     \hline
mpri\_list$_{xy}$  $\rightarrow \lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{mpri\_list$_{xy}$} $\rightarrow$ `*` primary$_z$
        \{ $v \leftarrow < \ \text{n\_mult} \ x \ z \ >$ \}
        ( mpri\_list$_{vw}$ $\mid$ dpri\_list$_{vw}$ ) \\
      \phantom{mpri\_list$_{xy}$} \{ $y \leftarrow w$ \} \\
     \hline
dpri\_list$_{xy}$  $\rightarrow$ $\lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{dpri\_list$_{xy}$} $\rightarrow$ `/` primary$_z$
        \{ $v \leftarrow < \ \text{n\_div} \ x \ z \ >$ \}
        ( dpri\_list$_{vw}$ $\mid$ dpri\_list$_{vw}$ ) \\
     \phantom{dpri\_list$_{xy}$} \{ $y \leftarrow w$ \} \\
     \hline
primary$_z$ $\rightarrow$ `name'$_x$ stru\_comp$_{xy}$
            \{ $ z \leftarrow y$ \}\\
     \phantom{primary$_z$}
        $\rightarrow$ `number'$_x$ unit$_{xy}$ \{ $ z \leftarrow y$ \} \\
     \phantom{primary$_z$}
        $\rightarrow$ `(' value$_x$ `)' \{ $ z \leftarrow x$ \} \\
     \hline
stru\_comp$_{xy}$ $\rightarrow \lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{stru\_comp$_{xy}$} $\rightarrow$ `.' `name'$_z$
     \{ $y \leftarrow < \ \text{n\_dot} \ x \ z \ > $ \}\\
     \hline
unit$_{xy}$ $\rightarrow \lambda$ \{ $y \leftarrow x$ \} \\
     \phantom{unit$_{xy}$} $\rightarrow$ `unit'$_z$
     \{ $y \leftarrow < \ \text{n\_unit} \ x \ z \ > $ \} \\
     \hline
\end{tabular}

This form of grammar is called an \emph{attribute grammar}.  The
subscripts are attributes.  Unless otherwise specified, subscripts that
have the same name are copied from left-to-right.  Parts within \{ and \}
are actions.  The $\leftarrow$ symbol is the assignment operator.  The
notation $< \ x \ y \ z $ ... $>$ means ``make a tree node with $x$ at
the root, and sons $y$, $z$, ..., in that order.

\label{lastpage}
\end{document}
% $Id$
