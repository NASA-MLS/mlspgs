% Making the graphics:
% tgif -print -color -eps wvs-147-0.obj; epstopdf wvs-147-0.eps
% tgif -print -color -eps wvs-147-1.obj; epstopdf wvs-147-1.eps
% tgif -print -color -eps wvs-147-2.obj; epstopdf wvs-147-2.eps
% tgif -print -color -eps wvs-147-2-5.obj; epstopdf wvs-147-2-5.eps
% tgif -print -color -eps wvs-147-3.obj; epstopdf wvs-147-3.eps
% tgif -print -color -eps wvs-147-4.obj; epstopdf wvs-147-4.eps
% tgif -print -color -eps wvs-147-5.obj; epstopdf wvs-147-5.eps
% tgif -print -color -eps wvs-147-6.obj; epstopdf wvs-147-6.eps
% tgif -print -color -eps wvs-147-7.obj; epstopdf wvs-147-7.eps
% tgif -print -color -jpeg wvs-147-0.obj
% tgif -print -color -jpeg wvs-147-1.obj
% tgif -print -color -jpeg wvs-147-2.obj
% tgif -print -color -jpeg wvs-147-2-5.obj
% tgif -print -color -jpeg wvs-147-3.obj
% tgif -print -color -jpeg wvs-147-4.obj
% tgif -print -color -jpeg wvs-147-5.obj
% tgif -print -color -jpeg wvs-147-6.obj
% tgif -print -color -jpeg wvs-147-7.obj

\makeatletter\let\ifGm@compatii\relax\makeatother
\documentclass[landscape]{beamer}

\usepackage{alltt}
\usepackage{amsmath}
\usepackage{color}
\usepackage{graphicx}
\usepackage{longtable}

% \ifx\pdfoutput\undefined
%   \pdfoutput=0
%   \usepackage{hyperref}
%   \hypersetup{%
%     hypertex,%
%     plainpages,%
%     hyperindex=true,%
%     hypertexnames=false%
%   }
%   % Specify the driver for the color package
%   \ExecuteOptions{dvips}
%   %\ExecuteOptions{xdvi}
% \else
%   \ifnum\pdfoutput>0
%     \usepackage{hyperref}
%     \hypersetup{%
%       pdftex,%
%       plainpages,%
%       hyperindex=true,%
%       pdfpagelabels,%
%       hypertexnames=false,%
%       colorlinks=true,%
%       linktocpage=true,%
%     }
%     % Specify the driver for the color package
%     \ExecuteOptions{pdftex}
%   \else
%     \usepackage{hyperref}
%     \hypersetup{%
%       hypertex,%
%       plainpages,%
%       hyperindex=true,%
%       hypertexnames=false%
%     }
%     % Specify the driver for the color package
%     \ExecuteOptions{dvips}
%     %\ExecuteOptions{xdvi}
%   \fi
% \fi

\hyperbaseurl{}
\newcommand\hr[1]{\href{#1.dvi}{dvi}, \href{#1.pdf}{pdf}}
\newcommand\h[1]{#1 (\hr{#1})}

\newcommand{\newframe}[2][]{\begin{frame}\frametitle{\hfill #2 \hfil}}
\renewcommand{\d}{\text{d}}

\title{Configuration File Processing
\thanks{See {\tt mlspgs/doc/wvs-004} for more detail} \\
wvs-147r4}

\author{Van Snyder}

\date{11 September 2019}
\titlegraphic{\includegraphics[width=1.0in]{eos_mls_logo_onpink}}


\begin{document}

\begin{frame}
  \Large
  \titlepage

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Processing}

\Large

Configuration file processing consists of

\begin{itemize}

\item parsing the configuration file -- converting it to a form easier to
      use for subsequent purposes,

\item checking types of entities and units of numeric ones, and

\item traversing the internal representation to drive program operations.

\end{itemize}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Processing}

\vspace*{-0.5in}
\includegraphics[scale=0.55,angle=270]{wvs-147-0}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Crash Course in Language Analysis -- Terminology}

\Large

An \emph{alphabet} is a set of symbols.  Sets are denoted by upper-case
Latin letters.

A \emph{language} is a set of sequences (or strings) from an alphabet.  A
sequence is denoted by a lower-case Latin letter.

A \emph{sentence} is a sequence from that set.  It might or might not
include the empty string, denoted $\lambda$ here.

The \emph{concatenation} $xy$ of two sequences is a sequence that consists
of the first sequence ($x$) followed by the second one ($y$).  $\lambda$
is the identity for concatenation: $x\lambda = \lambda x = x$.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Operator Definitions}

\begin{longtable}{clll}
\multicolumn{2}{c}{\bf Operator} & {\bf Operands} & {\bf Meaning} \\
\hline
$\rightarrow$  & produces & Symbol and sequence & Later\dots\\
$\Rightarrow$  & derives  & Sequences           & Later\dots\\
$\cup$         & union    & Sets $A$ and $B$    & Everything that is in \\
               &          &                     & either $A$ or $B$ \\
$\in$          & in       & Element $x$ and a set $S$
                                                & $x$ is in (a member of)
                                                  $S$ \\
$\wedge$       & and      & Propositions $x$ and $y$
                                                & $x$ and $y$ are both
                                                  true \\
$\vee$         & or       & Propositions $x$ and $y$
                                                & $x$ or $y$ or both are
                                                  true \\
\end{longtable}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{More Terminology}

\Large

The \emph{concatenation} $PQ$ of two sets $P$ and $Q$ is defined as
$\{xy \,|\, x \in P \wedge y \in Q\}$.

The simplest language over a set is the \emph{closure} of the alphabet. 
It contains all possible sequences, including $\lambda$.  It is denoted by
a postfix superscript asterisk, e.g. $T^*$.  $T^*$ is the solution of the
equation $T^* = \{\lambda\} \cup T T^*$.  Don't try to solve by
fixed-point iteration -- if $T$ is not empty the solution is infinite.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Grammars}

A \emph{grammar} is a set of rules for producing a language. 
Mathematically, a grammar $G$ is a four-tuple $G = ( T, N, P, S )$, in
which $T$ and $N$ are disjoint alphabets, called \emph{terminal} and
\emph{nonterminal} (more later), $P$ is a set of of \emph{productions}
(more below), and $S \in N$ is a distinguished symbol called the
\emph{starting symbol}.

Notational conventions:

\begin{itemize}

\item Upper-case letters from the beginning of the Latin alphabet (and
      $S$) denote symbols from $N$.

\item Lower-case letters from the beginning of the Latin alphabet denote
      symbols from $T$.

\item Lower-case letters from the end of the Latin alphabet denote symbols
      from $T^*$.

\item Lower-case letters from the Greek alphabet denote sequences from $(T
      \cup N)^*$.

\item Upper-case letters from the end of the Latin alphabet (except $S$)
      denote symbols from $(T \cup N)$.

\end{itemize}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Grammars (cont.)}

A \emph{production} is a statement of the form $A \rightarrow \alpha$.  If
one has a sequence of symbols from $(T \cup N)^*$ in which $A$ appears, it
is permissible to replace $A$ with $\alpha$.

A \emph{derivation} consists of this replacement.  The definition of $A
\rightarrow \alpha$ is ``$\beta A \gamma \Rightarrow \beta \alpha \gamma$
is permitted by the grammar.''  In this derivation step, $A$ \emph{produces}
$\alpha$.

A \emph{derivation sequence} consists of zero or more derivations.  It is
denoted $\Rightarrow^*$.

A \emph{leftmost} (resp. \emph{rightmost}) \emph{derivation sequence} is a
derivation sequence in which the leftmost (resp. rightmost) symbol from
$N$ is chosen for replacement at each step.

A \emph{sentential form} is a sequence $\xi \in ( T \cup N )^*$ such that
$S \Rightarrow^* \xi$.

A \emph{phrase} is a sequence $\zeta \in ( T \cup N )^*$ such that
$A \Rightarrow^* \zeta$ for some $A \in N$.

A \emph{sentence} is a sentential form consisting only of symbols from
$T$.

The \emph{language} $L(G)$ generated by a grammar $G$ is $L(G) = \{ x | S
\Rightarrow^* x \wedge x \in T^* \}$ is the set of its sentences.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Example (cont.)}

$G = (T,\, N,\, P,\, S)$ where \\[5pt]

$T = \{ +,\, *,\, a,\, b,\, c\}$\\[5pt]

$N = \{E,\, T,\, N\}$

\begin{tabbing}
$P = \{$ \=  $E \rightarrow T \,|\, E + T $ \\
     \> $T \rightarrow N\,|\, T * N$ \\
     \> $N \rightarrow a \,|\, b \,|\, c\,$ \}
\end{tabbing}

$S = E$\\[5pt]

where $X \rightarrow \alpha \,|\, \beta$ is shorthand for $\{ X
\rightarrow \alpha\} \cup \{X \rightarrow \beta\}$.\\[5pt]

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Example (cont.)}

Leftmost derivation of {$E \Rightarrow^*$ \tt a + b * c}:

$E \Rightarrow E + T \Rightarrow T + T \Rightarrow N + T \Rightarrow a + T
\Rightarrow a + T * N \Rightarrow a + N * N \Rightarrow a + b * N
\Rightarrow a + b * c$.

The process \emph{terminates} when the sequence consists entirely of
terminal symbols.  This can be visualized by the following tree:\\[5pt]

\begin{centering}
\includegraphics[scale=0.5]{wvs-147-1} \\
\end{centering}

If you trace out the leaves of this \emph{derivation tree} by a
depth-first left-to-right traversal, you get the derived text
\color{red}{\tt a + b * c}.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Example (cont.)}

The derivation tree has too much extraneous information.  A more useful
representation is the \emph{abstract syntax tree}.  Here \emph{abstract}
means ``uninteresting information has been removed.''\\[10pt]

\begin{centering}
\includegraphics[scale=0.8]{wvs-147-2} \\
\end{centering}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Producing an Abstract Syntax Tree}

A sequence of characters is difficult to work with, so we prefer to have
an abstract syntax tree.

Producing the abstract syntax tree consists of three steps:

\begin{enumerate}

\item Collect characters together into \emph{tokens}, which represent
      terminal symbols.  This process is called \emph{lexing}.  It
      recognizes the \emph{lexicon}, which is the set of sequences of
      characters from which terminal symbols are produced.

\item Analyze sequences of tokens to recognize which productions apply.
      This process is called \emph{parsing}.

\item Produce an abstract syntax tree.  This process is called
      \emph{translating}.

\end{enumerate}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Lexicon -- General}

A \emph{regular expression} is a notation for denoting a language with a
particularly simple structure.  Let $a$, $p$ and $q$ be regular
expressions.  Then:\\[3pt]

{\small
\begin{tabular}{|c|c|l|}
     \hline
{\bf Regular}                 & {\bf Denoted} &                   \\
{\bf expression}              & {\bf set}     & {\bf Description} \\
     \hline
     \hline
$\emptyset$ & $\emptyset$     & The empty set\\
     \hline
$\lambda$   & \{ $\lambda$ \} & The set consisting of the empty \\
            &                 & sequence\\
     \hline
$a$         & \{ $a$ \}       & The symbol $a$ from the alphabet\\
     \hline
$p \mid q$  & $P \cup Q$      & Any sequence in either $P$ or $Q$\\
     \hline
$pq$        & $PQ$            & The concatentation of $P$ and $Q$\\
     \hline
$p^*$       & $P^*$           & The reflexive and transitive closure \\
            &                 & (zero or more) of $P$\\
     \hline
$p^+$       & $P P^*$         & The transitive closure (one or more) \\
            &                 & of $P$\\
     \hline
$p?$        & $P \cup \{ \lambda \}$ & $P$ or the empty sequence\\
     \hline
\end{tabular}
}
\\[3pt]
Parentheses are used for grouping.  The $\mid$ symbol has a meaning here
different from its meaning within a set constructor.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Lexicon}

End-of-line shall not appear within a symbol in the lexicon.

Three terminal symbols are defined by regular expressions.  Others appear
in the configuration file exactly as they appear in the grammar (but
without quotation).  Let $L$ be the set of letters, $D$ be the set of
digits, and not$(x)$ be the set of characters other than $x$.\\[3pt]

{\small
`name' $= L(\{\text{`\_'}\} \cup L \cup D)^*$ (cannot begin with \_).


`number' $= D^+ ( \text{`.'} D^* ) ? ( \{ \text{`D' `E' `d` `e'} \ \}
            \{ \ \text{`+' `-'} \ \}? D^+) ?$


`string' $= (\{\ ' \ \} ( (\text{not}(')^*) \mid ({'} {'}) )^* \{\ ' \ \} )
       \mid (\{\ " \ \} ( (\text{not}(")^*) \mid (" ") )^* \{\ " \ \} ) $
}
\\[3pt]

\small
Strings are surrounded by quotes or apostrophes.  If surrounded by one,
the other can appear, or two of the surrounding one denote only one
appearance.

These three symbols are called \emph{pseudo-terminal} because they have an
internal structure -- but it's defined by the lexicon, not the grammar.

Comments begin with a semicolon and continue to the end of the line.

A statement may be continued onto another line by \$ not in a comment. 
Otherwise, end-of-line denotes the end of a statement.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Token representation}

A token is represented by its token index (in {\tt symbol\_types}), its
{\bf string index}, and its position in the input file.

\vspace*{5pt}
The lexer reads characters by way of the {\tt get\_char} subroutine in
the {\tt string\_table} module.

\vspace*{5pt}
As they are read, they are added to the end of the character table.  When
the lexer finds the end of a token, its text is searched using the hash
table.

\vspace*{5pt}
If it is found, the found string index is used and the characters are
erased from the character table.  Otherwise, it's added to the string
table and the new string index is used.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Token representation (cont.)}

The texts of tokens are stored in the {\bf character table}.  Each element
of the {\bf string table} contains the index in the character table of the
last character of the token.  Tokens are found quickly using the {\bf hash
table}.

\hspace*{0.25in}\includegraphics[scale=0.6]{wvs-147-2-5}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Lexicon (cont.)}

Reserved words such as {\tt begin}, operator symbols such as +, and
punctuation marks such as (, are put into the string table before the
lexer runs by {\tt Init\_Symbol\_Table} in the {\tt symbol\_table} module.
The types and texts of the sybols specified are in the {\tt symbol\_types}
module.\\[5pt]

The hash table, character table, and string table are initialized by {\tt
Init\_Lexer} in the {\tt lexer\_core} module, which is called from the main
program in {\tt mlsl2} (I don't know where it's done in {\tt mlsl1}.)

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Lexicon (cont.)}

The lexer is the subroutine {\tt lexer} in the {\tt lexer\_m}
module.\\[5pt]

It is a DFA, or \emph{deterministic finite automaton}.  Think of it as a
directed graph, where each state is represented by a vertex, and each edge
is labeled by a set of symbols from the alphabet.  It has a distinguished
starting state (a starting vertex in the graph).  Every time it is called,
it starts in the starting state.\\[5pt]

When a character is read, if it is the label of an edge incident from the
vertex that represents the current state, the character is consumed, and
the state of the lexer changes to the next vertex.\\[5pt]

When the lexer reaches a state identified as a final state, and there are
no transitions possible, the token specified by that state is returned to
the parser.  If the next character is not part of the token, the lexer
remembers it.\\[5pt]

If the lexer cannot make a transition from a non-final state, an error is
announced.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Grammar}

A configuration file is divided into sections that begin with the word
{\tt begin} followed by a section name and end with the word {\tt end}
followed by the same section name.  Section names are not arbitrary; they
are specified by the program.  The program also imposes restrictions on
their order.

Within a section, there are three kinds of statements:

\begin{itemize}

  \item A parameter definition of the form \emph{name = expression}.  The
    set of valid parameter definition names, and the types of their
    values, are specified by the program.

  \item A variable definition of the form \emph{name := expression}.  The
    set of valid variable names is not specified by the program. A variable's
    type is determined by the expression first assigned to it.  Once a
    variable has been assigned a value, a subsequent assignment cannot
    change its type.

  \item (next page)

\end{itemize}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Grammar}

(Statements cont.)

\begin{itemize}

  \item A specification of the form \emph{[ label: ] name [, fields] },
    where the label and fields are optional.  Each field is of the form
    \emph{name = expression} or \emph{/name}.  The set of valid
    specification names for each section, the set of valid field names for
    each specification, the type of value for each field, and the units of
    numeric values of fields, are specified by the program.  The form
    \emph{/name} is only valid for fields that can have logical or boolean
    values, and is equivalent to \emph{name=true}.

    \vspace*{5pt}
    The type of the value of a field, parameter, or variable can be
    numeric, a string, an enumerator, or the label of a specification. 
    The set of enumeration types, and the enumerators of each type, are
    specified by the program.

\end{itemize}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Grammar}

(Statements cont.)

Variable definitions can occur outside sections.

\vspace*{3pt}
Either surrounding sections and variable definitions, or within sections,
{\tt case}, {\tt if}, {\tt do}, and {\tt do while} constructs, having
the same syntax and semantics as in Fortran (except that the ``=" sign in
the {\tt do} construct is replaced by ``:="), may appear.  An additional
{\tt do} construct, with only one expression, may appear.  The type of
the expression may be any type, and it is assumed to be an array (a scalar
is considered to be an array of length one in this context); the body of
the construct is invoked once for each element of the expression. 
Constructs must be correctly nested.

\vspace*{3pt}
An {\tt exit} or {\tt cycle} statement may appear within a {\tt do}
construct, with the same semantics as in Fortran, except that if the
statement is within a section, the label referenced in the statement may
not refer to a {\tt do} construct enclosing a section.

\end{frame}

% -----------------------------------------------------------------------------

% \newframe{Configuration File Grammar -- Formal Specification}
% 
% The starting symbol is {\tt cf} (for ``configuration file'').  Terminal
% symbols are quoted (except {\tt EOS+} is also quoted because of a
% requirement of the parser generator).  The symbol {\tt =$>$} means
% \emph{generates} here (more later), instead of \emph{derives} as it does
% above.  The productions are:
% \vspace*{-6pt}
% 
% {\footnotesize\tt\begin{alltt}
% cf -> cfs
% 
% \vspace*{-4pt}
% \begin{tabbing}
% cfs \= -> one\_cf \\
%     \> -> include \\
%     \> -> cfs one\_cf
% \end{tabbing}
% \vspace*{-7pt}
% 
% \begin{tabbing}
% one\_cf \= -> \= EOS ; blank lines are OK \\
%         \> -> \= select case '(' expr ')' 'EOS+' cases\_outer end select
%         EOS \\
%         \> \> => n\_select \\
%         \> -> construct\_label do do\_header EOS cfs end do EOS => n\_do
%         \\
%         \> -> construct\_label do while '(' expr ')' EOS cfs end do EOS \\
%         \> \>  => n\_while \\
%         \> -> if\_stmt\_outer more\_if\_outer end if EOS => n\_if \\
%         \> -> cycle\_stmt \\
%         \> -> exit\_stmt \\
%         \> -> name ':=' value EOS => n\_variable \\
%         \> -> begin name EOS specs end name EOS => n\_cf
% \end{tabbing}
% 
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% cases\_outer \= -> case\_test\_outer \\
%              \> -> case\_test\_outer cases\_outer \\
%              \> -> case default EOS cfs => n\_default \\
% 
% \end{tabbing}
% case\_test\_outer -> case '(' expr ')' EOS cfs => n\_test
% 
% \begin{tabbing}
% construct\_label \= -> \\
%                 \> -> name ':' => n\_named
% \end{tabbing}
% 
% \begin{tabbing}
% do\_header \= -> name ':=' expr\_array => n\_do\_head \\
%           \> -> name ':=' expr ',' expr => n\_do\_head \\
%           \> -> name ':=' expr ',' expr ',' expr => n\_do\_head
% \end{tabbing}
% 
% expr\_array -> expr => n\_array
% 
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% if\_stmt\_outer -> if '(' expr ')' then EOS cfs => n\_test
% 
% \begin{tabbing}
% more\_if\_outer \= -> \\
%                 \> -> else if\_stmt\_outer more\_if\_outer \\
%                 \> -> else EOS cfs => n\_else \\
% \end{tabbing}
% 
% \begin{tabbing}
% cycle\_stmt \= -> cycle EOS => n\_cycle \\
%             \> -> cycle name EOS => n\_cycle \\
% 
% \end{tabbing}
% 
% \begin{tabbing}
% exit\_stmt \= -> exit EOS => n\_exit \\
%            \> -> exit name EOS => n\_exit \\
% \end{tabbing}
% 
% \begin{tabbing}
% 'EOS+' \= -> EOS \\
%        \> -> 'EOS+' EOS \\
% \end{tabbing}
% 
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% specs \= -> \\
%       \> -> specs spec
% \end{tabbing}
% 
% \begin{tabbing}
% spec \= -> one\_spec EOS \\
%      \> -> include
% \end{tabbing}
% ; "value" is either a scalar or an array enclosed in brackets
% 
% \begin{tabbing}
% one\_spec \= -> \= ; blank lines are OK \\
%           \> -> \> select case '(' expr ')' 'EOS+' cases end select EOS \\
%           \>    \> => n\_select \\
%           \> -> \> construct\_label do while '(' expr ')' EOS specs end do
%           EOS \\
%           \>     \> => n\_while \\
%           \> -> \> construct\_label do do\_header EOS specs end do EOS =>
%           n\_do \\
%           \> -> \> if\_stmt more\_if end if => n\_if \\
%           \> -> \> cycle\_stmt \\
%           \> -> \> exit\_stmt \\
%           \> -> \> name ':=' value => n\_variable \\
%           \> -> \> name ':' spec\_rest => n\_named \\
%           \> -> \> spec\_rest \\
%           \> -> \> name '=' value => n\_equal
% \end{tabbing}
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% 
% ; We need to consume the EOS here so it won't be the first \\
% ; token we see after closing the include file.
% 
% include -> '\#include' string EOS => 9 ; 9 means include a file
% 
% \begin{tabbing}
% cases \= -> case\_test \\
%       \> -> case\_test cases \\
%       \> -> case default EOS specs => n\_default
% \end{tabbing}
% 
% ; "expr" is a scalar
% 
% case\_test -> case '(' expr ')' EOS specs => n\_test
% 
% if\_stmt -> if '(' expr ')' then EOS specs => n\_test
% 
% \begin{tabbing}
% more\_if \= -> \\
%          \> -> else if\_stmt more\_if \\
%          \> -> else EOS specs => n\_else
% \end{tabbing}
% 
% spec\_rest -> name fields => n\_spec\_args
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% fields \= -> \\
%        \> -> ',' field fields
% \end{tabbing}
% 
% \begin{tabbing}
% field \= -> name '=' value => n\_asg \\
%       \> -> '/' name => n\_set\_one
% \end{tabbing}
% 
% ; "value" can be an array enclosed in brackets, or an array of \\
% ; arrays, but not any deeper nesting of arrays.
% 
% \begin{tabbing}
% value \= -> expr \\
%       \> -> '[' value2\_list ']'
% \end{tabbing}
% 
% \begin{tabbing}
% value2\_list \= -> value2 \\
%              \> -> value2\_list ',' value2
% \end{tabbing}
% 
% \begin{tabbing}
% value2 \= -> expr \\
%        \> -> '[' exprs ']' => n\_array
% \end{tabbing}
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% exprs \= -> expr \\
%       \> -> exprs ',' expr
% \end{tabbing}
% 
% \begin{tabbing}
% expr \= -> cond \\
%      \> -> test '?' expr '!' expr => n\_cond
% \end{tabbing}
% 
% \begin{tabbing}
% cond \= -> limit \\
%      \> -> limit ':'   limit => n\_colon \\
%      \> -> limit ':<'  limit => n\_less \\
%      \> -> limit '<:'  limit => n\_less\_colon \\
%      \> -> limit '<:<' limit => n\_less
% \end{tabbing}
% 
% \begin{tabbing}
% limit \= -> lterm \\
%       \> -> limit or lterm => n\_or
% \end{tabbing}
% 
% \begin{tabbing}
% lterm \= -> lnot \\
%       \> -> lterm and lnot => n\_and
% \end{tabbing}
% 
% \begin{tabbing}
% lnot \= -> test \\
%      \> -> not test => n\_not
% \end{tabbing}
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% test \= -> lfactor \\
%      \> -> lfactor '<'  lfactor => n\_less \\
%      \> -> lfactor '<=' lfactor => n\_less\_eq \\
%      \> -> lfactor '>'  lfactor => n\_greater \\
%      \> -> lfactor '>='lfactor => n\_greater\_eq \\
%      \> -> lfactor '==' lfactor => n\_equal\_equal \\
%      \> -> lfactor '/=' lfactor => n\_not\_equal
% \end{tabbing}
% 
% \begin{tabbing}
% lfactor \= -> term \\
%         \> -> '+' term => n\_plus \\
%         \> -> '-' term => n\_minus \\
%         \> -> lfactor '+' term => n\_plus \\
%         \> -> lfactor '-' term => n\_minus
% \end{tabbing}
% 
% \begin{tabbing}
% term \= -> factor \\
%      \> -> term '*' factor => n\_mult \\
%      \> -> term '/' factor => n\_div \\
%      \> -> term '$\setminus$' factor => n\_into
% \end{tabbing}
% 
% \begin{tabbing}
% factor \= -> primary \\
%        \> -> primary '\^{}' factor => n\_pow
% \end{tabbing}
% \end{alltt}}
% 
% \end{frame}
% 
% % -----------------------------------------------------------------------------
% 
% \newframe{Configuration File Grammar -- Formal Specification (cont.)}
% 
% {\footnotesize\tt\begin{alltt}
% \begin{tabbing}
% primary \= -> name dots => n\_dot? \\
%         \> -> number \\
%         \> -> number name => n\_unit \\
%         \> -> string \\
%         \> -> '(' expr ')' \\
%         \> -> '(' expr ')' name => n\_unit \\
%         \> -> name '[' expr ']' => n\_subscript \\
%         \> -> func\_ref \\
%         \> -> func\_ref name => n\_unit
% \end{tabbing}
% 
% func\_ref -> name '(' value2\_list ')' => n\_func\_ref
% 
% \begin{tabbing}
% dots \= -> \\
%      \> -> dot name dots
% \end{tabbing}
% \end{alltt}}
% 
% \end{frame}

% -----------------------------------------------------------------------------

\newframe{Translation}

\parskip 4pt

The {\tt =$>$} notation at the end of a production specifies an internal
vertex to generate in the abstract syntax tree.  Its sons are translations
of symbols in the right-hand-side of the production, in the order they
appear.  If a production does not generate an internal vertex, the
translation of its left-hand-side nonterminal symbol is the sequence of
translations of the right-hand side. The translation of a pseudo-terminal
is its string index, called \emph{sub-rosa} information because it is
passed ``under the table'' through the parser, from the lexer to
subsequent phases.

\vspace*{3pt}
True terminal symbols, such as operators or punctuation, do not have any
automatic translation.

\vspace*{3pt}
The notation ``{\tt =$>$ x ?}'' means ``generate {\tt x} if and only if it
would have more than one son.''

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Translation (cont.)}

To return to our simple example, with generation specified:
\vspace*{-6pt}
\begin{tabbing}
     \= $E$ \= $\rightarrow T $ \\
     \>     \> $ \rightarrow E + T \Rightarrow\, '+' $ \\
     \> $T$ \> $ \rightarrow N $ \\
     \>     \> $ \rightarrow T * N \Rightarrow\, '*' $ \\
     \> $N$ \> $ \rightarrow a \,|\, b \,|\, c$
\end{tabbing}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Translation (cont.)}

\small
The MLS parsing method, called LR, produces the reverse of a rightmost
derivation, i.e., for the example {\tt a + b * c}, the reverse of

\vspace*{5pt}
$E \Rightarrow E + T \Rightarrow E + T * N \Rightarrow E + T * c
\Rightarrow E + N * c \Rightarrow E + b * c \Rightarrow T + b * c
\Rightarrow N + b * c \Rightarrow a + b * c$ is produced.

\vspace*{5pt}
We use ``Cambridge Polish'' notation $< x\, y\, z\, \dots >$ for a subtree
to denote $x$ at the root with sons $y\,z\,\dots$.

\vspace*{5pt}
The reverse of the second step consists of recognizing that $T * N$ should
be \emph{reduced} to $T$ using the fourth production.  The translation of
$T * N$ at that point is the sequence ({\tt b c}), the concatenation of
the translations of $T$ and $N$, so the translation $\mathcal{T} =\, < *\,
b\, c >$ is constructed, and becomes the translation of $T$ upon
reduction.

\vspace*{5pt}
When $E + T$ is reduced to $E$, the translation of $E + T$ is the sequence
({\tt a}~$\mathcal{T})$, so the translation $< +\, a\,\, \mathcal{T} \,>$
is generated, and the complete translation is $< +\, a\, < *\, b\, c >
\,>$.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Translation (cont.)}

{\Large\bfseries
$E \Rightarrow E + T \Rightarrow E + T * N \Rightarrow E + T * c
\Rightarrow E + N * c \Rightarrow E + b * c \Rightarrow T + b * c
\Rightarrow N + b * c \Rightarrow a + b * c$}

\vspace*{0.25in}
\includegraphics[scale=0.95]{wvs-147-3}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Translation (cont.)}

\dots\ resulting in

\begin{centering}
\includegraphics[scale=0.8]{wvs-147-2} \\
\end{centering}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Configuration File Parsing and Translation}

The parser is the subroutine {\tt LR\_Parser} or {\tt LR\_Parser\_TX}
(depending upon which representation of the root of the abstract syntax
tree is desired).  These subroutines are identified by the generic name
{\tt Configuration}, in the {\tt parser} module.\\[5pt]

The parser is a \emph{pushdown automaton}.  It has a stack of states. 
When it reads a token, it can either make a transition, which pushes a new
state on the stack, or recognize the end of the right-hand-side of a
production, which causes it to do a reduction, which removes the
right-hand-side from the stack, generates a translation if one is
specified, and then makes a transition using the left-hand-side of the
recognized production.\\[5pt]

The pushdown automaton is calculated from the grammar by the {\tt LR}
program, and represented by a table produced by that program.
\\[5pt]

Complete formal specification of the Configuration File grammar is in {\tt
mlspgs/util/lr/l2cf.grm} and {\tt mlspgs/doc/wvs-004}.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Tree representation}

{\parskip 5pt
The abstract syntax tree is represented in the {\tt tree} module.  Its
vertex indices are specified in the {\tt tree\_types} module.  The names
of its vertices are used in the formal grammar in {\tt
mlspgs/util/lr/l2cf.grm}

It is stored using {\bf cdr code} (developed by McCarthy at MIT for
lisp).  Sibling vertices are stored in consecutive elements of {\tt
the\_tree} (a private array in the {\tt tree} module).  Their parent
vertex is stored later.  It is represented by a tree vertex kind, a tree
node index, the location of the first son, and the number of sons.

Instead of the tree vertex location of the first son, a pseudo-terminal
vertex has its string index, called \emph{sub-rosa} because the parser
passes it ``under the table'' into the tree.

Vertices of the tree can be examined, and some aspects modified, using
procedures in the {\tt tree} module.
}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking}

Type checking verifies that

\begin{itemize}

\item sections are in allowed order,

\item a parameter declaration or a specification is allowed in a section,

\item fields of a specification are of the correct types, and

\item numeric parameter values or specification field values have allowed
      units.

\end{itemize}

Type checking also constructs symbol and declaration tables, and connects
references to declarations.

\vspace*{3pt}
Symbol table entries are indexed by the string index passed through the
parser as \emph{sub-rosa} information for pseudo-terminal symbols.

\vspace*{3pt}
A symbol might have several declarations, which are in a linked list
starting from the symbol table entry.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- (cont).}

Type checking rules are represented by subtrees specified by {\tt
init\_tables\_module}.  They have the same representation as subtrees
produced by the parser.  They are constructed before the parser runs, and
then connected to the abstract syntax tree as a left brother:

\begin{centering}
\includegraphics[scale=0.7]{wvs-147-4}\\[5pt]
\end{centering}

The type checker then traverses the entire tree.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- (cont).}

Different kinds of type checking requirements are represented by different
trees.  An enumeration type is represented by

$<$ {\tt dt\_def type-name enumerator \dots} $>$.

For example, the type ``{\tt module}'' is
represented by\\[5pt]

\begin{centering}
\includegraphics[scale=0.5]{wvs-147-5}\\[5pt]
\end{centering}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- (cont).}

In the figure, the notation beside a tree vertex and preceded by a colon,
e.g. {\tt t\_module}, is an integer called a \emph{decoration}.  It is
added by the type checker (but decorations can be and are created or
replaced by later processes).  For ``{\tt module}'' it is the index of a
type name.  For ``{\tt ghz}'' and {\tt thz}'' it is the index of an
enumeration literal\dots.

\vspace*{0.1in}
The dotted lines indicate indexing in the symbol table using the string
index.  The type checker creates the declaration table entries, which
indicate that ``{\tt module}'' is a type name (and might have other
declarations), and ``{\tt ghz}'' and ``{\tt thz}'' are enumeration literal
names (and might have other declarations), and in both cases provides the
tree index for their declarations (the root of the type definition tree, a
vertex of type ``{\tt dt\_def}'').

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- Complicated examples}

%\vspace*{0.38in}
%\includegraphics[scale=0.25,angle=0]{wvs-147-6.jpg}
%\includegraphics[scale=0.5,angle=270]{wvs-147-6.pdf} % tgif lost colors in eps?
\includegraphics[scale=0.45,angle=270]{wvs-147-6}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- Complicated examples}

%\vspace*{1in}
\hspace*{0.4in}
\includegraphics[bb=17 71 466 716,scale=0.50,angle=270]{tree-1}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking -- Complicated examples}

\vspace*{-0.2in}

\includegraphics[scale=0.45,angle=270]{wvs-147-7}

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Type checking}

The type checker is the subroutine {\tt Check\_Tree} in the {\tt
tree\_checker} module.  This module is in {\tt mlspgs/srclib}.  It depends
upon named constants that are defined in {\tt init\_tables\_module}.  The
{\tt mlsl1} and {\tt mlsl2} programs have different versions of that
module, in {\tt mlspgs/l1} and {\tt mlspgs/l2}.  The named constants have
different values in those programs.  Therefore it cannot be in {\tt
mlspgs/lib}.

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Traversing the tree -- sections}

Given {\tt root} as the root of the subtree and {\tt first\_section} as
the subtree index of the next son to process, get the next son and update
the state (which one to do next):

{\tt son = next\_tree\_node(root,state,start=first\_section)
}\\[5pt]

{\tt son} is now the index of a {\tt cf} vertex.  Its first son is the
section name vertex.  Get the literal index of the section name:

{\tt section\_index = decoration(subtree(1,son))
}

The decoration was put into the section name vertex by the type
checker\\[5pt]

Decide which section to process:

{\tt {\bf select case} ( section\_index )
}\\[5pt]

Process MLS signals (for instance):

{\tt {\bf case} ( z\_mlsSignals )\\
{\bf call} MLSSignals ( son )
}\\[5pt]

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Traversing the tree -- within a section}

Let {\tt root} be the root of the subtree.  Its sons are either
specifications or parameter assignments.  (In MLSSignals we know they're
all specifications.)  Get the next son:

{\tt son = next\_tree\_node ( root, state )
}\\[5pt]

Get the label and the tree node index of the
specification or parameter assignment:

{\tt {\bf call} get\_label\_and\_spec ( son, name, key )\\
! node\_id(key) is now n\_spec\_args
}\\[5pt]

Get the identity of the next son:

{\tt\small {\bf select~case}~(~decoration(subtree(1,decoration(subtree(1,key))))~)
}\\[5pt]

\end{frame}

% -----------------------------------------------------------------------------

\newframe{Traversing the tree -- process the fields}

In {\tt MLSSignals}, for example:\\[5pt]

{\tt {\bf do} j = 2, nsons(key)\\
\hspace*{0.1in}son = subtree(j,key) ! n\_Asg (assign) vertex \\
\hspace*{0.1in}{\small field = decoration(subtree(1,son) ! of the field
name}\\
\hspace*{0.1in}gson = subtree(2,son) ! tree index of the subtree\\
\hspace*{0.1in}! after the ``='' sign after the field name\\
\hspace*{0.1in}{\bf select case} ( field )\\
\hspace*{0.1in}{\bf case} ( f\_centerFrequency )\\
\hspace*{0.2in}! Evaluate gson expression and check units\\
\hspace*{0.2in}{\small{\bf~call}~expr\_check~(~gson,~units,~value,~field,~phyq\_frequency~)}\\
\hspace*{0.2in}band\%centerFrequency = value(1)\\
\hspace*{0.1in}{\bf case} ( f\_suffix )\\
\hspace*{0.2in}{\small band\%suffix = sub\_rosa(gson) ! string index of
suffix}\\
\hspace*{0.1in}{\bf case} ( f\_radiometer )\\
\hspace*{0.2in}{\small band\%radiometer = decoration(decoration(gson))}\\
\hspace*{0.2in}! lit index of radiometer
}

\end{frame}

\end{document}

% $Id$

% $Log$
% Revision 1.5  2018/11/30 22:29:02  pwagner
% Replaced \includegraphics* with \includegraphics
%
% Revision 1.4  2018/11/21 01:21:32  vsnyder
% Add comments about how to make the graphics.  Fiddle includegraphics lines
% so that graphics come out oriented and sized correctly.
%
% Revision 1.3  2018/05/30 20:41:25  vsnyder
% Updated after presentation
%
% Revision 1.2  2018/05/30 17:37:41  vsnyder
% Updated for presentation
%
% Revision 1.1  2017/11/28 01:29:07  vsnyder
% Initial commit -- incomplete
%
