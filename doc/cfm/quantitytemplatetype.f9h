type QuantityTemplate_T

    ! Some administrative stuff

    integer :: name = 0        ! Not used

    ! This integer is of an enumerated type describing what kind of
    ! quantity this is -- one of the l_lits of type t_quantityType
    integer :: quantityType

    ! The dimensions of this quantity

    integer :: noInstances     ! Number of horizontal instances in this quantity
    integer :: noSurfs         ! Number of surfaces per instance
    integer :: noChans         ! Number of channels
    ! So far, the next two are used only for TScat quantities

    ! Flags describing the quantity

    logical :: coherent        ! Do instances have same vertical coordinates?
    logical :: stacked         ! Are instances true vertical profiles?
    logical :: regular         ! Are all channels/heights represented

    ! This next one allows software using the vector quantities to be somewhat
    ! lazy and, for example, avoid interpolation.  Minor frame quantities are
    ! incoherent and unstacked, but may be regular or irregular.  However, not
    ! all incoherent unstacked quantities are minor frame quantities.

    logical :: minorFrame      ! Is this a minor frame quantity.
    logical :: majorFrame      ! Is this a major frame quantity.

    ! This one indicates whether log or linear interpolation should be used
    logical :: logBasis                 ! If set use log
    real(r8) :: minValue                ! Minimum value to consider if using log

    ! This information describes how much of the data is in the overlap
    ! regions if any.

    integer :: noInstancesLowerOverlap
    integer :: noInstancesUpperOverlap

    ! Misc. information
    real(r8) :: badValue      ! Value used to flag bad/missing data
    integer :: unit           ! Unit quantity is in when scaled as below,
                              ! an l_lit of the type t_units in Units.f90.

    ! For regular quantities the number of elements of each instance
    ! is simply noSurfs*noChans.  For irregular ones it is less, but it is
    ! constant from instance to instance; this is that number.
    integer :: instanceLen

    ! Vertical coordinate
    integer :: verticalCoordinate ! The vertical coordinate used.  These
                                  ! are l_lits of the type t_VGridCoord
                                  ! defined in Init_Tables_Module.
    logical :: sharedVGrid        ! Set if surfs is a pointer not a copy
    integer :: vGridIndex         ! Index of any vGrid used
    real(r8), dimension(:,:), pointer :: surfs => NULL()

    ! This is dimensioned (noSurfs,1) for coherent quantities and
    ! (noSurfs, noInstances) for incoherent ones.  Pretending the values are
    ! dimensioned (noChans, noSurfs, noInstances), the SURFS coordinate
    ! for the (:,i,j) values is surfs(i,1) for a coherent quantity or
    ! surfs(i,j) for an incoherent one.

    ! Horizontal coordinates
    logical :: sharedHGrid              ! Set if horiz coords a pointer not a copy
    integer :: hGridIndex               ! Index of any hGrid used
    integer :: instanceOffset           ! Ind of 1st non overlapped instance
                                        ! in output
    integer :: grandTotalInstances      ! Total number of instances 
                                        ! in destination output file
    ! for example MAF index, or profile index.
    real(r8), dimension(:,:), pointer :: phi => NULL()

    ! This is dimensioned (1, noInstances) for stacked quantities and
    ! (noSurfs, noInstances) for unstacked ones.  The PHI coordinate for the
    ! (i,j) value is phi(1,j) for a stacked quantity and phi(i,j) for an
    ! unstacked one.

    ! These other coordinates are dimensioned in the same manner:
    real(r8), dimension(:,:), pointer :: geodLat => NULL()
    real(r8), dimension(:,:), pointer :: lon => NULL()
    real(r8), dimension(:,:), pointer :: time => NULL() ! Seconds since EPOCH
    real(r8), dimension(:,:), pointer :: solarTime => NULL()
    real(r8), dimension(:,:), pointer :: solarZenith => NULL()
    real(r8), dimension(:,:), pointer :: losAngle => NULL()

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! For quantities containing `channels' the following information may or
    ! may not be useful.

    ! Some quantities are on abritrary freqency grids; these quantities refer
    ! to those.
    logical, pointer :: Channels(:) => NULL() ! If /keepChannels is set
    integer :: frequencyCoordinate ! Not used
    logical :: sharedFGrid              ! Not used
    integer :: fGridIndex               ! Not used
    real(r8), dimension(:), pointer :: frequencies => NULL() ! Not used
                                                   ! (noChans)
    real(r8) :: lo                      ! Local oscillator
    integer :: signal                   ! Index into signals database
    integer :: sideband                 ! Associated sideband -1, 0, +1

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ! Some families of quantities require special additional information.
    ! This is given here if needed.

    integer :: instrumentModule ! Index in the Modules database
    integer :: radiometer       ! For ptan etc., index into radiometers database
    integer :: reflector        ! For reflector efficiency etc. terms
    integer :: molecule ! What molecule does this refer to? (One of the l_...
                        ! lits of type t_molecule in Molecules.)

    ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    ! For irregular quantities, instead of using the we have these arrays to
    ! help us navigate around the quantity.

    integer, dimension(:,:), pointer :: surfIndex => NULL()
    integer, dimension(:,:), pointer :: chanIndex => NULL()
    ! These are actually dimensioned (instanceLen, noInstances)
end type QuantityTemplate_T

