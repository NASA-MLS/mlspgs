; This l2cf segment is useful for constructing `standard' species.
; It will make heavy use of m4 to (hopefully) simplify things.

begin Construct

  ;; ----------------------------------------- Macros

  ;; Define all the molecules we'll consider.  Note that this is only
  ;; non-isotopic species (at least for the moment).
  ;; *** NOTE NO CONTINUATION LINES ALLOWED, SORRY!
  !ifdef(precisionEstimates,{
  !define(allLinearSRMolecules,{BrO, CH3CN, CO, ClO, HCl, HCN, H2O2, HNO3, HOCl, HO2, N2, N2O, OH, O2, SO2})

;  No log standard resolution molecules, so must not add to lists
;  !define(allLogSRMolecules,{})

  !define(allLinearVRMolecules,{O3})
  !define(allLogVRMolecules,{H2O})
  },{
  !define(allLinearMolecules,{BrO, CH3CN, CO, ClO, HCl, HCN, H2O2, HNO3, HOCl, HO2, N2, N2O, OH, O2, O3, SO2})

  !define(allLogMolecules,{H2O})

  !define(allLinearHRMolecules,{O3})
  !define(allLogHRMolecules,{H2O})
  })

  ;; Most users can pretty much ignore the stuff below here.
  ;; (And much of the stuff above really!)

  ;; ----------------------------------------- Derived macros

  ;; These are macros derived from above
  !ifdef(precisionEstimates,{
  !define(allSRMolecules,{!allLinearSRMolecules})
;  !define(allSRMolecules,{!allLinearSRMolecules,!allLogSRMolecules})
  !define(allVRMolecules,{!allLinearVRMolecules,!allLogVRMolecules})
  !define(allMolecules,{!allSRMolecules,!allVRMolecules})
  },{
  !define(allMolecules,{!allLinearMolecules, !allLogMolecules})
  !define(allHiResMolecules,
    {!makelist({},{_HR},!allLinearHRMolecules),!makelist({},{_HR},!allLogHRMolecules)})
  })

  ;; ----------------------------------------- Tangent pressures and phis

  ptanGHz: Quantity, type=ptan, module=GHz
  ptanTHz: Quantity, type=ptan, module=THz

  phitanGHz: Quantity, type=phitan, module=GHz
  phitanTHz: Quantity, type=phitan, module=THz

  ;; ----------------------------------------- Temperature / refgph
  
  !ifdef(precisionEstimates,{
  !ifelse(!resolution,standard,!dnl
    {temperature: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
     type=temperature},!dnl
    {temperature: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, $
     type=temperature})
  },{
  temperature: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=temperature
  temperature_HR: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, type=temperature
  })
  refGPH: Quantity, vGrid=vGridRefGPH, hGrid=hGridStandard, type=refGPH
  !ifdef(precisionEstimates,{
  !ifelse(!resolution,{standard},!dnl
    {GPH: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
     type=GPH},!dnl
    {GPH: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, $
     type=GPH})
  },{
  GPH: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=GPH
  })
  
  ;; ----------------------------------------- Volume mixing ratios

  ;; We'll make extensive use of m4 macros here.
  ;; First macros that define individual molecules.
  !ifdef(precisionEstimates,{
  !define(constructLinearSRVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructLogSRVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis!nl})
  !define(constructLinearHRVMR,{$1: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructLogHRVMR,{$1: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis!nl})

  ;; Define the 'standard' vmrs
  !forall( {constructLinearSRVMR}, !allLinearSRMolecules )
;  !forall( {constructLogSRVMR}, !allLogSRMolecules )

  ;; Define the 'variable resolution' vmrs
  ;; Note! Do not put a space before the closing parentheses as it
  ;; screws ends up between the molecule name and the _HR for the last
  ;; molecule in the list!
  !ifelse(!resolution,{standard},!dnl
    {!forall( {constructLinearSRVMR}, !allLinearVRMolecules)},!dnl
    {!forall( {constructLinearHRVMR}, !allLinearVRMolecules)})
  !ifelse(!resolution,{standard},!dnl
    {!forall( {constructLogSRVMR}, !allLogVRMolecules)},!dnl
    {!forall( {constructLogHRVMR}, !allLogVRMolecules)})

  ;; ----------------------------------------- RHI
  !ifelse(!resolution,{standard},!dnl
    {rhi: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
     type=rhi, molecule=h2o},!dnl
    {rhi: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, $
     type=rhi, molecule=h2o})
  },{
  !define(constructLinearVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructLogVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis!nl})
  !define(constructHiResLinearVMR,{$1{_HR}: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructHiResLogVMR,{$1{_HR}: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis!nl})

  ;; Define the 'standard' vmrs
  !forall( {constructLinearVMR}, !allLinearMolecules )
  !forall( {constructLogVMR}, !allLogMolecules )

  ;; Define the 'HiRes' vmrs
  ;; Note! Do not put a space before the closing parentheses as it
  ;; screws ends up between the molecule name and the _HR for the last
  ;; molecule in the list!
  !forall( {constructHiResLinearVMR}, !allLinearHRMolecules)
  !forall( {constructHiResLogVMR}, !allLogHRMolecules)

  ;; ----------------------------------------- RHI
  rhi: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=rhi, $
    molecule=h2o
  })
  
  ;; ----------------------------------------- Baselines
  
  !define(constructBaseline,{baseline$1: Quantity, type=baseline, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridBaseline, $
    fGrid=fGridBaseline$1!nl})

  !forall(constructBaseline, !allRadiometers )
  !define(allBaselines, {!makelist({baseline},{},!allRadiometers)})

  ;; ----------------------------------------- Extinctions

  !define(constructExtinction,{extinction$1: Quantity, type=extinction, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridExtinction, $
    fGrid=fGridExtinction$1!nl})
  !forall(constructExtinction, !allRadiometers )
  !define(allExtinctions, {!makelist({extinction},{},!allRadiometers)})

  ;; ----------------------------------------- Isotope ratios
  
  !define(constructIsotopeRatio,{isotoperatio$1: Quantity, type=isotopeRatio, $
    molecule=$1!nl})
    
  ;; Note! Do not put a space before the close parentheses here
  ;; otherwise it will end up before the _ratio on the last molecule
  !forall(constructIsotopeRatio,!isotopicMolecules)
  !define(allIsotopeRatios,{!makelist({isotoperatio},{},!isotopicMolecules)})

  ;; ----------------------------------------- Radiances

  !define(constructRadiance,{band$1: Quantity, type=radiance, signal=!signal($1)!nl})

  ;; Folded
  !forall(constructRadiance,!allBands)

  ;; Split
  !forall(constructRadiance,!allBandLSBs)
  !forall(constructRadiance,!allBandUSBs)

  ;; All
  !define(allFoldedRadiances, {!makelist({band},{},!allBands)})
  !define(allLSBRadiances, {!makelist({band},{},!allBandLSBs)})
  !define(allUSBRadiances, {!makelist({band},{},!allBandUSBs)})
  !define(allUnfoldedRadiances,{!allLSBRadiances, !allUSBRadiances})

  ;; ----------------------------------------- OpticalDepths

  !define(constructDepth,{depth$1: Quantity, type=opticalDepth, signal=!signal($1)!nl})

  ;; Folded
  !forall(constructDepth,!allBands)

  ;; Split
  !forall(constructDepth,!allBandLSBs)
  !forall(constructDepth,!allBandUSBs)

  ;; All
  !define(allFoldedDepths, {!makelist({depth},{},!allBands)})
  !define(allLSBDepths, {!makelist({depth},{},!allBandLSBs)})
  !define(allUSBDepths, {!makelist({depth},{},!allBandUSBs)})
  !define(allUnfoldedDepths,{!allLSBDepths, !allUSBDepths})

  ;; ----------------------------------------- Sideband ratios

  !define(constructSidebandRatio, {sidebandRatio$1: Quantity, type=sidebandRatio, $
    signal=!signal($1)!nl})
  
  ;; These are all split now
  !forall(constructSidebandRatio,!allBandLSBs)
  !forall(constructSidebandRatio,!allBandUSBs)

  ;; All
  !define(allLSBRatios, {!makelist({sidebandRatio},{},!allBandLSBs)})
  !define(allUSBRatios, {!makelist({sidebandRatio},{},!allBandUSBs)})
  !define(allSidebandRatios, {!allLSBRatios, !allUSBRatios})

  ;; ----------------------------------------- System temperatures

  !define(constructSystemTemperature, {systemTemperature$1: Quantity, $
    type=systemTemperature, signal=!signal($1)!nl})
  
  !forall(constructSystemTemperature,!allBands)

  !forall(constructSystemTemperature,!allBandLSBs)
  !forall(constructSystemTemperature,!allBandUSBs)

  ;; All
  !define(allFoldedSystemTemperatures, {!makelist({systemTemperature},{},!allBands)})
  !define(allLSBSystemTemperatures, {!makelist({systemTemperature},{},!allBandLSBs)})
  !define(allUSBSystemTemperatures, {!makelist({systemTemperature},{},!allBandUSBs)})
  !define(allUnfoldedSystemTemperatures, {!allLSBSystemTemperatures, !allUSBSystemTemperatures})

  ;; ----------------------------------------- Noise bandwidths

  !define(constructNoiseBandwidth, {noiseBandwidth$1: Quantity, $
    type=noiseBandwidth, signal=!signal($1)!nl})
  
  !forall(constructNoiseBandwidth,!allBands)

  !forall(constructNoiseBandwidth,!allBandLSBs)
  !forall(constructNoiseBandwidth,!allBandUSBs)

  ;; All
  !define(allFoldedNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBands)})
  !define(allLSBNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBandLSBs)})
  !define(allUSBNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBandUSBs)})
  !define(allUnfoldedNoiseBandwidths, {!allLSBNoiseBandwidths, !allUSBNoiseBandwidths})

  ;; ----------------------------------------- Scan residuals

  scanResidualGHz: Quantity, type=scanResidual, module=GHz
  scanResidualTHz: Quantity, type=scanResidual, module=THz

  ;; ----------------------------------------- Elevation offsets

  !define(constructElev,{elev$1: Quantity, type=elevOffset, radiometer=$1!nl})
  !forall(constructElev,!allRadiometers)
  !define(allElevs, {!makelist({elev},{},!allRadiometers)})

  ;; ----------------------------------------- Other minor stuff

  earthReflectivity: quantity, type = earthRefl
  orbitInclination: Quantity, type = orbitInclination, module=SC
  spaceRadiance: quantity, type = spaceRadiance

  scGeocAlt: Quantity, type = scGeocAlt, module=SC
  tngtGeocAltGHz: Quantity, type=tngtGeocAlt, module=GHz
  tngtGeocAltTHz: Quantity, type=tngtGeocAlt, module=THz

  scECI: quantity, type=scECI, module=SC
  tngtECIGHz: quantity, type=tngtECI, module=GHz
  tngtECITHz: quantity, type=tngtECI, module=THz

  scVelECI: quantity, type=scVelECI, module=SC
  scVelECR: quantity, type=scVelECR, module=SC
  losVelGHz: quantity, type=losVel, module=GHz
  losVelTHz: quantity, type=losVel, module=THz

  !define(lesserState, {earthReflectivity, orbitInclination, spaceRadiance, $
    scGeocAlt, tngtGeocAltGHz, tngtGeocAltTHz, scECI, tngtECIGHz, tngtECITHz, $
    scVelECR, scVelECI, losVelGHz, losVelTHz})

  ;; ------------------------------------------- Now define vector templates

  ;; Put extra line breaks here to get round a problem I'm having
  ;; running this with NAG.
  stateTemplate: VectorTemplate, quantities = [ $
    ptanGHZ, ptanTHz, phitanGHz, phitanTHz, temperature, $
    !ifdef(precisionEstimates,{},{!ifdef(skipHiRes,{},{temperature_HR,})}) $
    refGPH, GPH, $
    !allMolecules, $
    !ifdef(precisionEstimates,{},{!ifdef(skipHiRes,{},{!allHiResMolecules,})}) $
    rhi, !allBaselines, $
    !allExtinctions, $
    !allIsotopeRatios, $
    !allSidebandRatios, $
    !allFoldedSystemTemperatures, $
    !allUnfoldedSystemTemperatures, $
    !allFoldedNoiseBandwidths, $
    !allUnfoldedNoiseBandwidths, $
    !allElevs, $
    !lesserState ]

  measurementTemplate: VectorTemplate, quantities = [ $
    !allFoldedRadiances, scanResidualGHz, scanResidualTHz ]

  depthTemplate: VectorTemplate, quantities = [ !allFoldedDepths ]

end Construct
