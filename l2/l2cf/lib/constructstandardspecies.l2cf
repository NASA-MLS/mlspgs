; This l2cf segment is useful for constructing `standard' species.
; It will make heavy use of m4 to (hopefully) simplify things.

begin Construct

  ;; ----------------------------------------- Macros

  ;; Define all the molecules we'll consider.  Note that this is only
  ;; non-isotopic species (at least for the moment).
  ;; *** NOTE NO CONTINUATION LINES ALLOWED, SORRY!
  !define(allLinearMolecules,{BrO, CH3CL, CH3CN, CO, ClO, H2CO, H2O2, H2S, HCN, HCl, HNO3, HO2, HOCl, N2, N2O, NO, NO2, O2, O3, OCS, OH, SO2})
  !define(allLogMolecules,{H2O})
  !define(allLinearHRMolecules,{O3})
  !define(allLogHRMolecules,{H2O})

  ;; Most users can pretty much ignore the stuff below here.
  ;; (And much of the stuff above really!)

  ;; ----------------------------------------- Derived macros

  ;; These are macros derived from above
  !define(allMolecules,{!allLinearMolecules, !allLogMolecules})
  !define(allHiResMolecules,
    {!makelist({},{_HR},!allLinearHRMolecules),!makelist({},{_HR},!allLogHRMolecules)})

  ;; ----------------------------------------- Tangent pressures and phis

  ptanGHz: Quantity, type=ptan, module=GHz
  ptanTHz: Quantity, type=ptan, module=THz

  phitanGHz: Quantity, type=phitan, module=GHz
  phitanTHz: Quantity, type=phitan, module=THz

  ;; ----------------------------------------- Temperature / refgph

  temperature: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=temperature
  temperature_HR: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, $
    type=temperature
  GPH: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=GPH
  GPH_HR: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, type=GPH
  refGPH: Quantity, vGrid=vGridRefGPH, hGrid=hGridStandard, type=refGPH
  
  ;; ----------------------------------------- Volume mixing ratios

  ;; We'll make extensive use of m4 macros here.
  ;; First macros that define individual molecules.
  !define(constructLinearVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructLogVMR,{$1: Quantity, vGrid=vGridStandard, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis, minValue=0.1 ppmv!nl})
  !define(constructHiResLinearVMR,{$1{_HR}: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1!nl})
  !define(constructHiResLogVMR,{$1{_HR}: Quantity, vGrid=vGridHiRes, $
    hGrid=hGridStandard, type=vmr, molecule=$1, /logBasis, minValue=0.1 ppmv!nl})

  ;; Define the 'standard' vmrs
  !forall( {constructLinearVMR}, !allLinearMolecules )
  !forall( {constructLogVMR}, !allLogMolecules )

  ;; Define the 'HiRes' vmrs
  ;; Note! Do not put a space before the closing parentheses as it
  ;; screws ends up between the molecule name and the _HR for the last
  ;; molecule in the list!
  !forall( {constructHiResLinearVMR}, !allLinearHRMolecules)
  !forall( {constructHiResLogVMR}, !allLogHRMolecules)

  ;; We'll do Trop. H2O as a special one here.
  tropH2O: Quantity, type=vmr, molecule=h2o, $
    vGrid=vGridTropH2O, hGrid=hGridStandard, /logBasis, minValue=0.1ppmv
  tropH2O_HR: Quantity, type=vmr, molecule=h2o, $
    vGrid=vGridTropH2OHiRes, hGrid=hGridStandard, /logBasis, minValue=0.1ppmv

  ;; ----------------------------------------- RHI
  rhi: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=rhi, $
    molecule=h2o
  rhi_HR: Quantity, vGrid=vGridHiRes, hGrid=hGridStandard, type=rhi, $
    molecule=h2o
  
  ;; ----------------------------------------- Columns
  tpPressure: Quantity, type=boundaryPressure, hGrid=hGridStandard
  !define(constructColumn,{column_$1: Quantity, type=columnAbundance, $
    molecule=$1, hGrid=hGridStandard!nl})

  !forall( {constructColumn}, !allLinearMolecules )
  !forall( {constructColumn}, !allLogMolecules )
  !define(allColumns,
    {!makelist({column_},{},!allLinearMolecules),!makelist({column_},{},!allLogMolecules)})

  ;; ----------------------------------------- Cloud Input/Output
  hGridFine: hGrid, type=regular, spacing=0.5 degrees, origin=0 degrees, $
  module=GHz, /forbidOverspill, /insetOverlaps
  
  PSD:  Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=sizeDistribution
  earthradius: Quantity, hGrid=hGridStandard, type=earthradius
  surfaceType: Quantity, hGrid=hGridStandard, type=surfaceType

  IWC_Coarse:  Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=CloudIce
  LWC:  Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=CloudWater

  IWC:  Quantity, vGrid=vGridIWC, hGrid=hGridFine, type=CloudIce

  trans:   Quantity, type=  losTransFunc,   Sgrid=sGridStandard, module=GHz
  cext:    Quantity, vGrid= vGridIWC, hGrid=hGridStandard, type=cloudExtinction
  cextFine:    Quantity, vGrid= vGridIWC, hGrid=hGridFine, type=cloudExtinction

  ;; Folded radiance-like quantities for cloud models
  !define(constructDT,{DTband$1: Quantity, $
    type=cloudInducedRadiance, signal=!signal($1)!nl})
  !forall(constructDT,!allBands)
  !forall(constructDT,!allBandLSBs)
  !forall(constructDT,!allBandUSBs)
  
  !define(constructSENS,{SENSband$1: Quantity, $
    type=cloudRADSensitivity, signal=!signal($1)!nl})
  !forall(constructSENS,!allBandLSBs)
  !forall(constructSENS,!allBandUSBs)

  !define(allDTs,{!makelist({DTBand},{},!allBands)})
  !define(allSens,{!makelist({sensBand},{},!allLSBands)})
  !define(allSens,{!makelist({sensBand},{},!allUSBands)})
  
  !define(constructEOD,{EODband$1: Quantity, $
    type=effectiveOpticalDepth, signal=!signal($1)!nl})
  !forall(constructEOD,!allBands)
  !define(allEODS,{!makelist({EODband},{},!allBands)})

  massMeanDiameterIce: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
    type=massMeanDiameterIce
  massMeanDiameterWater: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
    type=massMeanDiameterWater

  ;; cldRad in l2gp format for quality flag uses
  !define(constructCloudMinMax,{!dnl
  cloudRadMin$1: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=temperature
  cloudRadMax$1: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=temperature!nl})
  !forall(constructCloudMinMax,!allBands)
  !define(allCloudMinMax,{!makelist({cloudRadMin},{},!allBands),!makelist({cloudRadMax},{},!allBands)})

  ;; ----------------------------------------- Baselines
  !define(constructBaseline,{baseline$1: Quantity, type=baseline, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridBaseline, $
    fGrid=fGridBaseline$1!nl})

  !forall(constructBaseline, !allRadiometers )
  !define(allBaselines, {!makelist({baseline},{},!allRadiometers)})

  ;; ----------------------------------------- Extinctions

  !define(constructExtinction,{!dnl
  extinctionShaped$1: Quantity, type=vmr, molecule=extinction, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridExtinction, $
    fGrid=fGridExtinction$1
  extinctionConstant$1: Quantity, type=vmr, molecule=extinction, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridExtinction, $
    fGrid=fGridExtinctionConstant
  extinctionShaped$1_HR: Quantity, type=vmr, molecule=extinction, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridExtinctionHiRes, $
    fGrid=fGridExtinction$1
  extinctionConstant$1_HR: Quantity, type=vmr, molecule=extinction, $
    radiometer=$1, hGrid=hGridStandard, vGrid=vGridExtinctionHiRes, $
    fGrid=fGridExtinctionConstant!nl})
  !forall(constructExtinction, !allRadiometers)
  !define(allShapedExtinctions, {!makelist({extinctionShaped},{},!allRadiometers),$
    !makelist({extinctionShaped},{_HR},!allRadiometers)})
  !define(allConstantExtinctions, {!makelist({extinctionConstant},{},!allRadiometers),$
    !makelist({extinctionConstant},{_HR},!allRadiometers)})
    
  !define(allExtinctions, {!allShapedExtinctions,!allConstantExtinctions})

  ;; ----------------------------------------- Isotope ratios
  
  !define(constructIsotopeRatio,{isotoperatio$1: Quantity, type=isotopeRatio, $
    molecule=$1!nl})
    
  ;; Note! Do not put a space before the close parentheses here
  ;; otherwise it will end up before the _ratio on the last molecule
  !forall(constructIsotopeRatio,!isotopicMolecules)
  !define(allIsotopeRatios,{!makelist({isotoperatio},{},!isotopicMolecules)})

  ;; ----------------------------------------- Radiances

  !define(constructRadiance,{band$1: Quantity, type=radiance, signal=!signal($1)!nl})

  ;; Folded
  !forall(constructRadiance,!allBands)

  ;; Split
  !forall(constructRadiance,!allBandLSBs)
  !forall(constructRadiance,!allBandUSBs)

  ;; All
  !define(allFoldedRadiances, {!makelist({band},{},!allBands)})
  !define(allLSBRadiances, {!makelist({band},{},!allBandLSBs)})
  !define(allUSBRadiances, {!makelist({band},{},!allBandUSBs)})
  !define(allUnfoldedRadiances,{!allLSBRadiances, !allUSBRadiances})

  ;; ----------------------------------------- OpticalDepths

  !define(constructDepth,{depth$1: Quantity, type=opticalDepth, signal=!signal($1)!nl})

  ;; Folded
  !forall(constructDepth,!allBands)

  ;; Split
  !forall(constructDepth,!allBandLSBs)
  !forall(constructDepth,!allBandUSBs)

  ;; All
  !define(allFoldedDepths, {!makelist({depth},{},!allBands)})
  !define(allLSBDepths, {!makelist({depth},{},!allBandLSBs)})
  !define(allUSBDepths, {!makelist({depth},{},!allBandUSBs)})
  !define(allUnfoldedDepths,{!allLSBDepths, !allUSBDepths})

  ;; ----------------------------------------- Sideband fractions

  !define(constructSidebandFractions, {!dnl
  limbSidebandFraction$1: Quantity, type=limbSidebandFraction, signal=!signal($1)
  calSidebandFraction$1: Quantity, type=calSidebandFraction, signal=!signal($1)!nl})
  
  ;; These are all split now
  !forall(constructSidebandFractions,!allBandLSBs)
  !forall(constructSidebandFractions,!allBandUSBs)

  ;; All
  !define(allSidebandFractions, {!dnl
    !makelist({limbSidebandFraction},{},!allBandLSBs), !dnl
    !makelist({calSidebandFraction},{},!allBandLSBs), !dnl
    !makelist({limbSidebandFraction},{},!allBandUSBs), !dnl
    !makelist({calSidebandFraction},{},!allBandUSBs)})

  ;; ----------------------------------------- System temperatures

  !define(constructSystemTemperature, {systemTemperature$1: Quantity, $
    type=systemTemperature, signal=!signal($1)!nl})
  
  !forall(constructSystemTemperature,!allBands)

  !forall(constructSystemTemperature,!allBandLSBs)
  !forall(constructSystemTemperature,!allBandUSBs)

  ;; All
  !define(allFoldedSystemTemperatures, {!makelist({systemTemperature},{},!allBands)})
  !define(allLSBSystemTemperatures, {!makelist({systemTemperature},{},!allBandLSBs)})
  !define(allUSBSystemTemperatures, {!makelist({systemTemperature},{},!allBandUSBs)})
  !define(allUnfoldedSystemTemperatures, {!allLSBSystemTemperatures, !allUSBSystemTemperatures})

  ;; ----------------------------------------- Noise bandwidths

  !define(constructNoiseBandwidth, {noiseBandwidth$1: Quantity, $
    type=noiseBandwidth, signal=!signal($1)!nl})
  
  !forall(constructNoiseBandwidth,!allBands)

  !forall(constructNoiseBandwidth,!allBandLSBs)
  !forall(constructNoiseBandwidth,!allBandUSBs)

  ;; All
  !define(allFoldedNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBands)})
  !define(allLSBNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBandLSBs)})
  !define(allUSBNoiseBandwidths, {!makelist({noiseBandwidth},{},!allBandUSBs)})
  !define(allUnfoldedNoiseBandwidths, {!allLSBNoiseBandwidths, !allUSBNoiseBandwidths})

  ;; ----------------------------------------- ChiSquares

  !define(ConstructChisqStuff, {!dnl
    chisqMMAF$1: Quantity, type=chisqMMAF, signal=!signal($1)
    chisqMMIF$1: Quantity, type=chisqMMIF, signal=!signal($1)
    chisqChan$1: Quantity, type=chisqChan, signal=!signal($1)
    noRadsPerMIF$1: Quantity, type=noRadsPerMIF, signal=!signal($1)
    chisqBinned$1: Quantity, type=chisqBinned, signal=!signal($1), $
      vGrid=vGridStandard, hGrid=hGridStandard
    noRadsBinned$1: Quantity, type=noRadsBinned, signal=!signal($1), $
      vGrid=vGridStandard, hGrid=hGridStandard!nl})
  !forall(ConstructChisqStuff,!allBands)

  !define(allChisqMMAFs,{!makelist({chisqMMAF},{},!allBands)})
  !define(allChisqMMIFs,{!makelist({chisqMMIF},{},!allBands)})
  !define(allChisqChans,{!makelist({chisqChan},{},!allBands)})
  !define(allChisqBinned,{!makelist({chisqBinned},{},!allBands)})
  !define(allNoRadsPerMIF,{!makelist({noRadsPerMIF},{},!allBands)})
  !define(allNoRadsBinned,{!makelist({noRadsBinned},{},!allBands)})

  ;; ----------------------------------------- Scan residuals

  scanResidualGHz: Quantity, type=scanResidual, module=GHz
  scanResidualTHz: Quantity, type=scanResidual, module=THz

  ;; ----------------------------------------- Elevation offsets

  !define(constructElev,{elev$1: Quantity, type=elevOffset, signal=!signal($1)!nl})
  !forall(constructElev,!allBandLSBs,!allBandUSBs)
  !define(allElevs, {!makelist({elev},{},!allBandLSBs,!allBandUSBs)})

  ;; ----------------------------------------- Antenna terms

  !ifdef(flagSkipLossTerms,{},{

  reflTempPrimary: Quantity, type=reflTemp, reflector=primary, module=GHz
  reflTempSecondary: Quantity, type=reflTemp, reflector=secondary, module=GHz
  reflTempTertiary: Quantity, type=reflTemp, reflector=tertiary, module=GHz

  !define(constructAntennaTerms,{!dnl
  ;; Primary
  reflReflPrimary$1: Quantity, type=reflRefl, reflector=primary, signal=!signal($1)
  reflTransPrimary$1: Quantity, type=reflTrans, reflector=primary, signal=!signal($1)
  reflSpillPrimary$1: Quantity, type=reflSpill, reflector=primary, signal=!signal($1)
  ;; Secondary
  reflReflSecondary$1: Quantity, type=reflRefl, reflector=secondary, signal=!signal($1)
  reflTransSecondary$1: Quantity, type=reflTrans, reflector=secondary, signal=!signal($1)
  reflSpillSecondary$1: Quantity, type=reflSpill, reflector=secondary, signal=!signal($1)
  ;; Tertiary
  reflReflTertiary$1: Quantity, type=reflRefl, reflector=tertiary, signal=!signal($1)
  reflTransTertiary$1: Quantity, type=reflTrans, reflector=tertiary, signal=!signal($1)
  reflSpillTertiary$1: Quantity, type=reflSpill, reflector=tertiary, signal=!signal($1)
  ;; Complete
  reflTransComplete$1: Quantity, type=reflTrans, reflector=complete, signal=!signal($1)
  ;; Strays
  strayRadiance$1: Quantity, type=strayRadiance, signal=!signal($1)!nl})
    
  !forall(constructAntennaTerms,!allBandLSBs,!allBandUSBs)

  ;; Now make the lists up, this is messy
  !define(allReflTemps,{reflTempPrimary, reflTempSecondary, reflTempTertiary})
  ;; Primary
  !define(allReflReflPrimaries, {!makelist({reflReflPrimary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflTransPrimaries, {!makelist({reflTransPrimary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflSpillPrimaries, {!makelist({reflSpillPrimary},{},!allBandLSBs,!allBandUSBs)})
  ;; Secondary
  !define(allReflReflSecondaries, {!dnl
    !makelist({reflReflSecondary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflTransSecondaries, {!dnl
    !makelist({reflTransSecondary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflSpillSecondaries, {!dnl
    !makelist({reflSpillSecondary},{},!allBandLSBs,!allBandUSBs)})
  ;; Tertiary
  !define(allReflReflTertiaries, {!dnl
    !makelist({reflReflTertiary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflTransTertiaries, {!dnl
    !makelist({reflTransTertiary},{},!allBandLSBs,!allBandUSBs)})
  !define(allReflSpillTertiaries, {!dnl
    !makelist({reflSpillTertiary},{},!allBandLSBs,!allBandUSBs)})
  ;; Complete
  !define(allReflTransCompletes,{!dnl
    !makelist({reflTransComplete},{},!allBandLSBs,!allBandUSBs)})
  ;; Strays
  !define(allStrayRadiances, {!makelist({strayRadiance},{},!allBandLSBs,!allBandUSBs)})

  ;; Now the 'master list'
  !define(allAntennaLossTerms,{!allReflTemps, $
    !allReflReflPrimaries,!allReflTransPrimaries,!allReflSpillPrimaries, $
    !allReflReflSecondaries,!allReflTransSecondaries,!allReflSpillSecondaries, $
    !allReflReflTertiaries,!allReflTransTertiaries,!allReflSpillTertiaries, $
    !allReflTransCompletes,!allStrayRadiances})
})

  ;; ----------------------------------------- Retrieval diagnostics
  ;; Note no continuation lines allowed here, sorry!
  !define(allRetrievalDiagnostics,{dnwt_ajn, dnwt_axmax, dnwt_cait, dnwt_chiSqMinNorm, dnwt_chiSqNorm, dnwt_diag, dnwt_dxdx, dnwt_dxdxl, dnwt_dxn, dnwt_dxnl, dnwt_fnmin, dnwt_fnorm, dnwt_gdx, dnwt_gfac, dnwt_gradn, dnwt_sq, dnwt_sqt, numJ, dnwt_flag, jacobian_rows, jacobian_cols})
  hGridDiag: hGrid, type=explicit, module=GHz, geodAngle= 0 degrees
  !define(constructRetrievalDiagnostic,{$1: Quantity, type=$1, $
    vGrid=vGridDiag, hGrid=hGridDiag!nl})
  !forall(constructRetrievalDiagnostic,!allRetrievalDiagnostics)
  !define(outputRetrievalDiagnostics,{dnwt_chiSqNorm, dnwt_chiSqMinNorm, jacobian_rows, jacobian_cols, dnwt_flag})

  ;; ----------------------------------------- Other minor stuff

  magneticField: quantity, type=magneticField, $
    vGrid=vGridStandard, hGrid=hGridStandard

  earthReflectivity: quantity, type=earthRefl
  orbitInclination: Quantity, type=orbitInclination, module=SC
  spaceRadiance: quantity, type=spaceRadiance

  scGeocAlt: Quantity, type=scGeocAlt, module=SC
  tngtGeocAltGHz: Quantity, type=tngtGeocAlt, module=GHz
  tngtGeocAltTHz: Quantity, type=tngtGeocAlt, module=THz

  scECI: quantity, type=scECI, module=SC
  tngtECIGHz: quantity, type=tngtECI, module=GHz
  tngtECITHz: quantity, type=tngtECI, module=THz

  scVelECI: quantity, type=scVelECI, module=SC
  scVelECR: quantity, type=scVelECR, module=SC
  losVelGHz: quantity, type=losVel, module=GHz
  losVelTHz: quantity, type=losVel, module=THz
  ECRtoFOV: quantity, type=ECRtoFOV, module=GHz

  !define(lesserState, {magneticField, earthReflectivity, orbitInclination, spaceRadiance, $
    scGeocAlt, tngtGeocAltGHz, tngtGeocAltTHz, scECI, tngtECIGHz, tngtECITHz, $
    scVelECR, scVelECI, losVelGHz, losVelTHz, ECRtoFOV})

  ;; ------------------------------------------- Now define vector templates

  ;; Put extra line breaks here to get round a problem I'm having
  ;; running this with NAG.
  stateTemplate: VectorTemplate, quantities = [ $
    ptanGHZ, ptanTHz, phitanGHz, phitanTHz, $
    temperature, temperature_HR, $
    refGPH, GPH, GPH_HR, $
    tpPressure, $
    iwc_coarse, iwc, lwc, surfaceType, psd, earthRadius, $
    trans, cext, cextFine, $
    massMeanDiameterIce, massMeanDiameterWater, $
    !allMolecules, tropH2O, tropH2O_HR, $
    !allHiResMolecules, $
    rhi, rhi_HR, $
    !allColumns, $
    !allBaselines, $
    !allExtinctions, $
    !allIsotopeRatios, $
    !allSidebandFractions, $
    !allFoldedSystemTemperatures, $
    !allUnfoldedSystemTemperatures, $
    !allFoldedNoiseBandwidths, $
    !allUnfoldedNoiseBandwidths, $
    !allElevs, !ifdef(flagSkipLossTerms,{},{!allAntennaLossTerms, }) $
    !lesserState ]

  measurementTemplate: VectorTemplate, quantities = [ $
    !allFoldedRadiances, scanResidualGHz, scanResidualTHz ]

  depthTemplate: VectorTemplate, quantities = [ !allFoldedDepths ]

  retrievalDiagnosticsTemplate: VectorTemplate, quantities = [ !allRetrievalDiagnostics ]

  radianceDiagnosticsTemplate: VectorTemplate, quantities = [ $
    !allChisqMMAFs, !allChisqMMIFs, !allChisqChans, !allChisqBinned, $
    !allNoRadsPerMIF, !allNoRadsBinned ]

  cloudOutputTemplate: VectorTemplate, quantities = [ $
    !allFoldedRadiances, !allDTs, !allCloudMinMax ]
    
end Construct
