; $Id$

; This l2cf fragment defines macros we're going to use a lot
; in doing phased retrievals

; Define some macros we need for various quantities
!define(allRadiometers,{R1A, R1B, R2, R3, R4, R5H, R5V})
!define(allBands,{!forloop({i},1,33,{!i, })34}) ; 1,2,3..34
!define(allBandLSBs,{!makelist({},{L},!allBands)})
!define(allBandUSBs,{!makelist({},{U},!allBands)})

;; This macro is called at the start of each phase to setup its
;; vectors and matrices.
!define(setupPhase,{!dnl
begin Fill
  ;; Define state related vectors
  x$1: Vector, template=x$1Template
  a$1: Vector, template=x$1Template
  t$1: Vector, template=x$1Template
  l$1: Vector, template=x$1Template
  vr$1: Vector, template=x$1Template
  hr$1: Vector, template=x$1Template
  sdIn$1: Vector, template=x$1Template
  sdOut$1: Vector, template=x$1Template
  lb$1: Vector, template=x$1Template
  hb$1: Vector, template=x$1template
  ;; Define measurement related vectors
  y$1: Vector, template=y$1Template
  yNoise$1: Vector, template=y$1Template
  f$1: Vector, template=y$1Template
  ;; Optical depth may be turned on again, sometime, for the PEs
  !ifdef(precisionEstimates,{},{od$1: Vector, template=od$1Template})
  ;; Define retrieval diagnostics vector
  diag$1: Vector, template=retrievalDiagnosticsTemplate
  ;; Fill state related vectors
  Transfer, source=state, destination=x$1
  Transfer, source=apriori, destination=a$1
  Transfer, source=aprioriPrecision, destination=sdIn$1
  Transfer, source=length, destination=l$1
  Transfer, source=vReg, destination=vr$1
  Transfer, source=hReg, destination=hr$1
  Transfer, source=lowBound, destination=lb$1
  Transfer, source=highBound, destination=hb$1
  ;; Construct and fill state covariance
  myCovariance$1: matrix, columns=a$1, type=spd
  FillCovariance, matrix=myCovariance$1, diagonal=sdIn$1, /invert, lengthScale=l$1
  ;; Construct averaging kernel matrix
  !ifdef(gotAK,{akOut$1: Matrix, columns=x$1, rows=x$1},{})
  ;; Fill radiance related vectors
  Transfer, source=measurement, destination=y$1
  Transfer, source=measurementNoise, destination=yNoise$1
end Fill})

;; This macro is called at the end of a retrieval phase to store the
;; results back.
!define(completePhase,{!dnl
;; Set default values for some parameters
!undefine(completePhasetroph2o)
!processparval({completePhase},!shift($@))
begin Fill
  ;; Put state etc. back
  Transfer, source=x$1, destination=state
  Transfer, source=sdOut$1, destination=outputPrecision
  !ifdef(completePhasetroph2o,{!dnl
    ;; In this case copy TropH2O into H2O as requested
    Fill, quantity=state.h2o, sourceQuantity=state.tropH2O, method=vector, /interpolate})
  ;; FM output will be turned on again, sometime, for the PEs
  !ifdef(precisionEstimates,{},{Transfer, source=f$1, destination=fwm})
  ;; Clean up
  Destroy, matrix=myCovariance$1
  ;; Compute new full GPH profile
  Fill, quantity=state.gph, method=hydrostatic, $
    refGPHquantity=state.refGPH, temperatureQuantity=state.temperature
  ;; And GPH precision
  Fill, quantity=outputPrecision.gph, method=gphPrecision, $
    refGPHPrecisionquantity=outputPrecision.refGPH, $
    tempPrecisionQuantity=outputPrecision.temperature
  ;; Compute RHI from H2O
  Fill, quantity=state.rhi, h2oQuantity=state.h2o, $
    temperatureQuantity=state.temperature, method=RHIFromH2O, /dontMask
  ;; And RHI precision
  Fill, quantity=outputPrecision.rhi, $
    h2oPrecisionQuantity=outputPrecision.h2o, $
    tempPrecisionQuantity=outputPrecision.temperature, $
    h2oQuantity=state.h2o, temperatureQuantity=state.temperature, $
    method=RHIPrecisionFromH2O, /dontMask
end Fill
begin Join
!forall(joinOneDiagDGG,!allRetrievalDiagnostics)
end Join})

;; This macro deals with the state subsetting for quantity $1
!define(subsetSpecies,{!dnl
!ifdef($1Range,{
Subset, quantity=state.$1, height=!$1Range
Subset, quantity=state.$1, height=!$1Range, mask=Tikhonov
Subset, quantity=length.$1, height=!$1Range})!nl})
!define(subsetState,{!dnl
!forall({subsetSpecies},!allMolecules)
!subsetSpecies(Temperature)!nl})

;; This macro deals with the radiance subsetting in an easy manner.
;; $1 is the phase name, $2 the band, $3 the height range and $4 the depth limit
!define(subsetGHzRadiance,{!dnl
Subset, quantity=y$1.band$2, height=$3, ptanQuantity=state.ptanGHz, $
  opticalDepth=od$1.depth$2, opticalDepthCutoff=$4!nl})
!define(subsetTHzRadiance,{!dnl
Subset, quantity=y$1.band$2, height=$3, ptanQuantity=state.ptanTHz, $
  opticalDepth=od$1.depth$2, opticalDepthCutoff=$4!nl})

;; These macros are used to accumulate quantities destined for the DGM
;; or DGG file.  $1 is the quantity within state, and $2 is the swath/sd
;; name.  The variable is joined into joinedDG?_$1_!phase to avoid confusion
!define(DGGDivert,1)
!define(DGMDivert,2)

!define(joinDGG,{
joinedDGG_$1_!phase: l2gp, source=state.$1, precision=outputPrecision.$1, swath='$2'
!ifdef(gotDGGs,{!dnl
  !divert(!DGGDivert), joinedDGG_$1_!phase!divert},{!dnl
  !divert(!DGGDivert)joinedDGG_$1_!phase!divert})
!define(gotDGGs,{Yes})
{
; --ConfigInfo-- DGG: $2
}
})
!define(joinDGM,{
joinedDGM_$1_!phase: l2aux, source=state.$1, sdName='$2'
joinedDGM_$1_!phase_precision: l2aux, source=outputPrecision.$1, sdName='$2 precision'
!ifdef(gotDGMs,{!dnl
  !divert(!DGMDivert), joinedDGM_$1_!phase, joinedDGM_$1_!phase_precision!divert},{!dnl
  !divert(!DGMDivert)joinedDGM_$1_!phase, joinedDGM_$1_!phase_precision!divert})
!define(gotDGMs,{Yes})
{;} --ConfigInfo-- DGM: $2
{;} --ConfigInfo-- DGM: $2 precision
})

;; This macro is used to offset the forward model radiances
;; It is called inside a Fill statement.  Note it takes !phase as a
;; 'global' parameter.
!define(offsetRadiance,{!dnl
   Fill, quantity=f!phase.band$1, radianceQuantity=y!phase.band$1, method=offsetRadiance!nl})
!define(offsetRadiances,{!dnl
   begin Fill
   !forall(offsetRadiance,$1)
   end Fill})

;; This macro is used to invoke direct writes to store forward model
;; radiances.  The band is $1, and a suffix for the sd name is given
;; in $2
!define(directWriteFwmRad,{
  !ifdef(l2version,{directWrite, source=fwm.band$1, /prefixSignal, $
  sdName=' model $2', file='!outpathl2fwm/MLS-Aura_L2FWM-Full_!l2version_!day.h4'})
{;} --ConfigInfo-- FWM: !TrimQ(!signal($1)) model $2
})

;; This macro uses the joinDGG (for the moment, will use DGM when we
;; got to hdf5) to join the diagnostics stuff
!define(joinOneDiagDGG,{
  joinedDGG_$1_!phase: l2gp, source=diag!phase.$1, precision=diag!phase.$1, $
    swath='!translit($1,{_},{-})-!phase'
!ifdef(gotDGGs,{!dnl
  !divert(!DGGDivert), joinedDGG_$1_!phase!divert},{!dnl
  !divert(!DGGDivert)joinedDGG_$1_!phase!divert})!dnl
!define(gotDGGs,{Yes})!dnl
{;} --ConfigInfo-- DGG: !translit($1,{_},{-})-!phase
})

;; This macro puts all the boring stuff in the Retrieve command line
;; that we're used to seeing
;  will add FM output to PEs later
!ifdef(precisionEstimates,{!dnl
  !define(retrievalArguments,{state=x$1, fwdModelExtra=state, $
    measurements=y$1, measurementSD=yNoise$1, $
    apriori=a$1, covariance=myCovariance$1, $
    outputSD=sdOut$1, $
    vRegWeightVec=vr$1, hRegWeightVec=hr$1})},!dnl
{ !define(retrievalArguments,{state=x$1, fwdModelExtra=state, $
    measurements=y$1, measurementSD=yNoise$1, $
    apriori=a$1, covariance=myCovariance$1, $
    outputSD=sdOut$1, fwdModelOut=f$1, $
    vRegWeightVec=vr$1, hRegWeightVec=hr$1, $
    lowBound=lb$1, highBound=hb$1, diagnostics=diag$1})})

;; This macro is used in sids runs to get the band number part of a band
;; specifier (i.e. strip off the sideband if it is present)
!define(getBandNumber,{!regexp({$1},{[0-9]+},{\&})})
!define(systemp,{!systemp$1})
!define(nbw,{!nbw$1})

;; This macro defines a set of full forward models under a given name
;; $1, for band $2, signal $3.
;; -------------------------- 2D forward models
!define(makeSimpleFwm,{!dnl
  $1: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /temp_der, /do_baseline
  $1_mono: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /temp_der, /do_baseline
  $1_notd: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /do_baseline
  $1_mono_notd: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /do_baseline})
!define(makeFwm,{!dnl
  $1: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /temp_der, /do_baseline
  $1_mono: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /temp_der, /do_baseline
  $1_notd: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /do_baseline
  $1_mono_notd: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=4.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /do_baseline})
; ------------------ 1D forward models
!define(makeSimpleFwm1d,{!dnl
  $1_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /temp_der, /do_baseline
  $1_mono_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /temp_der, /do_baseline
  $1_notd_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /do_baseline
  $1_mono_notd_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !simplerMolecules($2), $
    moleculeDerivatives = !simplerMoleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /do_baseline})
!define(makeFwm1d,{!dnl
  $1_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /temp_der, /do_baseline
  $1_mono_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /temp_der, /do_baseline
  $1_notd_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /do_freq_avg, /atmos_der, /do_baseline
  $1_mono_notd_1d: ForwardModel, type=full, $
    signals=$3, $
    phiWindow=0.0, $
    molecules = !molecules($2), $
    moleculeDerivatives = !moleculeFamilies($2), $
    integrationGrid=vGridTangent, $
    tangentGrid=vGridTangent, $
    /do_conv, /atmos_der, /do_baseline})

; $Log$
; Revision 1.32  2002/10/25 22:25:59  livesey
; Added the retrieval diagnostics stuff
;
; Revision 1.31  2002/10/25 01:10:33  livesey
; Added the tropH2O option to completephase
;
; Revision 1.30  2002/10/17 18:24:40  livesey
; Typo
;
; Revision 1.29  2002/10/17 18:19:50  livesey
; Added low/high bound to retrieval
;
; Revision 1.28  2002/10/16 20:21:11  mjf
; Added GPH precision.
;
; Revision 1.27  2002/10/11 19:39:21  livesey
; Bug fix
;
; Revision 1.26  2002/10/11 19:29:29  livesey
; Added 1D forward models.
;
; Revision 1.25  2002/10/09 00:48:23  livesey
; Split forward models into simple and otherwise
;
; Revision 1.24  2002/10/03 21:36:00  livesey
; Changed forward models to use simplerMolecules lists
;
; Revision 1.23  2002/10/03 16:18:24  livesey
; Changed temperaturePrecisionQuantity to tempPrecisionQuantity for Mark
;
; Revision 1.22  2002/10/03 05:41:41  livesey
; Added baseline to forward models
;
; Revision 1.21  2002/10/02 23:22:47  livesey
; New definitions of the joinDGG/DGM stuff.  Also added forward model
; construction stuff.
;
; Revision 1.20  2002/10/02 23:06:01  pwagner
; RHI now separate fill methods
;
; Revision 1.19  2002/10/01 18:33:36  mjf
; New Fill for RHi precision.  Need gotAK defined for AK output.
; RetrivalArguments depends on precisionEstimates.
;
; Revision 1.18  2002/08/26 20:27:07  livesey
; New regularization (horizontal and vetical)
;
; Revision 1.17  2002/08/23 23:26:29  livesey
; Made the FWM rad stuff report the actual signal
;
; Revision 1.16  2002/08/15 22:46:00  livesey
; Added regularization vector
;
; Revision 1.15  2002/08/05 17:20:23  livesey
; Added code to convert H2O back to RHI at the end of each phase
;
; Revision 1.14  2002/08/04 16:18:47  mjf
; Some things switched off for precision estimates.
;
; Revision 1.13  2002/07/23 23:47:28  livesey
; Added some macros for sids
;
; Revision 1.12  2002/07/22 20:34:17  livesey
; Tidied up bug with subsetState
;
; Revision 1.11  2002/07/20 00:54:56  livesey
; Added more subsetting stuff
;
; Revision 1.10  2002/07/18 06:30:55  livesey
; Added the radianceSubset stuff
;
; Revision 1.9  2002/07/17 19:30:10  livesey
; Fill GPH
;
; Revision 1.8  2002/07/06 21:18:48  livesey
; Made sure the direct writes for forward model radiances are only done if
; l2version is defined.
;
; Revision 1.7  2002/07/05 21:46:36  livesey
; Put in the configInfo information
;
; Revision 1.6  2002/07/05 21:37:02  livesey
; New (working) DGM/DGG handling
;
; Revision 1.5  2002/07/05 17:46:38  livesey
; New work for multiphase retrievals
;
; Revision 1.4  2002/06/24 17:24:47  livesey
; Bug in doNoise macro.
;
; Revision 1.3  2002/05/29 00:08:23  livesey
; Typo fix
;
; Revision 1.2  2002/05/28 22:36:14  livesey
; Semi freeze of version
;
; Revision 1.1  2002/04/29 21:54:59  pwagner
; First commit
;
