; $Id$

; This l2cf fragment defines macros we're going to use a lot
; in doing phased retrievals

; Define some macros we need for various quantities
!define(allRadiometers,{R1A, R1B, R2, R3, R4, R5H, R5V})
!define(allBands,{!forloop({i},1,33,{!i, })34}) ; 1,2,3..34
!define(allBandLSBs,{!makelist({},{L},!allBands)})
!define(allBandUSBs,{!makelist({},{U},!allBands)})

;; This macro is called at the start of each phase to setup its
;; vectors and matrices.
!define(setupPhase,{!dnl
begin Fill
  ;; Define state related vectors
  x$1: Vector, template=x$1Template
  a$1: Vector, template=x$1Template
  t$1: Vector, template=x$1Template
  l$1: Vector, template=x$1Template
  sdIn$1: Vector, template=x$1Template
  sdOut$1: Vector, template=x$1Template
  ;; Define measurement related vectors
  y$1: Vector, template=y$1Template
  yNoise$1: Vector, template=y$1Template
  f$1: Vector, template=y$1Template
  od$1: Vector, template=od$1Template
  ;; Fill state related vectors
  Transfer, source=state, destination=x$1
  Transfer, source=apriori, destination=a$1
  Transfer, source=aprioriPrecision, destination=sdIn$1
  Transfer, source=length, destination=l$1
  ;; Construct and fill state covariance
  myCovariance$1: matrix, columns=a$1, type=spd
  FillCovariance, matrix=myCovariance$1, diagonal=sdIn$1, /invert, lengthScale=l$1
  ;; Fill radiance related vectors
  Transfer, source=measurement, destination=y$1
  Transfer, source=measurementNoise, destination=yNoise$1
end Fill})

;; This macro is called at the end of a retrieval phase to store the
;; results back.
!define(completePhase,{!dnl
begin Fill
  Transfer, source=x$1, destination=state
  Transfer, source=sdOut$1, destination=outputPrecision
  Transfer, source=f$1, destination=fwm
  Destroy, matrix=myCovariance$1
end Fill})

;; These macros are used to accumulate quantities destined for the DGM
;; or DGG file.  $1 is the quantity within state, $2 is the name to
;; give the internal l2gp item (to avoid confusion with the 'main'
;; one), and $3 is the swath name.
!define(DGGDivert,1)
!define(DGMDivert,2)

!define(joinDGG,{
joinedDGG_$2: l2gp, source=state.$1, precision=outputPrecision.$1, swath='$3'
!ifdef(gotDGGs,{!dnl
  !divert(!DGGDivert), joinedDGG_$2!divert},{!dnl
  !divert(!DGGDivert)joinedDGG_$2!divert})
!define(gotDGGs,{Yes})
{
; --ConfigInfo-- DGG: $3
}
})
!define(joinDGM,{
joinedDGM_$2: l2aux, source=state.$1, sdName='$3'
joinedDGM_$2_precision: l2aux, source=outputPrecision.$1, sdName='$3 precision'
!ifdef(gotDGMs,{!dnl
  !divert(!DGMDivert), joinedDGM_$2, joinedDGM_$2_precision!divert},{!dnl
  !divert(!DGMDivert)joinedDGM_$2, joinedDGM_$2_precision!divert})
!define(gotDGMs,{Yes})
{
; --ConfigInfo-- DGM: $3
; --ConfigInfo-- DGM: $3 precision
}
})

;; This macro is used to invoke direct writes to store forward model
;; radiances.  The band is $1, and a suffix for the sd name is given
;; in $2
!define(directWriteFwmRad,{
  !ifdef(l2version,{directWrite, source=fwm.band$1, /prefixSignal, $
  sdName=' model $2', file='!outpathl2fwm/MLS-Aura_L2FWM-Full_!l2version_!day.h4'})
{
; --ConfigInfo-- FWM: band $1 model $2
}
})

;; This macro puts all the boring stuff in the Retrieve command line
;; that we're used to seeing
!define(retrievalArguments,{state=x$1, fwdModelExtra=state, $
  measurements=y$1, measurementSD=yNoise$1, $
  apriori=a$1, covariance=myCovariance$1, $
  outputSD=sdOut$1, fwdModelOut=f$1})

; $Log$
; Revision 1.7  2002/07/05 21:46:36  livesey
; Put in the configInfo information
;
; Revision 1.6  2002/07/05 21:37:02  livesey
; New (working) DGM/DGG handling
;
; Revision 1.5  2002/07/05 17:46:38  livesey
; New work for multiphase retrievals
;
; Revision 1.4  2002/06/24 17:24:47  livesey
; Bug in doNoise macro.
;
; Revision 1.3  2002/05/29 00:08:23  livesey
; Typo fix
;
; Revision 1.2  2002/05/28 22:36:14  livesey
; Semi freeze of version
;
; Revision 1.1  2002/04/29 21:54:59  pwagner
; First commit
;
