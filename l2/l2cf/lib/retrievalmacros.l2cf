; $Id$

; This l2cf fragment defines macros we're going to use a lot
; in doing phased retrievals

; Define some macros we need for various quantities
!define(allRadiometers,{R1A,R1B,R2,R3,R4,R5H,R5V})
!define(allBands,{!forloop({i},1,33,{!i, })34}) ; 1,2,3..34
!define(allBandLSBs,{!makelist({},{L},!allBands)})
!define(allBandUSBs,{!makelist({},{U},!allBands)})

; These macros define the MLS standard products
!define(allStandardProductsWithColumns,{BrO,CH3CN,ClO,CO,H2O,HCl,HCN,HNO3,HO2,HOCl,N2O,O3,OH})
!define(allStandardProductsWithoutColumns,{Temperature,GPH,RHI})
!define(allStandardProducts,{!allStandardProductsWithColumns,!allStandardProductsWithoutColumns})

;; This macro is used in sids runs to get the band number part of a band
;; specifier (i.e. strip off the sideband if it is present)
!define(getBandNumber,{!regexp({$1},{[0-9]+},{\&})})
;; Some other low level macros
!define(systemp,{!systemp$1})
!define(nbw,{!nbw$1})

;; This macro is called at the start of each phase to setup its
;; vectors and matrices.
!define(setupPhase,{!dnl
begin Fill
  ;; Define state related vectors
  x$1: Vector, template=x$1Template
  a$1: Vector, template=x$1Template
  t$1: Vector, template=x$1Template
  vr$1: Vector, template=x$1Template
  hr$1: Vector, template=x$1Template
  sdIn$1: Vector, template=x$1Template
  sdOut$1: Vector, template=x$1Template
  lb$1: Vector, template=x$1Template
  hb$1: Vector, template=x$1template
  ;; Define measurement related vectors
  y$1: Vector, template=y$1Template
  yNoise$1: Vector, template=y$1Template
  f$1: Vector, template=y$1Template
  ;; Optical depth may be turned on again, sometime, for the PEs
  !ifdef(flagPrecisionEstimates,{},{od$1: Vector, template=od$1Template})
  ;; Define retrieval diagnostics vector
  diag$1: Vector, template=retrievalDiagnosticsTemplate
  ;; Fill state related vectors
  Transfer, source=state, destination=x$1
  Transfer, source=apriori, destination=a$1
  Transfer, source=aprioriPrecision, destination=sdIn$1
  Transfer, source=vReg, destination=vr$1
  Transfer, source=hReg, destination=hr$1
  Transfer, source=lowBound, destination=lb$1
  Transfer, source=highBound, destination=hb$1
  ;; Construct and fill state covariance
  myCovariance$1: matrix, columns=a$1, type=spd
  FillCovariance, matrix=myCovariance$1, diagonal=sdIn$1, /invert
  ;; Construct averaging kernel matrix
  !ifdef(flagGotAK,{!dnl
  akOut$1: Matrix, columns=x$1, rows=x$1
  !ifdef(flagGotAnyAKs,{!dnl
  !divert(!AVKDivert), akOut$1!divert},{!dnl
  !divert(!AVKDivert)akOut$1!divert})
  !define(flagGotAnyAKs,{Yes})})
  ;; Fill radiance related vectors
  Transfer, source=measurement, destination=y$1
  Transfer, source=measurementNoise, destination=yNoise$1
end Fill})

;; This macro is called at the end of a retrieval phase to store the
;; results back.
!define(completePhase,{!dnl
;; Set default values for some parameters
!undefine(completePhasetroph2o)
!ProcessParVal({completePhase},!shift($@))
begin Fill
  ;; Put state etc. back
  Transfer, source=x$1, destination=state
  Transfer, source=sdOut$1, destination=outputPrecision
  !ifdef(completePhasetroph2o,{!dnl
    ;; In this case copy TropH2O into H2O as requested
    Fill, quantity=state.h2o, sourceQuantity=state.tropH2O, $
      method=vector, /interpolate
    ;; And its precision
    Fill, quantity=outputPrecision.h2o, sourceQuantity=outputPrecision.tropH2O, $
      method=vector, /interpolate})

  ;; FM output will be turned on again, sometime, for the PEs
  !ifdef(flagPrecisionEstimates,{},{Transfer, source=f$1, destination=fwm})
  ;; Clean up
  Destroy, matrix=myCovariance$1
  ;; Compute new full GPH profile
  Fill, quantity=state.gph, method=hydrostatic, $
    refGPHquantity=state.refGPH, temperatureQuantity=state.temperature
  ;; And GPH precision
  Fill, quantity=outputPrecision.gph, method=gphPrecision, $
    refGPHPrecisionquantity=outputPrecision.refGPH, $
    tempPrecisionQuantity=outputPrecision.temperature
  ;; Compute RHI from H2O
  Fill, quantity=state.rhi, h2oQuantity=state.h2o, $
    temperatureQuantity=state.temperature, method=RHIFromH2O, /dontMask
  ;; And RHI precision
  Fill, quantity=outputPrecision.rhi, $
    h2oPrecisionQuantity=outputPrecision.h2o, $
    tempPrecisionQuantity=outputPrecision.temperature, $
    h2oQuantity=state.h2o, temperatureQuantity=state.temperature, $
    method=RHIPrecisionFromH2O, /dontMask
  ;; Set precision -ve when wose than 50% apriori precision
  NegativePrecision, precision=outputPrecision, aprioriPrecision=aprioriPrecision
end Fill

!ifdef(flagPrecisionEstimates,{},{
  begin Join
    !forall(joinOneDiagDGG,!allRetrievalDiagnostics)
  end Join})
})

;; This macro initialises the _HR species with interpolations of their
;; standard resolution equivalents
!define(oneHiResTransfer,{Fill, quantity=state.$1, method=vector, $
  sourceQuantity=state.!trimHR($1), /interpolate!nl})
!define(initHiRes,{begin Fill
  Fill, quantity=state.Temperature_HR, method=vector, $
    sourceQuantity=state.Temperature, /interpolate
  !forall(oneHiResTransfer,!allHiResMolecules)
end Fill})

;; These macros are used to accumulate quantities destined for the DGM
;; or DGG file.  $1 is the quantity within state, and $2 is the swath/sd
;; name.  The variable is joined into joinedDG?_$1_!phase to avoid confusion
!define(DGGDivert,1)
!define(DGMDivert,2)
!define(AVKDivert,3)

!define(storeDGG,{!ifdef(flagGotDGGs,{!divert(!DGGDivert),!divert})!dnl
!define(flagGotDGGs,{Yes})!divert(!DGGDivert)$1!divert})

!define(storeDGM,{!ifdef(flagGotDGMs,{!divert(!DGMDivert),!divert})!dnl
!define(flagGotDGMs,{Yes})!divert(!DGMDivert)$1!divert})

!define(storeAVK,{!ifdef(flagGotAVKs,{!divert(!AVKDivert),!divert})!dnl
!define(flagGotAVKs,{Yes})!divert(!AVKDivert)$1!divert})

!define(joinDGG,{!dnl
!storeDGG(joinedDGG_$1_!phase)!dnl
joinedDGG_$1_!phase: l2gp, source=state.$1, precision=outputPrecision.$1, swath='$2'
})

!define(joinDGM,{!dnl
!storeDGM(joinedDGM_$1_!phase)!storeDGM(joinedDGM_$1_!phase_precision)!dnl
joinedDGM_$1_!phase: l2aux, source=state.$1, sdName='$2'
joinedDGM_$1_!phase_precision: l2aux, source=outputPrecision.$1, sdName='$2 precision'
})

;; This macro is used to fill radiance chi squares
!define(fillRadianceDiagnostics,{!dnl
   Fill, quantity=radianceDiagnostics.chisqMMAF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1
   Fill, quantity=radianceDiagnostics.chisqMMIF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1
   Fill, quantity=radianceDiagnostics.chisqChan$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1
   Fill, quantity=radianceDiagnostics.noRadsPerMIF$1, method=special, $
     measurements=y!phase.band$1
   Fill, quantity=radianceDiagnostics.chisqBinned$1, method=binmax, $
     sourceQuantity=radianceDiagnostics.chisqMMIF$1, $
     ptanQuantity=state.ptanGHz
   Fill, quantity=radianceDiagnostics.noRadsBinned$1, method=binTotal, $
     sourceQuantity=radianceDiagnostics.noRadsPerMIF$1, $
     ptanQuantity=state.ptanGHz!nl})

;; This macro joins the above filled quantities
!define(joinRadianceDiagnostics,{!dnl
   joinedDGM_chisqMMAF$1_!phase: l2aux, source=radianceDiagnostics.chisqMMAF$1, $
     /prefixSignal, sdName=' chisqMMAF !phase'
   joinedDGM_chisqMMIF$1_!phase: l2aux, source=radianceDiagnostics.chisqMMIF$1, $
     /prefixSignal, sdName=' chisqMMIF !phase'
   joinedDGM_chisqChan$1_!phase: l2aux, source=radianceDiagnostics.chisqChan$1, $
     /prefixSignal, sdName=' chisqChan !phase'
   joinedDGM_noRadsPerMIF$1_!phase: l2aux, source=radianceDiagnostics.noRadsPerMIF$1, $
     /prefixSignal, sdName=' noRadsPerMIF !phase'
   joinedDGG_chisqBinned$1_!phase: l2gp, source=radianceDiagnostics.chisqBinned$1, $
     /prefixSignal, swath=' chisqBinned !phase'
   joinedDGG_noRadsBinned$1_!phase: l2gp, source=radianceDiagnostics.noRadsBinned$1, $
     /prefixSignal, swath=' noRadsBinned !phase'
   !storeDGM(joinedDGM_chisqMMAF$1_!phase)!dnl
   !storeDGM(joinedDGM_chisqMMIF$1_!phase)!dnl
   !storeDGM(joinedDGM_chisqChan$1_!phase)!dnl
   !storeDGM(joinedDGM_noRadsPerMIF$1_!phase)!dnl
   !storeDGG(joinedDGG_chisqBinned$1_!phase)
   !storeDGG(joinedDGG_noRadsBinned$1_!phase)})

!define(doRadianceDiagnostics,{!dnl
   begin Fill
     !forall(fillRadianceDiagnostics,$*)
   end Fill
   begin Join
     !forall(joinRadianceDiagnostics,$*)
   end Join!nl})

;; This macro is used to offset the forward model radiances
;; It is called inside a Fill statement.  Note it takes !phase as a
;; 'global' parameter.
!define(offsetRadiance,{!dnl
   Fill, quantity=f!phase.band$1, radianceQuantity=y!phase.band$1, method=offsetRadiance!nl})
!define(offsetRadiances,{!dnl
   begin Fill
   !forall(offsetRadiance,$*)
   end Fill})

;; This macro is used to invoke direct writes to store forward model
;; radiances.  The band is $1, and a suffix for the sd name is given
;; in $2
!define(directWriteFwmRad,{
  !ifdef(l2version,{directWrite, source=fwm.band$1, /prefixSignal, $
  sdName=' model $2', file='!outpathl2fwm/MLS-Aura_L2FWM-Full_!l2version_!day.h4'})})

;; This macro uses the joinDGG (for the moment, will use DGM when we
;; got to hdf5) to join the diagnostics stuff
!define(joinOneDiagDGG,{!storeDGG(joinedDGG_$1_!phase)!dnl
  joinedDGG_$1_!phase: l2gp, source=diag!phase.$1, precision=diag!phase.$1, $
    swath='!translit($1,{_},{-})-!phase'!nl})

;; This macro puts all the boring stuff in the Retrieve command line
;; that we're used to seeing
;  will add FM output to PEs later
!ifdef(flagPrecisionEstimates,{!dnl
  !define(retrievalArguments,{$
  !ifdef(flagGotAK,{average=akOut$1,}) state=x$1, fwdModelExtra=state, $
    measurements=y$1, measurementSD=yNoise$1, $
    apriori=a$1, covariance=myCovariance$1, $
    outputSD=sdOut$1, $
    vRegWeightVec=vr$1, hRegWeightVec=hr$1})},!dnl
{ !define(retrievalArguments,{$
  !ifdef(flagGotAK,{average=akOut$1,}) state=x$1, fwdModelExtra=state, $
  measurements=y$1, measurementSD=yNoise$1, $
  apriori=a$1, covariance=myCovariance$1, $
  outputSD=sdOut$1, fwdModelOut=f$1, $
  vRegWeightVec=vr$1, hRegWeightVec=hr$1, $
  lowBound=lb$1, highBound=hb$1, diagnostics=diag$1})})

; $Log$
; Revision 1.46  2003/05/10 22:22:17  livesey
; New approach to standard products, joining, output, columns etc.
;
; Revision 1.45  2003/05/10 20:47:08  livesey
; Bug fixes
;
; Revision 1.44  2003/05/10 00:57:53  livesey
; More chi squared etc. stuff
;
; Revision 1.43  2003/05/08 21:08:02  livesey
; Various bug fixes and tidies
;
; Revision 1.42  2003/05/08 20:49:21  livesey
; Various tidyups and changes
;
; Revision 1.41  2003/03/22 01:18:24  livesey
; Added initHiRes
;
; Revision 1.40  2003/02/27 00:39:38  livesey
; General tidy up and dead wood removal
;
; Revision 1.39  2002/12/16 16:24:51  mjf
; HiRes and columns
;
; Revision 1.38  2002/11/26 23:38:20  livesey
; Added radiance diagnostics
;
; Revision 1.37  2002/11/21 18:24:11  livesey
; Refined Avk stuff
;
; Revision 1.36  2002/11/21 01:24:01  livesey
; Add transfer of outputPrecision.tropH2O if requested
;
; Revision 1.35  2002/11/21 01:19:18  livesey
; Added call to NegativePrecision command
;
; Revision 1.34  2002/11/20 19:59:37  mjf
; Fill columns to be added, but might break the retrieval, so commented
; out for just now.
;
; Revision 1.33  2002/10/25 23:56:45  livesey
; Minor changes in the diagnostics, added the offsetRadiances stuff
;
; Revision 1.32  2002/10/25 22:25:59  livesey
; Added the retrieval diagnostics stuff
;
; Revision 1.31  2002/10/25 01:10:33  livesey
; Added the tropH2O option to completephase
;
; Revision 1.30  2002/10/17 18:24:40  livesey
; Typo
;
; Revision 1.29  2002/10/17 18:19:50  livesey
; Added low/high bound to retrieval
;
; Revision 1.28  2002/10/16 20:21:11  mjf
; Added GPH precision.
;
; Revision 1.27  2002/10/11 19:39:21  livesey
; Bug fix
;
; Revision 1.26  2002/10/11 19:29:29  livesey
; Added 1D forward models.
;
; Revision 1.25  2002/10/09 00:48:23  livesey
; Split forward models into simple and otherwise
;
; Revision 1.24  2002/10/03 21:36:00  livesey
; Changed forward models to use simplerMolecules lists
;
; Revision 1.23  2002/10/03 16:18:24  livesey
; Changed temperaturePrecisionQuantity to tempPrecisionQuantity for Mark
;
; Revision 1.22  2002/10/03 05:41:41  livesey
; Added baseline to forward models
;
; Revision 1.21  2002/10/02 23:22:47  livesey
; New definitions of the joinDGG/DGM stuff.  Also added forward model
; construction stuff.
;
; Revision 1.20  2002/10/02 23:06:01  pwagner
; RHI now separate fill methods
;
; Revision 1.19  2002/10/01 18:33:36  mjf
; New Fill for RHi precision.  Need gotAK defined for AK output.
; RetrivalArguments depends on precisionEstimates.
;
; Revision 1.18  2002/08/26 20:27:07  livesey
; New regularization (horizontal and vetical)
;
; Revision 1.17  2002/08/23 23:26:29  livesey
; Made the FWM rad stuff report the actual signal
;
; Revision 1.16  2002/08/15 22:46:00  livesey
; Added regularization vector
;
; Revision 1.15  2002/08/05 17:20:23  livesey
; Added code to convert H2O back to RHI at the end of each phase
;
; Revision 1.14  2002/08/04 16:18:47  mjf
; Some things switched off for precision estimates.
;
; Revision 1.13  2002/07/23 23:47:28  livesey
; Added some macros for sids
;
; Revision 1.12  2002/07/22 20:34:17  livesey
; Tidied up bug with subsetState
;
; Revision 1.11  2002/07/20 00:54:56  livesey
; Added more subsetting stuff
;
; Revision 1.10  2002/07/18 06:30:55  livesey
; Added the radianceSubset stuff
;
; Revision 1.9  2002/07/17 19:30:10  livesey
; Fill GPH
;
; Revision 1.8  2002/07/06 21:18:48  livesey
; Made sure the direct writes for forward model radiances are only done if
; l2version is defined.
;
; Revision 1.7  2002/07/05 21:46:36  livesey
; Put in the configInfo information
;
; Revision 1.6  2002/07/05 21:37:02  livesey
; New (working) DGM/DGG handling
;
; Revision 1.5  2002/07/05 17:46:38  livesey
; New work for multiphase retrievals
;
; Revision 1.4  2002/06/24 17:24:47  livesey
; Bug in doNoise macro.
;
; Revision 1.3  2002/05/29 00:08:23  livesey
; Typo fix
;
; Revision 1.2  2002/05/28 22:36:14  livesey
; Semi freeze of version
;
; Revision 1.1  2002/04/29 21:54:59  pwagner
; First commit
;
