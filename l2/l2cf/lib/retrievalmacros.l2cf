; $Id$

; This l2cf fragment defines macros we're going to use a lot
; in doing phased retrievals

; ------------------------------------------------------- Derived flags

;; Setup some flags based on other flags
!ifdef(flagComputeAvks,{!define(flagDontDestroyVectors,1)})
!ifdef(flagComputeSout,{!define(flagDontDestroyVectors,1)})

; ------------------------------------------------------- Instrument information

; Define some macros we need for various quantities
!define(allRadiometers,{R1A,R1B,R2,R3,R4,R5H,R5V})
!define(allBands,{!forloop({i},1,33,{!i, })34}) ; 1,2,3..34
!define(allBandLSBs,{!makelist({},{L},!allBands)})
!define(allBandUSBs,{!forloop({i},2,20,{!i{}U,})23U,24U,25U,!forloop({i},27,31,{!i{}U,})33U})

;; This macro is used in sids runs to get the band number part of a band
;; specifier (i.e. strip off the sideband if it is present)
!define(getBandNumber,{!regexp({$1},{[0-9]+},{\&})})
;; Some other low level macros
!define(systemp,{!systemp$1})
!define(nbw,{!nbw$1})

; ------------------------------------------------------- Product information

; These macros define the MLS standard products
; IWC is somewhat special
!define(allStandardProductsWithColumns,{BrO,CH3CN,ClO,CO,H2O,HCl,HCN,HNO3,HO2,HOCl,N2O,O3,OH})
!define(allStandardProductsWithoutColumns,{Temperature,GPH,RHI})
!define(allStandardProducts,{!tidyList(!allStandardProductsWithColumns, $
  !allStandardProductsWithoutColumns)})
!define(allHiResProducts,{Temperature_HR,H2O_HR,RHI_HR,GPH_HR})

; ------------------------------------------------------- File IO information

;; These macros define the format of our output files
!ifdef(hdfVersion,{},{!define(hdfVersion,5)})

;; These macros define our standard output filenames
!define(l2gpFileName, !dnl
{!ifdef(flagUsingPCF,{$1},!dnl
{!outpathl2gp/MLS-Aura_L2GP-$1_!l2version_!day.he!hdfVersion})})
!define(DGGFileName, !dnl
{!ifdef(flagUsingPCF,{DGG},!dnl
{!outpathl2gp/MLS-Aura_L2GP-DGG_!l2version_!day.he!hdfVersion})})
!define(DGMFileName, !dnl
{!ifdef(flagUsingPCF,{L2AUX-DGM},!dnl
{!outpathl2aux/MLS-Aura_L2AUX-DGM_!l2version_!day.h!hdfVersion})})
;;;!define(DGGFilename,{'!outpathl2gp/MLS-Aura_L2GP-DGG_!l2version_!day.he!hdfVersion'})
;;;!define(DGMFilename,{'!outpathl2aux/MLS-Aura_L2AUX-DGM_!l2version_!day.h!hdfVersion'})
!define(CloudFilename, !dnl
{!ifdef(flagUsingPCF,{L2AUX-Cloud},!dnl
{!outpathl2aux/MLS-Aura_L2AUX-Cloud_!l2version_!day.h!hdfVersion})})

;; DGG/DGM DirectWrite command may or may not include file name
;; depending on whether we set flag to automatically split sources
!define(DirectWriteDGGCommand, !dnl
{!ifdef(flagAutoSplitSources,{DirectWrite},!dnl
{DirectWrite, file='!DGGFileName'})})
!define(DirectWriteDGMCommand, !dnl
{!ifdef(flagAutoSplitSources,{DirectWrite},!dnl
{DirectWrite, file='!DGMFileName'})})

;; Filename for forward model radiance output
!define(l2fwmFileName, !dnl
{!ifdef(flagUsingPCF,{$1},!dnl
{!outpathl2gp/MLS-Aura_L2FWM-$1_!l2version_!day.h!hdfVersion})})

; -------------------------------------------------------- Phase related macros

;; This macro is called at the start of each phase to setup its
;; vectors and matrices.
!define(setupPhase,{!dnl
begin Fill
  ;; Define state related vectors
  x$1: Vector, template=x$1Template
  a$1: Vector, template=x$1Template
  vr$1: Vector, template=x$1Template
  hr$1: Vector, template=x$1Template
  sdIn$1: Vector, template=x$1Template
  sdOut$1: Vector, template=x$1Template
  lb$1: Vector, template=x$1Template
  hb$1: Vector, template=x$1template
  !ifdef(flagGotTruth,{t$1: Vector, template=x$1template})
  ;; Define measurement related vectors
  y$1: Vector, template=y$1Template
  yNoise$1: Vector, template=y$1Template
  f$1: Vector, template=y$1Template
  od$1: Vector, template=od$1Template
  ;; Define retrieval diagnostics vector
  diag$1: Vector, template=retrievalDiagnosticsTemplate
  ;; Fill state related vectors
  Transfer, source=state, destination=x$1
  Transfer, source=apriori, destination=a$1
  Transfer, source=aprioriPrecision, destination=sdIn$1
  Transfer, source=vReg, destination=vr$1
  Transfer, source=hReg, destination=hr$1
  Transfer, source=lowBound, destination=lb$1
  Transfer, source=highBound, destination=hb$1
  !ifdef(flagGotTruth,{Transfer, source=truth, destination=t$1})
  ;; Construct and fill state covariance
  Sa$1: matrix, columns=a$1, type=spd
  FillCovariance, matrix=Sa$1, diagonal=sdIn$1, /invert

  ;; Other matrices
  !ifdef(flagComputeAvks,{avk$1: matrix, rows=a$1, $
    !ifdef(flagGotTruth,{columns=t$1},{columns=a$1})})
  !ifdef(flagComputeSout,{Sout$1: matrix, columns=x$1, type=spd})

  ;; Fill radiance related vectors
  Transfer, source=measurement, destination=y$1
  Transfer, source=measurementNoise, destination=yNoise$1
end Fill})

;; This macro is called at the end of a retrieval phase to store the
;; results back.
!define(completePhase,{!dnl
;; Set default values for some parameters
begin Fill
  ;; Put state etc. back
  Transfer, source=x$1, destination=state
  Transfer, source=sdOut$1, destination=outputPrecision

  ;; FM output will be turned on again, sometime, for the PEs
  !ifdef(flagPrecisionEstimates,{},{Transfer, source=f$1, destination=fwm})
  ;; Clean up dead vectors and matrices
  Destroy, matrix=Sa$1
  !ifdef(flagDontDestroyVectors,{},{
  Destroy, vector=x$1
  Destroy, vector=a$1
  Destroy, vector=vr$1
  Destroy, vector=hr$1
  Destroy, vector=sdIn$1
  Destroy, vector=sdOut$1
  Destroy, vector=lb$1
  Destroy, vector=hb$1
  Destroy, vector=y$1
  Destroy, vector=yNoise$1
  Destroy, vector=f$1
  !ifdef(flagGotTruth,{Destroy, vector=t$1})
  Destroy, vector=od$1})
  ;; Compute new full GPH profile
  Fill, quantity=state.gph, method=hydrostatic, $
    refGPHquantity=state.refGPH, temperatureQuantity=state.temperature
  ;; And GPH precision
  Fill, quantity=outputPrecision.gph, method=gphPrecision, $
    refGPHPrecisionquantity=outputPrecision.refGPH, $
    tempPrecisionQuantity=outputPrecision.temperature
  ;; Compute RHI from H2O
  Fill, quantity=state.rhi, h2oQuantity=state.h2o, $
    temperatureQuantity=state.temperature, method=RHIFromH2O, /dontMask
  ;; And RHI precision
  Fill, quantity=outputPrecision.rhi, $
    h2oPrecisionQuantity=outputPrecision.h2o, $
    tempPrecisionQuantity=outputPrecision.temperature, $
    h2oQuantity=state.h2o, temperatureQuantity=state.temperature, $
    method=RHIPrecisionFromH2O, /dontMask
  ;; Set precision -ve when wose than 50% apriori precision
  NegativePrecision, precision=outputPrecision, aprioriPrecision=aprioriPrecision
end Fill

!ifdef(flagSuppressRegularOutput,{},{
!ifdef(flagPrecisionEstimates,{},{
  begin Join
    !ifdef(flagAvoidDirectWrite,
    {!forall(joinOneDiagDGG,!outputRetrievalDiagnostics)},
    {!forall(directWriteOneDiagDGG,!outputRetrievalDiagnostics)})
  end Join
})})
})

; ------------------------------------------------------------- High resolution

;; This macro initialises the _HR species with interpolations of their
;; standard resolution equivalents
!define(oneHiResTransfer,{Fill, quantity=state.$1, method=vector, $
  sourceQuantity=state.!trimHR($1), /interpolate!nl})
!define(initHiRes,{begin Fill
  Fill, quantity=state.Temperature_HR, method=vector, $
    sourceQuantity=state.Temperature, /interpolate
  !forall(oneHiResTransfer,!allHiResMolecules)
end Fill})

; ------------------------------------------------------------- Diversions

;; These macros define the various diverts we're going to get going
!define(joinedDGGDivert,1)
!define(joinedDGMDivert,2)
!define(matrixDivert,3)
!define(directDGGDivert,4)
!define(directDGMDivert,5)
!define(directCloudDivert,6)

; ------------------------------------------------------------- Direct write

;; This macro is used to note a matrix to be output later
!define(noteMatrix,{!ifdef(flagGotMatrices,{!divert(!matrixDivert),!divert})!dnl
!define(flagGotMatrices,{Yes})!divert(!matrixDivert)$1!divert})

;; These macros are used to note a new directWrite DGG or DGM at a
;; rather low level.
!define(noteDirectDGG,{!dnl
  !ifdef(flagAvoidDirectWrite,{!dnl
    !M4Error({You are supposed to be avoiding direct writes})})!dnl
  !ifdef(flagGotDirectDGGs,{!divert(!directDGGDivert),!divert})!dnl
  !define(flagGotDirectDGGs,{Yes})!divert(!directDGGDivert)$1!divert})

!define(noteDirectDGM,{!dnl
  !ifdef(flagAvoidDirectWrite,{!dnl
    !M4Error({You are supposed to be avoiding direct writes})})!dnl
  !ifdef(flagGotDirectDGMs,{!divert(!directDGMDivert),!divert})!dnl
  !define(flagGotDirectDGMs,{Yes})!divert(!directDGMDivert)$1!divert})

!define(noteDirectCloud,{!ifdef(flagGotDirectClouds,{!divert(!directCloudDivert),!divert})!dnl
!define(flagGotDirectClouds,{Yes})!divert(!directCloudDivert)$1!divert})

;; This macro is used to write one DGG species complete with precision
;; The quantity is in state/outputPrecision.$1 and the label is in $2
;; other arguments can be optionally present (e.g. prefix signal) and
;; are applied to the label command
!define(directWriteDGG,{!dnl
Label, quantity=state.$1, label='$2'!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGG({source=state.$1,precision=outputPrecision.$1,status=otherDiagnostics.status$1, quality=otherDiagnostics.quality$1})})
;; This macro is similar except that it skips status and quality
!define(directWriteDGGNoDiag,{!dnl
Label, quantity=state.$1, label='$2'!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGG({source=state.$1,precision=outputPrecision.$1})})

;; This macro is similar to the above except for the case where
;; the vector name should be included in $1
!define(directWriteDGGNotState,{!dnl
Label, quantity=$1, label=$3!ifelse($#,3,{},{,!shift(!shift(!shift($*)))})!dnl
!noteDirectDGG({source=$1,precision=$2})})
;; This macro is similar to the above except for the case where there
;; is no precision quantity
!define(directWriteDGGNoPrecisionNotState,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGG({source=$1})})

;; This macro is used to write one DGM species.  The quantity is in $1
;; (including the vector), and the label is in $2
!define(directWriteDGM,{!dnl
Label, quantity=state.$1, label='$2'!ifelse($#,2,{},{,!shift(!shift($*))})
Label, quantity=outputPrecision.$1, $
  label='$2 precision'!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGM({source=state.$1,source=outputPrecision.$1})})
!define(directWriteDGMNotState,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})
!noteDirectDGM({source=$1})})

;; This macro is used to write one Cloud species.  The quantity is in $1
;; (including the vector), and the label is in $2
!define(directWriteCloud,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectCloud({source=$1})})

;; This macro is used to spit out all the accumulated DGM/DGGs
!ifdef(flagSuppressRegularOutput,
{!define(flushDGGDGMFiles,{!dnl
  !clearDivert(!directDGGDivert,!directDGMDivert,!directCloudDivert)})},
{!define(flushDGGDGMFiles,{!dnl
;; First do the DGGs
!ifdef(flagGotDirectDGGs,{!dnl
!DirectWriteDGGCommand, hdfVersion=!hdfVersion, $
  type=l2dgg, !undivert(!directDGGDivert)})
;; Now the DGMs
!ifdef(flagGotDirectDGMs,{!dnl
!DirectWriteDGMCommand, hdfVersion=!hdfVersion, $
  type=l2aux, !undivert(!directDGMDivert)})
;; Now the cloud stuff
!ifdef(flagGotDirectClouds,{!dnl
DirectWrite, file='!CloudFilename', hdfVersion=!hdfVersion, $
  type=l2aux, !undivert(!directCloudDivert)})
;; Clear our macros
!undefine(flagGotDirectDGGs)!undefine(flagGotDirectDGMs)!undefine(flagGotDirectClouds)})})

;; These macros are associated with the direct write code.  It writes a
;; set of radiances $2... into the L2FWM-$1 file.
!define(labelOneFwmRad,{label, quantity=fwm.band$1, /prefixSignal, label=' !phase'!nl})
!define(oneFwmRadTerm,{source=fwm.band$1,})

!ifdef(flagSuppressRegularOutput,
{!define(directWriteFwmRad,{})},
{!define(directWriteFwmRad,{!ifdef(l2version,{!dnl
!forall(labelOneFwmRad,!tidyList(!shift($*)))!dnl
  DirectWrite, !forall(oneFwmRadTerm,!tidyList(!shift($*))) type=l2fwm, $
  file='!l2fwmFileName($1)', $
  hdfVersion=!hdfVersion})})})

;; This macro writes radiance diagnostics
!define(directWriteRadianceDiagnostics,{!dnl
 !directWriteDGMNotState(minorFrameDiagnostics.chisqMMAF$1,' chisqMMAF !phase', /prefixSignal)
 !directWriteDGMNotState(minorFrameDiagnostics.chisqMMIF$1,' chisqMMIF !phase', /prefixSignal)
 !directWriteDGMNotState(minorFrameDiagnostics.chisqChan$1,' chisqChan !phase', /prefixSignal)
 !directWriteDGMNotState(minorFrameDiagnostics.noRadsPerMIF$1,' noRadsPerMIF !phase',/prefixSignal)

 !directWriteDGGNotState(mappedChisqMean.chisqBinned$1,mappedChisqMax.chisqBinned$1,!dnl
   ' chisqBinned !phase',/prefixSignal)
 !directWriteDGGNoPrecisionNotState(otherDiagnostics.noRadsBinned$1,!dnl
   ' noRadsBinned !phase',/prefixSignal)!nl})

;; This macro writes the misc. diagnostics
!define(directWriteOneDiagDGG,{!directWriteDGGNoPrecisionNotState(diag!phase.$1,'!translit($1,{_},{-})-!phase')!nl})

; ------------------------------------------------------------- Join

;; These macros are used to note the joined DGM/DGGs
!define(storeJoinedDGG,{!ifdef(flagAvoidDirectWrite,{},{!dnl
!M4Error({You should set flagAvoidDirectWrite to use joinDGG})})!dnl
!ifdef(flagGotJoinedDGGs,{!divert(!joinedDGGDivert),!divert})!dnl
!define(flagGotJoinedDGGs,{Yes})!divert(!joinedDGGDivert)$1!divert})

!define(storeJoinedDGM,{!ifdef(flagAvoidDirectWrite,{},{!dnl
!M4Error({You should set flagAvoidDirectWrite to use joinDGM})})!dnl
!ifdef(flagGotJoinedDGMs,{!divert(!joinedDGMDivert),!divert})!dnl
!define(flagGotJoinedDGMs,{Yes})!divert(!joinedDGMDivert)$1!divert})

!define(joinDGG,{!dnl
!storeJoinedDGG(joinedDGG_$1_!phase)!dnl
joinedDGG_$1_!phase: l2gp, source=state.$1, precision=outputPrecision.$1, swath='$2'
})

!define(joinDGM,{!dnl
!storeJoinedDGM(joinedDGM_$1_!phase)!storeJoinedDGM(joinedDGM_$1_!phase_precision)!dnl
joinedDGM_$1_!phase: l2aux, source=state.$1, sdName='$2'
joinedDGM_$1_!phase_precision: l2aux, source=outputPrecision.$1, sdName='$2 precision'
})

;; This macro joins the above filled quantities
!define(joinRadianceDiagnostics,{!dnl
   joinedDGM_chisqMMAF$1_!phase: l2aux, source=minorFrameDiagnostics.chisqMMAF$1, $
     /prefixSignal, sdName=' chisqMMAF !phase'
   joinedDGM_chisqMMIF$1_!phase: l2aux, source=minorFrameDiagnostics.chisqMMIF$1, $
     /prefixSignal, sdName=' chisqMMIF !phase'
   joinedDGM_chisqChan$1_!phase: l2aux, source=minorFrameDiagnostics.chisqChan$1, $
     /prefixSignal, sdName=' chisqChan !phase'
   joinedDGM_noRadsPerMIF$1_!phase: l2aux, source=minorFrameDiagnostics.noRadsPerMIF$1, $
     /prefixSignal, sdName=' noRadsPerMIF !phase'

   joinedDGG_chisqBinned$1_!phase: l2gp, $
     source=mappedChiSqMean.chisqBinned$1, $
     precision=mappedChisqMax.chisqBinned$1, $
     /prefixSignal, swath=' chisqBinned !phase'
   joinedDGG_noRadsBinned$1_!phase: l2gp, $
     source=minorFrameDiagnostics.noRadsBinned$1, $
     /prefixSignal, swath=' noRadsBinned !phase'

   !storeJoinedDGM(joinedDGM_chisqMMAF$1_!phase)!dnl
   !storeJoinedDGM(joinedDGM_chisqMMIF$1_!phase)!dnl
   !storeJoinedDGM(joinedDGM_chisqChan$1_!phase)!dnl
   !storeJoinedDGM(joinedDGM_noRadsPerMIF$1_!phase)!dnl

   !storeJoinedDGG(joinedDGG_chisqBinned$1_!phase)
   !storeJoinedDGG(joinedDGG_noRadsBinned$1_!phase)
})

;; This macro uses the joinDGG (for the moment, will use DGM when we
;; got to hdf5) to join the diagnostics stuff
!define(joinOneDiagDGG,{!storeJoinedDGG(joinedDGG_$1_!phase)!dnl
  joinedDGG_$1_!phase: l2gp, source=diag!phase.$1, $
    swath='!translit($1,{_},{-})-!phase'!nl})

; --------------------------------------------------------------- Filling diagnostics

;; This macro is used to fill radiance chi squares
!define(fillMinorFrameDiagnostics,{!dnl
   Fill, quantity=minorFrameDiagnostics.chisqMMAF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=minorFrameDiagnostics.chisqMMIF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=minorFrameDiagnostics.chisqChan$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=minorFrameDiagnostics.noRadsPerMIF$1, method=special, $
     measurements=y!phase.band$1!nl})

!define(fillMappedDiagnostics,{!dnl
   Fill, quantity=mappedChisqMean.chisqBinned$1, method=binmean, $
     sourceQuantity=minorFrameDiagnostics.chisqMMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)
   Fill, quantity=mappedChisqMax.chisqBinned$1, method=binmax, $
     sourceQuantity=minorFrameDiagnostics.chisqMMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)
   Fill, quantity=otherDiagnostics.chisqProfile$1, method=binmax, $
     sourceQuantity=minorFrameDiagnostics.chisqMMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)
   Fill, quantity=otherDiagnostics.noRadsBinned$1, method=binTotal, $
     sourceQuantity=minorFrameDiagnostics.noRadsPerMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)
   Fill, quantity=otherDiagnostics.noRadsProfile$1, method=binTotal, $
     sourceQuantity=minorFrameDiagnostics.noRadsPerMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)!nl})

;; This macro writes the above diagnostics
!define(doRadianceDiagnostics,{!dnl
   begin Fill
     !forall(fillMinorFrameDiagnostics,$*)
     !forall(fillMappedDiagnostics,$*)
   end Fill
   begin Join
     !ifdef(flagAvoidDirectWrite,
       {!forall(joinRadianceDiagnostics,$*)},
       {!forall(directWriteRadianceDiagnostics,$*)})
   end Join!nl})


; --------------------------------------------------------------- Offseting radiances

;; This macro is used to offset the forward model radiances
;; It is called inside a Fill statement.  Note it takes !phase as a
;; 'global' parameter.
!define(offsetRadiance,{!dnl
   Fill, quantity=f!phase.band$1, radianceQuantity=y!phase.band$1, method=offsetRadiance!nl})
!define(offsetRadiances,{!dnl
   begin Fill
   !forall(offsetRadiance,$*)
   end Fill})

; -------------------------------------------------------------- Retrievals

;; This macro puts all the boring stuff in the Retrieve command line
;; that we're used to seeing
;;  will add FM output to PEs later
!ifdef(flagPrecisionEstimates,{!dnl
  !define(retrievalArguments,{$
    state=x$1, fwdModelExtra=state, $
    measurements=y$1, measurementSD=yNoise$1, $
    apriori=a$1, covariance=Sa$1, $
    outputSD=sdOut$1, $
    !ifdef(flagComputeAvks,{average=Avk$1,!noteMatrix(Avk$1)}) $
    vRegWeightVec=vr$1!ifelse(!dimension,1D,{},{, hRegWeightVec=hr$1})})},!dnl
{ !define(retrievalArguments,{$
  state=x$1, fwdModelExtra=state, $
  measurements=y$1, measurementSD=yNoise$1, $
  apriori=a$1, covariance=Sa$1, $
  outputSD=sdOut$1, fwdModelOut=f$1, $
  vRegWeightVec=vr$1, hRegWeightVec=hr$1, $
  !ifdef(flagComputeAvks,{average=Avk$1,!noteMatrix(Avk$1)})!dnl
  !ifdef(flagComputeSout,{outputCovariance=Sout$1,!noteMatrix(Sout$1)})!dnl
  lowBound=lb$1, highBound=hb$1, diagnostics=diag$1})})

; ---------------------------------------------------------------- Standard products

;; This macro is used to transfer a product into the 'standard products'
;; vector
!define(makeStandardProduct,{!dnl
  Fill, quantity=standardProducts.$1, method=vector, sourceQuantity=state.$1
  Fill, quantity=standardPrecision.$1, method=vector, sourceQuantity=outputPrecision.$1
  Fill, quantity=standardDiagnostics.status$1, method=vector, sourceQuantity=otherDiagnostics.status$1
  Fill, quantity=standardDiagnostics.quality$1, method=vector, sourceQuantity=otherDiagnostics.quality$1
})
!define(makeStandardProductNoDiag,{!dnl
  Fill, quantity=standardProducts.$1, method=vector, sourceQuantity=state.$1
  Fill, quantity=standardPrecision.$1, method=vector, sourceQuantity=outputPrecision.$1
})

; ---------------------------------------------------- Status flag bits

;; Bit 0 - Do not use this profile
  !define(statusDoNotUse,1)
;; Bit 1 - Be careful with this profile                            
  !define(statusBeWary,2)
;; Bit 2 - Empty for now
;; Bit 3 - Empty for now
;; Bit 4 - This profile may have been affected by high altitude clouds
  !define(statusHighCloud,16)
;; Bit 5 - This profile may have been affected by low altitude clouds
  !define(statusLowCloud,32)
;; Bit 6 - Empty for now
;; Bit 7 - Empty for now
;; Bit 8 - This profile is based on too few radiances
  !define(statusTooFewRadiances,256)

; --------------------------------------------- Cloud specific stuff

!define(computeDT,{!dnl
Fill, quantity=cloudOutput.DTband$1, method=manipulate, $
  a=measurement.band$1, b=cloudOutput.band$1, manipulation='a-b'!nl})

!define(flagBand32Clouds,{!dnl
  FlagCloud, quantity=y!phase.band32, ptanQuantity=state.ptanGHz, $ 
    height = [ 4000mb : 150mb ], cloudChannels=[ 1 ], cloudHeight=[ 1000mb : 700mb ],$
    cloudRadiance=cloudOutput.DTband5, cloudRadianceCutoff= -10K, mask=[ cloud, linAlg ]
  FlagCloud, quantity=y!phase.band32, ptanQuantity=state.ptanGHz, $
    height = [ 150mb : 46mb ], cloudChannels=[ 1 ], mask=[ cloud, linAlg ], $
    cloudRadiance=cloudOutput.DTband5, cloudRadianceCutoff=2K
})

; ------------------ High level macros for status and quality filling
!define(addInOneChisq,{!dnl
Fill, quantity=diag!MFradiometer.chisqTmp, method=manipulate, manipulation='a>b', $
  a=diag!MFradiometer.chisqTmp, b=otherDiagnostics.chisqProfile$1, /force!nl})
!define(addInOneNoRads,{!dnl
Fill, quantity=diag!MFradiometer.noRadsTmp, method=manipulate, manipulation='a+b', $
  a=diag!MFradiometer.noRadsTmp, b=otherDiagnostics.noRadsProfile$1, /force!nl})

!define(makeFlagsForOneProduct,{!dnl
!undefine(MFproduct)!dnl
!undefine(MFradiometer)!dnl
!undefine(MFchisqscale)!dnl
!undefine(MFminrads)!dnl
!undefine(MFcloudmax)!dnl
!undefine(MFcloudmin)!dnl
!ProcessParVal(MF,$@)!dnl
;; Quality
Fill, quantity=diag!MFradiometer.chisqTmp, method=explicit, explicitValues=0, /spread
!forall(addInOneChisq,!flaggingBands)
;; Run a boxcar over this
Fill, quantity=diag!MFradiometer.chisqTmp, method=boxcar, sourceQuantity=diag!MFradiometer.chisqTmp, $
  boxCarMethod=max, width=3
;; Now fill quality from this.
Fill, quantity=otherDiagnostics.quality!MFproduct, method=quality, $
  sourceQuantity=diag!MFradiometer.chisqTmp, scale=!MFchisqscale

;; Status
Fill, quantity=otherDiagnostics.status!MFproduct, method=explicit, explicitValues=0, /spread
!ifdef(MFminrads,{
;; too few radiances
Fill, quantity=diag!MFradiometer.noRadsTmp, method=explicit, explicitValues=0, /spread
!forall(addInOneNoRads,!flaggingBands)
;; Run a boxcar over this
Fill, quantity=diag!MFradiometer.noRadsTmp, method=boxcar, sourceQuantity=diag!MFradiometer.noRadsTmp, $
  boxCarMethod=min, width=3
;; Set status based on this
Fill, quantity=otherDiagnostics.status!MFproduct, method=status, $
  status=!statusTooFewRadiances+!statusDoNotUse, $
  sourceQuantity=diag!MFradiometer.noRadsTmp, minValue=!MFminrads, /additional})

!ifdef(MFcloudmax,{
;; Status - cloudy radiances - already had the box car run on it.
Fill, quantity=otherDiagnostics.status!MFproduct, method=status, status=!statusHighCloud+!statusBeWary, $
  sourceQuantity=otherDiagnostics.highCloudSummary!MFradiometer, maxValue=!MFcloudmax, /additional
})
!ifdef(MFcloudmin,{
;; Status - cloudy radiances - already had the box car run on it.
Fill, quantity=otherDiagnostics.status!MFproduct, method=status, status=!statusHighCloud+!statusBeWary, $
  sourceQuantity=otherDiagnostics.lowCloudSummary!MFradiometer, minValue=!MFcloudmin, /additional
})})


; $Log$
; Revision 1.89  2004/04/14 23:07:22  livesey
; Moved cloud output to L2AUX-Cloud
;
; Revision 1.88  2004/04/08 22:42:23  livesey
; More agile flagging for R5 case.
;
; Revision 1.87  2004/04/06 01:18:07  livesey
; Bug fix in status no-radiance flag.
;
; Revision 1.86  2004/04/02 01:08:41  livesey
; Bug fixes and added cloudmin option to the flagging macro
;
; Revision 1.85  2004/03/27 00:16:34  livesey
; Added high level macros for status/quality filling.
;
; Revision 1.84  2004/03/17 17:13:54  livesey
; Added some status flag bit constants and more stuff for diagnostic
; precursors.
;
; Revision 1.83  2004/03/12 00:18:27  livesey
; Now defaults to hdf 5
;
; Revision 1.82  2004/03/10 23:00:29  pwagner
; Exclude file field from dgg/dgm directwrites if flagAutoSplitSources
;
; Revision 1.81  2004/02/13 21:12:23  livesey
; Added allHiResProducts
;
; Revision 1.80  2004/02/12 02:06:33  livesey
; Various bug fixes and additions
;
; Revision 1.79  2004/02/11 21:41:58  livesey
; Added output of status and quality and tidied up
;
; Revision 1.78  2004/02/03 21:43:56  livesey
; Updated handling of chisqBinned stuff
;
; Revision 1.77  2004/01/24 03:23:19  livesey
; Now uses truth for edge of averaging kernels if available.
;
; Revision 1.76  2004/01/16 15:55:36  mjf
; Some updates for precision estimates and 1D cases.
;
; Revision 1.75  2003/11/15 00:23:06  livesey
; Now automagically defines flagDontDestroyVectors
;
; Revision 1.74  2003/11/14 00:12:39  livesey
; Added ability to automatically produce averaging kernels and output
; covariances on request.  Also support for flagSuppressRegularOutput
;
; Revision 1.73  2003/10/15 23:33:24  pwagner
; Made l2fwm file name sensitive to usingPCF
;
; Revision 1.72  2003/09/05 23:26:28  pwagner
; Switched fwoward model radiance DirectWrite type from l2aux to l2fwm
;
; Revision 1.71  2003/09/02 22:48:43  pwagner
; Tweaked the defines to make the quotes come out right
;
; Revision 1.70  2003/09/02 22:25:25  pwagner
; Output/DirectWrite to abbreviated fileNames only if usingPCF
;
; Revision 1.69  2003/09/02 20:52:09  pwagner
; CloudFilename same as DGMFilename if usingPCF
;
; Revision 1.68  2003/08/28 23:52:59  livesey
; Tried to bring directWriteDGG/DGM and joinDGG/DGM more in line with each
; other.
;
; Revision 1.67  2003/08/28 16:30:25  livesey
; More changes to join vs. directWrite to bring them closer together.
;
; Revision 1.66  2003/08/27 22:23:58  livesey
; Moved error messages in joining
;
; Revision 1.65  2003/08/14 20:26:34  livesey
; Removed tropH2O stuff
;
; Revision 1.64  2003/08/06 17:49:31  livesey
; Changed output of matrices
;
; Revision 1.63  2003/07/24 22:13:28  livesey
; Changed type for DGG file
;
; Revision 1.62  2003/07/11 01:23:05  livesey
; Made it more backwards compatible
;
; Revision 1.61  2003/07/09 19:41:54  livesey
; Bug fix in cloud filename
;
; Revision 1.60  2003/07/09 17:58:01  livesey
; Added cloud file.
;
; Revision 1.59  2003/07/08 20:03:56  livesey
; New handling of hdf version stuff
;
; Revision 1.58  2003/07/08 00:50:43  livesey
; Better handling of l2fwm files
;
; Revision 1.57  2003/07/08 00:17:20  livesey
; New approach to output with directWrite being used most places
;
; Revision 1.56  2003/06/05 23:39:39  livesey
; IWC no longer a standard product
;
; Revision 1.55  2003/06/04 17:14:07  livesey
; Added filename stuff to directWrite
;
; Revision 1.54  2003/05/29 16:41:17  livesey
; Made allBandUSBs skip the upper sidebands in R1A/R1B
;
; Revision 1.53  2003/05/12 02:07:56  livesey
; Output subset of retrieval diagnostics, and drop precisions.
;
; Revision 1.52  2003/05/11 22:39:07  livesey
; Added ignore zero / negative flags.
;
; Revision 1.51  2003/05/11 22:35:54  livesey
; Restored the binned quantities, worked out what was wrong with them.
;
; Revision 1.50  2003/05/11 06:12:20  livesey
; Temporarily removed the binned stuff
;
; Revision 1.49  2003/05/11 00:17:46  livesey
; Reverted to previous version.  Couldn't merge two fields (yet).
;
; Revision 1.47  2003/05/10 23:38:57  livesey
; Various bug fixes etc.
;
; Revision 1.46  2003/05/10 22:22:17  livesey
; New approach to standard products, joining, output, columns etc.
;
; Revision 1.45  2003/05/10 20:47:08  livesey
; Bug fixes
;
; Revision 1.44  2003/05/10 00:57:53  livesey
; More chi squared etc. stuff
;
; Revision 1.43  2003/05/08 21:08:02  livesey
; Various bug fixes and tidies
;
; Revision 1.42  2003/05/08 20:49:21  livesey
; Various tidyups and changes
;
; Revision 1.41  2003/03/22 01:18:24  livesey
; Added initHiRes
;
; Revision 1.40  2003/02/27 00:39:38  livesey
; General tidy up and dead wood removal
;
; Revision 1.39  2002/12/16 16:24:51  mjf
; HiRes and columns
;
; Revision 1.38  2002/11/26 23:38:20  livesey
; Added radiance diagnostics
;
; Revision 1.37  2002/11/21 18:24:11  livesey
; Refined Avk stuff
;
; Revision 1.36  2002/11/21 01:24:01  livesey
; Add transfer of outputPrecision.tropH2O if requested
;
; Revision 1.35  2002/11/21 01:19:18  livesey
; Added call to NegativePrecision command
;
; Revision 1.34  2002/11/20 19:59:37  mjf
; Fill columns to be added, but might break the retrieval, so commented
; out for just now.
;
; Revision 1.33  2002/10/25 23:56:45  livesey
; Minor changes in the diagnostics, added the offsetRadiances stuff
;
; Revision 1.32  2002/10/25 22:25:59  livesey
; Added the retrieval diagnostics stuff
;
; Revision 1.31  2002/10/25 01:10:33  livesey
; Added the tropH2O option to completephase
;
; Revision 1.30  2002/10/17 18:24:40  livesey
; Typo
;
; Revision 1.29  2002/10/17 18:19:50  livesey
; Added low/high bound to retrieval
;
; Revision 1.28  2002/10/16 20:21:11  mjf
; Added GPH precision.
;
; Revision 1.27  2002/10/11 19:39:21  livesey
; Bug fix
;
; Revision 1.26  2002/10/11 19:29:29  livesey
; Added 1D forward models.
;
; Revision 1.25  2002/10/09 00:48:23  livesey
; Split forward models into simple and otherwise
;
; Revision 1.24  2002/10/03 21:36:00  livesey
; Changed forward models to use simplerMolecules lists
;
; Revision 1.23  2002/10/03 16:18:24  livesey
; Changed temperaturePrecisionQuantity to tempPrecisionQuantity for Mark
;
; Revision 1.22  2002/10/03 05:41:41  livesey
; Added baseline to forward models
;
; Revision 1.21  2002/10/02 23:22:47  livesey
; New definitions of the joinDGG/DGM stuff.  Also added forward model
; construction stuff.
;
; Revision 1.20  2002/10/02 23:06:01  pwagner
; RHI now separate fill methods
;
; Revision 1.19  2002/10/01 18:33:36  mjf
; New Fill for RHi precision.  Need gotAK defined for AK output.
; RetrivalArguments depends on precisionEstimates.
;
; Revision 1.18  2002/08/26 20:27:07  livesey
; New regularization (horizontal and vetical)
;
; Revision 1.17  2002/08/23 23:26:29  livesey
; Made the FWM rad stuff report the actual signal
;
; Revision 1.16  2002/08/15 22:46:00  livesey
; Added regularization vector
;
; Revision 1.15  2002/08/05 17:20:23  livesey
; Added code to convert H2O back to RHI at the end of each phase
;
; Revision 1.14  2002/08/04 16:18:47  mjf
; Some things switched off for precision estimates.
;
; Revision 1.13  2002/07/23 23:47:28  livesey
; Added some macros for sids
;
; Revision 1.12  2002/07/22 20:34:17  livesey
; Tidied up bug with subsetState
;
; Revision 1.11  2002/07/20 00:54:56  livesey
; Added more subsetting stuff
;
; Revision 1.10  2002/07/18 06:30:55  livesey
; Added the radianceSubset stuff
;
; Revision 1.9  2002/07/17 19:30:10  livesey
; Fill GPH
;
; Revision 1.8  2002/07/06 21:18:48  livesey
; Made sure the direct writes for forward model radiances are only done if
; l2version is defined.
;
; Revision 1.7  2002/07/05 21:46:36  livesey
; Put in the configInfo information
;
; Revision 1.6  2002/07/05 21:37:02  livesey
; New (working) DGM/DGG handling
;
; Revision 1.5  2002/07/05 17:46:38  livesey
; New work for multiphase retrievals
;
; Revision 1.4  2002/06/24 17:24:47  livesey
; Bug in doNoise macro.
;
; Revision 1.3  2002/05/29 00:08:23  livesey
; Typo fix
;
; Revision 1.2  2002/05/28 22:36:14  livesey
; Semi freeze of version
;
; Revision 1.1  2002/04/29 21:54:59  pwagner
; First commit
;
