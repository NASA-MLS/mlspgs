; $Id$

; This l2cf fragment defines macros we're going to use a lot
; in doing phased retrievals

; Define some macros we need for various quantities
!define(allRadiometers,{R1A,R1B,R2,R3,R4,R5H,R5V})
!define(allBands,{!forloop({i},1,33,{!i, })34}) ; 1,2,3..34
!define(allBandLSBs,{!makelist({},{L},!allBands)})
!define(allBandUSBs,{!forloop({i},2,20,{!i{}U,})23U,24U,25U,!forloop({i},27,31,{!i{}U,})33U})

; These macros define the MLS standard products
; IWC is somewhat special
!define(allStandardProductsWithColumns,{BrO,CH3CN,ClO,CO,H2O,HCl,HCN,HNO3,HO2,HOCl,N2O,O3,OH})
!define(allStandardProductsWithoutColumns,{Temperature,GPH,RHI})
!define(allStandardProducts,{!tidyList(!allStandardProductsWithColumns, $
  !allStandardProductsWithoutColumns)})

;; These macros define the format of our output files
!ifdef(hdfVersion,{},{!define(hdfVersion,4)})

;; These macros define our standard output filenames
!define(DGGFilename,{'!outpathl2gp/MLS-Aura_L2GP-DGG_!l2version_!day.he!hdfVersion'})
!define(DGMFilename,{'!outpathl2aux/MLS-Aura_L2AUX-DGM_!l2version_!day.h!hdfVersion'})
!define(CloudFilename,{'!outpathl2aux/MLS-Aura_L2AUX_Cloud_!l2version_!day.h!hdfVersion'})

;; This macro is used in sids runs to get the band number part of a band
;; specifier (i.e. strip off the sideband if it is present)
!define(getBandNumber,{!regexp({$1},{[0-9]+},{\&})})
;; Some other low level macros
!define(systemp,{!systemp$1})
!define(nbw,{!nbw$1})

;; This macro is called at the start of each phase to setup its
;; vectors and matrices.
!define(setupPhase,{!dnl
begin Fill
  ;; Define state related vectors
  x$1: Vector, template=x$1Template
  a$1: Vector, template=x$1Template
  vr$1: Vector, template=x$1Template
  hr$1: Vector, template=x$1Template
  sdIn$1: Vector, template=x$1Template
  sdOut$1: Vector, template=x$1Template
  lb$1: Vector, template=x$1Template
  hb$1: Vector, template=x$1template
  ;; Define measurement related vectors
  y$1: Vector, template=y$1Template
  yNoise$1: Vector, template=y$1Template
  f$1: Vector, template=y$1Template
  ;; Optical depth may be turned on again, sometime, for the PEs
  !ifdef(flagPrecisionEstimates,{},{od$1: Vector, template=od$1Template})
  ;; Define retrieval diagnostics vector
  diag$1: Vector, template=retrievalDiagnosticsTemplate
  ;; Fill state related vectors
  Transfer, source=state, destination=x$1
  Transfer, source=apriori, destination=a$1
  Transfer, source=aprioriPrecision, destination=sdIn$1
  Transfer, source=vReg, destination=vr$1
  Transfer, source=hReg, destination=hr$1
  Transfer, source=lowBound, destination=lb$1
  Transfer, source=highBound, destination=hb$1
  ;; Construct and fill state covariance
  myCovariance$1: matrix, columns=a$1, type=spd
  FillCovariance, matrix=myCovariance$1, diagonal=sdIn$1, /invert
  ;; Construct averaging kernel matrix
  !ifdef(flagGotAK,{!dnl
  akOut$1: Matrix, columns=x$1, rows=x$1
  !ifdef(flagGotAnyAKs,{!dnl
  !divert(!AVKDivert), akOut$1!divert},{!dnl
  !divert(!AVKDivert)akOut$1!divert})
  !define(flagGotAnyAKs,{Yes})})
  ;; Fill radiance related vectors
  Transfer, source=measurement, destination=y$1
  Transfer, source=measurementNoise, destination=yNoise$1
end Fill})

;; This macro is called at the end of a retrieval phase to store the
;; results back.
!define(completePhase,{!dnl
;; Set default values for some parameters
!undefine(completePhasetroph2o)
!ProcessParVal({completePhase},!shift($@))
begin Fill
  ;; Put state etc. back
  Transfer, source=x$1, destination=state
  Transfer, source=sdOut$1, destination=outputPrecision
  !ifdef(completePhasetroph2o,{!dnl
    ;; In this case copy TropH2O into H2O as requested
    Fill, quantity=state.h2o, sourceQuantity=state.tropH2O, $
      method=vector, /interpolate
    ;; And its precision
    Fill, quantity=outputPrecision.h2o, sourceQuantity=outputPrecision.tropH2O, $
      method=vector, /interpolate})

  ;; FM output will be turned on again, sometime, for the PEs
  !ifdef(flagPrecisionEstimates,{},{Transfer, source=f$1, destination=fwm})
  ;; Clean up dead vectors and matrices
  Destroy, matrix=myCovariance$1
  Destroy, vector=x$1
  Destroy, vector=a$1
  Destroy, vector=vr$1
  Destroy, vector=hr$1
  Destroy, vector=sdIn$1
  Destroy, vector=sdOut$1
  Destroy, vector=lb$1
  Destroy, vector=hb$1
  Destroy, vector=y$1
  Destroy, vector=yNoise$1
  Destroy, vector=f$1
  !ifdef(flagPrecisionEstimates,{},{Destroy, vector=od$1})
  ;; Compute new full GPH profile
  Fill, quantity=state.gph, method=hydrostatic, $
    refGPHquantity=state.refGPH, temperatureQuantity=state.temperature
  ;; And GPH precision
  Fill, quantity=outputPrecision.gph, method=gphPrecision, $
    refGPHPrecisionquantity=outputPrecision.refGPH, $
    tempPrecisionQuantity=outputPrecision.temperature
  ;; Compute RHI from H2O
  Fill, quantity=state.rhi, h2oQuantity=state.h2o, $
    temperatureQuantity=state.temperature, method=RHIFromH2O, /dontMask
  ;; And RHI precision
  Fill, quantity=outputPrecision.rhi, $
    h2oPrecisionQuantity=outputPrecision.h2o, $
    tempPrecisionQuantity=outputPrecision.temperature, $
    h2oQuantity=state.h2o, temperatureQuantity=state.temperature, $
    method=RHIPrecisionFromH2O, /dontMask
  ;; Set precision -ve when wose than 50% apriori precision
  NegativePrecision, precision=outputPrecision, aprioriPrecision=aprioriPrecision
end Fill

!ifdef(flagPrecisionEstimates,{},{
  begin Join
    !forall(directWriteOneDiagDGG,!outputRetrievalDiagnostics)
  end Join})
;;  begin Fill
;;    Destroy, vector=diag$1
;;  end Fill
})

;; This macro initialises the _HR species with interpolations of their
;; standard resolution equivalents
!define(oneHiResTransfer,{Fill, quantity=state.$1, method=vector, $
  sourceQuantity=state.!trimHR($1), /interpolate!nl})
!define(initHiRes,{begin Fill
  Fill, quantity=state.Temperature_HR, method=vector, $
    sourceQuantity=state.Temperature, /interpolate
  !forall(oneHiResTransfer,!allHiResMolecules)
end Fill})

;; These macros define the various diverts we're going to get going
!define(directDGGDivert,1)
!define(directDGMDivert,2)
!define(directCloudDivert,3)
!define(AVKDivert,4)

;; This macro is used to note an averaging kernel to be output later
!define(storeAVK,{!ifdef(flagGotAVKs,{!divert(!AVKDivert),!divert})!dnl
!define(flagGotAVKs,{Yes})!divert(!AVKDivert)$1!divert})

;; These macros are used to note a new directWrite DGG or DGM at a
;; rather low level.
!define(noteDirectDGG,{!ifdef(flagGotDirectDGGs,{!divert(!directDGGDivert),!divert})!dnl
!define(flagGotDirectDGGs,{Yes})!divert(!directDGGDivert)$1!divert})

!define(noteDirectDGM,{!ifdef(flagGotDirectDGMs,{!divert(!directDGMDivert),!divert})!dnl
!define(flagGotDirectDGMs,{Yes})!divert(!directDGMDivert)$1!divert})

!define(noteDirectCloud,{!ifdef(flagGotDirectClouds,{!divert(!directCloudDivert),!divert})!dnl
!define(flagGotDirectClouds,{Yes})!divert(!directCloudDivert)$1!divert})

;; This macro is used to write one DGG species complete with precision
;; The quantity is in state/outputPrecision.$1 and the label is in $2
;; other arguments can be optionally present (e.g. prefix signal) and
;; are applied to the label command
!define(directWriteDGG,{!dnl
Label, quantity=state.$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGG({source=state.$1,precision=outputPrecision.$1})})
;; This macro is similar to the above except for the case where there
;; is no precision quantity, and the vector name should be included in $1
!define(directWriteDGGNoPrecision,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGG({source=$1})})

;; This macro is used to write one DGM species.  The quantity is in $1
;; (including the vector), and the label is in $2
!define(directWriteDGM,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectDGM({source=$1})})

;; This macro is used to write one Cloud species.  The quantity is in $1
;; (including the vector), and the label is in $2
!define(directWriteCloud,{!dnl
Label, quantity=$1, label=$2!ifelse($#,2,{},{,!shift(!shift($*))})!dnl
!noteDirectCloud({source=$1})})

;; This macro is used to spit out all the accumulated DGM/DGGs
!define(flushDGGDGMFiles,{!dnl
;; First do the DGGs
!ifdef(flagGotDirectDGGs,{!dnl
DirectWrite, file=!DGGFilename, hdfVersion=!hdfVersion, $
  type=l2gp, !undivert(!directDGGDivert)})
;; Now the DGMs
!ifdef(flagGotDirectDGMs,{!dnl
DirectWrite, file=!DGMFilename, hdfVersion=!hdfVersion, $
  type=l2aux, !undivert(!directDGMDivert)})
;; Now the cloud stuff
!ifdef(flagGotDirectClouds,{!dnl
DirectWrite, file=!CloudFilename, hdfVersion=!hdfVersion, $
  type=l2aux, !undivert(!directCloudDivert)})
;; Clear our macros
!undefine(flagGotDirectDGGs)!undefine(flagGotDirectDGMs)!undefine(flagGotDirectClouds)})

;; These macros are associated with the direct write code.  It writes a
;; set of radiances $2... into the L2FWM-$1 file.
!define(labelOneFwmRad,{label, quantity=fwm.band$1, /prefixSignal, label=' !phase'!nl})
!define(oneFwmRadTerm,{source=fwm.band$1,})
!define(directWriteFwmRad,{!ifdef(l2version,{!dnl
!forall(labelOneFwmRad,!tidyList(!shift($*)))!dnl
  DirectWrite, !forall(oneFwmRadTerm,!tidyList(!shift($*))) type=l2aux, $
  file='!outpathl2fwm/MLS-Aura_L2FWM-$1_!l2version_!day.h!hdfVersion', $
  hdfVersion=!hdfVersion})})

;; This macro is used to fill radiance chi squares
!define(fillRadianceDiagnostics,{!dnl
   Fill, quantity=radianceDiagnostics.chisqMMAF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=radianceDiagnostics.chisqMMIF$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=radianceDiagnostics.chisqChan$1, method=special, $
     measurements=y!phase.band$1, model=f!phase.band$1, $
     noise=yNoise!phase.band$1, /ignoreZero, /ignoreNegative
   Fill, quantity=radianceDiagnostics.noRadsPerMIF$1, method=special, $
     measurements=y!phase.band$1
   Fill, quantity=radianceDiagnostics.chisqBinned$1, method=binmax, $
     sourceQuantity=radianceDiagnostics.chisqMMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)
   Fill, quantity=radianceDiagnostics.noRadsBinned$1, method=binTotal, $
     sourceQuantity=radianceDiagnostics.noRadsPerMIF$1, $
     ptanQuantity=state.ptan!moduleForBand($1)!nl})

;; This macro joins the above filled quantities
!define(joinRadianceDiagnostics,{!dnl
 !directWriteDGM(radianceDiagnostics.chisqMMAF$1,' chisqMMAF !phase', /prefixSignal)
 !directWriteDGM(radianceDiagnostics.chisqMMIF$1,' chisqMMIF !phase', /prefixSignal)
 !directWriteDGM(radianceDiagnostics.chisqChan$1,' chisqChan !phase', /prefixSignal)
 !directWriteDGM(radianceDiagnostics.noRadsPerMIF$1,' noRadsPerMIF !phase', /prefixSignal)

 !directWriteDGGNoPrecision(radianceDiagnostics.chisqBinned$1,!dnl
   ' chisqBinned !phase', /prefixSignal)
 !directWriteDGGNoPrecision( radianceDiagnostics.noRadsBinned$1,!dnl
   ' noRadsBinned !phase', /prefixSignal)!nl})

!define(doRadianceDiagnostics,{!dnl
   begin Fill
     !forall(fillRadianceDiagnostics,$*)
   end Fill
   begin Join
     !forall(joinRadianceDiagnostics,$*)
   end Join!nl})

;; This macro is used to offset the forward model radiances
;; It is called inside a Fill statement.  Note it takes !phase as a
;; 'global' parameter.
!define(offsetRadiance,{!dnl
   Fill, quantity=f!phase.band$1, radianceQuantity=y!phase.band$1, method=offsetRadiance!nl})
!define(offsetRadiances,{!dnl
   begin Fill
   !forall(offsetRadiance,$*)
   end Fill})

;; This macro writes the misc. diagnostics
!define(directWriteOneDiagDGG,{!directWriteDGGNoPrecision(diag!phase.$1,'!translit($1,{_},{-})-!phase')!nl})

;; This macro puts all the boring stuff in the Retrieve command line
;; that we're used to seeing
;;  will add FM output to PEs later
!ifdef(flagPrecisionEstimates,{!dnl
  !define(retrievalArguments,{$
  !ifdef(flagGotAK,{average=akOut$1,}) state=x$1, fwdModelExtra=state, $
    measurements=y$1, measurementSD=yNoise$1, $
    apriori=a$1, covariance=myCovariance$1, $
    outputSD=sdOut$1, $
    vRegWeightVec=vr$1, hRegWeightVec=hr$1})},!dnl
{ !define(retrievalArguments,{$
  !ifdef(flagGotAK,{average=akOut$1,}) state=x$1, fwdModelExtra=state, $
  measurements=y$1, measurementSD=yNoise$1, $
  apriori=a$1, covariance=myCovariance$1, $
  outputSD=sdOut$1, fwdModelOut=f$1, $
  vRegWeightVec=vr$1, hRegWeightVec=hr$1, $
  lowBound=lb$1, highBound=hb$1, diagnostics=diag$1})})

;; This macro is used to transfer a product into the 'standard products'
;; vector
!define(makeStandardProduct,{!dnl
  Fill, quantity=standardProducts.$1, method=vector, sourceQuantity=state.$1
  Fill, quantity=standardPrecision.$1, method=vector, sourceQuantity=outputPrecision.$1!nl})

; $Log$
; Revision 1.59  2003/07/08 20:03:56  livesey
; New handling of hdf version stuff
;
; Revision 1.58  2003/07/08 00:50:43  livesey
; Better handling of l2fwm files
;
; Revision 1.57  2003/07/08 00:17:20  livesey
; New approach to output with directWrite being used most places
;
; Revision 1.56  2003/06/05 23:39:39  livesey
; IWC no longer a standard product
;
; Revision 1.55  2003/06/04 17:14:07  livesey
; Added filename stuff to directWrite
;
; Revision 1.54  2003/05/29 16:41:17  livesey
; Made allBandUSBs skip the upper sidebands in R1A/R1B
;
; Revision 1.53  2003/05/12 02:07:56  livesey
; Output subset of retrieval diagnostics, and drop precisions.
;
; Revision 1.52  2003/05/11 22:39:07  livesey
; Added ignore zero / negative flags.
;
; Revision 1.51  2003/05/11 22:35:54  livesey
; Restored the binned quantities, worked out what was wrong with them.
;
; Revision 1.50  2003/05/11 06:12:20  livesey
; Temporarily removed the binned stuff
;
; Revision 1.49  2003/05/11 00:17:46  livesey
; Reverted to previous version.  Couldn't merge two fields (yet).
;
; Revision 1.47  2003/05/10 23:38:57  livesey
; Various bug fixes etc.
;
; Revision 1.46  2003/05/10 22:22:17  livesey
; New approach to standard products, joining, output, columns etc.
;
; Revision 1.45  2003/05/10 20:47:08  livesey
; Bug fixes
;
; Revision 1.44  2003/05/10 00:57:53  livesey
; More chi squared etc. stuff
;
; Revision 1.43  2003/05/08 21:08:02  livesey
; Various bug fixes and tidies
;
; Revision 1.42  2003/05/08 20:49:21  livesey
; Various tidyups and changes
;
; Revision 1.41  2003/03/22 01:18:24  livesey
; Added initHiRes
;
; Revision 1.40  2003/02/27 00:39:38  livesey
; General tidy up and dead wood removal
;
; Revision 1.39  2002/12/16 16:24:51  mjf
; HiRes and columns
;
; Revision 1.38  2002/11/26 23:38:20  livesey
; Added radiance diagnostics
;
; Revision 1.37  2002/11/21 18:24:11  livesey
; Refined Avk stuff
;
; Revision 1.36  2002/11/21 01:24:01  livesey
; Add transfer of outputPrecision.tropH2O if requested
;
; Revision 1.35  2002/11/21 01:19:18  livesey
; Added call to NegativePrecision command
;
; Revision 1.34  2002/11/20 19:59:37  mjf
; Fill columns to be added, but might break the retrieval, so commented
; out for just now.
;
; Revision 1.33  2002/10/25 23:56:45  livesey
; Minor changes in the diagnostics, added the offsetRadiances stuff
;
; Revision 1.32  2002/10/25 22:25:59  livesey
; Added the retrieval diagnostics stuff
;
; Revision 1.31  2002/10/25 01:10:33  livesey
; Added the tropH2O option to completephase
;
; Revision 1.30  2002/10/17 18:24:40  livesey
; Typo
;
; Revision 1.29  2002/10/17 18:19:50  livesey
; Added low/high bound to retrieval
;
; Revision 1.28  2002/10/16 20:21:11  mjf
; Added GPH precision.
;
; Revision 1.27  2002/10/11 19:39:21  livesey
; Bug fix
;
; Revision 1.26  2002/10/11 19:29:29  livesey
; Added 1D forward models.
;
; Revision 1.25  2002/10/09 00:48:23  livesey
; Split forward models into simple and otherwise
;
; Revision 1.24  2002/10/03 21:36:00  livesey
; Changed forward models to use simplerMolecules lists
;
; Revision 1.23  2002/10/03 16:18:24  livesey
; Changed temperaturePrecisionQuantity to tempPrecisionQuantity for Mark
;
; Revision 1.22  2002/10/03 05:41:41  livesey
; Added baseline to forward models
;
; Revision 1.21  2002/10/02 23:22:47  livesey
; New definitions of the joinDGG/DGM stuff.  Also added forward model
; construction stuff.
;
; Revision 1.20  2002/10/02 23:06:01  pwagner
; RHI now separate fill methods
;
; Revision 1.19  2002/10/01 18:33:36  mjf
; New Fill for RHi precision.  Need gotAK defined for AK output.
; RetrivalArguments depends on precisionEstimates.
;
; Revision 1.18  2002/08/26 20:27:07  livesey
; New regularization (horizontal and vetical)
;
; Revision 1.17  2002/08/23 23:26:29  livesey
; Made the FWM rad stuff report the actual signal
;
; Revision 1.16  2002/08/15 22:46:00  livesey
; Added regularization vector
;
; Revision 1.15  2002/08/05 17:20:23  livesey
; Added code to convert H2O back to RHI at the end of each phase
;
; Revision 1.14  2002/08/04 16:18:47  mjf
; Some things switched off for precision estimates.
;
; Revision 1.13  2002/07/23 23:47:28  livesey
; Added some macros for sids
;
; Revision 1.12  2002/07/22 20:34:17  livesey
; Tidied up bug with subsetState
;
; Revision 1.11  2002/07/20 00:54:56  livesey
; Added more subsetting stuff
;
; Revision 1.10  2002/07/18 06:30:55  livesey
; Added the radianceSubset stuff
;
; Revision 1.9  2002/07/17 19:30:10  livesey
; Fill GPH
;
; Revision 1.8  2002/07/06 21:18:48  livesey
; Made sure the direct writes for forward model radiances are only done if
; l2version is defined.
;
; Revision 1.7  2002/07/05 21:46:36  livesey
; Put in the configInfo information
;
; Revision 1.6  2002/07/05 21:37:02  livesey
; New (working) DGM/DGG handling
;
; Revision 1.5  2002/07/05 17:46:38  livesey
; New work for multiphase retrievals
;
; Revision 1.4  2002/06/24 17:24:47  livesey
; Bug in doNoise macro.
;
; Revision 1.3  2002/05/29 00:08:23  livesey
; Typo fix
;
; Revision 1.2  2002/05/28 22:36:14  livesey
; Semi freeze of version
;
; Revision 1.1  2002/04/29 21:54:59  pwagner
; First commit
;
