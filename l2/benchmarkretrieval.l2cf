; This l2cf is an attempt to make a universal l2cf for doing sids runs
; This is a simple l2cf for testing purposes. Mainly for testing the
; M4 stuff.  The band number to do is passed in as _band, the date as
; _day.

define(_outpath,/nas/bigdata/livesey/misc/)
define(_ver,v0-5-test1)
define(_day,1996-051)
define(_year,1996)

define(_signal,_sigBand$1)
define(_molecules,_mol$1)
define(_systemp, _systemp$1)

; First some m4 directives.
include(m4defs.l2cf)

; Now include the valid signals database
l2cfinc(validsignals-emls.l2cf)

; Now the spectroscopy database
l2cfinc(spectroscopy.l2cf)

; Now read the l2gp files for each specie
l2cfinc(readl2gpfiles.l2cf)

; Now read the gridded data for each specie
l2cfinc(readclimatology.l2cf)

; -------------------------------------------- Global settings ----
BEGIN GlobalSettings

    l1Boa, file='/nas/data/emls/l1boa/truth/{}_year{}/MLS-Aura_L1BOA_Full_s4-t_{}_day{}.dat'
    startTime = "00:00:00"
    endTime = "03:00:00"

    vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic, $
                   start=1000mb, formula=[25:12, 24:6]

    vGridRefGPH: vGrid, coordinate=Zeta, type=Explicit, values=100mb

    forwardModelGlobal, $
      l2pc='/nas/bigdata/livesey/misc/l2pc_band3_v1.0.dat', $
      l2pc='/nas/bigdata/livesey/misc/l2pc_band4_v1.0.dat', $
      l2pc='/nas/bigdata/livesey/misc/l2pc_band6_v1.0.dat'

    sidsFwm3: forwardModel, type=linear,  $
      signals = 'R2:190.B3F:N2O', $
      molecules = [o3, n2o, hno3], phiWindow=5
    retFwm3: forwardModel, type=linear,  $
      signals = 'R2:190.B3F:N2O', $
      molecules = [o3, n2o, hno3],  $
      moleculeDerivatives=[o3, n2o, hno3], /atmos_der, phiWindow=5
    outFwm3: forwardModel, type=linear,  $
      signals = 'R2:190.B3F:N2O', $
      molecules = [o3, n2o, hno3], phiWindow=5

    sidsFwm4: forwardModel, type=linear,  $
      signals = 'R2:190.B4F:HNO3', $
      molecules = [o3, n2o, hno3], phiWindow=5
    retFwm4: forwardModel, type=linear,  $
      signals = 'R2:190.B4F:HNO3', $
      molecules = [o3, n2o, hno3],  $
      moleculeDerivatives=[o3, n2o, hno3], /atmos_der, phiWindow=5
    outFwm4: forwardModel, type=linear,  $
      signals = 'R2:190.B4F:HNO3', $
      molecules = [o3, n2o, hno3], phiWindow=5

    sidsFwm6: forwardModel, type=linear,  $
      signals = 'R2:190.B6F:O3', $
      molecules = [o3], phiWindow=5
    retFwm6: forwardModel, type=linear,  $
      signals = 'R2:190.B6F:O3', $
      molecules = [o3],  $
      moleculeDerivatives=[o3], /atmos_der, phiWindow=5
    outFwm6: forwardModel, type=linear,  $
      signals = 'R2:190.B6F:O3', $
      molecules = [o3], phiWindow=5

END GlobalSettings

; ------------------------------------------ Chunk divide  ----
BEGIN ChunkDivide
;     IgnoreL1B= true
;     IdealLength=5 MAFs
;     NoChunks = 4
    IdealLength =             0.125 orbits
    overlap =                 0 MAFs
    HomeGeodAngle =           0 degrees
    HomeModule =              GHz
    ScanLowerLimit =          -10 km : 20 km
    ScanUpperLimit =          40 km : 100 km
    CriticalScanningModules = Both
    MaxGap =                  3 minutes
END ChunkDivide

; ------------------------------------------- Construct sections --
BEGIN Construct

    hGridStandard: hGrid, type=height, height=15km, module=GHz

END Construct

l2cfinc(constructstandardspecies.l2cf)
l2cfinc(constructunfoldedradiances.l2cf)

BEGIN Construct
    stateTemplate: VectorTemplate, quantities=  $
      [ o3, n2o, hno3 ]

    extraStateTemplate: VectorTemplate, quantities =  $
      [ temp, h2o, refGPH, ptanGHz, tngtGeocAltGHz, band3Ratio, band4Ratio, band6Ratio ]

    measTemplate: VectorTemplate, quantities= $
      [ band3, band4, band6 ]
END Construct

; ------------------------------------------- Fill -----------------

BEGIN Fill

    ;; Define the vectors
    x: Vector, template=stateTemplate ; State
    a: Vector, template=stateTemplate ; A priori
    sdIn: Vector, template=stateTemplate ; A priori standard deviation
    sdOut: Vector, template=stateTemplate ; Solution standard deviation
    t: Vector, template=stateTemplate ; Truth

    b: Vector, template=extraStateTemplate ; Extra state
    y: Vector, template=measTemplate ; Radiances
    ya: Vector, template=measTemplate ; Radiances for a priori state
    f: Vector, template=measTemplate ; Forward model radiances
    yNoise: Vector, template=measTemplate ; Radiance noise

    ;; Define the matrix
    K: Matrix, rows=y, columns=x

    ;; Fill t with the `truth'
    Fill, quantity=t.o3,    method=l2gp, sourceL2GP=l2gpO3Input, /interpolate
    Fill, quantity=t.n2o,   method=l2gp, sourceL2GP=l2gpN2OInput, /interpolate
    Fill, quantity=t.hno3,  method=l2gp, sourceL2GP=l2gpHNO3Input, /interpolate
    
    ;; Fill a and x with a apriori
    Fill, quantity=a.o3,      method=gridded, sourceGrid=gridO3, /interpolate
    Fill, quantity=a.n2o,     method=gridded, sourceGrid=gridN2O, /interpolate
    Fill, quantity=a.hno3,    method=gridded, sourceGrid=gridHNO3, /interpolate

    Fill, quantity=x.o3,      method=gridded, sourceGrid=gridO3, /interpolate
    Fill, quantity=x.n2o,     method=gridded, sourceGrid=gridN2O, /interpolate
    Fill, quantity=x.hno3,    method=gridded, sourceGrid=gridHNO3, /interpolate

    ;; Now fill the remaining state quantities
    Fill, quantity=b.temp,   method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
    Fill, quantity=b.h2o,     method=l2gp, sourceL2GP=l2gpH2OInput, /interpolate
    Fill, quantity=b.refGPH, method=explicit,explicitvalues=16km,/spread ; FIX LATER!!!

    Fill, quantity=b.tngtGeocAltGHz, method=l1b

    ;; Now the two tangent presssures
    Fill, quantity=b.ptanGHz, method=hydrostatic, $
      h2oQuantity=b.h2o, $
      temperatureQuantity=b.temp, $
      refGPHQuantity=b.refGPH, $
      geocAltitudeQuantity=b.tngtGeocAltGHz, $
      maxIterations=10

    ;; Now the sideband ratios
    Fill, quantity = b.band3Ratio, method=explicit,  $
      explicitValues = [ 0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5] 
    Fill, quantity = b.band4Ratio, method=explicit,  $
      explicitValues = [ 0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5] 
    Fill, quantity = b.band6Ratio, method=explicit,  $
      explicitValues = [ 0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5, $
                         0.5, 0.5, 0.5, 0.5, 0.5] 

    ;; Define matrices
    ;; myJacobian: matrix, rows=radiance, columns=state
    myCovariance: matrix, columns=x, type=spd, /extra

    Fill, quantity=sdIn.o3, method=explicit, explicitValues= 5 ppmv, /spread
    Fill, quantity=sdIn.n2o, method=explicit, explicitValues= 200 ppbv, /spread
    Fill, quantity=sdIn.hno3, method=explicit, explicitValues= 20 ppbv, /spread
    fillCovariance, matrix=myCovariance, diagonal=sdIn, /invert

END Fill


; ------------------------------------------------------- Sids -----

BEGIN Retrieve

   sids, fwdModelIn=t, fwdModelExtra=b, fwdModelOut=y,$
     forwardModel=[sidsFwm3, sidsFwm4, sidsFwm6]
   sids, fwdModelIn=a, fwdModelExtra=b, fwdModelOut=ya,$
     forwardModel=[outFwm3, outFwm4, sidsFwm6]

END Retrieve

; ------------------------------------------------- Fill, noise -----

BEGIN Fill

    Fill, quantity=yNoise.band3, radianceQuantity=y.band3,  $
      systemTemperature= 2000K, integrationTime=0.16 s,  $
      method = estimatedNoise
    Fill, quantity=yNoise.band4, radianceQuantity=y.band4,  $
      systemTemperature= 2000K, integrationTime=0.16 s,  $
      method = estimatedNoise
    Fill, quantity=yNoise.band6, radianceQuantity=y.band6,  $
      systemTemperature= 2000K, integrationTime=0.16 s,  $
      method = estimatedNoise

END Fill

; ------------------------------------------------------- Retrieve -----

BEGIN Retrieve

  time
  Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
    forwardModel=[retFwm3, retFwm4, retFwm6], $
    covariance=myCovariance, apriori=a, columnScale=norm, $
    maxF=2, maxJ=1, lambda=0.0,outputSD=sdOut

END Retrieve

BEGIN Retrieve

  sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
     forwardModel=[outFwm3, outFwm4, outFwm6]

END Retrieve


; ------------------------------------------------------- Join -----

BEGIN Join
    l2gpTemp: l2gp, source=b.temp, swath = 'Temperature'

    l2gpO3x:  l2gp, source=x.o3, swath = 'O3', precision=sdOut.o3
    l2gpO3a:  l2gp, source=a.o3, swath = 'O3', precision=sdIn.o3
    l2gpO3t:  l2gp, source=t.o3,  swath = 'O3'

    l2gpN2Ox:  l2gp, source=x.n2o, swath = 'N2O', precision=sdOut.n2o
    l2gpN2Oa:  l2gp, source=a.n2o, swath = 'N2O', precision=sdIn.n2o
    l2gpN2Ot:  l2gp, source=t.n2o,  swath = 'N2O'

    l2gpHNO3x:  l2gp, source=x.hno3, swath = 'HNO3', precision=sdOut.hno3
    l2gpHNO3a:  l2gp, source=a.hno3, swath = 'HNO3', precision=sdIn.hno3
    l2gpHNO3t:  l2gp, source=t.hno3,  swath = 'HNO3'

    measRadb3L2AUX: l2aux, source=y.band3, /prefixSignal, sdName=''
    measNoiseb3L2AUX: l2aux, source=yNoise.band3, /prefixSignal, sdName=' precision'
    aprioriRadb3L2AUX: l2aux, source=ya.band3, /prefixSignal, sdName=' apr'
    fitRadb3L2AUX: l2aux, source=f.band3, /prefixSignal, sdName=' fit'

    measRadb4L2AUX: l2aux, source=y.band4, /prefixSignal, sdName=''
    measNoiseb4L2AUX: l2aux, source=yNoise.band4, /prefixSignal, sdName=' precision'
    aprioriRadb4L2AUX: l2aux, source=ya.band4, /prefixSignal, sdName=' apr'
    fitRadb4L2AUX: l2aux, source=f.band4, /prefixSignal, sdName=' fit'

    measRadb6L2AUX: l2aux, source=y.band6, /prefixSignal, sdName=''
    measNoiseb6L2AUX: l2aux, source=yNoise.band6, /prefixSignal, sdName=' precision'
    aprioriRadb6L2AUX: l2aux, source=ya.band6, /prefixSignal, sdName=' apr'
    fitRadb6L2AUX: l2aux, source=f.band6, /prefixSignal, sdName=' fit'

    ptanGHzL2AUX: l2aux, source=b.ptanGHz
END Join


; ---------------------------------------------------------  Output  -----
BEGIN Output
    
    output, file='{}_outpath{}temp.l2gp', quantities=l2gpTemp, type=l2gp

    output, file='{}_outpath{}o3_x.l2gp', quantities=l2gpO3x, type=l2gp
    output, file='{}_outpath{}o3_a.l2gp', quantities=l2gpO3a, type=l2gp
    output, file='{}_outpath{}o3_t.l2gp', quantities=l2gpO3t, type=l2gp

    output, file='{}_outpath{}n2o_x.l2gp', quantities=l2gpN2Ox, type=l2gp
    output, file='{}_outpath{}n2o_a.l2gp', quantities=l2gpN2Oa, type=l2gp
    output, file='{}_outpath{}n2o_t.l2gp', quantities=l2gpN2Ot, type=l2gp

    output, file='{}_outpath{}hno3_x.l2gp', quantities=l2gpHNO3x, type=l2gp
    output, file='{}_outpath{}hno3_a.l2gp', quantities=l2gpHNO3a, type=l2gp
    output, file='{}_outpath{}hno3_t.l2gp', quantities=l2gpHNO3t, type=l2gp

    output, type=l2aux,  $
      file='{}_outpath{}data.l2aux', quantities=  $
      [ ptanGHzL2AUX,  $
        measRadb6L2Aux, fitRadb6L2Aux, measNoiseb6L2AUX, aprioriRadb6L2AUX, $
        measRadb3L2Aux, fitRadb3L2Aux, measNoiseb3L2AUX, aprioriRadb3L2AUX, $
        measRadb4L2Aux, fitRadb4L2Aux, measNoiseb4L2AUX, aprioriRadb4L2AUX ]

END Output
