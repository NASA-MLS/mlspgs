; This l2cf is an attempt to make a universal l2cf for doing sids runs
; This is a simple l2cf for testing purposes. Mainly for testing the
; M4 stuff.  The band number to do is passed in as _band, the date as
; !day.

; First some m4 directives.
include(m4defs.l2cf)

!define(outpath,/bigdata/livesey/misc/)
!define(ver,v0-5-test1)
!define(day,1996-051)

!define(signal,!sigBand$1)
!define(molecules,!mol$1)
!define(systemp, !systemp$1)

; Now include the valid signals database
!include(validsignals-emls.l2cf)

; Now the spectroscopy database
!include(spectroscopy.l2cf)

; Now read the l2gp files for each specie
!include(readl2gpfiles.l2cf)

; Now read the gridded data for each specie
!include(readclimatology.l2cf)

; -------------------------------------------- Global settings ----
begin GlobalSettings

  l1Boa, file='!data/emls/l1boa/truth/!year(!day)/MLS-Aura_L1BOA_Full_s4-t_!day.dat'
  startTime = "00:00:00"
  endTime = "00:05:00"

  vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic, $
    start=1000mb, formula=[25:12, 24:6]
  vGridBaseline: vGrid, coordinate=Zeta, type=Logarithmic, $
    start=1000mb, formula=[37:6]

  vGridRefGPH: vGrid, coordinate=Zeta, type=Explicit, values=100mb


  forwardModelGlobal, $
    l2pc='/bigdata/livesey/misc/l2pc_band1L_v1.0.dat'

  sidsFwm: forwardModel, type=linear,  $
    signals = 'R1A:118.B1LF:PT', /do_baseline
  retFwm: forwardModel, type=linear,  $
    signals = 'R1A:118.B1LF:PT', /temp_der, /do_baseline
  scanFwm: forwardModel, type=scan, module=GHz

end GlobalSettings

; ------------------------------------------ Chunk divide  ----
!include(chunkdivide1.l2cf)

; ------------------------------------------- Construct sections --
begin Construct
  hGridStandard: hGrid, type=height, height=15km, module=GHz
end Construct

!include(constructstandardspecies.l2cf)
!include(constructunfoldedradiances.l2cf)

begin Construct

  stateTemplate: VectorTemplate, quantities=  $
    [ refGPH, ptanGHz, temp, baselineR1A ]
  
  extraStateTemplate: VectorTemplate, quantities =  $
    [ tngtGeocAltGHz, h2o ]
  
  measTemplate: VectorTemplate, quantities= $
    [ band1L, scanResidualGHz ]
end Construct

; ------------------------------------------- Fill -----------------

begin Fill

  !define( truthGPH, 15.8km )
  
  ;; Define the vectors
  x: Vector, template=stateTemplate ; State
  a: Vector, template=stateTemplate ; A priori
  sdIn: Vector, template=stateTemplate ; A priori standard deviation
  sdOut: Vector, template=stateTemplate ; Solution standard deviation
  t: Vector, template=stateTemplate ; Truth
  
  b: Vector, template=extraStateTemplate ; Extra state
  y: Vector, template=measTemplate ; Radiances
  ya: Vector, template=measTemplate ; Radiances for a priori state
  f: Vector, template=measTemplate ; Forward model radiances
  yNoise: Vector, template=measTemplate ; Radiance noise
  
  ;; Define the matrix
  K: Matrix, rows=y, columns=x
  
  ;; Fill t with the `truth'
  Fill, quantity=t.temp,    method=l2gp, sourceL2GP=l2gpTEMPInput, /interpolate
  Fill, quantity=t.refGPH,  method=explicit, explicitValues=!truthGPH, /spread
  
  ;; Fill a and x with a apriori
  Fill, quantity=a.temp, method=gridded, sourceGrid=gridTemperature
  Fill, quantity=x.temp, method=gridded, sourceGrid=gridTemperature
  Fill, quantity=a.refGPH, method=explicit, explicitvalues=16km,/spread
  Fill, quantity=x.refGPH, method=explicit, explicitvalues=16km,/spread
  Fill, quantity=a.baselineR1A, method=explicit, explicitvalues=0K,/spread
  Fill, quantity=x.baselineR1A, method=explicit, explicitvalues=0K,/spread
  
;   ;; OR can use truth
;   Fill, quantity=a.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;   Fill, quantity=x.temp, method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
;   Fill, quantity=a.refGPH, method=explicit, explicitvalues=!truthGPH,/spread
;   Fill, quantity=x.refGPH, method=explicit, explicitvalues=!truthGPH,/spread
;   Fill, quantity=a.baselineR1A, method=explicit, explicitvalues=0K,/spread
;   Fill, quantity=x.baselineR1A, method=explicit, explicitvalues=0K,/spread
  
  ;; Now fill the remaining state quantities
  Fill, quantity=b.h2o, method=gridded, sourceGrid=gridH2O, /interpolate
  Fill, quantity=b.tngtGeocAltGHz, method=l1b
  
  ;; Now the tangent presssures
  Fill, quantity=t.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=t.temp, $
    refGPHQuantity=t.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  
  ;; Fill x and a from a priori
  Fill, quantity=x.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=a.temp, $
    refGPHQuantity=a.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  Fill, quantity=a.ptanGHz, method=hydrostatic, $
    h2oQuantity=b.h2o, $
    temperatureQuantity=a.temp, $
    refGPHQuantity=a.refGPH, $
    geocAltitudeQuantity=b.tngtGeocAltGHz, $
    maxIterations=10
  
;   ;; Or can use truth
;   Fill, quantity=x.ptanGHz, method=hydrostatic, $
;     h2oQuantity=b.h2o, $
;     temperatureQuantity=t.temp, $
;     refGPHQuantity=t.refGPH, $
;     geocAltitudeQuantity=b.tngtGeocAltGHz, $
;     maxIterations=10
;   Fill, quantity=a.ptanGHz, method=hydrostatic, $
;     h2oQuantity=b.h2o, $
;     temperatureQuantity=t.temp, $
;     refGPHQuantity=t.refGPH, $
;     geocAltitudeQuantity=b.tngtGeocAltGHz, $
;     maxIterations=10
  
  ;; Define matrices
  ;; myJacobian: matrix, rows=radiance, columns=state
  myCovariance: matrix, columns=x, type=spd
  
  Fill, quantity=sdIn.temp, method=explicit, explicitValues=20 K, /spread
  Fill, quantity=sdIn.refGPH, method=explicit, explicitValues= 5 km, /spread
  Fill, quantity=sdIn.ptanGHz, method=explicit, explicitValues= 0.2, /spread
  Fill, quantity=sdIn.baselineR1A, method=explicit, explicitValues= 5 K, /spread
  FillCovariance, matrix=myCovariance, diagonal=sdIn, /invert
end Fill

; ------------------------------------------------------- Sids -----

begin Retrieve
  Sids, fwdModelIn=t, fwdModelExtra=b, fwdModelOut=y,$
    forwardModel=[sidsFwm]
  Sids, fwdModelIn=a, fwdModelExtra=b, fwdModelOut=ya,$
    forwardModel=[sidsFwm]
end Retrieve

; ------------------------------------------------- Fill, noise -----

begin Fill
  Fill, quantity=yNoise.band1L, radianceQuantity=y.band1L,  $
    systemTemperature= 1500K, integrationTime=0.16 s,  $
    method = estimatedNoise
  Fill, quantity=yNoise.scanResidualGHz, method=explicit,  $
    explicitValues = 10 m ,/spread
  Snoop, comment='Before retrieval'
end Fill

; ------------------------------------------------------- Retrieve -----

begin Retrieve
;  Snoop, comment='Only retrieval'
  ;; Subset, quantity=x.temp, height= [ 100mb: 0.1mb ]
  Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
    forwardModel= [ retFwm, scanFwm ], $
    covariance=myCovariance, apriori=a, columnScale=none, $
    maxF=200, maxJ=100, lambda=10.0, outputSD=SDout
  Sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
     forwardModel=[sidsFwm]
  Sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
    forwardModel=[scanFwm]
end Retrieve

begin Fill
   Snoop, comment='After retrieval'
end Fill

; ------------------------------------------------------- Join -----

begin Join
  l2gpTx: l2gp, source=x.temp, swath = 'Temperature', precision=sdOut.temp
  l2gpTa: l2gp, source=a.temp, swath = 'Temperature', precision=sdIn.temp
  l2gpTt: l2gp, source=t.temp,  swath = 'Temperature'
  l2gpHx: l2gp, source=x.refGPH, swath = 'refGPH', precision=sdOut.refGPH
  l2gpHa: l2gp, source=a.refGPH, swath = 'refGPH', precision=sdIn.refGPH
  l2gpHt: l2gp, source=t.refGPH,  swath = 'refGPH'
  
  ptanXl2aux: l2aux, source=x.ptanGHz,sdName='ptanGHzX'
  ptanAl2aux: l2aux, source=a.ptanGHz,sdName='ptanGHzA'
  ptanTl2aux: l2aux, source=t.ptanGHz,sdName='ptanGHzT'
  ptanASl2aux: l2aux, source=sdIn.ptanGHz,sdName='ptanGHzA precision'
  ptanXSl2aux: l2aux, source=sdOut.ptanGHz,sdName='ptanGHzX precision'
  
  measRadL2AUX: l2aux, source=y.band1L, /prefixSignal, sdName=''
  measNoiseL2AUX: l2aux, source=yNoise.band1L, /prefixSignal, sdName=' precision'
  aprioriRadL2AUX: l2aux, source=ya.band1L, /prefixSignal, sdName=' apr'
  fitRadL2AUX: l2aux, source=f.band1L, /prefixSignal, sdName=' fit'
end Join


; ---------------------------------------------------------  Output  -----
begin Output
    
  Output, file='!outpath/temp_x.l2gp', quantities=l2gpTx, type=l2gp
  Output, file='!outpath/temp_a.l2gp', quantities=l2gpTa, type=l2gp
  Output, file='!outpath/temp_t.l2gp', quantities=l2gpTt, type=l2gp
  Output, file='!outpath/refGPH_x.l2gp', quantities=l2gpHx, type=l2gp
  Output, file='!outpath/refGPH_a.l2gp', quantities=l2gpHa, type=l2gp
  Output, file='!outpath/refGPH_t.l2gp', quantities=l2gpHt, type=l2gp
  
  Output, file='!outpath/data.l2aux', quantities= $
    [ ptanXl2aux, ptanAl2aux, ptanTl2aux, ptanASl2aux, ptanXSl2aux, $
    measRadL2aux, measNoiseL2AUX, aprioriRadL2AUX, fitRadL2AUX ], type=l2aux

end Output




