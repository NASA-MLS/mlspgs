; This l2cf is an attempt to make a universal l2cf for doing sids runs
; This is a simple l2cf for testing purposes. Mainly for testing the
; M4 stuff.  The band number to do is passed in as _band, the date as
; _day.

; First some m4 directives.
include(m4defs.l2cf)

!define(outpath,/bigdata/livesey/misc/)
!define(ver,v0-5-test1)
!define(day,1996-051)
!define(year,1996)

!define(signal,!sigBand$1)
!define(molecules,!mol$1)
!define(systemp, !systemp$1)

; Now include the valid signals database
!include(validsignals-emls.l2cf)

; Now the spectroscopy database
!include(spectroscopy.l2cf)

; Now read the l2gp files for each specie
!include(readl2gpfiles.l2cf)

; Now read the gridded data for each specie
!include(readclimatology.l2cf)

; -------------------------------------------- Global settings ----
BEGIN GlobalSettings

    l1Boa, file='!data/emls/l1boa/truth/!year(!day)/MLS-Aura_L1BOA_Full_s4-t_!day.dat'
    startTime = "00:00:00"
    endTime = "01:00:00"

    vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic, $
      start=1000mb, formula=[37:6]
    vGridBaseline: vGrid, coordinate=Zeta, type=Logarithmic, $
      start=1000mb, formula=[37:6]

    vGridRefGPH: vGrid, coordinate=Zeta, type=Explicit, values=100mb

    forwardModelGlobal, $
      l2pc='/bigdata/livesey/misc/l2pc_band6U_v1.0-lowres.dat'

    sidsFwm: forwardModel, type=linear,  $
      signals = 'R2:190.B6UF:O3', $
      molecules = o3, phiWindow=5, /do_baseline
    retFwm: forwardModel, type=linear,  $
      signals = 'R2:190.B6UF:O3', /do_baseline, $
      molecules = o3, moleculeDerivatives=o3, /atmos_der, phiWindow=5
    outFwm: forwardModel, type=linear, /do_baseline, $
      signals = 'R2:190.B6UF:O3', $
      molecules = o3, phiWindow=5

END GlobalSettings

; ------------------------------------------ Chunk divide  ----
BEGIN ChunkDivide
    NoChunks=1
    IgnoreL1B=true
    IdealLength =             10 MAFs
    overlap =                 0 MAFs
    HomeGeodAngle =           0 degrees
    HomeModule =              GHz
    ScanLowerLimit =          -10 km : 20 km
    ScanUpperLimit =          40 km : 100 km
    CriticalScanningModules = Both
    MaxGap =                  3 minutes
END ChunkDivide

; ------------------------------------------- Construct sections --
BEGIN Construct

    hGridStandard: hGrid, type=height, height=15km, module=GHz

END Construct

!include(constructstandardspecies.l2cf)
!include(constructunfoldedradiances.l2cf)

BEGIN Construct
  stateTemplate: VectorTemplate, quantities=  $
    [ o3, baselineR2 ]
  
  extraStateTemplate: VectorTemplate, quantities =  $
    [ temp, refGPH, ptanGHz, tngtGeocAltGHz, h2o ]
  
  measTemplate: VectorTemplate, quantities= $
    [ band6U ]
END Construct

; ------------------------------------------- Fill -----------------

BEGIN Fill

    ;; Define the vectors
    x: Vector, template=stateTemplate ; State
    a: Vector, template=stateTemplate ; A priori
    sdIn: Vector, template=stateTemplate ; A priori standard deviation
    sdOut: Vector, template=stateTemplate ; Solution standard deviation
    t: Vector, template=stateTemplate ; Truth

    b: Vector, template=extraStateTemplate ; Extra state
    y: Vector, template=measTemplate ; Radiances with noise
    ya: Vector, template=measTemplate ; Radiances for a priori state
    f: Vector, template=measTemplate ; Forward model radiances
    yNoise: Vector, template=measTemplate ; Radiance noise

    ;; Define the matrix
    K: Matrix, rows=y, columns=x

    ;; Fill t with the `truth'
    Fill, quantity=t.o3,    method=l2gp, sourceL2GP=l2gpO3Input, /interpolate
    Fill, quantity=t.baselineR2, method=explicit, explicitValues=0K, /spread
    
    ;; Fill a and x with a apriori
    Fill, quantity=a.o3,    method=gridded, sourceGrid=gridO3, /interpolate
    Fill, quantity=x.o3,    method=gridded, sourceGrid=gridO3, /interpolate
    Fill, quantity=a.baselineR2, method=explicit, explicitValues=0K, /spread
    Fill, quantity=x.baselineR2, method=explicit, explicitValues=0K, /spread

; OR can use truth
;      Fill, quantity=a.o3,    method=l2gp, sourceL2GP=l2gpO3Input, /interpolate
;      Fill, quantity=x.o3,    method=l2gp, sourceL2GP=l2gpO3Input, /interpolate
;      Fill, quantity=a.baselineR2, method=explicit, explicitValues=0K, /spread
;      Fill, quantity=x.baselineR2, method=explicit, explicitValues=0K, /spread

    ;; Now fill the remaining state quantities
    Fill, quantity=b.temp,   method=l2gp, sourceL2GP=l2gpTempInput, /interpolate
    Fill, quantity=b.refGPH, method=explicit,explicitvalues=16km,/spread ; FIX LATER!!!
    Fill, quantity=b.h2o,    method=gridded, sourceGrid=gridH2O, /interpolate

    Fill, quantity=b.tngtGeocAltGHz, method=l1b

;    Fill, quantity=b.baselineR2, method=explicit, explicitValues=100K,/spread

    ;; Now the two tangent presssures
    Fill, quantity=b.ptanGHz, method=hydrostatic, $
      h2oQuantity=b.h2o, $
      temperatureQuantity=b.temp, $
      refGPHQuantity=b.refGPH, $
      geocAltitudeQuantity=b.tngtGeocAltGHz, $
      maxIterations=10

    ;; Define matrices
    ;; myJacobian: matrix, rows=radiance, columns=state
    myCovariance: matrix, columns=x, type=spd

    Fill, quantity=sdIn.o3, method=explicit, explicitValues= 5 ppmv, /spread
    Fill, quantity=sdIn.baselineR2, method=explicit, explicitValues=500K, /spread
    fillCovariance, matrix=myCovariance, diagonal=sdIn, /invert

    Snoop, comment='At the end of first fill'

END Fill

; ------------------------------------------------------- Sids -----

BEGIN Retrieve

   time
   sids, fwdModelIn=t, fwdModelExtra=b, fwdModelOut=y,$
     forwardModel=[sidsFwm]
   sids, fwdModelIn=a, fwdModelExtra=b, fwdModelOut=ya,$
     forwardModel=[outFwm]

END Retrieve

; ------------------------------------------------- Fill, noise -----

BEGIN Fill

    Fill, quantity=yNoise.band6U, radianceQuantity=y.band6U,  $
      systemTemperature= 2000K, integrationTime=0.16 s,  $
      method = estimatedNoise

    Snoop, comment='Got the radiances'

END Fill

; ------------------------------------------------------- Retrieve -----

BEGIN Retrieve

;  Snoop, comment='In retrieve!'
   Subset, quantity=x.o3, height= [ 400mb : 0.1mb ]
   Subset, quantity=y.band6U, ptanQuantity=b.ptanGHz, height=[420mb:0.06mb]
;   Subset, quantity=y.band6U, channels=[1:25], /ignore
  Subset,quantity=y.band6U, channels=[1:5, 21:25], /ignore
  Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
    forwardModel=retFwm, $
    covariance=myCovariance, apriori=a, columnScale=none, $
    maxF=2, maxJ=1, lambda=0.0,outputSD=sdOut
  sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=f,$
    forwardModel=[outFwm]
  
END Retrieve

BEGIN Fill
  Snoop, comment='Done the retrieval'
END Fill

; ------------------------------------------------------- Join -----

BEGIN Join
    l2gpTemp: l2gp, source=b.temp, swath = 'Temperature'
    l2gpO3x:  l2gp, source=x.o3, swath = 'O3', precision=sdOut.o3
    l2gpO3a:  l2gp, source=a.o3, swath = 'O3', precision=sdIn.o3
    l2gpO3t:  l2gp, source=t.o3,  swath = 'O3'

    measRadL2AUX: l2aux, source=y.band6U, /prefixSignal, sdName=''
    measNoiseL2AUX: l2aux, source=yNoise.band6U, /prefixSignal, sdName=' precision'
    aprioriRadL2AUX: l2aux, source=ya.band6U, /prefixSignal, sdName=' apr'
    fitRadL2AUX: l2aux, source=f.band6U, /prefixSignal, sdName=' fit'
    ptanGHzL2AUX: l2aux, source=b.ptanGHz
END Join


; ---------------------------------------------------------  Output  -----
BEGIN Output
    
    output, file='!outpath/temp.l2gp', quantities=l2gpTemp, type=l2gp
    output, file='!outpath/o3_x.l2gp', quantities=l2gpO3x, type=l2gp
    output, file='!outpath/o3_a.l2gp', quantities=l2gpO3a, type=l2gp
    output, file='!outpath/o3_t.l2gp', quantities=l2gpO3t, type=l2gp
                  
    output, file='!outpath/data.l2aux', quantities=  $
      [ ptanGHzL2AUX, measRadL2Aux, fitRadL2Aux, measNoiseL2AUX, aprioriRadL2AUX ], type=l2aux

END Output
