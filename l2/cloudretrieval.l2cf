; =====================================================================
; This l2cf manages Full Cloud Forward Model sids runs
; ---------------------------------------------------------------------
; -July 16, 2001, first working version
; -Added FOV option Aug 20, 2001
; J.Jiang
; =====================================================================
include(m4defs.l2cf)

!ifdef(band, ,!define(band,{12U}))
!define(outpath,/nas/bigdata/dwu/emls/cloud_large/)
!define(ver,v0-5-test1)
!define(day,1996-051)
!define(signal,sigBand$1)
!define(molecules,mol$1)
!define(systemp, systemp$1)

;-----------------------------------
; Standard Include files
;-----------------------------------
; m4 directives.

; Now include the valid signals database
!include(validsignals-emls.l2cf)

; Now define the signals for each band
!include(signalsforband.l2cf)

; spectroscopy database
!include(spectroscopy.l2cf)

; Now the list of which lines apply for which bands
!include(moleculesperband.l2cf)

; read the l2gp files for each specie
BEGIN ReadApriori
    l2gpTempInput: l2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/MLS-Aura_L2GP_T_s4a-t_{}!day{}.dat'
    l2gpGPHInput: l2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/MLS-Aura_L2GP_GPH_s4a-t_{}!day{}.dat'
    l2gpH2OInput: l2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/Mask_MLS-Aura_L2GP_H2O_s4d-t_{}!day{}.dat'
    l2gpO3Input: l2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/MLS-Aura_L2GP_O3_s4-t_{}!day{}.dat'
    CloudIceInput: L2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/NoRandomMLS-Aura_L2GP_IWC_s4d-t_{}!day{}.dat'
    SizeDisInput:  L2gp, $
      file='/nas/bigdata/jonathan/emls/input/forCLDret/MLS-Aura_L2GP_PSD_s4d-t_{}!day{}.dat'
END ReadApriori

; read the gridded data for each specie
;!include(readclimatology.l2cf)

; --------------------------------- Global Settings ----------------------------------
; Forward Model Global Setup
;-------------------------------------------------------------------------------------

BEGIN GlobalSettings

    l1Boa, $
      file='/nas/data/emls/l1boa/truth/!year(!day)/MLS-Aura_L1BOA_Full_s4-t_!day.dat'

;    startTime = "00:20:00"
;    endTime   = "00:40:00"
    startTime = "00:00:00"
    endTime   = "12:00:00"

    vGridCloud: vGrid, coordinate=Zeta, type=Logarithmic,             $
                     start=1000mb, formula=[15:12]
    vGridStandard: vGrid, coordinate=Zeta, type=Logarithmic,             $
                     start=1000mb, formula=[72:12]
    vGridBaseline: vGrid, coordinate=Zeta, type=Logarithmic,             $
                     start=1000mb, formula=[72:12]

    vGridRefGPH:   vGrid, coordinate=Zeta, type=Explicit, values= 100mb

; sGrid use values in km
    sGrid1: vGrid, type=Explicit,                                        $
       values=[20,40,60,80,100,120,140,160,180,200,$
               220,240,260,280,300,320,340,360,380,400,420,440,460,480,500,$
               520,540,560,580,600,620,640,660,680,700,720,740,760,780,800]
;       values=[20,40,60,80,100,120,140,160,180,200,$
;               220,240,260,280,300,320,340,360,380,400,420,440,460,480,500]

    forwardModelGlobal,                                                  $
      antennaPatterns='/bigdata/jonathan/emls/input/aaap_emls_sids_v03.dat'

;-----------------------------------------------------------------------------------
; This is the call to Full Cloud Forward Model
;-----------------------------------------------------------------------------------
    cldFwm1: ForwardModel, type= CloudFull,  $
      signals          = [$
            'R2:190.B2LF:H2O.C13:25',   $
            'R2:190.B3LF:N2O.C25',  $
            'R2:190.B4LF:HNO3.C25',  $
            'R2:190.B5LF:CLO.C1',  $
            'R2:190.B5LF:CLO.C25',  $
            'R2:190.B6LF:O3.C1',  $
            'R2:190.B6LF:O3.C25',$
            'R3:240.B33LW:O3.C3',$
            'R2:190.B2UF:H2O.C13' ],$
      molecules        = [ h2o, o3 ],        $
      ncloudspecies    = 2,                  $
      nmodelsurfs      = 640,                $
      NSCATTERINGANGLES= 16,                 $
      NAZIMUTHANGLES   = 8,                  $
      NABTERMS         = 50,                 $
      NSIZEBINS        = 40,                 $
      cloud_der        = 1,                  $
      cloud_width      = 1,                  $        
      cloud_fov        = 0                   ; 1=with FOV, 0=without FOV

END GlobalSettings

; --------------------------------- Chunk divide -----------------------------------

BEGIN ChunkDivide
    IdealLength             = 0.125 orbits
    overlap                 = 2 MAFs
    HomeGeodAngle           = 0 degrees
    HomeModule              = GHz
    ScanLowerLimit          = -10 km : 20 km
    ScanUpperLimit          = 40 km : 100 km
    CriticalScanningModules = Both
    MaxGap                  = 3 minutes
END ChunkDivide

; ------------------------------ Construct sections --------------------------------

BEGIN Construct

  hGridStandard: hGrid, type=height, height=15km, module=GHz
  hGridFine: hGrid, type=height, height=0km, module=GHz, interpolationFactor=4.

;-----------------------------------------------------
; Construct quantities for cloud forward model inputs
;-----------------------------------------------------
   scGeocAlt: Quantity, type = scGeocAlt, module= SC
   tngtGeocAltGHz: Quantity, type=tngtGeocAlt, module=GHz
   tngtGeocAltTHz: Quantity, type=tngtGeocAlt, module=THz
   temp: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=temperature
   refGPH: Quantity, vGrid=vGridRefGPH, hGrid=hGridStandard, type=refGPH
   h2o: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=vmr,molecule=h2o
   o3: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type=vmr,molecule=o3
      
ptan:            Quantity, type = ptan, module=GHz
gph:             Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type = gph
CloudIce:        Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type = CloudIce
sizeDistribution:Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type = sizeDistribution

cloudWater:      Quantity, vGrid=vGridStandard, hGrid=hGridStandard, type = CloudWater
earthradius:     Quantity, hGrid=hGridStandard, type = earthradius 
surfaceType:     Quantity, hGrid=hGridStandard, type = surfaceType
elevOffsetR3:      Quantity, type = elevOffset, Radiometer = R3
elevOffsetR2:      Quantity, type = elevOffset, Radiometer = R2

;------------------------------------------------------
; Construct quantities for cloud forward model outputs
;------------------------------------------------------  
    cext_losTrans:  Quantity, type=losTransFunc, Sgrid=sGrid1, module=GHz
    cext_high_zt:   Quantity, vGrid=vGridcloud, hGrid=hGridStandard, $
                                 type = cloudExtinction
    cext_low_zt:   Quantity, vGrid=vGridcloud, hGrid=hGridFine, $
                                 type = cloudExtinction

TB2:    Quantity, type = radiance, signal = 'R2:190.B2LF:H2O.C13:25'
TcB2:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B2LF:H2O.C13:25'
SB2:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B2LF:H2O.C13:25'

TB3C25:    Quantity, type = radiance, signal = 'R2:190.B3LF:N2O.C25'
TcB3C25:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B3LF:N2O.C25'
SB3C25:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B3LF:N2O.C25'

TB4C25:    Quantity, type = radiance, signal = 'R2:190.B4LF:HNO3.C25'
TcB4C25:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B4LF:HNO3.C25'
SB4C25:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B4LF:HNO3.C25'

TB5C1:    Quantity, type = radiance, signal = 'R2:190.B5LF:CLO.C1'
TcB5C1:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B5LF:CLO.C1'
SB5C1:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B5LF:CLO.C1'

TB5C25:    Quantity, type = radiance, signal = 'R2:190.B5LF:CLO.C25'
TcB5C25:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B5LF:CLO.C25'
SB5C25:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B5LF:CLO.C25'

TB6C1:    Quantity, type = radiance, signal = 'R2:190.B6LF:O3.C1'
TcB6C1:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B6LF:O3.C1'
SB6C1:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B6LF:O3.C1'

TB6C25:    Quantity, type = radiance, signal = 'R2:190.B6LF:O3.C25'
TcB6C25:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B6LF:O3.C25'
SB6C25:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B6LF:O3.C25'

TB33C3:    Quantity, type = radiance, signal = 'R3:240.B33LW:O3.C3'
TcB33C3:  Quantity, type = cloudInducedRadiance,  signal = 'R3:240.B33LW:O3.C3'
SB33C3:  Quantity, type = cloudRADSensitivity,   signal = 'R3:240.B33LW:O3.C3'

TB2U:    Quantity, type = radiance, signal = 'R2:190.B2UF:H2O.C13'
TcB2U:  Quantity, type = cloudInducedRadiance,  signal = 'R2:190.B2UF:H2O.C13'
SB2U:  Quantity, type = cloudRADSensitivity,   signal = 'R2:190.B2UF:H2O.C13'

BetaC203: Quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
                                 type = cloudExtinction

 ;----------------------------
 ; Cloud forward model inputs    
 ;----------------------------

    stateTemplate: VectorTemplate, quantities= [cext_low_zt, cext_losTrans ]

    ModelOutputTemplate: VectorTemplate, quantities= [           $
      TB2, TcB2, SB2, $
      TB3C25, TcB3C25, SB3C25, $
      TB4C25, TcB4C25, SB4C25, $
      TB5C1, TcB5C1, SB5C1, $
      TB5C25, TcB5C25, SB5C25, $
      TB6C1, TcB6C1, SB6C1, $
      TB6C25, TcB6C25, SB6C25, $
      TB33C3, TcB33C3, SB33C3, $
      TB2U, TcB2U, SB2U, $
      BetaC203 ]

    extraStateTemplate: VectorTemplate, quantities =        $
      [ ptan, temp, gph, CloudIce, cloudWater, surfaceType, $
        sizeDistribution, earthradius, h2o, o3, scGeocAlt,  $
        elevOffsetR2, elevOffsetR3 ]

    extraStateTemplate1: VectorTemplate, quantities =       $
      [ refGPH, tngtGeocAltGHz ]

END Construct

; ------------------------------------------- Fill -------------------------

BEGIN Fill

    ;; Define the vectors

    x:      Vector, template=stateTemplate      ; State
    a:      Vector, template=stateTemplate      ; A prior
    sdIn:   Vector, template=stateTemplate         ; A priori standard deviation
    sdOut:  Vector, template=stateTemplate         ; retrieval standard deviation
    y:      Vector, template=ModelOutputTemplate          ; Radiances
    yNoise: Vector, template=ModelOutputTemplate          ; Radiance noise
    b:      Vector, template=extraStateTemplate      ; Extra state
    b1:     Vector, template=extraStateTemplate1     ; Extra state

;    f:      Vector, template=measTemplate            ; Forward model radiances

    ;; Define the matrix
    K: Matrix, rows=y, columns=x

    ;; Fill a and x with a apriori

    Fill, quantity=b.cloudIce,         method=l2gp, sourceL2GP=CloudIceInput, /interpolate
    Fill, quantity=b.sizeDistribution, method=l2gp, sourceL2GP=SizeDisInput, /interpolate
    
    ;; Fill surfacetype with "0" and cloud water with "0"
    Fill, quantity=x.cext_low_zt,  explicitValues = 0, method = explicit, /spread
    Fill, quantity=x.cext_lostrans,  explicitValues = 0, method = explicit, /spread
    Fill, quantity=a.cext_low_zt,  explicitValues = 0, method = explicit, /spread
    Fill, quantity=a.cext_lostrans,  explicitValues = 0, method = explicit, /spread
    
    Fill, quantity=b.surfacetype, explicitValues = 0, method = explicit, /spread
    Fill, quantity=b.cloudWater,  explicitValues = 0, method = explicit, /spread

    FILL, quantity=yNoise.TcB2U, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB2, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB3C25, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB4C25, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB5C1, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB5C25, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB6C1, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB6C25, explicitValues = 3., method  = explicit, /spread
    FILL, quantity=yNoise.TcB33C3, explicitValues = 3., method  = explicit, /spread

    ;; Fill the remaining state quantities
    Fill, quantity=b.temp, method=l2gp,    sourceL2GP=l2gpTempInput,/interpolate
    Fill, quantity=b.gph,  method=l2gp,    sourceL2GP=l2gpGPHInput, /interpolate
    Fill, quantity=b.earthradius, explicitValues = 6370. km, method = explicit, /spread
  
    Fill, quantity=b1.refGPH, method=l2gp, sourceL2GP=l2gpGPHInput, /interpolate
    Fill, quantity=b.h2o, method=l2gp, sourceL2GP=l2gpH2OInput, /interpolate
    Fill, quantity=b.o3, method=l2gp, sourceL2GP=l2gpO3Input, /interpolate
;    Fill, quantity=b.h2o,    method=gridded, sourceGrid=gridH2O, /interpolate
;    Fill, quantity=b.o3,    method=gridded, sourceGrid=gridO3, /interpolate

    Fill, quantity = b.elevOffsetR2, method = explicit, explicitValues = 0 degrees
    Fill, quantity = b.elevOffsetR3, method = explicit, explicitValues = 0 degrees
    Fill, quantity = b.scGeocAlt, method = l1b
    Fill, quantity= b1.tngtGeocAltGHz, method=l1b

    ;; Now the two tangent presssures
    Fill, quantity=b.ptan, method=hydrostatic, $
      h2oQuantity=b.h2o, $
      temperatureQuantity=b.temp, $
      refGPHQuantity=b1.refGPH, $
      geocAltitudeQuantity=b1.tngtGeocAltGHz, $
      maxIterations=10

    ;; Define matrices
     myCovariance: matrix, columns=x, type=spd
     Fill, quantity=sdIn.cext_low_zt, method=explicit, explicitValues= 1., /spread
     Fill, quantity=sdIn.cext_losTrans, method=explicit, explicitValues= 0.07, /spread
     fillCovariance, matrix=myCovariance, diagonal=sdIn,/invert

END Fill

; -----------------------------------Sids ------------------------------------

BEGIN Retrieve
;   time

   sids, fwdModelIn=x, fwdModelExtra=b, fwdModelOut=y,  $
         forwardModel=[cldFwm1]
         
   Retrieve, state=x, fwdModelExtra=b, measurements=y, measurementSD=yNoise, $
      forwardModel=[cldFwm1], method=LowCloud, covariance=myCovariance, $
      apriori=a,maxJ=5, lambda=10.0,outputSD=sdOut
      
END Retrieve

; -----------------------------------Join ------------------------------------
BEGIN Join

    measRad:  l2aux, source=y.tb2u, sdName='TB0' 
    measCLD:  l2aux, source=y.tcB2u, sdName='DTcir'

    ptanGHzL2AUX:  l2aux, source=b.ptan, sdName='ptanGHz'
    transL2AUX:  l2aux, source=x.cext_lostrans, sdName='trans'
    outLosSD:  l2aux, source=sdout.cext_lostrans, sdName='transSD'

    OutputExt: l2gp, source=x.cext_low_zt, swath = 'BETAc'
    OutputExtSD: l2gp, source=sdout.cext_low_zt, swath = 'BETAcSD'
    InputExt:  l2gp, source=y.BetaC203, swath = 'BETAc'
    InputExtSD: l2gp, source=sdin.cext_low_zt, swath = 'BETAcSD'

END Join

; ---------------------------------- Output  -----------------------------------
BEGIN Output

    output, file='!outpath/data.l2aux',quantities=              $
      [ measRad, measCLD, ptanGHzL2AUX,transL2AUX,outLosSD], type=l2aux

    output, file='!outpath/extSD_out.l2gp', quantities=OutputExtSD, type=l2gp
    output, file='!outpath/ext_out.l2gp', quantities=OutputExt, type=l2gp
    output, file='!outpath/ext_in.l2gp', quantities=InputExt, type=l2gp
    output, file='!outpath/extSD_in.l2gp', quantities=InputExtSD, type=l2gp

END Output
