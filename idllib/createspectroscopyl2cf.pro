; $Id$

pro CreateSpectroscopyL2CF, $
  molName=molName, $
  lineName=lineName, $
  crossRefName=crosRefName, $
  instrument=instrument, $
  retrieval=retrieval, $
  maxExtinctions=maxExtinctions

if n_elements(maxExtinctions) eq 0 then maxExtinctions = 1
if n_elements(instrument) eq 0 then instrument='emls'

; instrumentPrefixes=['emlsSignals=[ ', 'umlsSignals=[ ', 'xptl1Signals=[ ']
instrumentPrefixes = [ 'emlsSignals=[ ', 'umlsSignals=[ ' ]
noInstruments = n_elements(instrumentPrefixes)

if keyword_set(retrieval) then begin
  outName = 'spectroscopy-rtvl.l2cf'
endif else begin
  outName = 'spectroscopy.l2cf'
endelse

if n_elements(molName) eq 0 then $
  molName = getenv('HOME') + '/mlspgs/tables/mol_data_table.tex'
if n_elements(lineName) eq 0 then $
  lineName = getenv('HOME') + '/mlspgs/tables/line_data_table.tex'
if n_elements(crossRefName) eq 0 then $
  crossRefName = getenv('HOME') + '/mlspgs/tables/sps_cross_ref_table.txt'

; Call Bills code to read the files
Read_Spect_Dbase, molName, lineName, '', data,  $
  molID=molID, lineID=lineID, readID=readID

if keyword_set(retrieval) then TrimSpectroscopyForRetrieval, data

myID='$Id$'

; Read the cross reference information
openr, unit, crossRefName, /get_lun
line = ''
firstLine = 1
repeat begin
  readf, unit, line, format='(a)'
  if firstLine then crossRefID = line
  firstLine = 0
endrep until strmid(line,0,4) eq '----'
while not eof ( unit ) do begin
  readf, unit, line, format='(a)'
  words = strsplit ( line, ' ', /extract )
  if n_elements(words) gt 1 then begin
    if n_elements(texNames) eq 0 then begin
      texNames = words(0)
      l2Names = words(1)
      noChildren = fix ( words(3) )
    endif else begin
      texNames = [ texNames, words(0) ]
      l2Names = [ l2Names, words(1) ]
      noChildren = [ noChildren, fix ( words(3) ) ]
    endelse
  endif
endwhile
free_lun, unit
; Now work out the parents
noCrossRefs = n_elements(texNames)
parents = intarr ( noCrossRefs ) - 1
for index = 0, noCrossRefs - 1 do begin
  if noChildren(index) ne 0 then begin
    if noChildren(index) < 0 then i0 = index else i0 = index + 1
    i1 = index + abs(noChildren(index))
    parents(i0:i1) = index
  endif
endfor  

; Sort out nitrogen
change = (where(data.name eq 'N$_{2}$' or data.name eq 'EXTINCTION' $
  or strmid(data.name,0,10) eq 'H$_{2}$O-r') )
data(change).q=1.0

; Open the output file
Openw, unit, outName, /get_lun

; Write in the appropriate header information
printf, unit, '; --------------------------------------------- Spectroscopy ---- '
printf, unit, '; This file is automatically generated by the program'
printf, unit, '; mlspgs/idllib/createspectroscopyl2cf.pro do NOT edit it by hand.'
printf, unit, ''

if keyword_set(retrieval) then $
  printf, unit, '; NOTE**** This is the special file for doing fast retrievals'

printf, unit, '; Source file information:'
printf, unit, '; '+strmid(molID,7,strlen(molID)-9)
printf, unit, '; '+strmid(lineID,7,strlen(lineID)-9)
printf, unit, '; '+strmid(crossRefID,5,strlen(crossRefID)-7)
printf, unit, '; '+strmid(readID,5,strlen(readID)-7)
printf, unit, '; '+strmid(myID,5,strlen(myID)-7)
printf, unit, ''

printf, unit, 'begin spectroscopy'

noEMLSBands = 34
noUMLSBands = 6
noSidebands = 3

noMols = n_elements(data)
niceNames = strarr(noMols)
parentNames = niceNames
emlsMolecules = intarr ( noSidebands, noEMLSBands, noMols )
umlsMolecules = intarr ( noSidebands, noUMLSBands, noMols )

for mol = 0, noMols - 1 do begin

  ;; First try to un TeXify the molecule names
  ;; Also, after a space, add the name of the parent
  ;; Did it after the space to avoid the case statement getting overly large
  index = ( where ( data(mol).name eq texNames ) ) ( 0 )
  if index eq -1 then begin
    if strmid ( data(mol).name, 0, 10 ) eq 'H$_{2}$O-r' then begin
      niceNames(mol) = 'H2O_R' + strupcase ( strmid ( data(mol).name, 10, 2 ) )
      parentNames(mol) = 'H2O'
    endif else begin
      MyMessage, /error, "Unrecognized molecule: " + data(mol).name
    endelse
  endif else begin
    niceNames(mol) = l2Names(index)
    if parents(index) eq -1 then begin
      parentNames(mol) = niceNames ( mol )
    endif else begin
      parentNames(mol) = l2Names ( parents (index) )
    endelse
  endelse
  thisMolName = niceNames(mol)

  if ( min(data(mol).q) le 0.0 and data(mol).cont(0) eq 0.0 ) then begin
    print, 'Skipping ' + thisMolName
    niceNames ( mol ) = ''
    continue
  endif

  if n_elements(allNames) eq 0 then allNames = thisMolName $
  else allNames = allNames + ', ' + thisMolName
  
  ;; Now print out a header line
  printf,unit, ''
  printf,unit, '  ;; ----------------------------------- '+thisMolName
  if thisMolName ne 'EXTINCTION' then $
    printf,unit, '  !define(isotoperatio' + thisMolName + ',{' + $
    string ( data(mol).abun, format='(f10.8)' ) + '} )'
  printf,unit, ''
  for line = 0, data(mol).no_Lines - 1 do begin
    text= '  '+thisMolName + '_L' + string ( line+1, format='(I0)' ) + ': line, '
    AddWordToLine,text,unit,4, $
      'v0= '+strtrim(string( data(mol).frq(line), format='(f12.4)' ),2) + ' MHz, '
    AddWordToLine,text,unit,4, $
      'el= '+strtrim(string( data(mol).gse(line), format='(g13.8)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'str= '+strtrim(string( data(mol).ist(line), format='(f8.4)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'w= '+strtrim(string( data(mol).wc(line), format='(f8.4)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'n= '+strtrim(string(data(mol).nc(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'ps= '+strtrim(string(data(mol).ps(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'ns= '+strtrim(string(data(mol).ns(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'delta= '+strtrim(string(data(mol).int1(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'n1= '+strtrim(string(data(mol).n1(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'gamma= '+strtrim(string(data(mol).int2(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'n2= '+strtrim(string(data(mol).n2(line), format='(f6.3)'),2) + ', '

    ;; Do the quantum numbers
    noQNs = data(mol).qnfmt(line) mod 10
    qns = data(mol).qnfmt(line)
    for q = 0, noQNs - 1 do qns = [ qns, fix ( strmid ( data(mol).qnu(line), q*2, 2 ) ) ]
    for q = 0, noQNs - 1 do qns = [ qns, fix ( strmid ( data(mol).qnl(line), q*2, 2 ) ) ]
    AddWordToLine,text,unit,4, 'qn=[ '
    for q = 0, n_elements(qns)-2 do $
      AddWordToLine,text,unit,4, string(qns(q),format='(i0)')+', '
    AddWordToLine,text,unit,3, string(qns(2*noQNS),format='(i0)') + ' ]'
   
    for i=0, noInstruments - 1 do begin
      case i of
        0 : begin 
          prefix = 'emlsSignals=[ '
          bands = data(mol).eos_bands(line)
        end
        1 : begin
          prefix = 'umlsSignals=[ '
          bands = data(mol).uars_bands(line)
        end
;         2 : begin
;           prefix = 'xptl1Signals=[ '
;           bands = data(mol).xptl1_bands(line)
;         end
      endcase
      bands = strtrim(strsplit(bands,',',/extract),2)
      if bands(0) ne '' then begin
        text = text + ', '
        AddWordToLine,text,unit,4,prefix
        for j = 0, n_elements(bands)-1 do begin
          thisBand = strupcase ( bands(j) )
          bandNo = fix(strmid(thisBand,1,strlen(thisBand)))
          case 1 of
            strpos(thisBand,'U') ne -1 : sideband = 1
            strpos(thisBand,'L') ne -1 : sideband = -1
            else : sideband = 0
          endcase
          case 1 of 
            bandNo le 21 : thisBand=thisBand+'F'
            bandNo le 26 : thisBand=thisBand+'D'
            bandNo le 31 : thisBand=thisBand+'M'
            bandNo le 34 : thisBand=thisBand+'W'
          endcase
          thisBand="'"+thisBand+"'"
          if j lt n_elements(bands)-1 $
            then thisBand=thisBand+', ' $
          else thisBand=thisBand+' ]'
          AddWordToLine,text,unit,4,thisBand
          ;; Keep track of the molecule by molecule usage
          case i of
            0 : emlsMolecules ( sideband+1, bandNo-1, mol ) = 1
            1 : umlsMolecules ( sideband+1, bandNo-1, mol ) = 1
;           2 : xptl1Molecues ( sideband+1, bandNo-1, mol ) = 1
          endcase
        endfor
      endif                             ; Any bands
    endfor                              ; Loop over instruments

    ;; Special case for O2 polarized 118 line
    if thisMolName eq 'O2' and n_elements(qns) eq 5 and $
      min ( qns eq [ 102, 1, 1, 1, 0 ] ) then begin
      text = text + ', '
      AddWordToLine, text, unit, 4, "emlsSignalsPol=[ 'B22LD', " 
      AddWordToLine, text, unit, 4, "'B26LD' ]"
    endif
    
    if strtrim(text,2) ne '' then printf,unit,text
  endfor                                ; Loop over lines

  ;; Now print out the molecule information
  printf, unit, ''
  text = '  spectra, molecule= '+thisMolName+', Qlog=[ '

  for i = 0, 2 do begin
    text = text + strtrim(string(alog10(data(mol).q(i)), $
      format='(f10.4)'),2)
    if i ne 2 then text = text + ', '
  endfor

  ;; Lines
  if data(mol).no_lines gt 0 then begin
    text = text + ' ], $'
    printf, unit,text
    text = '    lines=[ '
    for line = 0, data(mol).no_lines - 2 do begin
      AddWordToLine, text, unit, 4, $
        thisMolName+'_L'+string(line+1,format='(I0)')+', '
    endfor
    AddWordToLine, text, unit, 4, $
      thisMolName+'_L'+string(data(mol).no_lines,format='(I0)')+' ]'
  endif else begin
    text = text + ' ]'
  endelse

  ;; Mass
  text = text + ', '
  AddWordToLine, text, unit, 4, $
    'mass= ' + strtrim ( string ( data(mol).mass, format='(f9.5)' ), 2 )
  
  ;; Continuum
  noNonZero = max(where(data(mol).cont ne 0.0))+1
  if noNonZero ne 0 then begin
    text = text + ', '
    AddWordToLine, text, unit, 4, $
      'continuum=[ '
    for i=0,noNonZero-2 do begin
      AddWordToLine, text, unit, 4, $
        strtrim(string(data(mol).cont(i)),2)+', '
    endfor
    AddWordToLine, text, unit, 4, $
      strtrim(string(data(mol).cont(noNonZero-1)),2)+' ]'
  endif
  
  ;; Finish off the line
  if strtrim(text,2) ne '' then printf,unit,text
endfor                                  ; End loop over molecules

printf, unit, ''
printf, unit, 'end spectroscopy'
printf, unit, ''

;; ------------------------------------- End of the spectroscopy part

;; Now write out the molecules per band stuff
case strlowcase ( instrument ) of 
  'umls' : array=umlsMolecules
  'emls' : array=emlsMolecules
; 'xptl1' : array=xptl1Molecules
  else : MyMessage,/error,'Unknown instrument'
endcase

;; Collapse the sidebands
array(1,*,*) = array(0,*,*) or array(1,*,*) or array(2,*,*) 
printf, unit, '; ----------------------------------------- Molecules per band'
printf, unit, ''
;; Make H2O, N2 and extinction used everywhere.
array(*,*,where(niceNames eq 'H2O')) = 1
array(*,*,where(niceNames eq 'N2')) = 1
array(*,*,where(niceNames eq 'O2')) = 1
array(*,*,where(niceNames eq 'EXTINCTION')) = 1
sidebandStrings = ['L','','U']
noBands = (size ( array ) ) (2)
;; Make the H2O_<radiometer> species used where appropriate
database = ReadValidSignals()
for radiometer = 0, database.noRadiometers-1 do begin
  relevantBands = where ( database.bands.radiometerIndex eq radiometer )
  array(*,relevantBands, $
    where(niceNames eq 'H2O_'+database.radiometers(radiometer).prefix ) ) = 1
endfor

;; Now, add some extra virtual bands which are the radiometers
newArray = intarr ( noSidebands, noBands+database.noRadiometers, noMols )
newArray(*,0:noBands-1,*) = array
for radiometer = 0, database.noRadiometers-1 do begin
  relevantBands = where ( database.bands.radiometerIndex eq radiometer )
  collapsed = total ( array (*,relevantBands,*), 2 )
  newArray(*,noBands+radiometer,*) = collapsed gt 0
endfor
array=newArray

if maxExtinctions ne 1 and maxExtinctions ne 2 then begin
  print,'Illegal value of maxExtinctions'
  stop
endif

for noExtinctions = 1, maxExtinctions do begin
  if noExtinctions eq 1 then extraName='' else extraName='2X'
  for band = 0, noBands + database.noRadiometers - 1 do begin
    for sideband = 0, 2 do begin
      ;; Which molecules does it use
      usedMols = where ( reform ( array(sideband, band, *) ) )
      ;; What parents do they have, get a unique list
      usedParents = parentNames ( usedMols )
      usedParents = usedParents ( sort ( usedParents ) )
      usedParents = usedParents ( uniq ( usedParents ) )
      if band lt noBands then $
        outName = string ( band+1, format='(i0)' ) $
      else outName = database.radiometers(band-noBands).prefix

      ;; First do the comprehensive lists for full forward models.
      line = '!define(molecules' + extraName + 'For' + outName + $
        sidebandStrings(sideband)+',{[ '
      for p = 0, n_elements(usedParents)-1 do begin
        if p ne 0 then line = line +', '
        thisParent = usedParents(p)
        if thisParent ne 'EXTINCTION' then begin
          children = where ( parentNames eq thisParent and $
            reform ( array(sideband, band, *) ) )
          AddWordToLine, line, unit, 2, '[ '+thisParent
          ;; Format is [ parent, <children> ]
          ;; Note, having the only child be the same as the parent is fine
          ;; (e.g. [ H2O, H2O ])
          for c = 0, n_elements(children) - 1 do begin
            line = line + ', '
            AddWordToLine, line, unit, 4, niceNames(children(c))
          endfor
          line = line + ' ]'
        endif else begin
          ;; For extinction just use extinction alone, no isotope
          if noExtinctions eq 1 then begin
            AddWordToLine, line, unit, 2, thisParent
          endif else begin
            AddWordToLine, line, unit, 2, thisParent + ', ' + thisParent
          endelse
        endelse
      endfor
      line = line + ' ]})'
      printf, unit, line

      ;; Now do just the parents for l2pc line forward models
      ;; First do the comprehensive lists for full forward models.
      line = '!define(moleculeFamilies' + extraName + 'For' + outName + $
        sidebandStrings(sideband)+',{[ '
      for p = 0, n_elements(usedParents)-1 do begin
        if p ne 0 then line = line + ', '
        thisParent = usedParents(p)
        children = where ( parentNames eq thisParent and $
          reform ( array(sideband, band, *) ) )
        if thisParent ne 'EXTINCTION' or noExtinctions eq 1 then begin
          AddWordToLine, line, unit, 2, thisParent
        endif else begin
          AddWordToLine, line, unit, 2, thisParent + ', ' + thisParent
        endelse
      endfor
      line = line +' ]})'
      printf, unit, line

    endfor                              ; Loop over sidebands
    printf, unit, ''
  endfor                                ; Loop over bands
endfor

;; Print out a few more macro definitions
printf,unit,'!define(molecules,{!moleculesFor$1})'
printf,unit,'!define(moleculeFamilies,{!moleculeFamiliesFor$1})'
printf,unit,'!define(molecules2X,{!molecules2XFor$1})'
printf,unit,'!define(moleculeFamilies2X,{!moleculeFamilies2XFor$1})'

isotopicMolecules = niceNames ( where ( nicenames ne 'EXTINCTION' and $
  nicenames ne '' ) )

printf,unit,'!define(isotopicMolecules,{' + strjoin(isotopicMolecules,',')+'})'

Free_lun, unit

end
