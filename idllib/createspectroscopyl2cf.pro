; $Id$

pro CreateSpectroscopyL2CF, $
  molName=molName, $
  lineName=lineName, uars=uars

outName = 'spectroscopy.l2cf'

if n_elements(molName) eq 0 then $
  molName = getenv('HOME')+'/mlspgs/tables/mol_data_table.tex'
if n_elements(lineName) eq 0 then $
  lineName = getenv('HOME')+'/mlspgs/tables/line_data_table.tex'

; Call Bills code to read the files
Read_Spect_Dbase, molName, lineName, '', data,  $
  molID=molID, lineID=lineID, readID=readID
myID='$Id$'

; Sort out nitrogen
change = (where(data.name eq 'N$_{2}$' or data.name eq 'EXTINCTION' ) )
data(change).q=1.0

; Open the output file
Openw, unit, outName, /get_lun

; Write in the appropriate header information
printf, unit, '; --------------------------------------------- Spectroscopy ---- '
printf, unit, '; This file is automatically generated by the program'
printf, unit, '; mlspgs/idllib/createspectroscopyl2cf.pro do NOT edit it by hand.'
printf, unit, ''
printf, unit, '; Source file information:'
printf, unit, '; '+strmid(molID,7,strlen(molID)-9)
printf, unit, '; '+strmid(lineID,7,strlen(lineID)-9)
printf, unit, '; '+strmid(readID,5,strlen(readID)-7)
printf, unit, '; '+strmid(myID,5,strlen(myID)-7)
printf, unit, ''

printf, unit, 'begin spectroscopy'

noEMLSBands = 34
noUMLSBands = 6
noSidebands = 3

noMols = n_elements(data)
niceNames = strarr(noMols)
parentNames = niceNames
emlsMolecules = intarr ( noSidebands, noEMLSBands, noMols )
umlsMolecules = intarr ( noSidebands, noUMLSBands, noMols )

for mol = 0, noMols - 1 do begin

  ;; First try to un TeXify the molecule names
  ;; Also, after a space, add the name of the parent
  ;; Did it after the space to avoid the case statement getting overly large
  thisMolName = data(mol).name
  case thisMolName of
    '$^{81}$BrO'      : thisMolName = 'Br_81_O BrO'
    '$^{79}$BrO'      : thisMolName = 'Br_79_O BrO'
    'CH$_{3}$CN'      : thisMolName = 'CH3CN'
    '$^{35}$ClO'      : thisMolName = 'Cl_35_O ClO'
    'H$^{35}$Cl'      : thisMolName = 'HCl_35 HCl'
    'H$^{37}$Cl'      : thisMolName = 'HCl_37 HCl'
    'H$_{2}$O'        : thisMolName = 'H2O'
    'H$_{2}^{18}$O'   : thisMolName = 'H2O_18 H2O'
    'H$_{2}$O$_{2}$'  : thisMolName = 'H2O2'
    'HNO$_{3}$'       : thisMolName = 'HNO3'
    'HNO$_{3}$-v6'    : thisMolName = 'HNO3_v6 HNO3'
    'HNO$_{3}$-v7'    : thisMolName = 'HNO3_v7 HNO3'
    'HNO$_{3}$-v8'    : thisMolName = 'HNO3_v8 HNO3'
    'HNO$_{3}$-v9'    : thisMolName = 'HNO3_v9 HNO3'
    'HO$^{35}$Cl'     : thisMolName = 'HOCl_35 HOCl'
    'HO$^{37}$Cl'     : thisMolName = 'HOCl_37 HOCl'
    'HO$_{2}$'        : thisMolName = 'HO2'
    'N$_{2}$'         : thisMolName = 'N2'
    'N$_{2}$O'        : thisMolName = 'N2O'
    'O$_{2}$'         : thisMolName = 'O2'
    'O$_{2}$-v1'      : thisMolName = 'O2_v1 O2'
    'O$^{18}$O'       : thisMolName = 'O_18_O O2'
    'O$_{3}$'         : thisMolName = 'O3'
    'O$_{3}$-v1,3'    : thisMolName = 'O3_v1_3 O3'
    'O$_{3}$-v2'      : thisMolName = 'O3_v2 O3'
    'O$_{2}^{18}$O'   : thisMolName = 'O3_ASYM_O_18 O3'
    'O$^{18}$OO'      : thisMolName = 'O3_SYM_O_18 O3'
    '$^{32}$SO$_{2}$' : thisMolName = 'S_32_O2 SO2'
    else: thisMolName = thisMolName
  endcase
  if ( strpos ( thisMolName, ' ' ) eq -1 ) then begin
    parentName = thisMolName
  endif else begin
    words = strsplit ( thisMolName,/extract )
    thisMolName = words(0)
    parentName = words(1)
  endelse

  niceNames(mol) = thisMolName
  parentNames(mol) = parentName
  if n_elements(allNames) eq 0 then allNames = thisMolName $
  else allNames = allNames + ', ' + thisMolName
  
  ;; Now print out a header line
  printf,unit, ''
  printf,unit, '  ;; ----------------------------------- '+thisMolName
  if thisMolName ne 'EXTINCTION' then $
    printf,unit, '  !define(isotoperatio' + thisMolName + ',{' + $
    string ( data(mol).abun, format='(f10.8)' ) + '} )'
  printf,unit, ''
  for line = 0, data(mol).no_Lines - 1 do begin
    text= '  '+thisMolName + '_L' + string ( line+1, format='(I0)' ) + ': line, '
    AddWordToLine,text,unit,4, $
      'v0= '+strtrim(string( data(mol).frq(line), format='(f12.4)' ),2) + ' MHz, '
    AddWordToLine,text,unit,4, $
      'el= '+strtrim(string( data(mol).gse(line), format='(g13.8)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'str= '+strtrim(string( data(mol).ist(line), format='(f8.4)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'w= '+strtrim(string( data(mol).wc(line), format='(f8.4)' ),2) + ', '
    AddWordToLine,text,unit,4, $
      'n= '+strtrim(string(data(mol).nc(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'ps= '+strtrim(string(data(mol).ps(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'ns= '+strtrim(string(data(mol).ns(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'delta= '+strtrim(string(data(mol).int1(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'n1= '+strtrim(string(data(mol).n1(line), format='(f6.3)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'gamma= '+strtrim(string(data(mol).int2(line), format='(g15.5)'),2) + ', '
    AddWordToLine,text,unit,4, $
      'n2= '+strtrim(string(data(mol).n2(line), format='(f6.3)'),2)

    for i=0,1 do begin
      case i of
        0 : begin 
          prefix = 'emlsSignals=[ '
          bands = data(mol).eos_bands(line)
        end
        1 : begin
          prefix = 'umlsSignals=[ '
          bands = data(mol).uars_bands(line)
        end
      endcase
      bands = strtrim(strsplit(bands,',',/extract),2)
      if bands(0) ne '' then begin
        AddWordToLine,text,unit,4,', '
        AddWordToLine,text,unit,4,prefix
        for j = 0, n_elements(bands)-1 do begin
          thisBand = strupcase ( bands(j) )
          bandNo = fix(strmid(thisBand,1,strlen(thisBand)))
          case 1 of
            strpos(thisBand,'U') ne -1 : sideband = 1
            strpos(thisBand,'L') ne -1 : sideband = -1
            else : sideband = 0
          endcase
          case 1 of 
            bandNo le 21 : thisBand=thisBand+'F'
            bandNo le 26 : thisBand=thisBand+'D'
            bandNo le 31 : thisBand=thisBand+'M'
            bandNo le 34 : thisBand=thisBand+'W'
          endcase
          thisBand="'"+thisBand+"'"
          if j lt n_elements(bands)-1 $
            then thisBand=thisBand+', ' $
            else thisBand=thisBand+' ]'
          AddWordToLine,text,unit,4,thisBand
          ;; Keep track of the molecule by molecule usage
          case i of
            0 : emlsMolecules ( sideband+1, bandNo-1, mol ) = 1
            1 : umlsMolecules ( sideband+1, bandNo-1, mol ) = 1
          endcase
        endfor
      endif                     ; Any bands
    endfor                      ; Loop over instruments
    
    if strtrim(text,2) ne '' then printf,unit,text
  endfor                        ; Loop over lines

  ;; Now print out the molecule information
  printf, unit, ''
  text = '  spectra, molecule= '+thisMolName+', Qlog=[ '

  ;; Qlog information
  for i = 0, 2 do begin
    text = text + strtrim(string(alog10(data(mol).q(i)), $
      format='(f10.4)'),2)
    if i ne 2 then text = text + ', '
  endfor

  ;; Lines
  if data(mol).no_lines gt 0 then begin
    text = text + ' ], $'
    printf, unit,text
    text = '    lines=[ '
    for line = 0, data(mol).no_lines - 2 do begin
      AddWordToLine, text, unit, 4, $
        thisMolName+'_L'+string(line+1,format='(I0)')+', '
    endfor
    AddWordToLine, text, unit, 4, $
      thisMolName+'_L'+string(data(mol).no_lines,format='(I0)')+' ]'
  endif else begin
    text = text + ' ]'
  endelse
  
  ;; Continuum
  noNonZero = max(where(data(mol).cont ne 0.0))+1
  if noNonZero ne 0 then begin
    text = text + ', '
      AddWordToLine, text, unit, 4, $
        'continuum=[ '
    for i=0,noNonZero-2 do begin
      AddWordToLine, text, unit, 4, $
        strtrim(string(data(mol).cont(i)),2)+', '
    endfor
      AddWordToLine, text, unit, 4, $
        strtrim(string(data(mol).cont(noNonZero-1)),2)+' ]'
  endif
  
  ;; Finish off the line
  if strtrim(text,2) ne '' then printf,unit,text
endfor                          ; End loop over molecules

printf, unit, ''
printf, unit, 'end spectroscopy'
printf, unit, ''

;; ------------------------------------- End of the spectroscopy part

;; Now write out the molecules per band stuff

if keyword_set(uars) $
  then array = umlsMolecules $
else array=emlsMolecules

;; Collapse the sidebands
array(1,*,*) = array(0,*,*) or array(1,*,*) or array(2,*,*) 
printf, unit, '; ----------------------------------------- Molecules per band'
printf, unit, ''
array(*,*,where(niceNames eq 'H2O')) = 1
array(*,*,where(niceNames eq 'N2')) = 1
sidebandStrings = ['L','','U']
noBands = (size ( array ) ) (2)

;; Now, add some extra virtual bands which are the radiometers
database = ReadValidSignals()
newArray = intarr ( noSidebands, noBands+database.noRadiometers, noMols )
newArray(*,0:noBands-1,*) = array
for radiometer = 0, database.noRadiometers-1 do begin
  relevantBands = where ( database.bands.radiometerIndex eq radiometer )
  collapsed = total ( array (*,relevantBands,*), 2 )
  newArray(*,noBands+radiometer,*) = collapsed gt 0
endfor
array=newArray
  

for band = 0, noBands + database.noRadiometers - 1 do begin
  for sideband = 0, 2 do begin
    ;; Which molecules does it use
    usedMols = where ( reform ( array(sideband, band, *) ) )
    ;; What parents do they have, get a unique list
    usedParents = parentNames ( usedMols )
    usedParents = usedParents ( sort ( usedParents ) )
    usedParents = usedParents ( uniq ( usedParents ) )
    if band lt noBands then $
      outName = string ( band+1, format='(i0)' ) $
    else outName = database.radiometers(band-noBands).prefix

    ;; First do the comprehensive lists for full forward models.
    line = '!define(moleculesFor' + outName + $
      sidebandStrings(sideband)+',{[ '
    for p = 0, n_elements(usedParents)-1 do begin
      if p ne 0 then line = line +', '
      thisParent = usedParents(p)
      children = where ( parentNames eq thisParent and $
        reform ( array(sideband, band, *) ) )
      AddWordToLine, line, unit, 2, '[ '+thisParent
      ;; Format is [ parent, <children> ]
      ;; Note, having the only child be the same as the parent is fine
      ;; (e.g. [ H2O, H2O ])
      for c = 0, n_elements(children) - 1 do begin
        line = line + ', '
        AddWordToLine, line, unit, 4, niceNames(children(c))
      endfor
      line = line + ' ]'
    endfor
    line = line + ' ]})'
    printf, unit, line

    ;; Now do just the parents for l2pc line forward models
    ;; First do the comprehensive lists for full forward models.
    line = '!define(moleculeFamiliesFor' + outName + $
      sidebandStrings(sideband)+',{[ '
    for p = 0, n_elements(usedParents)-1 do begin
      if p ne 0 then line = line + ', '
      thisParent = usedParents(p)
      children = where ( parentNames eq thisParent and $
        reform ( array(sideband, band, *) ) )
      AddWordToLine, line, unit, 2, thisParent
    endfor
    line = line +' ]})'
    printf, unit, line

  endfor                        ; Loop over sidebands
  printf, unit, ''
endfor                          ; Loop over bands

;; Print out a few more macro definitions
printf,unit,'!define(molecules,{!moleculesFor$1})'
printf,unit,'!define(moleculeFamilies,{!moleculeFamiliesFor$1})'

isotopicMolecules = niceNames ( where ( nicenames ne 'EXTINCTION' ) )

printf,unit,'!define(isotopicMolecules,{' + strjoin(isotopicMolecules,',')+'})'

Free_lun, unit

end
