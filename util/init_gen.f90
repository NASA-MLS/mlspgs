! Copyright (c) 2001, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

program INIT_GEN

  ! Generate the parameter statements and references to add_ident
  ! for init_tables_module and others similar to it.

  ! An input file specifies the names.
  ! You can put one or two names on a line, separated by spaces.
  ! The first name is the parameter name WITHOUT ITS PREFIX.
  ! The second name is the entity's text -- e.g. a field name.  If
  ! it's not present, the first name is used for the entity's text.

  ! Blank lines don't count.

  ! The command line controls everything else.  See the PRINT statements
  ! that explain the usage.

  use MACHINE,only: GETARG, HP, IO_ERROR

!---------------------------- RCS Ident Info -------------------------------
  character (len=*), parameter :: IdParm = &
       "$Id$"
  character (len=len(idParm)) :: Id = idParm
  character (len=*), parameter :: ModuleName = "$RCSfile$"
!---------------------------------------------------------------------------

  character(len=30) :: CapName               ! Capitalized? name
  integer, parameter :: Decl_Wid = len("  integer, parameter :: ")
  logical :: DoIdent = .true.                ! Do add_ident stuff, made false
                                             ! if no file is supplied for it
  logical :: DoCap = .false.                 ! "Capitalize declaration"
  character(len=40) :: FirstName = '1', LastName = ' '
  integer :: I, J                            ! subscripts, loop inductors
  character(len=127) :: InFile = ' '
  character(len=30) :: Index_Name            ! Array for output from add_ident
  integer :: Index_Wid                       ! Width of Index_Name
  integer :: IOSTAT
  character(len=127) :: LINE
  integer :: Margin = 0                      ! Internal margin
  integer :: MaxNames = 1000                 ! Maximum number of names
  integer :: MaxWid                          ! of a name
  character(len=30), dimension(:), allocatable :: Names ! for the symbol table
  integer :: Nspaces
  integer :: NumNames
  character(len=127) :: Out_Add, Out_Parm    ! File names
  character(len=40), dimension(:), allocatable :: P_Names   ! Parameter names
  !                                            that go with Names
  character(len=10) :: Pfx = ' '             ! for declarations

  character(len=127), dimension(3) :: HEADER = (/ &
    & 'This file is automatically generated by the makefile', &
    & 'Please do not edit it directly nor cvs commit it    ', &
    & 'Instead edit the file <file_name_here>              ' &
    & /)
  logical, parameter                        :: WRITEHEADER = .true.

  i = hp
  do
    i = i + 1
    call getarg ( i, line )
    if ( line(1:3) == '-c ' ) then
      doCap = .true.
    else if ( line(1:2) == '-f' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      firstName = line(3:)
    else if ( line(1:2) == '-i' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      inFile = line(3:)
      j = index(header(3),'<')
      header(3)(j:) = trim(infile)
    else if ( line(1:2) == '-j' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      j = index(header(3),'<')
      header(3)(j:) = trim(line(3:))
    else if ( line(1:2) == '-l' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      lastName = line(3:)
    else if ( line(1:2) == '-m' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      read ( line(3:), *, iostat=iostat ) margin
      if ( iostat /= 0 ) then
        call io_error ( 'While reading "m" option', iostat )
        margin = 0
      end if
    else if ( line(1:2) == '-n' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      read ( line(3:), *, iostat=iostat ) maxNames
      if ( iostat /= 0 ) then
        call io_error ( 'While reading "n" option', iostat )
        maxNames = 1000
      end if
     else if ( line(1:2) == '-p' ) then
      if ( line(3:3) == ' ' ) then
        i = i + 1
        call getarg ( i, line(3:) )
      end if
      pfx = line(3:)
    else if ( line(1:1) == '-' ) then
      call getarg ( hp, line )
      print *, 'Usage: ', trim(line), ' [options] out_parm [out_add index_name]'
      print *, ' Options:  -c: Capitalize entire name in declarations'
      print *, '           -f[ ]first_name -- The expression from which the'
      print *, '             first name gets its value.  Default 1.'
      print *, '           -i[ ]input_file -- stdin used otherwise.'
      print *, '           -j[ ]file -- name of file you piped in throough stdin.'
      print *, '           -l[ ]last_name -- A name made equal to the last name.'
      print *, '             Not emitted if not present.'
      print *, '           -m[ ]margin -- The "middle" margin, which is otherwise'
      print *, '             computed from the width of the widest name.'
      print *, '           -n[ ]number -- the maximum number of names, default ', &
        &                    maxNames
      print *, '           -p[ ]prefix -- Prefix for variable names.'
      print *, '           -<anything else>: This output.'
      print *, ' out_parm:   The file to store the generated parameter declarations.'
      print *, '                (Mandatory)'
      print *, '    The next two are co-optional: if one given then both must be given'
      print *, ' out_add:    The file to store the generated references to add_ident.'
      print *, ' index_name: The name of the array in which to store the outputs'
      print *, '             of add_ident.'
      stop
    else
  exit
    end if
  end do

  call getarg ( i, out_parm )
  if ( out_parm == ' ' ) then
    print *, 'No parameter declarations file name given.'
    stop
  end if
  call getarg ( i+1, out_add )
  doIdent = out_add /= ' '
  if ( doIdent ) then
    call getarg ( i+2, index_name )
    if ( index_name == ' ' ) then
      print *, 'No name given for the array to store references to add_ident.'
      stop
    end if
    index_Wid = len_trim(index_name)
  end if

  if ( inFile /= ' ' ) then
    open ( 10, file=inFile, form='formatted', status='old', iostat=iostat )
    if ( iostat /= 0 ) then
      call io_error ( 'Opening input file', iostat, inFile )
      stop
    end if
  end if

  if ( doIdent ) then
    open ( 11, file=out_add, form='formatted', iostat=iostat )
    if ( iostat /= 0 ) then
      call io_error ( 'Opening file for results of add_ident', iostat, inFile )
      stop
    end if
  end if

  open ( 12, file=out_parm, form='formatted', iostat=iostat )
  if ( iostat /= 0 ) then
    call io_error ( 'Opening file for parameter declarations', iostat, inFile )
    stop
  end if

  ! Read the names.  Calculate the width of the widest name.
  maxWid = 0
  numNames = 0
  allocate ( names(maxNames), p_names(maxNames), stat=iostat )
  if ( iostat > 0 ) then
    call io_error ( 'Allocating arrays', iostat )
    stop
  end if

  do
    if ( infile == ' ' ) then
      read ( *, '(a)', iostat=iostat ) line
    else
      read ( 10, '(a)', iostat=iostat ) line
    end if
    if ( iostat < 0 ) exit
    if ( iostat > 0 ) then
      call io_error ( 'Reading input file', iostat, inFile )
      stop
    end if
    if ( line == ' ' ) cycle
    line = adjustl(line)
    if ( line(1:1) == '#' .or. line(1:1) == '!' ) cycle
    numNames = numNames + 1
    if ( numNames > maxNames ) then
      print *, numNames, ' is too many names.  Use the "-n" option.'
      stop
    end if
    ! Trim off comments
    j = index(line,'#')
    if ( j /= 0 ) line(j:) = ' '
    j = index(line,'!')
    if ( j /= 0 ) line(j:) = ' '
    ! get p_name if any
    j = index(line,' ')
    p_names(numNames) = line(:j-1)
    line = adjustl(line(j+1:))
    if ( line == ' ' ) then
      names(numNames) = p_names(numNames)
    else
      names(numNames) = line
    end if
    p_names(numNames) = trim(pfx) // p_names(numNames)
    maxWid = max(maxWid, len_trim(p_names(numNames)))
  end do
  line = ' '
  close ( 10 )

  if ( lastName /= ' ' ) maxWid = max(maxWid, len_trim(lastName))

  ! Output the parameter declarations.

  line = ' ' ! used to output spaces

100 format ( "  integer, parameter :: ",a," = ",a,a)
  ! Warn off users from editing Out_parm
  if ( writeheader ) then
    write ( 12, '(a, a)' ) '! File name: ', trim(Out_parm)
    do i = 1, size(header)
      write ( 12, '(a, a)' ) '! ', trim(header(i))
    end do
  end if

  do i = 1, numNames
    capName = capitalize(p_names(i))
    capName(1:1) = cap(capName(1:1))
    if ( margin /= 0 ) then
      nspaces = margin - decl_wid - len_trim(capName) - 4
    else
      nspaces = maxwid - len_trim(capName)
    end if
    write ( 12, 100 ) trim(capName), line(:nspaces), &
                    & trim(firstName)
    firstName = trim(p_names(i)) // ' + 1'
  end do
  if ( lastName /= ' ' ) then
    lastName = capitalize ( lastName )
    lastName(1:1) = cap(lastName(1:1))
    if ( margin /= 0 ) then
      nspaces = margin - decl_wid - len_trim(lastName) - 4
    else
      nspaces = maxwid - len_trim(lastName)
    end if
    write ( 12, 100 ) trim(lastName), line(:nspaces), &
                    & trim(p_names(numNames))
  end if
  close ( 12 )

  if ( doIdent ) then
    ! Output the references to "add_ident"
    ! Warn off users from editing Out_add
    if ( writeheader ) then
      write ( 11, '(a, a)' ) '! File name: ', trim(Out_add)
      do i = 1, size(header)
        write ( 11, '(a, a)' ) '! ', trim(header(i))
      end do
    end if

    do i = 1, numNames
      if ( margin /= 0 ) then
        nspaces = margin - index_Wid - 10 - len_trim(p_names(i))
      else
        nspaces = maxwid - len_trim(p_names(i))
      end if
      write ( 11, '(4x,a,"(",a,") = ", a, "add_ident ( ''",a,"'' )")' ) &
        & index_name(:index_Wid), trim(p_names(i)), &
        & line(:nspaces), trim(names(i))
    end do
    close ( 11 )
  end if

contains

  character function Cap ( TheChar )
    character, intent(in) :: TheChar
    cap = theChar
    if ( cap >= 'a' .and. cap <= 'z' ) &
      & cap = achar(iachar(cap) + iachar('A') - iachar('a'))
  end function Cap

  function Capitalize ( TheName ) result ( CapName )
    character(len=*), intent(in) :: TheName
    character(len(theName)) :: CapName
    integer :: J
    capName = theName
    if ( doCap ) then
      do j = 1, len_trim(theName)
        capName(j:j) = cap(capName(j:j))
      end do
    end if
  end function Capitalize

end program INIT_GEN

! $Log$
! Revision 1.9  2001/10/12 22:13:44  vsnyder
! Put input file name in comment in output file
!
! Revision 1.8  2001/10/12 22:03:09  vsnyder
! Generate only the parameters if the add_ident file isn't specified
!
! Revision 1.7  2001/10/04 19:54:43  pwagner
! Now names file to be edited '<file_name_here>'
!
! Revision 1.6  2001/10/03 17:18:20  pwagner
! Added header warning against editing out_add, out_parm
!
! Revision 1.5  2001/07/25 19:57:30  vsnyder
! Correct blunder -- used 'names' instead of 'p_names'
!
! Revision 1.4  2001/07/25 19:47:22  vsnyder
! Added 'only' to 'use MACHINE'
!
! Revision 1.3  2001/07/25 18:49:08  vsnyder
! Change default input to stdin, add an option to specify otherwise
!
! Revision 1.2  2001/07/25 18:26:34  vsnyder
! Insert copyright notice
!
! Revision 1.1  2001/07/25 02:07:02  vsnyder
! Initial commit
!
