! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.
!     .  NASA contract NAS7-918 is acknowledged.

!     Sort the M:N-vector A.
!     A is not disturbed.  P is set so that A(P(J)) is the J'th element
!     of the sorted sequence.
!
!     To sort an array A' into descending order, let A = -A'
!     To sort an array A' into ascending order according to the
!     absolute value of the elements let A = ABS(A').
!     To sort an array A' into decending order according to the
!     absolute value of the elements let A = -ABS(A').
!
!     subroutine *SORTQ (A, M, N, P)
      integer, intent(in) :: M, N
      integer, intent(inout) :: P(*)
!
!     *****     Local Variables     ************************************
!
! BL      is the left bound of the sub-array to be sorted at the next
!         step.
! BR      is the right bound of the sub-array to be sorted at the next
!         step.
! CL      is the current left bound of the unsorted sub-array.
! CR      is the current right bound of the unsorted sub-array.
! PARTN   is the partition element.
! PTEMP   holds elements of P during exchanges.
! STACKL  keeps track of the left bounds of sub-arrays waiting to be
!         sorted.
! STACKR  keeps track of the right bounds of sub-arrays waiting to be
!         sorted.
! STKTOP  keeps track of the top of the stacks.
!
      integer BL,BR,CL,CR
      integer, parameter :: INSERT = 10
      integer PTEMP, STACKL(32), STACKR(32), STKTOP
      integer :: mm, nm
!
!     *****     Executable Statements     ******************************
!
      if ( all(is_what_ieee(nan_signal, A(M:N))) ) then
        return
      elseif ( any(is_what_ieee(nan_signal, A(M:N))) ) then
        call moveNaNsToEnd ( mm, nm )
      else
        mm = M
        nm = N
      endif
      if ( nm-mm >= insert ) then
         stktop = 1
         stackl(1) = mm
         stackr(1) = nm
         do while ( stktop /=  0 )
            bl = stackl(stktop)
            br = stackr(stktop)
            stktop = stktop-1
!           Choose a partitioning element.  Use the median of the first,
!           middle and last elements.  Sort them so the extreme elements
!           can serve as sentinels during partitioning.
            cl = (bl+br)/2
            ptemp = p(cl)
            if (a(p(bl)) > a(ptemp)) then
               p(cl) = p(bl)
               p(bl) = ptemp
               ptemp = p(cl)
            end if
            if (a(p(bl)) > a(p(br))) then
               cr = p(bl)
               p(bl) = p(br)
               p(br) = cr
            end if
            if (a(ptemp)> a(p(br))) then
               p(cl) = p(br)
               p(br) = ptemp
               ptemp = p(cl)
            end if
            p(cl) = p(br-1)
            p(br-1) = ptemp
            partn = a(ptemp)
!           Partition the sub-array around PARTN.  Exclude the above
!           considered elements from partitioning because they're al-
!           ready in the correct subfiles.  Stop scanning on equality to
!           prevent files containing equal values from causing a loop.
            cl = bl
            cr = br-1
            do
  30           cl = cl+1
                  if (a(p(cl)) < partn) go to 30
  40           cr = cr-1
                  if (a(p(cr)) > partn) go to 40
               if (cl > cr) exit
               ptemp = p(cl)
               p(cl) = p(cr)
               p(cr) = ptemp
            end do
!           Put sub-arrays on the stack if they're big enough.  Put the
!           larger under the smaller, so the smaller will be done next.
!           This makes the upper bound of the stack depth log2 (n-m+1).
!           (The "Hibbard" modification of quicksort).
            if (cl-bl > br-cr) then
               if ( cl-bl> insert ) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
            else
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
               if ( cl-bl > insert) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
            end if
         end do
      end if
!     Clean up small subfiles using insertion sort on everything.
      do cr  =  mm+1, nm
         ptemp = p(cr)
         partn = a(ptemp)
         cl = cr
  60     if ( a(p(cl-1)) > partn ) then
            p(cl) = p(cl-1)
            cl = cl-1
            if (cl > mm ) go to 60 
         end if
         p(cl) = ptemp
      end do
      return
  contains
    subroutine moveNaNsToEnd ( mm, nm )
      ! Move NaNs to end of A
      ! Args:
      integer, intent(out) :: mm, nm
      ! Internal variables
      integer :: k
      ! Executable
      mm = M
      nm = N
      k = M - 1
      do
        k = k + 1
        if ( k <= nm ) exit
        if ( .not. is_what_ieee(nan_signal, A(p(k))) ) cycle
        ! swap NaN for current last element
        ptemp = p(k)
        p(k) = p(nm)
        p(nm) = ptemp
        nm = nm - 1
      enddo
    end subroutine moveNaNsToEnd
!     end

! $Log$
! Revision 2.4  2010/11/30 00:34:52  pwagner
! NaNs now sort to the end
!
! Revision 2.3  2005/06/22 17:44:11  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.2  2003/06/20 01:34:30  vsnyder
! Change intent for A and P
!
! Revision 2.1  2003/06/20 00:17:51  vsnyder
! Initial commit
!
