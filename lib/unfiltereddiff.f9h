! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

!   subroutine DIFF_1D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
!     & WIDTH, FORMAT, LBOUND, OPTIONS )
!     double precision, intent(in) :: ARRAY1(:)
!     character(len=*), intent(in), optional :: NAME1
!     double precision, intent(in) :: ARRAY2(:)
!     character(len=*), intent(in), optional :: NAME2
!     integer, intent(in), optional :: WIDTH
!     character(len=*), intent(in), optional :: FORMAT
!     integer, intent(in), optional :: LBOUND ! Low bound for Array
!     character(len=*), iptional, intent(in) :: OPTIONS
! 
!     double precision, dimension(size(array1)) :: array1
!     double precision, dimension(size(array2)) :: array2
    integer, parameter :: MAXPCTS = 10
    logical :: NaNsIn1, NaNsIn2
    character(len=64) :: DiffName
    real(kind(array1)), dimension(3, MAXPCTS):: array1AtNAbs
    real(kind(array1)), dimension(3, MAXPCTS):: array2AtNAbs
    real(kind(array1)), dimension(3, MAXPCTS):: array1AtNRel
    real(kind(array1)), dimension(3, MAXPCTS):: array2AtNRel
    real(kind(array1)), dimension(2)         :: exvalues
    real(kind(array1)), dimension(2)         :: exratios
    real(kind(array1)), dimension(MAXPCTS)   :: gaps
    type(Stat_T), dimension(MAXPCTS)         :: gapStat
    real(kind(array1)), dimension(MAXPCTS)   :: gapratios
    type(Stat_T), dimension(MAXPCTS)         :: gapRatioStat
    real(kind(array1))                       :: minratio
    real(kind(array1))                       :: maxratio
    real(kind(array1))                       :: medianratio
    real(kind(array1))                       :: meanratio
    integer                                  :: numTot
    integer                                  :: numEqual
    real(kind(array1))                       :: pctDiff
    real(kind(array1))                       :: pctEqual
    real(kind(array1)), dimension(MAXPCTS)   :: pcts
    real(kind(array1)), dimension(MAXPCTS)   :: pctratios
    real(kind(array1)), dimension(MAXPCTS)   :: pctMaxGaps
    real(kind(array1)), dimension(MAXPCTS)   :: pctMaxGapAsRatios
    real(kind(array1)), dimension(MAXPCTS)   :: pctMeanGaps
    real(kind(array1)), dimension(MAXPCTS)   :: pctMaxRatios
    real(kind(array1)), dimension(MAXPCTS)   :: pctMaxRatioAsGaps
    real(kind(array1)), dimension(MAXPCTS)   :: pctMeanRatios
    real(kind(array1))                       :: rmsratio
    real(kind(array1))                       :: stddev
    real(kind(array1))                       :: stddevratio
    real                                     :: sTime
    real                                     :: t1
    real                                     :: t2
    real(kind(array1)), dimension(MAXPCTS,7) :: table
    logical, parameter                       :: PRINTREFERENCEVALUES = .false.
    logical, parameter                       :: PRINTMINMAXWITHRMS = .true.
    logical, parameter                       :: USEDUMPTABLE = .true.
    ! character(len=*), parameter      :: HEADSIDE = 'top'
    logical, parameter               :: DEBUG = .false.
    real(kind(array1)), dimension(MAXPCTS), parameter :: PCTAGES = &
      & (/ 99.9, 99.8, 99.7, 99.5, 99., 98., 97., 95., 90., 80. /)
    real, dimension(MAXPCTS), parameter :: PCTFACTORS = &
      & (/ .01, .02, .05, .1, .2, .5, 1., 2., 5., 10. /)
    logical, parameter :: unique = .false. 
    ! Executable
    t1 = 0.
    t2 = 0.
    sTime = 0.
    thisIsADiff = .true.  ! For special dumps
    myPCTFormat  = DEFAULTPCTFORMAT
    if ( PCTFORMAT /= '*' ) myPCTFormat = PCTFORMAT
    myClean      = theDefault('clean') ! .false.
    myDirect     = theDefault('direct') ! .false.
    myGaps       = theDefault('gaps')
    myRMS        = theDefault('rms')   ! .false.
    myStats      = theDefault('stat')  ! .false.
    myTable      = theDefault('table')  ! .false.
    myTranspose  = theDefault('transpose')  ! .false.
    myTrim       = theDefault('trim')  ! .false.
    myUnique     = theDefault('unique')
    myWholeArray = theDefault('wholearray') .or. &
        & .not. (myStats .or. myRMS.or. myTable)
    if ( present(options) ) then
      myClean       = index( options, 'c' ) > 0
      myDirect      = index( options, 'd' ) > 0
      myGaps        = index( options, 'g' ) > 0
      myRMS         = index( options, 'r' ) > 0
      myStats       = index( options, 's' ) > 0
      myTable       = index( options, 'b' ) > 0
      myTranspose   = index( options, 'p' ) > 0
      myTrim        = index( options, 't' ) > 0
      myUnique      = index( options, 'u' ) > 0
      myWholeArray  = ( index( options, 'w' ) > 0 ) .or. &
        & .not. (myStats .or. myRMS.or. myTable)
    endif

    if ( len_trim(name2) < 1 ) then
      DiffName = trim(name1) // ' (diff)'
    else
      DiffName = trim(name1) // ' - ' // trim(name2)
    endif

    if ( DEBUG ) then
      call outputNamedValue( 'myStats', myStats )
      call outputNamedValue( 'myRMs', myRMS)
      call outputNamedValue( 'myTable', myTable )
      call outputNamedValue( 'myWholeArray', myWholeArray )
    endif
    if ( myWholeArray ) then
      call dump(array1-array2, trim(DiffName), &
      & real(0.,kind(array1)), WIDTH, FORMAT, &
      & LBOUND, OPTIONS )
      return
    endif
    
    NaNsIn1 = any(.not. ieee_is_finite(array1))
    if ( NaNsIn1 .and. myDirect ) then
      call output( &
        & '*** skipping: non finite values found in ' // trim(name1), advance='yes')
      return
    endif
    if ( NaNsIn1 ) then
      if ( .not. any(ieee_is_finite(array1)) ) then
        call output( &
          & '*** skipping: no finite values found in ' // trim(name1), advance='yes')
        return
      endif
      call output( &
        & '*** non-finite values found in ' // trim(name1), advance='yes')
      call WhereAreTheInfs ( array1, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(Infs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
      call WhereAreTheNaNs ( array1, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(NaNs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
    endif

    NaNsIn2 = any(.not. ieee_is_finite(array2))
    if ( NaNsIn1 .and. myDirect ) then
      call output( &
        & '*** skipping: non finite values found in ' // trim(name2), advance='yes')
      return
    endif
    if ( NaNsIn2 ) then
      if ( .not. any(ieee_is_finite(array2)) ) then
        call output( &
          & '*** skipping: no finite values found in ' // trim(name2), advance='yes')
        return
      endif
      call output( &
        & '*** non-finite values found in ' // trim(name2), advance='yes')
      call WhereAreTheInfs ( array2, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(Infs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
      call WhereAreTheNaNs ( array2, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(NaNs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
    endif

    if ( DEBUG ) call SayTime( 'Checking for NaNs and Infs', stime )
    stime = t2
    if ( all(array1 == array2) ) then
      call output( '(The two arrays are exactly equal)', advance='yes' )
      return
    endif
    if ( myRMS ) then
      call allstats(array1, &
        & addedData=.false., min=refmin, max=refmax, rms=refrms)
      call allstats(array2, &
        & addedData=.true., min=refmin, max=refmax, rms=refrms)
      if ( PRINTREFERENCEVALUES ) &
        & call printRMSetc ( 'Reference values', refmin, refmax, refrms )
    endif
    if ( DEBUG ) call SayTime( 'statistics', stime )
    stime = t2
    call fillPcts
    if ( DEBUG ) call SayTime( 'percentages', stime )
    stime = t2
    call usePcts
    if ( DEBUG ) call SayTime( 'ratios', stime )
    stime = t2
    call dump(array1-array2, trim(DiffName), &
      & real(0.,kind(array1)), WIDTH, FORMAT, &
      & LBOUND, OPTIONS )
    if ( DEBUG ) call SayTime( 'dump', stime )
    stime = t2
    call doneWithDiff
    if ( DEBUG ) call output( 'DoneWithDiff', advance='yes' )
  contains
    subroutine doneWithDiff
      ! Internal variables
      character(len=12), dimension(7) :: formats
      character(len=16) :: originalSDFormat
      !
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      thisIsADiff = .false.   ! Reset
      if ( .not. PRINTMINMAXWITHRMS ) return
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      if ( DEBUG ) call outputNamedValue( 'maxarr(1-2)', maxval(array1-array2))
      if ( SHORTCUTDIFFS .and. &
        & (numEqual == numTot .or. stddev == real(0., kind(stddev))) ) then
        exvalues = real(0., kind(stddev))
        exratios = real(0., kind(stddev))
        minratio = real(0., kind(stddev))
        maxratio = real(0., kind(stddev))
        meanratio = real(0., kind(stddev))
        rmsratio = real(0., kind(stddev))
        medianratio = real(0., kind(stddev))
      else
        call ratios( array1, array2, exvalues, exratios, &
          & minratio, maxratio, meanratio, stddevratio, rmsratio, medianratio, &
          & op='-' )
      endif
      if ( myRMS ) then
        call output( 'Maximum difference: ', advance='no' )
        call output( exvalues(1), advance='no' )
        call output( '  ( as ratio:  ', advance='no' )
        call output( exratios(1), advance='no' )
        call output( ' )', advance='yes' )
        call output( 'Maximum ratio: ', advance='no' )
        call output( exratios(2), advance='no' )
        call output( '  ( as difference:  ', advance='no' )
        call output( exvalues(2), advance='no' )
        call output( ' )', advance='yes' )
        call printRMSetc( 'ratio', minratio, maxratio, rmsratio, meanratio )
      endif
      if ( myTABLE ) then
        call output( '% of arrays nearer than', advance='yes' )
        table(:,1) = gaps
        table(:,2) = pcts
        table(:,3) = gapratios
        table(:,4) = pctratios
        formats(1:3:2) = rmsFormat
        formats(2:4:2) = myPCTFormat ! '(0pf6.1)'
        call dumpTable ( table(:,1:4), &
          & (/ 'abs diff', &
          &    '%       ', &
          &    'as ratio', &
          &    '%       ' /), &
          & headside=dumpTableSide, formats=formats(1:4) )
        call output( 'By keeping the closest % of arrays', advance='yes' )
        table(:,1) = pctAges
      if ( SHORTCUTDIFFS .and. &
        & (numEqual == numTot .or. stddev == real(0., kind(stddev))) ) then
          table(:,2:7) = real(0., kind(stddev))
        else
          table(:,2) = pctMaxGaps
          table(:,3) = pctMaxGapAsRatios
          table(:,4) = pctMeanGaps
          table(:,5) = pctMaxRatios
          table(:,6) = pctMaxRatioAsGaps
          table(:,7) = pctMeanRatios
        endif
        formats(2:7) = rmsFormat
        formats(1) = myPCTFormat ! '(0pf6.1)'
        call dumpTable ( table, &
          & (/ '%          ', &
          &    'max diffs  ', &
          &    '(as ratio) ', &
          &    'mean diffs ', &
          &    'max ratios ', &
          &    '(as abs)   ', &
          &    'mean ratios' /), &
          & headside=dumpTableSide, formats=formats )
      endif
      if ( myStats ) then
        ! Now to show how near the two arrays are
        call output( '% of arrays equal ', advance='no' )
        call output( pctEqual, format = myPCTFormat, advance='no' )
        call output( '  (number of elements ', advance='no' )
        call output( numEqual, advance='no' )
        call output( ')', advance='yes' )
        call output( '% of arrays diff  ', advance='no' )
        call output( pctDiff, format = myPCTFormat, advance='no' )
        call output( '  (number of elements ', advance='no' )
        call output( numTot - numEqual, advance='no' )
        call output( ')', advance='yes' )
      endif
      outputOptions%sdFormatDefault = originalSDFormat
      
    end subroutine doneWithDiff

    subroutine fillPcts
      ! Executable
      numTot = max( 1, product(shape(array1)) )
      numEqual = count( array1 == array2 )
      pctEqual = (100.*numEqual)/numTot
      pctDiff = 100. - pctEqual
      stddev = mlsstddev( array1-array2 )
      gaps = PCTFACTORS*stddev
      call hownear( array1, array2, pcts, gaps=gaps )
      if ( DEBUG ) then
        call outputNamedValue( 'maxarr(1-2)', maxval(array1-array2))
        call outputNamedValue( 'stddev', stddev)
        call outputNamedValue( 'gaps(1)', gaps(1))
      endif
      call ratios( array1, array2, exvalues, exratios, &
        & stddevratio=stddevratio, op='-' )
      gapratios = pctFactors*stddevratio
      call hownear( array1, array2, pctratios, gapratios=gapratios )
    end subroutine fillPcts

    subroutine usePcts
      ! Internal variables
      integer :: i
      real(kind(array1)) :: absdiff
      ! Executable
      do i=1, MAXPCTS
        call reset(gapstat(i))
        call reset(gapratiostat(i))
      enddo
      call howfar( array1, array2, pctages, &
        & gaps=gapstat, mode='abs', array1AtN=array1AtNAbs, &
        & array2AtN=array2AtNAbs )
      call howfar( array1, array2, pctages, &
        & gaps=gapRatiostat, mode='rel', array1AtN=array1AtNRel, &
        & array2AtN=array2AtNRel )
      if ( DEBUG ) then
        call outputNamedValue( 'maxarrpcts(1-2)', maxval(array1-array2))
        call outputNamedValue( 'pctMaxGaps(1)', pctMaxGaps(1))
        call outputNamedValue( 'pctMaxRatios(1)', pctMaxRatios(1))
      endif
      pctMaxGaps = gapStat%max
      pctMeanGaps = gapStat%mean
      pctMaxRatios = gapRatioStat%max
      pctMeanRatios = gapRatioStat%mean
      do i=1, MAXPCTS
        pctMaxGapAsRatios(i) = 0.
        absdiff = abs( array1AtNAbs(1, i) - array2AtNAbs(1, i) )
        if ( absdiff > real(0.,kind(array1)) ) pctMaxGapAsRatios(i) = &
          &  absdiff / max( abs(array1AtNAbs(1, i)), abs(array2AtNAbs(1, i)) )
        pctMaxRatioAsGaps(i) = abs( array1AtNRel(1, i) - array2AtNRel(1, i) )
      enddo
    end subroutine usePcts

  subroutine SayTime ( What, startTime )
    character(len=*), intent(in) :: What
    real, intent(in), optional :: startTime
    real :: myt1
    if ( present(startTime) ) then
      myt1 = startTime
    else
      myt1 = t1
    endif
    call time_now ( t2 )
    call output ( "Timing for " // what // " = " )
    call output ( dble(t2 - myt1), advance = 'yes' )
  end subroutine SayTime

!   end subroutine DIFF_1D_DOUBLE
! $Log$
! Revision 2.5  2009/10/13 00:05:03  pwagner
! Should print rms figures only when requested to
!
! Revision 2.4  2009/09/10 20:59:12  pwagner
! 3 ways to summarize diffs: 'b' (table), 'r' (rms), 's' (number of differences)
!
! Revision 2.3  2009/08/17 18:05:14  pwagner
! direct option skips diffing if non-finite values found
!
! Revision 2.2  2009/06/16 17:12:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.1  2008/11/24 19:38:08  pwagner
! First commit
!
