! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$
    subroutine doneWithDiff
      ! Internal variables
      character(len=12), dimension(7) :: formats
      character(len=16) :: originalSDFormat
      !
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      thisIsADiff = .false.   ! Reset
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      if ( DEBUG ) call outputNamedValue( 'maxval(1-2)', maxval(Array1-Array2))
      if ( SHORTCUTDIFFS .and. &
        & (numEqual == numTot .or. stddev == real(0., kind(stddev))) ) then
        exvalues = real(0., kind(stddev))
        exratios = real(0., kind(stddev))
        minratio = real(0., kind(stddev))
        maxratio = real(0., kind(stddev))
        meanratio = real(0., kind(stddev))
        rmsratio = real(0., kind(stddev))
        medianratio = real(0., kind(stddev))
      else
        ! Note that if alreadySbtrcted we don't need to subtract again
        if ( alreadySbtrcted ) then
          call ratios( Array1, Array2, exvalues, exratios, &
            & minratio, maxratio, meanratio, stddevratio, rmsratio, medianratio )
          call allstats( Array1, min=minvalue, max=maxvalue, mean=meanvalue, &
            & rms=rmsvalue, median=medianvalue, fillValue=FillValue )
        else
          call ratios( Array1, Array2, exvalues, exratios, &
            & minratio, maxratio, meanratio, stddevratio, rmsratio, medianratio, &
            & op='-' )
          call allstats( array2-array1, min=minvalue, max=maxvalue, mean=meanvalue, &
            & rms=rmsvalue, median=medianvalue )
        end if
      end if
      if ( dopts(AuBrick)%v ) then
        call PrintName ( DiffName, NameHasBeenPrinted )
        
        call output( ' ** Reference values (min : max, rms): ', advance='no' )
        call output( refmin, advance='no' )
        call output( ' : ', advance='no' )
        call output( refmax, advance='no' )
        call output( ' , ', advance='no' )
        call output( refrms, advance='no' )
        call output( ' **', advance='no' )
        call newLine
        
        call output( ' ** Max. absolute: ', advance='no' )
        call output( exvalues(1), advance='no' )
        call output( ' ( =  ', advance='no' )
        call output( exratios(1), advance='no' )
        call output( ' fractional ) ** ', advance='no' )
        call newLine
        
        call output( ' ** Max. fractional: ', advance='no' )
        call output( exratios(2), advance='no' )
        call output( ' ( =  ', advance='no' )
        call output( exvalues(2), advance='no' )
        call output( ' absolute ) ** ', advance='no' )
        call newLine
      end if
      if ( dopts(myRatios)%v ) then
        call PrintName ( DiffName, NameHasBeenPrinted )
        
        call output( 'Maximum difference: ', advance='no' )
        call output( exvalues(1), advance='no' )
        call output( '  ( as ratio:  ', advance='no' )
        call output( exratios(1), advance='no' )
        call output( ' )', advance='no' )
        call finishLine
        call output( 'Maximum ratio: ', advance='no' )
        call output( exratios(2), advance='no' )
        call output( '  ( as difference:  ', advance='no' )
        call output( exvalues(2), advance='no' )
        call output( ' )', advance='no' )
        call finishLine
        ! nameHasBeenPrinted = .false.
        call printRMSetc( '(ratio)                                   ' // &
          & trim(DiffName), &
          & minratio, maxratio, rmsratio, meanratio )
      end if
      if ( dopts(RMS)%v ) then
        call printRMSetc( 'value', minvalue, maxvalue, rmsvalue, meanvalue )
      end if
      if ( dopts(table)%v ) then
        call PrintName ( DiffName, NameHasBeenPrinted )
        call output( '% of arrays nearer than', advance='yes' )
        theTable(:,1) = gaps
        theTable(:,2) = pcts
        theTable(:,3) = gapratios
        theTable(:,4) = pctratios
        formats(1:3:2) = rmsFormat
        formats(2:4:2) = myPCTFormat ! '(0pf6.1)'
        call dumpTable ( theTable(:,1:4), &
          & (/ 'abs diff', &
          &    '%       ', &
          &    'as ratio', &
          &    '%       ' /), &
          & headside=dumpTableSide, formats=formats(1:4) )
        call output( 'By keeping the closest % of arrays', advance='yes' )
        theTable(:,1) = pctAges
      if ( SHORTCUTDIFFS .and. &
        & (numEqual == numTot .or. stddev == real(0., kind(stddev))) ) then
          theTable(:,2:7) = real(0., kind(stddev))
        else
          theTable(:,2) = pctMaxGaps
          theTable(:,3) = pctMaxGapAsRatios
          theTable(:,4) = pctMeanGaps
          theTable(:,5) = pctMaxRatios
          theTable(:,6) = pctMaxRatioAsGaps
          theTable(:,7) = pctMeanRatios
          formats(2:7) = rmsFormat
          formats(1) = myPCTFormat ! '(0pf6.1)'
        end if
        call PrintName ( DiffName, NameHasBeenPrinted )
        call dumpTable ( theTable, &
          & (/ '%          ', &
          &    'max diffs  ', &
          &    '(as ratio) ', &
          &    'mean diffs ', &
          &    'max ratios ', &
          &    '(as abs)   ', &
          &    'mean ratios' /), &
          & headside=dumpTableSide, formats=formats )
      end if
      if ( dopts(stats)%v ) then
        call PrintName ( DiffName, NameHasBeenPrinted )
        ! Now to show how near the two arrays are
        if ( numNonFill < size(Array1) .and. numNonFill > 0 ) &
          & call outputNamedValue( 'count(NonFill), count(Fill)', &
          & (/ numNonFill, size(Array1) - numNonFill/) )
        if ( NameHasBeenPrinted ) nameOnEachLine = ' '
        call output( '% of arrays equal ', advance='no' )
        call output( pctEqual, format = myPCTFormat, advance='no' )
        call output( '  (number of elements ', advance='no' )
        call output( numEqual, advance='no' )
        call output( ')', advance='no' )
        call finishLine
        call output( '% of arrays diff  ', advance='no' )
        call output( pctDiff, format = myPCTFormat, advance='no' )
        call output( '  (number of elements ', advance='no' )
        call output( numTot - numEqual, advance='no' )
        call output( ')', advance='no' )
        call finishLine
      end if
      outputOptions%sdFormatDefault = originalSDFormat
      NameOnEachLine = ' '
      call theDumpEnds
      
    end subroutine doneWithDiff

    subroutine fillPcts
      ! Executable
      ! numTot = max( 1, product(shape(Array1)) )
      ! numEqual = count( Array1 == Array2 )
      pctEqual = (100.*numEqual)/max(numTot, 1)
      pctDiff = 100. - pctEqual
      stddev = mlsstddev( Array1-Array2 )
      gaps = PCTFACTORS*stddev
      call hownear( Array1, Array2, pcts, gaps=gaps )
      if ( DEBUG ) call outputNamedValue( 'maxval(1-2)', maxval(Array1-Array2))
      call ratios( Array1, Array2, exvalues, exratios, &
        & stddevratio=stddevratio, op='-' )
      gapratios = pctFactors*stddevratio
      call hownear( Array1, Array2, pctratios, gapratios=gapratios )
    end subroutine fillPcts

    subroutine usePcts
      ! Internal variables
      integer :: i, n
      real(kind(Array1)) :: absdiff
      ! Executable
      do i=1, MAXPCTS
        call reset(gapstat(i))
        call reset(gapratiostat(i))
      end do
      ! call howfar( Array1, Array2, pctages, &
      !  & gaps=gapstat, mode='abs' )
      ! call howfar( Array1, Array2, pctages, &
      !  & gaps=gapRatiostat, mode='rel' )
      call howfar( array1, array2, pctages, &
        & gaps=gapstat, mode='abs', array1AtN=array1AtNAbs, &
        & array2AtN=array2AtNAbs )
      call howfar( array1, array2, pctages, &
        & gaps=gapRatiostat, mode='rel', array1AtN=array1AtNRel, &
        & array2AtN=array2AtNRel )
      pctMaxGaps = gapStat%max
      pctMeanGaps = gapStat%mean
      pctMaxRatios = gapRatioStat%max
      pctMeanRatios = gapRatioStat%mean
      do i=1, MAXPCTS
        n = gapStat(i)%indexing(1)
        if ( n < 1 ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'unable to locate max of abs in filterediff' )
          cycle
        end if
        pctMaxGapAsRatios(i) = 0.
        ! absdiff = abs( Array1(n) - Array2(n) )
        ! if ( absdiff > real(0.,kind(Array1)) ) pctMaxGapAsRatios(i) = &
        !  &  absdiff / max( abs(Array1(n)), abs(Array2(n)) )
        n = gapRatioStat(i)%indexing(1)
        if ( n < 1 ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'unable to locate max of ratio in filterediff' )
          cycle
        end if
        ! pctMaxRatioAsGaps(i) = abs( Array1(n) - Array2(n) )
        absdiff = abs( array1AtNAbs(1, i) - array2AtNAbs(1, i) )
        if ( absdiff > real(0.,kind(Array1)) ) pctMaxGapAsRatios(i) = &
          &  absdiff / max( abs(array1AtNAbs(1, i)), abs(array2AtNAbs(1, i)) )
        pctMaxRatioAsGaps(i) = abs( array1AtNRel(1, i) - array2AtNRel(1, i) )
      end do
    end subroutine usePcts

  subroutine SayTime ( What, startTime )
    character(len=*), intent(in) :: What
    real, intent(in), optional :: startTime
    real :: myt1
    if ( present(startTime) ) then
      myt1 = startTime
    else
      myt1 = t1
    end if
    call time_now ( t2 )
    call output ( "Timing for " // what // " = " , advance='no' )
    call output ( dble(t2 - myt1), advance = 'yes' )
  end subroutine SayTime

! $Log$
! Revision 2.5  2018/02/28 19:52:40  pwagner
! Tries to prevent unwanted names on each line
!
! Revision 2.4  2017/07/31 23:08:52  pwagner
! Calls theDumpEnds on exit
!
! Revision 2.3  2017/07/19 22:47:22  pwagner
! Use PrintName procedure; pass DiffName to printRMSetc
!
! Revision 2.2  2017/07/10 18:32:57  pwagner
! Take greater care with printing DiffName
!
! Revision 2.1  2016/10/06 20:19:26  pwagner
! First commit
!
