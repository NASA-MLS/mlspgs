! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! subroutine Longest_Monotone_Subsequence ( A, Seq, Dir )
!   type(?), intent(in) :: A(:)
!   integer, allocatable :: Seq(:)
!   integer, intent(in), optional :: Dir ! Direction, default +1 => increasing

! This was adapted from a web page where zero-origin indexing was used.  That's
! why A, P and M have zero-origin arrays.  At the end, SEQ is computed for
! 1-origin indexing.

    integer :: P(0:size(a)-1), M(0:size(a))
    integer :: Hi, I, K, L, Lo, Mid, MyDir, NewL

    myDir = +1
    if ( present(dir) ) myDir = sign(1,dir)

    l = 0
    m(1) = 0
    do i = 0, size(a)-1
      ! Binary search for largest positive j <= l such that a(m(j)) < a(i)
      lo = 1
      hi = l
      do while ( lo <= hi )
        mid = ( lo + hi + 1 ) / 2
        if ( myDir*a(m(mid)) < myDir*a(i) ) then
          lo = mid + 1
        else
          hi = mid -1
        end if
      end do

      ! Lo is now 1 greater than the length of the longest prefix of a(i)

      newL = lo

      ! The predecessor of a(i) is the last index of the subsequence of
      ! length newL - 1

      p(i) = m(newL-1)
      m(newL) = i

      ! If we found a subsequence longer than any we've found, update L
      l = max(l, newL)

    end do

    ! Construct indices of the longest monotone subsequence
    if ( allocated(seq) ) then
      if ( size(seq) /= l ) deallocate ( seq )
    end if
    if ( .not. allocated(seq) ) allocate ( seq(l) )
    k = m(l)
    do i = l, 1, -1
      seq(i) = k + 1
      k = p(k)
    end do

! $Log$
! Revision 2.1  2015/04/04 01:38:25  vsnyder
! Initial commit
!
