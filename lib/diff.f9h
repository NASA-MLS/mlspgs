! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

!   subroutine DIFF_1D_DOUBLE ( ARRAY1, NAME1, ARRAY2, NAME2, &
!     & FILLVALUE, CLEAN, WIDTH, FORMAT, WHOLEARRAY, STATS, RMS, LBOUND )
!     double precision, intent(in) :: ARRAY1(:)
!     character(len=*), intent(in), optional :: NAME1
!     double precision, intent(in) :: ARRAY2(:)
!     character(len=*), intent(in), optional :: NAME2
!     double precision, intent(in), optional :: FILLVALUE
!     logical, intent(in), optional :: CLEAN
!     integer, intent(in), optional :: WIDTH
!     character(len=*), intent(in), optional :: FORMAT
!     logical, intent(in), optional :: WHOLEARRAY
!     logical, intent(in), optional :: STATS
!     logical, intent(in), optional :: RMS
!     integer, intent(in), optional :: LBOUND ! Low bound for Array
! 
!     double precision, dimension(size(array1)) :: filtered1
!     double precision, dimension(size(array2)) :: filtered2
    integer, parameter :: MAXPCTS = 10
    logical :: warn, NaNsIn1, NaNsIn2, alreadySbtrcted
    ! This is terrible: don't use lengths of optional args
    ! character(len(name1) + len(name2) + 8) :: DiffName
    character(len=64) :: DiffName
    integer :: i
    double precision :: tmax
    real(kind(array1)), dimension(2)      :: exvalues
    real(kind(array1)), dimension(2)      :: exratios
    real(kind(array1)), dimension(MAXPCTS):: gaps
    type(Stat_T), dimension(MAXPCTS)      :: gapStat
    real(kind(array1)), dimension(MAXPCTS):: gapratios
    type(Stat_T), dimension(MAXPCTS)      :: gapRatioStat
    real(kind(array1))                    :: minratio
    real(kind(array1))                    :: maxratio
    real(kind(array1))               :: medianratio
    real(kind(array1))               :: meanratio
    real(kind(array1))               :: rmsratio
    real(kind(array1))               :: stddev
    real(kind(array1))               :: stddevratio
    logical, parameter               :: PRINTREFERENCEVALUES = .false.
    logical, parameter               :: PRINTMINMAXWITHRMS = .true.
    logical, parameter               :: USEDUMPTABLE = .true.
    ! character(len=*), parameter      :: HEADSIDE = 'top'
    logical, parameter               :: DEBUG = .false.
    real(kind(array1)), dimension(MAXPCTS), parameter :: PCTAGES = &
      & (/ 99.9, 99.8, 99.7, 99.5, 99., 98., 97., 95., 90., 80. /)
    real, dimension(MAXPCTS), parameter :: PCTFACTORS = &
      & (/ .01, .02, .05, .1, .2, .5, 1., 2., 5., 10. /)
    real(kind(array1)), dimension(MAXPCTS) :: pcts
    real(kind(array1)), dimension(MAXPCTS) :: pctratios
    real(kind(array1)), dimension(MAXPCTS) :: pctMaxGaps
    real(kind(array1)), dimension(MAXPCTS) :: pctMaxGapAsRatios
    real(kind(array1)), dimension(MAXPCTS) :: pctMeanGaps
    real(kind(array1)), dimension(MAXPCTS) :: pctMaxRatios
    real(kind(array1)), dimension(MAXPCTS) :: pctMaxRatioAsGaps
    real(kind(array1)), dimension(MAXPCTS) :: pctMeanRatios
    real(kind(array1)), dimension(MAXPCTS,7) :: table
    logical, parameter :: unique = .false. 
    ! Executable
    thisIsADiff = .true.  ! For special dumps
    alreadySbtrcted = .false.
    myStats = .false.
    if ( present(stats) ) myStats = stats
    myRMS = .false.
    if ( present(RMS) ) myRMS = RMS

    if ( len_trim(name2) < 1 ) then
      DiffName = trim(name1) // ' (diff)'
    else
      DiffName = trim(name1) // ' - ' // trim(name2)
    endif

    myWholeArray = .not. (myStats .or. myRMS)
    if ( DEBUG ) then
      call outputNamedValue( 'myStats', myStats )
      call outputNamedValue( 'myRMS', myRMS )
      call outputNamedValue( 'myWholeArray', myWholeArray )
    endif
    if ( myWholeArray ) then
      call dump(array1-array2, trim(DiffName), &
      & real(0.,kind(array1)), CLEAN, WIDTH, FORMAT, &
      & WHOLEARRAY, STATS, RMS, unique, LBOUND )
      return
    endif
    if ( present(wholeArray) ) myWholeArray = wholeArray
    
    NaNsIn1 = any(.not. ieee_is_finite(array1))
    if ( NaNsIn1 ) then
      if ( .not. any(ieee_is_finite(array1)) ) then
        call output( &
          & '*** skipping: no finite values found in ' // trim(name1), advance='yes')
        return
      endif
      call output( &
        & '*** non-finite values found in ' // trim(name1), advance='yes')
      call WhereAreTheInfs ( array1, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(Infs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
      call WhereAreTheNaNs ( array1, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(NaNs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
    endif

    NaNsIn2 = any(.not. ieee_is_finite(array2))
    if ( NaNsIn2 ) then
      if ( .not. any(ieee_is_finite(array2)) ) then
        call output( &
          & '*** skipping: no finite values found in ' // trim(name2), advance='yes')
        return
      endif
      call output( &
        & '*** non-finite values found in ' // trim(name2), advance='yes')
      call WhereAreTheInfs ( array2, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(Infs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
      call WhereAreTheNaNs ( array2, which, how_many )
      if ( how_many > 0 ) then
        call outputNamedValue( 'num(NaNs)', how_many )
        if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
      endif
    endif

    call filterValues(reshape( array1, (/ product(shape(array1)) /) ), &
      & filtered1, &
      & reshape( array2, (/ product(shape(array2)) /) ), &
      & filtered2, &
      & warn, FillValue)
    if ( warn ) call output( &
      & '*** non-matched NaNs diffing ' // trim(DiffName), &
      & advance='yes')

    call ReplaceFillValues( filtered1, FillValue, newFill=real(0., kind(FillValue)) )
    call ReplaceFillValues( filtered2, FillValue, newFill=real(0., kind(FillValue)) )
    if ( all(filtered1 == filtered2) ) then
      call output( '(The two arrays are exactly equal)', advance='yes' )
      return
    endif
    if ( myRMS ) then
      ! We want to make sure we remove values from both arrays where either is fill
      if ( DEBUG ) call outputNamedValue( 'filtering FillValue', FillValue )
      filtered1 = reshape( array1, (/ product(shape(array1)) /) )
      filtered2 = reshape( array2, (/ product(shape(array2)) /) )
      where (filtered1 == FillValue)
        filtered2 = FillValue
      end where
      where (filtered2 == FillValue)
        filtered1 = FillValue
      end where
      numNonFill = count(filtered1 /= FillValue)
      call ReorderFillValues ( filtered1, FillValue )
      call ReorderFillValues ( filtered2, FillValue )
      call allstats(filtered1(1:numNonFill), &
        & addedData=.false., min=refmin, max=refmax, rms=refrms)
      call allstats(filtered2(1:numNonFill), &
        & addedData=.true., min=refmin, max=refmax, rms=refrms)
      if ( PRINTREFERENCEVALUES ) &
        & call printRMSetc ( 'Reference values', refmin, refmax, refrms )
      ! call dump ( filtered1, 'filtered1', fillvalue=fillvalue )
      ! call dump ( filtered2, 'filtered2', fillvalue=fillvalue )
      call fillPcts
      call usePcts
      ! Prepare to find abs, relative differences
      ! Avoid another automatic array
      do i=1, size(filtered1)
        tmax = max( abs(filtered1(i)), abs(filtered2(i)) )
        filtered1(i) = filtered1(i) - filtered2(i)
        filtered2(i) = tmax
      enddo
      ! call dump ( filtered1, 'filtered1-filtered2', fillvalue=real(0.,kind(array1)) )
      ! call outputNamedValue( 'num /= fill value', numNonFill )
      alreadySbtrcted = .true.
      if ( myWholeArray ) then
        call dump(filtered1, trim(DiffName), &
          & real(0.,kind(array1)), CLEAN, WIDTH, FORMAT, &
          & WHOLEARRAY, STATS, RMS, unique, LBOUND )
      else
        call dump( filtered1(1:numNonFill), trim(DiffName), &
          & real(0.,kind(array1)), CLEAN, WIDTH, FORMAT, &
          & WHOLEARRAY, STATS, RMS, unique, LBOUND )
      endif
      if ( DEBUG ) call output( 'DoneWithDiff', advance='yes' )
      call doneWithDiff
      return
      if ( PRINTREFERENCEVALUES ) &
        & call printRMSetc ( 'Reference values', refmin, refmax, refrms )
    endif
    if ( .not. alreadySbtrcted ) then
      call fillPcts
      call usePcts
      ! Prepare to find abs, relative differences
      ! Avoid another automatic array
      do i=1, size(filtered1)
        tmax = max( abs(filtered1(i)), abs(filtered2(i)) )
        filtered1(i) = filtered1(i) - filtered2(i)
        filtered2(i) = tmax
      enddo
    endif
    call dump(filtered1, trim(DiffName), &
      & real(0.,kind(array1)), CLEAN, WIDTH, FORMAT, &
      & WHOLEARRAY, STATS, RMS, unique, LBOUND )
    call doneWithDiff
    if ( DEBUG ) call output( 'DoneWithDiff', advance='yes' )
  contains
    subroutine doneWithDiff
      ! Internal variables
      character(len=12), dimension(7) :: formats
      character(len=16) :: originalSDFormat
      !
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      thisIsADiff = .false.   ! Reset
      if ( .not. PRINTMINMAXWITHRMS ) return
      originalSDFormat = outputOptions%sdFormatDefault
      outputOptions%sdFormatDefault = rmsFormat
      call ratios( filtered1, filtered2, exvalues, exratios, &
        & minratio, maxratio, meanratio, stddevratio, rmsratio, medianratio )
      call output( 'Maximum difference: ', advance='no' )
      call output( exvalues(1), advance='no' )
      call output( '  ( as ratio:  ', advance='no' )
      call output( exratios(1), advance='no' )
      call output( ' )', advance='yes' )
      call output( 'Maximum ratio: ', advance='no' )
      call output( exratios(2), advance='no' )
      call output( '  ( as difference:  ', advance='no' )
      call output( exvalues(2), advance='no' )
      call output( ' )', advance='yes' )
      call printRMSetc( 'ratio', minratio, maxratio, rmsratio, meanratio )
      if ( myStats .and. USEDUMPTABLE ) then
        call output( '% of arrays nearer than', advance='yes' )
        table(:,1) = gaps
        table(:,2) = pcts
        table(:,3) = gapratios
        table(:,4) = pctratios
        formats(1:3:2) = rmsFormat
        formats(2:4:2) = '(0pf6.1)'
        call dumpTable ( table(:,1:4), &
          & (/ 'abs diff', &
          &    '%       ', &
          &    'as ratio', &
          &    '%       ' /), &
          & headside=dumpTableSide, formats=formats(1:4) )
        call output( 'By keeping the closest % of arrays', advance='yes' )
        table(:,1) = pctAges
        table(:,2) = pctMaxGaps
        table(:,3) = pctMaxGapAsRatios
        table(:,4) = pctMeanGaps
        table(:,5) = pctMaxRatios
        table(:,6) = pctMaxRatioAsGaps
        table(:,7) = pctMeanRatios
        formats(2:7) = rmsFormat
        formats(1) = '(0pf6.1)'
        call dumpTable ( table, &
          & (/ '%          ', &
          &    'max diffs  ', &
          &    '(as ratio) ', &
          &    'mean diffs ', &
          &    'max ratios ', &
          &    '(as abs)   ', &
          &    'mean ratios' /), &
          & headside=dumpTableSide, formats=formats )
      elseif ( myStats ) then
        ! Now to show how near the two arrays are
        call output( '% of arrays nearer than', advance='yes' )
        call output( '(abs diff) ', advance='no' )
        call output( gaps, advance='yes' )
        call output( '%          ', advance='no' )
        call output( pcts, advance='yes' )
        call output( '(ratio diff) ', advance='no' )
        call output( gapratios, advance='yes' )
        call output( '%            ', advance='no' )
        call output( pctratios, advance='yes' )
        call output( 'By keeping the closest % of arrays', advance='yes' )
        call output( '%          ', advance='no' )
        call output( pctAges, FORMAT='(0pf8.1)', advance='yes' )
        call output( '(max diffs) ', advance='no' )
        call output( pctMaxGaps, advance='yes' )
        call output( '(mean diffs) ', advance='no' )
        call output( pctMeanGaps, advance='yes' )
        call output( '(max ratios) ', advance='no' )
        call output( pctMaxRatios, advance='yes' )
        call output( '(mean ratios) ', advance='no' )
        call output( pctMeanRatios, advance='yes' )
      endif
      outputOptions%sdFormatDefault = originalSDFormat
      
    end subroutine doneWithDiff

    subroutine fillPcts
      stddev = mlsstddev( filtered1-filtered2 )
      gaps = PCTFACTORS*stddev
      call hownear( filtered1, filtered2, pcts, gaps=gaps )
      call ratios( filtered1, filtered2, exvalues, exratios, &
        & stddevratio=stddevratio, op='-' )
      gapratios = pctFactors*stddevratio
      call hownear( filtered1, filtered2, pctratios, gapratios=gapratios )
    end subroutine fillPcts

    subroutine usePcts
      ! Internal variables
      integer :: i, n
      real(kind(array1)) :: absdiff
      ! Executable
      do i=1, MAXPCTS
        call reset(gapstat(i))
        call reset(gapratiostat(i))
      enddo
      call howfar( filtered1, filtered2, pctages, &
        & gaps=gapstat, mode='abs' )
      call howfar( filtered1, filtered2, pctages, &
        & gaps=gapRatiostat, mode='rel' )
      pctMaxGaps = gapStat%max
      pctMeanGaps = gapStat%mean
      pctMaxRatios = gapRatioStat%max
      pctMeanRatios = gapRatioStat%mean
      do i=1, MAXPCTS
        n = gapStat(i)%indexing(1)
        if ( n < 1 ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'unable to locate max of abs in filterediff' )
          cycle
        endif
        pctMaxGapAsRatios(i) = 0.
        absdiff = abs( filtered1(n) - filtered2(n) )
        if ( absdiff > real(0.,kind(array1)) ) pctMaxGapAsRatios(i) = &
          &  absdiff / max( abs(filtered1(n)), abs(filtered2(n)) )
        n = gapRatioStat(i)%indexing(1)
        if ( n < 1 ) then
          call MLSMessage ( MLSMSG_Warning, ModuleName, &
            & 'unable to locate max of ratio in filterediff' )
          cycle
        endif
        pctMaxRatioAsGaps(i) = abs( filtered1(n) - filtered2(n) )
      enddo
    end subroutine usePcts

!   end subroutine DIFF_1D_DOUBLE
! $Log$
! Revision 2.17  2008/11/24 19:35:15  pwagner
! Less wasteful of memory; should not segment dault so often
!
! Revision 2.16  2008/06/18 20:44:30  pwagner
! dump subroutine has new optonal arg 'unique'
!
! Revision 2.15  2008/02/07 18:45:21  pwagner
! Will not go through rms, stats, etc. if diffs all zero
!
! Revision 2.14  2008/01/09 20:54:03  pwagner
! When NaNs short-circuit dump or diff, print how many and where
!
! Revision 2.13  2007/10/24 23:58:49  pwagner
! pct summaries now include columns '(as ratio)', '(as abs)'
!
! Revision 2.12  2007/10/18 23:38:29  pwagner
! May use dumpTable for nicer formatting
!
! Revision 2.11  2007/10/12 23:34:49  pwagner
! Using new howfar procedure to summarize diffs after peeling away outliers
!
! Revision 2.10  2007/09/13 21:08:57  pwagner
! -rms and -s combined add new info about & how near
!
! Revision 2.9  2007/07/16 23:32:33  pwagner
! Improved rms-type diffs to concentrate on ratios
!
! Revision 2.8  2007/06/07 20:31:52  pwagner
! Avoid using lengths of optional args
!
! Revision 2.7  2006/06/24 23:07:55  pwagner
! Changes to reduce memory footprint computing statistics
!
! Revision 2.6  2006/03/15 17:34:38  pwagner
! Fixed bug causing incorrect rms when diffing with fill values
!
! Revision 2.5  2006/02/28 21:42:29  pwagner
! Replace fillvalues with 0 before computing rms (should actually remove)
!
! Revision 2.4  2005/12/17 00:58:56  pwagner
! dumps of rms, etc. should appear uniform
!
! Revision 2.3  2005/12/10 00:25:31  pwagner
! Non-essential fussing with debugging commands
!
! Revision 2.2  2005/06/22 17:44:10  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.1  2005/05/12 20:41:11  pwagner
! First commit
!
