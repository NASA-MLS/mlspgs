! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (data type)
! MLSMessageConfig         configuration controlling where to print, etc.
!     (severity levels)
! MLSMSG_Success           status returned when all went well
! MLSMSG_Debug             should print only if debugging turned on
! MLSMSG_Info              fyi only
! MLSMSG_Warning           not fatal, but deserving of attention
! MLSMSG_Error             quits after printing
! MLSMSG_Crash             should give traceback before quitting
! MLSMSG_Testwarning       test to see if we would print this warning
! MLSMSG_Severity_so_far   worst severity level noted so far in this run
! MLSMSG_Severity_to_quit  severity level needed to quit
! MLSMSG_Severity_to_walkback
!                          severity level needed to print callstack
!     (message prefixes for errors during ..)
! MLSMSG_Allocate          allocating an array
! MLSMSG_Fileopen          opening a file
! MLSMSG_Keyword           ???
! MLSMSG_L1BRead           reading an l1b file
! MLSMSG_Duplicate         ???
! MLSMSG_DeAllocate        deallocating an array
! MLSMSG_PVM               using a pvm library procedure

!     (returned status values from MLSMessage_)
! MLSMSGStatus_Normal      Everything normal
! MLSMSGStatus_Suppressed  Did not print msg
! MLSMSGStatus_Stopped     Called with severity >= MLSMSG_Severity_to_quit
! MLSMSGStatus_Dumped      Called with severity >= MLSMSG_Severity_to_walkback

!     (subroutines and functions)
! Crash_burn               crash and burn unless called from an exempt module
! DumpConfig               dump configuration
! RestoreConfig            restore configuration to its default state
! MLSMessage               main messaging routine
! MLSMessageSetup          routine interface to change some parts of MLSMessageConfig
! MLSMessageCalls          manage calling stack 
! MLSMessageClose          close MLSMessage log file; but without exiting
! MLSMessageExit           recommended way to finish main program
! MLSMessageInquire        Returns the requested info
! MLSMessageInternalFile   Returns the complete text that would be printed
! MLSMessageReset          reset flags, counters, etc. during runtime
! PVMErrorMessage          log a PVM error
! ReportTKStatus           converts SDP status to seveMLSMessage.f9hrity, prints if needed
! StopWithErrorMsg         report error msg, dump calling stack, stop
! SummarizeWarnings        show summary of how many warnings received
! === (end of toc) ===

! === (start of api) ===
! Crash_burn ( [char* module_name] )
! DumpConfig ( [MLSMessageConfig_T config] )
! RestoreConfig
! MLSMessage ( int Severity, char* ModuleNameIn, char* Message, 
!      [char* Advance], [MLSFile_T MLSFile], [status] )
! MLSMessageCalls ( char* command, [char* name] )
! MLSMessageClose
! MLSMessageSetup ( [log SuppressDebugs], [int LogFileUnit], [char* Prefix],
!      [log useToolkit], [log CrashOnAnyError] )
! MLSMessageExit ( [int status], [char* farewell] )
! MLSMessageInquire ( [char* Warning_msg], [int timesWarned], &
!    [int totalnumwarnings], [char* LastWarningMsg]  )
! char* MLSMessageInternalFile ( int Severity, char* ModuleNameIn, char* Message, 
!      [char* Advance], [MLSFile_T MLSFile] ) 
! MLSMessageReset ( [int logFileUnit], [log CrashOnAnyError], [log Warnings], &
!       [log clearLastWarning] )
! PVMErrorMessage ( int INFO, char* PLACE  )
! ReportTKStatus( int status, char* ModuleNameIn, char* Message, 
!      [int Threshold] )
! StopWithErrorMsg ( char* Message, [MLSFile_T MLSFile] )
! SummarizeWarnings
! === (end of api) ===
  ! ---------------------------------------------------------------------------

  ! Returned status values of how MLSMessage fared or how message was treated
  integer, public, parameter :: MLSMSGStatus_Normal     = PGS_S_SUCCESS ! == 0
  integer, public, parameter :: MLSMSGStatus_Suppressed = MLSMSGSTATUS_Normal + 1
  integer, public, parameter :: MLSMSGStatus_Stopped    = MLSMSGSTATUS_Suppressed + 1
  integer, public, parameter :: MLSMSGStatus_Dumped     = MLSMSGSTATUS_Stopped + 1

  ! If we are asked to exit, exit with this status instead of using Fortran STOP
  integer, public, parameter :: DEFAULTSTOPEXITSTATUS = 0
  ! So that we may limit the number of times warnings printed, messagewise
  character(len=*), parameter :: WARNINGSSUPPRESSED = '(No more warnings of this)'
  integer, parameter :: MAXNUMWARNINGS = 40 ! was 80, but most tests < 10
  integer, parameter :: WARNINGMESSLENGTH = 80
  integer, parameter :: TOTALNUMWARNINGSMAX = 10000000

  type :: MLSMSGWarnings_T
    character(len=WARNINGMESSLENGTH), dimension(MAXNUMWARNINGS) :: &
      &                   warningmessages = ' '
    integer, dimension(MAXNUMWARNINGS) :: timeswarned = 0
    integer :: numwarnings = 0
    integer :: totalnumwarnings = 0
    character(len=128) :: lastWarningMsg = ' '
    logical :: ALLCAPSSummaries    = .false. ! Print summary msgs in ALL CAPS
  end type MLSMSGWarnings_T

  integer, parameter :: MAXMESSLENGTH = 255 ! Max length to print on one line

  ! This variable describes all the warnings we've recorded
  type (MLSMSGWarnings_T), save :: MLSMSGWarnings

  ! This set of parameters are simple prefixes for common messages
  character (len=*), public, parameter :: MLSMSG_Fileopen = &
     & "Failed to open file: "
  character (len=*), public, parameter :: MLSMSG_Keyword = &
     & "Unrecognized configuration file keyword: "
  character (len=*), public, parameter :: MLSMSG_L1BRead = &
     & "Unable to read L1B data item: "
  character (len=*), public, parameter :: MLSMSG_Duplicate = &
     & "There is already an entry with the name "
  character (len=*), public, parameter :: MLSMSG_PVM = &
     & "PVM Error: "

  ! We add the following because the Intel compiler wraps stdout at 80 columns
  ! when 'FMT=*' but lets it "all hang out" if FMT='(a)'
  logical, private, parameter :: USEDEFAULTFORMATSTDOUT = .false. ! Use FMT=*
  ! This datatype describes the configuration of the messaging suite

 
  ! The following can be used to help trace the sequence of calls that led
  ! to an error; 
  
  ! it will be dumped (if non-blank) on calls to
  ! (1) StopWithErrorMsg
  ! (2) MLSMessage, if MLSMSG_Severity_to_walkback is set appropriately
  ! (3) MLSMessageCalls('dump')
  ! You may push a name onto it, pop a name off, or clear it by
  ! appropriate commands sent with subroutine MLSMessageCalls
  
  ! Note the following limitations:
  ! Each name must be shorter than (MAXSTACKNAMELEN+1) chars.
  ! Strung together, all the names must not exceed MaxTotalStackLen
  ! characters in length
  integer, parameter    ::    MaxStackNameLen  = 64
  integer, parameter    ::    MaxTotalStackLen = 2048
  integer, parameter    ::    MaxStackDepth    = 100
  type :: MLSCallStack_t
    character(len=maxTotalStackLen) :: Txt ! All the names, strung together
    integer :: Ind(0:maxStackDepth) = 0  ! Ind(i) is end of ith name
    integer :: Top = 0         ! Top of the stack, index into Ind
    ! The next two apply only inside MLSCallStack procedures
    logical :: silent  = .false. ! E.g., in case it becomes corrupted
    logical :: verbose = .false.
    ! These dbs affect other modules, letting us store and restore
    ! the amount of extra printing each equires
    logical :: verboseDB(1:maxStackDepth) = .false.
    logical :: debugDB(1:maxStackDepth) = .false.
  end type MLSCallStack_t
  type(MLSCallStack_t), save :: MLSCallStack
  
  ! Public procedures
  public :: Bummer, Crash_Burn, DumpConfig, RestoreConfig, SetConfig
  public :: Dump_MLSFile
  public :: MLSMessage, MLSMessage_, MLSMessageSetup
  public :: MLSMessageexit, MLSMessageInquire, MLSMessageInternalFile
  public :: MLSMessageClose, MLSMessageReset, PVMErrorMessage
  public :: ReportTKStatus
  public :: MLSMessageCalls, StopWithErrorMsg, SummarizeWarnings

  interface MLSMessage
    module procedure MLSMessage_
  end interface

  interface Bummer
    module procedure Bummer_chars
    module procedure Bummer_chararray
  end interface

contains

  ! -----------------------------------------------------  Bummer  -----
  ! Call banner to print your error message, then call MLSMessage to stop
  subroutine Bummer_chars ( chars, &
    & columnRange, alignment, skips, lineLength, severity )
    character(len=*), intent(in)                :: CHARS
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    integer, optional, intent(in)               :: LINELENGTH
    integer, optional, intent(in)               :: severity
    !
    ! Internal variables
    integer :: mySeverity
    ! Executable
    mySeverity = MLSMSG_Error
    if ( present(severity) ) mySeverity = severity
    call banner(  chars, columnrange, alignment, skips, linelength, mode='s' )
    call MLSMessage ( mySeverity, ModuleName, &
                  & '(See error message above)' )
  end subroutine Bummer_chars

  subroutine Bummer_chararray ( charArray, &
    & columnRange, alignment, skips, severity )
    character(len=*), dimension(:), intent(in)  :: CHARARRAY
    ! If columnRange(1) < 1, just use starting columns; otherwise move to
    integer, dimension(2), optional, intent(in) :: COLUMNRANGE
    character(len=1), intent(in), optional      :: ALIGNMENT ! L, R, C, or J
    integer, optional, intent(in)               :: SKIPS ! How many spaces between chars
    integer, optional, intent(in)               :: severity
    !
    ! Internal variables
    integer :: mySeverity
    ! Executable
    mySeverity = MLSMSG_Error
    if ( present(severity) ) mySeverity = severity
    call banner(  charArray, columnrange, alignment, skips )
    call MLSMessage ( mySeverity, ModuleName, &
                  & '(See error message above)' )
  end subroutine Bummer_chararray

  ! ------------------------------------------------  Crash_Burn  -----
  ! crash, burn unless ..
  subroutine Crash_Burn( Name, Message )
    ! arg
    character(len=*), optional, intent(in) :: Name
    character(len=*), optional, intent(in) :: Message
    ! Internal args
    character(len=prefixLen) :: myName
    myName = '(undefined)'
    if ( present(Name) ) myName = Name
    if ( present(Message) ) call PrintItOut( Message, MLSMSG_Info )
    if ( .not. dontCrashHere(myName) ) call crash_burn_rude
  end subroutine Crash_Burn

  ! ------------------------------------------------  DumpConfig  -----
  ! dump the configuration

  subroutine DumpConfig( config )
    use PrintIt_m, only: Set_Config
    ! Arg
    type(MLSMessageConfig_T), optional, intent(in) :: config
    ! Internal variables
    integer :: LogFileUnit
    type(MLSMessageConfig_T) :: myConfig
    character(len=prefixLen) :: Prefix
    logical :: Toolkit
    character(len=*), parameter                    :: colonel  = &
      & ': : : : : : : : : : : : : : : : : : :'
    character(len=*), parameter                    :: header  = &
      & 'dumping       :    MLS Message Config'
    integer :: OldLogFileUnit
    ! Executable
    if ( present(config) ) then
      myConfig = config
    else
      myConfig = MLSMessageConfig
    end if
    call get_config ( logFileUnit=OldLogFileUnit, prefix=prefix, useToolKit=toolkit )
    call set_config ( logFileUnit=StdoutLogUnit )
    call PrintItOut( colonel, MLSMSG_Info )
    call PrintItOut( header,  MLSMSG_Info )
    call PrintItOut( colonel, MLSMSG_Info )
    call dump ( 'logFileUnit             ', intValue= OldLogFileUnit                     )
    call dump ( 'meaning                 ', charValue= LogUnitName(OldLogFileUnit)       )
    call dump ( 'limitWarnings           ', intValue= myConfig%limitWarnings          )
    call dump ( 'masterTID               ', intValue= myConfig%masterTID              )
    call dump ( 'extra prefix            ', charValue=prefix                          )
    call dump ( 'extra Info              ', charValue=myConfig%Info                   )
    call dump ( 'useToolkit              ', logValue= toolkit                         )
    call dump ( 'Max Module name length  ', intValue= myConfig%MaxModuleNameLength    )
    call dump ( 'Max Severity length     ', intValue= myConfig%MaxSeverityNameLength  )
    call dump ( 'SendErrMsgToMaster      ', logValue= myConfig%SendErrMsgToMaster     )
    call dump ( 'ShowCumulativeSeverity  ', logValue= myConfig%ShowCumulativeSeverity )
    call dump ( 'Trace calls             ', logValue= myConfig%StackTrace             )
    
    call dump ( 'Status values           ', charValue=' '                             )
    call dump ( '  Success               ', intValue=MLSMSG_Success                   )
    call dump ( '  Debug                 ', intValue=MLSMSG_Debug                     )
    call dump ( '  Info                  ', intValue=MLSMSG_Info                      )
    call dump ( '  Warning               ', intValue=MLSMSG_Warning                   )
    call dump ( '  Error                 ', intValue=MLSMSG_Error                     )
    call dump ( '  Crash                 ', intValue=MLSMSG_Crash                     )
    call dump ( 'Severity to quit        ', intValue=MLSMSG_Severity_to_quit          )
    call dump ( 'Severity to crash       ', intValue=MLSMSG_Severity_to_walkback      )
    call dump ( 'Severity so far         ', intValue=MLSMSG_Severity_so_far           )
    
    call dump ( 'Skip ModNames threshhold', intValue=myConfig%skipModuleNamesThr      )
    call dump ( 'Skip Severity threshhold', intValue=myConfig%skipSeverityThr         )
    call dump ( 'Skip Messages threshhold', intValue=myConfig%skipMessageThr          )
    call dump ( 'Suppress Debugs         ', logValue=myConfig%suppressDebugs          )

    call dump ( 'Allowed to crash        ', logValue= .not. NeverCrash                )
    call dump ( 'Crash on any error      ', logValue= myConfig%CrashOnAnyError        )
    call dump ( 'Crash on this message   ', charValue= myConfig%CrashIfMsgSays        )
    call PrintItOut( colonel, MLSMSG_Info )
    call set_config ( logFileUnit=OldLogFileUnit )
  end subroutine DumpConfig

  ! ------------------------------------------------  MLSMessage_  -----

  ! This first routine is the main `messaging' code.
  subroutine MLSMessage_( severity, ModuleNameIn, Message, &
    & Advance, MLSFile, status )
    ! A wraparound subroutine so we can 
    ! (1) prevent excessively repeated warning messages
    ! (2) intercept calls 
    ! when the severity is MLSMSG_Error
    ! allowing us to push ModuleNameIn onto the calling stack
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    type(MLSFile_T), intent(in), optional :: MLSFile
    integer, intent(out), optional :: status ! 0 if msg printed, 1 if suppressed
    ! Internal variables
    integer :: msgLength                  ! length to be printed
    integer :: myStatus
    logical :: nosubsequentwarnings
    logical :: newwarning
    integer :: warning_index
    integer :: warningLength              ! length to be checked for repeats    
    character(len=len(Message)+len(WARNINGSSUPPRESSED)) :: &
      & msgPlusNotice                     ! actual message printed
    ! Executable
    msgPlusNotice = message
    myStatus = MLSMSGSTATUS_Suppressed

    ! Have we been asked to print an error message?
    ! If so, try harder to print that error msg to stdout, too
    if ( severity >= MLSMSG_Severity_to_quit ) then
      if ( MLSMessageConfig%LogFileUnit == DefaultLogUnit .or. &
        MLSMessageConfig%UseToolkit )  &
        & MLSMessageConfig%LogFileUnit = BothLogUnit
    endif
    ! This is the smaller of the actual length and what we allow to be printed
    msgLength = min( len(message), MAXMESSLENGTH )
    msgLength = max( msgLength, 1 )
    ! This is the smaller of the actual length and what we can check for repeats
    warningLength = min( len(message), WARNINGMESSLENGTH )
    warningLength = max( warningLength, 1 )
    ! Here's where we suppress warning messages beyond a limit for each and all
    if ( severity == MLSMSG_Warning ) &
      & MLSMSGWarnings%totalnumwarnings = &
      & min( TOTALNUMWARNINGSMAX, MLSMSGWarnings%totalnumwarnings + 1 )
    if ( any( severity == (/MLSMSG_Warning, MLSMSG_TestWarning/) ) .and. &
      & ( &
      &  ( MLSMSGWarnings%totalnumwarnings > TOTALNUMWARNINGSMAX - 1 ) &
      & .or. &
      &  ( MLSMSGWarnings%numwarnings >= MAXNUMWARNINGS - 1 ) &
      & ) &
      & ) then
      if ( present(status) ) status = myStatus
      if ( MessageMeansCrash ( Message ) ) call Crash_Burn ( Message=Message )
      return
    else if ( MLSMSGWarnings%totalnumwarnings > TOTALNUMWARNINGSMAX - 2 ) then
      msgPlusNotice = '(Max Warnings reached)' // message
      msgLength = min(warningLength+len('(Max Warnings reached)'), MAXMESSLENGTH)
    end if
    if ( MessageMeansCrash ( Message ) ) call Crash_Burn ( Message=Message )
    if ( severity == MLSMSG_Warning ) MLSMSGWarnings%lastWarningMsg = message
    nosubsequentwarnings = .false.
    if ( any( severity == (/MLSMSG_Warning, MLSMSG_TestWarning/) ) &
      & .and. MLSMessageConfig%limitWarnings > -1 &
      & .and. MLSMSGWarnings%numwarnings <= MAXNUMWARNINGS &
      & .and. message /= ' ' ) then
      ! See if we have seen this message before
      newwarning = .true.
      do warning_index = 1, MLSMSGWarnings%numwarnings
        newwarning = newwarning .and. &
          & ( MLSMSGWarnings%warningmessages(warning_index) /= &
          &   trim(message(1:warningLength)) )
      enddo
      if ( newwarning .and. MLSMSGWarnings%numwarnings >= MAXNUMWARNINGS ) then
        if ( severity == MLSMSG_TestWarning ) then
          if ( present(status) ) status = myStatus
          return
        end if
      else if ( newwarning .or. &
        & MLSMSGWarnings%numwarnings < 1 ) then
        if ( severity == MLSMSG_TestWarning ) then
          if ( MLSMessageConfig%limitWarnings > 0 ) myStatus = 0
          if ( present(status) ) status = myStatus
          return
        end if
        MLSMSGWarnings%numwarnings = MLSMSGWarnings%numwarnings + 1
        MLSMSGWarnings%warningmessages(MLSMSGWarnings%numwarnings) = message
        MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) = &
          & MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) + 1
        if ( MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) > &
          & MLSMessageConfig%limitWarnings ) then
          if ( present(status) ) status = myStatus
          return
        end if
        MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) = &
          & min(MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) + 1, &
          & MLSMessageConfig%limitWarnings + 1 )
        nosubsequentwarnings = &
          & (MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) > &
          & MLSMessageConfig%limitWarnings)
      else
        do warning_index = 1, MLSMSGWarnings%numwarnings
          if ( MLSMSGWarnings%warningmessages(warning_index) == &
            & message(1:warningLength) ) exit
        end do
        if ( warning_index > MLSMSGWarnings%numwarnings ) then
          if ( present(status) ) status = myStatus
          return
        else if ( severity == MLSMSG_TestWarning ) then
          if ( MLSMSGWarnings%timeswarned(warning_index) < &
            & MLSMessageConfig%limitWarnings  ) myStatus = 0
          if ( present(status) ) status = myStatus
          return
        end if
        ! Now we assure that the times warned array contains all
        ! the times we were called, not just the times we printed
        MLSMSGWarnings%timeswarned(warning_index) = &
          & min(MLSMSGWarnings%timeswarned(warning_index) + 1, &
          & TOTALNUMWARNINGSMAX )
        if ( MLSMSGWarnings%timeswarned(warning_index) > &
          & MLSMessageConfig%limitWarnings + 1 ) then
          if ( present(status) ) status = myStatus
          return
        end if
        nosubsequentwarnings = &
          & (MLSMSGWarnings%timeswarned(warning_index) > &
          & MLSMessageConfig%limitWarnings)
      end if
    end if

    if ( nosubsequentwarnings ) then
      msgPlusNotice = WARNINGSSUPPRESSED // msgPlusNotice
      msgLength = min(msgLength+len(WARNINGSSUPPRESSED), MAXMESSLENGTH)
    end if
    if ( .not. any ( severity >= &
      & (/ MLSMSG_Severity_to_quit, MLSMSG_Severity_to_walkback /) ) ) then
      ! Unless special treatment, just pass args to MLSMessageStd
      call MLSMessageStd( severity, ModuleNameIn, msgPlusNotice(1:msgLength), &
        & Advance )
      if ( present(status) ) status = MLSMSGSTATUS_Normal
      return
    end if
    call MLSMessageCalls( 'push', constantName=ModuleNameIn )
    if ( severity >= MLSMSG_Severity_to_quit ) then
      call StopWithErrorMsg( Message, MLSFile, advance=advance, severity=severity )
      myStatus = MLSMSGSTATUS_Stopped
    else
      call MLSMessageCalls( 'dump' )
      call MLSMessageStd( severity, ModuleNameIn, msgPlusNotice(1:msgLength), &
        & Advance, MLSFile=MLSFile )
      myStatus = MLSMSGSTATUS_Dumped
    end if
    call MLSMessageCalls( 'pop' )
    if ( present(status) ) status = myStatus
  end subroutine MLSMessage_

  ! --------------------------------------------  MLSMessageCalls  -----

  ! Manage the calling stack MLSCallStack
  ! It will be dumped on calling StopWithErrorMsg
  ! possible commands are 
  ! 'push'    push a new name onto MLSCallStack
  ! 'pop'     pop the last name off
  ! 'top'     just return the last name
  ! 'invert'  invert the stack (top becomes bottom, etc.)
  ! 'clear'   clear the stack
  ! 'print'   print its contents as a single line
  ! 'dump'    print a walkback, one name per line, top to bottom
  ! 'dumpdb'  dump verboseDB and debugDB
  ! 'depth'   return the number of elements on the stack
  ! 'length'  return the total length taken by the elements on the stack
  ! 'remain'  return the total length remaining before the stack is full
  ! 'verbosedb' reset all the elements of verboseDB
  !            (forgetting all the prior states of verboseness)
  ! 'debugdb' reset all the elements of debugDB
  !            (forgetting all the prior states of debugging)
  
  ! Every command except 'print', '[r]dump', 'depth', 'length', 'top',
  ! and 'remain' change the stack
  ! '[r]push' requires name as an input arg
  ! '[r]pop', 'top', and '[r]dump' produce the topmost name as an output arg
  ! 'depth', 'length', and 'remain' produce coded a integer name as output arg
  ! e.g, '1249'

  ! If name is omitted, it will be lost or assumed blank, as appropriate

  ! --------------------------------------------  MLSMessageCalls  -----
  subroutine MLSMessageCalls ( command, name, constantName, lvalue )
    ! Args
    character(len=*), intent(in)              :: command
    ! Because name is (inout) you cannot call this with a constant
    ! so if you wish to use a constant use constantName instead
    character(len=*), optional, intent(inout) :: name
    character(len=*), optional, intent(in)    :: constantName
    logical, optional, intent(in)             :: lvalue
    ! Internal variables
    character(len=1), parameter :: comma = achar(0) ! '?' ! ','
    integer :: i
    integer :: m
    logical :: myLValue
    character(len=MAXSTACKNAMELEN) :: myName
    logical, parameter  :: nosubsequentwarnings = .false.
    ! Executable
    myName = ' '
    if ( MLSMessageConfig%stackTrace ) then
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      if ( present(name) .or. present(constantName) ) then
        call printItOut ( 'MLSMessageCalls("' // trim(command) // '","' &
          & // trim(myName) // '")', MLSMSG_info )
      else
        call printItOut ( 'MLSMessageCalls("' // trim(command) // '")', MLSMSG_info )
      end if
    end if
    myName = ' '
    myLValue = .false.
    if ( present(lvalue) ) myLValue = lvalue
    select case( command )
    case ( 'push' )
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      call PushStack( myName )
    case ( 'pop', 'top' )
      call PopStack( name )
      if ( command == 'pop' ) MLSCallStack%top = MLSCallStack%top - 1
    case ( 'clear' )
      MLSCallStack%txt = ' '
      MLSCallStack%top = 0
    case ( 'invert' )
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'dump' )
      call dumpStack
    case ( 'dumpdb', 'dumpDB' )
      call dump( 'db', charValue='debug' )
      do i = 1, MLSCallStack%top
        write( myName, '(i2)' ) i
        call dump( trim(myName), logValue=MLSCallStack%debugDB(i) )
      end do
      call dump( 'db', charValue='verbose' )
      do i = 1, MLSCallStack%top
        write( myName, '(i2)' ) i
        call dump( trim(myName), logValue=MLSCallStack%verboseDB(i) )
      end do
    case ( 'print', 'rprint' )
      if ( MLSCallStack%top < 0 ) then
        call printItOut ( '.. Stack Underflow', MLSMSG_info )
      else if ( MLSCallStack%top == 0 ) then
        call printItOut ( '.. Stack Empty', MLSMSG_info )
      else if ( MLSCallStack%top > maxStackDepth ) then
        call printItOut ( '.. Stack Overflow', MLSMSG_info )
      else if ( command == 'print' ) then
        call printItOut ( MLSCallStack%txt(: &
          & MLSCallStack%ind(min(MLSCallStack%top,maxStackDepth))), MLSMSG_info )
      else if ( command == 'rprint' ) then
        MLSCallStack = InvertStack( MLSCallStack )
        call printItOut ( MLSCallStack%txt(: &
          & MLSCallStack%ind(min(MLSCallStack%top,maxStackDepth))), MLSMSG_info )
        MLSCallStack = InvertStack( MLSCallStack )
      end if
    case ( 'depth' )
      write( myName, '(i8)' ) MLSCallStack%top
      if ( present(name) ) name = myName
    case ( 'length' )
      write( myName, '(i8)' ) MLSCallStack%ind(min(MLSCallStack%top,maxStackDepth))
      if ( present(name) ) name = myName
    case ( 'remain' )
      write( myName, '(i8)' ) len(MLSCallStack%txt) - &
        & MLSCallStack%ind(min(MLSCallStack%top,maxStackDepth))
      if ( present(name) ) name = myName
    ! "r"-versions of the usual commands act on the Inverted CallStack
    case ( 'rpop', 'rtop' )
      MLSCallStack = InvertStack( MLSCallStack )
      call PopStack( name )
      if ( command == 'rpop' ) MLSCallStack%top = MLSCallStack%top - 1
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'rpush' )
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      MLSCallStack = InvertStack( MLSCallStack )
      call PushStack( myName )
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'rdump' )
      MLSCallStack = InvertStack( MLSCallStack )
      call dumpStack
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'verbosedb', 'verboseDB' )
      MLSCallStack%verboseDB = myLValue
    case ( 'debugdb', 'debugDB' )
      MLSCallStack%debugDB = myLValue
    case default
      ! Unrecognized command--we'll ignore it
      if ( present(name) ) name = "What?"
    end select
    if ( MLSCallStack%verbose .and. command /= 'dump' ) call dumpStack

  contains
    subroutine PopStack ( Name )
      character(len=*), optional, intent(inout) :: Name
      ! Internal variables
      integer :: newSize
      integer :: oldSize
      ! Executable
      oldSize = MLSCallStack%top
      if ( oldSize < 1 ) return
      if ( present(name) ) then
        if ( oldSize < 0 ) then
          name = "Stack underflow"
        else if ( oldSize >= maxStackDepth ) then
          name = "Stack overflow"
        else
          ! name = MLSCallStack%txt(MLSCallStack%ind(oldSize)+1: &
          !                        MLSCallStack%ind(oldSize+1))
          m = min(oldSize,maxStackDepth) + 1
          if ( MLSCallStack%ind(m-1) > len(MLSCallStack%txt) ) then
            call printitout( 'Bad news--call stack is bursting', &
              & MLSMSG_Error, 40, NoExit =.true. )
            call DumpStack
          endif
          name = MLSCallStack%txt(MLSCallStack%ind(m-2)+1: &
                                    MLSCallStack%ind(m-1))
        end if
      end if
      newSize = max(oldsize-1,1)
      if ( MLSVerboseSticky ) then
        ! nothing--keep existing MLSVerbose
      else if ( newSize > 0 ) then
        MLSVerbose = MLSCallStack%VerboseDB(newSize)
      else
        MLSVerbose = .false.
      end if
      if ( MLSDebugSticky ) then
        ! nothing--keep existing MLSDebug
      else if ( newSize > 0 ) then
        MLSDebug   = MLSCallStack%debugDB(newSize)
      else
        MLSDebug   = .false.
      end if
    end subroutine PopStack

    subroutine PushStack ( myname )
      character(len=*), intent(inout) :: myname
      ! Internal variables
      integer :: newSize
      integer :: oldSize
      ! Executable
      oldSize = MLSCallStack%top
      MLSCallStack%top = max(oldSize + 1, 1) ! MAX in case it underflowed earlier
      newSize = MLSCallStack%top
      myName = snipRCSFrom ( myName )
      m = len_trim(myName)
      if ( newSize > MaxStackDepth ) then
        call dumpStack ( adjustl(myName(:m)) )
        MLSCallStack%silent = .true.
      else
        MLSCallStack%ind(newSize) = MLSCallStack%ind(newSize-1) + m
        MLSCallStack%txt(MLSCallStack%ind(newSize-1)+1:) = myName(:m) ! clear the rest
        MLSCallStack%verboseDB(newSize) = MLSVerbose
        MLSCallStack%debugDB(newSize) = MLSDebug
      end if
    end subroutine PushStack

    subroutine DumpStack ( What )
      character(len=*), intent(in), optional :: What
      integer :: M
      ! call printItOut ( trim(MLSCallStack), MLSMSG_info )
      if ( MLSCallStack%silent ) return
      if ( present(name) ) name = '' ! In case the stack is weird
      call printItOut ( 'Calling stack (bottom-up)', MLSMSG_info )
      if ( MLSCallStack%top < 0 ) then
        call printItOut ( '.. Stack Underflow', MLSMSG_info )
      else if ( MLSCallStack%top == 0 ) then
        call printItOut ( '.. Stack Empty', MLSMSG_info )
      else
        do m = 1, min(MLSCallStack%top,maxStackDepth)
          call printItOut ( '.. ' // &
            & MLSCallStack%txt(MLSCallStack%ind(m-1)+1: &
                               MLSCallStack%ind(m)), MLSMSG_info )
        end do
        if ( MLSCallStack%top > maxStackDepth ) then
          if ( present(what) ) then
            call printItOut ( '.. Stack Overflow when pushing ' // what, &
            & MLSMSG_info )
          else
            write (myName(:12), '(i12)') MLSCallStack%top
            call printItOut ( '.. Stack Overflow, top=' // trim(adjustl(myName(:12))), &
              & MLSMSG_info )
          end if
        end if
        if ( present(name) ) &
          & name = MLSCallStack%txt(MLSCallStack%ind(m-2)+1: &
                                    MLSCallStack%ind(m-1))
      end if
    end subroutine DumpStack

    function InvertStack ( Stack ) result( Invert )
      ! Return an inverted Stack; i.e. topmost now bottommost
      ! 2nd from top now 2nd from bottom, etc.
      ! Method: 
      ! One-by-one pop items from input Stack, each time pushing them onto
      ! inverted stack
      type(MLSCallStack_t) :: STACK
      ! Local variables
      integer :: i
      integer :: stackDepth
      type(MLSCallStack_t) :: Invert
      character(len=MAXSTACKNAMELEN) :: Name
      ! Executable
      if ( Stack%top <= 0 ) return
      stackDepth = Stack%top
      do i = 1, stackDepth
        m = min(Stack%top,maxStackDepth) + 1
        name = Stack%txt(Stack%ind(m-2)+1: &
                                  Stack%ind(m-1))
        Stack%top = Stack%top - 1
        Invert%top = Invert%Top + 1
        m = len_trim(name)
        Invert%ind(Invert%top) = Invert%ind(Invert%top-1) + m
        Invert%txt(Invert%ind(Invert%top-1)+1:) = Name(:m) ! clear the rest
      enddo
    end function InvertStack
  end subroutine MLSMessageCalls

  ! ------------------------------------------  MLSMessageInquire  -----

  ! This routine returns requested info about Warnings
  subroutine MLSMessageInquire( Warning_msg, timesWarned, &
    &  totalnumwarnings, LastWarningMsg  )
    ! Args
    integer, optional, intent(out)          :: timesWarned ! how many times 
    character(len=*), optional, intent(in)  :: Warning_msg ! this happened
    integer, optional, intent(out)          :: totalnumwarnings ! grand total
    character(len=*), optional, intent(out) :: LastWarningMsg ! Unless cleared
    ! Internal variables
    integer :: warning_index
    ! Executable code
    if ( present(Warning_msg) ) then
      timesWarned = 0
      do warning_index = 1, MLSMSGWarnings%numwarnings
        if ( index( lowercase(MLSMSGWarnings%warningmessages(warning_index)), &
          & trim(lowercase(Warning_msg)) &
          & ) > 0 ) &
          & timesWarned = timesWarned + MLSMSGWarnings%timeswarned(warning_index)
      enddo
    end if
    if ( present(totalnumwarnings) ) &
      & totalnumwarnings = MLSMSGWarnings%totalNumWarnings
    if ( present(LastWarningMsg) ) &
      & LastWarningMsg = MLSMSGWarnings%LastWarningMsg
  end subroutine MLSMessageInquire

  !--------------------------------------  MLSMessageInternalFile  -----
  function MLSMessageInternalFile( Severity, ModuleNameIn, Message ) result(line)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=512)           :: Line   ! Line to output, should be long enough
    integer                       :: Line_len
    ! Internal variables
    ! Executable
    Line_len = 0
    line = ' '
    call assembleFullLine( Severity, ModuleNameIn, Message, line, line_len )
  end function MLSMessageInternalFile

  ! --------------------------------------------  MLSMessageSetup  -----

  ! This routine sets up the MLSMessage suite.  The defaults are of course
  ! sensible, but the user may wish to change things.
  ! (Since we made MLSMessageConfig public, is there any reason to keep this?)
  subroutine MLSMessageSetup ( SuppressDebugs, LogFileUnit, Prefix, useToolkit, &
    & CrashOnAnyError  )

    use PrintIt_M, only: Get_Config, Set_Config, StdoutLogunit

    ! Dummy arguments
    logical, optional, intent(in) :: SuppressDebugs
    integer, optional, intent(in) :: LogFileUnit
    character (len=*), optional, intent(in) :: Prefix
    logical, optional, intent(in) :: useToolkit
    logical, optional, intent(in) :: CrashOnAnyError

    ! Local variables
    integer :: MyLogFileUnit

    ! Executable code
    call get_config ( logFileUnit=myLogFileUnit )

    if ( present(suppressDebugs) ) &
      & MLSMessageConfig%suppressDebugs=suppressDebugs

    if ( present(logFileUnit) ) then
      if ( myLogFileUnit /= StdoutLogUnit ) call MLSMessage ( &
        & MLSMSG_Warning, ModuleName,"Already writing to a log file" )
    end if

    call set_config ( logFileUnit=myLogFileUnit, prefix=prefix, &
      & useToolkit=useToolkit )
    if ( present(CrashOnAnyError) ) &
      & MLSMessageConfig%CrashOnAnyError=CrashOnAnyError

  end subroutine MLSMessageSetup

  ! --------------------------------------------  MLSMessageClose  -----

  ! This routine simply closes the MLSMessage log file if there is one.
  ! It does so by pointing further logged messages at stdout
  subroutine MLSMessageClose
    use PrintIt_m, only: Set_Config
    ! Executable code
    call set_config ( logFileUnit = STDOUTLOGUNIT ) ! -1
  end subroutine MLSMessageClose

  ! ---------------------------------------------  MLSMessageExit  -----

  ! This routine (optionally) logs farewell, advances
  ! (hopefully) gracefully ends logging, and exits 
  ! (optionally with status )
  ! if farewell present, and non-blank, logs it
  ! if farewell present,  but blank, logs default message
  ! if farewell absent, does not log
  subroutine MLSMessageExit ( status, farewell )
  integer, optional, intent(in) :: STATUS
  character(LEN=*), optional, intent(in) :: FAREWELL
  CHARACTER(LEN=36) :: mesg

    ! Executable code
    if (present(status)) then
      if (present(farewell)) then
        if (farewell == ' ') then
          write(mesg, '(A29, I2, A1)') 'Exiting with status (', &
          status, ')'
          call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
        else
          call MLSMessage ( MLSMSG_Info, ModuleName, farewell, advance='y' )
        end if
      end if
      call MLSMessageClose
      if ( status == 1 .and. MLSMessageConfig%CrashOnAnyError ) &
        & call crash_burn
      call exit_with_status ( status  )
    else
      if (present(farewell)) then
        if (farewell == ' ') then
          mesg='exit with default status'
          call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
        else
          call MLSMessage ( MLSMSG_Info, ModuleName, farewell, advance='y' )
        end if
      end if
      call MLSMessageClose
      ! stop
      ! call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
      call exit_with_status ( DEFAULTSTOPEXITSTATUS )
    end if
  end subroutine MLSMessageExit

  ! --------------------------------------------  MLSMessageReset  -----

  ! This routine allows you to reset flags, counters, etc. during runtime
  ! (See also restoreConfig)
  subroutine MLSMessageReset ( logFileUnit, CrashOnAnyError, Warnings, &
    & clearLastWarning )
    ! Various uses:
    !   (if logFileUnit supplied)
    ! (1) Close current log file and (re-)open logFileUnit for logging
    !
    !   (if CrashOnAnyError supplied)
    ! (2) Set option so that any call with MLSMSG_Err will result in crash
    !
    !   (if Warnings supplied)
    ! (3) Print summary of past warnings; clear records, rezero totals, etc.
    !
    !   (if clearLastWarning supplied)
    ! (4) Clear last Warning Msg
    !
    ! (Would it be better to have 4 different routines?)
    use PrintIt_m, only: Get_Config, Set_Config
    ! Args
    integer, intent(in), optional :: logFileUnit
    logical, intent(in), optional :: CrashOnAnyError
    logical, intent(in), optional :: Warnings
    logical, intent(in), optional :: clearLastWarning
    ! Local variables
    character(len=6) :: logname
    integer :: MyLogFileUnit
    ! Executable code
    call get_config ( logFileUnit=myLogFileUnit )
    if ( present(logFileUnit) ) then
      if ( logFileUnit /= myLogFileUnit ) then
        write(logname, '(i6)') myLogFileUnit
        call MLSMessage ( MLSMSG_Info, ModuleName, &
          & 'Closing output on' // logname )
        call MLSMessageClose
        call set_config ( logFileUnit = logFileUnit )
        write(logname, '(i6)') logFileUnit
        call MLSMessage ( MLSMSG_Info, ModuleName, &
          & 'Opening output on' // logname )
      end if
    end if
    if ( present(CrashOnAnyError) ) MLSMessageConfig%CrashOnAnyError = CrashOnAnyError
    if ( present(Warnings) ) then
      if ( MLSMSGWarnings%totalNumWarnings > 0 ) then
        call SummarizeWarnings
        call PrintItOut( 'Forgetting old Warnings', MLSMSG_Info )
      end if
      MLSMSGWarnings%numwarnings = 0
      MLSMSGWarnings%totalnumwarnings = 0
      MLSMSGWarnings%timeswarned = 0
      MLSMSGWarnings%warningmessages = ' '
    end if
    if ( present(clearLastWarning) ) MLSMSGWarnings%lastWarningMsg = ' '
  end subroutine MLSMessageReset

  ! --------------------------------------------  PVMERRORMESSAGE  -----
  subroutine PVMErrorMessage ( INFO, PLACE  )
    ! This routine is called to log a PVM error
    integer, intent(in) :: INFO
    character (LEN=*) :: PLACE

    character (LEN=132) :: LINE

    write (line, * ) info
    call printitout(  MLSMSG_PVM // &
    & ' Info='//trim(adjustl(line)) // ' ' // place, MLSMSG_Error )
  end subroutine PVMErrorMessage

  ! ----------------------------------------------  RestoreConfig  -----

  ! restore the configuration to its default settings
  ! where it makes sense
  ! i.e., we wouldn't mess with masterTID or logFileUnit

  subroutine RestoreConfig ( complete )
    use PrintIt_m, only: Set_Config
    ! The next won't work because of Intel v12 internal compiler error
    ! MLSMessageConfig = MLSMessageConfig_T()
    ! So instead,
    ! Args
    logical, intent(in), optional            :: complete ! Restore even quit, crash!
    ! Internal variables
    logical                                  :: myComplete
    ! Executable
    myComplete                               = present(complete)
    if ( myComplete )   myComplete           = complete
    MLSMessageConfig%limitWarnings           = 1000 
    MLSMessageConfig%prefix                  = ' '  
    MLSMessageConfig%skipModuleNamesThr      = MLSMSG_Success ! Always show module   
    MLSMessageConfig%skipSeverityThr         = MLSMSG_Success ! Always show severit  
    MLSMessageConfig%skipMessageThr          = MLSMSG_Success ! Always show messages  
    MLSMessageConfig%suppressDebugs          = .false.                                
    MLSMessageConfig%AsciifyMessages         = .true.                                                                            
    MLSMessageConfig%MaxModuleNameLength     = 32
    MLSMessageConfig%MaxSeverityNameLength   = 8 
    MLSMessageConfig%CrashOnAnyError         = .false. ! See crash warning                                                       
    MLSMessageConfig%SendErrMsgToMaster      = .false. ! send last gasp to master?                                               
    MLSMessageConfig%ShowCumulativeSeverity  = .false. ! print severity_so_far?                
    MLSMessageConfig%StackTrace              = .false. ! Trace via MLSMessageCalls?            
    call set_config ( asciify=.true., prefix='' )
    if ( .not. myComplete ) return
    MLSMSG_Severity_to_quit                  = MLSMSG_Error
    MLSMSG_Severity_to_walkback              = MLSMSG_Error
  end subroutine RestoreConfig

  ! --------------------------------------------------  SetConfig  -----
  subroutine SetConfig ( Opts )
    character(len=*), intent(in) :: Opts(:)
    character(len=len(opts)) :: MyOpts(0:size(opts,1)+1)
    namelist / in / MLSMessageConfig
    myOpts(0) = '&in'
    myOpts(1:size(opts,1)) = opts
    myOpts(size(opts,1)+1) = '/'
    read ( myOpts, in )
  end subroutine SetConfig

  ! -------------------------------------------  StopWithErrorMsg  -----
  subroutine StopWithErrorMsg ( Message, MLSFile, Advance, severity )
    ! Print Message, dump calling stack (if any) and stop
    character (len=*), intent(in) :: Message ! Line of text
    type(MLSFile_T), intent(in), optional  :: MLSFile
    character(len=*), intent(in), optional :: Advance
    integer, intent(in), optional          :: severity
    ! Internal variables
    character(len=32) :: name
    integer :: mySeverity
    ! Executable
    mySeverity = MLSMSG_Error
    if ( present(severity) ) mySeverity = severity
    name = ' '
    call MLSMessageCalls( 'dump', name )
    if ( len_trim(name) < 1 ) name = ModuleName
    call MLSMessageStd( mySeverity, name, Message, MLSFile=MLSFile, &
      & advance=advance )
  end subroutine StopWithErrorMsg

  ! ------------------------------------------  SummarizeWarnings  -----
  subroutine SummarizeWarnings
    ! Print summary of warnings received
    ! Internal variables
    character(len=16) :: number
    integer :: i
    ! Executable
    call PrintItOut( '=========== Warnings Summary (' // &
      & trim(MLSMessageConfig%Info) // ') ==============', MLSMSG_Info )
    write(number, '(i10)') MLSMSGWarnings%totalnumwarnings
    call PrintItOut( 'Grand total' // ' ' // adjustl(number), MLSMSG_Info )
    write(number, '(i10)') MLSMSGWarnings%numwarnings
    call PrintItOut( 'Different' // ' ' // adjustl(number), MLSMSG_Info )
    if ( MLSMSGWarnings%numwarnings < 1 ) return
    call PrintItOut( 'number             message', MLSMSG_Info )
    do i=1, MLSMSGWarnings%numwarnings
      write(number, '(i10)') MLSMSGWarnings%timeswarned(i) - 1
      ! So grep can quickly spot the summarized warnings by, e.g.
      ! grep '##' mlsl2.log
      if ( MLSMSGWarnings%ALLCAPSSummaries ) then
        call PrintItOut( trim(number) // ' ## ' &
          &  // trim(Capitalize(MLSMSGWarnings%warningmessages(i))), MLSMSG_Info )
      else
        call PrintItOut( trim(number) // ' ## ' &
          &  // trim(MLSMSGWarnings%warningmessages(i)), MLSMSG_Info )
      end if
    enddo
  end subroutine SummarizeWarnings

  ! Private procedures
  ! -----------------------------------------------------  dump  -----
  subroutine dump ( name, intValue, charValue, logValue, trimName  )
    ! Print
    ! name : value
    ! where value is one of {intValue, charValue, logValue}
    character(len=*), intent(in) :: name
    integer, intent(in), optional :: intValue
    character(len=*), intent(in), optional :: charValue
    logical, intent(in), optional :: logValue
    logical, intent(in), optional :: trimName ! Print only leading non-blank
    !
    character(len=132) :: line
    character(len=32)  :: value
    logical            :: myTrim
    integer            :: myLen
    ! Executable
    myTrim = .false.
    if ( present(trimName) ) myTrim = trimName
    value = ''
    if ( present(intValue) ) then
      write(value, '(i10)') intValue
    else if ( present(logValue) ) then
      write(value, '(l10)') logValue
    elseif ( present(charValue) ) then
      ! If th character length is < 10, we want to flush right
      myLen = len_trim(charValue)
      if ( myLen > 10 ) then
         value(1:10) = charValue(1:10)
       else
         value(10-mylen+1:10) = charValue(1:myLen)
       endif
    endif
    line = name // '  :' // trim(value)
    if ( myTrim ) line = trim(name) // ' : ' // trim(value)
    call PrintItOut( trim(line), MLSMSG_Info )
  end subroutine dump

  ! ------------------------------------------ Dump_MLSFile ------------
  ! Uses  OutputTable 
  subroutine Dump_MLSFile ( MLSFile, details )
    use MLSCommon, only: AccessType, FileStringTable, Split_Path_Name
    ! Dummy arguments
    type (MLSFile_T), intent(in)         ::      MLSFile
    integer, intent(in), optional        ::      details
    ! Local variables
    integer                              ::      myDetails
    character(len=PGSd_Pc_File_Path_Max) ::      name
    character(len=PGSd_Pc_File_Path_Max) ::      path
    character(len=PGSd_Pc_File_Path_Max) ::      str

    ! Executable code
    myDetails = 0
    if ( present(details) ) myDetails = details
    call split_path_name(MLSFile%Name, Path, Name)
    call startTable
    call addRow_header ( 'File Info', 'c' )
    call addRow_divider ( '-' )
    if ( len_trim(path) > 0 ) call addRow ( 'path', trim(path) )
    call addRow ( 'name', trim(name) )
    ! If details < 0, show only this name
    if ( myDetails > -1 ) then
      if ( UseSDPToolkit .and. MLSFile%shortName /= ' ' ) &
        & call addRow ( 'short name', trim(MLSFile%shortName) )
      if ( len_trim(MLSFile%TypeStr) > 0 ) &
        & call addRow ( 'Type', MLSFile%TypeStr )
      if ( FILESTRINGTABLE ) then
        call get_string ( lit_indices(MLSFile%Type), str, strip=.true. )
        call addRow ( 'Type(int)', trim(str) )
      endif
      call addRow ( 'Access', trim(accessType(MLSFile%access)) )
      call addRow ( 'Access (int)', MLSFile%access )
      call addRow ( 'content', trim(MLSFile%content) )
      call addRow ( 'last Operation', trim(MLSFile%lastOperation) )
      call addRow ( 'still open?', MLSFile%stillOpen )
      if ( &
        & any(MLSFile%type == (/l_hdf, l_swath, l_hdfeos, l_zonalavg /) ) &
        & .or. &
        & MLSFile%TypeStr == 'hdf' &
        & ) &
        & call addRow ( 'hdf version', MLSFile%HDFVersion )
      ! If details < 1, don't show any FileID info
      if ( myDetails > 0 ) then
        call addRow_divider ( '-' )
        call addRow ( 'File ID', MLSFile%FileId%f_id )
        if ( MLSFile%FileId%grp_id > 0 ) &
          & call addRow ( 'Group ID', MLSFile%FileId%grp_id )
        if ( MLSFile%FileId%sd_id > 0 ) &
          & call addRow ( 'Dataset ID', MLSFile%FileId%sd_id )
        if ( UseSDPToolkit )  then
          call addRow ( 'PCF ID', MLSFile%PCFId )
          call addRow ( 'PCF Range', (/MLSFile%PCFidRange%Bottom, MLSFile%PCFidRange%Top /) )
        endif
        if ( MLSFile%recordLength > 0 ) &
          & call addRow ( 'record length', MLSFile%recordLength )
        call addRow ( 'error code', MLSFile%errorCode )
      endif
    endif
    call outputTable ( sep='|', border='-' )
  end subroutine Dump_MLSFile

  ! ---------------------------------------------------  MessageMeansCrash  -----
  function MessageMeansCrash ( Message ) result ( goCrash )
    ! Does the Message contain the fatal string causing us to Crash?
    character(len=*), intent(in)        :: message
    logical                             :: goCrash ! Does Message contain fatal string?
    ! Executable
    goCrash = .false.
    if ( len_trim(Message) < 1 &
      & .or. len_trim(MLSMessageConfig%CrashIfMsgSays) < 1 ) return
    goCrash = index( trim(Message), trim(MLSMessageConfig%CrashIfMsgSays) ) > 0
  end function MessageMeansCrash

  ! ----------------------------------------------  MLSMessageStd  -----
  ! After entering MLSMessage_,
  ! this is where most calls to MLSMessage trickle down to

    ! Print a message (unless printing is suppressed).  If it has %[Nn]
    ! in it, replace that with newline.
  subroutine MLSMessageStd ( Severity, ModuleNameIn, Message, &
    & Advance, MLSFile )

    use PrintIt_m, only: Get_Config
    ! use CALL_STACK_M, only: DUMP_STACK
    ! Dummy arguments
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    type(MLSFile_T), intent(in), optional :: MLSFile

    ! Local variables
    !                                     If nonzero, do not insert prefix.
    logical :: AllOfIt                  ! Print all of it (no %n or %N remains)
    integer :: L1, L2                   ! How far in the line have we printed?
    character (len=512), save :: Line   ! Line to output, should be long enough
    integer, save :: Line_len=0         ! Number of saved characters in line.
    integer :: LogFileUnit
    logical :: My_adv
    logical :: StackIsEmpty

    ! Executable code
    MLSMSG_Severity_so_far = max( MLSMSG_Severity_so_far, severity )
    my_adv = .true.
    if ( present(advance) ) &
      & my_adv = advance(1:1) /= 'n' .and. advance(1:1) /= 'N'

    my_adv = my_adv .and. ( severity >= MLSMessageConfig%skipMessageThr )
    if ( (.not. MLSMessageConfig%suppressDebugs).OR. &
         & (severity /= MLSMSG_Debug) ) then
      l1 = 0
      do
        l2 = index(Message(l1+1:),'%n' )
        if ( l2 == 0 ) l2 = index(Message(l1+1:),'%N')
        allOfIt = l2 == 0
        l2 = l2 + l1 - 1 ! Last character before %n or %N, if any
        if ( allOfIt ) l2 = len(Message) ! no %n or %N
        call assembleFullLine( Severity, ModuleNameIn, Message(l1+1:l2), &
          & line, line_len )
        l1 = l2 + 2 ! "n" or "N" of %n or %N
         ! Log the message using the toolkit routine
         ! (or its substitute )
         ! if either using toolkit or severity is sufficient to
         ! quit (which means we might have been called directly
         ! rather than from output module )

        if ( my_adv .or. .not. allOfIt ) then
          call printitout( line, severity, line_len, NoExit =.true. )
          line_len = 0
          line = ' '
        end if
        if ( allOfIt ) exit
      end do

    end if

    ! Now if it's an error, and the message is complete, then try to close
    ! log file if any and quit (or crash)
    if ( my_adv .and. severity >= MLSMSG_Severity_to_quit ) then
      ! Here's a chance to dump facts about last file we were reading/writing
      if ( present(MLSFile) ) then
        call Dump_MLSFile( MLSFile )
      else if ( MLSMessageConfig%MLSFile%name /= ' ' ) then
        call Dump_MLSFile( MLSMessageConfig%MLSFile )
      end if
      ! Here's a chance to use our (separate) call stack
      call dump_stack( where=.true., CPU=.true., &
        & PrintMemoryReport=.true., StackIsEmpty=StackIsEmpty )
      if ( MLSMessageConfig%SendErrMsgToMaster .and. &
        & MLSMessageConfig%masterTID > 0 ) call LastGasp(ModulenameIn, Message )
      call get_config ( logFileUnit = logFileUnit )
      if ( logFileUnit > 0 ) close ( logFileUnit  )
      if ( severity >= MLSMSG_Crash .or. MLSMessageConfig%CrashOnAnyError ) then
        NEVERCRASH = .false.
        call crash_burn
      end if
      call exit_with_status ( 1 )
    end if
  end subroutine MLSMessageStd

!
! $Log$
! Revision 2.61  2022/07/13 20:45:16  pwagner
! Suppress dumping MLSFile%TypeStr if its not set
!
! Revision 2.60  2020/04/30 23:13:21  pwagner
! If we are to quit, may  as well PrintFinalReport
!
! Revision 2.59  2019/04/09 20:33:56  pwagner
! Remove redundant USE statement
!
! Revision 2.58  2019/03/18 22:04:40  pwagner
! Try harder to Print Errors to stdout
!
! Revision 2.57  2019/02/21 22:33:30  pwagner
! Improved DumpConfig
!
! Revision 2.56  2019/01/24 18:29:45  pwagner
! Reorganized modules that print to simplify toolkit-free builds
!
! Revision 2.55  2018/11/05 18:17:57  pwagner
! Prevent warning messages from overfilling %warningmessages array
!
! Revision 2.54  2018/08/13 22:52:26  pwagner
! Improve DumpConfig; add items missing from toc
!
! Revision 2.53  2018/08/06 22:41:28  pwagner
! Reorient DumpFile_old to Dump_MLSFile
!
! Revision 2.52  2018/08/06 20:22:55  pwagner
! Warn and Dump if CallStack about to burst
!
! Revision 2.51  2018/03/27 22:08:06  pwagner
! Where to find get_string moved to .f90 module or its substitute
!
! Revision 2.50  2018/03/15 16:39:22  pwagner
! Moved 'Use' statement to .f90 where make can see it
!
! Revision 2.49  2018/03/14 21:49:34  pwagner
! Corrected desciptions in toc section
!
! Revision 2.48  2018/02/28 19:56:23  pwagner
! Improved appearance of DumpConfig
!
! Revision 2.47  2018/02/08 23:20:55  pwagner
! Improved appearance of Dump_MLSFile by use of outputTable
!
! Revision 2.46  2017/12/07 02:21:32  vsnyder
! Remove unused variable declaration
!
! Revision 2.45  2017/03/24 22:54:55  pwagner
! Ensure Message is printed before MessageMeansCrash causes Crash_and_Burn
!
! Revision 2.44  2017/03/23 16:22:45  pwagner
! Programs may optionally crash when MLSMessage logs fatal string
!
! Revision 2.43  2017/01/04 19:17:57  pwagner
! Optional arg StackIsEmpty to Dump_Stack prevents printing if stackIsEmpty
!
! Revision 2.42  2016/11/03 20:53:19  pwagner
! RestoreConfig defaults to being less complete
!
! Revision 2.41  2016/10/10 22:41:37  pwagner
! Avoid the Call_Stack module if no toolkit
!
! Revision 2.40  2015/09/02 23:15:52  pwagner
! Fixed bug that prevented dumping last MLSFile
!
! Revision 2.39  2015/06/30 18:40:26  pwagner
! Added a conditional crash_burn
!
! Revision 2.38  2015/05/27 22:44:15  vsnyder
! Use fixed-size arrays for verboseDB and debugDB rather than pointers to
! variable size arrays.  NAG had been complaining that these pointers'
! targets were somehow associated with other pointers, and that deallocating
! them here resulted in dangling pointers elsewhere.
!
! Revision 2.37  2015/03/28 01:14:28  vsnyder
! Added stuff to trace allocate/deallocate addresses
!
! Revision 2.36  2014/09/05 00:06:39  vsnyder
! More complete and accurate allocate/deallocate size tracking.
! Include addItemToDatabase instead of duplicating it here.
!
! Revision 2.35  2014/05/29 18:16:12  pwagner
! Fixed bug affecting call stack and another in StopWithErrorMsg
!
! Revision 2.34  2014/04/22 16:28:59  pwagner
! Added Bummer--writes error message as an eye-catching banner
!
! Revision 2.33  2013/11/18 22:22:48  pwagner
! Sticky versions of verbose, debug available
!
! Revision 2.32  2013/11/15 00:15:11  pwagner
! Remove MLSMESSAGESTD from public list
!
! Revision 2.31  2013/11/13 18:57:50  pwagner
! verbose and debug dbs track and restore states in MLSCallStack
!
! Revision 2.30  2013/11/01 00:06:33  pwagner
! Prevent dumps of a corrupt MLSCallStack
!
! Revision 2.29  2013/09/14 01:21:30  vsnyder
! Repair stack underflow problem in MLSMessageCalls with 'push' option.
! Add SetConfig.  Some cannonball polishing.
!
! Revision 2.28  2013/09/09 18:37:15  pwagner
! Workaround for ifort v12 internal compiler error
!
! Revision 2.27  2013/08/30 23:15:53  pwagner
! Fixed some bugs preventing effective dump_stack
!
! Revision 2.26  2013/08/29 19:16:23  pwagner
! Prevent an odd error pop-ing an empty stack
!
! Revision 2.25  2013/08/28 00:35:39  pwagner
! Moved more stuff from MLSMessage down to PrintIt module
!
! Revision 2.24  2013/08/23 02:51:04  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 2.23  2013/07/30 23:19:53  pwagner
! Added a few extra cmds to MLSCallStack
!
! Revision 2.22  2013/06/28 18:15:51  pwagner
! Eliminate bare stop; enhance call stack; treat each of line prefixes (severity, name) separately
!
! Revision 2.21  2012/08/21 23:52:32  pwagner
! Removed comments about non-existent function; MaxModuleNameLength made adequate
!
! Revision 2.20  2012/08/16 17:35:30  pwagner
! Changed how and when message lines are printed
!
! Revision 2.19  2012/07/18 00:36:03  pwagner
! Replaced -1 and -2 for LogFileUnit with module parameters
!
! Revision 2.18  2012/07/02 20:18:39  pwagner
! Added restoreConfig
!
! Revision 2.17  2012/05/16 19:23:26  vsnyder
! Remove duplicate SendErrMsgToMaster dump, some cannonball polishing
!
! Revision 2.16  2011/10/10 23:56:02  pwagner
! Prevent writing non-ascii chars to stdout
!
! Revision 2.15  2011/08/25 18:22:33  honghanh
! Add fix to PVMErrorMessage to print custom error message.
!
! Revision 2.14  2011/07/22 19:47:00  vsnyder
! Add Advance argument to StopWithErrorMsg, pass it through to MLSMessageStd.
! Add %n and %N as newline characters in MLSMessageStd.
!
! Revision 2.13  2011/06/29 21:40:11  pwagner
! Added ability to omit message prefixes, or entire messages according to sedverity
!
! Revision 2.12  2011/04/05 00:03:14  pwagner
! MLSMSG_Severity_so_far now available as a return status if mlspgs treated as a function
!
! Revision 2.11  2010/10/07 23:29:26  pwagner
! MLSMessage optionally returns status
!
! Revision 2.10  2009/06/16 17:10:12  pwagner
! Can Capitalize messages in warnings summaries
!
! Revision 2.9  2008/05/28 21:01:48  pwagner
! Break endless cycling between PVMErrorMessage and MLSMessage
!
! Revision 2.8  2008/05/23 23:16:22  vsnyder
! Added tracing of call stack operations
!
! Revision 2.7  2008/02/22 21:31:38  pwagner
! Can now dump messaging configuration
!
! Revision 2.6  2007/12/07 01:10:36  pwagner
! Keeps track of and permits inquiries about warnings better
!
! Revision 2.5  2007/10/03 23:59:46  vsnyder
! Simplify call stack
!
! Revision 2.4  2007/09/06 22:29:55  pwagner
! Impose limit on total warnings
!
! Revision 2.3  2007/08/31 00:02:28  pwagner
! Added procedure to summarize warnings
!
! Revision 2.2  2007/08/29 19:51:02  pwagner
! Worked around Intel quirk that wraps stdout when 'FMT=*'
!
! Revision 2.1  2007/08/27 23:52:14  pwagner
! First commit
!
