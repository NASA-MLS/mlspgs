! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! === (start of toc) ===
!     c o n t e n t s
!     - - - - - - - -

!     (parameters)
! MLSMSG_SUCCESS           status returned when all went well
! MLSMSG_DEBUG             should print only if debugging turned on
! MLSMSG_INFO              fyi only
! MLSMSG_WARNING           not fatal, but deserving of attention
! MLSMSG_ERROR             quits after printing
! MLSMSG_CRASH             should give traceback before quitting
! MLSMSG_TESTWARNING       test to see if we would print this warning
! MLSMSG_Severity_so_far   worst severity level noted so far in this run
! MLSMSG_Severity_to_quit  severity level needed to quit
! MLSMSG_Severity_to_walkback
!                          severity level needed to print callstack
! MLSMSG_Allocate          mesg prefix for this type of error
! MLSMSG_Fileopen          mesg prefix for this type of error
! MLSMSG_Keyword           mesg prefix for this type of error
! MLSMSG_L1BRead           mesg prefix for this type of error
! MLSMSG_Duplicate         mesg prefix for this type of error
! MLSMSG_DeAllocate        mesg prefix for this type of error
! MLSMSG_PVM               mesg prefix for this type of error
! MLSMessageConfig         configuration controlling where to print, etc.

!     (subroutines and functions)
! dumpConfig               dump configuration
! restoreConfig            restore configuration to its default state
! MLSMessage               main messaging routine
! MLSMessageSetup          routine interface to change some parts of MLSMessageConfig
! MLSMessageCalls          manage calling stack 
! MLSMessageClose          close MLSMessage log file; but see MLSMessageExit
! MLSMessageExit           recommended way to finish main program
! MLSMessageInquire        Returns the requested info
! MLSMessageInternalFile   Returns the complete text that would be printed
! MLSMessageReset          reset flags, counters, etc. during runtime
! PVMErrorMessage          log a PVM error
! ReportTKStatus           converts SDP status to severity, prints if needed
! StopWithErrorMsg         report error msg, dump calling stack, stop
! SummarizeWarnings        show summary of how many warnings received

! === (end of toc) ===

! === (start of api) ===
! dumpConfig ( [MLSMessageConfig_T config] )
! restoreConfig
! MLSMessage ( int Severity, char* ModuleNameIn, char* Message, 
!      [char* Advance], [MLSFile_T MLSFile], [status] )
! MLSMessageCalls ( char* command, [char* name] )
! MLSMessageSetup ( [log SuppressDebugs], [int LogFileUnit], [char* Prefix],
!      [log useToolkit], [log CrashOnAnyError] )
! MLSMessageExit ( [int status], [char* farewell] )
! MLSMessageInquire ( [char* Warning_msg], [int timesWarned], &
!    [int totalnumwarnings], [char* LastWarningMsg]  )
! char* MLSMessageInternalFile ( int Severity, char* ModuleNameIn, char* Message, 
!      [char* Advance], [MLSFile_T MLSFile] ) 
! MLSMessageReset ( [int logFileUnit], [log CrashOnAnyError], [log Warnings], &
!       [log clearLastWarning] )
! PVMErrorMessage ( int INFO, char* PLACE  )
! ReportTKStatus( int status, char* ModuleNameIn, char* Message, 
!      [int Threshold] )
! StopWithErrorMsg ( char* Message, [MLSFile_T MLSFile] )
! SummarizeWarnings
! === (end of api) ===
  ! ---------------------------------------------------------------------------

  ! Define some low level parameters.  These are used by the calling code to
  ! indicate the severity or otherwise of the messages.
  ! Normally, we treat any severity of Error or worse as reason to stop.
  ! Any Warning is worth recording, and suppressed when too numerous.
  ! Info may be customized to show, phase name, chunk number, etc.
  ! Be advised, Crash may not properly close files opened by your run.
  ! Use it only for specific debugging where you need a walkback.
  ! See also MLSMessageConfig%crashOnAnyError

  integer, public, parameter :: MLSMSG_Success     = PGS_S_SUCCESS ! == 0
  integer, public, parameter :: MLSMSG_Debug       = MLSMSG_Success + 1
  integer, public, parameter :: MLSMSG_Info        = MLSMSG_Debug + 1
  integer, public, parameter :: MLSMSG_Warning     = MLSMSG_Info + 1
  integer, public, parameter :: MLSMSG_Error       = MLSMSG_Warning + 1
  integer, public, parameter :: MLSMSG_Crash       = MLSMSG_Error + 1
  integer, public, parameter :: MLSMSG_TestWarning = MLSMSG_Crash + 1

  ! MLSMSG_Severity_to_* can be reset in a main program to cause us
  ! to become more lenient (set it higher) or strict (set it lower )
  integer, public, save      :: MLSMSG_Severity_so_far      = PGS_S_SUCCESS
  integer, public, save      :: MLSMSG_Severity_to_quit     = MLSMSG_Error
  integer, public, save      :: MLSMSG_Severity_to_walkback = MLSMSG_Error

  private :: SeverityNames
  character (len=*), dimension(MLSMSG_Success:MLSMSG_Crash), parameter :: &
     & SeverityNames = (/&
     & "Success", &
     & "Debug  ", &
     & "Info   ", &
     & "Warning", &
     & "Error  ", &
     & "Crash  " &
     /)

  ! Returned status values of how MLSMessage fared or how message was treated
  integer, public, parameter :: MLSMSGSTATUS_Normal = PGS_S_SUCCESS ! == 0
  integer, public, parameter :: MLSMSGSTATUS_Suppressed = MLSMSGSTATUS_Normal + 1
  integer, public, parameter :: MLSMSGSTATUS_Stopped = MLSMSGSTATUS_Suppressed + 1
  integer, public, parameter :: MLSMSGSTATUS_Dumped = MLSMSGSTATUS_Stopped + 1

  ! If we are asked to exit, exit with this status instead of using Fortran STOP
  integer, public, parameter :: DEFAULTSTOPEXITSTATUS = 0
  ! So that we may limit the number of times warnings printed, messagewise
  character(len=*), parameter :: WARNINGSSUPPRESSED = '(No more warnings of this)'
  integer, parameter :: MAXNUMWARNINGS = 40 ! was 80, but most tests < 10
  integer, parameter :: WARNINGMESSLENGTH = 80
  integer, parameter :: TOTALNUMWARNINGSMAX = 10000000

  type :: MLSMSGWarnings_T
    character(len=WARNINGMESSLENGTH), dimension(MAXNUMWARNINGS) :: &
      &                   warningmessages = ' '
    integer, dimension(MAXNUMWARNINGS) :: timeswarned = 0
    integer :: numwarnings = 0
    integer :: totalnumwarnings = 0
    character(len=128) :: lastWarningMsg = ' '
    logical :: ALLCAPSSummaries    = .false. ! Print summary msgs in ALL CAPS
  end type MLSMSGWarnings_T

  integer, parameter :: MAXMESSLENGTH = 255 ! Max length on one line

  ! This variable describes all the warnings we've recorded
  type (MLSMSGWarnings_T), save :: MLSMSGWarnings

  ! This set of parameters are simple prefixes for common messages

  character (len=*), public, parameter :: MLSMSG_Allocate = &
     & "Allocation failed: "
  character (len=*), public, parameter :: MLSMSG_Fileopen = &
     & "Failed to open file: "
  character (len=*), public, parameter :: MLSMSG_Keyword = &
     & "Unrecognized configuration file keyword: "
  character (len=*), public, parameter :: MLSMSG_L1BRead = &
     & "Unable to read L1B data item: "
  character (len=*), public, parameter :: MLSMSG_Duplicate = &
     & "There is already an entry with the name "
  character (len=*), public, parameter :: MLSMSG_DeAllocate = &
     & "Deallocation failed: "
  character (len=*), public, parameter :: MLSMSG_PVM = &
     & "PVM Error: "

  ! We add the following because the Intel compiler wraps stdout at 80 columns
  ! when 'FMT=*' but lets it "all hang out" if FMT='(a)'
  logical, private, parameter :: USEDEFAULTFORMATSTDOUT = .false. ! Use FMT=*
  ! This datatype describes the configuration of the messaging suite

  ! May get some of these from MLSCommon? 
  type, public :: MLSMessageConfig_T
    ! We log messages by toolkit (if useToolkit and UseSDPToolkit are TRUE )
    ! In the following, values would have the effect of adding logged messages:
    ! DEFAULTLOGUNIT: none added
    ! STDOUTLOGUNIT:  to stdout
    !  n > 0:         to ftn unit n
    integer :: logFileUnit             = DEFAULTLOGUNIT ! -2
    ! In the following, values would have the effect on identical warnings of:
    ! -1: Print every one without suppression
    !  0: Suppress every one
    !  1: Print every one only once
    integer :: limitWarnings           = 1000 ! Max number each warning
    integer :: masterTID               = -1 ! Where to send error msg
    character (len=prefixLen) :: prefix &
      &                                = ''   ! Prefix to every msg
    ! Instead of showing both module names and severity for every message
    ! you can control thresholds
    ! (1) the severity below which to skip showing module names
    integer :: skipModuleNamesThr      = MLSMSG_Success ! Always show module
    ! (2) the severity below which to skip showing severity
    integer :: skipSeverityThr         = MLSMSG_Success ! Always show severity
    ! (3) the severity below which to skip messages entirely
    integer :: skipMessageThr          = MLSMSG_Success ! Always show messages
    ! (4) simply skip every debug
    logical :: suppressDebugs          = .false.

    ! Instead of simply calling them Info, you could use something more
    ! informative, like Phase names
    character (len=prefixLen) :: Info   &
      &                                = ''      ! What (else) to call Info
    logical :: useToolkit              = .true.
    integer :: MaxModuleNameLength     = 32      ! Abbreviate longer name
    integer :: MaxSeverityNameLength   = 8       ! Abbreviate longer severity
    logical :: CrashOnAnyError         = .false. ! See crash warning
    logical :: SendErrMsgToMaster      = .false. ! send last gasp to master?
    logical :: ShowCumulativeSeverity  = .false. ! print severity_so_far?
    logical :: StackTrace              = .false. ! Trace via MLSMessageCalls?
    ! Track the last file we were reading/writing if an error occurs and
    ! that file isn't passed in the call statement
    type(MLSFile_T) :: MLSFile ! which file were we reading/writing last?
  end type MLSMessageConfig_T

  ! This variable describes the configuration
  type (MLSMessageConfig_T), public, save :: MLSMESSAGECONFIG
  
  ! The following can be used to help trace the sequence of calls that led
  ! to an error; 
  
  ! it will be dumped (if non-blank) on calls to
  ! (1) StopWithErrorMsg
  ! (2) MLSMessage, if MLSMSG_Severity_to_walkback is set appropriately
  ! (3) MLSMessageCalls('dump')
  ! You may push a name onto it, pop a name off, or clear it by
  ! appropriate commands sent with subroutine MLSMessageCalls
  
  ! Note the following limitations:
  ! Each name must be shorter than (MAXSTACKNAMELEN+1) chars.
  ! Strung together, all the names must not exceed 2048 characters in length
  integer, parameter    ::    MAXSTACKNAMELEN = 64
  type, public :: MLSCallStack_t
    character(len=2048) :: Txt ! All the names, strung together
    integer :: Ind(0:100) = 0  ! Ind(i) is end of ith name
    integer :: Top = 0         ! Top of the stack, index into Ind
    logical :: verbose = .false.
  end type MLSCallStack_t
  type(MLSCallStack_t), public, save :: MLSCALLSTACK
  
  ! Public procedures
  public :: DUMPCONFIG, RESTORECONFIG
  public :: MLSMESSAGE, MLSMESSAGE_, MLSMESSAGESETUP, MLSMESSAGECLOSE
  public :: MLSMESSAGEEXIT, MLSMESSAGEINQUIRE, MLSMESSAGEINTERNALFILE
  public :: MLSMESSAGERESET, PVMERRORMESSAGE
  public :: REPORTTKSTATUS
  public :: MLSMESSAGECALLS, STOPWITHERRORMSG, SUMMARIZEWARNINGS

  interface MLSMESSAGE
    module procedure MLSMESSAGE_
  end interface

contains

  ! ------------------------------------------------  dumpConfig  -----

  ! dump the configuration

  subroutine dumpConfig( config )
    use PrintIt_m, only: Get_Config, LogUnitName, PrefixLen
    ! arg
    type(MLSMessageConfig_T), optional, intent(in) :: config
    ! Internal args
    integer :: LogFileUnit
    type(MLSMessageConfig_T) :: myConfig
    character(len=prefixLen) :: Prefix
    logical :: Toolkit
    ! Executable
    if ( present(config) ) then
      myConfig = config
    else
      myConfig = MLSMessageConfig
    endif
    call get_config ( logFileUnit=logFileUnit, prefix=prefix, useToolKit=toolkit )
    call dump ( 'dumping ', charValue='MLS Message Config' )
    call dump ( ':', charValue=': : : : : : : : : : : : :' )
    call dump ( 'logFileUnit             ', intValue= logFileUnit )
    call dump ( 'meaning                 ', charValue= LogUnitName(logFileUnit))
    call dump ( 'limitWarnings           ', intValue= myConfig%limitWarnings          )
    call dump ( 'masterTID               ', intValue= myConfig%masterTID              )
    call dump ( 'extra prefix            ', charValue=prefix                 )
    call dump ( 'extra Info              ', charValue=myConfig%Info                   )
    call dump ( 'useToolkit              ', logValue= toolkit             )
    call dump ( 'Max Module name length  ', intValue= myConfig%MaxModuleNameLength  )
    call dump ( 'Max Severity length     ', intValue= myConfig%MaxSeverityNameLength  )
    call dump ( 'CrashOnAnyError         ', logValue= myConfig%CrashOnAnyError        )
    call dump ( 'SendErrMsgToMaster      ', logValue= myConfig%SendErrMsgToMaster     )
    call dump ( 'ShowCumulativeSeverity  ', logValue= myConfig%ShowCumulativeSeverity )
    call dump ( 'Trace calls             ', logValue= myConfig%StackTrace             )
    
    call dump ( 'Status values           ', charValue=' '                             )
    call dump ( '  Success               ', intValue=MLSMSG_Success                   )
    call dump ( '  Debug                 ', intValue=MLSMSG_Debug                     )
    call dump ( '  Info                  ', intValue=MLSMSG_Info                      )
    call dump ( '  Warning               ', intValue=MLSMSG_Warning                   )
    call dump ( '  Error                 ', intValue=MLSMSG_Error                     )
    call dump ( '  Crash                 ', intValue=MLSMSG_Crash                     )
    call dump ( 'Severity to quit        ', intValue=MLSMSG_Severity_to_quit          )
    call dump ( 'Severity to crash       ', intValue=MLSMSG_Severity_to_walkback      )
    call dump ( 'Severity so far         ', intValue=MLSMSG_Severity_so_far           )
    
    call dump ( 'Skip ModNames thr       ', intValue=myConfig%skipModuleNamesThr      )
    call dump ( 'Skip Severity thr       ', intValue=myConfig%skipSeverityThr         )
    call dump ( 'Skip Messages thr       ', intValue=myConfig%skipMessageThr          )
    call dump ( 'Suppress Debugs         ', logValue=myConfig%suppressDebugs          )
  end subroutine dumpConfig

  ! ------------------------------------------------  MLSMessage_  -----

  ! This first routine is the main `messaging' code.

  subroutine MLSMessage_( severity, ModuleNameIn, Message, &
    & Advance, MLSFile, status )
    ! A wraparound subroutine so we can 
    ! (1) prevent excessively repeated warning messages
    ! (2) intercept calls 
    ! when the severity is MLSMSG_Error
    ! allowing us to push ModuleNameIn onto the calling stack
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    type(MLSFile_T), intent(in), optional :: MLSFile
    integer, intent(out), optional :: status ! 0 if msg printed, 1 if suppressed
    ! Internal variables
    integer :: msgLength                  ! length to be printed
    integer :: myStatus
    logical :: nosubsequentwarnings
    logical :: newwarning
    integer :: warning_index
    integer :: warningLength              ! length to be checked for repeats    
    character(len=len(Message)+len(WARNINGSSUPPRESSED)) :: &
      & msgPlusNotice                     ! actual message printed
    ! Executable
    msgPlusNotice = message
    myStatus = MLSMSGSTATUS_Suppressed

    ! This is the smaller of the actual length and what we allow to be printed
    msgLength = min( len(message), MAXMESSLENGTH )
    msgLength = max( msgLength, 1 )
    ! This is the smaller of the actual length and what we can check for repeats
    warningLength = min( len(message), WARNINGMESSLENGTH )
    warningLength = max( warningLength, 1 )
    ! Here's where we suppress warning messages beyond a limit for each and all
    if ( severity == MLSMSG_Warning ) &
      & MLSMSGWarnings%totalnumwarnings = &
      & min( TOTALNUMWARNINGSMAX, MLSMSGWarnings%totalnumwarnings + 1 )
    if ( any( severity == (/MLSMSG_Warning, MLSMSG_TestWarning/) ) .and. &
      & ( MLSMSGWarnings%totalnumwarnings > TOTALNUMWARNINGSMAX - 1 ) ) then
      if ( present(status) ) status = myStatus
      return
    elseif ( MLSMSGWarnings%totalnumwarnings > TOTALNUMWARNINGSMAX - 2 ) then
      msgPlusNotice = '(Max Warnings reached)' // message
      msgLength = min(warningLength+len('(Max Warnings reached)'), MAXMESSLENGTH)
    endif
    if ( severity == MLSMSG_Warning ) MLSMSGWarnings%lastWarningMsg = message
    nosubsequentwarnings = .false.
    if ( any( severity == (/MLSMSG_Warning, MLSMSG_TestWarning/) ) &
      & .and. MLSMessageConfig%limitWarnings > -1 &
      & .and. MLSMSGWarnings%numwarnings <= MAXNUMWARNINGS &
      & .and. message /= ' ' ) then
      ! See if we have seen this message before
      newwarning = .true.
      do warning_index = 1, MLSMSGWarnings%numwarnings
        newwarning = newwarning .and. &
          & ( MLSMSGWarnings%warningmessages(warning_index) /= &
          &   trim(message(1:warningLength)) )
      enddo
      if ( newwarning .and. MLSMSGWarnings%numwarnings >= MAXNUMWARNINGS ) then
        if ( severity == MLSMSG_TestWarning ) then
          if ( present(status) ) status = myStatus
          return
        endif
      else if ( newwarning .or. &
        & MLSMSGWarnings%numwarnings < 1 ) then
        if ( severity == MLSMSG_TestWarning ) then
          if ( MLSMessageConfig%limitWarnings > 0 ) myStatus = 0
          if ( present(status) ) status = myStatus
          return
        endif
        MLSMSGWarnings%numwarnings = MLSMSGWarnings%numwarnings + 1
        MLSMSGWarnings%warningmessages(MLSMSGWarnings%numwarnings) = message
        MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) = &
          & MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) + 1
        if ( MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) > &
          & MLSMessageConfig%limitWarnings ) then
          if ( present(status) ) status = myStatus
          return
        endif
        MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) = &
          & min(MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) + 1, &
          & MLSMessageConfig%limitWarnings + 1 )
        nosubsequentwarnings = &
          & (MLSMSGWarnings%timeswarned(MLSMSGWarnings%numwarnings) > &
          & MLSMessageConfig%limitWarnings)
      else
        do warning_index = 1, MLSMSGWarnings%numwarnings
          if ( MLSMSGWarnings%warningmessages(warning_index) == &
            & message(1:warningLength) ) exit
        end do
        if ( warning_index > MLSMSGWarnings%numwarnings ) then
          if ( present(status) ) status = myStatus
          return
        elseif ( severity == MLSMSG_TestWarning ) then
          if ( MLSMSGWarnings%timeswarned(warning_index) < &
            & MLSMessageConfig%limitWarnings  ) myStatus = 0
          if ( present(status) ) status = myStatus
          return
        endif
        ! Now we assure that the times warned array contains all
        ! the times we were called, not just the times we printed
        MLSMSGWarnings%timeswarned(warning_index) = &
          & min(MLSMSGWarnings%timeswarned(warning_index) + 1, &
          & TOTALNUMWARNINGSMAX )
        if ( MLSMSGWarnings%timeswarned(warning_index) > &
          & MLSMessageConfig%limitWarnings + 1 ) then
          if ( present(status) ) status = myStatus
          return
        endif
        nosubsequentwarnings = &
          & (MLSMSGWarnings%timeswarned(warning_index) > &
          & MLSMessageConfig%limitWarnings)
      end if
    end if

    if ( nosubsequentwarnings ) then
      msgPlusNotice = WARNINGSSUPPRESSED // msgPlusNotice
      msgLength = min(msgLength+len(WARNINGSSUPPRESSED), MAXMESSLENGTH)
    endif
    if ( .not. any ( severity >= &
      & (/ MLSMSG_Severity_to_quit, MLSMSG_Severity_to_walkback /) ) ) then
      ! Unless special treatment, just pass args to MLSMessageStd
      call MLSMessageStd( severity, ModuleNameIn, msgPlusNotice(1:msgLength), &
        & Advance )
      if ( present(status) ) status = MLSMSGSTATUS_Normal
      return
    endif
    call MLSMessageCalls( 'push', constantName=ModuleNameIn )
    if ( severity >= MLSMSG_Severity_to_quit ) then
      call StopWithErrorMsg( Message, MLSFile, advance=advance )
      myStatus = MLSMSGSTATUS_Stopped
    else
      call MLSMessageCalls( 'dump' )
      call MLSMessageStd( severity, ModuleNameIn, msgPlusNotice(1:msgLength), &
        & Advance, MLSFile=MLSFile )
      myStatus = MLSMSGSTATUS_Dumped
    endif
    call MLSMessageCalls( 'pop' )
    if ( present(status) ) status = myStatus
  end subroutine MLSMessage_

  ! --------------------------------------------  MLSMessageCalls  -----

  ! Manage the calling stack MLSCallStack
  ! It will be dumped on calling StopWithErrorMsg
  ! possible commands are 
  ! 'push'    push a new name onto MLSCallStack
  ! 'pop'     pop the last name off
  ! 'top'     just return the last name
  ! 'invert'  invert the stack (top becomes bottom, etc.)
  ! 'clear'   clear the stack
  ! 'print'   print its contents as a single line
  ! 'dump'    print a walkback, one name per line, top to bottom
  ! 'depth'   return the number of elements on the stack
  ! 'length'  return the total length taken by the elements on the stack
  ! 'remain'  return the total length remaining before the stack is full
  
  ! Every command except 'print', '[r]dump', 'depth', 'length', 'top',
  ! and 'remain' change the stack
  ! '[r]push' requires name as an input arg
  ! '[r]pop', 'top', and '[r]dump' produce the topmost name as an output arg
  ! 'depth', 'length', and 'remain' produce coded a integer name as output arg
  ! e.g, '1249'

  ! If name is omitted, it will be lost or assumed blank, as appropriate

  subroutine MLSMessageCalls ( command, name, constantName )
    ! Args
    character(len=*), intent(in)              :: command
    ! Because name is (inout) you cannot call this with a constant
    ! so if you wish to use a constant use constantName instead
    character(len=*), optional, intent(inout) :: name
    character(len=*), optional, intent(in)    :: constantName
    ! Internal variables
    character(len=1), parameter :: comma = achar(0) ! '?' ! ','
    integer :: m
    character(len=MAXSTACKNAMELEN) :: myName
    logical, parameter  :: nosubsequentwarnings = .false.
    ! Executable
    myName = ' '
    if ( MLSMessageConfig%stackTrace ) then
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      if ( present(name) .or. present(constantName) ) then
        call printItOut ( 'MLSMessageCalls("' // trim(command) // '","' &
          & // trim(myName) // '")', MLSMSG_info )
      else
        call printItOut ( 'MLSMessageCalls("' // trim(command) // '")', MLSMSG_info )
      end if
    end if
    myName = ' '
    select case( command )
    case ( 'push' )
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      call PushStack( myName )
    case ( 'pop', 'top' )
      call PopStack( name )
      if ( command == 'pop' ) MLSCallStack%top = MLSCallStack%top - 1
    case ( 'clear' )
      MLSCallStack%txt = ' '
      MLSCallStack%top = 0
    case ( 'invert' )
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'dump' )
      call dumpStack
    case ( 'print', 'rprint' )
      if ( MLSCallStack%top < 0 ) then
        call printItOut ( '.. Stack Underflow', MLSMSG_info )
      else if ( MLSCallStack%top == 0 ) then
        call printItOut ( '.. Stack Empty', MLSMSG_info )
      else if ( MLSCallStack%top > ubound(MLSCallStack%ind,1) ) then
        call printItOut ( '.. Stack Overflow', MLSMSG_info )
      elseif( command == 'print' ) then
        call printItOut ( MLSCallStack%txt(: &
          & MLSCallStack%ind(min(MLSCallStack%top,ubound(MLSCallStack%ind,1)))), MLSMSG_info )
      elseif( command == 'rprint' ) then
        MLSCallStack = InvertStack( MLSCallStack )
        call printItOut ( MLSCallStack%txt(: &
          & MLSCallStack%ind(min(MLSCallStack%top,ubound(MLSCallStack%ind,1)))), MLSMSG_info )
        MLSCallStack = InvertStack( MLSCallStack )
      endif
    case ( 'depth' )
      write( myName, '(i8)' ) MLSCallStack%top
      if ( present(name) ) name = myName
    case ( 'length' )
      write( myName, '(i8)' ) MLSCallStack%ind(min(MLSCallStack%top,ubound(MLSCallStack%ind,1)))
      if ( present(name) ) name = myName
    case ( 'remain' )
      write( myName, '(i8)' ) len(MLSCallStack%txt) - &
        & MLSCallStack%ind(min(MLSCallStack%top,ubound(MLSCallStack%ind,1)))
      if ( present(name) ) name = myName
    ! "r"-versions of the usual commands act on the Inverted CallStack
    case ( 'rpop', 'rtop' )
      MLSCallStack = InvertStack( MLSCallStack )
      call PopStack( name )
      if ( command == 'rpop' ) MLSCallStack%top = MLSCallStack%top - 1
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'rpush' )
      if ( present(name) ) myName = name
      if ( present(constantName) ) myName = constantName
      MLSCallStack = InvertStack( MLSCallStack )
      call PushStack( myName )
      MLSCallStack = InvertStack( MLSCallStack )
    case ( 'rdump' )
      MLSCallStack = InvertStack( MLSCallStack )
      call dumpStack
      MLSCallStack = InvertStack( MLSCallStack )
    case default
      ! Unrecognized command--we'll ignore it
      if ( present(name) ) name = "What?"
    end select
    if ( MLSCallStack%verbose .and. command /= 'dump' ) call dumpStack

  contains
    subroutine PopStack ( Name )
      character(len=*), optional, intent(inout) :: Name
      if ( present(name) ) then
        if ( MLSCallStack%top < 0 ) then
          name = "Stack underflow"
        else if ( MLSCallStack%top >= ubound(MLSCallStack%ind,1) ) then
          name = "Stack overflow"
        else
          ! name = MLSCallStack%txt(MLSCallStack%ind(MLSCallStack%top)+1: &
          !                        MLSCallStack%ind(MLSCallStack%top+1))
          m = min(MLSCallStack%top,ubound(MLSCallStack%ind,1)) + 1
          name = MLSCallStack%txt(MLSCallStack%ind(m-2)+1: &
                                    MLSCallStack%ind(m-1))
        end if
      end if
    end subroutine PopStack

    subroutine PushStack ( myname )
      character(len=*), intent(inout) :: myname
      MLSCallStack%top = MLSCallStack%Top + 1
      myName = snipRCSFrom ( myName )
      m = len_trim(myName)
      if ( MLSCallStack%Top > ubound(MLSCallStack%ind,1) ) then
        call dumpStack ( adjustl(myName(:m)) )
      else
        MLSCallStack%ind(MLSCallStack%top) = MLSCallStack%ind(MLSCallStack%top-1) + m
        MLSCallStack%txt(MLSCallStack%ind(MLSCallStack%top-1)+1:) = myName(:m) ! clear the rest
      end if
    end subroutine PushStack

    subroutine DumpStack ( What )
      character(len=*), intent(in), optional :: What
      ! call printItOut ( trim(MLSCallStack), MLSMSG_info )
      if ( present(name) ) name = '' ! In case the stack is weird
      call printItOut ( 'Calling stack (bottom-up)', MLSMSG_info )
      if ( MLSCallStack%top < 0 ) then
        call printItOut ( '.. Stack Underflow', MLSMSG_info )
      else if ( MLSCallStack%top == 0 ) then
        call printItOut ( '.. Stack Empty', MLSMSG_info )
      else
        do m = 1, min(MLSCallStack%top,ubound(MLSCallStack%ind,1))
          call printItOut ( '.. ' // &
            & MLSCallStack%txt(MLSCallStack%ind(m-1)+1: &
                               MLSCallStack%ind(m)), MLSMSG_info )
        end do
        if ( MLSCallStack%top > ubound(MLSCallStack%ind,1) ) then
          if ( present(what) ) then
            call printItOut ( '.. Stack Overflow when pushing ' // what, &
            & MLSMSG_info )
          else
            write (myName(:12), '(i12)') MLSCallStack%top
            call printItOut ( '.. Stack Overflow, top=' // trim(adjustl(myName(:12))), &
              & MLSMSG_info )
          end if
        end if
        if ( present(name) ) &
          & name = MLSCallStack%txt(MLSCallStack%ind(m-2)+1: &
                                    MLSCallStack%ind(m-1))
      end if
    end subroutine DumpStack

    function InvertStack ( Stack ) result( Invert )
      ! Return an inverted Stack; i.e. topmost now bottommost
      ! 2nd from top now 2nd from bottom, etc.
      ! Method: 
      ! One-by-one pop items from input Stack, each time pushing them onto
      ! inverted stack
      type(MLSCallStack_t) :: STACK
      ! Local variables
      integer :: i
      integer :: stackDepth
      type(MLSCallStack_t) :: Invert
      character(len=MAXSTACKNAMELEN) :: Name
      ! Executable
      if ( Stack%top <= 0 ) return
      stackDepth = Stack%top
      do i = 1, stackDepth
        m = min(Stack%top,ubound(Stack%ind,1)) + 1
        name = Stack%txt(Stack%ind(m-2)+1: &
                                  Stack%ind(m-1))
        Stack%top = Stack%top - 1
        Invert%top = Invert%Top + 1
        m = len_trim(name)
        Invert%ind(Invert%top) = Invert%ind(Invert%top-1) + m
        Invert%txt(Invert%ind(Invert%top-1)+1:) = Name(:m) ! clear the rest
      enddo
    end function InvertStack
  end subroutine MLSMessageCalls

  ! --------------------------------------------  MLSMessageInquire  -----

  ! This routine returns requested info about Warnings

  subroutine MLSMessageInquire( Warning_msg, timesWarned, &
    &  totalnumwarnings, LastWarningMsg  )
    ! Args
    integer, optional, intent(out)          :: timesWarned ! how many times 
    character(len=*), optional, intent(in)  :: Warning_msg ! this happened
    integer, optional, intent(out)          :: totalnumwarnings ! grand total
    character(len=*), optional, intent(out) :: LastWarningMsg ! Unless cleared
    ! Internal variables
    integer :: warning_index
    ! Executable code
    if ( present(Warning_msg) ) then
      timesWarned = 0
      do warning_index = 1, MLSMSGWarnings%numwarnings
        if ( index( lowercase(MLSMSGWarnings%warningmessages(warning_index)), &
          & trim(lowercase(Warning_msg)) &
          & ) > 0 ) &
          & timesWarned = timesWarned + MLSMSGWarnings%timeswarned(warning_index)
      enddo
    endif
    if ( present(totalnumwarnings) ) &
      & totalnumwarnings = MLSMSGWarnings%totalNumWarnings
    if ( present(LastWarningMsg) ) &
      & LastWarningMsg = MLSMSGWarnings%LastWarningMsg
  end subroutine MLSMessageInquire

  !-----------------------------------------  MLSMessageInternalFile  -----
  function MLSMessageInternalFile( Severity, ModuleNameIn, Message ) result(line)
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=512)           :: Line   ! Line to output, should be long enough
    integer                       :: Line_len
    ! Internal variables
    ! Executable
    Line_len = 0
    line = ' '
    call assembleFullLine( Severity, ModuleNameIn, Message, line, line_len )
  end function MLSMessageInternalFile

  ! --------------------------------------------  MLSMessageSetup  -----

  ! This routine sets up the MLSMessage suite.  The defaults are of course
  ! sensible, but the user may wish to change things.
  ! (Since we made MLSMessageConfig public, is there any reason to keep this?)
  subroutine MLSMessageSetup ( SuppressDebugs, LogFileUnit, Prefix, useToolkit, &
    & CrashOnAnyError  )

    use PrintIt_m, only: Get_Config, Set_Config, StdoutLogUnit

    ! Dummy arguments
    logical, optional, intent(in) :: SuppressDebugs
    integer, optional, intent(in) :: LogFileUnit
    character (len=*), optional, intent(in) :: Prefix
    logical, optional, intent(in) :: useToolkit
    logical, optional, intent(in) :: CrashOnAnyError

    ! Local variables
    integer :: MyLogFileUnit

    ! Executable code
    call get_config ( logFileUnit=myLogFileUnit )

    if ( present(suppressDebugs) ) &
      & MLSMessageConfig%suppressDebugs=suppressDebugs

    if ( present(logFileUnit) ) then
      if ( myLogFileUnit /= StdoutLogUnit ) call MLSMessage ( &
        & MLSMSG_Warning, ModuleName,"Already writing to a log file" )
    end if

    call set_config ( logFileUnit=myLogFileUnit, prefix=prefix, &
      & useToolkit=useToolkit )
    if ( present(CrashOnAnyError) ) &
      & MLSMessageConfig%CrashOnAnyError=CrashOnAnyError

  end subroutine MLSMessageSetup

  ! --------------------------------------------  MLSMessageClose  -----

  ! This routine simply closes the MLSMessage log file if there is one.
  ! It does so by pointing further logged messages at stdout
  subroutine MLSMessageClose
    use PrintIt_m, only: Set_Config
    ! Executable code
    call set_config ( logFileUnit = STDOUTLOGUNIT ) ! -1
  end subroutine MLSMessageClose

  ! --------------------------------------------  MLSMessageExit  -----

  ! This routine (optionally) logs farewell, advances
  ! (hopefully) gracefully ends logging, and exits 
  ! (optionally with status )
  ! if farewell present, and non-blank, logs it
  ! if farewell present,  but blank, logs default message
  ! if farewell absent, does not log
  subroutine MLSMessageExit ( status, farewell )
  integer, optional, intent(in) :: STATUS
  character(LEN=*), optional, intent(in) :: FAREWELL
  CHARACTER(LEN=36) :: mesg

    ! Executable code
    if(present(status)) then
      if(present(farewell)) then
        if(farewell == ' ') then
          write(mesg, '(A29, I2, A1)') 'Exiting with status (', &
          status, ')'
          call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
        else
          call MLSMessage ( MLSMSG_Info, ModuleName, farewell, advance='y' )
        end if
      end if
      call MLSMessageClose
      if ( status == 1 .and. MLSMessageConfig%CrashOnAnyError ) call crash_burn
      call exit_with_status ( status  )
    else
      if(present(farewell)) then
        if(farewell == ' ') then
          mesg='exit with default status'
          call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
        else
          call MLSMessage ( MLSMSG_Info, ModuleName, farewell, advance='y' )
        end if
      end if
      call MLSMessageClose
      ! stop
      ! call MLSMessage ( MLSMSG_Info, ModuleName, mesg, advance='y' )
      call exit_with_status ( DEFAULTSTOPEXITSTATUS )
    end if
  end subroutine MLSMessageExit

  ! --------------------------------------------  MLSMessageReset  -----

  ! This routine allows you to reset flags, counters, etc. during runtime
  ! (See also restoreConfig)
  subroutine MLSMessageReset ( logFileUnit, CrashOnAnyError, Warnings, &
    & clearLastWarning )
    ! Various uses:
    !   (if logFileUnit supplied)
    ! (1) Close current log file and (re-)open logFileUnit for logging
    !
    !   (if CrashOnAnyError supplied)
    ! (2) Set option so that any call with MLSMSG_Err will result in crash
    !
    !   (if Warnings supplied)
    ! (3) Print summary of past warnings; clear records, rezero totals, etc.
    !
    !   (if clearLastWarning supplied)
    ! (4) Clear last Warning Msg
    !
    ! (Would it be better to have 4 different routines?)
    use PrintIt_m, only: Get_Config, Set_Config
    ! Args
    integer, intent(in), optional :: logFileUnit
    logical, intent(in), optional :: CrashOnAnyError
    logical, intent(in), optional :: Warnings
    logical, intent(in), optional :: clearLastWarning
    ! Local variables
    character(len=6) :: logname
    integer :: MyLogFileUnit
    ! Executable code
    call get_config ( logFileUnit=myLogFileUnit )
    if ( present(logFileUnit) ) then
      if ( logFileUnit /= myLogFileUnit ) then
        write(logname, '(i6)') myLogFileUnit
        call MLSMessage ( MLSMSG_Info, ModuleName, &
          & 'Closing output on' // logname )
        call MLSMessageClose
        call set_config ( logFileUnit = logFileUnit )
        write(logname, '(i6)') logFileUnit
        call MLSMessage ( MLSMSG_Info, ModuleName, &
          & 'Opening output on' // logname )
      end if
    end if
    if ( present(CrashOnAnyError) ) MLSMessageConfig%CrashOnAnyError = CrashOnAnyError
    if ( present(Warnings) ) then
      if ( MLSMSGWarnings%totalNumWarnings > 0 ) then
        call SummarizeWarnings
        call PrintItOut( 'Forgetting old Warnings', MLSMSG_Info )
      endif
      MLSMSGWarnings%numwarnings = 0
      MLSMSGWarnings%totalnumwarnings = 0
      MLSMSGWarnings%timeswarned = 0
      MLSMSGWarnings%warningmessages = ' '
    end if
    if ( present(clearLastWarning) ) MLSMSGWarnings%lastWarningMsg = ' '
  end subroutine MLSMessageReset

  ! --------------------------------------------  PVMERRORMESSAGE  -----
  subroutine PVMErrorMessage ( INFO, PLACE  )
    ! This routine is called to log a PVM error
    integer, intent(in) :: INFO
    character (LEN=*) :: PLACE

    character (LEN=132) :: LINE

    write (line, * ) info
    call printitout(  MLSMSG_PVM // &
    & ' Info='//trim(adjustl(line)) // ' ' // place, MLSMSG_Error )
  end subroutine PVMErrorMessage

  ! ------------------------------------------------  restoreConfig  -----

  ! restore the configuration to its default settings
  ! where it makes sense
  ! i.e., we wouldn't mess with masterTID or logFileUnit

  subroutine restoreConfig
    use PrintIt_m, only: Set_Config
    MLSMessageConfig%limitWarnings           = 1000 
    MLSMessageConfig%skipModuleNamesThr      = MLSMSG_Success ! Always show module   
    MLSMessageConfig%skipSeverityThr         = MLSMSG_Success ! Always show severit  
    MLSMessageConfig%skipMessageThr          = MLSMSG_Success ! Always show messages  
    MLSMessageConfig%suppressDebugs          = .false.                                
    MLSMessageConfig%MaxModuleNameLength     = 32
    MLSMessageConfig%MaxSeverityNameLength   = 8 
    MLSMessageConfig%CrashOnAnyError         = .false. ! See crash warning                                                       
    MLSMessageConfig%SendErrMsgToMaster      = .false. ! send last gasp to master?                                               
    MLSMessageConfig%ShowCumulativeSeverity  = .false. ! print severity_so_far?                
    MLSMessageConfig%StackTrace              = .false. ! Trace via MLSMessageCalls?            
    MLSMSG_Severity_to_quit                  = MLSMSG_Error
    MLSMSG_Severity_to_walkback              = MLSMSG_Error
    call set_config ( asciify=.true., prefix='' )
  end subroutine restoreConfig

  ! ------------ StopWithErrorMsg ------------
  subroutine StopWithErrorMsg ( Message, MLSFile, Advance )
    ! Print Message, dump calling stack (if any) and stop
    character (len=*), intent(in) :: Message ! Line of text
    type(MLSFile_T), intent(in), optional :: MLSFile
    character(len=*), intent(in), optional :: Advance
    ! Internal variables
    character(len=32) :: name
    ! Executable
    name = ' '
    call MLSMessageCalls( 'dump', name )
    if ( len_trim(name) < 1 ) name = ModuleName
    call MLSMessageStd( MLSMSG_Error, name, Message, MLSFile=MLSFile, &
      & advance=advance )
  end subroutine StopWithErrorMsg

  ! ------------ SummarizeWarnings ------------
  subroutine SummarizeWarnings
    ! Print summary of warnings received
    ! Internal variables
    character(len=16) :: number
    integer :: i
    ! Executable
    call PrintItOut( '=========== Warnings Summary (' // &
      & trim(MLSMessageConfig%Info) // ') ==============', MLSMSG_Info )
    write(number, '(i10)') MLSMSGWarnings%totalnumwarnings
    call PrintItOut( 'Grand total' // ' ' // adjustl(number), MLSMSG_Info )
    write(number, '(i10)') MLSMSGWarnings%numwarnings
    call PrintItOut( 'Different' // ' ' // adjustl(number), MLSMSG_Info )
    if ( MLSMSGWarnings%numwarnings < 1 ) return
    call PrintItOut( 'number             message', MLSMSG_Info )
    do i=1, MLSMSGWarnings%numwarnings
      write(number, '(i10)') MLSMSGWarnings%timeswarned(i) - 1
      ! So grep can quickly spot the summarized warnings by, e.g.
      ! grep '##' mlsl2.log
      if ( MLSMSGWarnings%ALLCAPSSummaries ) then
        call PrintItOut( trim(number) // ' ## ' &
          &  // trim(Capitalize(MLSMSGWarnings%warningmessages(i))), MLSMSG_Info )
      else
        call PrintItOut( trim(number) // ' ## ' &
          &  // trim(MLSMSGWarnings%warningmessages(i)), MLSMSG_Info )
      endif
    enddo
  end subroutine SummarizeWarnings

  ! Private procedures
  ! --------------------------------------------  dumpFile  -----
  subroutine dumpFile ( MLSFile  )
    ! Show everything about it
    type(MLSFile_T) :: MLSFile
    integer, parameter :: SEVERE = MLSMSG_Error
    ! Executable code
    call printitout ( 'MLS File Info: ', MLSMSG_Error )                                  
    call dump ( '(name) ', charValue=trim(MLSFile%Name))                                  
    call dump ( 'short name ', charValue=trim(MLSFile%shortName))                                  
    call dump ( '    Type (int)   : ', MLSFile%Type)
    call dump ( '    Type         : ', charValue=trim(MLSFile%TypeStr))
    call dump ( '    Access       : ', charValue=trim(accessDFACCToStr(MLSFile%access)))
    call dump ( '    content      : ', charValue=trim(MLSFile%content))
    call dump ( '    last Operatn : ', charValue=trim(MLSFile%lastOperation))
    call dump ( '    File ID      : ', MLSFile%FileId%f_id)
    call dump ( '    Group ID     : ', MLSFile%FileId%grp_id)
    call dump ( '    DataSet ID   : ', MLSFile%FileId%sd_id)
    call dump ( '    PCF ID       : ', MLSFile%PCFId)
    call dump ( '    PCF Range    : ', MLSFile%PCFidRange%Bottom)
    call dump ( '                 : ', MLSFile%PCFidRange%Top)
    call dump ( '    hdf version  : ', MLSFile%HDFVersion)
    call dump ( '    record length: ', MLSFile%recordLength)
    call dump ( '    Open?        : ', logValue= MLSFile%StillOpen)
    call dump ( '    error code   : ', MLSFile%errorCode)
  end subroutine dumpFile

  !-----------------------------------------  assembleFullLine  -----
  ! Assemble the full line out of 
  ! (1) A severity level
  ! (2) The module name
  ! (3) Whatever message we're asked to repeat
  subroutine assembleFullLine( Severity, ModuleNameIn, Message, &
    & line, line_len )
    integer, intent(in)           :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character(len=*)              :: Line
    integer                       :: line_len
    ! Assemble a full message line

    if ( severity < MLSMessageConfig%skipMessageThr ) then
      return
    elseif ( line_len == 0 ) then
      if ( severity < MLSMessageConfig%skipSeverityThr ) then
        line = ' '
      elseif ( severity > MLSMSG_Success-1 .and. severity < MLSMSG_Crash+1 ) then
        line = trim(SeverityNamesFun(severity))
        if ( MLSMessageConfig%ShowCumulativeSeverity .and. len_trim(line) > 0 ) then
          line = trim(line) // ':' // &
            & trim(SeverityNamesFun(MLSMSG_Severity_so_far))
        endif
        if ( severity == MLSMSG_Info .and. &
          & len_trim(MLSMessageConfig%Info) > 0 ) &
          & line = trim(line) // ' ' // MLSMessageConfig%Info
      else
        line = 'Unknown'
      end if
      line_len = len_trim(line)
      if ( severity >= MLSMessageConfig%skipModuleNamesThr .and. &
        & len_trim(snipRCSFrom ( moduleNameIn )) > 0 ) then
        line(line_len+1:line_len+2) = ' ('
        line(line_len+3:) = snipRCSFrom ( moduleNameIn )
        line_len = len_trim(line) + 3
        line(line_len-2:line_len-1) = '):'
      elseif ( severity >= MLSMessageConfig%skipSeverityThr ) then
        line_len = len_trim(line) + 1
        line(line_len:line_len) = ':'
      end if
    end if
    ! Make sure that we don't start prefixing with a blank
    if ( any( severity >= &
      & (/MLSMessageConfig%skipModuleNamesThr, MLSMessageConfig%skipSeverityThr/) &
      & ) .and. line(1:1) == ' ' ) then
      line_len = line_len - 1
      line(1:line_len) = line(2:line_len+1)
    endif
    line(line_len+1:) = message
    line_len = line_len + len(message) ! Not len_trim, so we can get
    ! trailing blanks into a part of a message.  If there are trailing
    ! blanks remaining when my_adv is true, they'll be trimmed off.
  end subroutine assembleFullLine

  ! --------------------------------------------  dump  -----
  subroutine dump ( name, intValue, charValue, logValue, trimName  )
    ! In any way we're asked
    character(len=*), intent(in) :: name
    integer, intent(in), optional :: intValue
    character(len=*), intent(in), optional :: charValue
    logical, intent(in), optional :: logValue
    logical, intent(in), optional :: trimName
    !
    character(len=132) :: line
    character(len=32)  :: value
    logical            :: myTrim
    ! Executable
    myTrim = .false.
    if ( present(trimName) ) myTrim = trimName
    value = ''
    if ( present(intValue) ) then
      write(value, '(i10)') intValue
    elseif ( present(logValue) ) then
      write(value, '(l10)') logValue
    endif
    if ( present(charValue) ) then
      line = name // ' : ' // trim(charvalue)
      if ( myTrim ) line = trim(name) // ' : ' // trim(charvalue)
    else
      line = name // ' : ' // trim(value)
      if ( myTrim ) line = trim(name) // ' : ' // trim(value)
    endif
    call printitout(trim(line), MLSMSG_Error)
  end subroutine dump

  function LowerCase (str) result (outstr)
    ! takes A-Z  and replaces with a-z
    ! leaving other chars alone
    !--------Argument--------!
    character (len=*), intent(in) :: STR
    character (len=len(str))      :: OUTSTR

    !----------Local vars----------!
    integer            :: i, icode
    integer, parameter :: offset=IACHAR("a")-IACHAR("A")
    !----------Executable part----------!
    outstr=str

    DO i = 1, LEN(str)
       icode=IACHAR(outstr(i:i))
       IF ( icode >=IACHAR("A") .AND. icode <= IACHAR("Z")) THEN
          outstr(i:i)=achar(icode+offset)
       END IF
    END DO

  END FUNCTION LowerCase

  subroutine MLSMessageStd ( Severity, ModuleNameIn, Message, &
    & Advance, MLSFile )

    ! Print a message (unless printing is suppressed).  If it has %[Nn]
    ! in it, replace that with newline.

    use PrintIt_m, only: Get_Config
    ! Dummy arguments
    integer, intent(in) :: Severity ! e.g. MLSMSG_Error
    character (len=*), intent(in) :: ModuleNameIn ! Name of module (see below)
    character (len=*), intent(in) :: Message ! Line of text
    character (len=*), intent(in), optional :: Advance ! Do not advance
    !                                 if present and the first character is 'N'
    !                                 or 'n'
    type(MLSFile_T), intent(in), optional :: MLSFile

    ! Local variables
    !                                     If nonzero, do not insert prefix.
    logical :: AllOfIt                  ! Print all of it (no %n or %N remains)
    integer :: L1, L2                   ! How far in the line have we printed?
    character (len=512), save :: Line   ! Line to output, should be long enough
    integer, save :: Line_len=0         ! Number of saved characters in line.
    integer :: LogFileUnit
    logical :: My_adv

    ! Executable code
    MLSMSG_Severity_so_far = max( MLSMSG_Severity_so_far, severity )
    my_adv = .true.
    if ( present(advance) ) &
      & my_adv = advance(1:1) /= 'n' .and. advance(1:1) /= 'N'

    my_adv = my_adv .and. ( severity >= MLSMessageConfig%skipMessageThr )
    if ( (.not. MLSMessageConfig%suppressDebugs).OR. &
         & (severity /= MLSMSG_Debug) ) then
      l1 = 0
      do
        l2 = index(Message(l1+1:),'%n' )
        if ( l2 == 0 ) l2 = index(Message(l1+1:),'%N')
        allOfIt = l2 == 0
        l2 = l2 + l1 - 1 ! Last character before %n or %N, if any
        if ( allOfIt ) l2 = len(Message) ! no %n or %N
        call assembleFullLine( Severity, ModuleNameIn, Message(l1+1:l2), &
          & line, line_len )
        l1 = l2 + 2 ! "n" or "N" of %n or %N
         ! Log the message using the toolkit routine
         ! (or its substitute )
         ! if either using toolkit or severity is sufficient to
         ! quit (which means we might have been called directly
         ! rather than from output module )

        if ( my_adv .or. .not. allOfIt ) then
          call printitout( line, severity, line_len )
          line_len = 0
          line = ' '
        end if
        if ( allOfIt ) exit
      end do

    end if

    ! Now if it's an error, and the message is complete, then try to close
    ! log file if any and quit (or crash)

    if ( my_adv .and. severity >= MLSMSG_Severity_to_quit ) then
      ! Here's a chance to dump facts about last file we were reading/writing
      if ( present(MLSFile) ) then
        call dumpFile(MLSFile)
      elseif( MLSMessageConfig%MLSFile%name /= ' ' ) then
        call dumpFile( MLSMessageConfig%MLSFile )
      endif
      if ( MLSMessageConfig%SendErrMsgToMaster .and. &
        & MLSMessageConfig%masterTID > 0 ) call LastGasp(ModulenameIn, Message )
      call get_config ( logFileUnit = logFileUnit )
      if ( logFileUnit > 0 ) close ( logFileUnit  )
      if ( severity >= MLSMSG_Crash .or. MLSMessageConfig%CrashOnAnyError ) then
        NEVERCRASH = .false.
        call crash_burn
      endif
      call exit_with_status ( 1  )
    end if
  end subroutine MLSMessageStd

  function ModuleNameFun ( moduleName ) result (name)
    ! Return name of module unless asked to abbreviate
    character(len=*), intent(in)    :: moduleName
    character(len=len(ModuleName))  :: name
    name = moduleName
    if ( len_trim(moduleName) < 1 ) name = 'Unknown'
    if ( MLSMessageConfig%MaxModuleNameLength < 1 ) then
      name = ' '
    elseif ( MLSMessageConfig%MaxModuleNameLength < len(ModuleName) ) then
      name = name(1:MLSMessageConfig%MaxModuleNameLength) // ' '
    endif
  end function ModuleNameFun

  function SeverityNamesFun ( severity ) result (name)
    ! Return name of level corresponding to severity, if recognized
    ! If not recignized, return  'Unknown'
    ! Full name unless asked to abbreviate
    integer, intent(in)                   :: severity
    character(len=len(SeverityNames(1)))  :: name
    if ( severity < MLSMSG_Success .or. severity > MLSMSG_Crash ) then
      name = 'Unknown'
    else
      name = SeverityNames( severity )
    endif
    if ( MLSMessageConfig%MaxSeverityNameLength < 1 ) then
      name = ' '
    elseif ( MLSMessageConfig%MaxSeverityNameLength < len(SeverityNames(1)) ) then
      name = name(1:MLSMessageConfig%MaxSeverityNameLength) // ' '
    endif
  end function SeverityNamesFun

  function snipRCSFrom ( with ) result ( without )
    ! Trim nonsense involving RCS system from input "with"
    ! (if present)
    ! Args
    character(len=*), intent(in) :: with
    character(len=len(with))     :: without
    integer :: secondBuck
      if ( with(1:1) == '$' ) then
      ! The with is <dollar>RCSFile: <filename>,v <dollar><otherstuff>
      ! The without is <filename><otherstuff>
        secondBuck = 1 + index( with(2:),'$')
        if ( secondBuck-3 > 11 .and. secondBuck < len_trim(with) ) then
          ! without = with(11:(LEN_TRIM(with)-8))
          without = with(11:secondBuck-4) // with(secondBuck+1:)
        else
          without = with(11:(LEN_TRIM(with)-8))
        endif
      else
        without = with
      end if
      without = ModuleNameFun( without )
  end function snipRCSFrom
  
!
! $Log$
! Revision 2.24  2013/08/23 02:51:04  vsnyder
! Move PrintItOut to PrintIt_m
!
! Revision 2.23  2013/07/30 23:19:53  pwagner
! Added a few extra cmds to MLSCallStack
!
! Revision 2.22  2013/06/28 18:15:51  pwagner
! Eliminate bare stop; enhance call stack; treat each of line prefixes (severity, name) separately
!
! Revision 2.21  2012/08/21 23:52:32  pwagner
! Removed comments about non-existent function; MaxModuleNameLength made adequate
!
! Revision 2.20  2012/08/16 17:35:30  pwagner
! Changed how and when message lines are printed
!
! Revision 2.19  2012/07/18 00:36:03  pwagner
! Replaced -1 and -2 for LogFileUnit with module parameters
!
! Revision 2.18  2012/07/02 20:18:39  pwagner
! Added restoreConfig
!
! Revision 2.17  2012/05/16 19:23:26  vsnyder
! Remove duplicate SendErrMsgToMaster dump, some cannonball polishing
!
! Revision 2.16  2011/10/10 23:56:02  pwagner
! Prevent writing non-ascii chars to stdout
!
! Revision 2.15  2011/08/25 18:22:33  honghanh
! Add fix to PVMErrorMessage to print custom error message.
!
! Revision 2.14  2011/07/22 19:47:00  vsnyder
! Add Advance argument to StopWithErrorMsg, pass it through to MLSMessageStd.
! Add %n and %N as newline characters in MLSMessageStd.
!
! Revision 2.13  2011/06/29 21:40:11  pwagner
! Added ability to omit message prefixes, or entire messages according to sedverity
!
! Revision 2.12  2011/04/05 00:03:14  pwagner
! MLSMSG_Severity_so_far now available as a return status if mlspgs treated as a function
!
! Revision 2.11  2010/10/07 23:29:26  pwagner
! MLSMessage optionally returns status
!
! Revision 2.10  2009/06/16 17:10:12  pwagner
! Can Capitalize messages in warnings summaries
!
! Revision 2.9  2008/05/28 21:01:48  pwagner
! Break endless cycling between PVMErrorMessage and MLSMessage
!
! Revision 2.8  2008/05/23 23:16:22  vsnyder
! Added tracing of call stack operations
!
! Revision 2.7  2008/02/22 21:31:38  pwagner
! Can now dump messaging configuration
!
! Revision 2.6  2007/12/07 01:10:36  pwagner
! Keeps track of and permits inquiries about warnings better
!
! Revision 2.5  2007/10/03 23:59:46  vsnyder
! Simplify call stack
!
! Revision 2.4  2007/09/06 22:29:55  pwagner
! Impose limit on total warnings
!
! Revision 2.3  2007/08/31 00:02:28  pwagner
! Added procedure to summarize warnings
!
! Revision 2.2  2007/08/29 19:51:02  pwagner
! Worked around Intel quirk that wraps stdout when 'FMT=*'
!
! Revision 2.1  2007/08/27 23:52:14  pwagner
! First commit
!
