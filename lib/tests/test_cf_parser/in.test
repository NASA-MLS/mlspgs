; $Id$
;
; This is the Level 2 Configuration file for version 0.1 of the Level
; 2 software for the EOS Microwave Limb Sounder (MLS).
;
; The task of the Level 2 software is to convert calibrated radiance
; observations (Level 1) data into estimates of geophysical parameters
; such as temperature and constituent abundance.
;
; For more details on the software see:
;    EOS MLS Retrieval Processes Algorithm Theoretical Basis Document
;      JPL D-16159
;    Functional Requirements for the EOS MLS Level 2 software
;      JPL D-18027
;    EOS MLS Level 2 file description document
;      JPL D-18028
;    EOS MLS Level 2 software users' guide
;      JPL D-18029
;    Design of the EOS MLS Level 2 software for version 0.1
;      JPL D-18030.
;
; In the case of version 0.1 the goal of the Level 2 software is
; simply to test the interfaces between the SDP software and the toolkit
; and between the software and the Level 1 software.
;
; -----------------------------------------------------------------------------
;
; This section of the l2cf gives global settings to the software,
; output file comments, file versions etc.  Note that while this
; section must occur first in the l2cf, the ordering of these options
; within the section is not critical
;
BEGIN GlobalSettings
    ;;
    ;; This comment string is placed in the `header' for all the
    ;; output files.
    ;;
    VersionComment="L2CF Version 0-1-0 for version 0.1 of the MLS software"
    ;;
    ;; The way the SDP toolkit works, the software cannot control
    ;; filenames, it is given them through the PCF.  This means that
    ;; all the software can do is ensure that it is being asked to
    ;; produce an appropriately named file.
    ;;
    ;; So here we state what version information we expect to see embedded
    ;; the filenames.  If these strings are blank then no limitation
    ;; is applied.  Also the user can override this checking by
    ;; setting the option "IgnoreVersion" to .TRUE. (the default is .FALSE.)
    ;; (Note that this will generate a warning message.)
    ;;
    InputVersionString="v0-1-0-test"
    OutputVersionString="v0-1-0-test"
    ;;
    ;; In most cases, an attempt to multiply define a priori
    ;; quantities should cause an error.  For example, if there are
    ;; two climatology files, then they should not both contain a
    ;; definition of temperature.  However, in testing it may be
    ;; useful to try out different a priori fields without having to
    ;; edit the complete `configured' file.  Setting this option
    ;; allows the user to `overload' the definitions of a priori
    ;; quantities by using multiple climatology files.  Values in
    ;; later files supersede those in earlier files.
    ;;
    ;; Note that if this option is set TRUE a warning message is
    ;; generated at the start and each time an overload takes place.
    ;;
    AllowClimatologyOverloads=FALSE
    ;;
END GlobalSettings
;
; -----------------------------------------------------------------------------
;
; This next part of the l2cf instructs the software to read various
; quantities in from the climatology database.

BEGIN ReadApriori
time
    ;;
    ;; Each line in this file describes one geophysical parameter
    ;; for which a priori information is needed from the
    ;; climatology file(s). 
    ;;
    ;; The first part of the line is the name by which the a priori
    ;; information is to be identified throughout the software.
    ;;
    ;; Following this a field 'source=<name>' indicates the name by
    ;; which the field is identified in the climatology file.
    ;;
    ;; The 'length=<length>' field indicates the horizontal
    ;; correlation length for the quantity.
    ;;
    ;; The field 'versionRange=..' indicates a range of acceptable
    ;; versions in CCSDS format.  
    ;; Alternative formats for the date information are:
    ;;  <earliest allowed date> .. <latest allowed date>
    ;;  .. <latest allowed date>   (i.e. dated some time before ..)
    ;;  <earliest allowed date> .. (i.e. dated some time after)
    ;;
    ;; The ordering of these fields is irrelevant, and all fields
    ;; other than source are optional
    ;;
    ;; So for example
    ;;
    aprioriTemp: climatology, source=temperature, length=200km, $
       versionRange="1999-01-01T" : "2000-01-01T"
    aprioriTemp_precision: climatology, source=temperature_precision, $
       length=200km, $
       versionRange="1999-01-01T" : "2000-01-01T"
    ;;
    ;; The quantity is aprioriTemp, information for this (value,
    ;; precision and vertical correlation length) is taken from the
    ;; `temp', 'temp_precision', and 'temp_verticalCorrelation' fields
    ;; in the climatology file(s) respectively.  The horizontal
    ;; smoothing length is 200km, and the data must come from a file
    ;; dated sometime between 1st January 1999 and 1st January 2000.
    ;; So here are the rest of the quantities.  We'll just consider
    ;; the primary products here.
    ;;
    aprioriGPH: climatology, source=GPH, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriGPH_precision: climatology, source=GPH_precision, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriH2O: climatology, source=H2O, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriHNO3: climatology, source=HNO3, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriO3: climatology, source=O3, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriHCl: climatology, source=HCL, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriClO: climatology, source=ClO, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriN2O: climatology, source=N2O, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    aprioriCO: climatology, source=CO, length=200km, $
      versionRange="1999-01-01" : "2000-01-01"
    ;;
END ReadApriori
;
; -----------------------------------------------------------------------------
;
; Having read some a priori data from the climatology database in the
; previous section, the next task is to possibly merge it with
; NCEP/DAO data.  This is the responsibility of this section of the l2cf
;
BEGIN MergeApriori
    ;;
    ;; Each line describes a seperate merge operation.  The first word
    ;; is the name of the apriori field as created in the ReadApriori
    ;; section.  Following that are various fields:
    ;;
    ;; The source field indicates whether NCEP or DAO data is to be
    ;; merged. The species field indicates what species is to be read
    ;; from the NCEP/DAO data. It is also used by the software to
    ;; indicate if this specie is to be treated in a special manner
    ;; (as is the case for GPH).
    ;;
    ;; There are two merging methods, 'weighted' and
    ;; 'direct'. Weighted merges the data using a weighting by error
    ;; method.  Direct simply replaces the data in the field with the
    ;; NCEP/DAO data.  In each case a range is given over which the
    ;; data is to be merged if available. A length scale is also given
    ;; for the `smooting' that takes place above and below the merge
    ;; range.
    ;;
    ;; So for example:
    ;;
    merge, apriori=aprioriTemp,source=NCEP,species=temperature, $
       range=1000.0mb : 1mb, method=weighted, scale=5km
    ;;
    ;; For aprioriTemp merge the NCEP temperature data in over the
    ;; range 1000-1 mb.  The merging is done using a weighting by
    ;; error method. The edges are 'merged' with a length scale of 5km
    ;; (crudely converted into pressure coordinates)
    ;;
    merge, apriori=aprioriTemp_precision, source=NCEP, $
      species=temperature_precision, range=1000.0mb : 1mb, $
      method=weighted, scale=5km
    ;;
    ;; This line describes how the precisions are merged also, if
    ;; omitted the orginal aprioriTemp_precision from the climatology
    ;; file is left intact.  This is the case for the
    ;; aprioriTemp_verticalCorrelation field, which as it is not
    ;; mentioned here, is unchanged from the input climatology dataset.
    ;;
    ;; Geopotential height is somewhat similar.
    ;;
    merge, apriori=aprioriGPH, source=NCEP, species=GPH, $
      height=100.0mb, method=weighted
    ;;
    ;; Only one surface is needed for GPH, so we give that
    ;; alone. Clearly we don't need scale information for a single
    ;; surface merge.
    ;;
    merge, apriori=aprioriGPH_precision, source=NCEP, $
      species=GPH_precision, height=100.0mb, method=weighted
    ;;
    ;; Later methods will be devised for relative humidity.
    ;;
END MergeApriori
;
; -----------------------------------------------------------------------------
;
; This next section of the l2cf defines how the dataset is to be
; broken into `chunks'.  This is done according to a set of rules,
; parameters for which are given below.
;
BEGIN ChunkDivide
time
    ;;
    ;; This items in this section can occur in any order.
    ;;
    ;; First we specify what is the desirable length of a chunk which
    ;; we wish to strive for.
    ;;
    IdealLength=0.25 orbits
    ;;
    ;; Here we specify it as a given fraction of an orbit.
    ;; Alternatives are a given number of major frames, or a given
    ;; length of time (speficied in minutes)
    ;;
    ;; Now we specify how many MAFs of overlap is desirable.
    ;;
    Overlap=5 MAFs
    ;;
    ;; Again, we could express this in orbits or minutes.
    ;;
    ;; Now we specify a home orbit angle.  This is the orbit angle we
    ;; will try to start at least one chunk at.  Ideally this would be
    ;; the the chunk that starts the first `full orbit' in the
    ;; dataset, but data gaps etc. may make this impossible.  The
    ;; `orbit angle' is similar to latitude, being the angle swept out
    ;; by the spacecraft (or tangent point in this case) in the
    ;; orbital plane.  0 is defined to be at the first equator
    ;; crossing of the day, and the angle increments through the day.
    ;; Thus the second orbit crossing of the day is at 360, the third
    ;; at 720 and so on.
    ;;
    HomeGeodAngle=0 degrees
    ;;
    ;; Here we define which of the two MLS module tangent points (THz
    ;; or GHz) this angle is refering to.
    ;;
    HomeModule=GHz
    ;;
    ;; Here we define the minimum criteria for even bothering to do a
    ;; retrieval. Long periods of data that do not meet this criteria
    ;; are excluded from consideration.
    ;;
    ScanLowerLimit= -10 km : 20 km
    ScanUpperLimit=  40 km : 100 km
    ;;
    CriticalScanningModules=Both
    ;;
    ;; So here we've defined a valid scan as one running from
    ;; somewhere between -10 and 10 km, upto somewhere between 40 and
    ;; 100km.  Both modules must be scanning for data to be useful.
    ;; Alternatives to 'both' are 'THz', 'GHz', 'either' or
    ;; 'none'. 'none' would allow for retrieval from limb tracking
    ;; data.
    ;;
    ;; Now we list the bands that must be on for data to be considered
    ;; useful. This is a standard boolean expression using the MLS
    ;; standard nomenclature and wildcards.
    ;;
    CriticalBands="R1A:118.B1:PT or R1B:118.B21:PT and R2:190.B*"
    ;;
    ;; This field is not dealt with in v0.1 and so it's value is in
    ;; fact irrelevant.
    ;;
    ;; Now we specify how long a data gap (i.e. one of the above
    ;; criteria not being met) is allowed before we force a chunk
    ;; division. We can specify this in minutes, MAFs or orbits.
    ;; 
    MaxGap=3 minutes
    ;;
END ChunkDivide
;
; ----------------------------------------------------------------------------
;
; This next section of the l2cf is probably the most complicated in
; this version of the software.  It describes how all the hierarchy of
; entities that make up vector templates are put together.
; vGrid,hGrid->quantity template->vector template.
;
BEGIN Construct
    ;;
    ;; The syntax of this section is of the form
    ;; <name>:<type of entity>, <definition>
    ;;
    ;; Where <type> is hGrid, vGrid, quantity or vectorTemplate.  Name
    ;; is a unique name to identify the object being created, and the
    ;; remaining information varies depending on what is being
    ;; described.
    ;;
    ;; ----------------------------------------------------------------------
    ;;
    ;; Let's start by creating a few vGrids. These are vertical
    ;; coordinate systems.
    ;;
    vGridHiRes: vGrid, coordinate=Pressure, type=Logarithmic, $
                start=1000mb, number=60, per_decade=12
    ;;
    ;; This gives us 60 pressure surfaces at 12 per decade from 1000mb up.
    ;;
    vGridStandard: vGrid, coordinate=Pressure,type=Logarithmic, $
                   start = 1000mb, number =[25, 24], per_decade =[12, 6]
    ;;
    ;; This one gives 12 per decade from 1000mb to 10mb, with 6 per
    ;; decade above that up to 0.001mb.
    ;;
    ;; The last one is a very simple one for GPH
    ;;
    vGridGPH: vGrid, coordinate=Pressure, type=Explicit, values=100mb
    ;;
    ;; ----------------------------------------------------------------------
    ;;
    ;; The next things to define are hGrids.  These define horizontal
    ;; coordinate systems.  This first one is the most basic.
    ;;
    hGridStandard: hGrid, module=ghz, type=fractional, fraction=0.5
    ;;
    ;; Here we say that the method hGridStandard has profiles spaced
    ;; at master coordinates (phi) in the center (0.5) of each scan.
    ;; By changing the value from 0.5 to say 0 we can place the
    ;; profiles a the lowest phi in each scan etc.
    ;;
    ;; Here are a few more for illustration purposes only
    ;;
    hGridTroposphere: hGrid, module=ghz, type=height, height=10km
    ;;
    ;; This hGrid places the profile at the point where the scans
    ;; cross 10km.  If for some bizarre reason this occurs twice in a
    ;; major frame (some severe spacecraft maneuver for example) the
    ;; earliest is chosen.
    ;;
    ;; Now here are two more ones derived from the first
    ;;
;?? hGridCoarse: hGrid, module=ghz, type=fractional, fraction=0.5, $
;??                     interpolationfactor=0.5
;?? hGridFine: hGrid, module=ghz, type=fractional, fraction=0.5, $
;??                   interpolationfactor=3
    ;;
    ;; The first corresponds to every second profile of hGridStandard,
    ;; the second to an interpolation in phi, with two extra profiles
    ;; evenly spaced between each one of hGridStandard.
    ;;
    ;; ---------------------------------------------------------------------
    ;;
    ;; Now we move onto defining the vector quantities.  The
    ;; definitions of these are a little more complex.  The simplest
    ;; way to describe it is by using examples.
    ;;
    temp: quantity, vGrid=vGridHiRes, hGrid=hGridStandard, type=temperature
    gph: quantity, vGrid=vGridGPH, hGrid=hGridStandard, type=gph
    ;;
    H2O: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=H2O, unit=ppmv
    HNO3: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=HNO3, unit=ppbv
    O3: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3, unit=ppmv
    HCl: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=HCl, unit=ppbv
    ClO: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=ClO, unit=ppbv
    N2O: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O, unit=ppbv
    CO: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=CO, unit=ppmv
    ;;
    ;; Now, here we'll introduce a few of the so-called 'diagnostic'
    ;; products, species from multiple bands etc.  As this is version
    ;; 0.1 we'll only do enough to test the system out, we won't go
    ;; the whole way and include them all.
    ;;
    O3_190: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3
    O3_640: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=O3
    ;;
    N2O_190: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O
    N2O_640: quantity, vGrid=vGridStandard, hGrid=hGridStandard, $
       type=vmr, molecule=N2O
    ;;
    ;; Define the tangent pressure quantities
    ;;
    ptan118: quantity, type=ptan, radiometer="R1A:118"
    ptan2t5h: quantity, type=ptan, radiometer="R5H:2T5"
    ;;
    ;; So clearly defining quantities is fairly complex. The fields
    ;; are as follows:
    ;;
    ;; name - Name for quantity
    ;; type - temperature, gph, vmr or ptan. (No doubt others will
    ;;        appear)
    ;; vGrid - name of vGrid for quantity if appropriate
    ;; hGrid - name of hGrid for quantity if appropriate
    ;; molecule - Name of molecule described by quantity for forward
    ;;            model calculation use
    ;; unit - Unit for quantity.
    ;; radiometer - Which radiometer ptan quantity refers to.
    ;;
    ;; The vGrid and hGrid fields may be implicit, For example in minor
    ;; frame quantities such as tangent pressures.  This is the limit
    ;; of the flexibility required for v0.1. Later versions will need
    ;; to consider spectroscopy quantities, isotope ratios, irregular
    ;; quantities etc.
    ;;
    ;; ====================================================================
    ;;
    ;; Now we define our vector templates.  This is simply done by
    ;;
    ;; vectorTemplate, quantities=quantity list
    ;;
    stateTemplate: vectorTemplate, quantities= [ ptan118, ptan2t5h, temp, gph, $
      h2o, hno3, o3, hcl, clo, n2o, co, o3_190, o3_640, n2o_190, n2o_640 ]
    ;;
    ;; Having done the state vector template, now we define the measurement
    ;; vectors.  These are typically made up of collections of bands.
    ;; Here is an example:
    ;;
;?? MainR1RadiancesTemplate: vectorTemplate, signals="R1A:118.B1F:PT" $
;??     "R1A:118.B32W:PT"
    ;;
    ;; This defines a measurement vector template containing all the
    ;; radiances in the 25 channel filter bank and wide filters in R1A
    ;; (leave aside the issue of multiple filterbank routing for the
    ;; moment).
    ;;
    ;; Of course, the vector quantities have not been defined with a
    ;; line 'quantity, name=R1A:118.B1F:PT ...' however, as the name
    ;; conforms to the channel nomenclature, it is implicitly
    ;; understood by the software.
    ;;
    ;; As this is version 0.1, and we're not going to do anything
    ;; with these vectors, we'll just define one more
    ;;
;?? OtherRadiancesTemplate: vectorTemplate, signals="R2:190.B2F:H2O" $
;??     "R2:190.B3F:N2O"
    ;;
END Construct
;
; -----------------------------------------------------------------------------
;
; Having created vector templates and the entities that compose them,
; the next stage is to define vectors according to those templates and
; fill them with appropriate values.
;
; The only option implemented in v0.1 is the creation. Filling is not
; done.
;
BEGIN Fill
    ;;
    ;; First we'll create two vectors: state and apriori which follow
    ;; the state template
    ;;
    state: Vector, template=stateTemplate
    apriori: Vector, template=stateTemplate
    ;;
    ;; Now we create the measurement vectors
    ;;
;?? MainR1Radiances: Vector, template=MainR1RadiancesTemplate
;?? OtherRadiances: Vector, template=OtherRadiancesTemplate
    ;;
END Fill
;
; ----------------------------------------------------------------------------
;
; This section of the l2cf defines the join operation where the data
; from the individual chunks are joined together in a continuous
; stream ready to be output.
;
BEGIN Join
    ;;
    ;; Each line in this file lists a quantity to be joined, the
    ;; source of information for it, and whether the overlaps are to
    ;; be compared and/or output.
    ;;
    ;; Here is a simple example
    ;;
    tempL2gp: l2gp, source=state.temp, /compareOverlaps, /outputOverlaps
    ;;
    ;; We create an output quantity called tempL2gp, taken from the temp
    ;; quantity in the vector called state.  The overlaps are
    ;; compared, and are to be output as an l2gp quantity.
    ;;
    ;; The rest are easy:
    ;;
    gphL2gp: l2gp, source=state.gph, /compareOverlaps, /outputOverlaps
    h2oL2gp: l2gp, source=state.h2o, /compareOverlaps, /outputOverlaps
    hno3L2gp: l2gp, source=state.hno3, /compareOverlaps, /outputOverlaps
    o3L2gp: l2gp, source=state.o3, /compareOverlaps, /outputOverlaps
    hclL2gp: l2gp, source=state.hcl, /compareOverlaps, /outputOverlaps
    cloL2gp: l2gp, source=state.clo, /compareOverlaps, /outputOverlaps
    n2oL2gp: l2gp, source=state.n2o, /compareOverlaps, /outputOverlaps
    coL2gp: l2gp, source=state.co, /compareOverlaps, /outputOverlaps
    ;;
    o3_190L2gp: l2gp, source=state.o3_190, /compareOverlaps, /outputOverlaps
    o3_640L2gp: l2gp, source=state.o3_640, /compareOverlaps, /outputOverlaps
    ;;
    n2o_190L2gp: l2gp, source=state.n2o_190, /compareOverlaps, /outputOverlaps
    n2o_640L2gp: l2gp, source=state.n2o_640, /compareOverlaps, /outputOverlaps
    ;;
    ptan118L2gp: l2aux, source=state.ptan118, /outputOverlaps
    ptan2t5hL2gp: l2aux, source=state.ptan2t5h, /outputOverlaps
    ;;
    ;; In later versions we will also join diagnostic quantities
    ;;
END Join
;
; -----------------------------------------------------------------------------
;
; In this last section of the l2cf, we detail how the output data
; created in the join section is sent to the various output files.
;
; This section will also deal with metadata population.  Details of
; this will be considered at the coding/implementation phase of the
; software.
;
BEGIN Output
    ;;
    ;; Each output Level 2 file is described on a separate line, with
    ;; a list of the output quantities to go in it.
    ;;
    ;; First the primary products
    ;;
    output, file='l2gp_temp', quantities=tempL2gp
    output, file='l2gp_gph', quantities=gphL2gp
    output, file='l2gp_h2o', quantities=h2oL2gp
    output, file='l2gp_hno3', quantities=hno3L2gp
    output, file='l2gp_o3', quantities=o3L2gp
    output, file='l2gp_hcl', quantities=hclL2gp
    output, file='l2gp_clo', quantities=cloL2gp
    output, file='l2gp_n2o', quantities=n2oL2gp
    output, file='l2gp_co', quantities=coL2gp
    ;;
    ;; Now the l2gp_others file contains the secondary l2gp quantities
    ;; and the overlaps from the primary products.
    ;;
    output, file='l2gp_others', quantities= [ o3_190L2gp, o3_640L2gp, $
                                             n2o_190L2gp, n2o_640L2gp ],  $
                                overlaps= [ tempL2gp, gphL2gp, h2oL2gp, $
                                           hno3L2gpo3L2gp, hclL2gp, cloL2gp, $
                                           n2oL2gp ]
    ;;
    ;; Now the l2aux file contains non l2gp data
    ;;
    output, file='l2aux_full', quantities= [ ptan118l2gp, ptan2t5hL2gp ], $
                               overlaps= [ ptan118L2gp, ptan2t5hL2gp ]
    ;;
    ;; In later versions there may be some lines dealing with metadata
    ;; population.
    ;;
END Output
;
; That's the end.
;
; ----------------------------------------------------------------------------
;
; $Log$
; Revision 1.2  2000/11/30 00:23:35  vsnyder
; Use [] syntax for arrays.
;
; Revision 1.1  2000/10/20 23:36:54  pwagner
; moved to test directory
;
; Revision 1.1  2000/10/11 20:54:39  vsnyder
; Initial addition
;
; Revision 2.0  2000/09/05 17:41:50  dcuddy
; Change revision to 2.0
;
; Revision 1.2  2000/07/28 18:34:59  vsnyder
; Corrected an inconsistency between vectorTemplate and Join.
;
