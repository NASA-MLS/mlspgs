! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

! $Id$

! ------------------------------------------------------------------------------
! Part of MatrixModule_0, used for r4 and r8 versions of routine of this name

    if ( b%nCols /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVectorNoT_0" )
    if ( b%nRows /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVectorNoT_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_diag = .true.
    if ( present(doDiag) ) my_diag = doDiag
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    sign = 1.0_rm
    if ( my_sub ) sign = -1.0_rm
    if ( .not. my_update ) p = 0.0_r4
    select case ( b%kind )
    case ( M_Absent )
    case ( M_Banded )
      do j = 1, size(v)            ! columns
        v1 = b%r2(j-1)             ! (starting position in B%VALUES) - 1
        n = b%r2(j) - v1           ! how many values
        m = b%r1(j)                ! starting row subscript in B%VALUES
        if ( my_diag ) then        ! do the whole matrix
          do i = m, m+n-1          ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = 1, n
        else                       ! skip the diagonal
          do i = m, min(m+n-1,j-1) ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m+n-1,j-1)
          do i = max(m,j+1), m+n-1 ! rows
            p(i) = p(i) + sign * b%values(v1+i-m+1,1) * v(j)
          end do ! i = m, min(m,n-1,j-1)
        end if
      end do ! j
     case ( M_Column_Sparse )
      do j = 1, size(p)            ! columns
        do n = b%r1(j-1)+1, b%r1(j)! rows
          i = b%r2(n)              ! row number
          if ( i/=j .or. my_diag ) &
            & p(i) = p(i) + sign * b%values(n,1) * v(j)
        end do ! n
      end do ! j
    case ( M_Full )
      if ( my_diag ) then          ! do the whole matrix
        call gemv ( 'n', size(b%values,1), size(b%values,2), sign, b%values, &
          & size(b%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + sign * matmul(b%values,v)
!       do i = 1, size(p)
!         p(i) = p(i) + sign * dot(size(v), b%values(i,1), size(b%values,1), v(1), 1)
!         p(i) = p(i) + sign * dot_product( b%values(i,:), v )
!       end do ! i
      else                         ! skip the diagonal
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( i > 1 ) p(i) = p(i) + &
            & sign * dot(i-1, b%values(i,1), size(b%values,1), v(1), 1)
!           & sign * dot_product(b%values(i,1:i-1), v(1:i-1))
          if ( i < size(v) ) p(i) = p(i) + &
            & sign * dot(size(v)-i, b%values(i,i+1), size(b%values,1), v(i+1), 1)
!           & sign * dot_product(b%values(i,i+1:), v(i+1:))
        end do ! i
!$OMP END PARALLEL DO
      end if
    end select

! $Log$
! Revision 2.1  2003/01/08 21:29:27  livesey
! First version, extracted from MatrixModule_0
!
