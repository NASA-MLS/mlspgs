! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! How to handle dumping stats in every module procedure of dump_0
! where it makes sense to dump stats
! 
! $Id$
! $RCSfile$

    ! call output('Entering dumpstats', advance='no')
    call PrintName ( Name, NameHasBeenPrinted )
    if ( dopts(itsShape)%v ) then
      call outputNamedValue( 'rank', myRank, advance='no' )
      call output( '   shape  ', advance='no' )
      call output( shape(array), advance='no' )
      if ( any(isInfinite(array)) ) call output( '(infinite values found)', advance='no' )
      if ( any(isNaN(array)) ) call output( '(NaNs found)', advance='no' )
      call newLine
    endif
    if ( dopts(myBandwidth)%v ) then
      call BandWidth( array, bwidth, pctnzero )
      call outputNamedValue( 'Band width', bwidth, advance='no' )
      call output( '   % /= 0  ', advance='no' )
      call output( pctnzero, advance='yes' )
    endif
    if ( any(shape(array) == 0) ) then
      ! We do nothing
    elseif ( dopts(RMS)%v .or. dopts(AuBrick)%v .or. &
      & dopts(ratios)%v .or. dopts(NaNs)%v ) then
      if ( .not. any(isfinite(array)) ) then
        call output ('(no finite values found in array) ', advance='yes')
      elseif ( .not. all(isfinite(array)) ) then
        if ( present(name) .and. .not. nameHasBeenPrinted ) &
          & call output ( trim(name) //'   ' , advance='no' )
        if ( dopts(NaNs)%v ) then
          call WhereAreTheInfs ( array, which, how_many )
          if ( how_many > 0 ) then
            call outputNamedValue( 'num(Infs)', how_many )
            if ( how_many < MAXNUMNANS ) &
              & call outputNamedValue( 'which', which(1:how_many) )
          endif
          call WhereAreTheNaNs ( array, which, how_many )
          if ( how_many > 0 ) then
            call outputNamedValue( 'num(NaNs)', how_many )
            if ( how_many < MAXNUMNANS ) &
              & call outputNamedValue( 'which', which(1:how_many) )
          endif
        else
          call output ('(non-finite values found in array--skipped) ', advance='yes')
        endif
      elseif ( dopts(NaNs)%v ) then
        ! Don't want to do anything else, because
        how_many = 0 ! No NaNs or Infs
      else if ( present(fillValue) ) then
        ! call output( 'dumpstats with FillValue ' // trim(name) , advance='no' )
        call printRMSetc ( Name, mlsmin(array, fillValue), &
          & mlsmax(array, fillValue), &
          & mlsstddev(array, fillValue), &
          & mlsmean(array, fillValue) )
        ! call output( 'done with PrintRMSetc.', advance='yes')
      else
        ! call output( 'dumpstats w/o FillValue ' // trim(name) , advance='no' )
        call printRMSetc ( Name, minval(array), maxval(array), &
          & sqrt(sum(array*array)/(size(array)+0.)), &
          & mean=sum(array)/(size(array)+0.) )
        ! call output( 'done with PrintRMSetc.', advance='yes')
      end if
    end if
    if ( any(shape(array) == 0) ) then
      ! We do nothing
    elseif ( dopts(stats)%v ) then
      ! Count how many meet our desired relationship w.r.t. FillValue
      select case ( fillvaluerelation )
      case ( '=' )
        numNonFill = count(array /= myFillValue)
      case ( '<' )
        numNonFill = count(array >= myFillValue)
      case ( '>' )
        numNonFill = count(array <= myFillValue)
      case default
        numNonFill = count(array /= myFillValue)
      end select
      numFill = size(array) - numNonFill
      ! call output( 'about to dump %', advance='yes' )
      if ( (PRINTFILLVALUE .or. present(FillValue)) .and. &
        & numFill+numNonFill > 0 .and. .not. thisIsADiff ) then
        call output( 'Compared with ', advance='no' )
        call output( myFillValue, advance='no' )
      end if
      if ( .not. thisIsADiff ) call printPercentages ( equal=numFill, unEqual=numNonFill )
    end if
    if ( dopts(collapseIt)%v .and. myRank > 1 ) then
      call dumpCollapsedArray( array, name, &
        & fillValue, trim(snipOption(options, dopt_Collapse)) // 'L' )
      ! call output('Leaving dumpstats', advance='no')
      call theDumpEnds
      return
    endif
    if ( .not. dopts(wholeArray)%v ) then
      ! call output('Leaving dumpstats', advance='no')
      call theDumpEnds
      return
    endif

    ! Avoid dumping the entire array if all its elements are equal
    if ( .not. dopts(clean)%v .and. dontDumpIfAllEqual .and. size(array) > 5 ) then
      if ( all(isInfinite(array)) ) then
        if ( dopts(laconic)%v .or. nameHasBeenPrinted ) then
          call blanks(3)
        elseif ( present(name) ) then
          call output( trim(name), advance='no' )
        else
          call output( 'array', advance='no' )
        end if
        call output ( '(' )
        if ( present(lbound) ) call output ( lbound )
        call output( ':) all ', advance='no' )
        call output( trim(arrayShapeToString(shape(array))), advance='no' )
        call output( ' values are ', advance='no' )
        call output( InfFunction(1.), FORMAT=SDFORMATDEFAULT, advance='yes' )
        ! call output('Leaving dumpstats', advance='no')
        call theDumpEnds
        return
      elseif ( all(isNaN(array)) ) then
        if ( dopts(laconic)%v .or. nameHasBeenPrinted ) then
          call blanks(3)
        elseif ( present(name) ) then
          call output( trim(name), advance='no' )
        else
          call output( 'array', advance='no' )
        end if
        call output ( '(' )
        if ( present(lbound) ) call output ( lbound )
        call output( ':) all ', advance='no' )
        call output( trim(arrayShapeToString(shape(array))), advance='no' )
        call output( ' values are ', advance='no' )
        call output( NaNFunction(1.), FORMAT=SDFORMATDEFAULT, advance='yes' )
        ! call output('Leaving dumpstats', advance='no')
        call theDumpEnds
        return
      elseif ( .not. all(isFinite(array)) ) then
        ! we'll need to dump to see where the NaNs and Infs are
      elseif ( minval(array) == maxval(array) ) then
        if ( dopts(laconic)%v .or. nameHasBeenPrinted ) then
          call blanks(3)
        elseif ( present(name) ) then
          call output( trim(name), advance='no' )
        else
          call output( 'array', advance='no' )
        end if
        call output ( '(' )
        if ( present(lbound) ) call output ( lbound )
        call output( ':) all ', advance='no' )
        call output( trim(arrayShapeToString(shape(array))), advance='no' )
        call output( ' values are ', advance='no' )
        call output( minval(array), advance='yes' )
        ! call output('Leaving dumpstats', advance='no')
        call theDumpEnds
        return
      end if
    end if
    nameOnEachLine = OldNameOnEachLine
    call theDumpEnds
    ! call output('Leaving dumpstats', advance='no')
! $Log$
! Revision 2.41  2018/02/28 19:15:27  pwagner
! Now calls theDumpEnds before ending
!
! Revision 2.40  2017/09/20 00:03:00  pwagner
! Try harder not to skip printing name if prior dump was all 0
!
! Revision 2.39  2017/09/15 22:36:30  pwagner
! If empty skip but dont return to caller just yet
!
! Revision 2.38  2017/07/19 22:45:20  pwagner
! Use PrintName procedure
!
! Revision 2.37  2017/07/10 18:27:09  pwagner
! Correct bugs that caused unwanted printing
!
! Revision 2.36  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.35  2016/04/05 23:55:17  pwagner
! -v verbose option added; usu. will print name on each line
!
! Revision 2.34  2015/08/25 18:38:27  vsnyder
! Include LBOUND in 'all values are the same' dumps
!
! Revision 2.33  2013/01/10 00:18:18  pwagner
! Dumps with -N just show where NaNs are
!
! Revision 2.32  2012/09/11 21:12:11  pwagner
! Requires 'N' option to show where NaNs, Infs are located
!
! Revision 2.31  2012/06/22 20:26:49  pwagner
! Specify advance arg because we may now set default to 'yes'
!
! Revision 2.30  2012/06/12 18:05:15  pwagner
! Info about NaNs and Infs on same line as shape
!
! Revision 2.29  2012/05/25 20:38:00  pwagner
! Warn if Infinities or NaNs found
!
! Revision 2.28  2012/03/12 20:03:49  vsnyder
! Don't summarize 'all ... values are' if clean is set
!
! Revision 2.27  2012/01/09 22:29:16  pwagner
! 'R' and 'r' act the same except for diffs
!
! Revision 2.26  2011/12/07 01:14:24  pwagner
! Added option to show bandwidth of banded arrays
!
! Revision 2.25  2011/07/26 20:42:49  pwagner
! Clearer, less redundant
!
! Revision 2.24  2011/04/20 22:23:17  pwagner
! Guards against empty array (Was it necessary?)
!
! Revision 2.23  2011/03/08 00:02:19  pwagner
! Stop double-printing name
!
! Revision 2.22  2011/02/05 00:59:36  pwagner
! Passes options minus collapse to dumpCollapsedArray
!
! Revision 2.21  2011/01/20 01:16:24  pwagner
! New '-l' option dumps collapsed representation of higher ranked array
!
! Revision 2.20  2009/11/20 01:16:47  pwagner
! Added new option H or 'shape' to just show array rank, shape
!
! Revision 2.19  2009/10/30 23:03:02  pwagner
! Should not double-print name if only whole array diff
!
! Revision 2.18  2009/10/19 17:29:24  pwagner
! Trying to prevent double-printing of name
!
! Revision 2.17  2009/10/13 00:06:12  pwagner
! Eliminate redundant printing of name
!
! Revision 2.16  2009/06/16 17:12:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.15  2008/01/09 20:53:43  pwagner
! When NaNs short-circuit dump or diff, print how many and where
!
! Revision 2.14  2008/01/07 21:39:36  pwagner
! Fixed bug reegarding NaNs and Infs in array not being dumped
!
! Revision 2.13  2007/07/16 23:33:28  pwagner
! May automatically set certain options by default
!
! Revision 2.12  2007/04/03 02:48:47  vsnyder
! More of not looking at non-present dummy arguments
!
! Revision 2.11  2007/03/23 00:09:13  pwagner
! Must never refer to optional parameter unless present
!
! Revision 2.10  2006/07/11 00:23:28  pwagner
! use fillValue properly when computing rms etc.
!
! Revision 2.9  2006/06/09 18:50:12  pwagner
! Avoid dumping an entire array if all elements the same
!
! Revision 2.8  2006/05/24 20:38:32  pwagner
! Allow any of 3 ordering relations for dumping pct
!
! Revision 2.7  2006/02/28 21:40:10  pwagner
! Reordered printing of rms, stats
!
! Revision 2.6  2005/12/17 00:58:56  pwagner
! dumps of rms, etc. should appear uniform
!
! Revision 2.5  2005/06/22 17:44:10  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.4  2005/05/12 20:42:45  pwagner
! Check  for NaNs before computing stats
!
! Revision 2.3  2004/07/21 19:57:21  pwagner
! New rms, wholeArray options to some dumps
!
! Revision 2.2  2004/06/11 19:05:39  pwagner
! defaults to dumping statsononeline
!
! Revision 2.1  2004/06/11 00:14:29  pwagner
! First commit
!
