!     .  Copyright (C) 1989, California Institute of Technology.
!     .  All rights reserved.  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.

!---------------------------- RCS Ident Info -------------------------------
      character (len=*), parameter :: IdParm = &
        "$Id$"
!---------------------------------------------------------------------------

      integer M, N

!     *****     Local Variables     ************************************

! BL      is the left bound of the sub-array to be sorted at the next
!         step.
! BR      is the right bound of the sub array to be sorted at the next
!         step.
! CL      is the current left bound of the unsorted sub-array.
! CR      is the current right bound of the unsorted sub-array.
! INSERT  the size at which to switch over to insertion sort
! PARTN   is the partition element.
! STACKL  keeps track of the left bounds of sub-arrays waiting to be
!         sorted.
! STACKR  keeps track of the right bounds of sub-arrays waiting to be
!         sorted.
! STKTOP  keeps track of the top of the stacks.
! TEMP    holds elements of A during exchanges.

      integer BL, BR, CL, CR
      integer, parameter :: INSERT = 10
      integer STACKL(32), STACKR(32), STKTOP

!     *****     Executable Statements     ******************************

      if ( n-m >= insert ) then
         stktop = 1
         stackl(1) = m
         stackr(1) = n
         do while ( stktop /= 0 )
            bl = stackl(stktop)
            br = stackr(stktop)
            stktop = stktop-1
!           Choose a partitioning element.  Use the median of the first,
!           middle and last elements.  Sort them so the extreme elements
!           serve as sentinels during partitioning.
            cl = (bl+br)/2
            partn = a(cl)
            if ( a(bl) > partn ) then
               a(cl) = a(bl)
               a(bl) = partn
               partn = a(cl)
            end if
            if ( a(bl) > a(br) ) then
               temp = a(br)
               a(br) = a(bl)
               a(bl) = temp
            end if
            if ( partn > a(br) ) then
               a(cl) = a(br)
               a(br) = partn
               partn = a(cl)
            end if
            a(cl) = a(br-1)
            a(br-1) = partn
!           Partition the sub-array around PARTN.  Exclude the above
!           considered elements from partitioning because they're al-
!           ready in the correct subfiles.  Stop scanning on equality to
!           prevent files containing equal values from causing a loop.
            cl = bl
            cr = br-1
            do
   30          cl = cl+1
                  if ( a(cl) < partn) go to 30
   40          cr = cr-1
                  if ( a(cr) > partn) go to 40
               if ( cl > cr) exit
               temp = a(cl)
               a(cl) = a(cr)
               a(cr) = temp
            end do
!           Put sub-arrays on the stack if they're big enough.  Put the
!           larger under the smaller, so the smaller will be done next.
!           This makes the upper bound of the stack depth log2 (n-m+1).
!           (The "Hibbard" modification of quicksort).
            if ( cl-bl > br-cr ) then
               if ( cl-bl > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
            else
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
               if ( cl-bl > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
            end if
         end do
      end if
!     Clean up small subfiles using insertion sort on everything.
      do cr = m+1, n
         partn = a(cr)
         cl = cr
   60    if ( a(cl-1) > partn ) then
            a(cl) = a(cl-1)
            cl = cl-1
            if ( cl > m) go to 60
         end if
         a(cl) = partn
      end do
      return

! $Log$
! Revision 2.1  2002/01/30 19:36:34  vsnyder
! Initial commit
!
