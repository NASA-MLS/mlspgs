! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

!   subroutine DIFF_1D_DOUBLE ( inArray1, NAME1, inArray2, NAME2, &
!     & FILLVALUE, WIDTH, FORMAT, LBOUND, OPTIONS )
!     double precision, intent(in) :: inArray1(:)
!     character(len=*), intent(in), optional :: NAME1
!     double precision, intent(in) :: inArray2(:)
!     character(len=*), intent(in), optional :: NAME2
!     double precision, intent(in)           :: FILLVALUE
!     integer, intent(in), optional :: WIDTH
!     character(len=*), intent(in), optional :: FORMAT
!     integer, intent(in), optional :: LBOUND ! Low bound for Array
!     character(len=*), intent(in), optional :: options
! 
!     double precision, dimension(size(inArray1)) :: Array1
!     double precision, dimension(size(inArray2)) :: Array2
    integer, parameter                     :: MAXPCTS = 10
    logical                                :: warn, NaNsIn1, NaNsIn2, alreadySbtrcted
    real(kind(inArray1)), dimension(3, MAXPCTS) :: array1AtNAbs
    real(kind(inArray1)), dimension(3, MAXPCTS) :: array2AtNAbs
    real(kind(inArray1)), dimension(3, MAXPCTS) :: array1AtNRel
    real(kind(inArray1)), dimension(3, MAXPCTS) :: array2AtNRel
    character(len=64)                      :: DiffName
    integer                                :: i
    double precision                       :: tmax
    real(kind(inArray1)), dimension(2)       :: exvalues
    real(kind(inArray1)), dimension(2)       :: exratios
    real(kind(inArray1)), dimension(MAXPCTS) :: gaps
    type(Stat_T), dimension(MAXPCTS)       :: gapStat
    real(kind(inArray1)), dimension(MAXPCTS) :: gapratios
    type(Stat_T), dimension(MAXPCTS)       :: gapRatioStat
    real(kind(inArray1))                     :: minratio
    real(kind(inArray1))                     :: maxratio
    real(kind(inArray1))                     :: medianratio
    real(kind(inArray1))                     :: meanratio
    real(kind(inArray1))                     :: minvalue
    real(kind(inArray1))                     :: maxvalue
    real(kind(inArray1))                     :: medianvalue
    real(kind(inArray1))                     :: meanvalue
    real(kind(inArray1))                     :: rmsvalue
    integer                                  :: numTot
    integer                                  :: numEqual
    real(kind(inArray1))                     :: pctDiff
    real(kind(inArray1))                     :: pctEqual
    real(kind(inArray1)), dimension(MAXPCTS) :: pcts
    real(kind(inArray1)), dimension(MAXPCTS) :: pctratios
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMaxGaps
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMaxGapAsRatios
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMeanGaps
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMaxRatios
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMaxRatioAsGaps
    real(kind(inArray1)), dimension(MAXPCTS) :: pctMeanRatios
    logical, parameter                       :: PRINTREFERENCEVALUES = .false.
    logical, parameter                       :: PRINTEXTRADUMP = .true.
    real(kind(inArray1))                     :: rmsratio
    real(kind(inArray1))                     :: stddev
    real(kind(inArray1))                     :: stddevratio
    real                                     :: t1
    real                                     :: t2
    logical, parameter                       :: DEBUG = .false.
    logical, parameter                       :: REPLACEFILLVALUESWITH0 = .false.
    real(kind(inArray1)), dimension(MAXPCTS), parameter :: PCTAGES = &
      & (/ 99.9, 99.8, 99.7, 99.5, 99., 98., 97., 95., 90., 80. /)
    real, dimension(MAXPCTS), parameter :: PCTFACTORS = &
      & (/ .01, .02, .05, .1, .2, .5, 1., 2., 5., 10. /)
    real(kind(inArray1)), dimension(MAXPCTS,7) :: TheTable
    logical, parameter :: unique = .false. 
    ! Executable
    t1 = 0.
    thisIsADiff = .true.  ! For special dumps
    alreadySbtrcted = .false.
    myPCTFormat  = DefaultPCTFormat
    if ( PCTFormat /= '*' ) myPCTFormat = PCTFormat
    if ( len_trim(name1) < 1 ) then
      DiffName = ' '
    else if ( len_trim(name2) < 1 ) then
      DiffName = trim(name1)
    else
      DiffName = trim(name1) // ' - ' // trim(name2)
    end if

    call theDumpBegins ( options, thisIsADiff, DiffName )

    if ( debug ) call DumpDumpOptions
    if ( DEBUG ) then
      call output( '(in diff)', advance='yes' )
      call outputNamedValue( 'DiffName', trim(DiffName) )
      call outputNamedValue( 'Stats', dopts(stats)%v )
      call outputNamedValue( 'Ratios', dopts(myRatios)%v )
      call outputNamedValue( 'RMS', dopts(RMS)%v )
      call outputNamedValue( 'Table', dopts(table)%v )
      call outputNamedValue( 'goldbrick', dopts(AuBrick)%v )
      call outputNamedValue( 'WholeArray', dopts(wholeArray)%v )
    end if
    if ( dopts(wholeArray)%v ) then
      call dump(inArray1-inArray2, trim(DiffName), &
      & real(0.,kind(inArray1)), WIDTH, FORMAT, &
      & LBOUND, options )
      return
    end if
    
    NaNsIn1 = any(.not. ieee_is_finite(inArray1))
    if ( NaNsIn1 ) then
      if ( .not. any(ieee_is_finite(inArray1)) ) then
        call output( '*** skipping: no finite values found', advance='no' )
        if ( len_trim(name1) > 0 ) then
          call output( ' in ' // trim(name1), advance='yes')
        else
          call output( ' in first array', advance='yes')
        end if
        return
      end if
      call output( '*** non-finite values found', advance='no' )
      if ( len_trim(name1) > 0 ) then
        call output( ' in ' // trim(name1), advance='yes')
      else
        call output( ' in first array', advance='yes')
      end if
      if ( dopts(NaNs)%v ) then
        call WhereAreTheInfs ( inArray1, which, how_many )
        if ( how_many > 0 ) then
          call outputNamedValue( 'num(Infs)', how_many )
          if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
        end if
        call WhereAreTheNaNs ( inArray1, which, how_many )
        if ( how_many > 0 ) then
          call outputNamedValue( 'num(NaNs)', how_many )
          if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
        end if
      end if
    end if

    NaNsIn2 = any(.not. ieee_is_finite(inArray2))
    if ( NaNsIn2 ) then
      if ( .not. any(ieee_is_finite(inArray2)) ) then
        call output( '*** skipping: no finite values found', advance='no' )
        if ( len_trim(name2) > 0 ) then
          call output( ' in ' // trim(name2), advance='yes')
        else
          call output( ' in second array', advance='yes')
        end if
        return
      end if
      call output( '*** non-finite values found', advance='no' )
      if ( len_trim(name2) > 0 ) then
        call output( ' in ' // trim(name2), advance='yes')
      else
        call output( ' in second array', advance='yes')
      end if
      if ( dopts(NaNs)%v ) then
        call WhereAreTheInfs ( inArray2, which, how_many )
        if ( how_many > 0 ) then
          call outputNamedValue( 'num(Infs)', how_many )
          if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
        end if
        call WhereAreTheNaNs ( inArray2, which, how_many )
        if ( how_many > 0 ) then
          call outputNamedValue( 'num(NaNs)', how_many )
          if ( how_many < 50 ) call outputNamedValue( 'which', which(1:how_many) )
        end if
      end if
    end if

    if ( NaNsIn1 .or. NaNsIn2 ) then
      call filterValues(reshape( inArray1, (/ product(shape(inArray1)) /) ), &
        & Array1, &
        & reshape( inArray2, (/ product(shape(inArray2)) /) ), &
        & Array2, &
        & warn, FillValue)
      if ( warn ) call output( &
        & '*** non-matched NaNs diffing ' // trim(DiffName), &
        & advance='yes')
    else
      ! All of inArray11 and inArray2 are finite, so we need only reshape to 1d
      Array1 = reshape( inArray1, (/ product(shape(inArray1)) /) )
      Array2 = reshape( inArray2, (/ product(shape(inArray2)) /) )
    end if

    ! call output( 'About to count array elements', advance='yes' )
    if ( all(Array1 == Array2) ) then
      call output( '(The two arrays are exactly equal)', advance='yes' )
      return
    else if ( all(Array1 == FillValue) ) then
      call outputNamedValue( trim(name1) // ' filled entirely with Fill values', &
        & FillValue )
      return
    else if ( all(Array2 == FillValue) ) then
      call outputNamedValue( '2nd array filled entirely with Fill values', &
        & FillValue )
      return
    end if
    numTot = count( (/Array1 /= FillValue/) )
    numEqual = count( (/Array1 /= FillValue .and. Array1 == Array2/) )
    ! I can't think of a good reason to replace FillValues with 0 here
    if ( REPLACEFILLVALUESWITH0 ) then
      call ReplaceFillValues( Array1, FillValue, newFill=real(0., kind(FillValue)) )
      call ReplaceFillValues( Array2, FillValue, newFill=real(0., kind(FillValue)) )
      if ( all(Array1 == Array2) ) then
        call output( '(The two arrays are exactly equal)', advance='yes' )
        return
      end if
    end if
    if ( dopts(RMS)%v .or. dopts(myRatios)%v .or. dopts(AuBrick)%v ) then
      ! We want to make sure we remove values from both arrays where either is fill
      if ( DEBUG ) call outputNamedValue( 'filtering FillValue', FillValue )
      Array1 = reshape( inArray1, (/ product(shape(inArray1)) /) )
      Array2 = reshape( inArray2, (/ product(shape(inArray2)) /) )
      where (Array1 == FillValue)
        Array2 = FillValue
      end where
      where (Array2 == FillValue)
        Array1 = FillValue
      end where
      numNonFill = count(Array1 /= FillValue)
      call ReorderFillValues ( Array1, FillValue )
      call ReorderFillValues ( Array2, FillValue )
      call allstats(Array1(1:numNonFill), &
        & addedData=.false., min=refmin, max=refmax, rms=refrms)
      call allstats(Array2(1:numNonFill), &
        & addedData=.true., min=refmin, max=refmax, rms=refrms)
      if ( PRINTREFERENCEVALUES ) &
        & call printRMSetc ( 'Reference values', refmin, refmax, refrms )
      if ( product(shape(inArray1)) > TOOMANYELEMENTS ) then
        call outputNamedValue( 'Array size excessive for pcts', product(shape(inArray1)) )
        if ( dopts(wholeArray)%v ) then
          if ( DEBUG ) call output( '1st call to dump', advance='yes' )
          call dump( Array1-Array2, trim(DiffName), &
            & real(0.,kind(inArray1)), WIDTH, FORMAT, &
            & LBOUND, options )
        else
          if ( DEBUG ) call output( '2nd call to dump', advance='yes' )
          call dump( Array1(1:numNonFill)-Array2(1:numNonFill), trim(DiffName), &
            & real(0.,kind(inArray1)), WIDTH, FORMAT, &
            & LBOUND, options )
        end if
        return
      else
        call fillPcts
      end if
      call usePcts
      ! Prepare to find abs, relative differences
      ! Avoid another automatic array
      do i=1, size(Array1)
        tmax = max( abs(Array1(i)), abs(Array2(i)) )
        Array1(i) = Array1(i) - Array2(i)
        Array2(i) = tmax
      end do
      alreadySbtrcted = .true.
      if ( dopts(wholeArray)%v ) then
          if ( DEBUG ) call output( '3rd call to dump', advance='yes' )
        call dump( Array1, trim(DiffName), &
          & real(0.,kind(inArray1)), WIDTH, FORMAT, &
          & LBOUND, options )
      else if ( .not. PRINTEXTRADUMP ) then
          if ( DEBUG ) call output( '4th call to dump', advance='yes' )
        call dump( Array1(1:numNonFill), trim(DiffName), &
          & real(0.,kind(inArray1)), WIDTH, FORMAT, &
          & LBOUND, options )
      end if
      if ( DEBUG ) call output( 'DoneWithDiff', advance='yes' )
      call doneWithDiff
      if ( PRINTREFERENCEVALUES ) &
        & call printRMSetc ( 'Reference values', refmin, refmax, refrms )
      return
    end if
    if ( .not. alreadySbtrcted ) then
      call fillPcts
      call usePcts
      ! Prepare to find abs, relative differences
      ! Avoid another automatic array
      do i=1, size(Array1)
        tmax = max( abs(Array1(i)), abs(Array2(i)) )
        Array1(i) = Array1(i) - Array2(i)
        Array2(i) = tmax
      end do
    end if
          if ( DEBUG ) call output( '5th call to dump', advance='yes' )
    if ( PRINTEXTRADUMP ) call dump(Array1, trim(DiffName), &
      & real(0.,kind(inArray1)), WIDTH, FORMAT, &
      & LBOUND, options )
    call doneWithDiff
    if ( DEBUG ) call output( 'DoneWithDiff', advance='yes' )
  contains
    include "donewithdiff.f9h"

!   end subroutine DIFF_1D_DOUBLE
! $Log$
! Revision 2.38  2017/07/31 23:00:25  pwagner
! Remove unneeded param
!
! Revision 2.37  2017/07/19 22:40:37  pwagner
! May print Name during theDumpBegins
!
! Revision 2.36  2016/10/21 23:12:05  vsnyder
! Make sure T1 is defined
!
! Revision 2.35  2016/10/06 20:21:28  pwagner
! parts commom to unfiltered and filtered diffs moved to donewithdiff.f9h
!
! Revision 2.34  2016/09/09 20:35:17  pwagner
! Added Au (Gold) brick option removing some hay from the stack of statistics
!
! Revision 2.33  2016/07/28 01:42:27  vsnyder
! Refactoring dump and diff
!
! Revision 2.32  2016/03/23 00:20:52  pwagner
! Diff now able to print name on each line
!
! Revision 2.31  2013/01/10 00:17:57  pwagner
! Dumps with -N just show where NaNs are
!
! Revision 2.30  2012/09/11 21:11:07  pwagner
! Requires 'N' option to show where NaNs, Infs are located
!
! Revision 2.29  2012/01/12 00:22:25  pwagner
! Dont automatically replace FillValues with 0
!
! Revision 2.28  2012/01/09 22:25:12  pwagner
! Distinguish 'r' option to print rms of ratios and 'R' option for rms of values
!
! Revision 2.27  2011/12/07 01:13:58  pwagner
! Added option to show bandwidth of banded arrays
!
! Revision 2.26  2011/08/03 22:03:12  pwagner
! Snipped two unneeded lines
!
! Revision 2.25  2011/07/26 20:42:04  pwagner
! Clearer, less redundant
!
! Revision 2.24  2011/02/05 00:55:35  pwagner
! Consistent with new dopt_ dump options
!
! Revision 2.23  2009/11/20 01:16:02  pwagner
! More protection against running out of memory diffing DACS datasets
!
! Revision 2.22  2009/10/30 23:02:04  pwagner
! Should not double-print name if only whole array diff
!
! Revision 2.21  2009/10/19 17:29:04  pwagner
! Trying to prevent double-printing of name
!
! Revision 2.20  2009/10/13 00:04:16  pwagner
! Corrected sometimes wrong percentages
!
! Revision 2.19  2009/09/10 20:58:40  pwagner
! 3 ways to summarize diffs: 'b' (table), 'r' (rms), 's' (number of differences)
!
! Revision 2.18  2009/06/16 17:12:55  pwagner
! Changed api for dump, diff routines; now rely on options for most optional behavior
!
! Revision 2.17  2008/11/24 19:35:15  pwagner
! Less wasteful of memory; should not segment dault so often
!
! Revision 2.16  2008/06/18 20:44:30  pwagner
! dump subroutine has new optonal arg 'unique'
!
! Revision 2.15  2008/02/07 18:45:21  pwagner
! Will not go through rms, stats, etc. if diffs all zero
!
! Revision 2.14  2008/01/09 20:54:03  pwagner
! When NaNs short-circuit dump or diff, print how many and where
!
! Revision 2.13  2007/10/24 23:58:49  pwagner
! pct summaries now include columns '(as ratio)', '(as abs)'
!
! Revision 2.12  2007/10/18 23:38:29  pwagner
! May use dumpTable for nicer formatting
!
! Revision 2.11  2007/10/12 23:34:49  pwagner
! Using new howfar procedure to summarize diffs after peeling away outliers
!
! Revision 2.10  2007/09/13 21:08:57  pwagner
! -rms and -s combined add new info about & how near
!
! Revision 2.9  2007/07/16 23:32:33  pwagner
! Improved rms-type diffs to concentrate on ratios
!
! Revision 2.8  2007/06/07 20:31:52  pwagner
! Avoid using lengths of optional args
!
! Revision 2.7  2006/06/24 23:07:55  pwagner
! Changes to reduce memory footprint computing statistics
!
! Revision 2.6  2006/03/15 17:34:38  pwagner
! Fixed bug causing incorrect rms when diffing with fill values
!
! Revision 2.5  2006/02/28 21:42:29  pwagner
! Replace fillvalues with 0 before computing rms (should actually remove)
!
! Revision 2.4  2005/12/17 00:58:56  pwagner
! dumps of rms, etc. should appear uniform
!
! Revision 2.3  2005/12/10 00:25:31  pwagner
! Non-essential fussing with debugging commands
!
! Revision 2.2  2005/06/22 17:44:10  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.1  2005/05/12 20:41:11  pwagner
! First commit
!
