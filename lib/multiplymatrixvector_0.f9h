! Copyright (c) 2002, California Institute of Technology.  ALL RIGHTS RESERVED.
! U.S. Government Sponsorship under NASA Contract NAS7-1407 is acknowledged.

! $Id$

! ------------------------------------------------------------------------------
! Part of MatrixModule_0, used for r4 and r8 versions of routine of this name

    if ( a%nRows /= size(v) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and vector not compatible in MultiplyMatrixVector_0" )
    if ( a%nCols /= size(p) ) call MLSMessage ( MLSMSG_Error, ModuleName, &
      & "Matrix block and result not compatible in MultiplyMatrixVector_0" )
    my_update = .false.
    if ( present(update) ) my_update = update
    my_sub = .false.
    if ( present(subtract) ) my_sub = subtract
    nullify ( my_Mask )
    if ( present(mask) ) my_mask => mask
    s = 1.0_rm
    if ( my_sub ) s = -1.0_rm
    if ( .not. my_update ) p = 0.0_r8
    select case ( a%kind )
    case ( M_Absent )
    case ( M_Banded )
!$OMP PARALLEL DO private ( v1, n, m, av )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        v1 = a%r2(i-1)             ! starting position in A%VALUES - 1
        n = a%r2(i) - v1           ! how many values
        if ( n <= 0 ) cycle
        m = a%r1(i)                ! starting position in V
        av = dot(n, a%values(v1+1,1), 1, v(m), 1)
!       av = dot_product( a%values(v1+1:v1+n,1), v(m:m+n-1) )
        p(i) = p(i) + s * av
      end do ! i
!$OMP END PARALLEL DO
     case ( M_Column_Sparse )
      do i = 1, size(p)
        if ( associated(my_mask) ) then
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
      cycle
        end if
        av = 0.0_r8
        do n = a%r1(i-1)+1, a%r1(i)
          av = av + a%values(n,1) * v(a%r2(n))
        end do ! n
        p(i) = p(i) + s * av
      end do ! i
    case ( M_Full )
      if ( associated(my_mask) ) then
!$OMP PARALLEL DO
        do i = 1, size(p)
          if ( iand(ichar(my_mask(i)),m_LinAlg) /= 0 ) &
        cycle
          p(i) = p(i) + s * dot(size(v), a%values(1,i), 1, v(1), 1)
!         p(i) = p(i) + s * dot_product( a%values(:,i), v)
        end do ! i
!$OMP END PARALLEL DO
      else
        call gemv ( 't', size(a%values,1), size(a%values,2), s, a%values, &
          & size(a%values,1), v, 1, 1.0_rm, p, 1 )
!       p = p + s * matmul(transpose(a%values),v)
      end if
    end select

! $Log$
! Revision 2.1  2003/01/08 21:29:27  livesey
! First version, extracted from MatrixModule_0
!
