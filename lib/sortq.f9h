!     .  Copyright (C) 1989, California Institute of Technology.
!     .  All rights reserved.  U. S. Government sponsorship under
!     .  NASA contract NAS7-918 is acknowledged.

!     Sort the M:N-vector A.
!     A is not disturbed.  P is set so that A(P(J)) is the J'th element
!     of the sorted sequence.
!
!     To sort an array A' into descending order, let A = -A'
!     To sort an array A' into ascending order according to the
!     absolute value of the elements let A = ABS(A').
!     To sort an array A' into decending order according to the
!     absolute value of the elements let A = -ABS(A').
!
!     subroutine *SORTQ (A, M, N, P)
      integer, intent(in) :: M, N
      integer, intent(out) :: P(*)
!
!     *****     Local Variables     ************************************
!
! BL      is the left bound of the sub-array to be sorted at the next
!         step.
! BR      is the right bound of the sub-array to be sorted at the next
!         step.
! CL      is the current left bound of the unsorted sub-array.
! CR      is the current right bound of the unsorted sub-array.
! PARTN   is the partition element.
! PTEMP   holds elements of P during exchanges.
! STACKL  keeps track of the left bounds of sub-arrays waiting to be
!         sorted.
! STACKR  keeps track of the right bounds of sub-arrays waiting to be
!         sorted.
! STKTOP  keeps track of the top of the stacks.
!
      integer BL,BR,CL,CR
      integer, parameter :: INSERT = 10
      integer PTEMP, STACKL(32), STACKR(32), STKTOP
!
!     *****     Executable Statements     ******************************
!
      if ( n-m >= insert ) then
         stktop = 1
         stackl(1) = m
         stackr(1) = n
         do while ( stktop /=  0 )
            bl = stackl(stktop)
            br = stackr(stktop)
            stktop = stktop-1
!           Choose a partitioning element.  Use the median of the first,
!           middle and last elements.  Sort them so the extreme elements
!           can serve as sentinels during partitioning.
            cl = (bl+br)/2
            ptemp = p(cl)
            if (a(p(bl)) > a(ptemp)) then
               p(cl) = p(bl)
               p(bl) = ptemp
               ptemp = p(cl)
            end if
            if (a(p(bl)) > a(p(br))) then
               cr = p(bl)
               p(bl) = p(br)
               p(br) = cr
            end if
            if (a(ptemp)> a(p(br))) then
               p(cl) = p(br)
               p(br) = ptemp
               ptemp = p(cl)
            end if
            p(cl) = p(br-1)
            p(br-1) = ptemp
            partn = a(ptemp)
!           Partition the sub-array around PARTN.  Exclude the above
!           considered elements from partitioning because they're al-
!           ready in the correct subfiles.  Stop scanning on equality to
!           prevent files containing equal values from causing a loop.
            cl = bl
            cr = br-1
            do
  30           cl = cl+1
                  if (a(p(cl)) < partn) go to 30
  40           cr = cr-1
                  if (a(p(cr)) > partn) go to 40
               if (cl > cr) exit
               ptemp = p(cl)
               p(cl) = p(cr)
               p(cr) = ptemp
            end do
!           Put sub-arrays on the stack if they're big enough.  Put the
!           larger under the smaller, so the smaller will be done next.
!           This makes the upper bound of the stack depth log2 (n-m+1).
!           (The "Hibbard" modification of quicksort).
            if (cl-bl > br-cr) then
               if ( cl-bl> insert ) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
            else
               if ( br-cr > insert ) then
                  stktop = stktop+1
                  stackl(stktop) = cl
                  stackr(stktop) = br
               end if
               if ( cl-bl > insert) then
                  stktop = stktop+1
                  stackl(stktop) = bl
                  stackr(stktop) = cr
               end if
            end if
         end do
      end if
!     Clean up small subfiles using insertion sort on everything.
      do cr  =  m+1, n
         ptemp = p(cr)
         partn = a(ptemp)
         cl = cr
  60     if ( a(p(cl-1)) > partn ) then
            p(cl) = p(cl-1)
            cl = cl-1
            if (cl > m ) go to 60 
         end if
         p(cl) = ptemp
      end do
      return
!     end

! $Log$
! Revision 2.1  2003/06/20 00:17:51  vsnyder
! Initial commit
!
