! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! pure function XYZ_to_Geod_Fukushima_* ( XYZ ) result ( Geod )

! Convert Geocentric Cartesian coordinates (XYZ) to Longitude (Geod(2)) in
! radians, Geodetic Latitude (Geod(1)) in radians, and Geodetic Height
! (Geod(3)).

  real(rk), parameter :: A = EarthRadA, B = EarthRadB
  real(rk), parameter :: Ec = Earth_Axis_Ratio ! b/a
  ! Square of first eccentricity = 1 - b^2/a^2
  real(rk), parameter :: E2 = Eccentricity_Sq
  real(rk), parameter :: Tol = tiny(1.0_rk)**(1.0/3.0) / A
  integer, parameter :: MaxIt = 1  ! Maximum number of iterations.  In Journal
                                   ! of Geodesy (2006) 79: 689-693, Fukushima
                                   ! says one iteration gets within a few micro
                                   ! arcseconds for heights below 30,000 km.

  real(rk) :: An, An3, Ap, Bn, Dn, Fn  ! Terms in the iteration
  real(rk) :: Cc                       ! Ec * Cn
  real(rk) :: Cn, Cp                   ! Cosine-like iterate, previous value
  integer :: I
  real(rk) :: P                        ! S / a
  real(rk) :: S                        ! sqrt ( x**2 + y**2 )
  real(rk) :: Sn, Sp                   ! Sine-like iterate, previous value
  real(rk) :: Z                        ! Ec * |z| / a

  ! Compute longitude
  geod(2) = atan2 ( xyz(2), xyz(1) )

  s = sqrt ( xyz(1)**2 + xyz(2)**2 )
  if ( s < sqrt(tiny(1.0_rk)) ) then ! Too near the poles
    geod(1) = sign(real(0.5_rk*pi,rk),xyz(3))
    geod(3) = abs(xyz(3)) - b
    return
  end if
    
  ! Now the Fukushima iteration for latitude
  P = s / a
  Z = abs(xyz(3)) * Ec / a
  Sp = Z
  Cp = Ec * P
  Ap = sqrt ( Sp**2 + Cp**2 )
  Bn = 1.5_rk * E2**2 * P * Sp**2 * Cp**2 * ( Ap - Ec )
  i = 1
  do
    An3 = Ap ** 3
    Dn = Z * An3 + E2 * Sp**3
    Fn = P * An3 - E2 * Cp**3
    Sn = Dn * Fn - Bn * Sp
    Cn = Fn**2 - Bn * Cp
    An = sqrt ( Sn**2 + Cn**2 )
    if ( i >= maxIt ) exit
    i = i + 1
    if ( abs(Cn-Cp) < tol * abs(p) .or. abs(Sn-Sp) < tol * Z ) exit
    Ap = An
    Bn = 1.5_rk * E2 * Sn * Cn**2 * ( ( P * Sn - Z * Cn ) * Ap - &
       & E2 * Sn * Cn )
    Cp = Cn
    Sp = Sn
  end do
  Cc = Ec * Cn
  ! Compute geodetic latitude
  geod(1) = sign ( atan2(Sn,Cc), xyz(3) )
  ! Compute geodetic height
  geod(3) = ( s * Cc + abs(xyz(3)) * Sn - b * An ) / sqrt ( Cc**2 + Sn**2 )

! $Id$

! $Log$
! Revision 2.5  2016/05/26 02:31:57  vsnyder
! Correct a comment
!
! Revision 2.4  2016/03/19 00:41:14  vsnyder
! Compute the height correctly near the south pole
!
! Revision 2.3  2016/01/05 21:42:26  vsnyder
! Remove unused named constant E2B
!
! Revision 2.2  2015/02/05 21:46:58  vsnyder
! Revise convergence test
!
! Revision 2.1  2014/11/26 23:50:14  vsnyder
! Initial commit
!
