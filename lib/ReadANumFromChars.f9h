! Copyright 2009, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$
!  subroutine readAnIntFromChars (str, num, forbiddens, ignore)
!    !--------Argument--------!
!    CHARACTER (LEN=*), INTENT(in) ::   str
!    integer, intent(out)          ::   num
    character (len=*), intent(in), optional     ::   forbiddens
    character (len=*), intent(in), optional     ::   ignore

    !----------local vars----------!
    integer :: j, k, status
    logical :: leave_undef
    character(len=40)                           ::   myForbiddens
    character(len=40)                           ::   myIgnore
    character(len=len(str))                     ::   myStr
    !----------Executable part----------!
   status = 0
   ! Check that all is well (if not returns STRINGCONTAINSFORBIDDENS)
   num = STRINGCONTAINSFORBIDDENS
   if ( present(forbiddens) ) then
     myForbiddens = adjustl(forbiddens)
   else
     myForbiddens = ' '
   endif
   if ( present(ignore) ) then
     myignore = adjustl(ignore)
   else
     myignore = ' '
   endif
   leave_undef = (str == ' ')
   if ( myForbiddens /= ' ' ) then
     do j=1, len(trim(myForbiddens))
        leave_undef = leave_undef &
         & .or. &
         & ( &
         &    index(str, myForbiddens(j:j)) > 0 &
         &  .and. &
         &    myForbiddens(j:j) /= ' ' &
         & )
     enddo
   endif
   if ( leave_undef ) then
     return
   elseif (  myIgnore == "" ) then
     read( str, *, iostat=status, err=100 ) num
     if ( status /= 0 ) num = STRINGCONTAINSFORBIDDENS
   elseif (  index(myIgnore, "*") /= 0 ) then
     ! Read the first number, and stop when an ignorable
     ! is found after a digit
     num = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     ! First, ignore the first sequence of ignorables
     do j = 1, len(str)
       if ( .not. isAlphabet(str(j:j)) .and. &
         & index(myIgnore, str(j:j)) < 1 ) then
         exit
       endif
     end do 
     ! Collect digits of the first number in the string
     do j = j, len(str)
       if ( .not. isAlphabet(str(j:j)) .and. &
         & index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       else
         exit
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) num
   else
     ! Read the first number, and stop when an ignorable
     ! is found after a digit
     num = 0  ! a str made up entirely of ignorables means "0"
     k = 1
     myStr = ""
     ! First, ignore the first sequence of ignorables
     do j = 1, len(str)
       if ( index(myIgnore, str(j:j)) < 1 ) then
         exit
       endif
     end do 
     ! Collect digits of the first number in the string
     do j = 1, len(str)
       if ( index(myIgnore, str(j:j)) < 1 ) then
         myStr(k:k) = str(j:j)
         k = k + 1
       else
         exit
       endif
     enddo
     if ( myStr /= "" ) read( mystr, *, iostat=status, err=100 ) num
   endif
   if ( status /= 0 ) num = STRINGCONTAINSFORBIDDENS
   return
100   num = STRINGCONTAINSFORBIDDENS
!  end subroutine readAnIntFromChars
! $Log$
! Revision 2.2  2010/06/23 20:42:21  honghanh
! Change readAnIntFromChars to only read the first number in the string
! if there are many numbers separated by ignored characters.
! Update comment of the method.
!
! Revision 2.1  2009/06/16 17:05:27  pwagner
! First commit
!
