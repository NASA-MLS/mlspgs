! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

!=============================================================================
module Geolocation_m
!=============================================================================

  ! Define geolocation representations.  Enquire a geolocation.
  ! Calculate interpolation coefficients.

  use Allocate_Deallocate, only: Allocate_Test, Deallocate_Test, Test_Allocate, &
    & Test_Deallocate
  use Geolocation_0, only: ECR_t, GeocLat_t, GeodLat_t, Lat_t, Lon_t, H_t, &
    & H_Geoc, H_Geod, H_V_t, H_V_Geoc, H_V_Geod, H_V_Zeta, RG, V_T, V_Geoc, &
    & V_Geod, V_Zeta
  use Generate_QTM_m, only: QTM_Tree_t

  implicit NONE
  private

  ! Types:
  public :: Coeff_t, Geolocation_t
  public :: ECR_t, H_t, H_Geoc, H_Geod
  public :: Lat_t, GeocLat_t, GeodLat_t, Lon_t
  public :: H_V_t, H_V_Geoc, H_V_Geod, H_V_Zeta
  public :: QTM_Tree_t, V_T, V_Geoc, V_Geod, V_Zeta
  ! All the procedures are type bound.  The specific and generic
  ! bindings are public but the "bare" procedures are private.

  public :: RG

!---------------------------- RCS Module Info ------------------------------
  character (len=*), private, parameter :: ModuleName= &
       "$RCSfile$"
  private :: not_used_here
!---------------------------------------------------------------------------

  type :: Geolocation_t
    ! DO NOT use the components without checking that they're associated!
    ! If you're not sure, use the functions.  If the functions return
    ! -huge(0.0_rg) then nothing was associated, or you asked for zeta when
    ! it wasn't associated, or you asked for height when zeta was associated. 
    ! We don't want to run the hydrostatic model to convert between them
    ! here -- and we don't have temperature anyway, so we can't.

    ! Horizontal coordinates, degrees
    type(lon_t), pointer, contiguous :: Lon1(:)=> null()       ! V*H*H
    type(lon_t), pointer, contiguous :: Lon2(:,:) => null()    ! => Lon1, V x H*H
    type(lon_t), pointer, contiguous :: Lon3(:,:,:) => null()  ! => Lon1, V x H x H
    type(geocLat_t), pointer, contiguous :: GeocLat1(:) => null()     ! V*H*H
    type(geocLat_t), pointer, contiguous :: GeocLat2(:,:) => null()   ! => geocLat1, V x H*H
    type(geocLat_t), pointer, contiguous :: GeocLat3(:,:,:) => null() ! => geocLat1, V x H x H
    type(geodLat_t), pointer, contiguous :: GeodLat1(:) => null()     ! V*H*H
    type(geodLat_t), pointer, contiguous :: GeodLat2(:,:) => null()   ! => geodLat1, V x H*H
    type(geodLat_t), pointer, contiguous :: GeodLat3(:,:,:) => null() ! => geodLat1, V x H x H
    ! Great-circle along-track coordinate, degrees, with origin at the
    ! instrument and increasing in the direction of the tangent.
    real(rg), pointer, contiguous :: Phi1(:) => null()         ! V*H*H
    real(rg), pointer, contiguous :: Phi2(:,:) => null()       ! => Phi1, V x H*H
    real(rg), pointer, contiguous :: Phi3(:,:,:) => null()     ! => Phi1, V x H x H
    ! Vertical coordinates, meters from the Earth center
    type(v_geoc), pointer, contiguous :: GeocV1(:) => null()   ! V*H*H or V*size(QTM_ZOT)
    type(v_geoc), pointer, contiguous :: GeocV2(:,:) => null() ! => GeocV1, V x H*H or
                                                               ! V x size(QTM_ZOT)
    type(v_geoc), pointer, contiguous :: GeocV3(:,:,:) => null() ! => GeocV1, V x H x H
    ! Vertical coordinates, meters above sea level
    type(v_geod), pointer, contiguous :: GeodV1(:) => null()   ! V*H*H or V*size(QTM_ZOT)
    type(v_geod), pointer, contiguous :: GeodV2(:,:) => null() ! => GeodV1, V x H*H or
                                                               ! V x size(QTM_ZOT)
    type(v_geod), pointer, contiguous :: GeodV3(:,:,:) => null() ! => GeodV1, V x H x H
    ! Vertical coordinates, zeta
    type(v_zeta), pointer, contiguous :: Zeta1(:) => null()    ! V*H*H
    type(v_zeta), pointer, contiguous :: Zeta2(:,:) => null()  ! => Zeta1, V x H*H
    type(v_zeta), pointer, contiguous :: Zeta3(:,:,:) => null() ! => Zeta1, V x H x H
    ! ECR coordinates, meters
    type(ecr_t), pointer, contiguous :: P1(:) => null()        ! V*H*H
    type(ecr_t), pointer, contiguous :: P2(:,:) => null()      ! => P1, V x H*H
    type(ecr_t), pointer, contiguous :: P3(:,:,:) => null()    ! => P1, V x H x H
    ! QTM horizontal grids, generated by Generate_QTM
    type(QTM_tree_t) :: QTM_Tree

    logical :: Cartesian = .false.   ! Horizontal lat/lon grid is Cartesian
    logical :: Coherent = .false.    ! Do instances have same sets of vertical
                                     ! coordinates?
    logical :: GreatCircle = .false. ! Are coordinates on a great circle?
    logical :: Stacked = .false.     ! Are instances true vertical profiles?  We
                                     ! assume that if they are, and the
                                     ! horizontal basis is two-dimensional, the
                                     ! instances are still true vertical
                                     ! profiles, not just in vertical planes.

  contains

    ! Create using geocentric lat and height (meters) from the Earth center
    procedure :: Geoc_V_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geoc_V_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geoc_V_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geoc_V_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geoc_V_1_2   ! Stacked but not coherent
    procedure :: Geoc_V_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geoc_V_2_1   ! Coherent, maybe stacked
    procedure :: Geoc_V_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using geocentric lat and height (meters) from the Earth center for
    ! two points on a great circle, and angles along that great circle
    procedure :: Geoc_V_G_0_1 ! One circle, coherent and stacked
    procedure :: Geoc_V_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geoc_V_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geoc_V_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and height (meters) from sea lavel for two
    ! points on a great circle, and angles along that great circle
    procedure :: Geod_V_G_0_1 ! One circle, coherent and stacked
    procedure :: Geod_V_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geod_V_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geod_V_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and zeta for two points on a great circle, and
    ! angles along that great circle
    procedure :: Geod_Z_G_0_1 ! One circle, coherent and stacked
    procedure :: Geod_Z_G_1_1 ! Several circles, coherent and stacked
    procedure :: Geod_Z_G_1_2 ! Several circles, incoherent and unstacked
    procedure :: Geod_Z_G_2_3 ! Several families of circles, incoherent and unstacked
    ! Create using geodetic lat and height (meters) above sea level
    ! Create using geodetic lat and height (meters) above sea level
    procedure :: Geod_V_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_V_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geod_V_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geod_V_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geod_V_1_2   ! Stacked but not coherent
    procedure :: Geod_V_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_V_2_1   ! Coherent, maybe stacked
    procedure :: Geod_V_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using geodetic lat and height zeta
    procedure :: Geod_Z_1     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_Z_1_1   ! Needs to be told whether it's coherent and stacked
    procedure :: Geod_Z_1_1_1 ! Inherently Cartesian, coherent, and stacked
    procedure :: Geod_Z_1_1_3 ! Inherently Cartesian, incoherent, and stacked
    procedure :: Geod_Z_1_2   ! Stacked but not coherent
    procedure :: Geod_Z_2     ! Entirely irregular -- neither coherent nor stacked
    procedure :: Geod_Z_2_1   ! Coherent, maybe stacked
    procedure :: Geod_Z_3     ! Entirely irregular -- neither coherent nor stacked
    ! Create using ECR, meters
    procedure :: Create_P_1   ! Neither coherent nor stacked
    procedure :: Create_P_2   ! Neither coherent nor stacked
    procedure :: Create_P_3   ! Neither coherent nor stacked

    ! Declare Create generic
    ! Entirely irregular -- neither coherent nor stacked:
    generic :: Create => geoc_v_1
    generic :: Create => geod_v_1
    generic :: Create => geod_z_1
    generic :: Create => geoc_v_2
    generic :: Create => geod_v_2
    generic :: Create => geod_z_2
    generic :: Create => geoc_v_3
    generic :: Create => geod_v_3
    generic :: Create => geod_z_3
    generic :: Create => create_p_1
    generic :: Create => create_p_2
    generic :: Create => create_p_3
    ! Needs to be told whether it's coherent and stacked:
    generic :: Create => geoc_v_1_1
    generic :: Create => geod_v_1_1
    generic :: Create => geod_z_1_1
    ! Stacked but not coherent:
    generic :: Create => geoc_v_1_2
    generic :: Create => geod_v_1_2
    generic :: Create => geod_z_1_2
    ! Coherent but not stacked
    generic :: Create => geoc_v_2_1
    generic :: Create => geod_v_2_1
    generic :: Create => geod_z_2_1
    ! On great circles
    generic :: Create => geoc_v_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geoc_v_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geoc_v_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geoc_v_g_2_3 ! Several families of circles, incoherent and instacked
    generic :: Create => geod_v_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geod_v_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geod_v_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geod_v_g_2_3 ! Several families of circles, incoherent and instacked
    generic :: Create => geod_z_g_0_1 ! One circle, maybe coherent and stacked
    generic :: Create => geod_z_g_1_1 ! Several circles, maybe coherent and stacked
    generic :: Create => geod_z_g_1_2 ! Several circles, incoherent and instacked
    generic :: Create => geod_z_g_2_3 ! Several families of circles, incoherent and instacked

    ! Interrogate
    procedure :: Lon        ! Degrees
    procedure :: GeocLat    ! Geocentric latitude, degrees
    procedure :: GeodLat    ! Geodetic latitude, degrees
    procedure :: GeocV      ! Geocentric height, meters from the Earth center
    procedure :: GeodV      ! Geodetic height, meters above sea level
    procedure :: Zeta       ! Zeta
    procedure :: Loc_Geoc   ! Lon degrees, geoc lat degrees, geoc height meters
    procedure :: Loc_Geod   ! Lon degrees, geod lat degrees, geod height meters
    procedure :: Loc_Zeta   ! Lon degrees, geod lat degrees, zeta
    procedure :: ECR        ! ECR coordinates, meters

    ! Fill alternative representations from existant geolocations
    procedure :: Fill_Geoc
    procedure :: Fill_Geod
    ! There is no Fill_Zeta because that would require a temperature field
    ! and access to the hydrostatic model.
    procedure :: Fill_ECR

    ! Insert alternative vertical coordinates
    procedure :: Insert_Geoc_1
    procedure :: Insert_Geoc_2
    procedure :: Insert_Geoc_3
    procedure :: Insert_Geod_1
    procedure :: Insert_Geod_2
    procedure :: Insert_Geod_3
    procedure :: Insert_Zeta_1
    procedure :: Insert_Zeta_2
    procedure :: Insert_Zeta_3

    generic :: Insert => Insert_Geoc_1
    generic :: Insert => Insert_Geoc_2
    generic :: Insert => Insert_Geoc_3
    generic :: Insert => Insert_Geod_1
    generic :: Insert => Insert_Geod_2
    generic :: Insert => Insert_Geod_3
    generic :: Insert => Insert_Zeta_1
    generic :: Insert => Insert_Zeta_2
    generic :: Insert => Insert_Zeta_3

    ! Remove alternative representations
    procedure :: Delete_Geoc
    procedure :: Delete_Geod
    procedure :: Delete_Zeta
    procedure :: Delete_ECR

    ! Destroy
    procedure :: Explicit_Destroy_G
    generic :: Destroy => Explicit_Destroy_G
    procedure :: Destroy_G_P1     ! Because we can't use deallocate_test
    final :: Destroy_G

  end type Geolocation_t

  ! Given a geolocation_t structure, and the geolocation of a point,
  ! interpolation coefficients from the structure to the point are represented
  ! by an object of this type:
  type :: Coeff_t
    integer, allocatable :: I(:)  ! Array element-order indices of points in
                                  ! the geolocation-t structure with nonzero
                                  ! interpolation coefficients.
    real(rg), allocatable :: C(:) ! Nonzero interpolation coefficients.
    ! Size(I) = size(c), typically 3 or 4 in two dimensions depending upon
    ! whether the grid is quadrilateral, or irregular and a Delaunay
    ! triangulation is used, or 6 or 8 in three dimensions depending upon
    ! whether the horizontal grid is quadrilateral, or irregular and a Delaunay
    ! triangulation is used.  If a tetrahedral tessellation is used, there
    ! would be four nonzeros.
  end type Coeff_t

contains

  ! -----  Geolocation_t procedures  -----------------------------------

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for the tangent points or spacecraft locations of all the
  ! MIFs in a MAF.  Coordinates of each point are longitude, geocentric latitude,
  ! and height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_1 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:)
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geocLat2(1:size(hv,1),1:1) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(hv,1),1:1) => g%geocV1
    g%geocV3(1:size(hv,1),1:1,1:1) => g%geocV1
    g%lon1 = hv%lon
    g%geocLat1%d = hv%lat
    g%geocV1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_1

  ! Create using longitude, geocentric latitude, height in meters from the
  ! Earth center.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be only stacked or
  ! only coherent.
  ! The order of geolocated values is vertical first, then horizontal.  If
  ! Regular is absent, or present and true, the horizontal order is longitude
  ! first, then latitude.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:)         ! Horizontal coordinates (lon, lat)
    type(v_geoc), intent(in) :: V(:)         ! Geocentric height, meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geocLat2(1:size(h),1:1) => g%geocLat1
    g%geocLat3(1:size(h),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%lon1 = h%lon
    g%geocLat1%d = h%lat
    g%geocV1%v = v%v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geoc_V_1_1

  ! Create using the outer product of longitude, geocentric latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geoc_V_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geocLat_t), intent(in) :: Lat(:)  ! Geocentric latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:)       ! Geocentric height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geocLat2(1:size(lat),1:1) => g%geocLat1
    g%geocLat3(1:size(lat),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%lon1= lon
    g%geocLat1 = lat
    g%geocV1 = v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geoc_V_1_1_1

  ! Create using the outer product of longitude and geocentric latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geocLat_t), intent(in) :: Lat(:)  ! Geocentric latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:,:,:)   ! Geocentric height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geocLat2(1:size(lat),1:1) => g%geocLat1
    g%geocLat3(1:size(lat),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
  end subroutine Geoc_V_1_1_3

  ! Stacked but not coherent, using longitude, geocentric latitude, and
  ! geocentric height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_geoc), intent(in) :: V(:,:)     ! Geocentric heights
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geocLat2(1:size(h),1:1) => g%geocLat1
    g%geocLat3(1:size(h),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%lon1 = h%lon
    g%geocLat1%d = h%lat
    g%geocV2 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geoc_V_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude, geocentric
  ! latitude, and geocentric height in meters from the Earth center.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:,:)  ! All geocentric coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geocLat2(1:size(hv,1),1:size(hv,2)) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(hv,1),1:size(hv,2)) => g%geocV1
    g%geocV3(1:size(hv,1),1:size(hv,2),1:1) => g%geocV1
    g%lon2 = hv%lon
    g%geocLat2%d = hv%lat
    g%geocV2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geoc_V_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_geoc), intent(in) :: V(:)       ! Geocentric heights
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geocLat2(1:size(h,1),1:size(h,2)) => g%geocLat1
    g%geocLat3(1:size(h,1),1:size(h,2),1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:1) => g%geocV1
    g%geocV3(1:size(v,1),1:1,1:1) => g%geocV1
    g%lon2 = h%lon
    g%geocLat2%d = h%lat
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geoc_V_2_1

  ! Entirely irregular, rank 3, using longitude, geocentric latitude, and
  ! geocentric height in meters from the Earth center.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geoc_V_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_geoc), intent(in) :: HV(:,:,:) ! All geocentric coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geocLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geocLat1
    g%geocLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geocLat1
    g%geocV2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geocV1
    g%geocV3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geocV1
    g%lon3 = hv%lon
    g%geocLat3%d = hv%lat
    g%geocV3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geoc_V_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! geocentric height (meters), and angle (degrees) along the great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geoc_V_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1, R2       ! Points on the great circle
    real(rg), intent(in) :: Phi(:)           ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:)         ! Geocentric heights (meters)
    logical, intent(in), optional :: Outer   ! Outer product, default YES
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geocLat2(1:size(phi),1:1) => g%geocLat1
    g%geocLat3(1:size(phi),1:1,1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%phi1 = phi
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and GeocLat for points on the great circle from R1 to R2
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, g%geocLat1%d )
  end subroutine Geoc_V_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of geocentric height
  ! (meters), and angle (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_geoc), intent(in) :: V(:)       ! Geocentric heights (meters) - same
                                           ! on all circles
    integer :: I, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geocLat2(1:size(phi),1:size(r1)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(r1),1:1) => g%geocLat1
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%phi1 = phi
    g%geocV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, g%geocLat2(:,i)%d )
    end do
  end subroutine Geoc_V_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by geocentric height (meters), and angle
  ! (degrees) along each great circle.  The angular spacing of the grid along
  ! each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and   !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:,:)     ! Geocentric heights (meters)
    integer :: I, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geocLat2(1:size(phi),1:size(r1)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(r1),1:1) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%phi1 = phi
    g%geocV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, g%geocLat2(:,i)%d )
    end do
  end subroutine Geoc_V_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by geocentric height
  ! (meters), and angle (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi. The third dimension
  ! of Phi and V can be considered an instance or family index.  This is intended
  ! to create a grid in each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geoc_V_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geoc), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geoc), intent(in) :: V(:,:,:)   ! Geocentric heights (meters)
    integer :: I, J, Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geocLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geocLat1
    g%geocLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geocLat1
    g%geocV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
    g%phi1 = phi
    g%geocV3%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, &
          & g%geocLat3(:,i,j)%d )
      end do
    end do
  end subroutine Geoc_V_G_2_3

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_1 ( G, HV )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:)      ! All geodetic coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:1) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(hv,1),1:1) => g%geodV1
    g%geodV3(1:size(hv,1),1:1,1:1) => g%geodV1
    g%lon1 = hv%lon
    g%geodLat1%d = hv%lat
    g%geodV1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_1

  ! Create using geodetic latitude and height in meters above sea level.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be just one.
  ! The order of geolocated values is vertical first, then horizontal.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)         ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:)         ! Geodetic height in meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV1%v = v%v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geod_V_1_1

  ! Create using the outer product of longitude, geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geod_V_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geoc), intent(in) :: V(:)       ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geocV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%lon1 = lon
    g%geocLat1%d = lat%d
    g%geocV1%v = v%v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geod_V_1_1_1

  ! Create using the outer product of longitude and geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)*size(v,3)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geodV1
  end subroutine Geod_V_1_1_3

  ! Stacked but not coherent, using longitude, geodetic latitude, and
  ! geodetic height in meters above sea level.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:,:)     ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geod_V_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude,
  ! geodetic latitude, and geodetic height in meters above sea level.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:,:)  ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(hv,1),1:size(hv,2)) => g%geodV1
    g%geodV3(1:size(hv,1),1:size(hv,2),1:1) => g%geodV1
    g%lon2 = hv%lon
    g%geodLat2%d = hv%lat
    g%geodV2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geod_V_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_geod), intent(in) :: V(:)       ! Geodetic height, meters
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geodLat2(1:size(h,1),1:size(h,2)) => g%geodLat1
    g%geodLat3(1:size(h,1),1:size(h,2),1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:1) => g%geodV1
    g%geodV3(1:size(v,1),1:1,1:1) => g%geodV1
    g%lon2 = h%lon
    g%geodLat2%d = h%lat
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geod_V_2_1

  ! Entirely irregular, rank 3, using longitude, geodetic latitude, and
  ! geodetic height in meters above sea level.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_V_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_geod), intent(in) :: HV(:,:,:) ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodLat1
    g%geodV2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodV1
    g%geodV3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodV1
    g%lon3 = hv%lon
    g%geodLat3%d = hv%lat
    g%geodV3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_V_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! geodetic height (meters), and angle (degrees) along the great circle.  The
  ! angular spacing of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geod_V_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1, R2     ! Points on the great circle
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:)       ! Geodetic heights (meters)
    logical, intent(in), optional :: Outer ! Outer product, default YES
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geodLat2(1:size(phi),1:1) => g%geodLat1
    g%geodLat3(1:size(phi),1:1,1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%phi1 = phi
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and geodLat for points on the great circle from R1 to R2
    ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, lat%d )
    g%geodLat1 = lat%geod()
  end subroutine Geod_V_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of geodetic height
  ! (meters), and angle (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_geod), intent(in) :: V(:)       ! Geodetic heights (meters) - same
                                           ! on all circles
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%geodV2(1:size(v),1:1) => g%geodV1
    g%geodV3(1:size(v),1:1,1:1) => g%geodV1
    g%phi1 = phi
    g%geodV1%v = v%v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_V_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by geodetic height (meters), and angle
  ! (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:,:)     ! Geodetic heights (meters)
    integer :: I, Stat
    type(geodLat_t) :: Lat(size(phi))      ! geodetic latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%phi1 = phi
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_V_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by geodetic height (meters),
  ! and angle (degrees) along each great circle.  The angular spacing of the grid
  ! along each circle is the same, given by Phi.  The third dimension of Phi and
  ! V can be considered an instance or family index.  This is intended to create
  ! a grid in each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_V_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: I, J, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodLat1
    g%geodV2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodV1
    g%geodV3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodV1
    g%phi1 = phi
    g%geodV3%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, lat%d )
        g%geodLat3(:,i,j) = lat%geod()
      end do
    end do
  end subroutine Geod_V_G_2_3

  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_1 ( G, HV )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:)      ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:1) => g%lon1
    g%lon3(1:size(hv,1),1:1,1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:1) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(hv,1),1:1) => g%zeta1
    g%zeta3(1:size(hv,1),1:1,1:1) => g%zeta1
    g%lon1 = hv%lon
    g%geodLat1%d = hv%lat
    g%zeta1%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_1

  ! Create using geodetic latitude and zeta.
  ! We can't tell just by the fact that both horizontal and vertical are one
  ! dimensional whether it's coherent and stacked, i.e., an outer product, or
  ! neither, i.e., a line through the atmosphere -- it can't be just one.
  ! The order of geolocated values is vertical first, then horizontal.
  ! If Regular is present and false, then
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(h) = size(v)                                 !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_1 ( G, H, V, Regular )
    class(geolocation_t), intent(out) :: G   ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)         ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:)         ! Geodetic height, meters
    logical, intent(in), optional :: Regular ! coherent and stacked, default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate( stat, 'zeta1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%zeta1 = v
    g%cartesian = .false.
    if ( present(regular) ) then
      g%coherent = regular
      g%stacked = regular
    else
      g%coherent = .true.
      g%stacked = .true.
    end if
  end subroutine Geod_Z_1_1

  ! Create using the outer product of longitude, geodetic latitude, and
  ! zeta.  This is inherently Cartesian, coherent, and stacked.
  ! The order of geolocated values is vertical, longitude, latitude.
  subroutine Geod_Z_1_1_1 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%lon1%d = lon%d
    g%geocLat1%d = lat%d
    g%geocV1%v = v%v
    g%cartesian = .true.
    g%coherent = .true.
    g%stacked = .true.
  end subroutine Geod_Z_1_1_1

  ! Create using the outer product of longitude and geodetic latitude, and
  ! height in meters from the Earth center.  This is inherently Cartesian,
  ! incoherent, and stacked.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(lon) and size(v,3) = size(lat)   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_1_3 ( G, Lat, Lon, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(geodLat_t), intent(in) :: Lat(:)  ! Geodetic latitude, degrees
    type(lon_t), intent(in) :: Lon(:)      ! Longitude, degrees
    type(v_geod), intent(in) :: V(:,:,:)   ! Geodetic height, meters
    integer :: Stat
    allocate ( g%lon1(size(lon)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(lat)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(lon),1:1) => g%lon1
    g%lon3(1:size(lon),1:1,1:1) => g%lon1
    g%geodLat2(1:size(lat),1:1) => g%geodLat1
    g%geodLat3(1:size(lat),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)*size(v,3)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
  end subroutine Geod_Z_1_1_3

  ! Stacked but not coherent, using longitude, geodetic latitude, and zeta.
  ! The order of geolocated values is the same as the array-element order of V.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(v,2) = size(h)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_1_2 ( G, H, V )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:)       ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:,:)     ! Zeta
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodV1', moduleName )
    g%lon2(1:size(h),1:1) => g%lon1
    g%lon3(1:size(h),1:1,1:1) => g%lon1
    g%geodLat2(1:size(h),1:1) => g%geodLat1
    g%geodLat3(1:size(h),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%lon1 = h%lon
    g%geodLat1%d = h%lat
    g%geodV2%v = v%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .true.
  end subroutine Geod_Z_1_2

  ! Entirely irregular, rank 2, e.g., for a plane, using longitude, geodetic
  ! latitude, and zeta.
  ! It might actually be coherent and stacked, depending upon values of HV.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_2 ( G, HV )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:,:)  ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:1) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(hv,1),1:size(hv,2)) => g%zeta1
    g%zeta3(1:size(hv,1),1:size(hv,2),1:1) => g%zeta1
    g%lon2 = hv%lon
    g%geodLat2%d = hv%lat
    g%zeta2%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_2

  ! Coherent, maybe stacked.
  ! If it's stacked, H gives coordinates in a horizontal plane.  Otherwise,
  ! H gives coordinates in a vertical plane.
  ! If it's stacked, the order of geolocated values is V, then the
  ! array-element order of H.  If it's not stacked, the order of geolocated
  ! values is the same as the array-element order of H.
  subroutine Geod_Z_2_1 ( G, H, V, Stacked )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: H(:,:)     ! Horizontal coordinates
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    logical, intent(in), optional :: Stacked ! default YES
    integer :: Stat
    allocate ( g%lon1(size(h)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(h)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(h,1),1:size(h,2)) => g%lon1
    g%lon3(1:size(h,1),1:size(h,2),1:1) => g%lon1
    g%geodLat2(1:size(h,1),1:size(h,2)) => g%geodLat1
    g%geodLat3(1:size(h,1),1:size(h,2),1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:1) => g%zeta1
    g%zeta3(1:size(v,1),1:1,1:1) => g%zeta1
    g%lon2 = h%lon
    g%geodLat2%d = h%lat
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    if ( present(stacked) ) then
      g%stacked = stacked
    else
      g%stacked = .true.
    end if
  end subroutine Geod_Z_2_1

  ! Entirely irregular, rank 3, using longitude, geodetic latitude, and zeta.
  ! The order of geolocated values is the same as the array-element order of HV.
  subroutine Geod_Z_3 ( G, HV )
    class(geolocation_t), intent(out) :: G  ! Intent(out) causes Destroy_G
    type(h_v_zeta), intent(in) :: HV(:,:,:) ! All coordinates
    integer :: Stat
    allocate ( g%lon1(size(hv)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(hv)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(hv)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%lon2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%lon1
    g%lon3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%lon1
    g%geodLat2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%geodLat1
    g%geodLat3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%geodLat1
    g%zeta2(1:size(hv,1),1:size(hv,2)*size(hv,3)) => g%zeta1
    g%zeta3(1:size(hv,1),1:size(hv,2),1:size(hv,3)) => g%zeta1
    g%lon3 = hv%lon
    g%geodLat3%d = hv%lat
    g%zeta3%v = hv%v
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Geod_Z_3

  ! Identify a great circle by two points on it.  If Outer is absent, or present
  ! and true, the grid is coherent and stacked, defined by the outer product of
  ! zeta, and angle (degrees) along the great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  ! If outer is present and false, the grid is one-dimensional, and
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(phi) = size(v).                              !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! the order of geolocated values is the same as the array-element order of Phi.
  subroutine Geod_Z_G_0_1 ( G, R1, R2, Phi, V, Outer )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1, R2     ! Points on the great circle
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:)       ! Zeta
    logical, intent(in), optional :: Outer ! Outer product, default YES
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    integer :: Stat
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geocLat1(size(phi)), stat=stat )
    call test_allocate ( stat, 'geocLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:1) => g%lon1
    g%lon3(1:size(phi),1:1,1:1) => g%lon1
    g%geodLat2(1:size(phi),1:1) => g%geodLat1
    g%geodLat3(1:size(phi),1:1,1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%phi1 = phi
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    if ( present(outer) ) then
      g%coherent = outer
      g%stacked = outer
    end if
    ! Compute Lon and GeocLat for points on the great circle from R1 to R2
    ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
    call great_circle_points ( r1%lon%d, r1%lat, r2%lon%d, r2%lat, phi, &
      & g%lon1%d, lat%d )
    g%geodLat1 = lat%geod()
  end subroutine Geod_Z_G_0_1

  ! Identify great circles by two points on each one.  The grid is coherent and
  ! stacked, defined on each circle by the outer product of zeta, and angle
  ! (degrees) along each great circle.
  ! The order of geolocated values is the same as the array-element order of V,
  ! followed by the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2)                               !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_1_1 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees) - same
                                           ! on all circles
    type(v_zeta), intent(in) :: V(:)       ! zeta -- same on all circles
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(phi)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(phi)*size(r1)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(r1)) => g%lon1
    g%lon3(1:size(phi),1:size(r1),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(r1)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(r1),1:1) => g%geodLat1
    g%zeta2(1:size(v),1:1) => g%zeta1
    g%zeta3(1:size(v),1:1,1:1) => g%zeta1
    g%phi1 = phi
    g%zeta1 = v
    g%cartesian = .false.
    g%coherent = .true.
    g%greatCircle = .true.
    g%stacked = .true.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_Z_G_1_1

  ! Identify great circles by two points on each one.  The grid is incoherent and
  ! unstacked, defined on each circle by zeta, and angle
  ! (degrees) along each great circle.  The angular spacing
  ! of the grid along each circle is the same, given by Phi.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! size(r1) = size(r2), size(phi) = size(v,1), and !!!!
  !!!! size(v,2) = size(r1) = size(r2)                   !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_1_2 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:), R2(:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:,:)     ! Zeta
    integer :: I, Stat
    type(geocLat_t) :: Lat(size(phi))      ! geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:1) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:1) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%phi1 = phi
    g%zeta2 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and geodLat for points on the great circles from R1 to R2
    do i = 1, size(r1)
      ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
      call great_circle_points ( r1(i)%lon%d, r1(i)%lat, r2(i)%lon%d, r2(i)%lat, &
        & phi, g%lon2(:,i)%d, lat%d )
      g%geodLat2(:,i) = lat%geod()
    end do
  end subroutine Geod_Z_G_1_2

  ! Identify families of great circles by two points on each one.  The grids are
  ! incoherent and unstacked, defined on each circle by zeta, and angle (degrees)
  ! along each great circle.  The angular spacing of the grid along each circle
  ! is the same, given by Phi.  The third dimension of Phi and V can be
  ! considered an instance or family index.  This is intended to create a grid in
  ! each ruled surface defined by one vertical scan.
  ! The order of geolocated values is the same as the array-element order of Phi.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!                                                   !!!!
  !!!! There is an assumption here, NOT CHECKED, that    !!!!
  !!!! shape(r1) = shape(r2), size(phi) = size(v,1), and !!!!
  !!!! shape(v)(2:3) = shape(r1) = shape(r2)             !!!!
  !!!!                                                   !!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine Geod_Z_G_2_3 ( G, R1, R2, Phi, V )
    use Geometry, only: Great_Circle_Points
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(h_geod), intent(in) :: R1(:,:), R2(:,:) ! Points on the great circles
    real(rg), intent(in) :: Phi(:)         ! Along-track angles (degrees)
    type(v_zeta), intent(in) :: V(:,:,:)   ! Zeta
    integer :: I, J, Stat
    type(geocLat_t) :: Lat(size(phi))      ! Geocentric latitudes
    call allocate_test ( g%phi1, size(phi), 'phi1', moduleName )
    allocate ( g%lon1(size(v)), stat=stat )
    call test_allocate ( stat, 'lon1', moduleName )
    allocate ( g%geodLat1(size(v)), stat=stat )
    call test_allocate ( stat, 'geodLat1', moduleName )
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'zeta1', moduleName )
    g%phi2(1:size(phi),1:1) => g%phi1
    g%phi3(1:size(phi),1:1,1:1) => g%phi1
    g%lon2(1:size(phi),1:size(v,2)*size(v,3)) => g%lon1
    g%lon3(1:size(phi),1:size(v,2),1:size(v,3)) => g%lon1
    g%geodLat2(1:size(phi),1:size(v,2)*size(v,3)) => g%geodLat1
    g%geodLat3(1:size(phi),1:size(v,2),1:size(v,3)) => g%geodLat1
    g%zeta2(1:size(v,1),1:size(v,2)*size(v,3)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
    g%phi1 = phi
    g%zeta3 = v
    g%cartesian = .false.
    g%coherent = .false.
    g%greatCircle = .true.
    g%stacked = .false.
    ! Compute Lon and GeocLat for points on the great circles from R1 to R2
    do j = 1, size(r1,2)
      do i = 1, size(r1,1)
        ! ??? Need work here ??? Convert R[12]%lat to geocentric first ???
        call great_circle_points ( r1(i,j)%lon%d, r1(i,j)%lat, &
          & r2(i,j)%lon%d, r2(i,j)%lat, phi, g%lon3(:,i,j)%d, lat%d )
        g%geodLat3(:,i,j) = lat%geod()
      end do
    end do
  end subroutine Geod_Z_G_2_3

  ! Create using ECR in meters
  ! Entirely irregular, rank 1, e.g., for a line not defined by reference to a
  ! great circle, or for all the MIFs in a MAF.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_1 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:)        ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=p, stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p),1:1) => g%p1
    g%p3(1:size(p),1:1,1:1) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_1

  ! Entirely irregular, rank 2, e.g., for a plane.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_2 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:,:)      ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=reshape(p,[size(p)]), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p,1),1:size(p,2)) => g%p1
    g%p3(1:size(p),1:size(p,2),1:1) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_2

  ! Entirely irregular, rank 3.
  ! The order of geolocated values is the same as the array-element order of P.
  subroutine Create_P_3 ( G, P )
    class(geolocation_t), intent(out) :: G ! Intent(out) causes Destroy_G
    type(ecr_t), intent(in) :: P(:,:,:)    ! All the coordinates, ECR, meters
    integer :: Stat
    allocate ( g%p1, source=reshape(p,[size(p)]), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', 1, size(p), storage_size(g%p1)/8 )
    g%p2(1:size(p,1),1:size(p,2)*size(p,3)) => g%p1
    g%p3(1:size(p),1:size(p,2),1:size(p,3)) => g%p1
    g%cartesian = .false.
    g%coherent = .false.
    g%stacked = .false.
  end subroutine Create_P_3

  ! Longitude
  type(lon_t) function Lon ( G, I, J, K )
    use Constants, only: Rad2Deg
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    real(rg) :: XYZ(3)
    if ( associated(g%lon1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          lon = g%lon3(i,merge(1,j,g%cartesian),merge(1,k,g%stacked))
        else
          lon = g%lon2(i,merge(1,j,g%cartesian))
        end if
      else if ( present(k) ) then
        lon = g%lon3(i,1,merge(1,k,g%stacked))
      else
        lon = g%lon1(i)
      end if
    else if ( associated(g%p1) ) then
      xyz = g%ecr(i,j,k)
      lon%d = atan2(xyz(2),xyz(1)) * rad2deg
    else ! nothing associated
      lon%d = -huge(0.0_rg)
    end if
  end function Lon

  ! Geocentric latitude
  type(geocLat_t) function GeocLat ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    type(geodLat_t) :: Geod
    real(rg) :: XYZ(3)
    if ( associated(g%geocLat1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          geocLat = g%geocLat3(merge(1,i,g%cartesian),j,merge(1,k,g%stacked))
        else
          geocLat = g%geocLat2(merge(1,i,g%cartesian),j)
        end if
      else if ( present(k) ) then
        geocLat = g%geocLat3(i,1,merge(1,k,g%stacked))
      else
        geocLat = g%geocLat1(i)
      end if
    else if ( associated(g%geodLat1) ) then
      geod = g%geodLat(i,j,k)
      geocLat = geod%geoc()
    else if ( associated(g%p1) ) then
      xyz = g%ecr(i,j,k)
      geocLat%d = asin(xyz(3)/norm2(xyz(1:2)))
    else ! nothing associated
      geocLat%d = -huge(0.0_rg)
    end if
  end function GeocLat

  ! Geodetic latitude
  type(geodLat_t) function GeodLat ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index if not stacked
    type(geocLat_t) :: Geoc
    if ( associated(g%geodLat1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          geodLat = g%geodLat3(merge(1,i,g%cartesian),j,merge(1,k,g%stacked))
        else
          geodLat = g%geodLat2(merge(1,i,g%cartesian),j)
        end if
      else if ( present(k) ) then
        geodLat = g%geodLat3(i,1,merge(1,k,g%stacked))
      else
        geodLat = g%geodLat1(i)
      end if
    else if ( associated(g%geocLat1) .or. associated(g%p1) ) then
      geoc = g%geocLat(i,j,k)
      geodLat = geoc%geod()
    else ! nothing associated
      geodLat%d = -huge(0.0_rg)
    end if
  end function GeodLat

  ! Geocentric height, meters from the Earth center
  type(v_geoc) function GeocV ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    type(h_v_geoc) :: Geoc
    type(h_v_geod) :: Geod
    type(v_geod) :: GeodV
    type(geodLat_t) :: LatGeod
    type(lon_t) :: Lon
    if ( g%coherent ) then
      if ( associated(g%geocV1) ) then
        GeocV = g%geocV1(k)
      else if ( associated(g%geodV1) ) then
        ! Convert [ longitude, geodetic latitude, geodetic height ] to geocentric.
        geod = h_v_geod ( lon=g%lon1(k), lat=g%geodLat1(k)%d, v=g%geodV1(k)%v )
        geoc = geod%geocV()
        GeocV%v = geoc%v
      else ! must be Zeta
        ! We would need the hydrostatic model to get geodV from Zeta, after
        ! which we could get GeocV from geodV
        GeocV%v = -huge(0.0_rg)
      end if
    else
      if ( associated(g%geocV1) ) then
        if ( present(j) ) then
          if ( present(k) ) then
            GeocV = g%geocV3(i,j,k)
          else
            GeocV = g%geocV2(i,j)
          end if
        else if ( present(k) ) then
          GeocV = g%geocV3(i,1,k)
        else
          GeocV = g%geocV1(i)
        end if
      else if ( associated(g%geodV1) ) then
        ! Convert [ longitude, geodetic latitude, geodetic height ] to geocentric.
        latGeod = g%geodLat(i,j,k)
        geodV = g%geodV(i,j,k)
        lon = g%lon(i,j,k)
        geod = h_v_geod ( lon=lon, lat=latGeod%d, v=geodV%v )
        geoc = geod%geocV()
        GeocV%v = geoc%v
      else if ( associated(g%p1) ) then ! ECR
        GeocV%v = norm2(g%ecr(i,j,k))
      else ! must be Zeta
        ! We would need the hydrostatic model to get geodV from Zeta, after
        ! which we could get GeocV from geodV
        GeocV%v = -huge(0.0_rg)
      end if
    end if
  end function GeocV

  ! Geodetic height, meters above sea level
  type(v_geod) function GeodV ( G, I, J, K )
    use Geometry, only: XYZ_To_Geod
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    real(rg) :: Geod(3)
    real(rg) :: XYZ(3)
    if ( associated(g%geodV1) ) then
      if ( g%coherent ) then
        if ( present(k) ) then
          geodV = g%geodV1(k)
        else if ( present(j) ) then
          geodV = g%geodV1(j)
        else
          geodV = g%geodV1(i)
        end if
      else
        if ( present(j) ) then
          if ( present(k) ) then
            geodV = g%geodV3(i,j,k)
          else
            geodV = g%geodV2(i,j)
          end if
        else if ( present(k) ) then
          geodV = g%geodV3(i,1,k)
        else
          geodV = g%geodV1(i)
        end if
      end if
    else if ( associated(g%geocV1) ) then
      xyz = g%ecr(i,j,k)
      geod = xyz_to_geod(xyz)
      geodV%v = geod(3)
    else ! must be Zeta
      ! We would need the hydrostatic model to get geodV from Zeta
      geodV%v = -huge(0.0_rg)
    end if
  end function GeodV

  ! Zeta
  type(v_zeta) function Zeta ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I
    integer, intent(in), optional :: J
    integer, intent(in), optional :: K
    if ( .not. associated(g%zeta1) ) then
      ! We would need the hydrostatic model to get Zeta from geodV
      zeta%v = -huge(0.0_rg)
      return
    end if
    if ( g%coherent ) then
      zeta = g%zeta1(k)
    else
      if ( present(j) ) then
        if ( present(k) ) then
          zeta = g%zeta3(i,j,k)
        else
          zeta = g%zeta2(i,j)
        end if
      else if ( present(k) ) then
        zeta = g%zeta3(i,1,k)
      else
        zeta = g%zeta1(i)
      end if
    end if
  end function Zeta

  ! Geocentric location (lon degrees, geoc lat degrees, geoc height meters)
  type(h_v_geoc) function Loc_Geoc ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(v_geoc) :: GeocV
    type(geocLat_t) :: LatGeoc
    loc_geoc%lon = g%lon(i,j,k)
    latGeoc = g%geocLat(i,j,k)
    loc_geoc%lat = latGeoc%d
    geocV = g%geocV(i,j,k)
    loc_geoc%v = geocV%v
  end function Loc_Geoc

  ! Geodetic location (lon degrees, geod lat degrees, geod height meters)
  type(h_v_geod) function Loc_Geod ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(v_geod) :: GeodV
    type(geodLat_t) :: LatGeod
    loc_geod%lon = g%lon(i,j,k)
    latGeod = g%geodLat(i,j,k)
    loc_geod%lat = latGeod%d
    geodV = g%geodV(i,j,k)
    loc_geod%v = geodV%v
  end function Loc_Geod

  ! Geodetic/Zeta location (lon degrees, geod lat degrees, zeta)
  type(h_v_zeta) function Loc_Zeta ( G, I, J, K )
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I, J, K
    type(geodLat_t) :: LatGeod
    type(v_zeta) :: Zeta
    loc_zeta%lon = g%lon(i,j,k)
    latGeod = g%geodLat(i,j,k)
    loc_zeta%lat = latGeod%d
    zeta = g%zeta(i,j,k)
    loc_zeta%v = zeta%v
  end function Loc_Zeta

  ! ECR coordinates, meters
  function ECR ( G, I, J, K )
    use Geometry, only: GeodToECRm, GeocToECRu
    class(geolocation_t), intent(in) :: G
    integer, intent(in) :: I            ! Lon index if Cartesian, or
                                        ! Lat index if J is not present
    integer, intent(in), optional :: J  ! Lat index if Cartesian
    integer, intent(in), optional :: K  ! Height index
    real(rg) :: ECR(3)
    type(v_geoc) :: GeocV
    type(v_geod) :: GeodV
    type(geocLat_t) :: LatGeoc
    type(geodLat_t) :: LatGeod
    type(lon_t) :: Lon
    if ( associated(g%p1) ) then
      if ( present(j) ) then
        if ( present(k) ) then
          ecr = g%p3(i,j,k)%xyz
        else
          ecr = g%p2(i,j)%xyz
        end if
      else if ( present(k) ) then
        ecr = g%p3(i,1,k)%xyz
      else
        ecr = g%p1(i)%xyz
      end if
    else if ( associated(g%geodV1) ) then
      ! Convert [ longitude, geodetic latitude, geodetic height] to ECR (meters)
      geodV = g%geodV(i,j,k)
      latGeod = g%geodLat(i,j,k)
      lon = g%lon(i,j,k)
      ecr = geodToECRm ( [ lon%d, latGeod%d, geodV%v ] )
    else if ( associated(g%geocV1) ) then
      ! Convert [ longitude, geocentric latitude, geocentric height] to ECR
      geocV = g%geocV(i,j,k)
      latGeoc = g%geocLat(i,j,k)
      lon = g%lon(i,j,k)
      ecr = GeocToECRu ( latGeoc%d, lon%d ) * geocV%v
    else
      ecr = [-huge(0.0_rg),-huge(0.0_rg),-huge(0.0_rg)]
    end if
  end function ECR

  ! Fill geocentric latitude and height components.
  subroutine Fill_Geoc ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%geocLat1) ) return ! Already have it
    if ( associated(g%geodLat1) ) then
      if ( .not. associated(g%geodV1) ) return ! must be zeta, can't convert
      allocate ( g%geocLat1(size(g%geodLat1)), stat=stat )
      call test_allocate ( stat, 'geocLat1', moduleName )
      allocate ( g%geocV1(size(g%geodV1)), stat=stat )
      call test_allocate ( stat, 'geocV1', moduleName )
    else if ( associated(g%P1) ) then
      allocate ( g%geocLat1(size(g%p1)), stat=stat )
      call test_allocate ( stat, 'geocLat1', moduleName )
      allocate ( g%geocV1(size(g%p1)), stat=stat )
      call test_allocate ( stat, 'geocV1', moduleName )
    else
      return ! can't do it
    end if
    g%geocLat2(1:size(g%geodLat2,1),1:size(g%geodLat2,2)) => g%geocLat1
    g%geocLat3(1:size(g%geodLat3,1),1:size(g%geodLat3,2),1:size(g%geodLat3,3)) => g%geocLat1
    g%geocV2(1:size(g%geodV2,1),1:size(g%geodV2,2)) => g%geocV1
    g%geocV3(1:size(g%geodV3,1),1:size(g%geodV3,2),1:size(g%geodV3,3)) => g%geocV1
    if ( g%coherent ) then
      do k = 1, size(g%geocV1,1)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geocLat3(i,j,1) = g%geocLat(i,j,1)
            g%lon3(i,j,1) = g%lon(i,j,1)
            g%geocV3(i,j,k) = g%GeocV(i,j,k)
          end do
        end do
      end do
    else
      do k = 1, size(g%geocV3,3)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geocLat3(i,j,k) = g%geocLat(i,j,k)
            g%lon3(i,j,k) = g%lon(i,j,k)
            g%geocV3(i,j,k) = g%GeocV(i,j,k)
          end do
        end do
      end do
    end if
  end subroutine Fill_Geoc

  ! Fill geodetic latitude and height components.
  subroutine Fill_Geod ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%geodLat1) ) return ! Already have it
    if ( associated(g%geocLat1) ) then
      if ( .not. associated(g%geocV1) ) return ! must be zeta, can't convert
      allocate ( g%geodLat1(size(g%geocLat1)), stat=stat )
      call test_allocate ( stat, 'geodLat1', moduleName )
      allocate ( g%geodV1(size(g%geocV1)), stat=stat )
      call test_allocate ( stat, 'geodV1', moduleName )
    else if ( associated(g%P1) ) then
      allocate ( g%geodLat1(size(g%P1)), stat=stat )
      call test_allocate ( stat, 'geodLat1', moduleName )
      allocate ( g%geodV1(size(g%P1)), stat=stat )
      call test_allocate ( stat, 'geodV1', moduleName )
    else
      return ! can't do it
    end if
    g%geodLat2(1:size(g%geocLat2,1),1:size(g%geocLat2,2)) => g%geodLat1
    g%geodLat3(1:size(g%geocLat3,1),1:size(g%geocLat3,2),1:size(g%geocLat3,3)) => g%geodLat1
    g%geodV2(1:size(g%geocV2,1),1:size(g%geocV2,2)) => g%geodV1
    g%geodV3(1:size(g%geocV3,1),1:size(g%geocV3,2),1:size(g%geocV3,3)) => g%geodV1
    if ( g%coherent ) then
      do k = 1, size(g%geodV1,1)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geodLat3(i,j,1) = g%geodLat(i,j,1)
            g%lon3(i,j,1) = g%lon(i,j,1)
            g%geodV3(i,j,k) = g%geodV(i,j,k)
          end do
        end do
      end do
    else
      do k = 1, size(g%geodV3,3)
        do j = 1, size(g%lon3,2)
          do i = 1, size(g%lon3,1)
            g%geodLat3(i,j,k) = g%geodLat(i,j,k)
            g%lon3(i,j,k) = g%lon(i,j,k)
            g%geodV3(i,j,k) = g%geodV(i,j,k)
          end do
        end do
      end do
    end if
  end subroutine Fill_Geod

  ! Fill ecr coordinates
  subroutine Fill_ECR ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: I, J, K, Stat
    if ( associated(g%P1) ) return ! Already have it
    if ( associated(g%zeta1) ) return ! Can't do it
    if ( associated(g%geocV1) ) then
      k = merge(size(g%geocV1,1),size(g%lon3,3),g%coherent)
    else if ( associated(g%geodv1) ) then
      k = merge(size(g%geodV1,1),size(g%lon3,3),g%coherent)
    end if
    call g%destroy_g_p1
    allocate ( g%p1(size(g%lon3,1)*size(g%lon3,2)*k), stat=stat )
    call test_allocate ( stat, moduleName, 'P1', &
      & 1, size(g%lon3,1)*size(g%lon3,2)*k, storage_size(g%p1)/8 )
    g%p2(1:size(g%lon3,1),1:size(g%lon3,2)) => g%p1
    g%p3(1:size(g%lon3,1),1:size(g%lon3,2),1:k) => g%p1
    do k = 1, size(g%P3,3)
      do j = 1, size(g%P3,2)
        do i = 1, size(g%P3,1)
          g%p3(i,j,k)%xyz = g%ecr(i,j,k)
        end do
      end do
    end do
  end subroutine Fill_ECR

  ! Insert geocentric height, meters from the Earth center.
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v),1:1) => g%geocV1
    g%geocV3(1:size(v),1:1,1:1) => g%geocV1
    g%geocV1%v = v%v
  end subroutine Insert_Geoc_1

  ! Insert geocentric height, meters from the Earth center
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:1) => g%geocV1
    g%geocV2%v = v%v
  end subroutine Insert_Geoc_2

  ! Insert geocentric height, meters from the Earth center
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geocentric height.
  ! If you already have geodetic height, use Fill_Geoc.
  ! If the grid is stacked and zeta, geocentric height doesn't make sense!
  subroutine Insert_Geoc_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geoc), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%geocV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%GeocV1', moduleName )
    g%geocV2(1:size(v,1),1:size(v,2)) => g%geocV1
    g%geocV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geocV1
    g%geocV3%v = v%v
  end subroutine Insert_Geoc_3

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:1) => g%geodV1
    g%geodV3(1:size(v,1),1:1,1:1) => g%geodV1
    g%geodV1%v = v%v
  end subroutine Insert_Geod_1

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:1) => g%geodV1
    g%geodV2%v = v%v
  end subroutine Insert_Geod_2

  ! Insert geodetic height, meters above sea level
  ! This assumes you already have zeta, and have used a hydrostatic model to
  ! compute geodetic height.
  ! If you already have geocentric height, use Fill_Geod.
  subroutine Insert_Geod_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_geod), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%geodV1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%geodV1', moduleName )
    g%geodV2(1:size(v,1),1:size(v,2)) => g%geodV1
    g%geodV3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%geodV1
    g%geodV3%v = v%v
  end subroutine Insert_Geod_3

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_1 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:1) => g%zeta1
    g%zeta3(1:size(v,1),1:1,1:1) => g%zeta1
    g%zeta1 = v
  end subroutine Insert_Zeta_1

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_2 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:,:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:1) => g%zeta1
    g%zeta2 = v
  end subroutine Insert_Zeta_2

  ! Insert Zeta
  ! This assumes you already have geocentric or geodetic height, and have used
  ! a hydrostatic model to compute zeta.
  ! If the grid is stacked and geocentric, zeta doesn't make sense!
  subroutine Insert_Zeta_3 ( G, V )
    class(geolocation_t), intent(inout) :: G
    type(v_zeta), intent(in) :: V(:,:,:)
    integer :: Stat
    allocate ( g%zeta1(size(v)), stat=stat )
    call test_allocate ( stat, 'G%zeta1', moduleName )
    g%zeta2(1:size(v,1),1:size(v,2)) => g%zeta1
    g%zeta3(1:size(v,1),1:size(v,2),1:size(v,3)) => g%zeta1
    g%zeta3 = v
  end subroutine Insert_Zeta_3

  ! Delete geocentric latitudes and geocentric vertical coordinates
  subroutine Delete_Geoc ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%geocLat1) ) deallocate ( g%geocLat1 )
    nullify ( g%geocLat2, g%geocLat3 )
    if ( associated(g%geocV1) ) deallocate ( g%geocV1 )
    nullify ( g%geocV2, g%geocV3 )
  end subroutine Delete_Geoc

  ! Delete geodetic latitudes and geodetic vertical coordinates
  subroutine Delete_Geod ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%geodV1) ) deallocate ( g%geodV1 )
    nullify ( g%geodV2, g%geodV3 )
    if ( associated(g%zeta1) ) return ! Need to keep lat
    if ( associated(g%geodLat1) ) deallocate ( g%geodLat1 )
    nullify ( g%geodLat2, g%geodLat3 )
  end subroutine Delete_Geod

  ! Delete geodetic latitudes and zeta
  subroutine Delete_Zeta ( G )
    class(geolocation_t), intent(inout) :: G
    if ( associated(g%zeta1) ) deallocate ( g%zeta1 )
    nullify ( g%zeta2, g%zeta3 )
    if ( associated(g%geodV1) ) return ! Need to keep lat
    if ( associated(g%geodLat1) ) deallocate ( g%geodLat1 )
    nullify ( g%geodLat2, g%geodLat3 )
  end subroutine Delete_Zeta

  ! Delete ECR coordinates
  subroutine Delete_ECR ( G )
    class(geolocation_t), intent(inout) :: G
    call g%destroy_g_p1
    nullify ( g%P2, g%P3 )
  end subroutine Delete_ECR

! impure elemental &
  subroutine Destroy_G ( G )
    type(geolocation_t), intent(inout) :: G
    integer :: Stat
    deallocate ( g%lon1, stat=stat )
    call test_deallocate ( stat, 'lon1', moduleName )
    deallocate ( g%geocLat1, stat=stat )
    call test_deallocate ( stat, 'geocLat1', moduleName )
    call deallocate_test ( g%phi1, 'geocLat1', moduleName )
    deallocate ( g%geodLat1, stat=stat )
    call test_deallocate ( stat, 'geodLat1', moduleName )
    deallocate ( g%geocV1, stat=stat )
    call test_deallocate ( stat, 'geocV1', moduleName )
    deallocate ( g%geodV1, stat=stat )
    call test_deallocate ( stat, 'geodV1', moduleName )
    deallocate ( g%zeta1, stat=stat )
    call test_deallocate ( stat, 'zeta1', moduleName )
    call g%destroy_g_p1
    nullify ( g%lon2, g%lon3, g%geocLat2, g%geocLat3, g%geodLat2, g%geodLat3 )
    nullify ( g%phi2, g%phi3, g%geocV2, g%geocV3, g%geodV2, g%geodV3 )
    nullify ( g%zeta2, g%zeta3, g%p2, g%p3 )
  end subroutine Destroy_G

  subroutine Destroy_G_P1 ( G )
    class(geolocation_t), intent(inout) :: G
    integer :: S, Stat
    if ( associated(g%p1) ) then
      s = size(g%p1) * storage_size(g%p1) / 8
      deallocate ( g%p1, stat=stat )
      call test_deallocate ( stat, moduleName, 'P1', s )
    end if
  end subroutine Destroy_G_P1

! impure elemental &
  subroutine Explicit_Destroy_G ( Not_Used )
    class(geolocation_t), intent(out) :: Not_Used ! Intent(out) causes Destroy_G
  end subroutine Explicit_Destroy_G

!=============================================================================
!--------------------------- end bloc --------------------------------------
  logical function not_used_here()
  character (len=*), parameter :: IdParm = &
       "$Id$"
  character (len=len(idParm)) :: Id = idParm
    not_used_here = (id(1:1) == ModuleName(1:1))
    print *, Id ! .mod files sometimes change if PRINT is added
  end function not_used_here
!---------------------------------------------------------------------------

end module Geolocation_m

! $Log$
! Revision 2.7  2016/10/17 23:56:33  vsnyder
! Remove unused USE
!
! Revision 2.6  2016/09/23 01:49:58  vsnyder
! All the QTM stuff is in QTM_Tree instead of here
!
! Revision 2.5  2016/03/25 00:45:25  vsnyder
! Change type of Lon components from real(rg) to type(lon_t).  Change type
! of GeodLat components from real(rg) to type(geodLat_t).  Change type of
! GeocV components from real(rg) to type(v_geoc).  Change type of GeodV
! components from real(rg) to type(v_geod).  Change type of Zeta
! components from real(rg) to type(v_zeta).  Need to allocate these guys
! using an allocate statement, and then use test_allocate, and similarly
! for deallocating them.
!
! Revision 2.4  2016/02/26 02:02:00  vsnyder
! Make Coeff_t and QTM_tree_t public.  Add QTM_Geoc, QTM_Geod and QTM_Lats
! components.  Spiff some comments.
!
! Revision 2.3  2016/01/26 19:55:21  vsnyder
! Attach QTM
!
! Revision 2.2  2016/01/23 02:47:33  vsnyder
! Use geolocation types and type-bound procedures from Geolocation_0
!
! Revision 2.1  2015/11/14 18:02:37  vsnyder
! Initial commit
!
