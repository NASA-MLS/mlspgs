! Copyright 2005, by the California Institute of Technology. ALL
! RIGHTS RESERVED. United States Government Sponsorship acknowledged. Any
! commercial use must be negotiated with the Office of Technology Transfer
! at the California Institute of Technology.

! This software may be subject to U.S. export control laws. By accepting this
! software, the user agrees to comply with all applicable U.S. export laws and
! regulations. User has the responsibility to obtain export licenses, or other
! export authority as may be required before exporting such information to
! foreign countries or providing access to foreign persons.

! $Id$

! ------------------------------------------------------------------------------
! Part of l3ascii, used for r4 and r8 versions of routine of this name
! Bugs and gotchas:
! we treat the case of seasonally cyclic data in a brittle and tricky way
! We append an extra "December" before the start of the year 
! and an extra "January" after the end
! Obviously bogus if the noDates /= 12

! Better would be to create a new Hunt and a new Interpolate procedure
! capable of coping with cyclic data
logical :: DEEBUG
integer :: gdate1, gdate2    ! grid dates corresponding to cyclic dates
logical :: seasonalCycle     ! If true, our field data is for no particular year
logical, parameter :: WARNIFNOT12MONTHS = .false.
logical, parameter :: WARNIFDATESOUTSIDERANGE = .false.
! Executable
DEEBUG = .false.
if ( present(debug) ) DEEBUG = debug
nullify ( tmpalt, tmpdate )

! --- Set default values for all optional parameters
if ( present(lat) ) then
  inlat = lat
else
  inlat = 30.0
end if

if ( present(pressure) ) then
  inpressure = pressure
else
  inpressure = 10.0
end if

if ( present(lon) ) then
  inlon = lon
else
  inlon = 0.0
end if

if ( present(sza) ) then
  insza = sza
else
  insza = 30.0
end if

if ( present(lst) ) then
  inlst = lst
else
  inlst = 12.0
end if

if ( present(date) ) then
  indate = date
else
  indate = 15768000.0 ! This should be June (ish)
end if

! OK, that's the optional arguments sorted. 
! Now, we have to find which two indices the chosen value lies between
! for each of the six values.
call ilocate ( real(field%lats, r8), inlat, ilat1, ilat2 )
call ilocate ( real(field%lons, r8), inlon, ilon1, ilon2 )
call ilocate ( real(field%szas, r8), insza, isza1, isza2 )
call ilocate ( real(field%lsts, r8), inlst, ilst1, ilst2 )
! We can't interpolate dates and prssures as they are. We construct
! a mean date and a log pressure
call allocate_test ( tmpalt, field%noHeights, 'tmpalt', moduleName )

! Now think about cases when the gridded date is descriptive of no
! particular year, i.e. it is seasonally cyclic

! What we must do is to construct the following artificial year:
! Dec Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan
! For 14 months in all
! We will assume that either there is no seasonal cycle at all, in which
! case the number of dates is 1, or else that grid supplies the 12 months
! Jan - Dec

! Actually, what we do would still work even if the grid supplies, e.g., only
! every 2nd month Feb, Apr, Jun, Aug, Oct, Dec
! so we will disable the warning message below
if ( field%noYear .and. field%noDates > 1 ) then
  if ( field%noDates /= 12 .and. WARNIFNOT12MONTHS ) &
    & call MLSMessage ( MLSMSG_Warning, ModuleName, 'interpolating grid ' // &
    & trim(field%description) // ' is seasonally cyclic, but isnt 12 months' )
  ! Subtract the year information from indate.
  ! Note this (temporarily!?) brushes over issues to do with leap years.
  seasonalCycle = .true.
  inDate = modulo ( inDate, 60.0_r8*60.0*24.0*365.25 )
  call allocate_test ( tmpdate, field%noDates + 2, 'tmpdate', moduleName )
  tmpdate(2:field%noDates + 1) = (field%dateStarts+field%dateEnds)/2.0
  tmpdate(1) = tmpdate(field%noDates + 1) - 60.0_r8*60.0*24.0*365
  tmpdate(field%noDates + 2) = tmpdate(2) + 60.0_r8*60.0*24.0*365
else
  seasonalCycle = .false.
  call allocate_test ( tmpdate, field%noDates, 'tmpdate', moduleName )
  tmpdate = (field%dateStarts+field%dateEnds)/2.0
  if ( field%noYear ) inDate = modulo ( inDate, 60.0_r8*60.0*24.0*365.25 )
end if

if ( any(field%heights <= 0._rgr) ) then
  tmpalt = field%missingValue
    call MLSMessage ( MLSMSG_Warning, ModuleName, 'interpolating grid ' // &
      & trim(field%description) // ' contains negative or 0 values' )
else
  tmpalt = -log10(field%heights)
endif

if ( inpressure <= 0._rgr ) then
  inalt = field%missingValue
  call outputNamedValue( 'Warning--input pressure ' // &
    & ' is ', inPressure, advance='yes' )
else
  inalt = -log10(inpressure)
endif
call ilocate ( tmpdate, indate, idate1, idate2 )
if ( DEEBUG ) then
  call outputNamedValue( 'idate1, idate2', (/idate1, idate2/) )
endif
! Something would have to go seriously wrong for the next to occur
if ( WARNIFDATESOUTSIDERANGE .and. &
  & (idate2 < 1 .or. idate1 > size(field%field, 6) ) &
  & ) then
  call outputNamedValue( 'idate1, idate2', (/idate1, idate2/) )
  call outputNamedValue ( 'shape(field)', shape(field%field) )
  if ( present(date) ) call outputNamedValue ( 'Date', Date )
  call outputNamedValue ( 'inDate', inDate )
  call outputNamedValue ( 'tmpdate', tmpdate )
  call outputNamedValue ( 'noYear', field%noYear )
  call Dump( field%dateStarts, 'field%dateStarts' )
  call Dump( field%dateEnds, 'field%dateEnds' )
  call MLSMessage ( MLSMSG_Warning, ModuleName, &
    & 'The date index is out of its allowed range' )
endif
call ilocate ( tmpalt, inalt, ialt1, ialt2 )
! We now know that the desired point is inside the 6-D hypercuboid 
! bin of the array field%field(ialt1:ialt2, ilat1:ilat2, .......)
! Time to do the actual interpolation. Yuck. 
! There are up to 2^6=64 values
! to be taken into account. 

! Lets try allocating a cube of the right shape.
if ( ialt1 == ialt2 ) then !test whether the altitude is between two of the 
  hcshape(1) = 1       ! grid values (so we interpolate) or if there
else                   ! is only one value (so we just return that value)
  hcshape(1) = 2
end if
if ( ilat1 == ilat2 ) then
  hcshape(2) = 1
else
  hcshape(2) = 2
end if
if ( ilon1 == ilon2 ) then
  hcshape(3) = 1
else
  hcshape(3) = 2
end if
if ( ilst1 == ilst2 ) then
  hcshape(4) = 1
else
  hcshape(4) = 2
end if
if ( isza1 == isza2 ) then
  hcshape(5) = 1
else
  hcshape(5) = 2
end if
if ( idate1 == idate2 ) then
  hcshape(6) = 1
else
  hcshape(6) = 2
end if


if ( DEEBUG ) then
  call outputNamedValue( 'hyper cube shape', hcshape )
  call dump( (/indate/),  'indate', format='(1pe12.3)' )
  call dump(  tmpdate,  'tmpdate', format='(1pe12.3)' )
endif
! Allocate a 6-D hypercube that our point lies in. Some of the 
! dimensions may be "collapsed" 
allocate ( hcube(1:hcshape(1),1:hcshape(2),1:hcshape(3), &
  & 1:hcshape(4),1:hcshape(5),1:hcshape(6)) )
! Copy data into hypercube
if ( seasonalCycle .and. idate1 /= idate2 ) then
  ! We need the following trickery:
  !   idate     1   2   3  .. 14
  ! grid date   12  1   2  ..  1
  ! This translates to
  ! gdate = 1 + mod(idate-2, noDates)
  gdate1 = 1 + mod(idate1+field%noDates-2, field%noDates)
  gdate2 = 1 + mod(idate2+field%noDates-2, field%noDates)
  if ( DEEBUG ) then
    call outputNamedValue( 'gdate1, gdate2', (/gdate1, gdate2/) )
  endif
  hcube(:,:,:,:,:,1) = field%field(ialt1:ialt2, ilat1:ilat2, ilon1:ilon2, &
    & ilst1:ilst2,isza1:isza2, gdate1)
  hcube(:,:,:,:,:,2) = field%field(ialt1:ialt2, ilat1:ilat2, ilon1:ilon2, &
    & ilst1:ilst2,isza1:isza2, gdate2)
else
  hcube = field%field(ialt1:ialt2, ilat1:ilat2, ilon1:ilon2, &
    & ilst1:ilst2,isza1:isza2, idate1:idate2)
endif
! If any of these are 'missing' then the result is missing
if ( any ( hcube >= nearest ( field%missingValue, -1.0 ) .and. &
  &        hcube <= nearest ( field%missingValue,  1.0 ) ) ) then
  outVal = field%missingValue
else

  ! Now we interpolate along each of the axes where this is needed
  ! Reduce 6-d to 5-d
  if ( hcshape(6) == 2 ) then !Interpolate in date 
    hcube(:,:,:,:,:,1) = hcube(:,:,:,:,:,1) + &
      &  (hcube(:,:,:,:,:,2) - hcube(:,:,:,:,:,1)) * &
      &  (indate-tmpdate(idate1)) / (tmpdate(idate2)-tmpdate(idate1))
    if ( DEEBUG ) call outputNamedValue( 'eps', &
      & (indate-tmpdate(idate1)) / (tmpdate(idate2)-tmpdate(idate1)) &
      & )
  else
    if ( DEEBUG ) call output( 'No need to interpolate dates', advance='yes' )
  endif
  ! Reduce  5-d to 4d
  if ( hcshape(5) == 2 ) then !Interpolate in local Solar zenith ang  SZA
    hcube(:,:,:,:,1,1) = hcube(:,:,:,:,1,1) + &
      &  (hcube(:,:,:,:,2,1) - &
      &  hcube(:,:,:,:,1,1)) * &
      &  (insza-field%szas(isza1)) / &
      &  (field%szas(isza2)-field%szas(isza1))
  end if

  ! Reduce  4-d to 3d
  if ( hcshape(4) == 2 ) then !Interpolate in local solar time
    hcube(:,:,:,1,1,1) = hcube(:,:,:,1,1,1) + &
      &  (hcube(:,:,:,2,1,1) - &
      &  hcube(:,:,:,1,1,1)) * &
      &  (inlst-field%lsts(ilst1)) / &
      &  (field%lsts(ilst2)-field%lsts(ilst1))
  end if

  ! Reduce  3-d to 2d
  if ( hcshape(3) == 2 ) then !Interpolate in longitude
    hcube(:,:,1,1,1,1) = hcube(:,:,1,1,1,1) + &
      &  (hcube(:,:,2,1,1,1) - &
      &  hcube(:,:,1,1,1,1)) * &
      &  (inlon-field%lons(ilon1)) / &
      &  (field%lons(ilon2)-field%lons(ilon1))
  end if
  ! Reduce  2-d to 1d
  if ( hcshape(2) == 2 ) then !Interpolate in latitude

    hcube(:,1,1,1,1,1) = hcube(:,1,1,1,1,1) + &
      &  (hcube(:,2,1,1,1,1) - &
      &  hcube(:,1,1,1,1,1)) * &
      &  (inlat-field%lats(ilat1)) / &
      &  (field%lats(ilat2)-field%lats(ilat1))
  end if

  ! Reduce  1-d to 0d
  if ( hcshape(1) == 2 ) then !interpolate in altitude
    hcube(1,1,1,1,1,1) = hcube(1,1,1,1,1,1) + &
      &  (hcube(2,1,1,1,1,1) - &
      &  hcube(1,1,1,1,1,1)) * &
      &  (inalt-tmpalt(ialt1)) / &
      &  (tmpalt(ialt2)-tmpalt(ialt1))
  end if
  outval = hcube(1,1,1,1,1,1)
end if
call deallocate_test ( tmpdate, 'tmpdate', moduleName )
call deallocate_test ( tmpalt, 'tmpalt', moduleName )
deallocate ( hcube )
! $Log$
! Revision 2.10  2019/01/17 16:16:06  pwagner
! Last commit re. idate1, idate2 was probably an error
!
! Revision 2.9  2017/07/10 18:24:32  pwagner
! Try to catch range errors for idate1, idate2
!
! Revision 2.8  2014/05/28 21:57:19  pwagner
! Prevent defining hcube for index 2 when idate1 == idate2
!
! Revision 2.7  2012/03/06 19:31:22  pwagner
! Fix bug affecting seasonal cyclic symmetric grids
!
! Revision 2.6  2007/09/27 21:53:59  pwagner
! Uses MLSMessage to warn instead of output
!
! Revision 2.5  2007/03/07 01:22:46  pwagner
! Side-step another log of non-positive args case lf6.2 caught
!
! Revision 2.4  2007/03/02 18:16:00  pwagner
! Dont take log if heights contains missingValues; only lf6.2 complained
!
! Revision 2.3  2005/06/22 17:44:42  pwagner
! Reworded Copyright statement, moved rcs id
!
! Revision 2.2  2003/02/28 02:26:59  livesey
! Added handling of missing data.
!
! Revision 2.1  2003/02/19 19:09:42  pwagner
! First commit
!
